# 分治

分治即**分而治之**，我们可以将分治拆分一下进行解读。一个是分，另外一个是治。

- 分。 将一个规模为 N 的问题分解为若干个规模较小的子问题
- 治。 根据子问题的解求原问题。

从上面的描述，我们可以理出几个关键点。

- 一定是先分再治。
- 治一定是利用分的结果进行的，也就是说治依赖分。

因此一般我们可以：

```
将一个规模为 N 的问题分解为 K 个规模较小的子问题，并根据子问题的解求原问题。这些子问题相互独立且与原问题性质相同，求出子问题的解，就可得到原问题的解。
```

那么就可以尝试使用分治法。

说起来很简单，但事实并非如此。分治是一种难度很大的思想，并且 LC 上题目并不多见。因此我的建议是大家透过几道经典的分支问题，好好研究，最后结合我们给出的每日一题题目进行联系，这样应付大多数面试是不成问题的。

## 适用场景

一般题目具有以下 3 个特征，就可以考虑使用分治算法

1. 如果问题可以被分解为若干个规模较小的相同问题。（动态规划也是？那有什么区别？）

2. 这些被分解的问题的结果可以进行合并。（分治的核心标志）

3. 这些被分解的问题是相互独立的，不包含重叠的子问题（动态规划也是？那有什么区别？）

可以看出，分治和动态规划有很深的联系。另外分治和其他思想，比如二分也颇有原因，因为本质上**二分就是一种只有分没有治的分治**。

## 解题步骤

![分治](https://img-blog.csdnimg.cn/20200823212452121.png)

1. 将原问题分解至，达到求解边界的结构相同互相独立的子问题。（这是重点，也是难点。实际操作并不容易想到）
2. 对所有的子问题进行求解。
3. 将所有子问题的解进行合并，从而得到原问题。

相比于 2 和 3，1 既是重点也是难点。很多题目其实很难看出来可以使用分治来解决的。也无法通过几句话就讲清楚的，我认为分治是比**动态规划更难**的思想。因为分治动态规划只需要关注局部即可，而分治则需要关注全体，因为你需要对全体进行**分和治的操作**。

上面是分治做题的指导思想，对你做具体题目实际上并没有什么帮助。接下来我们来一点实操技巧。

## 实操技巧

这里给出几个解决分治问题的几个分治技巧给大家。

1. 思考子问题的求解边界(问题缩小至什么规模时可以求解)，使用函数来定义问题。（和动态规划类似）
2. 思考如果将子问题的解进行合并。（假设子问题已经计算好了，我们如何合并？）
3. 思考编码思路（一般利用递归）

我们以经典的归并排序算法为例，讲解一下如下使用这几个技巧。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200823220453220.png)

如果，我们需要对一个数组进行排序。这个问题可以进行分解成独立子问题么？

1. 显然如果规模缩小到只有一个元素时，问题就变得很容易解了。（实操技巧 1）

接下来，我们思考：如果两个子数组（子问题）已经有序，我们如何将其合并？

2. 然后我们发现将子问题的解两两之间进行合并其实就是合并两个有序数组（使用[双指针](https://github.com/leetcode-pp/91alg-1/blob/master/basic-05.md)轻松解决）（实操技巧 2）

3. 于是，我们可以定义问题函数为 f(l, r) 为对数组 [l,r] 区间进行排序。接下来逐步分解到对单个数（分）进行求解（单个数天然有序），之后使用合并两个有序数组的技巧（治）来完成，这样逐步**治** 即可得到答案。

### 代码（JS）

```js
var sortArray = function (nums) {
  var len = nums.length;
  if (len < 2) {
    return nums;
  }
  var middle = parseInt(len / 2),
    left = nums.slice(0, middle),
    right = nums.slice(middle);
  return merge(sortArray(left), sortArray(right));
};

function merge(left, right) {
  let ans = [];
  let leftPoint = (rightPoint = 0);
  let leftLen = left.length,
    rightLen = right.length;
  while (leftPoint < leftLen && rightPoint < rightLen) {
    if (left[leftPoint] < right[rightPoint]) {
      ans.push(left[leftPoint]);
      leftPoint++;
    } else {
      ans.push(right[rightPoint]);
      rightPoint++;
    }
  }
  return ans.concat(
    leftPoint < leftLen ? left.slice(leftPoint) : right.slice(rightPoint)
  );
}
```

时间复杂度为 $O(nlogn)$，空间复杂度是 $O(n)$ （可通过原地交换优化到 $O(1)$）

## 分治和二分的异同

分治和二分其实还是有点像的。只不过二分只对问题进行**分**，分完直接舍弃。而分治不仅需要对问题进行分解，而且需要对问题的多个问题进行**治**。

分治和动态规划都涉及到问题的问题，并且都需要保证子问题不重不漏。那么两者有啥不同呢？动态规划是**通过递推和选择进行转移，从特殊推广到一般**。而分治也可能涉及到选择，比如快速选择算法就是一个分治算法。那它俩不就更一样了吗？我觉得真的挺像的，只不过有一点两者有很大的不同。那就是**动态规划解决的问题往往伴随重叠子问题**（因为不重叠没必要动态规划），而分治则不是。

## 总结

如果一个问题可以被分解为若干个**不重叠**的独立子问题，并且子问题可以推导出原问题。我们就可以对问题进行定义，并使用分治来解决。具体地，我们先对问题进行分解（可以借助递归完成），接下来对问题的解进行合并（通常结合其他基础算法知识）即可。

分治是一种很难掌握且考察相对比较少的问思想。另外它和二分，动态规划等其他专题渊源颇深，大家可以结合起来进行理解。

通过我们给出的经典例题，大家可以感受一下分治和**二分以及动态规划**的异同，这可以很好地帮助你学习分治算法。

## 练习题

最后推荐几道题帮助大家理解和运用分治思维。

- 手写堆
- 手写线段树
- 归并排序

- [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

- [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)
