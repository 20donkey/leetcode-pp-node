## 题目地址(347. 前 K 个高频元素)

https://leetcode-cn.com/problems/top-k-frequent-elements/

## 入选理由

- 统计频率是哈希表的一个应用。当然如果数据范围小，可以考虑使用数组，理论性能更好（复杂度不变）
- 推荐大家和今天的力扣每日一题结合练习。https://leetcode-cn.com/problems/degree-of-an-array/ 那道题考察了一个哈希表记录最近和最远位置的点，这个考点也很常见。

## 题目描述

```
给定一个非空的整数数组，返回其中出现频率前  k  高的元素。
示例 1:


输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]


示例 2:


输入: nums = [1], k = 1
输出: [1]


提示：

- 你可以假设给定的  k  总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
- 你的算法的时间复杂度必须优于 O(n log n) , n  是数组的大小。
- 题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
- 你可以按任意顺序返回答案。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/top-k-frequent-elements
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

```

## 标签

- 堆
- 排序
- 哈希表

## 难度

- 中等

## 前置知识

- 哈希表
- 堆排序
- 快速选择


## 思路

直接根据题意，可以把问题化解两个小问题

- 计算每个数的频次
- 在生成频次里取前 K 大的

对频次计算的话，我们可以采用哈希表, key 为列表的数，value 为出现的频次

生成频次里取 K 大的，也就是我们熟悉 TOP K 问题，通过通过以下方式求取

1. 排序，取前 K 大的
2. 建堆
3. 快速选择


### 思路 - 哈希表+桶排序

1. 哈希表记录数值频次
2. 从最后一个桶开始遍历直到取出K个数

``` java {9-10,19-25}
class Solution {

    public int[] topKFrequent(int[] nums, int k) {

        List<Integer> res = new LinkedList<>();
        List<Integer>[] bucket = new List[nums.length + 1];
        Map<Integer, Integer> counter = new HashMap<>();
        
        for (int num: nums)
            counter.put(num, counter.getOrDefault(num, 0) + 1);
            
        for (Map.Entry<Integer, Integer> entry: counter.entrySet()) {
            int val = entry.getValue();
            if (bucket[val] == null)
                bucket[val] = new LinkedList<>();
            bucket[val].add(entry.getKey());
        }
        
        int kNum = 0;
        for (int i = bucket.length - 1; i >= 0; i--)
            if (bucket[i] != null) 
                for (int elem: bucket[i]){
                    
                    res.add(elem);
                    kNum++;
                }     

        int[] ret = new int[k];
        for (int i = 0; i < ret.length; i++)
            ret[i] = res.get(i);

        return ret;
    }
}
```

- 时间复杂度: $O(N)$, $N$为数组长度
- 空间复杂度: $O(N)$, $N$为数组长度

### 思路 - 哈希表+堆排序

1. 建立一个 size 为 K 的小顶堆
2. 对每个频次 C ，与堆顶 T 比较，如果 C > T, C 替换 T，并维持小顶堆性质。

```c++ {10-19}
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int,int> counts;
        // 计算频次
        for(int i : nums) counts[i]++;
        // 最小堆
        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;
        // 堆中元素为 [频次，数值] 元组，并根据频次维护小顶堆特性
        for(auto it : counts) {
            if (q.size() != k) {
                q.push(make_pair(it.second, it.first));
            } else {
                if (it.second > q.top().first) {
                    q.pop();
                    q.push(make_pair(it.second, it.first));
                }
            }
        }
        vector<int> res;
        while(q.size()) {
            res.push_back(q.top().second);
            q.pop();
        }
        return vector<int>(res.rbegin(), res.rend());
    }
};
```

- 时间复杂度: $O(N \* logK)$, $N$为数组长度
- 空间复杂度: $O(N)$, $N$为数组长度，主要为哈希表开销

### 思路 - 快速选择

快速排序变种，快速排序的核心是选出一个拆分点，将数组分为 `left`, `right` 两个 part，对两个 part 内的元素分治处理，时间是 O(n \* logn), 但是注意，我们只是需要找出前 K 个数，并不需要其有序，所有通过拆分出 K 个数，使得前 K 个数都大于后面 n - k 个数即可。

和快速排序的唯一不同是，快速选择每次不会递归访问 pivot 两侧，而是仅访问一侧。

和快速排序一样，最坏的情况时间复杂度是平方。这和 pivot 的选择有关，因此实际应用中更多的是检测到数组相对无序才会使用该算法。

代码

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {
  const counts = {};
  for (let num of nums) {
    counts[num] = (counts[num] || 0) + 1;
  }
  let pairs = Object.keys(counts).map((key) => [counts[key], key]);

  select(0, pairs.length - 1, k);
  return pairs.slice(0, k).map((item) => item[1]);

  // 快速选择
  function select(left, right, offset) {
    if (left >= right) {
      return;
    }
    const pivotIndex = partition(left, right);
    console.log({ pairs, pivotIndex });
    if (pivotIndex === offset) {
      return;
    }

    if (pivotIndex <= offset) {
      select(pivotIndex + 1, right, offset);
    } else {
      select(left, pivotIndex - 1);
    }
  }

  // 拆分数组为两个part
  function partition(left, right) {
    const [pivot] = pairs[right];
    let cur = left;
    let leftPartIndex = left;
    while (cur < right) {
      if (pairs[cur][0] > pivot) {
        swap(leftPartIndex++, cur);
      }
      cur++;
    }
    swap(right, leftPartIndex);
    return leftPartIndex;
  }

  function swap(x, y) {
    const term = pairs[x];
    pairs[x] = pairs[y];
    pairs[y] = term;
  }
};
```

- 时间复杂度: $O(N)$, 最坏能到 $O(N^2)$
- 空间复杂度: $O(N)$
