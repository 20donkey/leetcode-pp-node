## 题目地址（Number of Operations to Decrement Target to Zero）

https://binarysearch.com/problems/Number-of-Operations-to-Decrement-Target-to-Zero

## 入选理由

1. 这道题太常见了，以至于力扣就有一个类似的。https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards/

## 标签

- 滑动窗口

## 难度

- 中等

## 题目描述

You are given a list of positive integers nums and an integer target. Consider an operation where we remove a number v from either the front or the back of nums and decrement target by v.

Return the minimum number of operations required to decrement target to zero. If it's not possible, return -1.

Constraints

n ≤ 100,000 where n is the length of nums
Example 1
Input
nums = [3, 1, 1, 2, 5, 1, 1]
target = 7
Output
3
Explanation
We can remove 1, 1 and 5 from the back to decrement target to zero.

Example 2
Input
nums = [2, 4]
target = 7
Output
-1
Explanation
There's no way to decrement target = 7 to zero.

## 前置知识

- 二分法
- 滑动窗口

## 二分法

### 思路

这道题的意思是给你一个数组，你只可以移除数组两端的数。求最小移除次数，使得移除的数字和为 target。

我们可以反向思考，删除和为 target 的若干数字等价于保留若干和为 sum(A) - target 的数。这样问题就转化为 **求连续子数组和为 sum(A) - target 的最长子数组**。这种问题可以使用滑动窗口来解决。

> 注意抽象后的问题有“连续”关键字，就应该想到可能会用到滑动窗口优化。具体能不能用再根据题目信息做二次判断。

### 代码

代码支持：Python3

Python3 Code:

```py
class Solution:
    def solve(self, A, target):
        if not A and not target: return 0
        target = sum(A) - target
        ans = len(A) + 1
        i = t = 0

        for j in range(len(A)):
            t += A[j]
            while i <= j and t > target:
                t -= A[i]
                i += 1
            if t == target: ans = min(ans, len(A) - (j - i + 1))
        return -1 if ans == len(A) + 1 else ans
```

**复杂度分析**

令 n 为数组长度。

- 时间复杂度：$O(n)$
- 空间复杂度：1

力扣的小伙伴可以[关注我](https://leetcode-cn.com/u/fe-lucifer/)，这样就会第一时间收到我的动态啦~

以上就是本文的全部内容了。大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。 目前已经 40K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。
