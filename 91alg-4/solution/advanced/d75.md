# 28 实现 strStr()-BF&RK

## 入选理由

1. 字符串匹配问题经典中的经典，本次专题不要求深度，要求掌握即可
2. 一题两做，本次要求大家用 BF 和 RK 两种方法 AC

## 题目地址

https://leetcode-cn.com/problems/implement-strstr/

## 题目描述

```
实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

输入: haystack = "hello", needle = "ll"
输出: 2
示例 2:

输入: haystack = "aaaaa", needle = "bba"
输出: -1
说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。
```

## 前置知识

- 滑动窗口
- 字符串
- Hash 运算

## 暴力法

### 思路

该题基本上就是字符串匹配问题的入门，选这个题的原因也很简单，一般 KMP&RK 算法出现在面试中的频率相对较低，因此不需要过分考察深度，只需要掌握该算法基本即可。该题稍微注意一下的地方就是待匹配串可能多个符合模式串的子串，我们只需要返回第一次匹配成功的位置即可。

### 代码

代码支持： Python3

Python3 Code：

```python
class Solution:
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        lenA, lenB = len(haystack), len(needle)
        if not lenB:
            return 0
        if lenB > lenA:
            return -1

        for i in range(lenA - lenB + 1):
            if haystack[i:i + lenB] == needle:
                return i
        return -1
```

**复杂度分析**

设：待匹配串长为$N$，模式串串长为$M$

- 时间复杂度: $O(NM)$
- 空间复杂度：$O(1)$

### 进阶

- 能否实现查找所有匹配成功的位置？

## RK（滚动哈希）

首先我们把 needle 用 hash 算法计算一次哈希值，接下来我们的目标就是在 haystack 中找到一个连续子串使得其哈希值也是 needle 计算出来的哈希值。

由于 haystack 和 needle 最多只有 26 个字符，因此我们可以用 26 进制进制编码。

比如 hi 就编码为 26 \* (ord('h') - ord('a')) + ord('i') - ord('a')， 这就是我们的哈希算法。

于是这个问题可以使用滑动窗口来解决。具体来说：

- 先计算出和 needle 长度一致的哈希值，也就是 haystack[:len(needle)] 的哈希值。
- 然后我们需要移动窗口，每次移动一格。 这样哈希值仅需要减去左侧移除窗口的值和右侧移入窗口的值即可。
- 滚动过程发现哈希值和 needle 的哈希值一致，则说明找到了，直接返回。
- 到最后都没有找到，则返回 -1。

这个算法也有一个比较形象的名字（滚动哈希）

### 思路

### 代码

代码支持： Java, Python3

Java Code:

```java
class Solution {

    int prime = 101;

    public int strStr(String haystack, String needle) {

        if (haystack == null || needle == null || haystack.length() < needle.length())
            return -1;

        int n = haystack.length(), m = needle.length();

        long pHashVal = initHash(needle, m);
        long tHashVal = initHash(haystack, m);

        for (int i = 0; i <= n - m; i++) {

            if (i > 0 && i <= n - m)
                tHashVal = recalHash(haystack, i - 1, i + m - 1, tHashVal, m);

            if (pHashVal == tHashVal && isEqual(haystack, needle, i))
                return i;
        }

        return -1;
    }

    public long initHash(String text, int end) {

        long hashVal = 0;

        for (int i = 0; i < end; i++)
            hashVal += text.charAt(i) * Math.pow(prime, i);

        return hashVal;
    }

    public long recalHash(String text, int oldIdx, int newIdx, long hashVal, int patternLength) {

        long newHash = hashVal - text.charAt(oldIdx);
        newHash /= prime;
        newHash += text.charAt(newIdx) * Math.pow(prime, patternLength - 1);

        return newHash;
    }

    public boolean isEqual(String text, String pattern, int tStart) {

        int end = tStart + pattern.length();
        int pStart = 0;

        while (tStart < end) {

            if (text.charAt(tStart) != pattern.charAt(pStart))
                return false;

            tStart++;
            pStart++;
        }

        return true;
    }
}
```

> 这里 Java 代码稍作解释一下，我这用个 101 的素数太小了，但是因为毕竟在刷题，不用设置过大，如果工程上使用还是要谨慎选取的。

Python3 Code:

```py
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if not haystack and not needle:
            return 0
        if not haystack or len(haystack) < len(needle):
            return -1
        if not needle:
            return 0
        hash_val = 0
        target = 0
        for i in range(len(haystack)):
            if i < len(needle):
                hash_val = hash_val * 26 + (ord(haystack[i]) - ord("a"))
                target = target * 26 + (ord(needle[i]) - ord("a"))
            else:
                hash_val = (
                    hash_val - (ord(haystack[i - len(needle)]) - ord("a")) * 26 ** (len(needle) - 1)
                ) * 26 + (ord(haystack[i]) - ord("a"))
            if i >= len(needle) - 1 and hash_val == target:
                return i - len(needle) + 1
        return 0 if hash_val == target else -1
```

**复杂度分析**

设：待匹配串长为$N$，模式串串长为$M$

- 时间复杂度：一般情况是$O(N+M)$
- 空间复杂度：$O(1)$
