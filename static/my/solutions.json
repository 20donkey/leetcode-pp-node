{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297935552","body":"### 思路\n\n套用加法模版\n\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n\n### 代码\n\n```js\nvar addToArrayForm = function (num, k) {\n    let n = num.length;\n    let i = n - 1;\n    let sum = 0;\n    let carry = 0;\n    let res = [];\n    while (i >= 0 || k !== 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n        sum = x + y + carry;\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10);\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if(carry) res.push(carry)\n    return res.reverse();\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299476563","body":"### 思路\n\nMath.min(s[i]到其左侧最近字符c,s[i]到其右侧最近字符c)\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = new Array(n).fill(0);\n\n  for (let i = 0, idx = -n; i < n; ++i) {\n      if (s[i] === c) {\n          idx = i;\n      }\n      ans[i] = i - idx;\n  }\n  console.log('ans ==>',ans)\n\n  for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n      if (s[i] == c) {\n          idx = i;\n      }\n      ans[i] = Math.min(ans[i], idx - i);\n  }\n  return ans;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)，其中 n 为字符串长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301563740","body":"### 思路\n\n用数组维护一个栈\n\n### 代码\n\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.arr = []\n  this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.arr.length < this.maxSize){\n    this.arr.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function(\n) {\n  if(this.arr.length === 0) return -1;\n  return this.arr.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const len = this.arr.length;\n  if(len < k){\n    this.arr = this.arr.map(item=> item+val)\n    return\n  }\n  for(let i= 0; i<k;i++){\n    this.arr[i] = this.arr[i]+val\n  }\n\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：increment为 O(n)，其中 n 为最大长度。\n+ 空间复杂度：O(n)，其中 n 为最大长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302881831","body":"### 思路\n\n使用栈维护当前【】进出\n\n### 代码\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n  let res = \"\"\n  let stack = [];\n  let multi = 0;\n  for(let  i = 0; i < s.length;i++){\n    const item = s[i];\n    const isNum = !isNaN(Number(item));\n    const isLBrackets = item === \"[\"\n    const isRBrackets = item === \"]\"\n    if(isNum){\n      multi = Number(`${multi}${item}`);\n    }else if(isLBrackets){\n      stack.push([multi,res])\n      res = \"\";\n      multi = 0\n    }else if(isRBrackets){\n      const stackItem = stack.pop();\n      res = stackItem[1] + res.repeat(stackItem[0])\n    }else{\n      res += item\n    }\n  }\n  return res\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397247","body":"### 思路\n\n因为要求用栈的原生操作，但又需要能拿到栈头元素，因此需要多使用一个数组来模拟队列\n\n### 代码\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack = [];\n  this.helpStack = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\n// 从队列首部移除元素\nMyQueue.prototype.pop = function () {\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\n// 返回队列首部的元素\nMyQueue.prototype.peek = function () {\n  const len = this.helpStack.length;\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack[len - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  if (this.stack.length || this.helpStack.length) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N 为栈中元素个数\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304700283","body":"### 思路\n\n借鉴单调栈思路 <https://lucifer.ren/blog/2020/11/03/monotone-stack/>\n\n### 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const temp = [];\n  for (let i = 0; i < arr.length; i++) {\n    let a = arr[i];\n    if (temp.length > 0 && temp[temp.length - 1] > a) {\n      const cur = temp[temp.length - 1];  // 保存临时最大值\n      while (temp && temp[temp.length - 1] > a) temp.pop();\n      temp.push(cur);\n    } else {\n      temp.push(a);\n    }\n  }\n  return temp.length;\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(n)，其中 n 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305003518","body":"### 思路\n\n寻找倒数第N位节点可以采用双指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0;\n  let start = head;\n  while (start) {\n    start = start.next;\n    count++\n  }\n  // 减少次数\n  k = k % count;\n  // 快指针先走\n  let fast = head;\n  let slow = head;\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res\n\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306537644","body":"### 思路\n\n化简为两节点的交换\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n var swapPairs = function(head) {\n  if(!head || !head.next) return head\n  let preNode = new ListNode();\n  preNode.next = head;\n  let now = head;\n  let res = head.next;\n  while(now && now.next){\n    let nextNode = now.next;\n    let temp = nextNode.next;\n\n    // 进行反转\n    now.next = temp;\n    nextNode.next = now;\n    preNode.next = nextNode;\n    preNode = now;\n    now = temp;\n  }\n  return res;\n\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1309652528","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\n var sortedListToBST = function(head) {\n  if(!head) return head;\n  return dfs(head,null)\n};\n\nfunction dfs(head,tail){\n  if(head === tail) return null\n  let fast = head;\n  let slow = head;\n  while(fast!==tail && fast.next!==tail){\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head,slow);\n  root.right = dfs(slow.next,tail);\n  return root\n}\n```\n\n### 复杂度\n\n+ 时间：o(nlogn)\n+ 空间：o(logn)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309672208","body":"### 思路\n\n双指针 a + c + b = b + c + a\n\n### 代码\n\n```js\n var getIntersectionNode = function(headA, headB) {\n  if(!headA || !headB) return null;\n  let a = headA;\n  let b = headB;\n  while(a !==b){\n    if(a === null){\n      a = headB;\n    }else if(b === null){\n      b = headA\n    }else{\n      a = a.next;\n      b = b.next;\n    }\n  }\n  return a\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311153769","body":"### 思路\n\n双指针 or 哈希\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\n var detectCycle = function(head) {\n  if (head === null) {\n      return null;\n  }\n  let slow = head, fast = head;\n  while (fast !== null) {\n      slow = slow.next;\n      if (fast.next !== null) {\n          fast = fast.next.next;\n      } else {\n          return null;\n      }\n      if (fast === slow) {\n          let ptr = head;\n          while (ptr !== slow) {\n              ptr = ptr.next;\n              slow = slow.next;\n          }\n          return ptr;\n      }\n  }\n  return null;\n};\n\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312519174","body":"### 思路\n\n双向链表+hashmap\n\n### 代码\n\n```js\nclass DoubleLinkedListNode {\n  constructor(key,value) {\n    this.key = key;\n    this.value = value;\n    this.prev = null;\n    this.next = null;\n  }\n}\nclass LRUCache {\n  constructor(capacity){\n    this.capacity = capacity;\n    this.hashmap = {}\n    this.useSize = 0;\n    this.dummyHead= new DoubleLinkedListNode(null,null);\n    this.dummyTail= new DoubleLinkedListNode(null,null);\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n  }\n\n  _isFull(){\n    return this.useSize === this.capacity;\n  }\n\n  _removeNode(node){\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n\n  _addToHead(node){\n    const head = this.dummyHead.next;\n    node.next = head;\n    node.prev = this.dummyHead;\n    this.dummyHead.next = node;\n    head.prev = node;\n  }\n\n  get(key){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      const removeNode = this._removeNode(node);\n      this._addToHead(removeNode);\n      return node.value;\n    }else{\n      return -1;\n    }\n  }\n\n  put(key,val){\n    if(this.hashmap[key]){\n      const node = this.hashmap[key];\n      node.value = val;\n      this._addToHead(this._removeNode(node)) \n    }else{\n      if(this._isFull()){\n        // 先获取最后一个\n        const node = this.dummyTail.prev;\n        this._removeNode(node);\n        delete this.hashmap[node.key];\n        this.useSize--;\n      }\n\n      const node = new DoubleLinkedListNode(key,val);\n      this.hashmap[key] = node;\n      this._addToHead(node)\n      this.useSize++\n    }\n  }\n}\n\n\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(n)\n+ 时间复杂度 O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312525247","body":"### 思路\r\n\r\n递归\r\n\r\n### 代码\r\n\r\n```js\r\n// 递归\r\n var maxDepth = function(root) {\r\n  if(!root) return 0;\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) +1 \r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n+ 时间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312955475","body":"### 思路\n\n1. 递归\n2. 前序和中序遍历结果可以确定一颗树\n\n### 代码\n\n```js\n var isSameTree = function(p, q) {\n    if(p === null && q === null) return true;\n  if(p && !q) return false;\n  if(!p && q) return false;\n  return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right , q.right)\n};\n\n\n// 前序&&中序\n\nvar isSameTree = function(p, q) {\n  const preOrderP = preOrder(p,[])\n  const preOrderQ = preOrder(q,[])\n  const middleOrderP = middleOrder(p,[])\n  const middleOrderQ = middleOrder(q,[])\n  return preOrderP.join(\" \") === preOrderQ.join(\" \") && middleOrderP.join(\" \") === middleOrderQ.join(\" \") \n};\n\nfunction preOrder(root,arr){\n  if(root === null){\n    arr.push(\" \")\n    return arr\n  }\n  arr.push(root.val);\n  preOrder(root.left, arr);\n  preOrder(root.right, arr);\n  return arr\n}\n\nfunction middleOrder(root,arr){\n  if(root === null){\n    arr.push(\" \")\n    return arr\n  }\n  preOrder(root.left, arr);\n  arr.push(root.val);\n  preOrder(root.right, arr);\n  return arr\n}\n```\n\n### 空间复杂度\n\n+ 时间复杂度：O(N)，其中 N 为树的节点数。\n\n+ 空间复杂度：O(h)，其中 h 为树的高度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315549039","body":"### 思路\n\n递归求解\n\n### 代码\n\n```js\nvar sumNumbers = function (root) {\n  const helper = (root, cur) => {\n    if (root === null) return 0;\n    cur = 10 * cur + root.val;\n    if (root.left === null && root.right === null) return cur;\n    return helper(root.left, cur) + helper(root.right, cur);\n  };\n  return helper(root, 0);\n};\n```\n\n### 复杂度\n\n令 n 为节点总数， h 为树的高度。\n\n+ 时间复杂度：O(n)\n\n+ 空间复杂度：O(h)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316200432","body":"### 思路\n\nBFS\n套路：使用 curLevel 和 nextLevel 进行分析\n\n### 代码\n\n```js\nvar findBottomLeftValue = function(root) {\n  if(!root) return root;\n  let curLevel = [root];\n  let res =root.val;\n  while(curLevel.length){\n    let nextLevel = [];\n    for(let i = 0; i< curLevel.length; i++){\n      const item = curLevel[i]\n      item.left && nextLevel.push(item.left);\n      item.right && nextLevel.push(item.right);\n    }\n    res = curLevel[0].val\n        curLevel = nextLevel;\n  }\n  return res;\n};\n```\n\n### 复杂度\n\n令 n 为节点总数\n\n+ 时间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318917549","body":"### 思路\n\n参考的题解，BFS\n\n### 代码\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\n var serialize = function(root) {\n    if(!root) return \"x\";\n    let queue = [root];\n    let res = []\n    while(queue.length){\n      let item = queue.shift();\n      if(item){\n        res.push(item.val);\n        queue.push(item.left);\n        queue.push(item.right)\n      }else{\n        res.push(\"x\")\n      }\n    }\n    return res.join(\",\")\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    if(data ===\"x\") return null;\n    const list = data.split(\",\");\n    const root = new TreeNode(list[0]);\n    const queue = [root];\n    let cursor = 1;\n    while(cursor < list.length){\n      const node = queue.shift();\n      const leftVal = list[cursor];\n      const rightVal = list[cursor+1];\n      if(leftVal!==\"x\"){\n        const leftNode = new TreeNode(leftVal);\n        node.left = leftNode;\n        queue.push(leftNode);\n      }\n      if(rightVal!==\"x\"){\n        const rightNode = new TreeNode(rightVal);\n        node.right = rightNode;\n        queue.push(rightNode);\n      }\n      cursor+=2;\n    }\n    return root;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```\n\n### 复杂度分析\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1321041396","body":"### 思路\n\n先通过DFS获取树每个节点的坐标，然后再根据要求进行排序\n\n### 代码\n\n```js\nvar verticalTraversal = function(root) {\n  const nodes = [];\n  dfs(root, 0, 0, nodes);\n  nodes.sort((tuple1, tuple2) => {\n      if (tuple1[0] !== tuple2[0]) {\n          return tuple1[0] - tuple2[0];\n      } else if (tuple1[1] !== tuple2[1]) {\n          return tuple1[1] - tuple2[1];\n      } else {\n          return tuple1[2] - tuple2[2];\n      }\n  });\n\n  const ans = [];\n  let lastcol = -Number.MAX_VALUE;\n  for (const tuple of nodes) {\n      let col = tuple[0], row = tuple[1], value = tuple[2];\n      if (col !== lastcol) {\n          lastcol = col;\n          ans.push([]);\n      }\n      ans[ans.length - 1].push(value);\n  }\n  return ans;\n}\n\nconst dfs = (node, row, col, nodes) => {\n  if (node === null) {\n      return;\n  }\n  nodes.push([col, row, node.val]);\n  dfs(node.left, row + 1, col - 1, nodes);\n  dfs(node.right, row + 1, col + 1, nodes);\n}\n\n\n```\n\n### 复杂度分析\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321042169","body":"### 思路\n\n使用一个map来帮忙\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n var twoSum = function(nums, target) {\n  const len = nums.length;\n  const map = new Map();\n  for(let i= 0; i <len; i++){\n    const cut = target-nums[i];\n    if(map.has(cut)){\n      return [map.get(cut),i]\n    }else{\n      map.set(nums[i],i)\n    }\n  }\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1326595680","body":"### 思路\n\n使用hashmap记录次数配合最小堆进行排序\n\n### 代码\n\n```js\nvar topKFrequent = function (nums, k) {\n  let n = nums.length;\n  let map = new Map();\n  for (let i = 0; i < n; i++) {\n    const item = nums[i];\n    const val = map.get(item);\n    if (map.has(item)) {\n      map.set(item, val + 1)\n    } else {\n      map.set(item, 1)\n    }\n  }\n\n  const res = [];\n  let len = 0;\n  map.forEach((value, key) => {\n    // 小于k个直接插入\n    if (len < k) {\n      res.push(key);\n      if (len === k - 1){\n        buildHeap(res, map, k)\n      }\n    } else {\n      // 多的先判断该值和堆顶的大小。\n      if (map.get(res[0]) < value) {\n        res[0] = key;\n        heapify(res,map,0,k);\n      }\n    }\n    len++\n  })\n\n\n  // 构建最大堆\n  function buildHeap(list, map, k) {\n    const last = Math.floor(k / 2);\n    for (let i = last; i >= 0; i--) {\n      heapify(list, map, i, k);\n    }\n  }\n\n  function swap(items, i, j) {\n    let temp = items[i]\n    items[i] = items[j]\n    items[j] = temp\n  }\n\n  // 排序\n  function heapify(list, map, i, heapSize) {\n    // if (i >= heapSize) return\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n    let min = i;\n    if (left < heapSize && map.get(list[left]) < map.get(list[min])) {\n      min = left;\n    }\n    if (right < heapSize && map.get(list[right]) < map.get(list[min])) {\n      min = right\n    }\n    if (min !== i) {\n      swap(list, min, i);\n      heapify(list,map, min, heapSize)\n    }\n\n  }\n\n  return res\n};\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1326684383","body":"### 思路\n\n使用hash表\n\n### 代码\n\n```js\nvar numberOfBoomerangs = function(points) {\n  let ans = 0;\n  for (const p of points) {\n      const cnt = new Map();\n      for (const q of points) {\n          const dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n          // console.log('dis,p,q ==>',dis,p,q)\n          cnt.set(dis, (cnt.get(dis) || 0) + 1);\n      }\n      for (const [_, m] of cnt.entries()) {\n          ans += m * (m - 1);\n      }\n  }\n  return ans;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n平方)，其中 n 为数组长度。\n+ 空间复杂度：O(n)，其中 n 为数组长度。\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1327035141","body":"### 思路\n\n双指针\n\n### 代码\n\n```js\nvar lengthOfLongestSubstring = function (s) {\n  if (!s) return s;\n  let start = 0;\n  let end = 0;\n  let max = 0;\n  let map = new Map();\n  for (let i = 0; i < s.length; i++) {\n    const cur = s[i];\n    if (map.has(cur)) {\n      const lastIndex = map.get(cur);\n      // 左指针的移动位置需要额外注意：\n      // 先找出重复字符的下一位，但要比当前索引大\n      // 如果 s[r] 曾在 [l, r] 滑动窗口中出现\n      // 就收缩滑动窗口左侧，把 l 指针移动到 s[r] 上次出现的位置 + 1\n      start = Math.max(lastIndex + 1, start);\n    }\n    map.set(cur, i);\n    max = Math.max(end - start + 1, max)\n    end = end + 1;\n  }\n  return max\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符长度。\n+ 空间复杂度：O(n)\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326692327","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```js\n var middleNode = function(head) {\n  if(!head) return head;\n  let newHead = head;\n  let quick = newHead;\n  let slow = newHead;\n  while(quick && quick.next){\n    quick = quick.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为链表长度。\n+ 空间复杂度：O(1)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328446731","body":"### 思路\n\n暴力法 & 双向队列\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\n var maxSlidingWindow = function(nums, k) {\n  let res = [];\n  for(let i = 0; i < nums.length - k+1; i++){\n    const curMax = cal(nums,i,i+k);\n    res.push(curMax)\n  }\n  return res\n};\n\nfunction cal(nums,start,end){\n  console.log('start,end ==>',start,end)\n  let max = nums[start];\n  for(let i= start; i < end; i++){\n    max = Math.max(nums[i],max)\n  }\n  return max;\n}\n\n\n\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n  // 前 k - 1 个数入队\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  // 滑动窗口\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums;\n  }\n\n  push(val) {\n    const nums = this.list;\n    // 保证数据从队头到队尾递减\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n    nums.push(val);\n  }\n\n  // 队头出队\n  shift(val) {\n    let nums = this.list;\n    if (nums[0] === val) {\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\nconsole.log(' ==>',maxSlidingWindow([1,3,-1,-3,5,3,6,7],3))\n```\n\n### 复杂度分析\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336161687","body":"### 思路\n\n学习一下优先队列的内部实现\n\n### 代码\n\n```js\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function (tasks) {\n  const queue = new MinPriorityQueue();\n  // 记录索引\n  tasks = tasks.map((task, index) => {\n    return {\n      index,\n      start: task[0],\n      time: task[1]\n    }\n  })\n  // 排序\n  tasks.sort((a, b) => b.start - a.start);\n  const answer = [];\n  let time = 0;\n\n  while (tasks.length > 0 || !queue.isEmpty()) {\n    // 快进 time\n    if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\n      time = tasks[tasks.length - 1].start;\n    }\n\n\n    // 向队列中加入可执行任务\n    while (tasks.length > 0) {\n      if (tasks[tasks.length - 1].start <= time) {\n        const task = tasks.pop();\n        queue.enqueue(task, task.time * 100000 + task.index)\n      } else {\n        break;\n      }\n    }\n\n    // 执行任务\n    const { element: task } = queue.dequeue();\n    time += task.time;\n    answer.push(task.index)\n  }\n\n  return answer;\n\n};\n```\n\n### 复杂度分析\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339594434","body":"### 思路\n\n使用堆排序\n\n### 代码\n\n```js\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n var sortArray = function(nums) {\n  buildHeap(nums, nums.length);\n  for(let i= nums.length -1; i>=0; i--){\n    // 首先头尾交换，因为此时的头部是最大值\n    swap(nums, i, 0);\n    // 交换完之后去掉头部，并重新构建最大堆\n    // 但此时的长度-1，也就是i的值\n    heapify(nums, i ,0);\n  }\n  return nums\n};\n\n\nfunction buildHeap(nums,len){\n  const last = Math.floor(len / 2);\n  for(let i = last; i >= 0 ; i--){\n    heapify(nums, len, i);\n  }\n}\n\nfunction heapify(nums, len ,i){\n  if(i >= len) return;\n  const left = i* 2 + 1;\n  const right = i*2 +2;\n  let max = i;\n  if(left < len && nums[left] > nums[max]){\n    max = left;\n  }\n  if(right < len && nums[right] > nums[max]){\n    max = right;\n  }\n  if(max !== i){\n    swap(nums, max, i);  // 交换结点\n    heapify(nums, len, max);\n  }\n}\n\n\nfunction swap(items, i, j) {\n  let temp = items[i]\n  items[i] = items[j]\n  items[j] = temp\n}\n\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346694452","body":"var swimInWater = function(grid) {\n    let ARR = [[0,1],[0,-1],[1,0],[-1,0]];\n    //记录所有已经访问过的点\n    let dp = new Array(grid.length).fill(0).map(i=>new Array(grid[0].length).fill(0));\n    let result = 0;\n    let stack=[[0,0]];\n\n    while(stack.length>0){\n        let [row,col] = stack.shift();\n        //用以记录当前已经保存的所有能走的点\n        result = Math.max(result,grid[row][col]);\n\n        if(row===grid.length-1 && col===grid[0].length-1){\n            //达到终点结束遍历\n            break;\n        }\n        for(let [dr,dc] of ARR){\n            let [nr,nc] = [dr+row,dc+col];\n            if(nr<grid.length && nr>=0 && nc<grid[0].length && nc>=0 && !dp[nr][nc]){\n                dp[nr][nc]=1\n                //此处若使用二分查找插入还能对时间进行优化\n                stack.push([nr,nc,grid[nr][nc]])\n            }\n        }\n        //排序还能使用二分插入法进行优化\n        stack.sort((a,b)=>a[2]-b[2])\n    }\n    return result;\n};\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357597052","body":"```js\n/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n  let res = 0;\n  const board = new Array(n)\n  for (let i = 0; i < n; i++) {\n    // 棋盘的初始化\n    board[i] = new Array(n).fill('.')\n  }\n  const isValid = (row, col) => {\n    for (let i = 0; i < row; i++) {\n      // 之前的行\n      for (let j = 0; j < n; j++) {\n        // 所有的列\n        if (\n          board[i][j] == 'Q' && // 发现了皇后，并且和自己同列/对角线\n          (j == col || i + j === row + col || i - j === row - col)\n        ) {\n          return false // 不是合法的选择\n        }\n      }\n    }\n    return true\n  }\n  const helper = row => {\n    // 放置当前行的皇后\n    if (row == n) {\n        res++\n    }\n    for (let col = 0; col < n; col++) {\n      // 枚举出所有选择\n      if (isValid(row, col)) {\n        // 剪掉无效的选择\n        board[row][col] = 'Q' // 作出选择，放置皇后\n        helper(row + 1) // 继续选择，往下递归\n        board[row][col] = '.' // 撤销当前选择\n      }\n    }\n  }\n  helper(0) // 从第0行开始放置\n  return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297933717","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n\n## 思路\n1、遍历数组，逆序逐位相加(注意相加进位问题)\n2、考虑k的数字长度大于数组长度的问题\n3、逆序输出即可\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        int len = num.length;\n        //1、从后往前逐位相加\n        for (int i = len-1; i >=0 ; i--) {\n            //1.1逐位相加\n            int sum = num[i] + k%10;\n            k /=10;\n            //1.2相加进位\n            if (sum >= 10){\n                k++;\n                sum -=10;\n            }\n            result.add(sum);\n        }\n\n        //2、如果k的长度大于num的数组长度\n        for (;k>0;k /=10){\n            result.add(k %10);\n        }\n\n        //3、将结果反转输出即可\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299506664","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n## 思路\n\n正反遍历方式：\n     *      1、正遍历记录从左侧到字符c的距离\n     *      2、返遍历记录从右侧到字符c的距离\n     *      取两者的最小值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int indexC1 = -n;\n        for (int i = 0; i < n ; ++i) {//正向遍历\n            if (s.charAt(i) == c){\n                indexC1 = i;\n            }\n            res[i] = i - indexC1;\n        }\n\n        int indexC2 = 2*n;//反向遍历初始值使用2n的目地是防止下面取最小值时出现错误数据\n        for (int i = n-1; i >=0 ; --i) {//反向遍历\n            if (s.charAt(i) == c){\n                indexC2 = i;\n            }\n            res[i] = Math.min(res[i],indexC2 - i);//取最小值\n        }\n        return res;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301558840","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 思路\n使用数组模拟栈,用一个变量 top 记录当前栈顶的位置\n     *      1、对于push操作,首先判断当前元素的个数是否达到上限,如果没有达到上限,则把栈顶top后移一个位置 并添加元素\n     *      2、对于pop操作,首先判断栈是否为空,非空则返回栈顶top对应位置的元素,栈顶top向前移一个位置 否则返回-1\n     *      3、对于inc操作,对栈底的最多k个元素增加val\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top;//记录栈顶的位置\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (stack.length > 0 && top >= 0){\n            --top;\n            return stack[top + 1];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k, top + 1);\n        for (int i = 0; i < min; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(1) inc操作的时间复杂为O(k)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303174000","body":"算法流程：\n1、构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n         1.1当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n         1.2当 c 为字母时，在 res 尾部添加 c；\n         1.3当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 \n              1.3.1记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n              1.3.2记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n              1.3.3进入到新 [ 后，res 和 multi 重新记录。\n          1.4当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n               1.4.1last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n               1.4.2cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n2、返回字符串 res。\n\n代码：java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n复杂度分析：\n时间复杂度 \nO(N)\n空间复杂度 \nO(N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304540439","body":"思路:\n我们创建两个栈，分别为 out 和 in：\n        in 用作处理输入操作 push()，使用 in 时需确保 out 为空\n        out 用作处理输出操作 pop() 和 peek()，使用 out 时需确保 in 为空\n\n代码:java\n\nclass MyQueue {\n    Deque<Integer> out, in;\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while (!out.isEmpty()) in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n\n复杂度分析:\n       时间复杂度：O(n)O(n)\n       空间复杂度：O(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304788782","body":"思路:\n根据栈的思想，我们在栈中维护每个块的最大值\n1、若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n2、若栈顶元素大于当前元素，则需要融合到上一个块中去，直到当前元素大于栈顶元素或者栈为空\n\n代码：java\npublic int maxChunksToSorted(int[] arr) {\nDeque<Integer> stack = new LinkedList<>();\n        for (int num : arr) {\n            //若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n            if (stack.isEmpty() || stack.peek() <= num) {\n                stack.push(num);\n            } else {\n                //融合块，保留当前块的最大元素\n                //比如之前有块[3]、[4],若num = 1，\n                //则融合为[3,4,1],因为排序1会排到前边去，当前块的最大值还是4\n                int max = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(max);\n            }\n        }\n        return stack.size();\n }\n\n复杂度分析:\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305695785","body":"思路:\n1、先把链表全部放进数组里面去。\n2、因为旋转的次数等于链表中元素的值的话，链表旋转后还是相等的。\n3、考虑取模了，取模之后为0的话说明旋转之后不变，直接返回\n4、通过链表的长度得出最后的返回头和返回头的前一个元素\n5、得到返回的元素头的前一个元素，我们把它指向一个空，先断开链表\n\n代码:java\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        List<ListNode> arrayList = new ArrayList<>();\n        ListNode cur = head;\n        while (cur != null) {\n            arrayList.add(cur);\n            cur = cur.next;\n        }\n        int size = arrayList.size();\n        int number = k % size;\n        if (number == 0) {\n            return head;\n        }\n        int index = size - number;\n        ListNode lastNode = arrayList.get(index - 1);\n        lastNode.next = null;\n        ListNode node = arrayList.get(index);\n        cur = node;\n        for (int i = 1; i < number; i++) {\n            node = node.next;\n        }\n        node.next = head;\n        return cur;\n    }\n}\n\n复杂度分析:\n时间复杂度O(n)\n空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307270957","body":"思路:递归处理\n1、返回值：交换完成的子链表\n2、调用单元：设需要交换的两个点为 head 和 next，head 连接后面交换完成的子链表，next 连接 head，完成交换\n3、终止条件：head 为空指针或者 next 为空指针，也就是当前无节点或者只有一个节点，无法进行交换\n\n\n代码:java\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n}\n\n复杂度分析:\n时间复杂度:O(n) 其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\n空间复杂度:O(n) 其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308841501","body":"思路：\n1、用双指针来找到链表的中点，\n2、用pre来当做中点的前一个点，n2 = pre.next，\n3、让n1比n2多走一步，这样当n1到达最后一个点时n2到了中点。\n4、此时切断n2和左边的联系来将链表一切两半。\n5、接下来可以利用递归的反转性，node.left = sortedListToBST(head); 这样树的最左边节点就是最小值。node.right = sortedListToBST(n2.next);这样树的右边第一个节点就是最大值。\n\n\n代码:java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if(head == null) return null;\n        else if(head.next == null) return new TreeNode(head.val);\n        ListNode pre = head;\n        ListNode n2 = pre.next;\n        ListNode n1 = n2.next;\n        \n        while(n1 != null && n1.next != null) {\n            pre = pre.next;\n            n2 = pre.next;\n            n1 = n1.next.next;\n        }\n        pre.next = null;\n        TreeNode node = new TreeNode(n2.val);\n        node.left = sortedListToBST(head);\n        node.right = sortedListToBST(n2.next);\n        return node;\n    }\n}\n\n复杂度分析:\n时间复杂度:O(nlogn)\n空间复杂度:O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310191339","body":"\n## 题目地址(160. 相交链表)\n\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists/\n\n## 题目描述\n\n```\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\n\n图示两个链表在节点 c1 开始相交：\n\n题目数据 保证 整个链式结构中不存在环。\n\n注意，函数返回结果后，链表必须 保持其原始结构 。\n\n自定义评测：\n\n评测系统 的输入如下（你设计的程序 不适用 此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。\n\n \n\n示例 1：\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n\n\n \n\n示例 2：\n\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3：\n\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n \n\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <= m\n0 <= skipB <= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n \n\n进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。\n解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。\n所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。\n如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1：\n这个逻辑可以覆盖这种情况的，相当于 c1 节点是 null 空指针嘛，可以正确返回 null。\n\n## 关键点\n\n-  双指针技巧\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while (p1 != p2){\n            if(p1 == null){\n                p1 = headB;\n            }else {\n                p1 = p1.next;\n            }\n\n            if(p2 == null){\n                p2 = headA;\n            }else {\n                p2 = p2.next;\n            }\n\n        }\n        return p1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297828208","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const ret = [];\n  \n  while(num.length || k) {\n    k += num.pop() || 0;\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  while(k) {\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  \n  return ret;\n};\n\n// Time Complexity O(N)\n// Space Complexity O(N)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341352","body":"```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const ret = new Array(s.length);\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ret[i] = 0;\n    } else {\n      if (i === 0) {\n        ret[i] = 10001;\n      } else {\n        ret[i] = ret[i - 1] + 1;\n      }\n    }\n  }\n  \n  for (let j = s.length - 2; j >= 0; j--) {\n    ret[j] = Math.min(ret[j], ret[j + 1] + 1);\n  }\n  \n  return ret;\n};\n```\n- Time Complexity O(N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301505213","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.max = maxSize;\n  this.size = 0;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.size < this.max) {\n    this.stack.push(x);\n    this.size++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.size > 0) {\n    this.size--;\n    return this.stack.pop();\n  }\n  \n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.size) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n- Time Complexity inc O(N) push,pop O(1)\n- Space Complexity O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304551283","body":"```js\n\nvar MyQueue = function() {\n  this.outStack = [];\n  this.inStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.outStack.length && !this.inStack.length;\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n- Time Complexity O( N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801302","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = [arr[0]];\n  \n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] >= stack[stack.length - 1]) {\n      stack.push(arr[i]);\n    }\n    \n    const topNum = stack.pop();\n    while (stack.length && stack[stack.length - 1] > arr[i]) {\n      stack.pop();\n    }\n    stack.push(topNum);\n  }\n  \n  return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305733649","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next || k === 0) {\n    return head;\n  }\n\n  let p = head;\n  let len = 1;\n\n  while (p.next) {\n    p = p.next;\n    len++;\n  }\n\n  k = k % len;\n  p.next = head;\n\n  for (let i = 0; i < len - k; i++) {\n    p = p.next;\n  }\n\n  const newLink = p.next;\n  p.next = null;\n\n  return newLink;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308917828","body":"```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n  if (!head) {\n    return null;\n  }\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head === tail) {\n    return null;\n  }\n  let fast = head;\n  let slow = head;\n  \n  while (fast !== tail && fast.next !== tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  \n  const node = new TreeNode(slow.val);\n  node.left = dfs(head, slow);\n  node.right = dfs(slow.next, tail);\n  \n  return node;\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312716633","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root) {\n  if (!root) {\n    return 0;\n  }\n  \n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n};\n```\n- Time Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313938862","body":"```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n  if (!p && !q) {\r\n    return true;\r\n  }\r\n  if (!p || !q) {\r\n    return false;\r\n  }\r\n  \r\n  if (p.val !== q.val) {\r\n    return false;\r\n  }\r\n  \r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315494654","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n  const rArr = [];\n  \n  function dfs(node, arr) {\n    arr.push(node.val);\n    if (!node.left && !node.right) {\n      const sum = arr.join('');\n      rArr.push(parseInt(sum));\n      return;\n    }\n    if (node.left) {\n      dfs(node.left, arr);\n      arr.pop();\n    }\n    if (node.right) {\n      dfs(node.right, arr);\n      arr.pop();\n    }\n  }\n  \n  dfs(root, []);\n  const ret = rArr.reduce((pre, cur) => {\n    return pre += cur\n  })\n  \n  return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317169077","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  const arr = [root];\n  let ret = arr[0].val;\n  \n  while (arr.length) {\n    let len = arr.length;\n    for (let i = 0; i < len; i++) {\n      const node = arr.shift();\n      if (i === 0) {\n        ret = node.val;\n      }\n      node.left && arr.push(node.left);\n      node.right && arr.push(node.right);\n    }\n  }\n  \n  return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318776946","body":"```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n  if (!root) {\n    return 'x';\n  }\n  \n  return root.val + ',' + serialize(root.left) + ',' + serialize(root.right);\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');\n  \n  function buildTree(arr) {\n    const item = arr.shift();\n    if (item === 'x') {\n      return null;\n    }\n    \n    const node = new TreeNode(item);\n    node.left = buildTree(arr);\n    node.right = buildTree(arr);\n    \n    return node;\n  }\n  \n  return buildTree(list)\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320889824","body":"```js\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n  let map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const diff = target - nums[i];\n    \n    if (map.has(diff)) {\n      \n      return [map.get(diff), i];\n    } else {\n      map.set(nums[i], i);\n    }\n  }\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325120791","body":"```js\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n  const wordSize = words[0].length;\n  const wordsLen = wordSize * words.length;\n  let map = new Map();\n  let ans = [];\n  for (let i = 0; i< words.length; i++) {\n    map.has(words[i]) ? map.set(words[i], map.get(words[i]) + 1) : map.set(words[i], 1);\n  }\n  for (let i = 0; i < s.length - wordsLen + 1; i++) {\n    const tmap = new Map(map);\n    let count = words.length;\n    for (let p = i; p < i + wordsLen; p += wordSize) {\n      const word = s.slice(p, p + wordSize);\n      if (!tmap.has(word) || tmap.get(word) <= 0) {\n        break;\n      }\n      tmap.set(word, tmap.get(word) - 1);\n      count--;\n    }\n    if (count === 0) {\n      ans.push(i);\n    }\n  }\n  return ans;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297940594","body":"### 将 `num` 转为数字\n\n#### 思路\n\n将 `num` 由列表转为数字，与 `k` 求和后再转为数组输出\n\n#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        t = 10\n        n = len(num)\n        res = 0\n        for i in range(n):\n            res += t ** i * num[n - i - 1]\n        res += k\n        \n        out = []\n        while res:\n            out.append(res % 10)\n            res = res // 10\n        return out[::-1]\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(n)$\n\n### 逐位相加\n\n#### 思路\n\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\n> * https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n\n#### 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        if len(num) < len(str(k)):\n            num = [0] * (len(str(k)) - len(num)) + num\n        n = max(len(str(k)), len(num)) - 1\n        while n >= 0 or k:\n            sums = num[n] + k % 10 + carry\n\n            basic = sums % 10\n            carry = sums // 10\n            res.insert(0, basic)\n\n            n -= 1\n            k //= 10\n        if carry:\n            res.insert(0, carry)\n            return res\n        else:\n            return res\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299391606","body":"### 代码\n\n```python\nclass Solution:\n    def shortestToChar (self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n + 1] * n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != -1:\n                res[i] = i - idx\n\n        idx = n\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != n:\n                res[i] = min(idx - i, res[i])\n\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$ 。遍历 s 即可，\n* 空间复杂度： $O(n)$。和 s 等长的结果数组，","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301554047","body":"```python\nclass CustomStack:  \n    def __init__(self, maxSize: int):  \n        self.stack = []  \n        self.size = maxSize  \n  \n    def push(self, x: int) -> None:  \n        if len(self.stack) < self.size:  \n            self.stack.append(x)  \n  \n    def pop(self) -> int:  \n        return self.stack.pop() if len(self.stack) > 0 else -1  \n  \n    def increment(self, k: int, val: int) -> None:  \n        if len(self.stack) < k:  \n            self.stack = [i + val for i in self.stack]  \n        else:  \n            self.stack[:k] = [i + val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302833820","body":"### 思路\n\n将每个字符入栈 ，当遇到 `']'` 时出栈，直至遇到 `'['`，`'['` 前的所有数字出栈，即为 `k`，将出栈得到的括号内所有字符重复 `k` 次，入栈。\n\n### 代码\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\": # \"[\" 之后的字符为当前要处理的子串\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0 # 进位，因为数字取值为 [1, 300]，需要考虑 10 以上的重复情况\n                while stack and stack[-1].isdigit(): # \"[\" 之前的数字为当前子串要重复的次数\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c += 1\n                ch = ch * time\n                stack.append(ch) # 处理完的子串入栈\n            else:\n                stack. append (i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$，需要遍历一遍字符\n* 空间复杂度：$O(n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304406391","body":"```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.inqueue = []\r\n        self.outqueue = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.inqueue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.inqueue and not self.outqueue:  # 两个栈均为空时\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304816175","body":"\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        local_max = -1\r\n        for num in arr:\r\n            while stack and stack[-1] > num:\r\n                stack.pop()\r\n            if num >= local_max:\r\n                stack.append(num)\r\n            else:\r\n                stack.append(local_max)\r\n            local_max = stack[-1]  # 不放在 lm = stack.pop() 是为了防止 num>lm 时最大值记录错误\r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(N)$\r\n- 空间复杂度： $O(N)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304976331","body":"### 思路\r\n\r\n- 将 链表 首尾串联形成循环链表\r\n- 旋转 k 次后的尾结点位置为 $(len(link) - k) \\% len(link)$，从该位置断开，取该位置下个结点为头节点即可。\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        length = 1\r\n        cur = head\r\n\r\n        while cur.next:\r\n            cur = cur.next\r\n            length += 1\r\n\r\n        target = (length - k) % length\r\n        cur.next = head\r\n        for _ in range(target):\r\n            cur = cur.next\r\n\r\n        head = cur.next\r\n        cur.next = None\r\n\r\n        return head\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306835996","body":"\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\n\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        start = pre = ListNode()\r\n        pre.next = head\r\n        while pre.next and pre.next.next:\r\n            slow, fast = pre.next, pre.next.next\r\n            slow.next = fast.next\r\n            fast.next = slow\r\n            pre.next = fast\r\n            pre = slow\r\n        return start.next\r\n````\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308036046","body":"```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head: ListNode) -> int:\r\n            ret = 0\r\n            while head:\r\n                ret += 1\r\n                head = head.next\r\n            return ret\r\n\r\n        def buildTree(left: int, right: int) -> TreeNode:\r\n            if left > right:\r\n                return None\r\n            mid = (left + right ) // 2 # 中间结点\r\n            \r\n            root = TreeNode()\r\n            root.left = buildTree(left, mid - 1)\r\n            \r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            \r\n            root.right = buildTree(mid + 1, right)\r\n            return root\r\n\r\n        length = getLength(head)\r\n        return buildTree(0, length - 1)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309634405","body":"#### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode (self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n#### 复杂度\r\n\r\n时间复杂度： $O(m+n)$\r\n空间复杂度： $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311454840","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n        fast = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n\r\n#### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(1)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312468386","body":"```python\r\nfrom collections import OrderedDict\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        else:\r\n            self.cache.move_to_tail(key)\r\n            return self.cache[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        self.cache[key] = value\r\n        self.cache.move_to_tail(key)\r\n        if len(self.cache) > self.capacity:\r\n            self.cache.popitem(last=False)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312659800","body":"```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312939839","body":"```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:  # 二者均为空\r\n            return True\r\n        if (not p and q) or (p and not q):  # 一个为空，另一个非空\r\n            return False\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314612513","body":"```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        return self.preorderTraversal(root, 0)\r\n\r\n    def preorderTraversal(self, root, pre_sum=0):\r\n        if not root:\r\n            return 0\r\n        \r\n        sum_to_cur = pre_sum * 10 + root.val # 截至到当前结点的路径和\r\n        if not root.left and not root.right:\r\n            return sum_to_cur\r\n\r\n        # 若为非叶子结点，则路径和需继续累加左子结点和右子结点\r\n        return self.preorderTraversal(root.left, sum_to_cur) + self.preorderTraversal(\r\n            root.right, sum_to_cur\r\n        )\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316133998","body":"### 广度优先搜索\r\n\r\n#### 思路\r\n\r\n* 层序遍历 时，每层按 **从右到左** 顺序进行，则该层最后一个结点，则是该层最左结点。\r\n* 从而最左下结点为层序遍历的最后一个结点\r\n\r\n#### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        return self.levelTraversal(root)\r\n\r\n    def levelTraversal(self, root):\r\n        queue = [root]\r\n        tmp = None\r\n\r\n        while queue:\r\n            for _ in range(len(queue)):  # 遍历每一层\r\n                tmp = queue.pop(0)\r\n                if tmp.right:  # 右结点先入队\r\n                    queue.append(tmp.right)\r\n                if tmp.left:\r\n                    queue.append(tmp.left)\r\n        ans = tmp.val  # 最后一个入队的结点即为最左下结点\r\n        return ans\r\n```\r\n\r\n* 从左到右遍历时，每层第一个元素即是该层第一个元素。\r\n\r\n```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\n\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        return self.levelTraversal(root)\r\n\r\n    def levelTraversal(self, root):\r\n        queue = [root]\r\n        ans = None\r\n\r\n        while queue:\r\n            ans = queue[0].val  # 每层第一个元素 -> 最后一层第一个元素即为最左下结点\r\n            # 开始遍历每一层\r\n            for _ in range(len(queue)):  # 每一层的处理\r\n                tmp = queue.pop(0)\r\n                if tmp.left:\r\n                    queue.append(tmp.left)\r\n                if tmp.right:\r\n                    queue.append(tmp.right)\r\n        return ans\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。\r\n* 空间复杂度：$O(n)$。如果二叉树是满完全二叉树，那么队列 `queue` 最多保存 $\\big \\lceil \\dfrac{n}{2} \\big \\rceil$ 个节点\r\n\r\n### 深度优先搜索\r\n\r\n#### 思路\r\n\r\n* 采用深度优先搜索，到第一次到达新的一层时，即为当前最左下结点。\r\n* 记录当前结点所在的深度和最大深度，第一次取得最大深度时，即到达新的一层，该结点便是最左下结点。\r\n\r\n#### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        # self.ans,self.max_depth = None,0\r\n        ans = 0\r\n        max_depth = 0\r\n\r\n        def dfs(root, depth=0):\r\n            nonlocal ans, max_depth\r\n            if not root:\r\n                return None\r\n            depth += 1\r\n            if depth > max_depth:\r\n                max_depth = depth\r\n                ans = root.val\r\n            dfs(root.left, depth)\r\n            dfs(root.right, depth)\r\n\r\n        dfs(root, 0)\r\n        return ans\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：$O(n)$，其中 $n$ 是二叉树的节点数目。需要遍历 $n$ 个节点。\r\n* 空间复杂度：$O(n)$。递归栈需要占用 $O(n)$ 的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317952142","body":"### 广度优先搜索 - 层序遍历\r\n\r\n序列化的结果正好时二叉树的层序遍历结果。注意没有左右孩子结点要输出 `'null'`，而不是跳过。\r\n\r\n#### 代码\r\n\r\n```python\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n\r\nclass Codec:\r\n    from collections import deque\r\n    \r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        queue = self.deque([root])\r\n        res = []\r\n        while queue:\r\n            for _ in range(len(queue)): \r\n            # for _ in range(len(queue)): # 加与不加 for 循环均可\r\n                node = queue.popleft()\r\n                if node:\r\n                    res.append(str(node.val))\r\n                    # if node.left: # 必须取消\r\n                    queue.append(node.left)\r\n                    # if node.right: # 必须取消\r\n                    queue.append(node.right)\r\n                else:\r\n                    res.append(\"null\")\r\n        return \",\".join(res)\r\n    \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data, i = data.split(\",\"), 1\r\n        root = TreeNode(data[0])\r\n        queue = self.deque([root])\r\n        \r\n        while i < len(data):\r\n            for _ in range(len(queue)):\r\n            # for _ in range(len(queue)):# 加与不加 for 循环均可\r\n                node = queue.popleft()\r\n                if data[i] != \"null\":\r\n                    node.left = TreeNode(data[i])\r\n                    queue.append(node.left)\r\n                i += 1\r\n                if data[i] != \"null\":\r\n                    node.right = TreeNode(data[i])\r\n                    queue.append(node.right)\r\n                i += 1\r\n        Return root\r\n```\r\n\r\n#### 复杂度\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(n)$\r\n\r\n### 前序遍历\r\n\r\n序列化的结果为前序遍历的输出，注意子节点为空时，需要输出子结点为 `null` 。\r\n\r\n#### 代码\r\n\r\n1. 外部变量 `self.index` 记录每次要处理的元素位置，按顺序依次处理。\r\n\r\n```python\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\n\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        return self.dfs(root)\r\n        \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        data = data.split(\",\")\r\n        self.index = 0\r\n        return self.build_dfs(data)\r\n        \r\n    def dfs(self, root):\r\n        if not root:\r\n            return \"null\"\r\n        return str(root.val) + \",\" + self.dfs(root.left) + \",\" + self.dfs(root.right)\r\n        \r\n    def build_dfs(self, data):\r\n        if self.index >= len(data) or data[self.index] == \"null\":\r\n            self.index += 1\r\n            return None\r\n        root = TreeNode(int(data[self.index]))\r\n        self.index += 1\r\n        root.left = self.build_dfs(data)\r\n        root.right = self.build_dfs(data)\r\n        Return root\r\n```\r\n\r\n2. DFS 反序列化每次要处理的字符都是 `data` 的下一个元素，处理完成后直接 `pop` 出队即可。\r\n   * 以 `['1', '2', 'null', 'null', '3', '4', 'null', 'null', '5', 'null', 'null']` 为例，`1` 的右结点是 `3`，将 `1` 的左子树 `[2,'null','null']` 处理完成后正好是 `3`。\r\n\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"null\"\r\n        return (\r\n            str(root.val)\r\n            + \",\"\r\n            + self.serialize(root.left)\r\n            + \",\"\r\n            + self.serialize(root.right)\r\n        )\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        data = collections.deque(data.split(\",\"))\r\n        # data = data.split(',')\r\n        def traversal(data):  # 前序遍历\r\n            val = data.popleft()\r\n            # val = data.pop(0)\r\n            if val == \"null\":\r\n                return None\r\n            root = TreeNode(int(val))\r\n            root.left = traversal(data)\r\n            root.right = traversal(data)\r\n            return root\r\n            \r\n        return traversal(data)\r\n```\r\n\r\n#### 复杂度\r\n* 时间复杂度： $O(n)$\r\n* 空间复杂度： $O(n)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319393365","body":"### 思路\r\n\r\n- 先遍历记录下二叉树中每个元素的行列值，然后再根据（列，行，值）进行排序。\r\n- 由于题中要求按列优先，所以三元组中把列排在第一个元素。\r\n- python 中 `sorted` 函数可以对元组进行排序，按照各元素升序进行排序，先根据第一个元素排序，再根据第二个元素排序，正好满足题中要求。\r\n\r\n### 代码\r\n\r\n#### 深度优先搜索\r\n\r\n```python\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        self.info = []\r\n        self.dfs(root, 0, 0)\r\n\r\n        info = sorted(self.info)\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def dfs(self, root, row, col):\r\n        if not root:\r\n            return None\r\n        self.info.append((col, row, root.val))\r\n        self.dfs(root.left, row + 1, col - 1)\r\n        self.dfs(root.right, row + 1, col + 1)\r\n```\r\n\r\n#### 广度优先搜索\r\n\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        info = sorted(self.bfs(root))\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def bfs(self, root):\r\n        from collections import deque\r\n\r\n        ans = []\r\n        que = deque([(0, 0, root)])\r\n        while que:\r\n            for _ in range(len(que)):\r\n                tmp = que.popleft()\r\n                row, col = tmp[1], tmp[0]\r\n                node = tmp[2]\r\n                ans.append((col, row, node.val))\r\n                if node.left:\r\n                    que.append((col - 1, row + 1, node.left))\r\n                if node.right:\r\n                    que.append((col + 1, row + 1, node.right))\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n\\log(n))$，主要是排序的复杂度。\r\n- 空间复杂度： $O(n)$，需要存储所有结点的 (行, 列, 值) 信息。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298100069","body":"##### 989\n\n数组形式的整数加法\n\n```\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n```\n\n从低位向高位计算，注意边界处理（既然用数组表示数了，肯定可能大数）。\n\n```\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; i--)\n        {\n            int c = num[i] + k % 10;\n            k /= 10;\n            if (c >= 10)\n            {\n                k++; // 进位到k上\n                c -= 10;\n            }\n            res.push_back(c);\n        }\n        while (k)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n* O(N)\n* O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300711980","body":"#### 821\n\n字符的最短距离\n\n两次遍历。\n\n```\nclass Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        int i = 0, j = 0;\n        int n = s.size();\n        vector<int> res(n, 10007);\n        for (; j < n; j++)\n        {\n            if (s[j] == c)\n            {\n                int t = j - i;\n                for (; i <= j; i++)\n                {\n                    res[i] = min(res[i], t);\n                    t--;\n                }\n            }\n        }\n        i = n - 1, j = n - 1;\n        for (; i >= 0; i--)\n        {\n            if (s[i] == c)\n            {\n                int t = j - i;\n                for (; j >= i; j--)\n                {\n                    res[j] = min(res[j], t);\n                    t--;\n                }\n            }\n        }\n        for (int &a : res)\n        {\n            printf(\"%d \", a);\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301571798","body":"空间换时间，采用一个额外的数组increment来记录每次的increment操作。初始化为(maxSize, 0)，值如下。本质是到用时再计算。\nclass CustomStack\n{\npublic:\n    CustomStack(int _maxSize)\n        : maxSize(_maxSize)\n    {\n        stk.resize(_maxSize);\n        add.resize(_maxSize);\n        top = -1;\n    }\n\n    void push(int x)\n    {\n        if (top != maxSize - 1)\n        {\n            top++;\n            stk[top] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (top == -1)\n        {\n            return -1;\n        }\n        int res = stk[top] + add[top];\n        if (top != 0)\n        {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        top--;\n        return res;\n    }\n\n    void increment(int k, int val)\n    {\n        int l = min(k - 1, top);\n        if (l >= 0)\n        {\n            add[l] += val;\n        }\n    }\n\nprivate:\n    vector<int> stk;\n    vector<int> add;\n    int maxSize = -1;\n    int top;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302878649","body":"字符串解码\n\n```\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n括号内嵌套括号，需要从内向外生成与拼接字符串，和栈先入后出的特性对应。\n\n```\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561577","body":"\n\n##### 232\n\n栈实现队列\n\n双栈模拟队列；而非栈+辅助栈模拟队列；**后者push总是O(N)**，pop简单为O(1)。但是在双栈模拟情况下，仍能保证pop为O(1)，进行一次O(N)“倾倒”操作后，后续取这些元素O(1)即可。\n\n```\nclass MyQueue\n{\npublic:\n    // stack in\n    stack<int> s1;\n    // stack out\n    stack<int> s2;\n    MyQueue()\n    {\n    }\n\n    void push(int x)\n    {\n        s1.push(x);\n    }\n\n    int pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int res = s2.top();\n        s2.pop();\n        return res;\n    }\n\n    int peek()\n    {\n        int res = this->pop();\n        s2.push(res);\n        return res;\n    }\n\n    bool empty()\n    {\n        return s1.empty() && s2.empty();\n    }\n};\n```\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829697","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> st{};\n        for (auto & i: arr) {\n            if (st.empty() || i >= st.top()) {\n                st.emplace(i);\n            }else {\n                auto t = st.top();\n                st.pop();\n                while (!st.empty() && st.top() > i) {\n                    st.pop();\n                }\n                st.emplace(t);\n            }\n        }\n        return st.size();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304961272","body":"利用环找到新的头尾节点，因为内部关系没变，只修改\n\n* 尾节点指向头节点\n* 找到新的尾节点后\n  * 设置新头节点（新尾节点的下一个）\n  * 设置新尾节点（next置为nullptr）\n\n```\nclass Solution\n{\n    public:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // 原来的尾结点指向原来的头结点，形成环\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // 找到断开环的位置\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // 新的头结点指向断开环的位置\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n* Time O(N)\n* Space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297925085","body":"Keep adding the last digit of k to the last element of the array, then update k to k divided by ten plus the remainder of the last digit of k plus the last element of the array until the array is empty and k equals 0.\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        stack<int> tempS;\n        vector<int> res;\n        while(!num.empty())\n        {\n            int temp = k%10 + num.back();\n            tempS.push(temp % 10);\n            k  = k/10 + temp/10;\n            num.pop_back();\n        }\n        \n        while(k > 0)\n        {\n            tempS.push(k%10);\n            k /= 10;\n        }\n        \n        while(!tempS.empty())\n        {\n            res.push_back(tempS.top());\n            tempS.pop();\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299563969","body":"Traverse from left to right and set the value to the distance to char c. Traverse from right to left to update if a shorter length is found.\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.size();\n        vector<int> res;\n        int tempPos = INT_MAX;\n        \n        for(int i = 0; i < len; i++)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res.push_back(abs(i - tempPos));\n        }\n        \n        for(int i = len - 1; i >= 0; i--)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res[i] = min(res[i], abs(i - tempPos));\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301686760","body":"class CustomStack {\n\npublic:\n    int *s;\n    int size;\n    int index;\n    \n    CustomStack(int maxSize) {\n        s = (int*)malloc(sizeof(int) * (maxSize+1));\n        size = maxSize;\n        index = 0;\n    }\n    \n    void push(int x) {\n        if(index < size)\n        {\n            index++;\n            *(s + index) = x;\n        }\n    }\n    \n    int pop() {\n        if(index > 0)\n        {\n            int res = *(s+index);\n            index--;\n            return res;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 1; i <= k && i <= size; i++)\n            *(s+i) += val;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302894191","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> string_S;\n        stack<int> int_S;\n            \n        int index = 0;\n        string curRes = \"\";\n        while(index < s.size())\n        {\n            if(s[index] >= '0' && s[index] <= '9')\n            {\n                int count = 0;\n                while(s[index] >= '0' && s[index] <= '9')   \n                {\n                    count = 10 * count + (s[index] - '0');\n                    index++;\n                }\n                int_S.push(count);\n            }\n            \n            else if(s[index] == '[')\n            {\n                string_S.push(curRes);\n                curRes = \"\";\n                index++;\n            }\n            \n            else if(s[index] == ']')\n            {\n                string tempStr = string_S.top();\n                int repeatCount = int_S.top();\n                \n                string_S.pop();\n                int_S.pop();\n                    \n                while(repeatCount > 0)\n                {\n                    tempStr.append(curRes);\n                    repeatCount--;\n                }\n                \n                curRes = tempStr;\n                index++;\n            }\n            \n            else\n            {\n                curRes += s[index];\n                index++;\n            }\n        }\n        \n        return curRes;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304438835","body":"class MyQueue {\n    stack<int> pop_stack;\n    stack<int> push_stack;\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        push_stack.push(x);\n    }\n    \n    int pop() {\n        if(!pop_stack.empty())\n        {\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n    }\n    \n    int peek() {\n        if(!pop_stack.empty())\n            return pop_stack.top();\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            return pop_stack.top();\n        }\n    }\n    \n    bool empty() {\n        return pop_stack.empty() && push_stack.empty();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304651899","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> leftMax;\n        vector<int> rightMin;\n        int res = 1;\n        \n        leftMax.push_back(arr[0]);\n        for(int i = 1; i < arr.size(); i++)\n            leftMax.push_back(max(leftMax[i-1], arr[i]));\n        \n        rightMin.push_back(arr[arr.size() - 1]);\n        for(int i = arr.size() - 2; i >= 0; i--)\n            rightMin.insert(rightMin.begin(), 1, min(rightMin[rightMin.size()-(arr.size() - i - 1)], arr[i]));\n        \n        for(int i = 0; i < arr.size() - 1; i++)\n        {\n            if(leftMax[i] <= rightMin[i+1])\n                res++;\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305221514","body":"class Solution {\r\npublic:\r\n    ListNode *rotateRight(ListNode *head, int k) {\r\n        int len = 1;\r\n        if (head == NULL || k == 0)\r\n            return head;\r\n        ListNode *p = head;\r\n        while (p->next)\r\n        {\r\n            p = p->next;\r\n            len++;\r\n        }\r\n        if (k > len)\r\n            k %= len;\r\n        p->next = head;\r\n        for (int i = 0; i < len - k; i++)\r\n            p = p->next;\r\n        head = p->next;\r\n        p->next = NULL;\r\n        return head;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306648621","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == NULL || head->next == NULL)\n            return head;\n        \n        ListNode* pre = head;\n        ListNode* cur = head->next;\n        \n        pre->next = cur->next;\n        cur->next = pre;\n        \n        ListNode* next = swapPairs(pre->next);\n        pre->next = next;\n        \n        return cur;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310170075","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *ptr1 = headA;\n        ListNode *ptr2 = headB;\n        \n        while(ptr1 != ptr2){\n            ptr1 = ptr1->next;\n            ptr2 = ptr2->next;\n            \n            if(ptr1 == ptr2) break;\n            \n            if(ptr1 == NULL) ptr1 = headB;\n            if(ptr2 == NULL) ptr2 = headA;\n \n        }\n        return ptr1;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311189710","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        \n        while(fast && fast->next)\n        {\n            slow = slow->next;\n            fast = fast->next->next;\n            \n            if(slow == fast)\n            {\n                slow = head;\n                \n                while(slow != fast)\n                {\n                    slow = slow->next;\n                    fast = fast->next;\n                }\n                \n                return slow;\n            }\n        }\n        return NULL;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312641208","body":"class Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n            return 0;\n        int maxLeft = maxDepth(root->left);\n        int maxRight = maxDepth(root->right);\n        \n        return max(maxLeft, maxRight) + 1;\n    }\n\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313968035","body":"class Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)\n            return true;\n        if(!p || !q)\n            return false;\n        if(p->val != q->val)\n            return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right,q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314773758","body":"class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        return addNodes(root, 0);\n    }\n    \n    int addNodes(TreeNode* node, int num)\n    {\n        if(node == NULL)\n            return 0;\n        if(!node->left && !node->right)\n            return num * 10 + node->val;\n        return addNodes(node->left, num * 10 + node->val) + addNodes(node->right, num * 10 + node->val);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316704136","body":"class Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        \n        q.push(root);\n        \n        while(!q.empty()){\n            root = q.front();\n            q.pop();\n            if(root->right)\n                q.push(root->right);\n            if(root->left)\n                q.push(root->left);\n        }\n        \n        return root->val;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320933686","body":"class Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int> &numbers, int target) {\r\n        unordered_map<int, int> numbers_m;\r\n        vector<int> res;\r\n        size_t i;\r\n        \r\n        for(i = 0; i < numbers.size(); i++)\r\n            numbers_m[numbers[i]] = i;\r\n        \r\n        for(i = 0; i < numbers.size(); i++)\r\n        {\r\n            int temp = target - numbers[i];\r\n            \r\n            if(numbers_m.find(temp) != numbers_m.end() && numbers_m[temp] > i)\r\n            {\r\n                res.push_back(i);\r\n                res.push_back(numbers_m[temp]);\r\n                return res;\r\n            }\r\n        }\r\n        \r\n\t\treturn res;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320938931","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> q;\n        map<int, int> m;\n        vector<int> res;\n        \n        for(size_t i = 0; i < nums.size(); i++)\n            m[nums[i]]++;\n        \n        for(map<int,int>::iterator it = m.begin(); it != m.end(); it++)\n            q.push({it->second, it->first});\n        \n        for(int i = 0; i < k; i++)\n        {\n            res.push_back(q.top().second);\n            q.pop();\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321218925","body":"class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        \n        int res = 0;\n        \n        for(int i = 0; i < points.size(); i++)\n        {\n            unordered_map<long, int> distance_count;\n            \n            for(int j = 0; j < points.size(); j++)\n            {\n                if(i == j)\n                    continue;\n                long distance = pow(points[i][0]-points[j][0],2) + pow(points[i][1]-points[j][1],2);\n                distance_count[distance]++;\n            }\n            \n            for(auto m:distance_count)\n                if(m.second > 1)\n                    res += m.second * (m.second - 1);\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322912478","body":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int left = 0, right = 1;\n        int res = 0;\n        unordered_map<char, int> m;\n        \n        m[s[left]] = 1;\n        \n        if(s.size() == 0)\n            return 0;\n        \n        if(s.size() == 1)\n            return 1;\n        \n        while(right != s.size())\n        {\n            if(m.find(s[right]) == m.end())\n            {\n                m[s[right]] = 1;\n                res = max(res, right-left+1);\n                right++;\n                \n            }\n            else\n            {\n                while(s[left] != s[right])\n                {\n                    m.erase(s[left]);\n                    left++;\n                }\n                    \n                left++;\n                m.erase(s[right]);\n            }\n        }\n        return res;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327954425","body":"class Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n        \r\n        while(fast && fast->next)\r\n        {\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        \r\n        return slow;;\r\n    }\r\n};","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327953022","body":"class Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int index = 0;\n        \n        for(int i = 0; i < nums.size() - 1; i++)\n        {\n            if(nums[i] != nums[i+1])\n            {\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        nums[index] = nums[nums.size()-1];\n        return index+1;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328373061","body":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int> res;\n        int* left = (int*)malloc(sizeof(int) * nums.size());\n        int* right = (int*)malloc(sizeof(int) * nums.size());\n        \n        *left = nums[0];\n        *(right + nums.size() - 1) = nums[nums.size() - 1];\n        \n        for(int i = 1; i < nums.size(); i++)\n        {\n            left[i] = (i % k == 0) ? nums[i] : max(left[i-1], nums[i]);\n            \n            int j = nums.size() - i - 1;\n            \n            right[j] = (j % k == 0) ? nums[j] : max(right[j+1], nums[j]);\n        }\n                        \n        for(int i = 0; i + k <= nums.size(); i++)\n        {\n            res.push_back(max(right[i], left[i+k-1]));     \n        }\n                        \n        return res;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331758002","body":"class Solution {\nprivate:\n    bool res = true;\n    vector<bool> visited;\n    vector<bool> dislike;\n    \npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) \n    {\n        visited.resize(n + 1, false);\n        dislike.resize(n + 1, true);\n        \n        vector<vector<int>> graph = createGraph(n, dislikes);\n        \n        for(int i = 1; i < n + 1; i++)\n        {\n            if(!visited[i])\n            {\n                res = bfs(i, graph);\n                if(!res)\n                    return false;\n            }\n                \n        }\n        \n        return true;\n    }\n    \n    vector<vector<int>> createGraph(int n, vector<vector<int>>& dislikes)\n    {\n        vector<vector<int>> graph;\n        graph.resize(n + 1, vector<int>(0));\n        for(vector<int> vec : dislikes)\n        {\n            int v1 = vec[0];\n            int v2 = vec[1];\n            \n            graph[v1].push_back(v2);\n            graph[v2].push_back(v1);\n        }\n        return graph;\n    }\n    \n    bool bfs(int v, vector<vector<int>> graph)\n    {\n        if(!res)\n            return false;\n        \n        queue<int> q;\n        q.push(v);\n        \n        while(!q.empty() && res)\n        {\n            int vertex = q.front();\n            q.pop();\n            visited[vertex] = true;\n            \n            for(int neighbor : graph[vertex])\n            {\n                if(!visited[neighbor])\n                {\n                    dislike[neighbor] = !dislike[vertex];\n                    q.push(neighbor);\n                }\n                else\n                {\n                    if(dislike[neighbor] == dislike[vertex])\n                    {\n                        res = false;\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        return true;\n    }\n    \n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334700302","body":"class Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int RC = 0, LC = 0, UC = 0, DC = 0;\n        for(auto c:moves)\n        {\n            if(c == 'L')\n                LC++;\n            else if(c == 'R')\n                RC++;\n            else if(c == 'U')\n                UC++;\n            else if(c == 'D')\n                DC++;\n        }\n        \n        return LC == RC && DC == UC;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336928186","body":"class Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int len1 = a.size(), len2 = b.size();\n        int res = len1 + len2;\n        \n        vector<int> vec1(26);\n        vector<int> vec2(26);\n        \n        for(auto c:a)\n            vec1[c - 'a']++;\n        \n        for(auto c:b)\n            vec2[c - 'a']++;\n        \n        for(int i = 0; i < 26; i++)\n        {\n            res = min(res, len1 + len2 - vec1[i] - vec2[i]);\n            if(i > 0){\n                vec1[i] += vec1[i - 1];\n                vec2[i] += vec2[i - 1];\n            }\n            if(i < 25) {\n                res = (len1 - vec1[i] + vec2[i] < len2 - vec2[i] + vec1[i] ? min(res, len1 - vec1[i] + vec2[i]) : min(res, len2 - vec2[i] + vec1[i]));\n            }\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338981581","body":"class Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n    \n    void mergeSort(vector<int> &nums, int begin, int end) {\n        if(begin >= end)\n            return;\n        \n        int mid = (end - begin) / 2 + begin;\n        mergeSort(nums, begin, mid);\n        mergeSort(nums, mid + 1, end);\n        mergeArray(nums, begin, end, mid);\n    }\n    \n    void mergeArray(vector<int> &nums, int begin, int end, int mid){\n        int index = 0, l = begin, r = mid + 1;\n        vector<int> sorted(end - begin + 1, 0);\n        \n        while(l <= mid && r <= end){\n            if(nums[l] < nums[r])\n                sorted[index++] = nums[l++];\n            else\n                sorted[index++] = nums[r++];\n        }\n        while(l <= mid)\n            sorted[index++] = nums[l++];\n        while(r <= end)\n            sorted[index++] = nums[r++];\n        for(int i = begin; i <= end; i++)\n            nums[i] = sorted[i - begin];\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345136366","body":"class Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(), houses.end());\n        sort(heaters.begin(), heaters.end());\n        vector<int> res(houses.size(), INT_MAX);\n\n        for(int i = 0, j = 0; i < houses.size() && j < heaters.size(); )\n        {\n            if(houses[i] <= heaters[j]){\n                res[i] = heaters[j] - houses[i];\n                i++;\n            }\n            else{\n                j++;\n            }\n        }\n\n        for(int i = houses.size() - 1, j = heaters.size() - 1; i >= 0 && j >= 0;){\n            if(houses[i] >= heaters[j]){\n                res[i] = min(res[i], houses[i] - heaters[j]);\n                i--;\n            }\n            else{\n                j--;\n            }\n        }\n        return *max_element(res.begin(), res.end());\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350403406","body":"class Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if(k == 0 || n >= k + maxPts) {\n            return 1.0;\n        }\n\n        double res = 0.0;\n    \tdouble sum = 0.0;\n    \tvector<double> vec(n + 1);\n    \t\n\n    \tfor (int i = 1; i <= n; i++) {\n    \t\tvec[i] = i <= maxPts ? sum / maxPts + 1.0 / maxPts : sum/maxPts;\n    \t\tif (i >= k) {\n    \t\t    res += vec[i];\n    \t\t}\n            else if (i < k) {\n    \t\t    sum += vec[i];\n    \t\t}\n    \t\t\n            if (i > maxPts) {\n    \t\t    sum -= vec[i - maxPts];\n    \t\t}\n    \t}\n    \treturn res;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1353801504","body":"class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> need, window;\n        \n        for(char c : t)\n            need[c]++;\n        \n        int left = 0, right = 0, valid = 0;\n        int start = 0, len = INT_MAX;\n        \n        while(right < s.size())\n        {\n            char c = s[right];\n            right++;\n            \n            if(need.count(c))\n            {\n                window[c]++;\n                if(window[c] == need[c])\n                    valid++;\n            }\n            \n            while(valid == need.size())\n            {\n                if(right - left < len)\n                {\n                    start = left;\n                    len = right - left;\n                }\n                \n                char c = s[left];\n                \n                if(need.count(c))\n                {\n                    if(window[c] == need[c])\n                        valid--;\n                    window[c]--;\n                }\n                left++;\n            }\n        }\n        \n        return len == INT_MAX ? \"\" : s.substr(start, len);\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359031715","body":"class Solution {\npublic:\n    int gridArea(vector<vector<int>>& grid, int i, int j){\n        if( i >= 0 && i < grid.size() && j >= 0 && j < grid[0].size() && grid[i][j] == 1){\n            grid[i][j] = 0;\n            return 1 + gridArea(grid, i+1, j) + gridArea(grid, i-1, j) + gridArea(grid, i, j-1) + gridArea(grid, i, j+1);\n        }\n        return 0;\n    }\n\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int res = 0;\n        for(int i = 0; i < grid.size(); i++)\n            for(int j = 0; j < grid[0].size(); j++)\n                if(grid[i][j] == 1)\n                    res = max(max_area, gridArea(grid, i, j));\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361556002","body":"class Solution {\npublic:\n    int maxDistance(vector<vector<int>>& g, int steps = 0) {\n        queue<pair<int, int>> water, water1;\n\n        for(int i = 0; i < g.size(); i++)\n        {\n            for(int j = 0; j < g[i].size(); j++)\n            {\n                if(g[i][j] == 1)\n                {\n                    water.push({i-1, j});\n                    water.push({i+1, j});\n                    water.push({i, j+1});\n                    water.push({i, j-1});\n                }\n            }\n        }\n\n        while(!water.empty())\n        {\n            steps++;\n            while(!water.empty())\n            {\n                int i = water.front().first;\n                int j = water.front().second;\n                water.pop();\n                if(i >= 0 && j >= 0 && i < g[i].size() && g[i][j] == 0)\n                {\n                    g[i][j] = steps;\n                    water1.push({i-1, j});\n                    water1.push({i+1, j});\n                    water1.push({i, j-1});\n                    water1.push({i, j+1});\n                }\n            }\n            swap(water, water1);\n        }\n        \n        return steps == 1 ? -1 : steps - 1;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364349470","body":"class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        cost.push_back(0);\n\n        for(int i = cost.size() - 3; i >= 0; i--)\n            cost[i] += min(cost[i+1], cost[i+2]);\n\n        return min(cost[0], cost[1]);\n    }\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366185726","body":"class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m+1, vector<int>(n+1, 0));\n\n        for(int i = 0; i < n; i++)\n            dp[m][i] = 0;\n        \n        for(int j = 0; j < m; j++)\n            dp[j][n] = 0;\n\n        for(int i = m-1; i >= 0; i--)\n        {\n            for(int j = n-1; j >= 0; j--)\n            {\n                if(i == m-1 && j == n-1)\n                    dp[i][j] = 1;\n                else\n                    dp[i][j] = dp[i+1][j] + dp[i][j+1];\n\n            }\n        }\n        return dp[0][0];\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1366979458","body":"class Solution {\npublic:\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<double>> dp(n, vector<double>(n, 0));\n        vector<int> dx = {2, 2, 1, 1, -1, -1, -2, -2};\n        vector<int> dy = {1, -1, 2, -2, -2, 2, 1, -1};\n        double res = 0;\n        dp[row][column] = 1;\n\n        while(k > 0)\n        {\n            vector<vector<double>> dp2(n, vector<double>(n, 0));\n            for(int x = 0; x < n; x++)\n            {\n                for(int y = 0; y < n; y++)\n                {\n                    for(int k = 0; k < 8; k++)\n                    {\n                        int new_x = x + dx[k];\n                        int new_y = y + dy[k];\n                        if(new_x >= 0 && new_x < n && new_y >= 0 && new_y < n)\n                        {\n                            dp2[new_x][new_y] += dp[x][y] / 8.0;\n                        }\n                    }\n                }\n            }\n            dp = dp2;\n            k--;\n        }\n        for(auto vec:dp)\n            for(auto value:vec)\n                res += value;\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369229763","body":"class Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n\n        dp[0] = 1;\n\n        for(auto coin : coins)\n            for(int i = coin; i <= amount; i++)\n                dp[i] += dp[i-coin];\n        \n        return dp[amount];\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374631573","body":"class Solution {\npublic:\n    struct compare {\n        bool operator() (ListNode* a, ListNode* b){\n            return a->val > b->val;\n        }\n    };\n    \n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<ListNode*, vector<ListNode*>, compare> q;\n        ListNode* dummy = new ListNode(-1);\n        ListNode* current_head = dummy;\n        for(int i = 0; i < lists.size(); i++)\n        {\n            if(lists[i] != NULL)\n            {\n                q.push(lists[i]);\n            }\n        }\n        \n\n        while(!q.empty())\n        {\n            current_head->next = q.top();\n            if(q.top()->next)\n                q.push(q.top()->next);\n            q.pop();\n            current_head = current_head->next;\n        }\n        return dummy->next;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298345996","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        strings = ''\n        for i in num:\n            strings += str(i)\n        res = int(strings) + k\n        output = []\n        for i in str(res):\n            output.append(int(i))\n        return output","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304703297","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for index in arr:\n            if stack and stack[-1] > index:\n                current = stack[-1]\n                while stack and stack[-1] > index:\n                    stack.pop()\n                stack.append(current)\n            else:\n                stack.append(index)\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305486823","body":"class Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313542940","body":"public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n\n        if (q.val != p.val) return false;\n\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298416612","body":"### 思路\n\n直接还原num数组的数字加和再放入list——>有数值太大的情况，不行\n\n既然还原数字存在问题那就不还原\n\n-   遍历数组，从后往前的从num中拿出数字 `idxNum = num[length - 1 - i]`，令`k += idxNum`\n\n-   在遍历数组时，不断地对 k 取 10 的余数，然后 add 到 list，但是需要分情况讨论\n\n    -   遍历结束前 k == 0\n\n        在遍历的过程中，不断地对 k 取 10 的余数添加到list，直到 k == 0\n\n    -   遍历结束前 k != 0\n\n        对于这种情况需要进行判断`if (i == length - 1 && k != 0)`，如果满足，就进入循环中，直到 k 为 0\n\n-   最后，使用Collections工具类，将list翻转返回\n\n### 代码\n\n```java\nclass Solution {\n    public ArrayList addToArrayForm(int[] num, int k) {\n        int idxNum, length = num.length;\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxNum = num[length - 1 - i];\n            k += idxNum;\n            if (k != 0) {\n                list.add(k % 10);\n                k = k / 10;\n            } else {\n                list.add(k);\n            }\n            if (i == length - 1 && k != 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N + max(0, K - N))，N为数组的长度，K为k对应数字的长度\n- 空间复杂度：O(N) (不确定)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300132201","body":"### 思路\n\n对数组进行正反两次遍历\n\n-   先正序遍历，尽可能地写入到 answer 数组中\n-   再反序遍历，对于 answer 不为0的位置进行比较更新，对于 answer 为 0 且不是 c 的位置重新赋值\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int currentCharIdx = -1, length = s.length();\n        int[] answer = new int[length];\n\n        // 正序遍历\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n                answer[i] = 0;\n            } else if (currentCharIdx < 0) {\n                answer[i] = 0;\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        // 反序遍历\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n            } else if (answer[i] != 0) {\n                answer[i] = Math.min(answer[i], Math.abs(i - currentCharIdx));\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        return answer;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302000318","body":"### 思路\n\n根据栈的定义，在类中定义一个数组用于存储元素，定义current指针指向栈顶，定义maxSize记录栈的容量\n\n### 代码\n\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int current, maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.current = -1;\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if (current + 1 < maxSize) {\n            current++;\n            stack[current] = x;\n        }\n    }\n\n    public int pop() {\n        if (current > -1) return stack[current--];\n        else return -1;\n    }\n\n    public void increment(int k, int val) {\n        if (current + 1 > k)\n            for (int i = 0; i < k; i++) stack[i] += val;\n        else\n            for (int i = 0; i <= current; i++) stack[i] += val;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：\n\n    - `CustomStack()`O(1)\n\n    - `push()`O(1)\n\n    - `pop()`O(1)\n\n    - `increment()`O(max(k, currentNums)) \n\n        >   `currentNums`是当前栈的大小\n\n- 空间复杂度：O(N) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303514136","body":"### 思路\n\n最后写的脑袋晕晕沉沉，总算是ac了\n\n维护两个stack，一个是数字栈，一个是字符串栈，遍历给定的字符串`char c = s.charAt(i)`：\n\n-   c 是数字\n\n    题目中数字没有限定是个位数，因此需要保留并计算\n\n-   `c == '['`\n\n    此时记录数字完成，开始记录区间内的字符串，因此需要完成：\n\n    -   将记录的数字入栈，数字归零\n    -   将记录的字符串入栈，字符串内容清空\n\n-   c 是字母\n\n    将字母`append`到当前记录的字符串中\n\n-   `c == ']'`\n\n    此时，小区间的字符串记录完成，需要进行解码操作：\n\n    -   获取当前区间对应的重复次数num——数字栈出栈\n    -   获取上一次记录的字符串temp——字符串栈出栈（没有的话是`\"\"`）\n    -   将记录的当前小区间字符串在temp后面添加num次，保留temp\n\n直到遍历完成\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        Stack<Integer> numStack = new Stack<>();\n        Stack<StringBuffer> stringStack = new Stack<>();\n\n        StringBuffer result = new StringBuffer();\n        int multi = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                multi = 10 * multi + c - '0';\n            } else if (c == '[') {\n                stringStack.push(result);\n                numStack.add(multi);\n                result = new StringBuffer();\n                multi = 0;\n            } else if (Character.isAlphabetic(c)) {\n                //记录当前小段的 string\n                result.append(c);\n            } else if (c == ']') {\n                // decode\n                StringBuffer temp = stringStack.pop();\n                multi = numStack.pop();\n                for (int j = 0; j < multi; j++) temp.append(result);\n                multi = 0;\n                result = temp;\n            }\n        }\n        return result.toString();\n    }\n}\n\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1308563165","body":"### 思路\n\n两个栈，一个栈用于中转数据，一个栈用于存储数据。\n\n需要注意的是，在`push()`时调整栈中元素顺序比较方便，否则需要在`pop()`和`peek()`方法中都调整元素顺序\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> storeStack;\n    Stack<Integer> tempStack;\n\n\n    public MyQueue() {\n        this.storeStack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!storeStack.empty()) {\n            tempStack.push(storeStack.pop());\n        }\n        tempStack.push(x);\n        while (!tempStack.empty()) {\n            storeStack.push(tempStack.pop());\n        }\n    }\n\n    public int pop() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.pop();\n    }\n\n    public int peek() {\n        return storeStack.peek();\n    }\n\n    public boolean empty() {\n        return storeStack.empty();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1333792993","body":"### 思路\n\n计数法\n\n当前数组`arr`、排好序的数组`excepted`\n\n如果两个数组从0~n截取的子数组排序后是一样的，那么这两个数组内各个元素的个数都是相等的；反之，则是两个数组则不同\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();\n        int ans = 0, nonZero = 0;\n        int[] excepted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(excepted);\n\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i];\n            int y = excepted[i];\n\n            hashMap.put(x, hashMap.getOrDefault(x, 0) + 1);\n\n            if (hashMap.get(x) == 0) nonZero--;\n\n            if (hashMap.get(x) == 1) nonZero++;\n\n            hashMap.put(y, hashMap.getOrDefault(y, 0) - 1);\n\n            if (hashMap.get(y) == -1) nonZero++;\n\n            if (hashMap.get(y) == 0) nonZero--;\n\n            if (nonZero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1313762132","body":"### 思路\n\n将链表首尾相接，构成环形链表。\n\n节点向右移动k个长度→head向右移动`size - k % size`个长度\n\n将头节点移动后，将其前一个节点与他的连接断开，返回新的头节点即可\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null) return head;\n        ListNode temp = head, tail;\n        int length = 1;\n        while (temp.next != null) {\n            temp = temp.next;\n            length++;\n        }\n        tail = temp;\n        tail.next = head;\n        k = length - k % length;\n        if (k == 0) return head;\n        temp = head;\n        for (int i = 0; i < k; i++) {\n            temp = temp.next;\n        }\n        head = temp;\n        while (temp.next != head) {\n            temp = temp.next;\n            if (temp.next == head) break;\n        }\n        temp.next = null;\n        return head;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307327084","body":"``` JAVA\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode pre = null;\n        ListNode current = head;\n        ListNode next = head.next;\n        ListNode tmp;\n        head = next;\n\n        while (true) {\n            tmp = next.next;\n            current.next = tmp;\n            next.next = current;\n            if (pre != null) {\n                pre.next = next;\n            }\n\n            pre = current;\n            if (pre.next == null) {\n                return head;\n            }\n            current = pre.next;\n            if (pre.next.next == null) {\n                return head;\n            }\n            next = pre.next.next;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308691179","body":"先打卡，明天补全\n``` java\nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return dfs(head, null);\n    }\n\n    private TreeNode dfs(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n\n        ListNode slowNode = head, fastNode = head;\n\n        while (fastNode != tail && fastNode.next != tail) {\n            slowNode = slowNode.next;\n            fastNode = fastNode.next.next;\n        }\n        TreeNode root = new TreeNode();\n        root.val = slowNode.val;\n        root.left = dfs(head, slowNode);\n        root.right = dfs(slowNode.next, tail);\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310228548","body":"``` java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311648965","body":"``` java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n\n        if (head == null) {\n            return null;\n        }\n        ListNode fast = head, slow = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) {\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                // fast or slow\n                return slow;\n            }\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1373467532","body":"### 思路\n\n创建一个HashMap来存储元素，达到以O(1)的时间复杂度进行`get() put()`\n\n### 代码\n\n```java\nclass LRUCache {\n\n    class LRUNode {\n        int key;\n        int value;\n        LRUNode pre;\n        LRUNode next;\n\n        public LRUNode() {\n        }\n\n        public LRUNode(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n\n    int capacity;\n    HashMap<Integer, LRUNode> hashMap;\n    LRUNode head = new LRUNode(-1, -1);\n    LRUNode tail = new LRUNode(-1, -1);\n    // LRUNode temp;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        hashMap = new HashMap<>(capacity);\n        head.next = tail;\n        tail.pre = head;\n    }\n\n    public int get(int key) {\n        if (!hashMap.containsKey(key)) return -1;\n\n        // 获取当前 node\n        LRUNode lruNode = hashMap.get(key);\n\n        if (head.next == lruNode && lruNode.pre == head) {\n            return lruNode.value;\n        }\n\n        lruNode.pre.next = lruNode.next;\n        lruNode.next.pre = lruNode.pre;\n\n        head.next.pre = lruNode;\n        lruNode.next = head.next;\n        head.next = lruNode;\n        lruNode.pre = head;\n        return lruNode.value;\n    }\n\n    public void put(int key, int value) {\n\n        // 判断是否存在 key\n        if (hashMap.containsKey(key)) {\n            LRUNode lruNode = hashMap.get(key);\n            if (value != lruNode.value) lruNode.value = value;\n            if (head.next == lruNode && lruNode.pre == head) return;\n            lruNode.pre.next = lruNode.next;\n            lruNode.next.pre = lruNode.pre;\n            head.next.pre = lruNode;\n            lruNode.next = head.next;\n            head.next = lruNode;\n            lruNode.pre = head;\n            return;\n        }\n\n        // 判断链表是否满了\n        if (hashMap.size() == this.capacity) {\n            hashMap.remove(tail.pre.key);\n            LRUNode pre = tail.pre.pre;\n            pre.next = tail;\n            tail.pre = pre;\n        }\n\n        // 将新的 key 插入到链表中\n        LRUNode lruNode = new LRUNode(key, value);\n        hashMap.put(key, lruNode);\n        head.next.pre = lruNode;\n        lruNode.next = head.next;\n        head.next = lruNode;\n        lruNode.pre = head;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727615","body":"``` java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313649595","body":"### 思路\n\n层序遍历，递归比较每层的节点是否相等\n\n### 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        }\n\n        if (p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(min(M,N))（M、N分别是两棵树的高度）\n- 空间复杂度：O(min(M,N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314829173","body":"### 思路\n\n深度优先，记忆递归\n\n递归回调条件：`root.left == null && root.right == null`\n\n### 代码\n\n```java\nclass Solution {\n    // 记录结果\n    int sum = 0;\n\n    public int sumNumbers(TreeNode root) {\n        // 从根节点开始遍历，传入节点和当前值\n        dfs(root, 0);\n        return sum;\n    }\n\n    private void dfs(TreeNode root, int currentNum) {、\n        // 终止条件\n        if (root.left == null && root.right == null) {\n            sum = currentNum * 10 + root.val + sum;\n            return;\n        }\n        currentNum = currentNum * 10 + root.val;\n        // 递归调用\n        if (root.left != null) dfs(root.left, currentNum);\n        if (root.right != null) dfs(root.right, currentNum);\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n\n- 空间复杂度：O(H)\n\n    >N为节点数，H为树高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316947217","body":"### 思路\n\n要找左下角的元素，第一想到了层序遍历，记录每层第一个节点的值。\n\n### 代码\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        return bfs(root);\n    }\n\n    private int bfs(TreeNode node) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(node);\n        int res = 0;\n        while (queue.size() > 0) {\n            Queue<TreeNode> currentLayer = queue;\n            queue = new LinkedList<>();\n            int size = currentLayer.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode currentNode = currentLayer.poll();\n                // 记录每层第一个节点值\n                if (i == 0) res = currentNode.val;\n                if (currentNode.left != null) queue.add(currentNode.left);\n                if (currentNode.right != null) queue.add(currentNode.right);\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318648645","body":"``` java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n\n        if (root == null) {\n            return \"\";\n        }\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                sb.append(node.val + \",\");\n                queue.add(node.left);\n                queue.add(node.right);\n            } else {\n                sb.append(\"X,\");\n            }\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == \"\" || data == null) {\n            return null;\n        }\n        Queue<String> queueString = new LinkedList<>(Arrays.asList(data.split(\",\")));\n        TreeNode root = new TreeNode(Integer.parseInt(queueString.poll()));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (!queueString.isEmpty()) {\n\n            TreeNode node = queue.poll();\n            String left = queueString.poll();\n            String right = queueString.poll();\n\n            if (!Objects.equals(left, \"X\")) {\n                assert node != null;\n                node.left = new TreeNode(Integer.parseInt(left));\n                queue.add(node.left);\n            }\n            if (!Objects.equals(right, \"X\")) {\n                assert node != null;\n                node.right = new TreeNode(Integer.parseInt(right));\n                queue.add(node.right);\n            }\n        }\n\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319953182","body":"``` java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    // 列\n    int col = 0;\n    // 排\n    int row = 0;\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n\n        List<int[]> list = new ArrayList<>();\n        dfs(root, col, row, list);\n\n        if (list == null) {\n            return null;\n        }\n        list.sort(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[0] == o2[0] && o1[1] == o2[1]) {\n                    return o1[2] - o2[2];\n                }\n                if (o1[0] == o2[0]) {\n                    return o1[1] - o2[1];\n                }\n                return o1[0] - o2[0];\n            }\n        });\n        List<List<Integer>> resList = new ArrayList<>();\n\n        int currentCol = Integer.MIN_VALUE;\n        for (int i = 0; i < list.size(); i++) {\n            int col = list.get(i)[0];\n            if (currentCol == col) {\n                resList.get(resList.size() - 1).add(list.get(i)[2]);\n                continue;\n            }\n            currentCol = col;\n            List<Integer> tempList = new ArrayList<>();\n            tempList.add(list.get(i)[2]);\n            resList.add(tempList);\n        }\n\n\n        return resList;\n    }\n\n    private void dfs(TreeNode node, int col, int row, List<int[]> nodeList) {\n        if (node == null) {\n            return;\n        }\n        nodeList.add(new int[]{col, row, node.val});\n        // 深度优先\n        dfs(node.left, col - 1, row + 1, nodeList);\n        dfs(node.right, col + 1, row + 1, nodeList);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1322064052","body":"### 思路\n\n暴力解法，将所有的数放到HashSet中，然后依次遍历\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) set.add(num);\n        Integer remain;\n        int[] res = new int[]{};\n        for (int i = 0; i < nums.length; i++) {\n            remain = target - nums[i];\n            if (set.contains(remain)) {\n                for (int j = 0; j < nums.length; j++) {\n                    if (i != j && nums[j] == remain) {\n                        res = new int[]{i, j};\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O($$N^2$$)\n- 空间复杂度：O(N)\n\n\n\n\n\n\n\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322065007","body":"``` java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n\n    \n        if (points.length < 3) {\n            return 0;\n        }\n        int ans = 0;\n        int length = points.length;\n\n        for (int i = 0; i < points.length; i++) {\n            HashMap<Integer, Integer> hashMap = new HashMap<>();\n            for (int j = 0; j < points.length; j++) {\n                if (i == j) {\n                    continue;\n                }\n                int distance =\n                        (points[i][0] - points[j][0]) * (points[i][0] - points[j][0]) +\n                                (points[i][1] - points[j][1]) * (points[i][1] - points[j][1]); \n                hashMap.put(distance, hashMap.containsKey(distance) ? hashMap.get(distance) + 1 : 1);\n            }\n            for (Integer value : hashMap.values()) {\n                if (value >= 2) {\n                    ans += value * (value - 1);\n                }\n            }\n\n        }\n\n\n        return ans;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323750152","body":"``` java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n           HashMap<Character,Integer> window=new HashMap<>();\n        int left=0,right=0;\n        int res=0;\n        while(right<s.length()){\n            char c=s.charAt(right);\n            right++;\n            window.put(c,window.getOrDefault(c,0)+1);\n            while (window.get(c)>1){\n                char d=s.charAt(left);\n                left++;\n                window.put(d,window.get(d)-1);\n            }\n            res=Math.max(res,right-left);\n        }\n        return res;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326509065","body":"``` java\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> record = {{0, 1}};\n        int sum = 0, ans = 0;\n        for (int elem: nums) {\n            sum += elem;\n            int modulus = (sum % k + k) % k;\n            if (record.count(modulus)) {\n                ans += record[modulus];\n            }\n            ++record[modulus];\n        }\n        return ans;\n    }\n};\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327379660","body":"### 思路\n\n快慢指针，快指针到了尾端，慢指针正好在中间\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328944245","body":"``` java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int j = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328945011","body":"``` java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329316437","body":"```\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330763943","body":"``` java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[][] trustGraph = new int[n][2];\n\n        for (int i = 0; i < trust.length; i++) {\n            int person = trust[i][0];\n            int trustPerson = trust[i][1];\n            trustGraph[person - 1][0]++;\n            trustGraph[trustPerson - 1][1]++;\n        }\n\n        for (int i = 0; i < trustGraph.length; i++) {\n            if (trustGraph[i][0] == 0 && trustGraph[i][1] == n - 1) {\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332071892","body":"``` java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        for (int i = 1; i <= n; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge : dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= n; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0)) return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node)) return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei : graph[node])\n            if (!dfs(nei, c ^ 1)) return false;\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333795065","body":"so hard\n``` java\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335430720","body":"``` java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n\n        if (moves == null || moves.length() == 0) {\n            return true;\n        }\n\n        //int[] position = new int[]{0, 0};\n        int x = 0, y = 0;\n\n        for (char c : moves.toCharArray()) {\n\n            switch (c) {\n                case 'R' -> x++;\n                case 'L' -> x--;\n                case 'U' -> y++;\n                case 'D' -> y--;\n            }\n\n        }\n        return (x == 0 && y == 0);\n    }\n    \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1337166388","body":"``` java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n\n        // tasks 的指针、系统当前时间\n        int length = tasks.length, point = 0, systemTime = 0, resultPoint = 0;\n        int result[] = new int[length];\n        int[][] tasksIds = new int[length][3];\n\n        // 为 tasks 添加 id\n        for (int i = 0; i < tasksIds.length; i++) {\n            tasksIds[i][0] = tasks[i][0];\n            tasksIds[i][1] = tasks[i][1];\n            tasksIds[i][2] = i;\n        }\n        \n        // 按照 tasks 的执行时间先后进行排序\n        Arrays.sort(tasksIds, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n        // 优先队列，[执行时间][任务id] --> 队列中选择时间最短的任务执行，多个最短时间任务选择下表最小的\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                return o1[0] == o2[0] ? o1[1] - o2[1] : o1[0] - o2[0];\n            }\n        });\n        while (point < length) {\n            // 当任务列表中的加入时间小于当前系统时间，就把任务加入到队列中\n            // 直到当前时间内的任务都添加到队列\n            while (point < length && tasksIds[point][0] <= systemTime) {\n                queue.add(new int[]{tasksIds[point][1], tasksIds[point][2]});\n                point++;\n            }\n\n            if (queue.isEmpty()) {\n                // 队列为空，跳过执行过程，系统时间赋值为下一个任务的开始时间\n                systemTime = tasksIds[point][0];\n            } else {\n                // 队列不为空，执行任务，把任务id写入到结果中\n                int[] poll = queue.poll();\n                result[resultPoint] = poll[1];\n                systemTime += poll[0];\n                resultPoint++;\n            }\n        }\n        while (!queue.isEmpty()) {\n            result[resultPoint++] = queue.poll()[1];\n        }\n        return result;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1337167673","body":"``` java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n\n        String[] loginTimes = loginTime.split(\":\");\n        String[] logoutTimes = logoutTime.split(\":\");\n\n        int nums = 0;\n        int startTime = Integer.parseInt(loginTimes[0]) * 60 + Integer.parseInt(loginTimes[1]);\n        int endTime = Integer.parseInt(logoutTimes[0]) * 60 + Integer.parseInt(logoutTimes[1]);\n\n        if (endTime < startTime) {\n            endTime += (60 * 24);\n        }\n\n        endTime = endTime / 15 * 15;\n\n        return Math.max(0, (endTime - startTime)) / 15;\n\n\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337172270","body":"``` java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339406294","body":"``` java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            int j = i - 1;\n            while (j > -1 && nums[j] > num) {\n                nums[j + 1] = nums[j];\n                j--;\n            }\n            nums[j + 1] = num;\n        }\n\n        return nums;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341012023","body":"``` java\nclass Solution {\n    public int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n        int ans = (int) Math.exp(0.5 * Math.log(x));\n        return (long) (ans + 1) * (ans + 1) <= x ? ans + 1 : ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342714199","body":"``` java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) { // 循环直至区间左右端点相同\n            int mid = left + (right - left) / 2; // 防止计算时溢出\n            if (isBadVersion(mid)) {\n                right = mid; // 答案在区间 [left, mid] 中\n            } else {\n                left = mid + 1; // 答案在区间 [mid+1, right] 中\n            }\n        }\n        // 此时有 left == right，区间缩为一个点，即为答案\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344324206","body":"``` java\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345290777","body":"``` JAVA\nclass Solution {\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348431118","body":"``` java\nclass Solution {\n    public int maxVowels(String s, int k) {\n\n        HashSet<Character> vowelSet = new HashSet<>();\n        vowelSet.add('a');\n        vowelSet.add('e');\n        vowelSet.add('i');\n        vowelSet.add('o');\n        vowelSet.add('u');\n        char[] charArray = s.toCharArray();\n        int right, result = 0, temp = 0;\n\n        // 初始化窗口\n        for (int i = 0; i < k; i++) {\n            if (vowelSet.contains(charArray[i])) {\n                temp += 1;\n            }\n        }\n        result = Math.max(temp, result);\n\n        for (right = k; right < charArray.length; right++) {\n            if (vowelSet.contains(charArray[right])) temp++;\n            if (vowelSet.contains(charArray[right - k])) temp--;\n            result = Math.max(temp, result);\n        }\n\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350913156","body":"``` java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353187194","body":"``` JAVA\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1355103142","body":"``` java\nclass Solution {\n    Map<Character, Integer> ori = new HashMap<Character, Integer>();\n    Map<Character, Integer> cnt = new HashMap<Character, Integer>();\n\n    public String minWindow(String s, String t) {\n        int tLen = t.length();\n        for (int i = 0; i < tLen; i++) {\n            char c = t.charAt(i);\n            ori.put(c, ori.getOrDefault(c, 0) + 1);\n        }\n        int l = 0, r = -1;\n        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;\n        int sLen = s.length();\n        while (r < sLen) {\n            ++r;\n            if (r < sLen && ori.containsKey(s.charAt(r))) {\n                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                    ansR = l + len;\n                }\n                if (ori.containsKey(s.charAt(l))) {\n                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);\n                }\n                ++l;\n            }\n        }\n        return ansL == -1 ? \"\" : s.substring(ansL, ansR);\n    }\n\n    public boolean check() {\n        Iterator iter = ori.entrySet().iterator(); \n        while (iter.hasNext()) { \n            Map.Entry entry = (Map.Entry) iter.next(); \n            Character key = (Character) entry.getKey(); \n            Integer val = (Integer) entry.getValue(); \n            if (cnt.getOrDefault(key, 0) < val) {\n                return false;\n            }\n        } \n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356315724","body":"``` JAVA\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int len = cardPoints.length;\n        int[] preSum = new int[len + 1];\n        for (int i = 1; i <= len; i++) {\n            preSum[i] = preSum[i - 1] + cardPoints[i - 1];\n        }\n\n        int max = 0;\n        for (int i = 0; i <= k; i++) {\n            int score = preSum[i] + preSum[len] - preSum[len - k + i];\n            max = Math.max(score, max);\n        }\n        return max;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361314183","body":"``` java\nclass Solution {\n    int[][] grid;\n    int[] x = {-1, 0, 1, 0};\n    int[] y = {0, -1, 0, 1};\n    int n;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int maxManhattanDistance = -1;\n\n        for (int row = 0; row < grid.length; row++) {\n            for (int column = 0; column < grid.length; column++) {\n\n                if (grid[row][column] == 0) {\n                    maxManhattanDistance = Math.max(maxManhattanDistance, detectDistance(row, column));\n                }\n\n            }\n\n        }\n        return maxManhattanDistance;\n    }\n\n\n    private int detectDistance(int row, int column) {\n\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] searched = new boolean[n][n];\n\n        queue.offer(new int[]{row, column, 0});\n        searched[row][column] = true;\n        while (!queue.isEmpty()) {\n            int[] poll = queue.poll();\n            // 然后遍历四个方向 左下右上 四个子节点\n            for (int i = 0; i < 4; i++) {\n                int detectX = poll[0] + x[i];\n                int detectY = poll[1] + y[i];\n                if (detectX < 0 || detectX >= grid.length || detectY < 0 || detectY >= grid.length) {\n                    continue;\n                }\n                // 这次bfs中没有遍历到这个点\n                if (!searched[detectX][detectY]) {\n                    // 先把其子节点加入到队列中\n                    queue.offer(new int[]{detectX, detectY, poll[2] + 1});\n                    // 标记已经遍历过这个点了\n                    searched[detectX][detectY] = true;\n                    // 找到了土地 返回此时的距离\n                    if (grid[detectX][detectY] == 1) {\n                        return poll[2] + 1;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364544706","body":"``` java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n\n        if (cost == null || cost.length <= 1) {\n            return 0;\n        }\n        int[] dp = new int[cost.length + 1];\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n\n        for (int i = 2; i <= cost.length; i++) {\n            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + (i == cost.length ? 0 : cost[i]);\n        }\n        return dp[cost.length];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364692725","body":"``` java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        // 子问题：\n        // f(k) = 偷 [0..k) 房间中的最大金额\n\n        // f(0) = 0\n        // f(1) = nums[0]\n        // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n\n        int N = nums.length;\n        int[] dp = new int[N+1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        for (int k = 2; k <= N; k++) {\n            dp[k] = Math.max(dp[k-1], nums[k-1] + dp[k-2]);\n        }\n        return dp[N];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365259145","body":"``` java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int length = nums.length;\n        int maxLength = 1;\n        int res = 0;\n        // dp[i][0] 表示 以 nums[i] 结尾的最长上升子序列的长度\n        // dp[i][1] 表示 以 nums[i] 结尾的长度为 dp[i][0] 的子序列的个数。\n        // 最长递增子序列的长度最少为 1\n        \n        int[][] dp = new int[length][2];\n        for (int i = 0; i < length; i++) {\n            Arrays.fill(dp[i], 1);\n        }\n\n        for (int i = 0; i < length; i++) {\n            for (int j = i + 1; j < length; j++) {\n                // 可以拼接\n                if (nums[j] > nums[i]) {\n                    // 在 j 处拼接后，判断序列是否变长了\n                    if (dp[i][0] + 1 > dp[j][0]) {\n                        // 以 nums[j] 结尾的最长上升子序列长度，在前面的基础 +1\n                        dp[j][0] = dp[i][0] + 1;\n                        dp[j][1] = dp[i][1];\n                        maxLength = Math.max(maxLength, dp[j][0]);\n                    } else if (dp[i][0] + 1 == dp[j][0]) {\n                        dp[j][1] += dp[i][1];\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < length; i++) {\n            if (dp[i][0] == maxLength) {\n                res += dp[i][1];\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365992063","body":"``` java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n = text1.length();\n        int m = text2.length();\n        char[] charArray1 = text1.toCharArray();\n        char[] charArray2 = text2.toCharArray();\n        int[][] dp = new int[n + 1][m + 1];\n        int ans = 0;\n\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                if (charArray1[i-1] == charArray2[j-1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    ans = Math.max(ans, dp[i][j]);\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366705556","body":"``` java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        // 优化方式\n        // 第 i 行 第 j 列的可能数目\n        int[] dp = new int[n];\n        // 这是第 1（index= 0） 行的数目\n        Arrays.fill(dp, 1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n        return dp[n - 1];\n    }\n}\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370936105","body":"``` java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n\n        int childrenNums = g.length, cookiesNums = s.length,\n                res = 0, maxContentNum = Math.min(childrenNums, cookiesNums);\n        Arrays.sort(g);\n        Arrays.sort(s);\n\n        int currentChild = 0, currentCookie = 0;\n\n        while (res < maxContentNum && currentCookie < cookiesNums && currentChild < childrenNums) {\n            // 当前 cookie 可以满足这个孩子\n            if (g[currentChild] <= s[currentCookie]) {\n                res++;\n                currentCookie++;\n                currentChild++;\n            } else {\n                currentCookie++;\n            }\n        }\n\n        return res;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374507450","body":"``` java\nclass Solution {\n\n    private HashMap<Integer, Integer> hashMap;\n    \n    public int numTrees(int n) {\n        hashMap = new HashMap<>(n + 1);\n        hashMap.put(1, 1);\n        hashMap.put(0, 1);\n        return dp(n);\n    }\n\n    public int dp(int n) {\n        if (hashMap.containsKey(n)) return hashMap.get(n);\n        int res = 0;\n        for (int i = 1; i <= n; i++) {\n            res += dp(i - 1) * dp(n - i);\n        }\n        hashMap.put(n, res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297919309","body":"## 思路\r\n\r\n\r\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''.join(map(str, num))\r\n        sum = int(x) + k\r\n        return list(map(int, str(sum)))\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299640797","body":"## 思路\r\n\r\n\r\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [n for i in range(n)]\r\n        dist = n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1 \r\n            ans[i] = dist\r\n        for j in range(n-1, -1, -1):\r\n            if s[j] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1\r\n            ans[j] = min(dist, ans[j])\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302069633","body":"## 思路\r\n\r\n\r\n用数组模拟栈操作\r\n\r\n## 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n            \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.size)):\r\n            self.stack[i] += val\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push：****$O(1)$， ****pop：****$O(1)$， ****increment：****$O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303062796","body":"## 思路\r\n\r\n---\r\n\r\n双栈，一个栈存放数字，一个栈存放字母\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                tmpstr = \"\"\r\n                numstr = \"\"\r\n                while stack and stack[-1] != \"[\":\r\n                    char = stack.pop()\r\n                    tmpstr = char + tmpstr\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop()\r\n                    numstr = num + numstr\r\n                stack.append(int(numstr) * tmpstr)\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427028","body":"## 思路\r\n\r\n\r\n使用两个栈（先进后出）实现队列（先进先出），一个栈用来存储元素\r\n\r\n## 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.stack1:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push:**** $O(N)$ ****pop:**** $O(1)$ ****peek:**** $O(1)$  ****empty:**** $O(1)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304997160","body":"## 思路\r\n\r\n\r\n从左向右遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        n = len(arr)\r\n        for i in range(n):\r\n            m = arr[i]\r\n            while stack and stack[-1] > arr[i]:\r\n                m = max(stack.pop(), m)\r\n            stack.append(m)\r\n        return len(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305617402","body":"## 思路\r\n\r\n\r\n遍历链表得到链表长度，连接链表首尾形成环形链表，然后根据移动的距离断开链表。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next or k==0: return head\r\n        n_nodes = 1\r\n        tail = p = head\r\n        while tail.next:\r\n            n_nodes += 1\r\n            tail = tail.next\r\n        tail.next = head\r\n\r\n        for _ in range(n_nodes - k%n_nodes - 1):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n\r\n        return new_head\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307173696","body":"## 思路\r\n\r\n---\r\n\r\n迭代的方法，由preA -> A -> B ->nextB 修改为 preA ->B ->A ->nextB，交换两个节点位置，经过3次操作A.next = B.next; B.next = A; preA.next = B. \r\n\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n\r\n        new_head = ListNode(next = head)\r\n        prev = new_head\r\n        cur = head\r\n        while cur and cur.next:\r\n            n_node = cur.next\r\n            cur.next = n_node.next\r\n            n_node.next = cur\r\n\r\n            prev.next = n_node\r\n            prev = cur\r\n            cur = cur.next\r\n        return new_head.next\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308610220","body":"## 思路\r\n\r\n\r\n使用快慢指针找到二叉树的根节点，中点左边的值构造左子树，右边的值构造右子树；最后递归链表生成二叉树。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        return self.buildTree(head, None)\r\n        \r\n    def buildTree(self, head, tail):\r\n        if head == tail: return\r\n        slow = head\r\n        fast = head\r\n        while fast != tail and fast.next != tail:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        root = TreeNode(slow.val)\r\n        root.left = self.buildTree(head, slow)\r\n        root.right = self.buildTree(slow.next, tail)\r\n        return root\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(nlogn)$\r\n- **Space:** $O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309717348","body":"## 思路\r\n\r\n\r\n使用两个指针分别指向两条链表的头节点。当a到达链表A的尾部，将它重定位到链表B的头节点；b同理。在此过程中a、b指针相遇，相遇节点则为两链表相交的起始节点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        a = headA\r\n        b = headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1312734521","body":"## 思路\r\n\r\n\r\n快慢两个指针，从head结点走到入环点需要走a + nb， 而slow已经走了nb，那么slow再走a步即为入环点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(1)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312982036","body":"## 思路\r\n\r\n\r\n哈希表加双向链表\r\n\r\n## 代码\r\n\r\n```python\r\nclass ListNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def move_node_to_tail(self, key):\r\n        node = self.hashmap[key]\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev.next = node\r\n        self.tail.prev = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            self.move_node_to_tail(key)\r\n        res = self.hashmap.get(key, -1)\r\n        if res == -1:\r\n            return res\r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            self.hashmap[key].value = value\r\n            self.move_node_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                self.hashmap.pop(self.head.next.key)\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head\r\n            new = ListNode(key, value)\r\n            self.hashmap[key] = new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail\r\n            self.tail.prev.next = new\r\n            self.tail.prev = new\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(1)$\r\n- **Space:** $O(N)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1313049274","body":"## 思路\r\n\r\n\r\nDFS；递归很好用\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root == None:\r\n            return 0\r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n        return max(left_depth, right_depth) + 1\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- ***Space:*** $O(h)$ ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313160627","body":"## 思路\r\n\r\n\r\n深度优先搜索，递归的判断是否相同\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(min(m,n))$, m和n分别为两个二叉树的节点数\r\n- **Space:** $O(min(m,n))$, m和n分别为两个二叉树的节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265470","body":"## 思路\r\n\r\n\r\n深度优先搜索，遍历每个节点然后分别对左右子节点进行递归。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        def dfs(root, prevTotal):\r\n            if not root: \r\n                return 0\r\n            total = prevTotal * 10 + root.val\r\n            if not root.left and not root.right:\r\n                return total\r\n            else:\r\n                return dfs(root.left, total) + dfs(root.right, total)\r\n        return dfs(root, 0)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$, n是二叉树节点个数\r\n- **Space:** $O(n)$, n是二叉树节点个数","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318189889","body":"## 思路\r\n\r\n\r\nDFS前序遍历\r\n\r\n## 代码\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        def preorder(root):\r\n            if not root:\r\n                return \"null,\"\r\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\r\n\r\n        return preorder(root)[:-1]\r\n\r\n    def deserialize(self, data: str):\r\n        nodes = data.split(\",\")\r\n\r\n        def preorder(i):\r\n            if i >= len(nodes) or nodes[i] == \"null\":\r\n                return i, None\r\n            root = TreeNode(nodes[i])\r\n            j, root.left = preorder(i + 1)\r\n            k, root.right = preorder(j + 1)\r\n            return k, root\r\n\r\n        return preorder(0)[1]\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$, N是二叉树节点个数\r\n- **Space:** $O(h)$, h是树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319782307","body":"## 思路\r\n\r\n\r\n遍历一遍二叉树的节点，保存节点的横纵坐标和节点的值，根据纵坐标，横坐标，节点的值依次排序，再遍历一遍将每一列的节点的值取出。\r\n\r\n## 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = []\r\n        def dfs(root, row, col):\r\n            if not root: return None\r\n            nodes.append((col, row, root.val))\r\n            dfs(root.left, row+1, col-1)\r\n            dfs(root.right, row+1, col+1)\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans = []\r\n        i = j = 0\r\n        while i < len(nodes):\r\n            col_ans = []\r\n            while j< len(nodes) and nodes[j][0] == nodes[i][0]:\r\n                col_ans.append(nodes[j][2])\r\n                j += 1\r\n            ans.append(col_ans)\r\n            i = j\r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n\r\n- 时间复杂度：O(NlogN),N是节点的数量\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320825254","body":"## 思路\r\n\r\n\r\n使用哈希表\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        n = len(nums)\r\n        for i in range(1, n):\r\n            temp = nums[:i]\r\n            if (target - nums[i]) in temp:\r\n                j = temp.index(target - nums[i])\r\n                break\r\n        return [i,j]\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321148820","body":"## 思路\r\n\r\n\r\n使用哈希表+堆排序\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        count = list(collections.Counter(nums).items())\r\n        count = list(map(lambda x: (-x[1], x[0]), count))\r\n        heapq.heapify(count)\r\n        res = []\r\n        for _ in range(k):\r\n            res.append(heapq.heappop(count)[1])\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(klogM)$\r\n- **Space:** $O(M),M是不同元素个数$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322186038","body":"## 思路\r\n\r\n\r\n枚举每个距离相等的点，从其中选出两个端点。考虑顺序，将每个点作为原点遍历之后累加。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for p in points:\r\n\t      cnt = defaultdict(int)\r\n\t      for q in points:\r\n\t\t    dis = (p[0]-q[0]) * (p[0]-q[0]) + (p[1]-q[1]) * (p[1]-q[1])\r\n\t\t    cnt[dis] += 1\r\n\t      for m in cnt.values():\r\n\t\t    ans += m * (m-1)\r\n\t return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n2)$，n为数组长度\r\n- **Space:** $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323852561","body":"## 思路\r\n\r\n\r\n判断元素是否在滑动窗口内\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        a = []\r\n        res = 0\r\n        for i in s:\r\n            if i in a:\r\n                a = a[a.index(i) + 1:]\r\n            a.append(i)\r\n            res = max(res, len(a))\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325290958","body":"## 思路\r\n\r\n\r\n前缀和：子数组 A[i:j] 的和就是 pres[j] - pres[i-1]，其中 pres 为 A 的前缀和。\r\n同余：两个模k余数相同的数字相减，得到的值定可以被k整除。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- **Space:** $O(min(n,k))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326617633","body":"## 思路\r\n\r\n\r\n使用快慢指针，当快指针走到链表尾部，慢指针刚好走到中间\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head is None:\r\n            return None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为链表长度\r\n- ***Space:***","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327997903","body":"## 思路\r\n\r\n\r\n使用双指针，快指针遍历每个位置，当元素不同时，将此值赋给慢指针位置\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        fast = slow = 1\r\n        while fast < len(nums):\r\n            if nums[fast] != nums[fast - 1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        return slow\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- **Space:** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328272559","body":"## 思路\r\n\r\n---\r\n\r\n二分法\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left, right = 0, len(nums) - 1\r\n\r\n        while left <= right:\r\n            middle = (left + right) // 2\r\n\r\n            if nums[middle] < target:\r\n                left = middle + 1\r\n            elif nums[middle] > target:\r\n                right = middle - 1\r\n            else:\r\n                return middle\r\n        return right + 1\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(logn)$，n为数组长度\r\n- ***Space:*** $O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329313914","body":"## 思路\r\n\r\n\r\n用双端队列保存滑动窗口最大值，移除失效元素\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        q, res = [], []\r\n        for i, num in enumerate(nums):\r\n            while q and q[-1][1] < num:\r\n                q.pop()\r\n            q.append((i, num))\r\n            while i - q[0][0] >= k:\r\n                q.pop(0)\r\n            if i >= k-1:\r\n                res.append(q[0][1])\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- ***Space:*** $O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330826217","body":"## 思路\r\n\r\n---\r\n\r\n求图的入度和出度，找到入度为n-1，出度为0的点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n     def findJudge(self, N, trust):\r\n        count = [0] * (N + 1)\r\n        for i, j in trust:\r\n            count[i] -= 1\r\n            count[j] += 1\r\n        for i in range(1, N + 1):\r\n            if count[i] == N - 1:\r\n                return i\r\n        return -1\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(n)$，n为数组长度\r\n- ***Space:*** $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332362931","body":"## 思路\r\n\r\n---\r\n\r\n建立并遍历图，使用染色法给图中的点进行分组。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def dfs(self, graph, colors, i, color, N):\r\n        colors[i] = color\r\n        for j in range(N):\r\n            # dislike eachother\r\n            if graph[i][j] == 1:\r\n                if colors[j] == color:\r\n                    return False\r\n                if colors[j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\r\n                    return False\r\n        return True\r\n\r\n    def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:\r\n        graph = [[0] * N for i in range(N)]\r\n        colors = [0] * N\r\n        for a, b in dislikes:\r\n            graph[a - 1][b - 1] = 1\r\n            graph[b - 1][a - 1] = 1\r\n        for i in range(N):\r\n            if colors[i] == 0 and not self.dfs(graph, colors, i, 1, N):\r\n                return False\r\n        return True\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(m+n)$，m和n分别为图中点和边的数目\r\n- ***Space:*** $O(m^2)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1336184017","body":"## 思路\r\n\r\n---\r\n\r\n模拟字符串的移动。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        x = y = 0\r\n        for move in moves:\r\n            if move == 'R':\r\n                x += 1\r\n            if move == 'L':\r\n                x -= 1\r\n            if move == 'U':\r\n                y += 1\r\n            if move == 'D':\r\n                y -= 1\r\n        return x == 0 and y == 0\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(n)$，n为字符串moves的长度\r\n- ***Space:*** $O(1)$","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1337599682","body":"## 思路\r\n\r\n---\r\n\r\n对开始时间和结束时间做规范化处理，然后模拟游戏时间进行判断。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        sh, sm = map(int, loginTime.split(\":\"))\r\n        eh, em = map(int, logoutTime.split(\":\"))\r\n        d = 0\r\n        if sh * 60 + sm > eh * 60 + em:\r\n            d += 1\r\n        if 0 < sm <= 15:\r\n            sm = 15\r\n        elif 15 < sm <= 30:\r\n            sm = 30\r\n        elif 30 < sm <= 45:\r\n            sm = 45\r\n        elif 45 < sm <= 60:\r\n            sm = 0\r\n            sh += 1\r\n        if 0 <= em < 15:\r\n            em = 0\r\n        elif 15 <= em < 30:\r\n            em = 15\r\n        elif 30 <= em < 45:\r\n            em = 30\r\n        elif 45 <= em < 60:\r\n            em = 45\r\n        st = sh * 60 + sm\r\n        et = eh * 60 + em\r\n        if d == 1:\r\n            et += 24 * 60\r\n        return max(0, (et - st)) // 15\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(1)$\r\n- ***Space:*** $O(1)$","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341139622","body":"## 思路\r\n\r\n---\r\n\r\n二分法：寻找最右边的满足条件的值\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        ans, l, r = 0, 0, x\r\n        while l <= r:\r\n            mid = (l + r) // 2  (取整除，向下取整)\r\n            if mid ** 2 > x:\r\n                r = mid - 1\r\n            if mid ** 2 <= x:\r\n                ans = mid\r\n                l = mid + 1\r\n        return int(ans)\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(logx)$\r\n- ***Space:*** $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345267969","body":"## 思路\r\n\r\n---\r\n\r\n二分法：寻找最左边的满足条件的值\r\n\r\n## 代码\r\n\r\n```python\r\nfrom sortedcontainers import SortedList\r\nclass Solution:\r\n    def solve(self, A):\r\n        d = SortedList()\r\n        ans = 0\r\n\r\n        for a in A:\r\n            i = d.bisect_right(a * 3)\r\n            ans += len(d) - i\r\n            d.add(a)\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(nlogn)$\r\n- ***Space:*** $O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353266710","body":"## 思路\r\n\r\n---\r\n\r\n哈希表+滑动窗口。value为0时，移除key，哈希表容量为0时，说明找到了一个异位词。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        target = collections.Counter(p)  # Counter(计数器)追踪值的出现次数，用字典存储(key=值，value=出现次数)\r\n        ans = []\r\n        for i in range(len(s)):\r\n            if i >= len(p):\r\n                target[s[i - len(p)]] += 1\r\n                if target[s[i - len(p)]] == 0:\r\n                    del target[s[i - len(p)]]  # 列表操作，删除一个或几个元素\r\n            target[s[i]] -= 1\r\n            if target[s[i]] == 0:\r\n                del target[s[i]]\r\n            if len(target) == 0:\r\n                ans.append(i - len(p) + 1)\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(n)$，s长度为n\r\n- ***Space:*** $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1357766047","body":"## 思路\r\n\r\n---\r\n\r\n笛卡尔积问题\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def readBinaryWatch(self, num: int) -> List[str]:\r\n        def possible_number(count, minute=False):\r\n            if count == 0: return [0]\r\n            if minute:\r\n                return filter(lambda a: a < 60, map(sum, combinations([1, 2, 4, 8, 16, 32], count)))\r\n            return filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count)))\r\n        ans = set()\r\n        for i in range(min(4, num + 1)):\r\n            for a in possible_number(i):\r\n                for b in possible_number(num - i, True):\r\n                    ans.add(str(a) + \":\" + str(b).rjust(2, '0'))\r\n        return list(ans)\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(N)$\r\n- ***Space:*** $O(N)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357748016","body":"## 思路\r\n\r\n---\r\n\r\n每次获得可以放置皇后的位置中的最低位，并将该位的值置成 0，尝试在该位置放置皇后。这样即可遍历每个可以放置皇后的位置。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def totalNQueens(self, n: int) -> int:\r\n        def solve(row: int, columns: int, diagonals1: int, diagonals2: int) -> int:\r\n            if row == n:\r\n                return 1\r\n            else:\r\n                count = 0\r\n                availablePositions = ((1 << n) - 1) & (~(columns | diagonals1 | diagonals2))\r\n                while availablePositions:\r\n                    position = availablePositions & (-availablePositions)\r\n                    availablePositions = availablePositions & (availablePositions - 1)\r\n                    count += solve(row + 1, columns | position, (diagonals1 | position) << 1, (diagonals2 | position) >> 1)\r\n                return count\r\n\r\n        return solve(0, 0, 0, 0)\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(N!)$，N为皇后个数\r\n- ***Space:*** $O(N)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363971004","body":"# [91-53]Top-View-of-a-Tree\r\n\r\n## 思路\r\n\r\n---\r\n\r\nBFS层次遍历\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def solve(self, root):\r\n        q = collections.deque([(root, 0)])\r\n        d = {}\r\n        while q:\r\n            cur, pos = q.popleft()\r\n            if pos not in d:\r\n                d[pos] = cur.val\r\n            if cur.left:\r\n                q.append((cur.left, pos - 1))\r\n            if cur.right:\r\n                q.append((cur.right, pos + 1))\r\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(nlogn)$，令n节点数。\r\n- ***Space:*** $O(n)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365190958","body":"## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n = len(nums)\r\n        # dp[i][0] ->  LIS\r\n        # dp[i][1] -> NumberOfLIS\r\n        dp = [[1, 1] for i in range(n)]\r\n        ans = [1, 1]\r\n        longest = 1\r\n        for i in range(n):\r\n            for j in range(i + 1, n):\r\n                if nums[j] > nums[i]:\r\n                    if dp[i][0] + 1 > dp[j][0]:\r\n                        dp[j][0] = dp[i][0] + 1\r\n                        # 下面这行代码容易忘记，导致出错\r\n                        dp[j][1] = dp[i][1]\r\n                        longest = max(longest, dp[j][0])\r\n                    elif dp[i][0] + 1 == dp[j][0]:\r\n                        dp[j][1] += dp[i][1]\r\n        return sum(dp[i][1] for i in range(n) if dp[i][0] == longest)\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(N^2)$，令N为数组长度。\r\n- ***Space:*** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365965257","body":"## 思路\r\n\r\n---\r\n\r\ndp建模套路\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\r\n        m, n = len(A), len(B)\r\n        ans = 0\r\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\r\n        for i in range(1, m + 1):\r\n            for j in range(1, n + 1):\r\n                if A[i - 1] == B[j - 1]:\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1\r\n                    ans = max(ans, dp[i][j])\r\n                else:\r\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(m*n)$，m和n分别为A和B的长度。\r\n- ***Space:*** $O(m*n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366697326","body":"## 思路\r\n\r\n---\r\n\r\n动态规划建模\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        d = [[1] * n for _ in range(m)]\r\n\r\n        for col in range(1, m):\r\n            for row in range(1, n):\r\n                d[col][row] = d[col - 1][row] + d[col][row-1]\r\n\r\n        return d[m-1][n-1]\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(m*n)$，\r\n- ***Space:*** $O(m*n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1369004771","body":"## 思路\r\n\r\n---\r\n\r\n完全背包\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def coinChange(self, coins, amount):\r\n        dp = [amount + 1] * (amount+1)\r\n        dp[0] = 0\r\n        for i in range(1, amount+1):\r\n            for coin in coins:\r\n                if i >= coin:\r\n                    dp[i] = min(dp[i], dp[i-coin]+1)\r\n        return -1 if dp[amount] == amount + 1 else dp[amount]\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(N*amount)$，N为物品个数即硬币种类，amount为总金额即背包大小。\r\n- ***Space:*** $O(amount)$","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373811854","body":"## 思路\r\n\r\n---\r\n\r\n排序+双指针：对people体重升序排序；最轻的人和最重的人体重相加若小于船载重即可同时运载两人。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\r\n        count = 0\r\n        l = 0\r\n        r = len(people) - 1\r\n        people.sort()\r\n\r\n        while l < r:\r\n            total = people[l] + people[r]\r\n            if total > limit:\r\n                r -= 1\r\n                count += 1\r\n            else:\r\n                r -= 1\r\n                l += 1\r\n                count += 1\r\n        if l == r:\r\n            return count + 1\r\n        return count\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(nlogn)$\r\n- ***Space:*** $O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1378859374","body":"## 思路\r\n\r\n---\r\n\r\n用一个小顶堆保存每个链表中的最小节点，每次将值最小的节点出堆，加入新的有序链表，并将这个节点的后一个节点入堆，直到堆中没有节点。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n      def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\r\n\t     h = []\r\n\t     for idx, node in enumerate(lists):\r\n\t\t   if node: h.append((node.val, idx, node))\r\n\t\t\t   heapq.heapify(h)\r\n\t\t\t   p = new_head = ListNode()\r\n\t\t\t   while h:\r\n\t\t\t\t  _, idx,node = heapq.heappop(h)\r\n\t\t\t\t  p.next = node\r\n\t\t\t\t  p = p.next\r\n\t\t\t\t  if node.next:\r\n\t\t\t\t\t  heapq.heappush(h, (node.next.val, idx,node.next))\r\n      return new_head.next\r\n```\r\n\r\n## 复杂度\r\n\r\n---\r\n\r\n- ****Time:**** $O(n * logk)$\r\n- ***Space:*** $O(logk)$","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314813262","body":"- Time: $O(N)$, N 为节点数\r\n- Space: $O(H)$, H 为树的高度\r\n\r\n```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        int ans = 0;\r\n        dfs(root, 0, ans);\r\n        return ans;\r\n    }\r\nprivate:\r\n    void dfs(TreeNode* root, int path, int& ans) {\r\n        if (!root) return;\r\n\r\n        path = path * 10 + root->val;\r\n\r\n        if (!root->left && !root->right) {\r\n            ans += path;\r\n            return;\r\n        }\r\n\r\n        dfs(root->left, path, ans);\r\n        dfs(root->right, path, ans);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316234676","body":"```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        // return dfs(root);\r\n        return bfs(root);\r\n    }\r\nprivate:\r\n    int dfs(TreeNode* root) {\r\n        int ans = -1, max_level = -1;\r\n        dfs(root, 0, max_level, ans);\r\n        return ans;\r\n    }\r\n\r\n    void dfs(TreeNode* root, int level, int& max_level, int& ans) {\r\n        if (!root) return;\r\n\r\n        if (max_level < level) {\r\n            max_level = level;\r\n            ans = root->val;\r\n        }\r\n\r\n        dfs(root->left, level + 1, max_level, ans);\r\n        dfs(root->right, level + 1, max_level, ans);\r\n    }\r\n\r\n    int bfs(TreeNode* root) {\r\n        if (!root) return -1;\r\n\r\n        int ans = -1;\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            ans = q.front()->val;\r\n\r\n            int size = q.size();\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                if (node->left) q.push(node->left);\r\n                if (node->right) q.push(node->right);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318185720","body":"```cpp\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n    string empty_node = \"#\";\r\n    string delimeter = \",\";\r\n    string end_of_level = \";\";\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        if (!root) return string();\r\n\r\n        string serialized_string;\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                if (node) {\r\n                    serialized_string += to_string(node->val);\r\n                    q.push(node->left);\r\n                    q.push(node->right);\r\n                } else {\r\n                    serialized_string += empty_node;\r\n                }\r\n                serialized_string += delimeter;\r\n            }\r\n        }\r\n\r\n        return serialized_string;\r\n    }\r\n\r\n    TreeNode* makeTreeNode(const string& data, int& pos) {\r\n        string::size_type delim = data.find(delimeter, pos);\r\n        string val = data.substr(pos, delim - pos);\r\n        pos = delim + 1;\r\n\r\n        if (val.compare(empty_node) == 0)\r\n            return nullptr;\r\n\r\n        return new TreeNode(stoi(val));\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if (data.empty()) return nullptr;\r\n\r\n        int i = 0;\r\n        TreeNode* root = makeTreeNode(data, i);\r\n\r\n        queue<TreeNode*> q;\r\n        q.push(root);\r\n\r\n        while (!q.empty()) {\r\n            int size = q.size();\r\n\r\n            while (size--) {\r\n                TreeNode* node = q.front(); q.pop();\r\n                node->left = makeTreeNode(data, i);\r\n                node->right = makeTreeNode(data, i);\r\n\r\n                if (node->left)\r\n                    q.push(node->left);\r\n                if (node->right)\r\n                    q.push(node->right);\r\n            }\r\n        }\r\n\r\n        return root;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321376511","body":"- Time: $O(N^2)$\r\n- Space: $O(N)$\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        int ans = 0;\r\n\r\n        for (int i = 0; i < points.size(); i++) {\r\n            unordered_map<int, int> dist_counts;\r\n\r\n            for (int j = 0; j < points.size(); j++) {\r\n                int x1 = points[i][0], y1 = points[i][1];\r\n                int x2 = points[j][0], y2 = points[j][1];\r\n                int dist = pow(x1 - x2, 2) + pow(y1 - y2, 2);\r\n                dist_counts[dist]++; \r\n            }\r\n\r\n            for (auto it : dist_counts)\r\n                ans += it.second * (it.second - 1);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324686639","body":"- Time: $O(n*(n-m))$, n is the length of `s`, m is the total length of all the words in `words`\r\n- Space: $O(m)$, m is the size of `words`\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string s, vector<string>& words) {\r\n        int word_len = words[0].size();\r\n        int substr_len = word_len * words.size();\r\n        vector<int> res;\r\n\r\n        if (s.size() < substr_len) return res;\r\n    \r\n        unordered_map<string, int> available_words;\r\n        for (auto& word : words)\r\n            available_words[word]++;\r\n\r\n        for (int i = 0; i <= s.size() - substr_len; i++) {\r\n            unordered_map<string, int> words_count;\r\n\r\n            for (int j = i; j <= i + substr_len - word_len; j += word_len)\r\n                words_count[s.substr(j, word_len)]++;\r\n\r\n            if (available_words == words_count) res.emplace_back(i);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304830763","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = Counter()\r\n        res = 0\r\n        for x, y in zip(arr, sorted(arr)):\r\n            cnt[x] += 1\r\n            if cnt[x] == 0:\r\n                del cnt[x]\r\n            cnt[y] -= 1\r\n            if cnt[y] == 0:\r\n                del cnt[y]\r\n            if len(cnt) == 0:\r\n                res += 1\r\n        return res\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304810452","body":"class Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312750422","body":"class Solution:\n    def maxDepth(self, root: TreeNode) -> int:\n        if not root: return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382347","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tmp = []\n        n = 0\n        for i in range(len(num)-1,-1,-1):\n            k, m = k//10, k%10\n            n, t = (num[i]+m+n)//10, (num[i]+m+n)%10\n            tmp.append(t)\n        k = k+n\n        while k!=0:\n            k,m = k//10,k%10\n            tmp.append(m)\n        return tmp[::-1]\n```\n### 复杂度分析\n- 时间复杂度：O（n）\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299439197","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if s[0]==c:\n            beg = 0\n        else:\n            beg = len(s)\n        end = s.find(c,1)\n        res = []\n        for i in range(len(s)):\n            res.append(min(abs(i-beg),abs(i-end)))\n            if i == end:\n                beg = end\n                end = s.find(c,beg+1)\n        return res\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1306683100","body":"### 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.size = maxSize\r\n        self.stk = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stk)<self.size:\r\n            self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stk)==0:\r\n            return -1\r\n        return self.stk.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(len(self.stk)):\r\n            if i<k:\r\n                self.stk[i]+=val\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303088901","body":"### 思路\n使用栈，遍历字符串，将字符数字和‘【’入栈，直到碰到‘】’，开始出栈，将‘【’之前的字符出栈存在restr里面，然后将‘【’之后的数字出栈存在num中，然后将num倍的restr入栈，直到遍历结束\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1306681084","body":"### 思路\r\n用两个栈实现队列\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stk = []\r\n        self.stk2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.stk:\r\n            self.stk2.append(self.stk.pop())\r\n        x = self.stk2.pop()\r\n        while self.stk2:\r\n            self.stk.append(self.stk2.pop())\r\n        return x\r\n\r\n    def peek(self) -> int:\r\n        while self.stk:\r\n            self.stk2.append(self.stk.pop())\r\n        x = self.stk2.pop()\r\n        self.stk2.append(x)\r\n        while self.stk2:\r\n            self.stk.append(self.stk2.pop())\r\n        return x\r\n\r\n    def empty(self) -> bool:\r\n        if not (self.stk or self.stk2):\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：O（n） \r\n- 空间复杂度：O（n）","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310419817","body":"### 代码\n```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        p1 = headA\n        p2 = headB\n        while p1 != p2:\n            if not p1:\n                p1 = headB\n            else:\n                p1 = p1.next\n            if not p2:\n                p2 = headA\n            else:\n                p2 = p2.next\n        return p1\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315011350","body":"### 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = 0\n        q = deque()\n        q.append((root,0))\n        while q:\n            node,value = q.popleft()\n            if node.left:\n                q.append((node.left,value*10+node.val))\n            if node.right:\n                q.append((node.right,value*10+node.val))\n            if not node.left and not node.right:\n                res += value*10+node.val\n        return res\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322138601","body":"### 思路\n哈希\n### 代码\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        if len(points) < 3:\n            return 0\n        from collections import defaultdict\n        n = len(points)\n        res = 0\n        for i in range(n):\n            m = defaultdict(int)\n            for j in range(n):\n                if i!=j:\n                    dis = (points[i][0]-points[j][0])**2+(points[i][1]-points[j][1])**2\n                    m[dis]+=1\n            for v in m.values():\n                res += v*(v-1)\n        return res\n```\n### 复杂度分析\n- 时间：O（n^2） \n- 空间：O（n）","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329005909","body":"### 代码\n```python\nclass MyQueue(object):\n    def __init__(self):\n        self.queue = []\n    \n    def pop(self, value):\n        if self.queue and value == self.queue[0]:\n            self.queue.pop(0)\n    \n    def push(self, value):\n        while self.queue and value>self.queue[-1]:\n            self.queue.pop()\n        self.queue.append(value)\n    \n    def front(self):\n        return self.queue[0]\n\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        que = MyQueue()\n        res = []\n        for i in range(k):\n            que.push(nums[i])\n        res.append(que.front())\n        for i in range(k, len(nums)):\n            que.pop(nums[i-k])\n            que.push(nums[i])\n            res.append(que.front())\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305655564","body":"## 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next:\n            cut += 1\n            if cut == cnt - k:\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n            \n        return res if res else head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298145845","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1: # while a没完 or b没完\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304457480","body":"## **思路：两个栈倒腾**\n\n之前写过O(n)的，以下是O(1)的思路\n\nO(n)也是两个栈互相倒，但是复杂度较高。两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个**辅助的self.front变量，记录stackin最前面元素**。\n\npop的时候，rather than倒进去又倒出来，可以在stackout空的时候才倒，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶元素，否则，就是self.front\n\n### **代码**\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return \n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304787936","body":"用栈保存单调递增的片段的最大的值，中间小的不重要；所以可以用单调栈，如果碰到更小的就弹出来，直到小的能够放进去为止，该数字之前的片段才能保证排序之后递增，并且能和后面的连上。如果碰到更大的直接放进栈即可\n\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # 用单调栈存储一个块的最大值，单调栈是递增的\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # 碰到更小的值，就得把前面的一个个拿出来，知道形成新的块能够合并掉这个最小值\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val) # 要记录当前块的最大值并且放回去\n            else: # 碰到更大的值，可以无脑作为一个新的块\n                stack.append(n)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312510932","body":"### **思路：双向链表+哈希**\n\n\n由于要求的是O1的复杂度，要求删除、添加、换位置都是O1能够用的是链表和哈希，这题的关键就说用**双向链表+哈希，双向链表存储节点的顺序，哈希存储key对应的node**。这里要注意的是：\n\n（1）双向链表用**两个哨兵做头尾**会比较方便边界计算，用一个dummy头和一个curnode指针也可以，但是要每次改curnode的位置，容易错\n\n（2）put和get值的时候虽然不把node取出，但是都算访问了node，需要把node放到最后\n\n（3）双向链表直接存储key和val，不能只存val，因为key和val可能不一样\n\n### **代码**\n\n```python\nclass ListNode:\n    def __init__(self, key=None, val=None):\n        self.prev = None\n        self.next = None\n        self.val = val\n        self.key = key\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        # 初始化哈希表 {key: ListNode}\n        self.hashmap = dict()\n        # 初始化双向链表\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        # 如果在hash中，返回该值。放到双向链表最后\n        if key in self.hashmap:\n            self.move_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        return -1 if res == -1 else res.val\n            \n    def move_to_tail(self, key) -> None:\n        node = self.hashmap[key]\n\t\t\t\t# 拆出\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\t\t\t\t# 插入\n        node.prev = self.tail.prev\n        node.next = self.tail\n        self.tail.prev.next = node\n        self.tail.prev = node\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 若该key已经在双向链表中，把该key放到最后，并且改变值\n            self.hashmap[key].val = value\n            self.move_to_tail(key)\n            return\n        if len(self.hashmap) == self.capacity:\n            # 删除头节点\n            del_node = self.head.next\n            self.head.next = del_node.next\n            del_node.next.prev = self.head\n            self.hashmap.pop(del_node.key)\n\n        new_node = ListNode(key, value)\n        self.hashmap[key] = new_node\n        self.tail.prev.next = new_node\n        new_node.prev = self.tail.prev\n        new_node.next = self.tail\n        self.tail.prev = new_node\n\n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665583","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303685599","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304491666","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766445","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305402662","body":"#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while (cur.next) {\n        cur = cur.next;\n        n++;\n    }\n\n    let add = n - k % n;\n    if (add === n) {\n        return head;\n    }\n\n    cur.next = head;\n    while (add) {\n        cur = cur.next;\n        add--;\n    }\n\n    const ret = cur.next;\n    cur.next = null;\n    return ret;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306724203","body":"### 解题思路\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\n3. 令cur指针指向pre.next；next指针指向pre.next.next\n4. 交换过程如下：\n- pre.next = next\n- cur.next = next.next\n- next.next = cur\n- pre = cur\n\n### 代码实现\njavaScript\n\n```\nvar swapPairs = function(head) {\n    let dummyNode = new ListNode(0);\n    dummyNode.next = head;\n    let pre = dummyNode;\n    while(pre.next && pre.next.next) {\n        const cur = pre.next;\n        const next = pre.next.next;\n        pre.next = next;\n        cur.next = next.next;\n        next.next = cur;\n        pre = cur;\n    }\n    return dummyNode.next;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$, N为链表中节点数目\n- 空间复杂度 $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311457389","body":"### 解题思路\n\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head === null || head.next === null) return null;\n    // 定义快慢两个指针、只想链表头部\n    let fast = head;\n    let slow = head;\n    // 快指针走两步，满指针走一步\n    do {\n        if (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n        } else {\n            fast = null\n        }\n        slow = slow.next;\n    } while(fast !== slow)\n    if (fast === null) return null;\n    // 相遇后将快指针指向链表头部\n    fast = head;\n    while(fast !== slow) {\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507692","body":"### 解题思路\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\n### 代码实现\n> javaScript\n\n```\nvar LinkedList = function(key, val) {\n    this.key = key;\n    this.val = val;\n    this.prev = null;\n    this.next = null;\n}\n\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.size = 0;\n    this.cache = new Map();\n    // 构建虚拟节点\n    this.dummyHead = new LinkedList();\n    this.dummyTail = new LinkedList();\n    this.dummyHead.next = this.dummyTail;\n    this.dummyTail.prev = this.dummyHead;\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (!this.cache.has(key)) {\n        return -1;\n    }\n    const node = this.cache.get(key);\n    // 将节点移动至链表头部\n    this.removeNode(node);\n    this.appendToHead(node);\n    return node.val;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 判断关键字key是否存在于缓存中\n    const node = this.cache.get(key);\n    if (node) {\n        // 更新关键字的值\n        node.val = value;\n        this.cache.set(key, node);\n        // 将关键字移动至链表头部\n        this.removeNode(node);\n        this.appendToHead(node);\n    } else {\n        // 当缓存容量达到上限时\n        if (this.size === this.capacity) {\n            // 删除最久未使用的\n            this.removeTailNode();\n        }\n        // 创建新节点\n        const newNode = new LinkedList(key, value);\n        this.cache.set(key, newNode)\n        this.appendToHead(newNode);\n        this.size ++;\n    }\n};\n\nLRUCache.prototype.removeNode = function(node) {\n    let preNode = node.prev;\n    let nextNode = node.next;\n    preNode.next = nextNode;\n    nextNode.prev = preNode;\n}\n\nLRUCache.prototype.appendToHead = function(node) {\n    let head = this.dummyHead.next;\n    this.dummyHead.next = node;\n    node.prev = this.dummyHead;\n    node.next = head;\n    head.prev = node;\n}\n\nLRUCache.prototype.removeTailNode = function() {\n    this.size --;\n    let tailNode = this.dummyTail.prev;\n    this.cache.delete(tailNode.key);\n    this.removeNode(tailNode);\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(1)$ \n- 空间复杂度：$O(capacity)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312751748","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar maxDepth = function(root, depth = 0) {\n  if(!root) return depth;\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\n- 空间复杂度 $(K)$, k为二叉树的深度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313816269","body":"### 解题思路\n> DFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n  if(!p && !q) return true\n  if(!p || !q) return false;\n  if(p.val != q.val) return false;\n\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315499549","body":"### 解题思路\n> DFS\n\n### 代码实现\n\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return dfs(root, 0)\n};\nvar dfs = function(root, sum) {\n    if (root === null) {\n        return 0;\n    }\n    const curSum = sum * 10 + root.val;\n    // 遍历到根节点\n    if (root.left === null && root.right === null) {\n        return curSum;\n    } else {\n        return dfs(root.left, curSum) + dfs(root.right, curSum);\n    }\n}\n\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数\n\n\n### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if (root === null) {\n        return 0;\n    }\n    const queue = [[root, root.val]];\n    let sum = 0;\n    while(queue.length > 0) {\n        const [node, curSum] = queue.shift();\n        if(node.left === null && node.right === null) {\n            sum += curSum;\n        } else {\n          node.left && queue.push([node.left, curSum * 10 + node.left.val]);  \n          node.right && queue.push([node.right, curSum * 10 + node.right.val]);  \n        }\n    }\n    return sum;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(n)$ n为二叉树的节点个数\n- 空间复杂度 $O(n)$ n为二叉树的节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317077026","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n```\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n  if(!root) return null;\n  const queue = [root]\n  let mostLeft = null;\n  while(queue.length > 0){\n    let curLevelSize = queue.length\n    mostLeft = queue[0]\n    for(let i = 0; i < curLevelSize; i++){\n      const curNode = queue.shift();\n      curNode.left && queue.push(curNode.left)\n      curNode.right&& queue.push(curNode.right)\n    }\n  }\n  return mostLeft.val\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ N为二叉树的节点\n- 空间复杂度 $O(N)$ N为二叉树的节点","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318195377","body":"### 解题思路\n> DFS（递归）\n\n### 代码实现\n> javaScript\n\n```\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nconst serialize = (root) => {\n  if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  } \n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list);\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320079106","body":"### 解题思路\n> BFS\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n  if(!root) return root\n  const result = []\n  const obj = new Map();\n  // [node, rowVal, colVal]\n  const queue = [[root,0, 0]]\n\n  while(queue.length){\n    const [node, row, col] = queue.shift()\n    obj.set(col, (obj.get(col) || []).concat([[node.val, row]]))\n    node.left && queue.push([node.left, row + 1, col - 1 ])\n    node.right && queue.push([node.right, row + 1 , col + 1 ])\n  }\n\n  // sort\n  let sortedKeys = [...obj.keys()].sort((a,b) => a - b)\n\n  for(const key of sortedKeys){\n    let temp = obj.get(key)\n    temp = temp.sort((a,b) => {\n      if(a[1] != b[1]){\n        return a[1] - b[1]\n      }\n      return a[0] - b[0]\n    })\n    result.push(temp.map((item) => item[0]))\n  }\n  return result;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(NlogN)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320883050","body":"### 解题思路\n> 哈希表\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    const hashMap = new Map();\n    for(let i = 0; i < nums.length; i++){\n      if (hashMap.has(target - nums[i])) {\n        return [hashMap.get(target - nums[i]), i]\n      } else {\n        hashMap.set(nums[i], i)\n      }\n    }\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$ \n- 空间复杂度 $O(N)$ ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128169","body":"### 代码实现\n> javaScript\n\n```\nlet topKFrequent = function(nums, k) {\n    let map = new Map(), arr = [...new Set(nums)]\n    nums.map((num) => {\n        if(map.has(num)) map.set(num, map.get(num)+1)\n        else map.set(num, 1)\n    })\n    \n    // 如果元素数量小于等于 k\n    if(map.size <= k) {\n        return [...map.keys()]\n    }\n    \n    return bucketSort(map, k)\n};\n\n// 桶排序\nlet bucketSort = (map, k) => {\n    let arr = [], res = []\n    map.forEach((value, key) => {\n        // 利用出现频率作为下标，将数据分配到各个桶中\n        if(!arr[value]) {\n            arr[value] = [key]\n        } else {\n            arr[value].push(key)\n        }\n    })\n    // 倒序遍历获取出现频率最大的前k个数\n    for(let i = arr.length - 1;i >= 0 && res.length < k;i--){\n        if(arr[i]) {\n            res.push(...arr[i])\n        }\n\t}\n\treturn res\n}\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322122689","body":"### 解题思路\n> 哈希表\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    const maps = Array(points.length)\n        .fill(0)\n        .map(() => ({}));\n    let count = 0;\n\n    points.forEach((a, i) => {\n        const map = maps[i];\n        points.forEach((b, j) => {\n            if (a !== b) {\n                const dist = calcDistOf2Points(a, b);\n                map[dist] = (map[dist] || 0) + 1;\n            }\n        });\n        for (const dist in map) {\n            const num = map[dist];\n            if (num > 1) count += num * (num - 1);\n        }\n    });\n    return count;\n    function calcDistOf2Points([x1, y1], [x2, y2]) {\n        return (x1 - x2) ** 2 + (y1 - y2) ** 2;\n    }\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(Nˆ2)$ N 是数组长度\n- 空间复杂度 $O(Nˆ2)$ 需要 N 个哈希表来记录 N 个点到其他 N-1 个点的距离，最坏的情况是每个点到其他点的距离都不一样，那每个哈希表的大小就是 N-1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323709316","body":"### 解题思路\n>  哈希表+滑动窗口\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    const hashMap = new Set()\n    let longestSubstring = 0;\n    let slow = 0;\n    for(let fast = 0; fast < s.length; fast++){\n        let char = s[fast]  \n        while(hashMap.has(char) && slow < s.length){\n            hashMap.delete(s[slow])\n            slow++\n        }\n        longestSubstring = Math.max(longestSubstring, fast - slow + 1)\n        hashMap.add(char)\n    }\n    return longestSubstring\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327088522","body":"#### 解题思路\n> 双指针\n\n#### 代码实现\n\n```\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function (head) {\n  let slow = (fast = head);\n  while (slow && fast && fast.next) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  return slow;\n};\n```\n#### 复杂度分析\n- 时间复杂度: $O(N)$\n\n- 空间复杂度: $O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328262561","body":"### 解题思路\n> 二分法\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while(left <= right) {\n    const mid = Math.floor(left + (right - left) / 2);\n    if(target === nums[mid]) {\n        right = mid - 1;\n    } else if(target > nums[mid]){\n        left = mid + 1\n    } else {\n        right = mid - 1\n    }\n  }\n  return left;\n};\n```\n### 复杂度分析\n- 时间复杂度 $O(logN)$\n- 空间复杂度 $O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329293905","body":"### 代码实现\n\nvar maxSlidingWindow = function(nums, k) {\n    const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n};\n\n### 复杂度分析\n\n- 时间复杂度：$O(N)$\n\n- 空间复杂度 $O(N)$，即为存储 prefixMax和suffixMax 需要的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330617911","body":"### 解题思路\n> 图\n\n### 解题思路\n1.  根据题意可知，在法官存在的情况下，法官不相信任何人，每个人（除了法官外）都信任法官，且只有一名法官。因此法官这个节点的入度是 n-1, 出度是 0；\n\n2. 遍历每个节点的入度和出度，如果找到一个符合条件的节点，由于题目保证只有一个法官，可以直接返回结果；如果不存在符合条件的点，则返回 -1\n\n### 代码实现\n> javaScript\n\n```\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const inDegrees = new Array(n + 1).fill(0);\n    const outDegrees = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0], y = edge[1];\n        ++inDegrees[y];\n        ++outDegrees[x];\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (inDegrees[i] === n - 1 && outDegrees[i] === 0) {\n            return i;\n        }\n    }\n    return -1;\n};\n```\n### 复杂度分析\n- 时间复杂度：$O(n+m)$\n- 空间复杂度：$O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332223440","body":"### 解题思路\n> DFS\n\n### 代码实现\n> JavaScript\n\n```\nvar possibleBipartition = function(n, dislikes) {\n    const dfs = (curnode, nowcolor, color, g) => {\n        color[curnode] = nowcolor;\n        for (const nextnode of g[curnode]) {\n            if (color[nextnode] !== 0 && color[nextnode] === color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] === 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    const color = new Array(n + 1).fill(0);\n    const g = new Array(n + 1).fill(0);\n    for (let i = 0; i <= n; ++i) {\n        g[i] = [];\n    }\n    for (const p of dislikes) {\n        g[p[0]].push(p[1]);\n        g[p[1]].push(p[0]);\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (color[i] === 0 && !dfs(i, 1, color, g)) {\n            return false;\n        }\n    }\n    return true;\n};\n```\n### 复杂度分析\n- 时间复杂$:$O(n+m)$\n\n- 空间复杂度: $O(n+m)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341032029","body":"### 解题思路\n> 二分查找\n\n### 代码实现\n\n```\nvar mySqrt = function(x) {\n    if (x == 0 || x == 1) {\n        return x;\n    }\n\n    let left = 1;\n    let right = x / 2;\n    while (left < right) {\n        let mid = left + (right - left + 1) / 2;\n        if (mid > x / mid) {\n            right = mid - 1;\n        } else {\n            left = mid;\n        }\n    }\n    return left;\n};\n```\n### 复杂度分析\n- 时间复杂度：$O(logx)$，即为二分查找需要的次数\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342868778","body":"### 解题思路\n> 二分法寻找最左边界\n\n### 代码实现\n> > javaScript\n\n```\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let low = 0;\n        let high = n;\n        while (low <= high) {\n            let mid = Math.floor((low + high) / 2);\n            const midV = isBadVersion(mid);\n            if (midV) {\n               high = mid - 1\n            } else {\n               low = mid + 1\n            }\n        }\n        return low;\n    };\n};\n```\n### 复杂度分析\n- 时间复杂度: $O(logn)$\n- 空间复杂度: $O(1)$","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350757323","body":"var new21Game = function(N, K, W) {\n    if(K>N) return 0\n    const dp = new Array(K+W).fill(1)\n    let temp = K\n    let s = 0\n    while(temp<K+W){\n        if(temp>N){\n            dp[temp] = 0\n        }\n        s+=dp[temp]\n        temp++\n    }\n    let downTemp = K-1\n    while(downTemp>=0){\n        dp[downTemp] = s/W\n        s = s+dp[downTemp]-dp[downTemp+W]\n        downTemp--\n    }\n    return dp[0]\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361211959","body":"/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxDistance = function (grid) {\n  let n = grid.length;\n  let queue = [],\n    areaCount = 0;\n  // 0 海洋 1陆地\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      // 所有陆地入队列\n      if (grid[i][j] == 1) queue.push([i, j]);\n      // 统计海洋的数量\n      else areaCount++;\n    }\n  }\n  // 只有陆地或者说只有海洋\n  if (queue.length == 0 || areaCount == 0) return -1;\n  let directions = [\n    [0, 1],\n    [0, -1],\n    [-1, 0],\n    [1, 0],\n  ];\n  // 广度扩散\n  let depth = 0;\n  while (queue.length) {\n    let size = queue.length;\n    depth++;\n    for (let i = 0; i < size; i++) {\n      // 队首出\n      let [curI, curJ] = queue.shift();\n      for (let dir of directions) {\n        let newI = dir[0] + curI,\n          newJ = dir[1] + curJ;\n        // 越界 或者已经是陆地了\n        if (\n          newI < 0 ||\n          newJ < 0 ||\n          newI >= n ||\n          newJ >= n ||\n          grid[newI][newJ] == 1\n        )\n          continue;\n        // 把所有的海洋都变成陆地\n        grid[newI][newJ] = 1;\n        queue.push([newI, newJ]);\n        areaCount--;\n        // 如果海洋都变成了陆地，就是走过的最远路径了\n        if (areaCount == 0) return depth;\n      }\n    }\n  }\n  return -1;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370922533","body":"```\r\nvar findContentChildren = function(g, s) {\r\n    g.sort((a, b) => a - b);\r\n    s.sort((a, b) => a - b);\r\n    const m = g.length, n = s.length;\r\n    let count = 0;\r\n    for (let i = 0, j = 0; i < m && j < n; i++, j++) {\r\n        while (j < n && g[i] > s[j]) {\r\n            j++;\r\n        }\r\n        if (j < n) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374832835","body":"#### 代码实现\n\n```\nvar mergeKLists = function(lists) {\n  if (!lists.length) {\n    return null;\n  }\n  const merge = (head1, head2) => {\n    let dummy = new ListNode(0);\n    let cur = dummy;\n    while (head1 && head2) {\n      if (head1.val < head2.val) {\n        cur.next = head1;\n        head1 = head1.next;\n      } else {\n        cur.next = head2;\n        head2 = head2.next;\n      }\n      cur = cur.next;\n    }\n    cur.next = head1 == null ? head2 : head1;\n    return dummy.next;\n  };\n  const mergeLists = (lists, start, end) => {\n    if (start + 1 == end) {\n      return lists[start];\n    }\n    let mid = (start + end) >> 1;\n    let head1 = mergeLists(lists, start, mid);\n    let head2 = mergeLists(lists, mid, end);\n    return merge(head1, head2);\n  };\n  return mergeLists(lists, 0, lists.length);\n};\n```\n\n#### 复杂度分析\n- 空间复杂度： $O(logk)$\n- 时间复杂度:  $O(O(kn×logk))$","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382691392","body":"#### 代码实现\n\n```\nfunction TreeNode(val) {\n    this.val = val || null\n    this.children = {}\n}\n\n/**\n * @param {string} big\n * @param {string[]} smalls\n * @return {number[][]}\n */\nvar multiSearch = function (big, smalls) {\n    const res = smalls.map(() => [])\n    if (!big) {\n        return res\n    }\n    let Tree = new TreeNode()\n    let now;\n    smalls.forEach((small, index) => {\n        now = Tree;\n        for (let i = 0; i < small.length; i++) {\n            if (!now.children[small[i]]) {\n                now.children[small[i]] = new TreeNode(small[i])\n            }\n            now = now.children[small[i]]\n        }\n        now.children['last'] = index\n    })\n\n    for (let i = 0; i < big.length; i++) {\n        let now = Tree;\n        for (let j = i; j < big.length; j++) {\n            if (!now.children[big[j]]) {\n                break\n            }\n            now = now.children[big[j]]\n            if (now.children.last !== undefined) {\n                res[now.children.last].push(i)\n            }\n        }\n    }\n    return res\n};\n```\n#### 复杂度分析\n- 时间复杂度：$(N^2)$\n- 空间复杂度: $O(S)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298752942","body":"# Thoughts:\r\n\r\nTake K as a carry, add it to the lowest digit, Update Carry K and keep going to higher digit.\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; --i){\r\n            res.add(0, (num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n# Time Complexicity:\r\nO(N)\r\n\r\n# Space Complexicity:\r\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753644","body":"## 思路\n从末尾开始遍历数组元素，与k相加，并维护k值，及进位，\n然后将末位的值加入集合\n遍历完毕数组后，若k仍然有值，将其各位加入数组\n最后返回\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        for(int i=len-1;i>=0;i--){\n            int t=num[i]+k;\n            //这样就不用反转\n            res.add(0,t%10);\n            k=t/10;\n        }\n      //遍历完毕数组后，若k仍然有值，将其各位加入数组\n     //即k位数比数组长度大的情况\n        while(k>0){\n            res.add(0,k%10);\n            k /=10;\n        }\n        return res;\n    }\n}\n```\nTime:O(n)\nSpace:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300799149","body":"##思路\n1、从当前元素开始，左、右分别寻找字符c\n2、若找到了则计算长度距离，若两个方向都找到，则并维护一个最小距离值\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int index = -n;\n//正向查找\n        for (int i = 0; i < n ; ++i) {\n            if (s.charAt(i) == c){\n                index = i;\n            }\n            res[i] = i - index1;\n        }\n        int index2 = 2*n;\n//反向查找\n        for (int i = n-1; i >=0 ; --i) {\n            if (s.charAt(i) == c){\n                index2 = i;\n               }\n    //维护最小距离\n            res[i] = Math.min(res[i],index2 - i);\n        }\n        return res;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302327842","body":"## 思路\r\n使用数组模拟\r\n\r\n1. 定义一个数组和一个指针\r\n2. 初始化数组为定义的大小，并为指针赋值初始值\r\n3. 弹出方法\r\n   -若到达初始化值-1下标的元素——即最后一个元素就返回\r\n   -不然就先向右移动指针，指针+1先\r\n   -然后给指针指向下标赋值\r\n\r\n4. pop 弹出：直接返回指针指向元素，然后左移一位 -1\r\n    -若指针与初始值相同，则返回-1\r\n5. 指定元素 加上对应值\r\n   - 比较k 和 指针+1 哪个小，\r\n   - 遍历这个较小值的所有元素，\r\n   - 并每个元素加上要加的值val\r\n\r\n\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    int st[];\r\n    int p;\r\n    public CustomStack(int maxSize) {\r\n        st=new int[maxSize];\r\n        p=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //限制功能为初始化长度内使用\r\n        if(p==(st.length-1)){\r\n            return;\r\n        }\r\n        st[++p]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        //弹出全部时返回\r\n        if(p == -1){\r\n            return -1;\r\n        }\r\n\r\n        return st[p--];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int l=Math.min(k,p+1);\r\n        for(int i=0;i<l;i++){\r\n            st[i]+=val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\nTime:O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303803971","body":"## 思路\r\n用列表模拟栈\r\n先入栈，碰到 】 再出栈\r\n先循环到[ 拼接字符\r\n碰到 【，出栈\r\n再拼接数字\r\n循环字符串 数字值 遍\r\n返回\r\n## 代码\r\n```python\r\n class Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        # 定义列表\r\n        stack=[]\r\n\r\n        # 遍历字符串\r\n        for c in s:\r\n            # 出栈\r\n            if c == ']':\r\n                strT= ''\r\n                count=''\r\n                # 没碰到 [ 不停止循环\r\n                while stack and stack[-1] !='[':\r\n                    # 栈顶，即列表末尾元素弹出并返回值\r\n                    strT =stack.pop() +strT \r\n                \r\n                # 弹出 [\r\n                stack.pop()\r\n                # 碰到非数字再跳出循环\r\n                while stack and stack[-1].isnumeric():\r\n                    count =stack.pop() +count;\r\n                stack.append(strT * int(count))\r\n             # 入栈\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\nTime：O(N)\r\nSpace:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572910","body":"## 思路\r\n使用两个栈来辅助实现队列的功能\r\n\r\n## 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n         self.inStack = []\r\n         self.outStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n       # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 出栈队头元素\r\n        return self.outStack.pop()\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 返回最后的元素\r\n        return self.outStack[-1]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n    # 移动到另外一个栈\r\n    def moveOut(self):\r\n          if not self.outStack:\r\n           # 若不在out列表内就加入这个列表\r\n            while self.inStack:\r\n                 self.outStack.append(self.inStack.pop())\r\n\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n## 算法复杂度\r\nTIME：O(N)\r\nSPACE:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304832356","body":"## 思路\n单调栈\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        st = []\n        for a in arr:\n            if st and st[-1] > a:\n                cur = st[-1]\n                while st and st[-1] > a: st.pop()\n                st.append(cur)\n            else:\n                st.append(a)\n        return len(st)\n```\n## 复杂度分析\n\nTIME：O(N)\n\nSPACE：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305822674","body":"## 思路\n快慢指针\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){ return head;}\n        int c = 0;\n        ListNode cur = head;\n        while(cur != null){\n            cur = cur.next;\n            c++;\n        }\n        k = k % c;\n        ListNode slow = head, fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                slow = slow.next;\n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = slow.next;\n        slow.next = null;\n        return res;\n    }\n}\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307444095","body":"\n\n\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n if(head == null || head.next == null) return head;\n        ListNode pre = new ListNode(-1, head), res;\n        pre.next = head;\n        res = head.next;\n        ListNode fNode = head, sNode, nextNode;\n        while(fNode != null && fNode.next != null){\n            sNode = fNode.next;\n            nextNode = sNode.next;\n\n            fNode.next = nextNode;\n            sNode.next = fNode;\n            pre.next = sNode;\n\n            pre = fNode;\n            fNode = nextNode;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308979133","body":"\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n  public TreeNode sortedListToBST(ListNode head) {\n      if(head == null){\n          return null;\n      }\n      return dfs(head,null);\n  }\n  private TreeNode dfs(ListNode head, ListNode tail){\n      if(head == tail){\n           return null;\n      }\n      ListNode fast = head, slow = head;\n      //找到中点 slow\n      while(fast != tail && fast.next != tail){\n          fast = fast.next.next;\n          slow = slow.next;\n      }\n      //中点左右开始递归dfs\n      TreeNode root = new TreeNode(slow.val);\n      root.left = dfs(head, slow);\n      root.right = dfs(slow.next, tail);\n      return root;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310515458","body":"## 思路\r\n双指针，两个指针同时移动，一个移动到末尾，之后移动到另一条链表开头，两个都这么干\r\n1：A+C+B\r\n2: B=C+A  \r\n若二者相交就会出现相交节点\r\n## 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\r\n        a,b=headA,headB\r\n        while a != b:\r\n            a=a.next if a else headB\r\n            b=b.next if b else headA\r\n        return a\r\n    \r\n```\r\n## 复杂度分析\r\n\r\nTIME：O(N)\r\n\r\nSPACE：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311871905","body":"## 思路\n快慢指针，经过推断，得出相交后，再置一个指针到开始位置，以慢指针的速度走，两者相交位置寄环开始处\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null){\n            return null;\n        }\n        ListNode fast=head,slow=head;\n        while(fast!=null){\n            slow=slow.next;\n            if(fast.next!=null){\n                fast=fast.next.next;\n            }else{\n                return null;\n            }\n\n            if(fast==slow){\n                ListNode ft=head;\n\n                while(ft!=slow){\n                    ft=ft.next;\n                    slow=slow.next;\n                }\n                return ft;\n            }\n\n        }\n        return null;\n    }\n}\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312515225","body":"```\nclass LRUCache {\n    class DLinkedNode {\n        int key, value;\n        DLinkedNode prev, next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size, cap;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        //add dummy head and dummyTail\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n        //if key exist, move it to head by using its location store in Hashmap\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762345","body":"## 思路\r\n递归，比较大小\r\n## 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(H)，H为最大深度，最坏情况H=N","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313980871","body":"## 思路\n递归\n## 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        //判断有空节点的情况下是否相同\n        if(p==null && q==null){\n            return true;\n        }\n         if(p==null || q==null){\n            return false;\n        }\n\n        //判断节点是否相同，不同则返回false\n         if(p.val != q.val){\n            return false;\n        }\n\n        return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n\n        isSameTree(p.right);\n    }\n}\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(H)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315518337","body":"## 思路\r\nBFS 加栈来一层一层遍历，\r\n\r\n- 若无子节点，直接加当前节点值\r\n- 若存在左\\右子节点\r\n- 加上值\r\n\r\n## 代码\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n         Queue<TreeNode> qu = new LinkedList<>();\r\n        qu.offer(root);\r\n        int sum = 0;\r\n        //bfs 栈\r\n        while(!qu.isEmpty()){\r\n          int size = qu.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = qu.poll();\r\n                \r\n                if (cur.left == null && cur.right == null) {\r\n                    sum = sum + cur.val;\r\n                }\r\n\r\n                if (cur.left != null) {\r\n                    cur.left.val = cur.val * 10 + cur.left.val;\r\n                    qu.offer(cur.left);\r\n                }\r\n\r\n                if (cur.right != null) {\r\n                    cur.right.val = cur.val * 10 + cur.right.val;\r\n                    qu.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(b)，最坏情况b为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317222978","body":"## 思路\nbfs层序遍历，最后一层的第一个点返回\n## 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        if(root==null){\n            return 0;\n        }\n        LinkedList<TreeNode> qu=new LinkedList<>();\n        qu.offer(root);\n        int res=0;\n        while(!qu.isEmpty()){\n            int size=qu.size();\n            for(int i=0;i<size;i++){\n                TreeNode node=qu.poll();\n                if(i==0){\n                    res=node.val;\n                }\n                if(node.left!=null){\n                    qu.addLast(node.left);\n                }\n                if(node.right !=null){\n                    qu.addLast(node.right);\n                }\n\n            }\n            \n        }\n        return res;     \n    }\n}\n\n```\n## 算法复杂度\nTIME:O(N)\nSPACE:O(Q)，最坏情况Q与N同阶\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318850496","body":"## 思路\r\n序列化：bfs\r\n反序列化：bfs +3指针\r\n## 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        ans = ''\r\n        queue = [root]\r\n        while queue:\r\n            node = queue.pop(0)\r\n            if node:\r\n                ans += str(node.val) + ','\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                ans += '#,'\r\n        print(ans[:-1])\r\n        return ans[:-1]\r\n        \r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if data == '#': return None\r\n        nodes = data.split(',')\r\n        if not nodes: return None\r\n        root = TreeNode(nodes[0])\r\n        queue = [root]\r\n        # 有 root了，从 1 开始\r\n        i = 1\r\n\r\n        while i < len(nodes) - 1:\r\n            node = queue.pop(0)\r\n            lv = nodes[i]\r\n            rv = nodes[i + 1]\r\n            i += 2\r\n            if lv != '#':\r\n                l = TreeNode(lv)\r\n                node.left = l\r\n                queue.append(l)\r\n\r\n            if rv != '#':\r\n                r = TreeNode(rv)\r\n                node.right = r\r\n                queue.append(r)\r\n        return root\r\n\r\n# Your Codec object will be instantiated and called as such:\r\n# ser = Codec()\r\n# deser = Codec()\r\n# ans = deser.deserialize(ser.serialize(root))\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(N)\r\nSPACE:O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320216302","body":"## 思路\r\nDFS\r\n## 代码\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def verticalTraversal(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: List[List[int]]\r\n        \"\"\"\r\n        se = collections.defaultdict(\r\n            lambda: collections.defaultdict(list))\r\n        def dfs(root, x=0, y=0):\r\n            if not root:\r\n                return\r\n            se[x][y].append(root.val)\r\n            dfs(root.left, x-1, y+1)\r\n            dfs(root.right, x+1, y+1)\r\n        dfs(root)\r\n        ans = []\r\n       \r\n        for x in sorted(se):\r\n            level = []\r\n            for y in sorted(se[x]):\r\n                level += sorted(v for v in se[x][y])\r\n            ans.append(level)\r\n        return ans\r\n\r\n\r\n```\r\n## 算法复杂度\r\nTIME:O(nlogn)\r\nSPACE:O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912101","body":"## 思路\n\n## 代码\n```java\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target-nums[i],i);\n        }\n         return new int[]{};\n    }\n    \n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321165259","body":"## 思路\nmap存数字及次数，\n构建一个大小为k的小顶堆，\n遍历map，与堆顶元素比较，大的赋值为堆顶\n\n## 代码\n```java\n\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        //计数\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        // 数组第1个元素值，第2个元素次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                //比较次数，构建小顶堆\n                return a[1] - b[1];\n            }\n        });\n        //遍历map，拿出来与堆封顶部比较\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int num = entry.getKey()；\n            int c = entry.getValue();\n            //堆维护为k大小\n            if (queue.size() == k) {\n                //比较堆顶数据，哪个大哪个加入堆顶\n                if (queue.peek()[1] < c) {\n                    queue.poll();\n                    queue.offer(new int[]{num, c});\n                }\n            } else {\n                queue.offer(new int[]{num, c});\n            }\n        }\n        //最后取出值\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(nlogk)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322265773","body":"## 思路\n哈希表处理结果，再遍历计算\n## 代码\n```java\n\n\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        if(points==null||points.length<=2){\n            return 0;\n        }\n        int res=0;\n        Map<Integer,Integer> map=new HashMap<>();\n        for(int i=0;i<points.length;i++){\n            for(int j=0;j<points.length;j++){\n                int len=getLen(points[i],points[j]);\n                map.put(len, map.getOrDefault(len, 0) + 1);\n            }\n             for (int count : map.values()){\n                 res += count * (count - 1);\n             }\n            \n        map.clear();\n        }\n        return res;\n    }\n   int getLen(int[] a,int[] b){\n        int x=b[0]-a[0];\n        int y=b[1]-a[1];\n        return x*x+y*y;\n    }\n}\n```\n## 算法复杂度\nTIME:O(n*n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323894545","body":"## 思路\nset判断重复，滑动窗口\n## 代码\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int l = 0;\n        int maxLen = 0;\n        Set<Character> set = new HashSet<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (!set.add(s.charAt(i))) {\n                maxLen = Math.max(maxLen, set.size());\n                while (s.charAt(l) != s.charAt(i)) {\n                    set.remove(s.charAt(l));\n                    l++;\n                }\n                l += 1;\n            }\n        }\n        return Math.max(maxLen, set.size());\n    }\n}\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325301819","body":"## 思路\nset判断重复，滑动窗口\n## 代码\n```java\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n          List<Integer> res = new ArrayList<>();\n        Map<String, Integer> map = new HashMap<>();\n        if (words == null || words.length == 0)\n            return res;\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n        int match = 0;\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n            for (; j < cur.length(); j += wordLen) {\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n            if (j == cur.length())\n                res.add(i);\n        }\n        return res;\n    }\n}\n```\n## 算法复杂度\nTIME:O(m*n*k)\nSPACE:O(m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326625022","body":"## 思路\n同余定理+前缀和\n## 代码\n```java\n\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int t = 0;\n      //前缀和\n        for (int n : nums){\n\t\t t += n;\n\t\t}\n          \n       t= Math.floorMod(t, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - t, k)))\n                res = Math.min(res, i -map.get(Math.floorMod(prefix - t, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327632732","body":"## 思路\n双指针，快慢指针\n## 代码\n```python\n\n\n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328070958","body":"## 思路\n双指针，读写指针\n\t• 一样的值，读指针前进，\n\t• 不同值，写指针移动并写入\n## 代码\n```python\n\n\n\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328274205","body":"## 思路\n二分\n## 代码\n```java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int l = 0,r = nums.length - 1\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (target > nums[mid]) {\n                l = mid + 1;\n            } else if (target < nums[mid]) {\n                r = mid - 1;\n            } else if (target == nums[mid]){\n                return mid;\n            }\n        }\n        return l;\n    }\n}\n```\n## 算法复杂度\nTIME:O(nlogn)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329404129","body":"## 思路\r\n双端队列\r\n\r\n-  维护队列大小\r\n\r\n- \t索引大于 i - k + 1,出队\r\n\r\n- \t 小于当前元素，出队\r\n\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int len=nums.length;\r\n        int[] res = new int[len - k + 1];\r\n        Deque<Integer> dq = new ArrayDeque<>();\r\n        for (int i = 0; i < len; i++){\r\n            //索引大于 i - k + 1,出队\r\n            if (!dq.isEmpty() && dq.peekFirst() + k <= i) {\r\n                dq.pollFirst();\r\n            }\r\n            //小于当前元素，出队\r\n            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]){\r\n                dq.pollLast();\r\n            }\r\n            dq.offerLast(i);\r\n            if (i - k + 1 >= 0) {\r\n                res[i - k + 1] = nums[dq.peekFirst()];\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(n)\r\nSPACE:O(k)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330871820","body":"## 思路\n## 代码\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] count = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0];\n            int y = edge[1];\n            ++count[y];\n            --count[x];\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (count[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n## 算法复杂度\nTIME:O(n)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1333970472","body":"\r\n## 思路\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    ArrayList<Integer>[] g;\r\n    Map<Integer, Integer> color;\r\n    public boolean possibleBipartition(int N, int[][] dislikes) {\r\n        g = new ArrayList[N+1];\r\n        for (int i = 1; i <= N; ++i){\r\n            g[i] = new ArrayList();\r\n        }\r\n        for (int[] edge: dislikes) {\r\n            g[edge[0]].add(edge[1]);\r\n            g[edge[1]].add(edge[0]);\r\n        }\r\n        color = new HashMap();\r\n        for (int o = 1; o <= N; ++o){\r\n            if (!color.containsKey(o) && !dfs(o, 0))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    public boolean dfs(int o, int c) {\r\n        if (color.containsKey(o)){\r\n             return color.get(o) == c;\r\n        }\r\n        color.put(o, c);\r\n        for (int t: g[o]){\r\n            if (!dfs(t, c ^ 1))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```\r\n## 算法复杂度\r\nTIME:O(v+e)\r\nSPACE:O(v+e)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333997574","body":"\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n   public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n        List<Integer>[] gAdj = new ArrayList[m];\r\n        List<Integer>[] iAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            gAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            iAdj[i] = new ArrayList<>();\r\n        }\r\n        int[] gInde = new int[m];\r\n        int[] iInde = new int[n];\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    gAdj[beforeGroup].add(currentGroup);\r\n                    gInde[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                iAdj[item].add(i);\r\n                iInde[i]++;\r\n            }\r\n        }\r\n        //得到结果\r\n        List<Integer> groupsList = topologicalSort(gAdj, gInde, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(iAdj, iInde, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        // 据结果，多对一,一对多\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335472323","body":"## 思路\r\n模拟\r\n\r\n## 代码\r\n```java\r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0, y = 0;\r\n        for(char move: moves.toCharArray()) {\r\n            if(move == 'R') {\r\n                x++;\r\n            } else if(move == 'L') {\r\n                x--;\r\n            } else if(move == 'U') {\r\n                y++;\r\n            } else if(move == 'D') {\r\n                y--;\r\n            }\r\n        }\r\nboolean r=x == 0 && y == 0;\r\n        return r;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336188278","body":"## 思路\n\n\n## 代码\n```python\n\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n\n```\n## 算法复杂度\nTIME:O(nlogn)\nSPACE:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336437667","body":"## 思路\n模拟\n- 切割字符串获取开始结束时间\n- 处理出时间的有效值\n- 计算开始结束的总分钟数，计算局数\n\n## 代码\n```python\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n//切割字符串为小时，分钟值，获取开始结束时间的值\n        sh, sm = map(int, startTime.split(\":\"))\n        eh, em = map(int, finishTime.split(\":\"))\n        d = 0\n        if sh * 60 + sm > eh * 60 + em: d += 1\n//据时间在有效范围内赋值到有效开始时间\n        if 0 < sm <= 15:\n            sm = 15\n        elif 15 < sm <= 30:\n            sm = 30\n        elif 30 < sm <= 45:\n            sm = 45\n        elif 45 < sm <= 60:\n            sm = 0\n            sh += 1\n//结束时间处理，取最接近的小于等于自身的有效时间\n        if 0 <= em < 15:\n            em = 0\n        elif 15 <= em < 30:\n            em = 15\n        elif 30 <= em < 45:\n            em = 30\n        elif 45 <= em < 60:\n            em = 45\n//计算开始时间，结束时间，用于计算局数\n        st = sh * 60 + sm\n        et = eh * 60 + em\n        if d == 1: et += 24 * 60\n        return max(0, (et - st)) \n```\n## 算法复杂度\nTime：O(1)\nSpace: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1342936165","body":"## 代码\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int l = 0, r = x, \r\n        int res = -1;\r\n        while (l <= r) {\r\n            int m= l + (r - l) / 2;\r\n            if ((long) m * m <= x) {\r\n                res = m;\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342939118","body":"## 代码\r\n```java\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int l = 1;\r\n        int r = n;\r\n        while (l <= r) {\r\n            int m = l + ((r - l) >> 1);\r\n            if (isBadVersion(m)) {\r\n                r = m -1;\r\n            } else {\r\n                l = m + 1;\r\n            }\r\n        }\r\n\r\n        return l;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344477824","body":"```python\r\nclass Solutempion:\r\n    def reversePairs(self, nums: List[int]) -> int:\r\n        self.cnt = 0\r\n        def merge(nums, start, mid, end, temp):\r\n            i, j = start, mid + 1\r\n            while i <= mid and j <= end:\r\n                if nums[i] <=  nums[j]:\r\n                    temp.append(nums[i])\r\n                    i += 1\r\n                else:\r\n                    temp.append(nums[j])\r\n                    j += 1\r\n            tempi, tempj = start, mid + 1\r\n            while tempi <= mid and tempj <= end:\r\n                if nums[tempi] <=  2 * nums[tempj]:\r\n                    tempi += 1\r\n                else:\r\n                    self.cnt += mid - tempi + 1\r\n                    tempj += 1\r\n            while i <= mid:\r\n                temp.append(nums[i])\r\n                i += 1\r\n            while j <= end:\r\n                temp.append(nums[j])\r\n                j += 1\r\n            for i in range(len(temp)):\r\n                nums[start + i] = temp[i]\r\n            temp.clear()\r\n\r\n        def mergeSort(nums, start, end, temp):\r\n            if start >= end: return\r\n            mid = (start + end) >> 1\r\n            mergeSort(nums, start, mid, temp)\r\n            mergeSort(nums, mid + 1, end, temp)\r\n            merge(nums, start, mid,  end, temp)\r\n        mergeSort(nums, 0, len(nums) - 1, [])\r\n        return self.cnt\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345294015","body":"\n```class Solution {\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345588310","body":"```java\nimport java.util.*;\n\nclass Solution {\n    public int solve(int[] nums, int k) {\n        Arrays.sort(nums);\n        int absMin = 0;\n        int absMax = nums[nums.length-1] - nums[0];\n\n        while (absMin <= absMax) {\n            int absMid = (absMin + absMax) / 2;\n            if (countNotGreater(nums, absMid) <= k) {\n                absMin = absMid + 1;\n            } else {\n                absMax = absMid - 1;\n            }\n        }\n\n        return absMin;\n    }\n\n    private long countNotGreater(int[] nums, int tar) {\n        long count = 0;\n        int l = 0;\n        for (int r=1; r<nums.length; r++) {\n            while (nums[r] - nums[l] > tar) {\n                l++;\n            }\n\n            count += r - l;\n        }\n        return count;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346783385","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(vec) for vec in grid])\n        seen = set()\n\n        def test(mid, x, y):\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            if grid[x][y] > mid:\n                return False\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n            return ans\n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348878729","body":"```java\npublic int maxVowels(String s, int k) {\n\n    if (s == null || s.length() < k)\n        return 0;\n\n    int res = 0;\n    Set<Character> set = new HashSet<>(){{\n        add('a');add('e');add('i');add('o');add('u');\n    }};\n\n    // init\n    for (int i = 0; i < k; i++)\n        if (set.contains(s.charAt(i)))\n            res++;\n\n    int cur = res;\n    for (int i = 1; i < s.length() - k + 1; i++) {\n\n        if (set.contains(s.charAt(i - 1)))\n            cur--;\n        if (set.contains(s.charAt(i + k - 1)))\n            cur++;\n\n        res = Math.max(res, cur);\n    }\n\n    return res;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351685624","body":"```\nclass Solution {\n     public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1;\n        double dp[] = new double[N + 1],  Wsum = 1, res = 0;\n        dp[0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            dp[i] = Wsum / W;\n            if (i < K) Wsum += dp[i]; else res += dp[i];\n            if (i - W >= 0) Wsum -= dp[i - W];\n        }\n        return res;\n    }\n}\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356317053","body":"```\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356834398","body":"```\r\nclass Solution:\r\n    def readBinaryWatch(self, num: int) -> List[str]:\r\n        def possible_number(count, minute=False):\r\n            if count == 0: return [0]\r\n            if minute:\r\n                return filter(lambda a: a < 60, map(sum, combinations([1, 2, 4, 8, 16, 32], count)))\r\n            return filter(lambda a: a < 12, map(sum, combinations([1, 2, 4, 8], count)))\r\n        ans = set()\r\n        for i in range(min(4, num + 1)):\r\n            for a in possible_number(i):\r\n                for b in possible_number(num - i, True):\r\n                    ans.add(str(a) + \":\" + str(b).rjust(2, '0'))\r\n        return list(ans)\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359615886","body":"\r\n```\r\nclass Solution:\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        m = len(grid)\r\n        if m == 0: return 0\r\n        n = len(grid[0])\r\n        ans = 0\r\n        def dfs(i, j):\r\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\r\n            if grid[i][j] == 0: return 0\r\n            grid[i][j] = 0\r\n            top = dfs(i + 1, j)\r\n            bottom = dfs(i - 1, j)\r\n            left = dfs(i, j - 1)\r\n            right = dfs(i, j + 1)\r\n            return 1 + sum([top, bottom, left, right])\r\n        for i in range(m):\r\n            for j in range(n):\r\n                ans = max(ans, dfs(i, j))\r\n        return ans\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298431856","body":"### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = 0\r\n        carry = k\r\n        for i in range(len(num)-1,-1,-1):\r\n            tem = num[i] + carry\r\n            print(tem)\r\n            if tem // 10 > 0 :\r\n                carry = tem // 10\r\n                num[i] = tem % 10\r\n                print(carry)\r\n            else:\r\n                num[i] = tem % 10\r\n                carry = 0\r\n                break\r\n        if carry < 10 and carry > 0:\r\n             return [carry] + num\r\n        else:\r\n            while(carry):\r\n                print(carry)\r\n                num = [carry % 10] + num\r\n                carry = carry // 10\r\n                print(num)\r\n        return num\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305503158","body":"```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        if not head or not head.next:\r\n            return head\r\n        count = 1\r\n\r\n        while(tail.next):\r\n            tail = tail.next\r\n            count += 1\r\n    \r\n        if k % count == 0:\r\n            return head\r\n\r\n        #首尾相连\r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298538203","body":"## 思路\n\n> + 思路描述 \n\n## 代码\n\n```python\n# 代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp = temp + str(i)\n        return [int(i) for i in str(int(temp)+k)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300753664","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302258679","body":"class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307019179","body":"class Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        start = pre = ListNode()\n        pre.next = head\n        while pre.next and pre.next.next:\n            slow, fast = pre.next, pre.next.next\n            slow.next = fast.next\n            fast.next = slow\n            pre.next = fast\n            pre = slow\n        return start.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308536551","body":"class Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode();\n        root.val = mid.val;\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    public ListNode getMid(ListNode left,ListNode right){\n        ListNode slow = left;\n        ListNode fast = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311883070","body":"    public ListNode detectCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast !=null && fast.next !=null){\n            fast = fast.next.next;\n            slow = slow.next;\n            if(slow == fast){\n                break;\n            }\n        }\n        if(fast == null || fast.next==null){\n            return null;\n        }\n        \n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317194064","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318816329","body":"public class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320911248","body":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            auto iter = mp.find(target - nums[i]);\n            if (iter != mp.end()) {\n                return {iter->second, i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325893200","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> modulo_count = {{0, 1}};\n        int sum = 0;\n        int count = 0;\n        for (auto& num : nums) {\n            sum += num;\n            int modulo = (sum % k + k) % k;\n            count += modulo_count[modulo];\n            modulo_count[modulo]++;\n        }\n        return count;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068040","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        // 读p写p1指针\n        int p = 0, p1 = 0;\n        while(p1 < nums.length){\n            if(nums[p] != nums[p1]){\n                p++;\n                nums[p] = nums[p1];\n            }\n            p1++;\n        }\n        return p + 1;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328272331","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left<=right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n                ans = mid;\n            }\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329254304","body":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        deque<int> q;\n        for (int i = 0; i < k; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n\n        vector<int> ans = {nums[q.front()]};\n        for (int i = k; i < n; ++i) {\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\n                q.pop_back();\n            }\n            q.push_back(i);\n            while (q.front() <= i - k) {\n                q.pop_front();\n            }\n            ans.push_back(nums[q.front()]);\n        }\n        return ans;\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332315578","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3-c):\n                    return False\n            return True\n        \n        g = defaultdict(list)\n        color = [0]*n\n        for a,b in dislikes:\n            a, b = a-1, b-1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i,1) for i,c in enumerate(color))","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336056340","body":"class Solution {\n    public int[] getOrder(int[][] _tasks) {\n        int n = _tasks.length;\n        // 编号，进入时间，耗时\n        int[][] tasks = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            tasks[i] = new int[]{i, _tasks[i][0], _tasks[i][1]};\n        }\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\n        // 耗时，编号\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n        int[] ans = new int[n];\n        for (int i = 0, cnt = 0, time = 1; cnt < n;) {\n            while (i < n && tasks[i][1] <= time) {\n                sortTasks.offer(new int[]{tasks[i][2], tasks[i][0]});\n                i++;\n            }\n            if (sortTasks.isEmpty()) {\n                time = tasks[i][1];\n                continue;\n            }\n            int[] cur = sortTasks.poll();\n            ans[cnt++] = cur[1];\n            time += cur[0];\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336349392","body":"class Solution:\ndef numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\nstart_hour, start_min = int(loginTime[:2]), int(loginTime[3:])\nend_hour, end_min = int(logoutTime[:2]), int(logoutTime[3:])\nif (start_hour > end_hour) or (start_hour == end_hour and start_min > end_min):\nend_hour += 24\nanswer = 0\nminutes = [0, 15, 30, 45]\nif not (start_hour == end_hour and start_min <= end_min):\nanswer += 4 * (end_hour - start_hour - 1) + 4 - bisect_left(minutes, start_min) + bisect_right(minutes, end_min) - 1\nelse:\nfor i in range(3):\nif start_min <= minutes[i] and minutes[i + 1] <= end_min:\nanswer += 1\nreturn answer","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339427230","body":"class Solution {\n    int partition(vector<int>& nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[r]);\n        return i + 1;\n    }\n    int randomized_partition(vector<int>& nums, int l, int r) {\n        int i = rand() % (r - l + 1) + l; \n        swap(nums[r], nums[i]);\n        return partition(nums, l, r);\n    }\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\n        if (l < r) {\n            int pos = randomized_partition(nums, l, r);\n            randomized_quicksort(nums, l, pos - 1);\n            randomized_quicksort(nums, pos + 1, r);\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        srand((unsigned)time(NULL));\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341174774","body":"class Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x;\n        int l = 0, r = x;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (mid > x / mid) r = mid;\n            else l = mid + 1;\n        }\n        return l - 1;\n    }\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1346827302","body":"class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        # 帮助函数判断是否为元音字母\n        def isVowel(ch):\n            return int(ch in \"aeiou\")\n        \n        n = len(s)\n        # 计算所有元音字母的数量\n        vowel_count = sum(1 for i in range(k) if isVowel(s[i]))\n        ans = vowel_count\n        # 如果k=s长度，则直接返回原因字母总数量\n        for i in range(k, n):\n            # i为右指针，下一个要进入滑动窗口的值，i-k为左指针下一个要进入滑动窗口的值\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k])\n            ans = max(ans, vowel_count)   # 结果是所有滑动窗口的最大值\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1353398366","body":"class Solution {\npublic:\n    unordered_map <char, int> ori, cnt;\n\n    bool check() {\n        for (const auto &p: ori) {\n            if (cnt[p.first] < p.second) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    string minWindow(string s, string t) {\n        for (const auto &c: t) {\n            ++ori[c];\n        }\n\n        int l = 0, r = -1;\n        int len = INT_MAX, ansL = -1, ansR = -1;\n\n        while (r < int(s.size())) {\n            if (ori.find(s[++r]) != ori.end()) {\n                ++cnt[s[r]];\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                }\n                if (ori.find(s[l]) != ori.end()) {\n                    --cnt[s[l]];\n                }\n                ++l;\n            }\n        }\n\n        return ansL == -1 ? string() : s.substr(ansL, len);\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356824659","body":"const transform2Binary = (num) => num.toString(2)\nconst getOneCount = (binary) => binary.split('0').join('').length\n\nconst readBinaryWatch = (turnedOn) => {\n    const result = []\n    for (let h = 0; h < 12; h++) {\n        for (let m = 0; m <= 59; m++) {\n            if (getOneCount(transform2Binary(h)) + getOneCount(transform2Binary(m)) === turnedOn) {\n                result.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m)\n            }\n        }\n    }\n    return result\n}\n\n##  复杂度分析\n时间复杂度：O(1)\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361538571","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        steps = -1\n        queue = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        while len(queue) > 0:\n            for _ in range(len(queue)): \n                x, y = queue.pop(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n                \n        return steps","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364489913","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        # dp数组\n        dp = [0] * (n+1)\n        # 动态转移方程，需要判断对迭代顺序\n        for i in range(2, n+1):\n            dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])\n        return dp[n]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364686250","body":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n\n        size = len(nums)\n        if size == 1:\n            return nums[0]\n        \n        dp = [0] * size\n        dp[0] = nums[0]\n        dp[1] = max(nums[0], nums[1])\n        for i in range(2, size):\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\n        \n        return dp[size - 1]\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366639112","body":"class Solution {\n    public int uniquePaths(int m, int n) {\n        int[] cur = new int[n];\n        Arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] += cur[j-1] ;\n            }\n        }\n        return cur[n-1];\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368468073","body":"class Solution {\n    int count = 0;\n\n    public int findTargetSumWays(int[] nums, int target) {\n        backtrack(nums, target, 0, 0);\n        return count;\n    }\n\n    public void backtrack(int[] nums, int target, int index, int sum) {\n        if (index == nums.length) {\n            if (sum == target) {\n                count++;\n            }\n        } else {\n            backtrack(nums, target, index + 1, sum + nums[index]);\n            backtrack(nums, target, index + 1, sum - nums[index]);\n        }\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372390313","body":"class Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.size() == 0) return 0;\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (end <= intervals[i][0]) {\n                end = intervals[i][1];\n                count++;\n            }\n        }\n        return intervals.size() - count;\n    }\n\n    static bool cmp (const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    }\n\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374505939","body":"排列组合\n左边子树比顶点 i 小，右边大\n计算累加和 i*（n-i-1）\n\nclass Solution {\n    vector<int> vis;\n    int dp(int n){\n        if(vis[n])return vis[n];\n        int ans=0;\n        for(int i=0;i<n;++i)ans+=dp(i)*dp(n-i-1);\n        return vis[n]=ans;\n    }\npublic:\n    int numTrees(int n) {\n        vis.assign(n+1,0);\n        vis[0]=1;\n        return dp(n);\n    }\n};\nclass Solution {\npublic:\n    int numTrees(int n) {\n        // G(n): 长度为 nn 的序列能构成的不同二叉搜索树的个数。\n        // F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数(1≤i≤n)。\n        // G(n)= i=1∑n F(i,n)\n        // F(i,n)=G(i−1)⋅G(n−i)\n        // G(n)= i=1∑n G(i−1)⋅G(n−i)\n        vector<int> G(n+1,0);\n        G[0]=1;\n        G[1]=1;\n\n        for(int i=2;i<=n;i++){\n            for(int j=1;j<=i;j++){\n                G[i]+=G[j-1]*G[i-j];\n            }\n        }\n        return G[n];\n    }\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381196337","body":"class MapSum {\npublic:\n    map<string,int> mapsum;\n    MapSum() {\n        \n    }\n    \n    void insert(string key, int val) {\n        mapsum[key]=val;\n    }\n    \n    int sum(string prefix) {\n        int sum=0;\n     for(auto [x,val]:mapsum){\n         if(x.substr(0,prefix.length())==prefix){\n            sum+=val;\n         }\n     }    \n        return sum; \n     }   \n\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1367378260","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> link=new LinkedList<>();\r\n\r\n        int i=num.length-1;\r\n        int temp=0;\r\n        int index=0;\r\n        while(index!=0||k!=0||i!=-1){\r\n            if(i>=0) {\r\n                temp = num[i--] + k % 10 + index;\r\n            }else{\r\n                temp=k%10+index;\r\n            }\r\n            \r\n            index=0;\r\n            if(temp>=10){\r\n                index=1;\r\n            }\r\n            link.addFirst(temp%10);\r\n            k/=10;\r\n            \r\n        }\r\n        return link;\r\n    }\r\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1367386651","body":"class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n         int[] res=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            res[i]=Integer.MAX_VALUE;\r\n            if(s.charAt(i)==c){\r\n                res[i]=0;\r\n            }\r\n        }\r\n        for(int i=1;i<s.length();i++){\r\n            if(res[i-1]!=Integer.MAX_VALUE){\r\n                res[i]=Math.min(res[i-1]+1,res[i]);\r\n            }\r\n        }\r\n        for(int i=s.length()-2;i>=0;i--){\r\n            res[i]=Math.min(res[i+1]+1,res[i]);\r\n        }\r\n        return res;\r\n    }\r\n}","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304714739","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n        int res = 0;\r\n        int[] sortedArr = new int[arr.length];\r\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\r\n        Arrays.sort(sortedArr);\r\n        for (int i = 0; i < sortedArr.length; i++) {\r\n            int x = arr[i], y = sortedArr[i];\r\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\r\n            if (cnt.get(x) == 0) {\r\n                cnt.remove(x);\r\n            }\r\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\r\n            if (cnt.get(y) == 0) {\r\n                cnt.remove(y);\r\n            }\r\n            if (cnt.isEmpty()) {\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312631240","body":"**Idea**\r\n\r\n```\r\n二叉树的最大深度一题，可用二叉树遍历法和动态规划法：\r\n二叉树遍历法：\r\n先遍历左节点，然后遍历右节点，在遍历过程中需要储存比较二叉树各分支的深度大小然后取最大值\r\n动态规划法：\r\n从整体出发，求出左右子树最大二叉树深度，最后再比较。\r\n```\r\n\r\n**code**\r\n\r\n```java\r\n\r\npublic class day13 {\r\n    public class TreeNode {\r\n      int val;\r\n      TreeNode left;\r\n      TreeNode right;\r\n      TreeNode() {}\r\n      TreeNode(int val) { this.val = val; }\r\n      TreeNode(int val, TreeNode left, TreeNode right) {\r\n          this.val = val;\r\n          this.left = left;\r\n          this.right = right;\r\n      }\r\n    }\r\n    //二叉树遍历法\r\n    int depth=0;//储存历史二叉树深度\r\n    int res=0;//储存临时二叉树深度\r\n    public int maxDepth(TreeNode root) {\r\n        traverse(root);\r\n        return res;\r\n        }\r\n        void traverse(TreeNode root){\r\n        if (root==null){\r\n            return ;\r\n        }\r\n        depth++;//深度加加\r\n            res=Math.max(res,depth);//当前深度与历史深度比较，取最大值\r\n        traverse(root.left);\r\n        traverse(root.right);\r\n        depth--;//遍历完后需要减去左结点那边加的1\r\n    }\r\n    //动态规划法\r\n    public int maxDepth1(TreeNode root) {\r\n        if(root==null)\r\n            return 0;\r\n        int leftMax=maxDepth1(root.left);//左子树最大深度\r\n        int rightMax=maxDepth1(root.right);//右子树最大深度\r\n        return 1+Math.max(leftMax,rightMax);//比较两子树深度，取最大值；深度节点累加\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319621774","body":"Idea\r\n\r\n```\r\n题目要求设计一个计算二叉树的垂序遍历序列。\r\n主要要求如下，\r\n结点为(row，col),则其左孩子为(row+1,col-1),右孩子为(row+1,col+1)\r\n二叉树的垂序遍历从最左边的列开始直到最右边的列结束，\r\n按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。\r\n若同行同列上有多个结点，按结点值大小进行排序。\r\n上述要求可转化为如下言语：\r\n1·首先使用dfs把二叉树的结点转化为坐标形式（坐标轴可自定义）\r\n2·然后按x坐标从小到大排序（此时x为列）\r\n3·同x坐标，按y坐标从大到小排序（此时y为行）\r\n4·同x、y坐标，按值从小到达排序\r\n5·将同x坐标的结点储存在一个ArrayList中\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class day18 {\r\n   List<int[]> totalList=new ArrayList<>();\r\n   public List<List<Integer>>verticalTraversal(TreeNode root){\r\n       dfs(root,0,0);\r\n\r\n       //按x、y、val比较\r\n       Collections.sort(totalList,(a,b)->{\r\n           if(a[0]!=b[0]){//列从小到大\r\n               return a[0]-b[0];//结果从小到大返回\r\n           }\r\n           if(a[1]==b[1]){//列行相等，按值大小\r\n               return a[2]-b[2];//结果从小到大返回\r\n           }\r\n           //列相等，行从大到小\r\n           return b[1]-a[1];//结果从大到小返回\r\n       });\r\n       //经过比较器的比较后，\r\n       //totalList里面的元素根据x、y、val从小到大排列\r\n       List<List<Integer>>res=new ArrayList<>();\r\n       if(totalList.size()==0)return res;\r\n       res.add(new ArrayList<>());\r\n       //取最小列的序号\r\n       int pre=totalList.get(0)[0];\r\n       for(int[] sub:totalList){\r\n           //如果上一列已经全部添加完毕，执行if语句块，新建一个ArrayList()储存下一列\r\n           if(pre!=sub[0]){\r\n               pre=sub[0];\r\n               res.add(new ArrayList<>());\r\n           }\r\n           res.get(res.size()-1).add(sub[2]);//把相应的值添加到相应的列中\r\n\r\n       }\r\n       return res;\r\n\r\n    }\r\n    //把给定二叉树的结点转化为坐标存在，储存在totalList列表中\r\n    void dfs(TreeNode node,int x,int y){\r\n       if(node==null)return ;\r\n        //代码坐标轴：\r\n        //从左到右为正（小到大排序）\r\n        //从下到上为正（大到小排序）\r\n        //(纵坐标，横坐标)\r\n       dfs(node.left,x-1,y-1);\r\n       dfs(node.right,x+1,y-1);\r\n       totalList.add(new int[]{x,y,node.val});\r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323630582","body":"Idea\r\n\r\n```\r\n主要是使用滑动窗口。右窗口先向前移动，然后用HashMap对字符计数，若有字符个数超过1，则左窗口+1，直至字符个数重新等于1，然后右窗口再向前移动，由此循环往复。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n           HashMap<Character,Integer> window=new HashMap<>();\r\n        int left=0,right=0;\r\n        int res=0;\r\n        while(right<s.length()){\r\n            char c=s.charAt(right);\r\n            right++;\r\n            window.put(c,window.getOrDefault(c,0)+1);\r\n            while (window.get(c)>1){\r\n                char d=s.charAt(left);\r\n                left++;\r\n                window.put(d,window.get(d)-1);\r\n            }\r\n            res=Math.max(res,right-left);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327974445","body":"**Idea**\r\n\r\n```\r\n使用双指针，定义两个同起点的读写指针，然后用fast(读指针)找不同元素，slow(写指针)写入元素。\r\n该题主要解题思路：从一个数组中，剔除重复元素，按顺序只保留不重复的元素。\r\n开始时，不知道那些元素是不重复的，然后用读指针去试探，找出不同的元素；找到不同元素后，写指针向前移动一步，以写入这个元素。\r\n```\r\n\r\n**Code**\r\n\r\n```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int slow=0,fast=1;\r\n            if(nums[slow]==nums[fast]) {\r\n                while (nums[slow] == nums[fast]) {\r\n                    fast++;\r\n                }\r\n                slow++;\r\n                int temp=slow;\r\n                while(temp<=fast) {\r\n                    nums[temp] = nums[fast];\r\n                }\r\n            }\r\n            if(nums[slow]!=nums[fast]&&fast<nums.length){\r\n                slow++;\r\n                fast++;\r\n            }\r\n            return slow+1; \r\n    }\r\n}\r\n```\r\n\r\n\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332761344","body":"Idea\r\n\r\n\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335150379","body":"Idea\r\n\r\n```\r\n定义res_x,res_y两个变量\r\n分别根据字母对这两个变量进行操作，根据判断它们是否等于0来返回相应得boolean值\r\n```\r\n\r\nCode\r\n\r\n```java\r\npublic class day32 {\r\n    public boolean judgeCircle(String moves) {\r\n        int res_x=0,res_y=0;\r\n        for(int i=0;i<moves.length();i++){\r\n            if(moves.charAt(i)=='R'){\r\n                res_x+=1;\r\n            }else if(moves.charAt(i)=='L'){\r\n                res_x-=1;\r\n            }else if(moves.charAt(i)=='U'){\r\n                res_y-=1;\r\n            }else if(moves.charAt(i)=='D'){\r\n                res_y+=1;\r\n            }\r\n        }\r\n        if(res_x==0&&res_y==0)\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\nComplex\r\n\r\n```\r\nTime:O(n)\r\nSpace:O(1)\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336187992","body":"Idea\r\n\r\n```\r\n题目要求设置一个单线程CPU，该CPU会按以下方式运行：\r\n前提：给定任务格式：[开始时间，执行时间]\r\n1·CPU空闲，且任务队列中没有需要执行的任务，CPU保持空闲状态\r\n2·CPU空闲，单任务队列中又需要执行的任务，CPU会选择执行时间最短的任务开始执行，若多个任务具有同样的执行时间，则选取下标最小的任务开始执行\r\n3·一旦某项任务开始执行，CPU在执行完整个任务前都不会停止\r\n4·CPU可以在完成一项任务后，立即开始执行一项新任务\r\n\r\n根据上述描述，可转化为以下计算机语言：\r\n1·首先按从上到下的顺序给任务编号\r\n2·其次，根据开始时间从小到大进行排序，便于后续入队处理\r\n3·定义一个优先队列，队列排序原则为：同执行时间，按下标从小到大进行排序\r\n4·使用双while循环，进行入队和任务处理操作\r\n```\r\n\r\nCode\r\n\r\n```java\r\n public int[] getOrder(int[][] tasks){\r\n        int n=tasks.length;\r\n        int[] ans=new int[n];\r\n        int[][] extTasks=new int[n][3];\r\n        //对任务进行编号\r\n        for (int i=0;i<n;i++){\r\n            extTasks[i][0]=i;\r\n            extTasks[i][1]=tasks[i][0];\r\n            extTasks[i][2]=tasks[i][1];\r\n        }\r\n        //按任务开始时间进行排序，以便于后面入队处理\r\n        Arrays.sort(extTasks,(a,b)->a[1]-b[1]);//根据开始时间对任务进行从小到大的排序\r\n        //定义一个队列排序器，\r\n        //处理短的先出队；若处理时间相同，则下标小的任务优先处理\r\n        PriorityQueue<int[]>pq=new PriorityQueue<int[]>((a,b)->a[2]==b[2]?a[0]-b[0]:a[2]-b[2]);\r\n        int time=0;//处理时间\r\n        int ai=0;//已排序的任务数量\r\n        int ti=0;//待排序任务下标\r\n        while(ai<n){\r\n            //任务入队\r\n            while(ti<n&&extTasks[ti][1]<=time){\r\n                pq.offer(extTasks[ti++]);\r\n            }\r\n            //开始时，若当前时间点没有任务，快进至有任务的地方\r\n            if(pq.isEmpty()){\r\n                time=extTasks[ti][1];\r\n                continue;\r\n            }\r\n            //任务处理\r\n            int[] bestFit=pq.poll();//弹出处理时间最短的结点\r\n            ans[ai++]=bestFit[0];//储存任务编号\r\n            time+=bestFit[2];//计算处理时间\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341189999","body":"Idea\r\n\r\n```\r\n使用二分，使用二分中的判断左边界，左边界最小可以取到多少，注意可以取到等号，\r\n并且还要注意提前把值保存。\r\n\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int left=0,right=x,ans=0;\r\n        while(left<=right){\r\n            int mid=(right-left)/2+left;\r\n            if((long)mid*mid<=x){\r\n                left=mid+1;\r\n                ans=mid;\r\n            }else\r\n                right=mid-1;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\nComplex\r\n\r\n```\r\nTime:O(logn)\r\nSpace:O(1)\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341224829","body":"Idea\n\n```\n使用二分，利用判断左边界的方法，如果是错误的版本，则有右边界减一；如果是正确的版本，则左边界加一\n```\n\nCode\n\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left=0,right=n;\n        while(left<right){\n            int mid=(right-left)/2+left;\n            if(isBadVersion(mid)){\n                right=mid;\n            }else\n                left=mid+1;\n        }\n        return left;\n    }\n}\n```\n\nComplex\n\n```\nTime:O(logn)\nSpace:O(1)\n```\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352477791","body":"class Solution {\r\n    public:\r\n    vector<int> findAnagrams(string s, string t) {\r\n        unordered_map<char, int> need, window;\r\n        for (char c : t) need[c]++;\r\n\r\n        int left = 0, right = 0;\r\n        int valid = 0;\r\n        vector<int> res; // 记录结果\r\n        while (right < s.size()) {\r\n            char c = s[right];\r\n            right++;\r\n            // 进行窗口内数据的一系列更新\r\n            if (need.count(c)) {\r\n                window[c]++;\r\n                if (window[c] == need[c])\r\n                    valid++;\r\n            }\r\n            // 判断左侧窗口是否要收缩\r\n            while (right - left >= t.size()) {\r\n                // 当窗口符合条件时，把起始索引加入 res\r\n                if (valid == need.size())\r\n                    res.push_back(left);\r\n                char d = s[left];\r\n                left++;\r\n                // 进行窗口内数据的一系列更新\r\n                if (need.count(d)) {\r\n                    if (window[d] == need[d])\r\n                        valid--;\r\n                    window[d]--;\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362953325","body":"public int findShortestCircleContainingTarget(List<List<Integer>> graph, int target) {\r\n    Queue<Integer> queue = new ArrayDeque<>();\r\n    Set<Integer> seen = new HashSet<>();\r\n    queue.offer(target);\r\n\r\n    int len = 0;\r\n    while (!queue.isEmpty()) {\r\n        len++;\r\n        for (int size = queue.size(); size > 0; size--) {\r\n            var cur = queue.poll();\r\n            seen.add(cur);\r\n\r\n            for (var next : graph.get(cur)) {\r\n                if (!seen.contains(next))\r\n                    queue.offer(next);\r\n                else if (next == target)\r\n                    return len;\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367300261","body":"class Solution {\r\n\r\n    private int[][] dir = {{-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}, {-2, -1}};\r\n\r\n    public double knightProbability(int N, int K, int r, int c) {\r\n\r\n        double[][] dp = new double[N][N];\r\n        dp[r][c] = 1;\r\n\r\n        for (int step = 1; step <= K; step++) {\r\n\r\n            double[][] dpTemp = new double[N][N];\r\n\r\n            for (int i = 0; i < N; i++)\r\n                for (int j = 0; j < N; j++)\r\n                    for (int[] direction : dir) {\r\n\r\n                        int lastR = i - direction[0];\r\n                        int lastC = j - direction[1];\r\n                        if (lastR >= 0 && lastR < N && lastC >= 0 && lastC < N)\r\n                            dpTemp[i][j] += dp[lastR][lastC] * 0.125;\r\n                    }\r\n\r\n            dp = dpTemp;\r\n        }\r\n\r\n        double res = 0;\r\n\r\n        for (int i = 0; i < N; i++)\r\n            for (int j = 0; j < N; j++)\r\n                res += dp[i][j];\r\n\r\n        return res;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371711626","body":"class Solution:\r\ndef eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\nn = len(intervals)\r\nif n == 0: return 0\r\nintervals.sort(key = lambda x:x[1])\r\nprint(intervals)\r\ncount = 0\r\nr = intervals[0][1]\r\nfor i in range(1,n):\r\n\r\n        if r > intervals[i][0]:\r\n            count += 1\r\n        else:\r\n            r  = intervals[i][1]\r\n    return count","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298745122","body":"思路\r\n遍历两个数组\r\n代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kNum = new ArrayList<>();\r\n        while(k!=0) {\r\n            kNum.add(k%10);\r\n            k/=10;\r\n        }\r\n        List<Integer> arrayNum = new ArrayList<>();\r\n        for(int i = num.length-1; i >= 0; i--) {\r\n            arrayNum.add(num[i]);\r\n        }\r\n        int i = 0, add = 0, j = Math.min(kNum.size(), arrayNum.size());\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i < j) {\r\n            ans.add((kNum.get(i)+arrayNum.get(i)+ add)%10 );\r\n            add = (kNum.get(i)+arrayNum.get(i)+ add)/10;\r\n            i++;\r\n        }\r\n        if(j == kNum.size()) {\r\n            while (i<arrayNum.size()) {\r\n                ans.add((arrayNum.get(i)+add)%10);\r\n                add = (arrayNum.get(i)+add)/10;\r\n                i++;\r\n            }\r\n        } else {\r\n            while (i<kNum.size()) {\r\n                ans.add((kNum.get(i)+ add)%10 );\r\n                add = (kNum.get(i)+ add)/10;\r\n                i++;\r\n            }\r\n        }\r\n        if(add!=0) ans.add(add);\r\n        List<Integer> realAns = new ArrayList<>();\r\n        for(int n = ans.size()-1;n>=0; n--) {\r\n            realAns.add(ans.get(n));\r\n        }\r\n        return realAns;\r\n    }\r\n}\r\n```\r\n复杂度\r\nO(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568664","body":"```java\nimport java.util.Stack;\n\nclass MyQueue {\n    Stack<Integer> stack;\n    Stack<Integer> tempStack;\n\n    public MyQueue() {\n        this.stack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.isEmpty()) {\n            stack.push(x);\n        } else {\n          while(!stack.isEmpty()) {\n              tempStack.push(stack.pop());\n          }\n          stack.push(x);\n          while(!tempStack.empty()) {\n              stack.push(tempStack.pop());\n          }\n        }\n    }\n    \n    public int pop() {\n        return stack.pop();\n    }\n    \n    public int peek() {\n        return stack.peek();\n    }\n    \n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304824953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304848410","body":"```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0)\n            return head;\n        ListNode pointer = head;\n        int count = 0;\n        while(pointer.next != null) {\n            pointer = pointer.next;\n            count++;\n        }\n        pointer.next = head;\n        count++;\n        int times = k/count+1;\n        for(int i = 0; i < count - (k%count); i++) {\n            head = head.next;\n            pointer = pointer.next;\n        }\n        ListNode ans = head;\n        pointer.next = null;\n        return ans;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298531682","body":"### 代码优化：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n        k = Math.floor(k / 10) = 100 \r\n        k = k + 1 = 101\r\n        res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299438780","body":"### 代码优化：\r\n问题可以转换成，对 s 的每个下标 i，求\r\n\r\ns[i] 到其左侧最近的字符 c 的距离\r\ns[i] 到其右侧最近的字符 c 的距离\r\n这两者的最小值。\r\n\r\n代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    // 两次遍历\r\n    var len = s.length;\r\n    var ans = new Array(len).fill(0);\r\n    var idl = -len;\r\n    var idr = 2 * len;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            idl = i;\r\n        }\r\n        ans[i] = i - idl;\r\n    }\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            idr = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], idr - i);\r\n    }\r\n    return ans;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1303543816","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度: push和pop为O（1），increment为O（min（k，top））\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303544379","body":"### 思路：\r\n遍历数组，\r\n1. 如果是'[',直接入栈\r\n2. 如果是'数字'，将连续数字字符识别出来，统一放入栈中\r\n3. 如果是']',进行处理\r\n-  ① 连续获取字符串，直到遇到”[“\r\n- ② 取出数字\r\n- ③ 计算出字符串后再入栈\r\n4. 如果是'普通字符'，正常入栈\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304811807","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304811620","body":"### 思路：\r\n单调栈（递增）\r\n- 当前值大于等于栈顶，可以成块\r\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\r\n\r\n### 代码\r\n```js\r\n// 获取栈顶元素\r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // 小于的时候，只保留栈顶用于成块\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= 可以独立成块\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1308083057","body":"### 思路：\r\n取余数 + 快慢指针\r\n\r\n### 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    function ListNode(val, next) {\r\n        this.val = (val===undefined ? 0 : val)\r\n        this.next = (next===undefined ? null : next)\r\n    }\r\n    if (!head) {\r\n        return head;\r\n    }\r\n    let dummyNode = new ListNode();\r\n    dummyNode.next = head;\r\n    let cur = head;\r\n    // 计算链表的长度\r\n    let length = 1;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        length ++;\r\n    }\r\n    // 快慢指针的间距\r\n    k = k % length;\r\n    let slowNode = head;\r\n    let fastNode = head;\r\n    for (let i = 1; i <= k; i++) {\r\n        fastNode = fastNode.next;\r\n    }\r\n\r\n    // 快慢指针同时前进\r\n    while(fastNode.next) {\r\n        slowNode && (slowNode = slowNode.next);\r\n        fastNode = fastNode.next;\r\n    }\r\n    // 调整节点\r\n    fastNode.next = head;\r\n    dummyNode.next = slowNode.next;\r\n    slowNode.next = null;\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1308083819","body":"### 思路：\r\n记录前中后节点\r\n待优化，减少pre节点的记录改用xx.next\r\n\r\n### 代码\r\n```js\r\nfunction ListNode(val, next) {\r\n    this.val = (val===undefined ? 0 : val)\r\n    this.next = (next===undefined ? null : next)\r\n}\r\n\r\nvar swapPairs = function(head) {\r\n    if (!head) return head;\r\n    if (head && !head.next) return head;\r\n    // 创建dumy节点\r\n    let dummyNode = new ListNode();\r\n\r\n    let pre = dummyNode;\r\n    let cur = head;\r\n    let next = head.next;\r\n    while (true) {\r\n        pre.next = cur.next;\r\n        cur.next = next.next;\r\n        tmp = next.next;\r\n        next.next = cur;\r\n        \r\n        pre = cur;\r\n        if (tmp && tmp.next) {\r\n            cur = tmp;\r\n            next = tmp.next;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return dummyNode.next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308084315","body":"### 思路：\r\n1、将有序链表转成有序数组, 分治\r\n[-10,-3,0,5,9] 输出为[0,-10,5,null,-3,null,9]\r\n2、快慢指针\r\n为了断开，我们需要保存慢指针的前一个节点，因为单向链表的结点没有前驱指针。\r\n### 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n    const arr = [];\r\n    while (head) {\r\n        // 将链表节点的值逐个推入数组arr\r\n        arr.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // 根据索引start到end的子数组构建子树\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null; // 指针交错，形成不了子序列，返回null节点\r\n        // >>> 无符号右移动。math.floor\r\n        const mid = (start + end) >>> 1; // 求中间索引 中间元素是根节点的值\r\n        const root = new TreeNode(arr[mid]); // 创建根节点\r\n        root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n        root.right = buildBST(mid + 1, end); // 递归构建右子树\r\n        return root; // 返回当前子树\r\n    };\r\n    const root = buildBST(0, arr.length - 1); // 根据整个arr数组构建\r\n    return root;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1312734738","body":"### 思路：\r\n分别与另外一个链表’连接‘，第二轮时相遇\r\n没有修改next，只是不断改变当前指针而已，所以不会出环\r\n\r\n\r\n### 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA,\r\n        b = headB;\r\n    while (a != b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next;\r\n    }\r\n    return a;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1312734536","body":"### 思路：\r\n- 看官方题解总结的思路：定义 链表头部到链表入口有a个节点（不计链表入口节点），链表环有b个节点\r\n- 用快(fast)慢(low)指针第一次相遇。①fast = slow + nb； ② fast = 2low; ①-② 推导出slow = nb\r\n- 如果让指针从链表头部一直向前走并统计步数k，那么所有走到链表入口节点时的步数 是：k=a+nb，slow指针走过的步数为nb步。因此，我们只要想办法让slow再走a步停下来，就可以到环的入口。\r\n\r\n=> slow指针位置不变，将fast指针重新指向链表头部节点，slow和fast同时每轮向前走a步在链表入口相遇；\r\n\r\n### 代码\r\n```js\r\n var detectCycle = function(head) {\r\n    if (head === null) return null;\r\n    var slow = head;\r\n    var quick = head;\r\n    // 直到第一次相遇\r\n    while (true) {\r\n        // 慢指针每次前进一步\r\n        slow = slow.next;\r\n        // 快指针每次前进两步\r\n        quick = quick.next && quick.next.next || null;\r\n        // 无环\r\n        if (quick === null || slow === null) return null;\r\n        if (slow === quick) break;\r\n    }\r\n    // quick从头节点开始走，slow保持不变\r\n    if (slow === quick) {\r\n        quick = head;\r\n    }\r\n    // 快慢指针没次走一步\r\n    while (slow !== quick) {\r\n        slow = slow.next;\r\n        quick = quick.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312734318","body":"### 思路：\r\n求左右子树深度的最大值\r\n\r\n### 代码\r\n```js\r\nvar maxDepth = function(root) {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298650820","body":"### 思路\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+912, 2+91, 1+9, 0+1。\r\n\r\n自我复述视频： https://www.bilibili.com/video/BV14W4y1771Z/\r\n\r\n### 代码\r\n```js\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let i = num.length - 1 \r\n    let res = []\r\n\r\n    while(i>=0 || k>0){\r\n        if(i>=0){\r\n            k += num[i]\r\n            i --\r\n        }\r\n        res.push(k % 10)\r\n        k = parseInt(k /10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300481747","body":"**代码**\r\n```\r\nclass Solution:\r\n    def shortestToChar (self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [n + 1] * n\r\n        idx = -1\r\n        for i in range(n):  # 左侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != -1:\r\n                res[i] = i - idx\r\n\r\n        idx = n\r\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != n:\r\n                res[i] = min(idx - i, res[i])\r\n\r\n        return res\r\n```\r\n**复杂度**\r\n时间复杂度：$O(n)$ 。遍历 s 即可，\r\n空间复杂度： 。和 s 等长的结果数组，","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303481781","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305679863","body":"class Solution(object):\n\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            #首先考虑边界，特殊情况\n            if k == 0 or not head or not head.next:\n                return head\n            \n            n = 1\n            cur = head\n\n            while cur.next:\n                cur = cur.next # 这里cur更新后，head不会更新，因为cur被重新赋值了，如果cur.next=xxx，那么head.next也会变化\n                n += 1\n            \n            add = n - k % n # 断开的位置\n            if add == n:\n                return head\n            \n            cur.next = head # 连接闭环\n            while add:\n                print(add)\n                cur = cur.next\n                add -= 1\n            \n            ret = cur.next\n            cur.next = None\n            return ret","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331579660","body":"深度优先搜索\n\n```python\nclass Solution:\ndef possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\ng = [[] for _ in range(n)]\nfor x, y in dislikes:\ng[x - 1].append(y - 1)\ng[y - 1].append(x - 1)\ncolor = [0] * n # color[x] = 0 表示未访问节点 x\ndef dfs(x: int, c: int) -> bool:\ncolor[x] = c\nreturn all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\nreturn all(c or dfs(i, 1) for i, c in enumerate(color))\n```\n复杂度分析\n-时间复杂度 O(m+n)\n-空间复杂度O(m+n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339551996","body":"这道题需要时间复杂度为nlogn，而快排最坏时间复杂度是$n^2$，又因为题目要求最少的空间复杂度，所以选择基数排序\n\nfunc sortArray(nums []int) []int {\n\tif len(nums) < 2 {\n\t\treturn nums\n\t}\n\tfor i := 0; i < len(nums); i++ {\n\t\ttmp := nums[i]\n\t\tj := i\n\t\tfor ; j > 0 && nums[j-1] > tmp; j-- {\n\t\t\tnums[j] = nums[j-1]\n\t\t}\n\t\tif i != j {\n\t\t\tnums[j] = tmp\n\t\t}\n\t}\n\treturn nums\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347687003","body":"```cpp\nclass Solution {\npublic:\n    int maxVowels(string s, int k) {\n      unordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u'};\n      int cnt = 0, ans = 0;\n      int n = s.size();\n      for (int i = 0; i < n; i++) {\n        if (i >= k) cnt -= vowels.count(s[i - k]);\n        cnt += vowels.count(s[i]);\n        ans = max(ans, cnt);\n      }\n      return ans;\n    }\n};\n```\nT:O(n)  S:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370687604","body":"```python\nclass Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        g.sort(reverse=True)\n        s.sort(reverse=True)\n        gi, si = 0, 0\n        count = 0\n        \n        while si < len(s) and gi < len(g):\n            if g[gi] <= s[si]:\n                gi += 1\n                si += 1\n                count += 1\n            else:\n                gi += 1\n        return count\n```\n\n时间复杂度：由于使用了排序，因此时间复杂度大约为 O(nlogn)\n\n空间复杂度：取决于具体的排序方法","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302315589","body":"```ts\r\nclass CustomStack {\r\n  maxSize: number\r\n  stack: number[]\r\n\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.stack.length >= this.maxSize) return\r\n    this.stack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.stack.length === 0) return -1\r\n    return this.stack.pop()\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    for (let i = 0; i < k && i < this.stack.length; i++) this.stack[i] += val\r\n  }\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307419612","body":"```ts\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n  let dummyHead = new ListNode()\r\n  dummyHead.next = head\r\n  let cur = dummyHead\r\n  while (cur.next && cur.next.next) {\r\n    let next1 = cur.next,\r\n      next2 = next1.next.next\r\n    cur.next = next1.next\r\n    next1.next.next = next1\r\n    next1.next = next2\r\n    cur = next1\r\n  }\r\n  return dummyHead.next\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313916646","body":"```ts\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n  if (p === null && q === null) return true\r\n  if (p === null || q === null) return false\r\n  if (p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315505829","body":"```ts\r\nfunction sumNumbers(root: TreeNode | null): number {\r\n  return dfs(root, 0)\r\n};\r\n\r\nfunction dfs(root: TreeNode | null, preSum: number): number {\r\n  if (!root) return 0\r\n  const sum = preSum * 10 + root.val\r\n  if (!root.left && !root.right) return sum\r\n  return dfs(root.left, sum) + dfs(root.right, sum)\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317121716","body":"```ts\r\nfunction findBottomLeftValue(root: TreeNode | null): number {\r\n  if (!root) return 0\r\n  let ret = 0\r\n  let queue = [root]\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    ret = node.val\r\n    node.right && queue.push(node.right)\r\n    node.left && queue.push(node.left)\r\n  }\r\n  return ret\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318572975","body":"```ts\r\nfunction serialize(root: TreeNode | null): string {\r\n  if (!root) return ''\r\n  const ret = []\r\n  const queue = [root]\r\n\r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    if (node) {\r\n      ret.push(node.val)\r\n      queue.push(node.left)\r\n      queue.push(node.right)\r\n    } else {\r\n      ret.push('#')\r\n    }\r\n  }\r\n  return ret.join(',')\r\n}\r\n\r\nfunction deserialize(data: string): TreeNode | null {\r\n  if (!data) return null\r\n  const list = data.split(',')\r\n  const root = new TreeNode(+list.shift())\r\n  const queue = [root]\r\n  \r\n  while (queue.length) {\r\n    const node = queue.shift()\r\n    // 第一个是左节点，节点为空，直接跳过\r\n    const leftVal = list.shift()\r\n    if (leftVal !== \"#\") {\r\n      node.left = new TreeNode(+leftVal)\r\n      queue.push(node.left)\r\n    }\r\n    // 第二个是右节点，节点为空，直接跳过\r\n    const rightVal = list.shift()\r\n    if (rightVal !== \"#\") {\r\n      node.right = new TreeNode(+rightVal)\r\n      queue.push(node.right)\r\n    }\r\n  }\r\n  return root\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912306","body":"```ts\r\nfunction twoSum(nums: number[], target: number): number[] {\r\n  const hash = new Map<number, number>()\r\n  for (let i = 0; i < nums.length; i++) {\r\n    const num = nums[i],\r\n      s = target - num\r\n    if (hash.has(s)) return [hash.get(s), i]\r\n    else hash.set(num, i)\r\n  }\r\n  return []\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321151630","body":"```ts\r\nfunction topKFrequent(nums: number[], k: number): number[] {\r\n  const statistic: { [k: number]: number } = nums.reduce((acc, cur) => (acc[cur] = (acc[cur] || 0) + 1, acc), {})\r\n  const queue = new MinPriorityQueue({ priority: (item: [number, number]) => item[1] })\r\n  for (const item of Object.entries(statistic)) {\r\n    queue.enqueue(item)\r\n    if (queue.size() > k) queue.dequeue()\r\n  }\r\n  const res: number[] = []\r\n  while (queue.size()) res.push(queue.dequeue().element[0])\r\n  return res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321930710","body":"### Algorithm: HashMap\r\n### Code(TypeScript):\r\n```ts\r\nfunction numberOfBoomerangs(points: number[][]): number {\r\n  let ret = 0\r\n  points.forEach((p) => {\r\n    const map = new Map<number, number>()\r\n    points.forEach((q) => {\r\n      const dis = distance(p ,q)\r\n      map.set(dis, (map.get(dis) || 0) + 1)\r\n    })\r\n    for (const v of map.values()) ret += v * (v - 1)\r\n  })\r\n  return ret\r\n};\r\n\r\nfunction distance(a: number[], b: number[]): number {\r\n  return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2)\r\n}\r\n```\r\n### Time Complexity: $O(n^2)$\r\n### Space Complexity: $O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298166132","body":"# LeetCode Link\n\n[Add to Array-Form of Integer - LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/description/)\n\n# Idea\n\nAdd from last of the array `num`.\n\nUse `linkedList.addFist()` method to collect the reversed result.\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        LinkedList<Integer> lst = new LinkedList<>();\n        int carry = 0;\n        while (k != 0 || i >= 0 || carry != 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int sum = a + k % 10 + carry;\n            lst.addFirst(sum % 10);\n\n            i--;\n            k /= 10;\n            carry = sum / 10;\n        }\n        return (List<Integer>) lst;\n    }\n}\n```\n\n# Complexity Analysis\n\n**Time Complexity**\n\n`O(N+L)`, where `N` is the length of `num`, `L` is number of digits of `k`.\n\n**Space Complexity**\n\n`O(1)` no extra space required.\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1305664270","body":"# LeetCode Link\r\n\r\n[[Implement Queue using Stacks - LeetCode](https://leetcode.com/problems/implement-queue-using-stacks/)](https://leetcode.com/problems/implement-queue-using-stacks/)\r\n\r\n# Idea\r\n\r\n- Use Singly linked list to implement stack\r\n- Use two stacks as a queue.\r\n\r\n# Code\r\n\r\n```java\r\nclass MyQueue {\r\n    private class Stack {\r\n        private class ListNode {\r\n            int val;\r\n            ListNode next;\r\n            public ListNode(int val, ListNode next) {\r\n                this.val = val;\r\n                this.next = next;\r\n            }\r\n            \r\n            public ListNode(int val) {\r\n                this(val, null);\r\n            }\r\n        }\r\n        // Use SLL as a stack\r\n        \r\n        ListNode head;\r\n        \r\n        public Stack() {\r\n            head = new ListNode(0);\r\n        }\r\n        \r\n        public boolean isEmpty() {\r\n            return head.next == null;\r\n        }\r\n        \r\n        public int pop() {\r\n            int val = head.next.val;\r\n            head.next = head.next.next;\r\n            return val;\r\n        }\r\n        \r\n        public void push(int x) {\r\n            ListNode p = new ListNode(x, head.next);\r\n            head.next = p;\r\n        }\r\n        public int peek() {\r\n            return head.next.val;\r\n        }\r\n    }\r\n    \r\n    Stack in;\r\n    Stack out;\r\n    public MyQueue() {\r\n        in = new Stack();\r\n        out = new Stack();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        peek();\r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity: \r\n\r\n- Push Stack: O(1)\r\n- Pop Stack: O(1)\r\n\r\nSpace Complexity: O(N)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305662724","body":"# LeetCode Link\r\n\r\n[[Rotate List - LeetCode](https://leetcode.com/problems/rotate-list/)](https://leetcode.com/problems/rotate-list/)\r\n\r\n# Idea\r\n\r\n1. Get the length k of linkedlist.\r\n2. k = n % k. Find the (n - k)th listNode. Cut into 2 lists, swap position, and contatenate.\r\n\r\n# Code\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        if (k == 0) return head;\r\n        // get length\r\n        int size = getSize(head);\r\n        k = k % size;\r\n        if (k == 0) return head;\r\n        k = size - k;\r\n        //System.out.printf(\"k = %d\",k);\r\n        ListNode p = head;\r\n        while (k > 1) {\r\n            p = p.next;\r\n            k--;\r\n        }\r\n        // k ==0, p is the kth node\r\n        ListNode newHead = p.next;\r\n        p.next = null;\r\n        p = newHead;\r\n        while (p.next != null) {\r\n            p = p.next;\r\n        }\r\n        // p is the last node\r\n        p.next = head;\r\n        return newHead;\r\n    }\r\n\r\n    public int getSize(ListNode head) {\r\n        ListNode p = head;\r\n        int cnt = 0;\r\n        while (p != null) {\r\n            cnt++;\r\n            p = p.next;\r\n        }\r\n        return cnt;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity: O(N)\r\n\r\nSpace Complexity: O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312374794","body":"# LeetCode Link\r\n\r\n[[LRU Cache - LeetCode](https://leetcode.com/problems/lru-cache/)](https://leetcode.com/problems/lru-cache/)\r\n\r\n# Idea\r\n\r\nDoublyLinkedList + HashMap.\r\n\r\n# Code\r\n\r\n```java\r\nclass LRUCache {\r\n    private class Node {\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        public Node(int key, int val, Node prev, Node next) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.prev = prev;\r\n            this.next = next;\r\n        }\r\n        public Node(int key, int val) {\r\n            this(key, val, null, null);\r\n        }\r\n    }\r\n\r\n    private class DDL {\r\n        // doubly linked list\r\n        private Node head;\r\n        private Node tail;\r\n        public DDL() {\r\n            head = new Node(0, 0);\r\n            tail = new Node(0,0);\r\n            head.next = tail;\r\n            tail.prev = head;\r\n        }\r\n\r\n        public Node pollFirst() {\r\n            Node evict = head.next;\r\n            removeNode(evict);\r\n            return evict;\r\n        }\r\n\r\n        public void removeNode(Node node) {\r\n            node.next.prev = node.prev;\r\n            node.prev.next = node.next;\r\n            node.next = null;\r\n            node.prev = null;\r\n        }\r\n\r\n        public void offerLast(Node node) {\r\n            node.next = tail;\r\n            node.prev = tail.prev;\r\n            tail.prev.next = node;\r\n            tail.prev = node;\r\n        }\r\n    }\r\n\r\n    private DDL ddl = new DDL();\r\n    private int cap;\r\n    private Map<Integer, Node> memo = new HashMap<>();\r\n\r\n    public LRUCache(int capacity) {\r\n        cap = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (!memo.containsKey(key)) return -1;\r\n        Node node = memo.get(key);\r\n        ddl.removeNode(node);\r\n        ddl.offerLast(node);\r\n        return node.val;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (memo.containsKey(key)) {\r\n            Node node = memo.get(key);\r\n            node.val = value;\r\n            ddl.removeNode(node);\r\n            ddl.offerLast(node);\r\n        }\r\n        else {\r\n            Node node = new Node(key, value);\r\n            if (memo.size() >= cap) {\r\n                // should evict\r\n                Node evict = ddl.pollFirst();\r\n                memo.remove(evict.key);\r\n            }\r\n            ddl.offerLast(node);\r\n            memo.put(key, node);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n# Complexity Analysis\r\n\r\nTime Complexity\r\n\r\nO(1)\r\n\r\nSpace Complexity\r\n\r\nO(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298358969","body":"```\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    swapArr(num)\r\n    kArr := convertToArray(k)\r\n    var res []int\r\n    var carry int\r\n    var bitSum int\r\n    for i, j := 0, 0; i < len(num) || j < len(kArr); {\r\n        if i >= len(num) {\r\n            bitSum = kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            j++\r\n        } else if j >= len(kArr) {\r\n            bitSum = num[i] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n        } else {\r\n            bitSum = num[i] + kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n            j++\r\n        }\r\n    }\r\n    if carry > 0 {\r\n        res = append(res, carry)\r\n    }\r\n    swapArr(res)\r\n    return res\r\n}\r\n\r\nfunc swapArr(arr []int) {\r\n    for i, j := 0, len(arr) - 1; i < j; i, j = i+1, j-1 {\r\n        arr[i], arr[j] = arr[j], arr[i]\r\n    }\r\n}\r\n\r\nfunc convertToArray(k int) []int {\r\n    var res []int\r\n    for k > 0 {\r\n        mod := k % 10\r\n        k = k / 10\r\n        res = append(res, mod)\r\n    }\r\n    return res\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301587875","body":"```\r\ntype CustomStack struct {\r\n    arr []int\r\n    sp int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{ arr: make([]int, maxSize), sp: -1 }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.sp >= len(this.arr) - 1 {\r\n        return\r\n    }\r\n    this.sp += 1\r\n    this.arr[this.sp] = x\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.sp < 0 {\r\n        return -1\r\n    }\r\n    res := this.arr[this.sp]\r\n    this.sp -= 1\r\n    return res\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    for i := 0; i <= this.sp && i < k; i++ {\r\n        this.arr[i] += val\r\n    }\r\n}\r\n```\r\nTime: O(k)\r\nSpace: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306538978","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * type ListNode struct {\r\n *     Val int\r\n *     Next *ListNode\r\n * }\r\n */\r\ntype LinkedList struct{\r\n    Head *ListNode\r\n    Tail *ListNode\r\n}\r\n\r\nfunc (l *LinkedList) Push(node *ListNode) {\r\n    if l.Head == nil {\r\n        l.Head = node\r\n        l.Tail = node\r\n    } else {\r\n        l.Tail.Next = node\r\n        l.Tail = node\r\n    }\r\n    node.Next = nil\r\n}\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil {\r\n        return nil\r\n    }\r\n    firstList := LinkedList{}\r\n    secondList := LinkedList{}\r\n    resultList := LinkedList{}\r\n    count := 0\r\n    for curNode := head; curNode != nil; {\r\n        if count % 2 == 0 { // put input firstList\r\n            next := curNode.Next\r\n            firstList.Push(curNode)\r\n            curNode = next\r\n        } else { // put input secondList\r\n            next := curNode.Next\r\n            secondList.Push(curNode)\r\n            curNode = next\r\n        }\r\n        count++\r\n    }\r\n    for nodeFirst, nodeSecond := firstList.Head, secondList.Head; nodeFirst != nil || nodeSecond != nil; {\r\n        if nodeFirst == nil { // firstList at the tail\r\n            nextNodeSecond := nodeSecond.Next\r\n            resultList.Push(nodeSecond)\r\n            nodeSecond = nextNodeSecond\r\n        } else if nodeSecond == nil { // secondList at the tail\r\n            nextNodeFirst := nodeFirst.Next\r\n            resultList.Push(nodeFirst)\r\n            nodeFirst = nextNodeFirst\r\n        } else { // both list is not at tail\r\n            nextNodeSecond := nodeSecond.Next\r\n            resultList.Push(nodeSecond)\r\n            nodeSecond = nextNodeSecond\r\n            nextNodeFirst := nodeFirst.Next\r\n            resultList.Push(nodeFirst)\r\n            nodeFirst = nextNodeFirst\r\n        }\r\n    }\r\n    return resultList.Head\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312491196","body":"```\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * obj := Constructor(capacity);\r\n * param_1 := obj.Get(key);\r\n * obj.Put(key,value);\r\n */\r\n\r\ntype Node struct {\r\n    Key int\r\n    Value int\r\n    Next *Node\r\n    Prev *Node\r\n}\r\n\r\ntype LRUCache struct {\r\n    Head *Node\r\n    Tail *Node\r\n    M map[int]*Node\r\n    Count int\r\n    Capacity int\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    head := &Node{}\r\n    tail := &Node{}\r\n    head.Next = tail\r\n    tail.Prev = head\r\n    return LRUCache{ Head: head, Tail: tail, M: make(map[int]*Node), Count: 0, Capacity: capacity }\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *Node) {\r\n    node.Prev.Next, node.Next.Prev = node.Next, node.Prev\r\n    node.Prev, node.Next = nil, nil\r\n}\r\n\r\nfunc (this *LRUCache) insertToHead(node *Node) {\r\n    node.Next, node.Prev = this.Head.Next, this.Head\r\n    node.Prev.Next, node.Next.Prev = node, node\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    node, ok := this.M[key]\r\n    if !ok {\r\n        return -1\r\n    }\r\n    value := node.Value\r\n    // move node to head\r\n    this.removeNode(node)\r\n    this.insertToHead(node)\r\n    return value\r\n}\r\n\r\nfunc (this *LRUCache) Put(key int, value int) {\r\n    node, ok := this.M[key]\r\n    if ok { // if key exist, update node and move to head\r\n        node.Value = value\r\n        this.removeNode(node)\r\n        this.insertToHead(node)\r\n    } else { // if key not exist, create a new node and insert to head\r\n        newNode := &Node{ Value: value, Key: key }\r\n        if this.Count >= this.Capacity {\r\n            lastNode := this.Tail.Prev\r\n            this.removeNode(lastNode)\r\n            delete(this.M, lastNode.Key)\r\n            this.Count -= 1\r\n        }\r\n        this.insertToHead(newNode)\r\n        this.M[key] = newNode\r\n        this.Count += 1\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314641386","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\nfunc sumNumbers(root *TreeNode) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    var dfs func(node *TreeNode)\r\n    var path []int\r\n    var res int\r\n    dfs = func(node *TreeNode) {\r\n        defer func(){\r\n            path = path[:len(path) - 1]\r\n        }()\r\n        path = append(path, node.Val)\r\n        leftNode := node.Left\r\n        RightNode := node.Right\r\n        if leftNode == nil && RightNode == nil {\r\n            res += arrayToNum(path)\r\n        }\r\n        if leftNode != nil {\r\n            dfs(leftNode)\r\n        }\r\n        if RightNode != nil {\r\n            dfs(RightNode)\r\n        }\r\n    }\r\n    dfs(root)\r\n    return res\r\n}\r\n\r\nfunc arrayToNum(arr []int) int {\r\n    var res int\r\n    for i := len(arr) - 1; i >= 0; i-- {\r\n        res += arr[i] * int(math.Pow(10, float64(len(arr) - 1 - i)))\r\n    }\r\n    return res\r\n}\r\n\r\n```\r\nTime: O(n)\r\nSpace: O(logn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316223679","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * type TreeNode struct {\r\n *     Val int\r\n *     Left *TreeNode\r\n *     Right *TreeNode\r\n * }\r\n */\r\n\r\ntype QueueNode struct {\r\n    treeNode *TreeNode\r\n    level int\r\n}\r\n\r\nfunc findBottomLeftValue(root *TreeNode) int {\r\n    var q []QueueNode\r\n    // init q\r\n    curDeepestLevel := 1\r\n    firstNodeOfLevel := root\r\n    rootQueueNode := QueueNode{treeNode: root, level: 1}\r\n    q = append(q, rootQueueNode)\r\n    var node *TreeNode\r\n    var level int\r\n    for len(q) > 0 {\r\n        node = q[0].treeNode\r\n        level = q[0].level\r\n        if level > curDeepestLevel {\r\n            curDeepestLevel = level\r\n            firstNodeOfLevel = node\r\n        }\r\n        q = q[1:] // pop from head\r\n        if node.Left != nil { // push left node\r\n            q = append(q, QueueNode{ treeNode: node.Left, level: level + 1 })\r\n        }\r\n        if node.Right != nil { // push right node\r\n            q = append(q, QueueNode{ treeNode: node.Right, level: level + 1 })\r\n        }\r\n    }\r\n    return firstNodeOfLevel.Val\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321432308","body":"```\r\nfunc numberOfBoomerangs(points [][]int) int {\r\n    distance := make([][]float64, len(points))\r\n    var totalNumber int\r\n    for i := 0; i < len(distance); i++ {\r\n        distance[i] = make([]float64, len(points))\r\n    }\r\n    for i, row := range distance {\r\n        for j := 0; j < len(row); j++ {\r\n            distance[i][j] = getDistance(points, i, j)\r\n        }\r\n    }\r\n    for i, row := range distance {\r\n        var number int // Boomerange number per row\r\n        distMap := make(map[float64]int) // distMap: { distance: number }\r\n        for j := 0; j < len(row); j++ {\r\n            distMap[distance[i][j]] += 1\r\n        }\r\n        for _, value := range distMap {\r\n            if value > 1 {\r\n                number += value * (value - 1)\r\n            }\r\n        }\r\n        totalNumber += number\r\n    }\r\n    return totalNumber\r\n}\r\n\r\nfunc getDistance(points [][]int, i, j int) float64 {\r\n    x := points[i]\r\n    y := points[j]\r\n    return math.Sqrt((math.Pow(float64(x[0] - y[0]), 2) + math.Pow(float64(x[1] - y[1]), 2)))\r\n}\r\n```\r\nTime: O(n^2)\r\nSpace: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322956717","body":"```\r\nfunc lengthOfLongestSubstring(s string) int {\r\n\tm := make(map[byte]bool)\r\n\ti := 0\r\n\tvar longestLength int \r\n\tfor j := 0; j < len(s); j++ {\r\n\t\tfor i < j {\r\n\t\t\t_, ok := m[s[j]]\r\n\t\t\tif !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tdelete(m, s[i])\r\n\t\t\ti++\r\n\t\t}\r\n\t\tm[s[j]] = true\r\n\t\tif j - i + 1 > longestLength {\r\n\t\t\tlongestLength = j - i + 1\r\n\t\t}\r\n\t}\r\n\treturn longestLength\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326986507","body":"```\r\nfunc middleNode(head *ListNode) *ListNode {\r\n    slow, fast := head, head\r\n    for fast != nil && fast.Next != nil {\r\n        slow = slow.Next\r\n        fast = fast.Next.Next\r\n    }\r\n    return slow\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328608530","body":"```\r\nfunc maxSlidingWindow(nums []int, k int) []int {\r\n    if len(nums) < k {\r\n        return []int{}\r\n    }\r\n    var descDeque []Item\r\n    res := make([]int, len(nums))\r\n    for i := 0; i < len(nums); i++ {\r\n        left := i - k + 1\r\n        // remove item out of window\r\n        for len(descDeque) > 0 {\r\n            if descDeque[0].Idx < left {\r\n                descDeque = descDeque[1:]\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n        // remove item in descDeque which smaller than inserted item\r\n        for len(descDeque) > 0 && descDeque[len(descDeque) - 1].Value < nums[i] {\r\n            descDeque = descDeque[:len(descDeque) - 1]\r\n        }\r\n        // insert item\r\n        descDeque = append(descDeque, Item{ Value: nums[i], Idx: i })\r\n        res[i] = descDeque[0].Value\r\n    }\r\n    return res[k-1:]\r\n}\r\n\r\ntype Item struct {\r\n    Value int\r\n    Idx int\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331695645","body":"```\r\nfunc possibleBipartition(n int, dislikes [][]int) bool {\r\n    if len(dislikes) == 0 {\r\n        return true\r\n    }\r\n    color := make([]int, n + 1)\r\n    // initiate adjacent table\r\n    adjTable := make([][]int, n + 1)\r\n    for idx, _ := range adjTable {\r\n        adjTable[idx] = []int{}\r\n    }\r\n    // build adjacent table\r\n    for _, edge := range dislikes {\r\n        adjTable[edge[0]] = append(adjTable[edge[0]], edge[1])\r\n        adjTable[edge[1]] = append(adjTable[edge[1]], edge[0])\r\n    }\r\n    // travers graph and paint, 1: red; 0: no color; -1: blue\r\n    for v, _ := range adjTable {\r\n        if color[v] != 0 {\r\n            continue\r\n        }\r\n        var queue []int\r\n        color[v] = 1\r\n        queue = append(queue, v)\r\n        for len(queue) > 0 {\r\n            v := queue[0]\r\n            queue = queue[1:]\r\n            edge := adjTable[v]\r\n            for _, outV := range edge {\r\n                if color[outV] == color[v] {\r\n                    return false\r\n                }\r\n                if color[outV] == 0 {\r\n                    color[outV] = -color[v]\r\n                    queue = append(queue, outV)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333560332","body":"```\r\nfunc sortItems(n int, m int, group []int, beforeItems [][]int) []int {\r\n\tvar res []int\r\n\tcurGroup := m\r\n\tfor idx, value := range group { // reassign each -1 group\r\n\t\tif value == -1 {\r\n\t\t\tgroup[idx] = curGroup\r\n\t\t\tcurGroup++\r\n\t\t}\r\n\t}\r\n\r\n\titemIndegree := make([]int, n)\r\n\tgroupIndegree := make([]int, curGroup)\r\n\tgroupItem := make([][]int, curGroup)\r\n\tfor item, groupIdx := range group { // build groupIndegree, itemIndegree and groupItem\r\n\t\tbefore := beforeItems[item]\r\n\t\titemIndegree[item] = len(before)\r\n\t\tgroupItem[groupIdx] = append(groupItem[groupIdx], item)\r\n\t\tfor _, beforeItem := range before {\r\n\t\t\tif group[beforeItem] != groupIdx {\r\n\t\t\t\tgroupIndegree[groupIdx] += 1\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tgraph := make([][]int, n)\r\n\tfor curItem, before := range beforeItems { // build graph by beforeItems\r\n\t\tfor _, item := range before {\r\n\t\t\tgraph[item] = append(graph[item], curItem)\r\n\t\t}\r\n\t}\r\n\tvar groupQueue []int\r\n\tvar sortedGroup []int\r\n\tfor groupIdx, inDegree := range groupIndegree {\r\n\t\tif inDegree == 0 {\r\n\t\t\tgroupQueue = append(groupQueue, groupIdx)\r\n\t\t}\r\n\t}\r\n\r\n\tsortGroup := func(groupIdx int) bool { // true - success, false - has cycle\r\n\t\tvar itemQueue []int\r\n\t\tvar sortedItem []int\r\n\t\tfor _, item := range groupItem[groupIdx] {\r\n\t\t\tif itemIndegree[item] == 0 {\r\n\t\t\t\titemQueue = append(itemQueue, item)\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor len(itemQueue) > 0 {\r\n\t\t\titemIdx := itemQueue[0]\r\n\t\t\titemQueue = itemQueue[1:]\r\n\t\t\tsortedItem = append(sortedItem, itemIdx)\r\n\t\t\tfor _, toVertex := range graph[itemIdx] {\r\n\t\t\t\titemGroup := group[toVertex]\r\n\t\t\t\tif itemGroup == groupIdx { // two item in same group\r\n\t\t\t\t\tif itemIndegree[toVertex] -= 1; itemIndegree[toVertex] == 0 {\r\n\t\t\t\t\t\titemQueue = append(itemQueue, toVertex)\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // toVertex in other group\r\n\t\t\t\t\titemIndegree[toVertex] -= 1\r\n\t\t\t\t\tif groupIndegree[itemGroup] -= 1; groupIndegree[itemGroup] == 0 { // add group with indegree == 0 into groupQueue\r\n\t\t\t\t\t\tgroupQueue = append(groupQueue, itemGroup)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\tif len(sortedItem) != len(groupItem[groupIdx]) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tres = append(res, sortedItem...)\r\n\t\treturn true\r\n\t}\r\n\r\n\tfor len(groupQueue) > 0 {\r\n\t\tgroupIdx := groupQueue[0]\r\n\t\tgroupQueue = groupQueue[1:]\r\n\t\tsortedGroup = append(sortedGroup, groupIdx)\r\n\t\tif !sortGroup(groupIdx) {\r\n\t\t\treturn []int{}\r\n\t\t}\r\n\t}\r\n\r\n\tif len(sortedGroup) != len(groupItem) {\r\n\t\treturn []int{}\r\n\t}\r\n\r\n\treturn res\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335057498","body":"```\r\nfunc judgeCircle(moves string) bool {\r\n    x := 0\r\n    y := 0\r\n    for i := 0; i < len(moves); i++ {\r\n        switch string(moves[i]) {\r\n            case \"U\":\r\n                y += 1\r\n            case \"D\":\r\n                y -= 1\r\n            case \"L\":\r\n                x -= 1\r\n            case \"R\":\r\n                x += 1\r\n        }\r\n    }\r\n    if x == 0 && y == 0 {\r\n        return true\r\n    }\r\n    return false\r\n}\r\n```\r\nTIme: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336711891","body":"```\r\nfunc minCharacters(a string, b string) int {\r\n    aStr := \"a\"\r\n    aletter := aStr[0]\r\n    zStr := \"z\"\r\n    zletter := zStr[0]\r\n    res := math.MaxInt\r\n    // loop from a to z\r\n    for letter := aletter; letter <= zletter; letter++ {\r\n        var count1, count2, count3 int\r\n        for i := 0; i < len(a); i++ {\r\n            if letter != aletter {\r\n                // case 1 count\r\n                if a[i] >= letter {\r\n                    count1 += 1\r\n                }\r\n                // case 2 count\r\n                if a[i] < letter {\r\n                    count2 += 1\r\n                }\r\n            }\r\n            if a[i] != letter {\r\n                count3 += 1\r\n            }\r\n        }\r\n        for j := 0; j < len(b); j++ {\r\n            if letter != aletter {\r\n                // case 1 count\r\n                if b[j] < letter {\r\n                    count1 += 1\r\n                }\r\n                // case 2 count\r\n                if b[j] >= letter {\r\n                    count2 += 1\r\n                }\r\n            }\r\n            if b[j] != letter {\r\n                count3 += 1\r\n            }\r\n        }\r\n        if letter != aletter && count1 < res {\r\n            res = count1\r\n        }\r\n        if letter != aletter && count2 < res {\r\n            res = count2\r\n        }\r\n        if count3 < res {\r\n            res = count3\r\n        }\r\n    }\r\n    return res\r\n}\r\n```\r\nTIme: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343842377","body":"```\r\nfunc reversePairs(nums []int) int {\r\n    var res int\r\n    mergeSort(nums, &res)\r\n    return res\r\n}\r\nfunc mergeSort(nums []int, res *int) []int {\r\n    if len(nums) <= 1 {\r\n        return nums\r\n    }\r\n    var mergedArray []int\r\n    array1 := nums[:(len(nums) - 1) / 2 + 1]\r\n    array2 := nums[(len(nums) - 1) / 2 + 1:]\r\n    sortArray1 := mergeSort(array1, res)\r\n    sortArray2 := mergeSort(array2, res)\r\n    for i := 0; i < len(sortArray1); i++ {\r\n        m, n := 0, len(sortArray2) - 1\r\n        for m < n {\r\n            mid := m + (n - m) / 2\r\n            if sortArray1[i] <= 2 * sortArray2[mid] {\r\n                n = mid\r\n            } else {\r\n                m = mid + 1\r\n            }\r\n        }\r\n        if sortArray1[i] > 2 * sortArray2[m] {\r\n            m += 1\r\n        }\r\n        *res += m\r\n    }\r\n    for i, j := 0, 0; i < len(sortArray1) || j < len(sortArray2); {\r\n        if i >= len(sortArray1) {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        } else if j >= len(sortArray2) {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else if sortArray1[i] <= sortArray2[j] {\r\n            mergedArray = append(mergedArray, sortArray1[i])\r\n            i++\r\n        } else {\r\n            mergedArray = append(mergedArray, sortArray2[j])\r\n            j++\r\n        }\r\n    }\r\n    return mergedArray\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345473510","body":"```\r\nfunc smallestDistancePair(nums []int, k int) int {\r\n    sort.Ints(nums)\r\n    min, max := math.MaxInt, math.MinInt\r\n    for _, value := range nums {\r\n        if value < min {\r\n            min = value\r\n        }\r\n        if value > max {\r\n            max = value\r\n        }\r\n    }\r\n    maxDist := max - min\r\n    i, j := 0, maxDist\r\n    for i < j {\r\n        mid := i + (j - i) / 2\r\n        if numberByDist(nums, mid) >= k {\r\n            j = mid\r\n        } else {\r\n            i = mid + 1\r\n        }\r\n    }\r\n    return i\r\n}\r\n// get the i, j pair that distance of i, j smaller and equal than target\r\nfunc numberByDist(nums []int, dist int) int {\r\n    var res int\r\n    for i, j := 0, 0; i < len(nums); i++ {\r\n        for j < len(nums) && nums[j] <= nums[i] + dist {\r\n            j++\r\n        }\r\n        res += (j - i  - 1)\r\n    }\r\n    return res\r\n}\r\n```\r\nTime: O(nlogn)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350357793","body":"```\r\nfunc new21Game(n int, k int, maxPts int) float64 {\r\n    dp := make([]float64, k + maxPts)\r\n    for i := k; i < k + maxPts; i++ {\r\n        if i <= n {\r\n            dp[i] = 1\r\n        } else {\r\n            dp[i] = 0\r\n        }\r\n    }\r\n    for i := k - 1; i >= 0; i-- {\r\n        var sum float64\r\n        for j := i + 1; j <= i + maxPts; j++ {\r\n            sum += dp[j]\r\n        }\r\n        dp[i] = sum / float64(maxPts)\r\n    }\r\n    return dp[0]\r\n}\r\n```\r\nTime: O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356020224","body":"```\r\nfunc minOperations(nums []int, x int) int {\r\n    var total int\r\n    longest := 0\r\n    for _, val := range nums {\r\n        total += val\r\n    }\r\n    if x > total {\r\n        return -1\r\n    }\r\n    if x == total {\r\n        return len(nums)\r\n    }\r\n    var subTotal, i, j int\r\n    for ;j < len(nums); j++ {\r\n        subTotal += nums[j]\r\n        for i < j && subTotal > (total - x) {\r\n            subTotal -= nums[i]\r\n            i++\r\n        }\r\n        if subTotal == (total - x) && (j - i + 1) > longest {\r\n            longest = j - i + 1\r\n        }\r\n    }\r\n    if longest == 0 {\r\n        return -1\r\n    }\r\n    return len(nums) - longest\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356710839","body":"```\r\nfunc readBinaryWatch(turnedOn int) []string {\r\n    bits := make([]int, 10)\r\n    var res []string\r\n    cache := make(map[int]bool)\r\n    dfs(bits, 0, turnedOn, cache, &res)\r\n    return res\r\n}\r\n\r\nfunc dfs(bits []int, count int, turnedOn int, cache map[int]bool, res *[]string) {\r\n    num := convertToInt(bits)\r\n    if cache[num] {\r\n        return\r\n    }\r\n    defer func(){\r\n        cache[num] = true   \r\n    }()\r\n    if count == turnedOn {\r\n        time, ok := getTime(bits)\r\n        if ok {\r\n            *res = append(*res, time)\r\n        }\r\n        return\r\n    }\r\n    for i := 0; i < len(bits); i++ {\r\n        if bits[i] == 0 {\r\n            bits[i] = 1\r\n            dfs(bits, count + 1, turnedOn, cache, res)\r\n            bits[i] = 0\r\n        }\r\n    }\r\n}\r\n\r\nfunc convertToInt(bits []int) int {\r\n    var res int\r\n    for i := len(bits) - 1; i >= 0; i-- {\r\n        res += bits[i] * int(math.Pow(2, float64(len(bits) - 1 - i)))\r\n    }\r\n    return res\r\n}\r\n\r\nfunc getTime(bits []int) (time string, valid bool) {\r\n    hourBit := bits[0:4]\r\n    minuteBit := bits[4:]\r\n    var hour, minute int\r\n    for i := len(hourBit) - 1;  i >= 0; i-- {\r\n        hour += hourBit[i] * int(math.Pow(2, float64(len(hourBit) - 1 - i)))\r\n    }\r\n    for i := len(minuteBit) - 1;  i >= 0; i-- {\r\n        minute += minuteBit[i] * int(math.Pow(2, float64(len(minuteBit) - 1 - i)))\r\n    }\r\n    if hour < 12 && minute < 60 {\r\n        if minute < 10 {\r\n            time = fmt.Sprintf(\"%d:0%d\", hour, minute)\r\n        } else {\r\n            time = fmt.Sprintf(\"%d:%d\", hour, minute)\r\n        }\r\n        valid = true\r\n        return\r\n    }\r\n    valid = false\r\n    return\r\n}\r\n```\r\nTime: O(C10 turnOn)","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364880735","body":"```\r\nfunc findNumberOfLIS(nums []int) int {\r\n    dp := make([]int, len(nums))\r\n    count := make([]int, len(nums))\r\n    // m: { key: 每个i的subMaxLength, value: subMaxLength的个数 }\r\n    m := make(map[int]int)\r\n    maxLength := 1\r\n    for i := 0; i < len(dp); i++ {\r\n        subMaxLength := 1\r\n        subMap := make(map[int]int)\r\n        subMap[1] = 1\r\n        for j := 0; j < i; j++ {\r\n            if nums[j] < nums[i] {\r\n                subMap[dp[j] + 1] += count[j]\r\n                if dp[j] + 1 > subMaxLength {\r\n                    subMaxLength = dp[j] + 1\r\n                }\r\n            }\r\n        }\r\n        dp[i] = subMaxLength\r\n        count[i] = subMap[subMaxLength]\r\n        m[subMaxLength] += subMap[subMaxLength]\r\n        if subMaxLength > maxLength {\r\n            maxLength = subMaxLength\r\n        }\r\n    }\r\n    return m[maxLength]\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368204113","body":"```\r\nfunc canPartition(nums []int) bool {\r\n    //画一个二维表格， 就清晰了\r\n    sum := 0\r\n    for _, v := range nums {\r\n        sum += v\r\n    }\r\n    if sum % 2 != 0 {\r\n        return false\r\n    }\r\n    m := len(nums)\r\n    target := sum / 2\r\n    dp := make([][]bool, m + 1)\r\n    for i := 0; i < m + 1; i++ {\r\n        dp[i] = make([]bool, target + 1)\r\n    }\r\n\r\n    for i := 0; i < m + 1; i++ {\r\n        dp[i][0] = true\r\n    }\r\n    for i := 1; i < m + 1; i++ {\r\n        for j := 0; j < target + 1; j++ {\r\n            if j - nums[i - 1] >= 0 {\r\n                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i - 1]]\r\n            }else {\r\n                dp[i][j] = dp[i - 1][j]\r\n            }\r\n        }\r\n    }\r\n    return dp[m][target]\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370679699","body":"```\r\nfunc findContentChildren(g []int, s []int) (res int) {\r\n\tsort.Ints(g)\r\n\tsort.Ints(s)\r\n\tgFlag, sFlag := 0, 0\r\n\tfor gFlag < len(g) && sFlag < len(s) {\r\n\t\tif g[gFlag] <= s[sFlag] {\r\n\t\t\tres++\r\n\t\t\tgFlag++\r\n\t\t}\r\n\t\tsFlag++\r\n\t}\r\n\treturn\r\n}\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375271631","body":"```\r\nfunc beautifulArray(n int) []int {\r\n    if n == 1 {\r\n        return []int{1}\r\n    }\r\n\r\n    array := make([]int, 0, n)\r\n\r\n    odds := beautifulArray((n+1)>>1)\r\n    evens := beautifulArray(n>>1)\r\n\r\n    for _, o := range odds {\r\n        array = append(array, 2*o-1)\r\n    }\r\n\r\n    for _, e := range evens {\r\n        array = append(array, 2*e)\r\n    }\r\n\r\n    return array\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298065318","body":"```java\n/*\nPlan: perform addition from backwards, edge case: k has more digits, carry\n\nTime: O(max(log_10(num), log_10(k))), number of digits\nSpace: O(max(log_10(num), log_10(k)))\n*/\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int curSum = 0, carry = 0;\n        LinkedList<Integer> sum = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            curSum = num[i] + k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        // if k has more digits\n        while (k > 0) {\n            curSum = k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        if (carry == 1) {\n            sum.addFirst(1);\n        }\n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725572","body":"```java\n/*\nstore a representative in the stack for each chunk (max value in that chunk)\nIf the current num == prev max, add to stack\nIf current num > prev max, add to stack\nIf current num < prev max, pop until find the right chunk to merge:\ninsert 3, e.g. 1, 4, pop 4, insert 3\n\n[4,2,2,1,1]\n-> 1\n\nstack:bottom ---> increasing\nTime: O(arr.length)\nSpace: O(arr.length)\n\n\n\n*/\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            }\n            else {\n                int curmax = stack.peek();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(curmax); // merge num into the chunk represented by curmax\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298605508","body":"### 思路 从数组最后一个元素开始加，用一个队列记录答案，用一个变量记录是否要进一位。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        Deque<Integer> res = new ArrayDeque<>();\n        int plusOne = 0;\n        for(int i = num.length - 1 ; i >= 0 ; i--){\n            int n = num[i] + k%10 + plusOne;\n            k = k/10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        //结束后，k可能还有剩余，或者还要进位\n        while(k != 0){\n            int n = k % 10 + plusOne;\n            k /= 10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        if(plusOne == 1){\n            res.addFirst(1);\n        }\n        return new ArrayList<Integer>(res);\n\n    }\n}\n```\n### 复杂度  \n时间O(n),n是数组长度  \n空间O(n),记录答案所消耗的开销\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1298895541","body":"\n### Method 1:\n双指针，对于每一个元素，定义两个指针从自身背向出发，定义变量distance记录距离，当遇到字符c时，返回distance.\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        for(int i = 0 ; i < s.length() ;i++){\n            res[i] = getShortestChar(s , i , c);\n        }\n        return res;\n    }\n    //双指针\n    public int getShortestChar(String s , int i , char c){\n        if(s.charAt(i) - c == 0)return 0;\n        int left = i , right = i;\n        int distance = 0;\n        while(left >= 0 || right <= s.length() - 1 ){\n            \n            if(s.charAt(left) - c ==0 || s.charAt(right) - c == 0){\n                return distance;\n            }\n            if(left > 0){\n                left--;\n            }\n            if(right < s.length() - 1){\n                right++;\n            }\n            distance++;\n\n        }\n        return distance;\n\n    }\n}\n```\n### 复杂度\n时间O(n^2)  \n空间O(n)  \n### method 2:\n两遍遍历，同时记录到c的距离。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] res = new int[N];\n        int idx = -N;\n        for(int i = 0 ; i < N ; i++){\n            if(s.charAt(i) - c == 0){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        \n        for(int i = N - 1 ; i >= 0 ;i--){\n            if( s.charAt(i) - c ==0){\n                idx = i;\n            }\n            res[i] = Math.min(res[i] , Math.abs(i - idx));\n        }\n        return res;\n    }\n}\n```\n### 复杂度\nTime O(n)  \nSpace O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301009155","body":"### 思路：数组模拟栈，定义变量idx表示当前栈的容量。\n```java\nclass CustomStack {\n    int[] stack;\n    int idx;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        idx = -1;\n    }\n    \n    public void push(int x) {\n        \n        if(idx < maxSize - 1 && idx >= -1){\n            ++idx;\n            stack[idx] = x;\n        }\n    }\n    \n    public int pop() {\n        if(idx >= 0){\n            return stack[idx--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k , idx + 1);\n        for(int i = 0 ; i < min ; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度\npop() : time O(1), space O(1)  \npush() : time O(1),space O(1)  \nincrement(): time O(k),space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302697660","body":"### 思路：遍历字符串，当字符不是” ]“右括号时压入栈，遇到右括号时，栈弹出，在遇到 \" [ \"左括号前，把所有字符组成repeatString , 然后当还是数字时弹出，组成num，对repeatString 重复num次，再把新的字符串压入栈中。\n```java\nclass Solution {\n    public String decodeString(String s) {\n        int N = s.length();\n        Stack<String> stack = new Stack<>();\n        for(int i = 0 ; i < N ; i ++){\n            String repeatStr = \"\";\n            String num = \"\";\n            String newString = \"\";\n            String cur = s.substring(i , i + 1);\n            if(!cur.equals(\"]\") ){\n                stack.push(s.substring(i , i+1));\n            }else{\n                while(!stack.isEmpty() && !stack.peek().equals(\"[\")){\n                    repeatStr = stack.pop() + repeatStr;\n                }\n                stack.pop();// pop :[\n                while(!stack.isEmpty() && stack.peek().matches(\"[0-9]\")){\n                    num = stack.pop() + num;\n                }\n                for(int j = 0 ; j < Integer.valueOf(num) ; j++){\n                    newString += repeatStr;\n                }\n                //把新字符串压回栈中\n                for(int j = 0 ; j < newString.length() ; j++){\n                    stack.push(newString.substring(j , j + 1));\n                }\n            }\n            \n            \n        }\n        String res = \"\";\n        while(!stack.isEmpty()){\n            res = stack.pop() + res;\n        }\n        return res;\n    }\n}\n```\ntime O(n)  \nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561045","body":"\n```java\nclass MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        if(in.isEmpty() && out.isEmpty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304790996","body":"\n先抄个答案·\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int res = 0;\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        for (int i = 0; i < sortedArr.length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n            if (cnt.get(x) == 0) {\n                cnt.remove(x);\n            }\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\n            if (cnt.get(y) == 0) {\n                cnt.remove(y);\n            }\n            if (cnt.isEmpty()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n\n```\ntime O(nlogn)\nspace O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308860428","body":"### 思路：每次找到链表的中点，将该点作为树的根节点，然后用递归继续寻找链表左边的中点以及右边的中点\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return bfs(head ,null);\n        \n    }\n    public TreeNode bfs(ListNode start , ListNode end){\n        if(start == end) return null;\n\n        \n        ListNode fast = start,slow = start;\n        while(fast != end && fast.next != end){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        \n        TreeNode root = new TreeNode(slow.val);\n        root.left = bfs(start , slow);\n        root.right = bfs(slow.next , end);\n\n        return root;\n    }\n}\n```\ntime O(n)\nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309185190","body":"### 思路：定义两个指针指向headA和headB,当A指针走到null则从B链开始走,当B指针走到null则从A链开始走，两指针再次相遇时则是相交点，不相遇则会返回null\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        \n        ListNode A =  headA, B = headB;\n        while(A != B){\n            if(A == null){\n                A = headB;\n            }else{\n                A = A.next;\n            }\n            if(B == null){\n                B = headA;\n            }else{\n                B = B.next;\n            }\n            \n        }\n        return A;\n    }\n}\n```\ntime O(n + m)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311857299","body":"### 思路：快慢指针，当快慢指针相遇时，快指针再从头开始走，再次相遇则是环入口点\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head==null)return null;\n        ListNode fast = head,slow=head;\n        \n        while(true){\n            if(fast==null||fast.next==null)return null;\n            fast=fast.next.next;\n            slow = slow.next;\n            if(fast==slow)break;\n        }\n        fast=head;\n        while(fast!=slow){\n            fast=fast.next;\n            slow=slow.next;\n        }\n        return fast;\n    }\n}\n```\ntime o(n)\nspace O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320051310","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n\n```\ntime O(nlogn)\nspaceO(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326782228","body":"### 思路：快慢指针，快指针一次走两步，慢指针一次走一步，快指针走到结尾时，此时慢指针即为中点\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head , fast = head;\n        while(fast != null && fast.next !=null ){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\ntime O(n),n为链表节点数量\nspace O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334465309","body":"### 思路：简单模拟。\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0,y=0;\n        char[] c = moves.toCharArray();\n        for(char each:c){\n            if(each-'U' == 0){\n                y--;\n            }else if(each - 'D' == 0){\n                y++;\n            }else if(each - 'L' == 0){\n                x--;\n            }else if(each - 'R' == 0){\n                x++;\n            }\n        }\n\n        if(x == 0 && y ==0){\n            return true;\n        }\n        return false;\n    }\n}\n```\ntime O(n),n字符串长度\nspace O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340708773","body":"### 思路：二分法，注意用long存放以免溢出\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        if(x == 0 || x == 1)return x;\n        long start = 1 , end = x;\n\n        while(start + 1 < end){\n            long mid = start + (end - start)/2;\n            if(mid*mid > x){\n                end = mid;\n            }else{\n                start = mid;\n            }\n\n        }\n        if(end*end <= x)return (int)end;\n        if(start*start <= x)return (int)start;\n        return 1;\n    }\n}\n```\nTime O(logn)\nspace O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341375134","body":"### 思路：二分法\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        return BinarySerach(n);\n    }\n\n    public int BinarySerach(int n){\n        int start = 1 , end = n;\n        while( start + 1 < end){\n            int mid = start + (end - start) / 2;\n            if(!isBadVersion(mid) ){\n                start = mid;\n            }else{\n                end = mid;\n            }\n\n        }\n        if(isBadVersion(start)) return start;\n\n        if(isBadVersion(end)) return end;\n            \n        return -1;\n    }\n}\n```\ntime O(logn)\nspace O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364178698","body":"#思路：动态规划\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n];//dp[n]代表爬到第n个台阶支付的最小费用\n        dp[0] = 0;//爬到第0个台阶花费0\n        dp[1] = 0;//爬到第一个台阶花费0\n        for(int i = 2 ; i < n ; i++){\n            dp[i] = Math.min( dp[i - 1] + cost[i - 1] , dp[i - 2] + cost[ i - 2]);\n        }\n        //爬到最后第一个台阶或最后第二个台阶，再详细对比\n        return Math.min(dp[ n - 1 ] + cost[n - 1] , dp[n - 2] + cost[n - 2] );\n        \n\n    }\n}\n```\ntimeO(n)\nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364592316","body":"# 思路：动态规划\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        \n        int n = nums.length;\n        if(n == 1)return nums[0];\n\n        int[] dp = new int[n];//表示前i个房屋能偷到的最高金额\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0] , nums[1]);\n        for(int i = 2 ; i < n ; i++){\n            dp[i] = Math.max( dp[ i-1 ]  ,dp[i - 2] + nums[i] );\n        }\n        return dp[n - 1];\n        \n\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317132508","body":"### 思路\nBFS\n### code\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        if(!root){\n            return -1;\n        }\n        q.push(root);\n         int left = root->val;\n        while(!q.empty()){\n            int qSize = q.size();\n            TreeNode* curr = q.front();\n            left = curr->val;\n            while(qSize--){\n                curr = q.front();\n                q.pop();\n                if(curr->left)\n                q.push(curr->left);\n                if(curr->right)\n                q.push(curr->right);\n            }\n\n        }\n        return left;\n    }\n\n};\n```\n### 复杂度\n时间: O(n) \n空间: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321178084","body":"### 思路\r\n用hashmap存起来\r\n再放进最大堆里\r\n\r\n### code\r\n```C++\r\nstruct cmp {\r\n    bool operator()(pair<int,int> const& p1, pair<int,int> const& p2)\r\n    {\r\n    \r\n        return p1.second < p2.second;\r\n    }\r\n};\r\n \r\n\r\nclass Solution {\r\npublic:\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> hashMap;\r\n        for(auto i: nums){\r\n            ++hashMap[i];\r\n        }\r\n        priority_queue<pair<int,int>, vector<pair<int,int>>, cmp> heap;\r\n        for(auto i: hashMap){\r\n            heap.push(make_pair(i.first,i.second));\r\n        }\r\n        vector<int>ret;\r\n        for(int i = 0; i < k; ++i){\r\n            \r\n            ret.push_back(heap.top().first);\r\n            heap.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间: 插入hashmap 为O(n), n是整个vector长度, 插入heap是logN, n是vector里unique的数字的长度, 删除是logN\r\n空间: O(N) n是vector里unique的数字的个数","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323781155","body":"### 思路\n哈希表和滑动窗口结合.\n当一个元素能在哈希表里被找到说明有元素重复, 需要把当前窗口从左往右一直erase元素直到找到那个重复元素为止.\n然后比较新的窗口的大小和之前的size大小, 并插入当前元素\n\n### code\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int i = 0; \n        int j = 0;\n        int ret = 0;\n        unordered_set<char>hashTable;\n        while(j<s.size()){\n            while(hashTable.find(s[j]) != hashTable.end()){\n                hashTable.erase(s[i]);\n                ++i;\n            }\n            ret = max(ret, j-i+1);\n            hashTable.insert(s[j]);\n            ++j;\n        }\n        return ret;\n    }\n};\n```\n\n###  复杂度\n时间: O(n) \n空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297848071","body":"python one line\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [int(i) for i in list(str(int(''.join(map(str,num)))+k))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299744757","body":"```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        dis = []\n        idx = s.index(c)\n        for i in range(len(s)):\n            if abs(idx-i)>abs(s.find(c,i)-i):\n                idx = s.index(c,i)\n            if s[i]!=c:\n                dis.append(abs(idx-i))\n            else:\n                dis.append(0)\n        return dis\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301701899","body":"```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize = maxSize\n        self.stack = []\n        self.inc = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n\n        return self.stack.pop()+self.inc.pop()\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.inc:\n            self.inc[min(k, len(self.inc))-1] += val\n```\n- Time:O(n)\n- Space:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302812702","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        # 两个栈，一个进数字，一个进字母，反括号出栈\n        stack = [];curNum=0;curString=''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304395500","body":"```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.in_stk = []\n        self.out_stk = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.in_stk.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek()\n        return self.out_stk.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.out_stk:\n            while self.in_stk:\n                self.out_stk.append(self.in_stk.pop())\n        return self.out_stk[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.in_stk and not self.out_stk\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304729549","body":"```python \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        count = 0\n        for i in arr:\n            if len(stack)==0 or stack[-1]<=i:\n                stack.append(i)\n            else:\n                ma = stack[-1]\n                # 如果遇到更大的值，则一直往前比较（每次比较都会删去栈顶一个元素）\n                while stack and stack[-1]>i:\n                    ma = max(ma,stack.pop())\n                stack.append(ma)\n        return len(stack)\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304941600","body":"```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 返回链表倒数第k个元素，当k大于链表长度时，返回倒数K/len的元素，然后最后一位拼接一下\n        # 先获取数组长度\n        if not head:\n            return None\n        lastElement = head\n        length = 1\n        while(lastElement.next):\n            lastElement = lastElement.next\n            length += 1\n        # 先拼成环\n        lastElement.next = head\n        # 找出倒数第k个元素，进行切割\n        k = k%length\n        p = head\n        for i in range(length - k - 1):\n            p = p.next\n\n        head2 = p.next\n        p.next=None\n        return head2\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306422586","body":"```python\nclass Solution(object):\n    def swapPairs(self, head):\n        if not head or not head.next:\n            return head\n        # 创建一个prev节点指向A，可以避免判断边界条件\n        ans = prev = ListNode()\n        prev.next = head\n        # prev-a-b-c-d-e\n        # prev-b-a-c\n        while head and head.next:\n            a = head\n            b = a.next\n            c = b.next\n\n            prev.next = b\n            b.next = a\n            a.next = c\n\n            prev = a\n            head = c\n\n        return ans.next\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307987276","body":"```python\nclass Solution(object):\n    def sortedListToBST(self, head):\n        # 定义快慢指针，找到中点，为二叉搜索树的根节点\n        if not head:\n            return head\n        pre,slow,fast = None,head,head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n\n        if pre:\n            pre.next = None\n        \n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return node\n```\n- Time:O(nlogn)\n- Space:O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309696587","body":"```python\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 两列表加起来一样长\n        # A+B=B+A,然后最后两者将重合在一起\n        a,b = headA,headB\n        while(a!=b):\n            a = headB if not a else a.next\n            b = headA if not b else b.next\n        return a\n```\n- Time：O(n)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311342879","body":"```python\nclass Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        # 设定快慢指针，有环的链表最终会相遇\n        slow = fast = head\n        while fast and fast.next:\n            slow  = slow .next\n            fast = fast.next.next\n            if slow==fast:\n                break\n        else: return None\n        while head != slow:\n            head,slow = head.next,slow.next\n        return head\n```\n- Time: O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312405826","body":"```python\nclass ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache(object):\n\n    def __init__(self, capacity):\n        self.dic = dict() \n        self.capacity = capacity\n        self.head = ListNode(0, 0)\n        self.tail = ListNode(-1, -1)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self,key):\n        if key in self.dic:\n            node = self.dic[key]\n            self.removeFromList(node)\n            self.insertIntoHead(node)\n            return node.value\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.dic:               \n            node = self.dic[key]\n            self.removeFromList(node)\n            self.insertIntoHead(node)\n            node.value = value        \n        else: \n            if len(self.dic) >= self.capacity:\n                self.removeFromTail()\n            node = ListNode(key,value)\n            self.dic[key] = node\n            self.insertIntoHead(node)\n\n    def removeFromList(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def insertIntoHead(self, node):\n        headNext = self.head.next \n        self.head.next = node \n        node.prev = self.head \n        node.next = headNext \n        headNext.prev = node\n    \n    def removeFromTail(self):\n        if len(self.dic) == 0: return\n        tail_node = self.tail.prev\n        del self.dic[tail_node.key]\n        self.removeFromList(tail_node)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312642638","body":"```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # 使用DFS\n        if not root: return 0\n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312862826","body":"```python\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val==q.val and self.isSameTree(p.left,p.left) and self.isSameTree(q.right,q.right)\n```\n- Time:O(N)，其中 N 为树的节点数。\n- Space: O(h)，其中 h 为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314920392","body":"```python\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.res = 0\n        self.dfs(root,0)\n        return self.res\n\n    def dfs(self,root,path):\n        if root:\n            if not root.left and not root.right:\n                path = path*10+root.val\n                self.res += path\n            self.dfs(root.left,path*10+root.val)\n            self.dfs(root.right,path*10+root.val)\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316122994","body":"```python\nclass Solution(object):\n    def findBottomLeftValue(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.last_left,self.last_row = 0,-1\n        def dfs(cur_node,cur_row):\n            if not cur_node:\n                return\n            \n            if cur_row>self.last_row:\n                self.last_row = cur_row\n                self.last_left = cur_node.val\n\n            dfs(cur_node.left,cur_row + 1)\n            dfs(cur_node.right,cur_row+1)\n        \n        dfs(root,0)\n\n        return self.last_left\n```\n- Time:O(N)，其中 N 为树的节点总数。\n- Space:O(h)，其中 h 为树的高度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317848629","body":"```python\nclass Codec:\n\n    def serialize(self, root):\n        # 考虑最基本的情况，当一个节点为空节点的时候用什么字符代替\n        if not root:\n            return 'x'\n        # 对树进行先序遍历\n        return ','.join([str(root.val),self.serialize(root.left),self.serialize(root.right)])\n\n    def deserialize(self, data):\n        # 遇到x则置为null\n        self.data = data\n        if self.data[0] == 'x':\n            return None\n        node = TreeNode(self.data[:self.data.find(',')])\n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\n        return node\n```\n- Time:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319720394","body":"```python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        queue = [(root, 0)]\n        hashmap = collections.defaultdict(list);\n        level = 0\n        while (len(queue)):\n            levelSize = len(queue)\n            while (levelSize > 0):\n                curElem, pos = queue.pop(0)\n                hashmap[pos].append((level, curElem.val));\n                \n                if (curElem.left):\n                    queue.append((curElem.left, pos-1))\n                \n                if (curElem.right):\n                    queue.append((curElem.right, pos+1));\n                    \n                levelSize-=1;\n            level+=1;\n        keys = sorted(hashmap.keys());\n        result = []\n            \n        for key in keys:\n            curLevelElems = hashmap[key];\n            curLevelElems = sorted(hashmap[key])\n            result.append(list(map(lambda x: x[1],curLevelElems)));\n        return result\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320861209","body":"```python\nclass Solution(object):\n    def twoSum(self, nums, target):\n        seen = {}\n        for i, num in enumerate(nums):\n            if target - num in seen:\n                return [seen[target - num], i]\n            seen[num] = i\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321053046","body":"```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        hs = {}\n        frq = {}\n        for i in range(0,len(nums)):\n            if nums[i] not in hs:\n                hs[nums[i]] = 1\n            else:\n                hs[nums[i]] += 1\n        \n        for z,v in hs.iteritems():\n            if v not in frq:\n                frq[v] = [z]\n            else:\n                frq[v].append(z)\n        arr = []\n\n        for x in range(len(nums),0,-1):\n            if x in frq:\n                for i in frq[x]:\n                    arr.append(i)\n        return [arr[x] for x in range(0, k)]\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321299162","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points):\n        n = 0\n        for a,b in points:\n            counter = {}\n            for x,y in points:\n                dis = (x-a)**2 + (y-b)**2\n                if dis in counter:\n                    n += 2*counter[dis]\n                    counter[dis] += 1\n                else:\n                    counter[dis] = 1\n        return n\n```\n- Time:O(n^2)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322854831","body":"```python\nclass Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # 设置一个栈,无重复的就入栈,有重复就出栈,直至没有重复的再入栈\n        stack = []\n        n=0\n        for i in s:\n            while i in stack:\n                stack = stack[1:]\n            stack.append(i)\n            if n<len(stack):\n                n = len(stack)\n        return n\n```\n- Time:O(n^2)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324671646","body":"```python\nfrom collections import deque, defaultdict\n\nclass Solution(object):\n    def findSubstring(self, s, words):\n        # 使用哈系表加滑动窗口,滑动窗口的总长度不变\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n        # 创建关于words的字典\n        for word in words:\n            ori_word_dict[word] += 1\n        # 这里是滑动窗口的长度,正好对应了单词组合的总长度\n        all_word_len = len(words)*word_len\n        result = []\n        for i in range(word_len):\n            # 初始化滑动窗口\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i,len(s)-word_len+1,word_len):\n                word = s[j:j+word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n        return result\n```\n- Time:O(n*m)\n- Space:O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325799363","body":"```python\nclass Solution:\n    def minSubarray(self, nums, k):\n        target = sum(nums) % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % k\n            curtarget = (cur - target + k) % k\n            if curtarget in dic:\n                ans = min(ans,i-dic[curtarget])\n            dic[cur] = i\n        \n        if ans == len(nums):\n            return -1\n        return ans\n```\n- Time:O(n)\n- Space:O(min(n,k))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326928990","body":"```python\nclass Solution(object):\n    def middleNode(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        fast = slow = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        return slow\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327985688","body":"```python\nclass Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        x = 1\n\n        for i in range(len(nums)-1):\n            if(nums[i] != nums[i+1]):\n                nums[x] = nums[i+1]\n                x += 1\n        return(x)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161925","body":"```python\nclass Solution(object):\n    def searchInsert(self, nums, target):\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n- Time: O(logn)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328995556","body":"```python\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        from collections import deque\n        q = deque()\n        res = []\n        for i,cur in enumerate(nums):\n            while q and nums[q[-1]]<cur:\n                q.pop()\n            q.append(i)\n            if q[0] == i-k:\n                q.popleft()\n            if i>=k-1:\n                res.append(nums[q[0]])\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329920221","body":"```python\nclass Solution(object):\n    def findJudge(self, n, trust):\n        trusted = [0]*(n+1)\n        for (a,b) in trust:\n            trusted[a] -= 1\n            trusted[b] += 1\n        for i in  range(1,n+1):\n            if trusted[i] == n-1:\n                return i\n        return -1\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331500382","body":"```python\nimport collections\n\n\nclass Solution(object):\n    def possibleBipartition(self, n, dislikes):\n        Not_COLORED,BLUE,GREEN = 0,1,-1\n        def helper(person_id,color):\n            color_table[person_id] = color\n            for the_other in dislike_table[person_id]:\n                if color_table[the_other] == color:\n                    return False\n                if color_table[the_other] == Not_COLORED and not helper(the_other,-color):\n                    return False\n            return True\n        if n==1 or not dislikes:\n            return True\n        dislike_table = collections.defaultdict(list)\n        color_table = collections.defaultdict(int)\n        for p1,p2 in dislikes:\n            dislike_table[p1].append(p2)\n            dislike_table[p2].append(p1)\n        for person_id in range(1,n+1):\n            if color_table[person_id] == Not_COLORED and not helper(person_id,BLUE):\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333246361","body":"```python\nimport collections\nclass Solution:\n    def has_cycle(self,graph,cur_node,visited,result):\n        if visited[cur_node]==1:\n            return False\n        if visited[cur_node]==2:\n            return True\n        visited[cur_node]=2\n        for next_node in graph[cur_node]:\n            if self.has_cycle(graph,next_node,visited,result):\n                return True\n        visited[cur_node] = 1\n        result.append(cur_node)\n        return False\n    def sortItems(self, n, m, group, beforeItems):\n        # Map between group_id and item_ids\n        group_items_map = defaultdict(list)\n        # Visited for items in each group. Will be used later\n        visited_item = defaultdict(dict)\n        for i in range(n):\n            # Assign no-group items to a new group\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n            group_items_map[group[i]].append(i)\n            visited_item[group[i]][i] = 0\n\n        # key - group_id : value - next_groups\n        graph_group = defaultdict(set)\n        # key - group_id : value - {key - item_id : value: next_items}\n        graph_item = {i: defaultdict(list) for i in range(m)}\n\n        # Create graph for items and groups\n        for item_after, before_items in enumerate(beforeItems):\n            for item_before in before_items:\n                group_before = group[item_before]\n                group_after = group[item_after]\n\n                # If two items belong to different groups,\n                #   add a dependency between groups\n                # Otherwise, add a dependency between items in the same group\n                if group_before != group_after:\n                    graph_group[group_before].add(group_after)\n                else:\n                    graph_item[group_before][item_before].append(item_after)\n\n        # Use DFS to find group order\n        visited_group = [0] * m\n        group_order = []\n        for group_id in range(m):\n            if self.has_cycle(graph_group, group_id,\n                              visited_group, group_order):\n                return []\n\n        # Use DFS to find item order in each group\n        full_item_order = []\n        for group_id in group_order:\n            for item_id in group_items_map[group_id]:\n                if self.has_cycle(graph_item[group_id], item_id,\n                                  visited_item[group_id], full_item_order):\n                    return []\n        return full_item_order[::-1]\n   ```\n- Time:O(m+n)\n- Space:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334590680","body":"```python\nclass Solution(object):\n    def judgeCircle(self, moves):\n        return moves.count('L') == moves.count('R') and moves.count('U') == moves.count('D')\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336294247","body":"```python\nclass Solution:\n    def numberOfRounds(self, s, f):\n        sh, sm = s.split(\":\")\n        eh, em = f.split(\":\")\n        sh, sm, eh, em = int(sh), int(sm), int(eh), int(em)\n        if sh == eh:\n            if sm <= em:\n                d = em//15-(sm//15)-(1 if sm % 15 > 0 else 0)\n                return d if d > 0 else 0\n            else:\n                sm = 60-sm\n                val = 0\n                val += sm//15\n                val += em//15\n                return 23*4+val\n        else:\n            if eh < sh:\n                eh += 24\n            val = 0\n            sm = 60-sm\n            val += sm//15\n            val += em//15\n            sh += 1\n            return (eh-sh)*4+val\n```\n- Time:O(1)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336579090","body":"```python\nclass Solution:\n    def minCharacters(self,a,b):\n        cn1,cn2 = [0]*26,[0]*26\n        for c in a: cn1[ord(c)-97] += 1\n        for c in b: cn2[ord(c)-97] += 1\n\n        ans = len(a)+len(b)-max(x+y for x,y in zip(cn1,cn2))\n        for i in range(1, 26):  # note that letters can't be smaller than 'a' or bigger than 'z'\n            ans = min(ans, sum(cn1[:i]) + sum(cn2[i:]), sum(cn1[i:]) + sum(cn2[:i]))\n        return ans\n```\n- Time:O(26)\n- Space:O(52)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338354873","body":"```python\nclass Solution:\n    def sortArray(self, N):\n        def quicksort(A, I, J):\n            if J - I <= 1: return\n            p = partition(A, I, J)\n            quicksort(A, I, p), quicksort(A, p + 1, J)\n        \n        def partition(A, I, J):\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\n            for j in range(I,J):\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\n            A[J-1], A[i] = A[i], A[J-1]\n            return i\n        \n        quicksort(N,0,len(N))\n        return N\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340253231","body":"```python\nclass Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        l,r = 0,x\n        while l<=r:\n            mid = l + (r-l)//2\n            if mid*mid <= x < (mid+1)*(mid+1):\n                return mid\n            elif x<mid*mid:\n                r = mid-1\n            else:\n                l=mid+1\n```\n- Time:O(logn)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341755370","body":"```python\nclass Solution(object):\n    def firstBadVersion(self, n):\n        r = n-1\n        l = 0\n        while(l<=r):\n            mid = l + (r-l)/2\n            if isBadVersion(mid)==False:\n                l = mid+1\n            else:\n                r = mid-1\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343904464","body":"```python\nclass Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        s = []\n        count = 0\n        for i in reversed(xrange(len(nums))):\n            count += bisect.bisect_left(s,nums[i])\n            bisect.insort_left(s,nums[i]*2)\n        return count\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345691529","body":"```python\nclass Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # 其实就是从矩阵的左上角到右上角，然后想办法走最短路径\n        m = len(grid)\n        l,r = 2*m-2,m*m\n\n        def search(i,j):\n            if ele[i][j]:\n                return False\n            ele[i][j] = 1\n            if grid[i][j]<=ans:\n                if i==j==m-1:\n                    return True\n                return any([search(a,b) for a,b in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)] if 0<=a<m and 0<=b<m])\n        \n        for ans in range(max(l,grid[-1][-1]),r):\n            ele = [[0]*m for _ in range(m)]\n            if search(0,0):\n                return ans\n```\n- Time:O(NlogM)\n- Space:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347500153","body":"```python\nclass Solution(object):\n    def maxVowels(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        # 滑动窗口\n        yuanyin = ['a', 'e', 'i', 'o', 'u']\n        currCount = 0\n        maxCount = 0\n        for index, v in enumerate(s):\n            if index >= k:\n                if s[index-k] in yuanyin:\n                    currCount -= 1\n            if s[index] in yuanyin:\n                currCount += 1\n            maxCount = max(currCount,maxCount)\n        return maxCount\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350202286","body":"```python\nclass Solution:\n    def new21Game(self, n, k, maxPts):\n        if k == 0:\n            return 1.0\n        dp = [0.0] * (k + maxPts)\n        for i in range(k, min(n, k + maxPts - 1) + 1):\n            dp[i] = 1.0\n        for i in range(k - 1, -1, -1):\n            for j in range(1, maxPts + 1):\n                dp[i] += dp[i + j] / maxPts\n        return dp[0]\n```\n- Time:O(min(n,k+maxPts))\n- Space:O(k+maxPts)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352368806","body":"```python\nimport collections\nclass Solution:\n    def findAnagrams(self, s, p):\n        # 统计p的各个字母数量\n        myDictP=collections.Counter(p)\n        myDictS=collections.Counter(s[:len(p)])\n        output=[]\n        i=0\n        j=len(p)\n        \n        while j<=len(s):\n            # 如果字母频率组成相同，则记下当前索引\n            if myDictS==myDictP:\n                output.append(i)\n            # 最左边的字母出现次数-1\n            myDictS[s[i]]-=1\n            if myDictS[s[i]]<=0:\n                myDictS.pop(s[i])\n                \n            if j<len(s):    \n                 myDictS[s[j]]+=1\n            j+=1\n            i+=1\n            \n        return output\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354063915","body":"```python\nclass Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        need = collections.Counter(t)            #hash table to store char frequency\n        missing = len(t)                         #total number of chars we care\n        start, end = 0, 0\n        i = 0\n        for j, char in enumerate(s, 1):          #index j from 1\n            if need[char] > 0:\n                missing -= 1\n            need[char] -= 1\n            if missing == 0:                     #match all chars\n                while i < j and need[s[i]] < 0:  #remove chars to find the real start\n                    need[s[i]] += 1\n                    i += 1\n                need[s[i]] += 1                  #make sure the first appearing char satisfies need[char]>0\n                missing += 1                     #we missed this first char, so add missing by 1\n                if end == 0 or j-i < end-start:  #update window\n                    start, end = i, j\n                i += 1                           #update i to start+1 for next window\n        return s[start:end]\n```\n- Time:O(n)\n- Space:O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356938755","body":"```python\nclass Solution(object):\n    def totalNQueens(self, n):\n        row = col = ans = 0\n        queens = [-1]*n\n        columns = [True] * n + [False]\n        back = [True] * n * 2\n        forward = [True] * n * 2\n        while True:\n            if columns[col] and back[col - row + n] and forward[col + row]:\n                queens[row] = col\n                columns[col] = back[col - row + n] = forward[col + row] = False\n                row += 1\n                col = 0\n            else:\n                if row == n or col == n:\n                    if row == n:\n                        ans += 1\n                    if row == 0:\n                        return ans\n                    row -= 1\n                    col = queens[row]\n                    columns[col] = back[col - row + n] = forward[col + row] = True\n                col += 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358835841","body":"```python\nclass Solution(object):\n    def maxAreaOfIsland(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        maxArea = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n               if grid[i][j] == 1:  # run dfs only when we find a land\n                    maxArea = max(maxArea, self.dfs(grid, i, j))\n        return maxArea\n\n    def dfs(self, grid, i, j):\n        if i<0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j] != 1:\n            return 0\n        maxArea = 1\n        grid[i][j] = '#'  \n        maxArea += self.dfs(grid, i+1, j)\n        maxArea += self.dfs(grid, i-1, j)\n        maxArea += self.dfs(grid, i, j+1)\n        maxArea += self.dfs(grid, i, j-1)\n        \n        return maxArea\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361198906","body":"```python\nfrom collections import deque\n\nclass Solution:\n    def is_cell_valid(self, cell_i, cell_j, n):\n        return (cell_i >= 0 and cell_i <= n - 1) and (cell_j >= 0 and cell_j <= n-1)\n    \n    def add_adj_to_search(self, cell_i, cell_j, queue, n):\n        if self.is_cell_valid(cell_i, cell_j, n):\n            queue.append((cell_i, cell_j, 1))\n        \n    def maxDistance(self, grid):\n        n = len(grid)\n        dis = [[-1 for _ in range(n) ]for _ in range(n)]\n        q = deque()\n        lands = []\n        furthest_seen = 1\n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dis[i][j] = 0\n                    lands.append((i, j))\n\n        if not lands or len(lands) == n**2:\n            return -1\n\n        cell_neighbors = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        \n        for land_i, land_j in lands:\n            for cell_i, cell_j in cell_neighbors:\n                self.add_adj_to_search(land_i + cell_i, land_j + cell_j, q, n)\n\n        while q:\n            cell_i, cell_j, distance = q.popleft()\n            if dis[cell_i][cell_j] == -1:\n\n                dis[cell_i][cell_j] = distance\n                furthest_seen = max(furthest_seen, distance)\n\n                for nei_i, nei_j in cell_neighbors:\n                    new_i, new_j = cell_i + nei_i, cell_j + nei_j\n\n                    if self.is_cell_valid(new_i, new_j, n):\n                        q.append((new_i, new_j, distance + 1))\n\n        return furthest_seen\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364430033","body":"```python\nclass Solution:\n\tdef minCostClimbingStairs(self, cost):\n\t\tcur = 0 \n\t\tdp0 = cost[0]\n\t\tif len(cost) >= 2:\n\t\t\tdp1 = cost[1]\n\n\t\tfor i in range(2, len(cost)):\n\t\t\tcur = cost[i] + min(dp0, dp1)\n\t\t\tdp0 = dp1\n\t\t\tdp1 = cur\n\n\t\treturn min(dp0, dp1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364668626","body":"```python\nclass Solution(object):\n    def rob(self, nums):\n        length = len(nums)\n        if length==0:\n            return 0\n        if length==1:\n            return nums[0]\n        if length==2:\n            return max(nums)\n        \n        dp = [0]*length\n        dp[0],dp[1] = nums[0],max(nums[0],nums[1])\n\n        for i in range(2,length):\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1])\n        print(dp)\n\n        return max(dp)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365582079","body":"```python\nclass Solution:\n    def longestCommonSubsequence(self, s1, s2):\n        dp = [[0 for i in range(len(s1)+1)] for j in range(len(s2)+1)]\n        for i in range(1,len(dp)):\n            for j in range(1,len(dp[i])):\n                s1_sub = s1[:j]\n                s2_sub = s2[:i]\n                if s1_sub[-1] == s2_sub[-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i][j-1],dp[i-1][j])\n        return dp[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366373398","body":"```JavaScript\nvar uniquePaths = function(m, n) {\n    // m-1个右，n-1个下\n    // 相当于有m个空，让n-1个下排雷组合\n    // C  n-1+m-1\n    // Total permutations = (m+n)! / (m! * n!)\n    if(m === 1 || n === 1) return 1;\n    m--; n--;\n    // Swap, so that m is the bigger number\n    if(m<n){\n        m=m+n;\n        n=m-n;\n        m=m-n;\n    }\n    let res=1;\n    let j=1;\n    for(let i=m+1;i<=m+n;i++,j++){\n        res*=i;\n        res/=j;\n    }\n    return res;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367706408","body":"```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        def dfs_rec_memo(total,num_used):\n            if(tuple(num_used) in cache):\n                return cache[tuple(num_used)]\n            for num in range(1,maxChoosableInteger + 1):\n                if(not num_used[num]):\n                    if(total +num>=desiredTotal):\n                        cache[tuple(num_used)] = True\n                        return True\n                    num_used[num] = True\n                    if(not dfs_rec_memo(total+num,num_used)):\n                        num_used[num] = False\n                        cache[tuple(num_used)] = True\n                        return True\n                    num_used[num] = False\n            cache[tuple(num_used)] = False\n            return False\n        if(1+maxChoosableInteger)*maxChoosableInteger//2 < desiredTotal:\n            return False\n        \n        cache = {}\n        num_used = [False]*(maxChoosableInteger+1)\n        return dfs_rec_memo(0,num_used)\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369510433","body":"```javascript\nvar change = function (amount, coins) {\n    let dp = new Array(amount + 1).fill(0);\n    dp[0] = 1;\n    for (let coin of coins) {\n        for (let i = coin; i < amount + 1; i++) {\n\n            dp[i] += dp[i - coin];\n        }\n    }\n    return dp[amount];\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546268","body":"### 思路: 用一个栈负责进入,然后将这个栈中的元素倒置放在另一个栈中,每次push取栈1,pop和peek取栈2的栈顶\n\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = []\n};\n\n\nMyQueue.prototype.push = function(x) {\n    console.info(x)\n    this.stack1.push(x)\n    \n};\n\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\n\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length-1] \n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length ==0 && this.stack2.length == 0\n};\n\nvar obj = new MyQueue()\nobj.push(1)\nvar param_2 = obj.pop()\n\n### 复杂度分析:\n时间: pop,peek O(n), empty O(1)\n空间: O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312425909","body":"### 思路\n根据题意，插入和查询都必须满足O(1)的平均时间复杂度，我们可以分别用双向链表实现插入删除，hash表实现查询，具体思路：\n\n查询时：未查到，返回-1；查到了，除了返回值，我们还要将对应的node更新至头部\n插入时：未存在，将节点插在头部，若插入后超过容量，直接删除尾部节点；若存在，就变更对应的值，并将节点移到头部\n\n<pre>\n<code>\nclass Node{\n    int key;\n    int value;\n    Node pre;\n    Node next;\n}\n\n/**\n     * 0. hash表维护查O(1): {{1: {1, 1}}, {2: {2, 2}}}\n     * 1. 双向链表实现插入删除O(1)\n     */\n    class LRUCache {\n        private HashMap<Integer, Node> dict;\n        private int capacity;\n        private Node head;\n        private Node tail;\n\n        public LRUCache(int capacity) {\n            this.capacity = capacity;\n            dict = new HashMap<>();\n            head = new Node();\n            tail = new Node();\n            head.next = tail;\n            tail.pre = head;\n        }\n\n        public int get(int key) {\n            if(!dict.containsKey(key)) return -1;\n            //存在，节点更新至头部\n            Node node = dict.get(key);\n            remove(node);\n            insert(head, node);\n            return node.value;\n        }\n\n        public void put(int key, int value) {\n            if(!dict.containsKey(key)){\n                //不存在，将节点放在头节点后面\n                Node node = new Node();\n                node.key = key;\n                node.value = value;\n                dict.put(key, node);\n                insert(head, node);\n                //超过容量，更新hash表，并移除末尾节点\n                if(dict.size() > capacity){\n                    dict.remove(tail.pre.key);\n                    remove(tail.pre);\n                }\n            }else{\n                //存在，则将该节点移到头部\n                Node node = dict.get(key);\n                node.value = value;\n                remove(node);\n                insert(head, node);\n            }\n\n        }\n\n        //双向链表的插入删除模板\n        void insert(Node head, Node node){\n            head.next.pre = node;\n            node.next = head.next;\n            head.next = node;\n            node.pre = head;\n        }\n\n        void remove(Node node){\n            node.pre.next = node.next;\n            node.next.pre = node.pre;\n        }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n<code>\n<pre>\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318746952","body":"## 代码\n<pre>\n<code>\nvar serialize = function(root) {\n    return rserialize(root, '');\n};\n\nvar deserialize = function(data) {\n    const dataArray = data.split(\",\");\n    return rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\n    if (root === null) {\n        str += \"None,\";\n    } else {\n        str += root.val + '' + \",\";\n        str = rserialize(root.left, str);\n        str = rserialize(root.right, str);\n    }\n    return str;\n}\n\nconst rdeserialize = (dataList) => {\n    if (dataList[0] === \"None\") {\n        dataList.shift();\n        return null;\n    }\n\n    const root = new TreeNode(parseInt(dataList[0]));\n    dataList.shift();\n    root.left = rdeserialize(dataList);\n    root.right = rdeserialize(dataList);\n\n    return root;\n}\n</code>\n</pre>\n\n## 复杂度\n时间复杂度：在序列化和反序列化函数中，我们只访问每个节点一次，因此时间复杂度为 O(n)O(n)，其中 nn 是节点数，即树的大小。 \n\n空间复杂度：在序列化和反序列化函数中，我们递归会使用栈空间，故渐进空间复杂度为 O(n)O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325971232","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& A, int K) {\n    \tint res = 0, sum = 0;\n        unordered_map<int, int> m{{0, 1}};\n        for (int num : A) {\n        \tsum = (sum + num % K + K) % K;\n        \tres += m[sum];\n        \t++m[sum];\n        }\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297621667","body":"**Thoughts**\n\nAdding k with the last digit of num, the mod result will be the digit of result, and carry-on can be calculated as well\n\n**Complexity**\n\nO(N)\n\n**Code**\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list  = new LinkedList<>();\n        int n = num.length;\n\n        // each time we add k with last digit of num, add the mod value to the list \n        for (int i = n - 1; i >= 0; i--) {\n            list.add(0, (num[i] + k) % 10);\n            // carry on value\n            k = (num[i] + k) / 10;\n        }\n        //for the rest of k\n        while (k > 0) {\n            list.add(0, k % 10);\n            k /= 10;\n        }\n        return list;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299508660","body":"**Thoughts**\n\nSweep string s from left and right side, if we locate c, record the index, then compare the absolute value of i and index\n\n**Complexity**\n\nTime: O(n)\nSpace: O(1) no other space except the result\n\n**Code**\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n\n        for (int i = 0, idx = -len; i < len; i++) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n        for (int i = len - 1, idx = 2 * len; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = Math.min(idx - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302272872","body":"**Thoughts**\n\nJust simple manipulation \n\n**Time Complexity**\n\nTime: O(1)\nSpace: O(1)\n\n**Code**\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top; // to record the index of top element\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303802706","body":"**Thoughts**\n\nUse Stack to push characters of s, stop when it hits ], and then gather the characters, read the multiplier, finally push all characters into the stack and pop out\n\n**Complexity**\n\nTime: O(N), N is the length of s\nSpace: O(N) the use of stack\n\n**Code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n            } else {\n                StringBuilder sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                String sub = sb.toString();\n                stack.pop(); // remove [\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                int count = Integer.valueOf(sb.toString());\n\n                while (count > 0) {\n                    for (char su: sub.toCharArray()) {\n                        stack.push(su);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304389055","body":"***Thoughts***\n\nUsing two stacks, one is to save input, another one is used to save data in reverse direction\n\n***Complexity***\n\nTime: O(1) no traversing\nSpace: O(N). use another stack\n\n***Code***\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() { \n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815563","body":"***Thoughts***\n\n1. If current number is greater the peek of stack, it can be an individual chunk\n2. If current number is less than the peek of stack, we remove the values greater than it\n\n**Complexity**\n\nTime: O(N)\nSpace: O(N)\n\n**Code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307365421","body":"**Thoughts**\n\nRecursive way to sway a pair of nodes, each time move to the next pair\n\n**Complexity**\n\nTime: O(N)\n\nSpace: O(N) stack been used\n\n**Code**\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode tmp = head.next;\n        head.next = swapPairs(tmp.next);\n        tmp.next = head;\n        return tmp;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308168028","body":"**Thoughts**\n\nDivide and conquer \n\n**Complexity**\n\nTime: O(NlogN)\nSpace: O(logN) max depth of stack \n\n**Code**\n\n```java\n\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) return null;\n\n        ListNode mid = findMid(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode findMid(ListNode left, ListNode right) {\n        ListNode slow = left;\n        ListNode fast = left;\n\n        while (fast != right && fast.next != right) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310455614","body":"**Thoughts**\n\nTwo pointers, once pointer A meet the tail of headA, connect it to headB, A and B will finally meet at the intersection if there's one\n\n**Complexity**\n\nTime: O(n) , n is the total length of two lists\nSpace: O(1)\n\n**Code**\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode pA = headA, pB = headB;\n\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311783416","body":"**Thoughts**\r\n\r\nIf no loop, fast will hit the tail of list; if loop. exists, fast will catch slow eventually. \r\nOnce fast caught slow, we use another pointer to find the node cycle begins\r\n\r\n**Complexity**\r\n\r\nTime: O(n)\r\nSpace: O(1)\r\n\r\n**Code**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;// no loop\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (fast == slow) break; // fast caught slow in the loop\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            // once slow == fast, loop ends\r\n            // fast will be at the point cycle begins\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312515659","body":"***Code***\n\n```java\nclass LRUCache { \n\n    class DoublyLinkedNde {\n        int key;\n        int val;\n        DoublyLinkedNde prev;\n        DoublyLinkedNde next;\n        public DoublyLinkedNde() {}\n        public DoublyLinkedNde (int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private Map<Integer, DoublyLinkedNde> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DoublyLinkedNde head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        head = new DoublyLinkedNde();\n        tail = new DoublyLinkedNde();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DoublyLinkedNde tmp = cache.get(key);\n        if (tmp == null) {\n            return -1;\n        }\n        moveToHead(tmp);\n        return tmp.val;\n    }\n    \n    public void put(int key, int value) {\n        DoublyLinkedNde tmp = cache.get(key);\n        if (tmp != null) {\n            tmp.val = value;\n            moveToHead(tmp);\n        } else {\n            DoublyLinkedNde node = new DoublyLinkedNde(key, value);\n            cache.put(key, node);\n            addNode(node);\n            size++;\n            if (size > capacity) {\n                DoublyLinkedNde res = removeTail();\n                cache.remove(res.key);\n                size--;\n            }\n        }\n\n    }\n \n    private void moveToHead(DoublyLinkedNde node) {\n        remove(node);\n        addNode(node);\n    }\n\n    private void remove(DoublyLinkedNde node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void addNode(DoublyLinkedNde node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private DoublyLinkedNde removeTail() {\n        DoublyLinkedNde res = tail.prev;\n        remove(res);\n        return res;\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312518111","body":"***Thoughts***\n\nRecursive solution\n\n**Complexity**\n\nTime: O(N), each node being visited once\nSpace: O(height), the height of tree\n\n**Code**\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        } else {\n            return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n        }\n    }\n}\n\n```\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316280920","body":"***Thoughts***\n\nBFS, each time visit right subnode, and then left subnode. so the last node we visit must be the very left subnode of the last level\n\n***Complexity***\n\nTime: O(n), visit all nodes\nSpace: O(n) extra space used\n\n***Code***\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res = 0;\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode p = queue.poll();\n            if (p.right != null) {\n                queue.offer(p.right);\n            }\n            if (p.left != null) {\n                queue.offer(p.left);\n            }\n            res = p.val;\n        }\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297787339","body":"### 思路\r\n\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+2, 2+1, 1+9。当对应位的加和结果超过10，我们将先将0加入list，再加入1，最后结果是1035。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n    for (int i = num.length - 1; i >= 0; i--) {\r\n            res.add((num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while(k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341332","body":"### 思路\r\n两次遍历，第一次找到每个i左边最近的 c，第二次找到每个i右边最近的 c。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        \r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = i - j;\r\n        }\r\n        \r\n        for(int i = n-1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = Math.min(ans[i], j - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301328092","body":"### 思路\r\n新建一个数组来进行模拟栈的操作\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top = -1;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) return -1;\r\n        top--;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：increment的操作是O(n)，其他操作是O(1)。\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303048165","body":"## Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## Time Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304413581","body":"## Thoughts\r\n- 使用两个栈，一个输入栈，一个输出栈\r\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\r\n- empty方法需要判断两个栈都为空\r\n\r\n## Code\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s2.isEmpty()) {\r\n          while(!s1.isEmpty()) s2.push(s1.pop());  \r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n## TC\r\nTime: O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304649141","body":"## Thoughts\r\n前缀和方法：\r\narr: [2,1,3,4,4]\r\ncopy:[1,2,3,4,4]\r\n## Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] copy = arr.clone();\r\n        Arrays.sort(copy);\r\n        int count = 0;\r\n        int sum1 = 0, sum2 = 0;\r\n        for(int i = 0; i < arr.length; i++) {\r\n            sum1 += arr[i];\r\n            sum2 += copy[i];\r\n            if(sum1 == sum2) {\r\n                count++;\r\n                sum1 = 0;\r\n                sum2 = 0;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n## TC\r\n- Time: O(nlogn)\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304922454","body":"## Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode p = head;\r\n        int count = 1;\r\n        while(p.next != null) {\r\n            p = p.next;\r\n            count += 1;\r\n        }\r\n        if((k % count) == 0) return head;\r\n        ListNode slow = head, fast = head;\r\n        for(int i = 0; i < (k % count); i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        ListNode node = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n    return node;\r\n    }\r\n}\r\n/*\r\n[1,2,3,4,5]\r\n[4,5,1,2,3]\r\n*/\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305969136","body":"## Code\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head.next;\r\n        ListNode others = head.next.next;\r\n        //swap the first two nodes\r\n        fast.next = slow;\r\n        //recursive\r\n        slow.next = swapPairs(others);\r\n        \r\n        return fast;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308007109","body":"## Thoughts\r\n和leetcode 108很像，也可以直接将list转化为array然后套用108的解法。\r\n## Code\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return build(head, null);\r\n    }\r\n    public TreeNode build(ListNode head, ListNode tail){\r\n        if(head == tail) return null;\r\n        ListNode slow = head, fast = head;\r\n        while(fast != tail && fast.next != tail){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = build(head, slow);\r\n        root.right = build(slow.next, tail);\r\n        \r\n        return root;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309196539","body":"## Code\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b  = headB;\r\n        \r\n        while( a != b){\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        \r\n        return a;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310690399","body":"## Code\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow) break;\r\n        }\r\n        slow = head;\r\n        if(fast == null || fast.next == null){\r\n            return null;\r\n        }\r\n        while(slow != fast) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312369145","body":"```java\r\nclass LRUCache {\r\n    int cap;\r\n    Map<Integer, Integer> cache;\r\n    public LRUCache(int capacity) {\r\n        cap = capacity;\r\n        cache = new LinkedHashMap<>();\r\n    }\r\n    \r\n    public int get(int key) {\r\n    /*\r\n    if key 存在:\r\n        返回节点值\r\n        把节点移到链表头部\r\n    else:\r\n        返回 -1\r\n    */ \r\n        if(cache.containsKey(key)){\r\n            makeRecently(key);\r\n            return cache.get(key);\r\n        }else return -1;\r\n        \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n    /*\r\n    if key 存在:\r\n        更新节点值\r\n        把节点移到链表头部\r\n\r\n    else:\r\n        if 缓存满了:\r\n            移除最后一个节点\r\n            删除它在哈希表中的映射\r\n\r\n        新建一个节点\r\n        把节点加到链表头部\r\n        在哈希表中增加映射\r\n    */\r\n        if(cache.containsKey(key)){\r\n            cache.put(key, value);\r\n            makeRecently(key);\r\n            return;\r\n        }\r\n        else {\r\n            if(cache.size() >= cap){\r\n                int recentKey = cache.keySet().iterator().next();\r\n                cache.remove(recentKey);\r\n            }\r\n            cache.put(key, value);\r\n        }\r\n    }\r\n    \r\n    public void makeRecently(int key) {\r\n        int val = cache.get(key);\r\n        cache.remove(key);\r\n        cache.put(key, val);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312760528","body":"#Code\r\n```java\r\nclass Solution {\r\n    int curDepth = 0;\r\n    int maxDepth = 0;\r\n    \r\n    public int maxDepth(TreeNode root) {\r\n        traverse(root);\r\n        return maxDepth;\r\n    }\r\n    \r\n    private void traverse(TreeNode root) {\r\n        if (root == null) return;\r\n        curDepth++;\r\n        maxDepth = Math.max(maxDepth, curDepth);\r\n        traverse(root.left);\r\n        traverse(root.right);\r\n        curDepth--;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313218209","body":"## Code\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        else if (p == null || q == null) return false;\r\n        else if (p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314804536","body":"```java\r\nclass Solution {\r\n    private int ans;\r\n    public int sumNumbers(TreeNode root) {\r\n        dfs(root, 0);\r\n        return ans;\r\n    }\r\n    \r\n    public int dfs(TreeNode root, int n) {\r\n        if(root.left == null && root.right == null) {\r\n            ans += n * 10 + root.val;\r\n            return ans;\r\n        }\r\n        dfs(root.left, n * 10 + root.val);\r\n        dfs(root.right, n * 10 + root.val);\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316513626","body":"```java\r\nclass Solution {\r\n    public int findBottomLeftValue(TreeNode root) {\r\n        int res = 0;\r\n        Deque<TreeNode> queue = new ArrayDeque<>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            res = queue.peek().val;\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = queue.poll();\r\n                if (cur.left != null) {\r\n                    queue.offer(cur.left);\r\n                }\r\n                if (cur.right != null) {\r\n                    queue.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318107182","body":"```java\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuilder sb = new StringBuilder();\r\n        serialize(root, sb);\r\n        return sb.toString();\r\n    }\r\n    \r\n    void serialize(TreeNode root, StringBuilder sb) {\r\n        if(root == null) {\r\n            sb.append(\"null\").append(\",\");\r\n            return;\r\n        }\r\n        sb.append(root.val).append(\",\");\r\n        serialize(root.left, sb);\r\n        serialize(root.right, sb);\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        LinkedList<String> nodes = new LinkedList<>();\r\n        for(String s : data.split(\",\")) {\r\n            nodes.add(s);\r\n        }\r\n        return deserialize(nodes);\r\n    }\r\n    \r\n    TreeNode deserialize(LinkedList<String> nodes) {\r\n        if(nodes.isEmpty()) return null;\r\n        String first = nodes.remove();\r\n        if(first.equals(\"null\")) return null;\r\n        TreeNode root = new TreeNode(Integer.parseInt(first));\r\n        root.left = deserialize(nodes);\r\n        root.right = deserialize(nodes);\r\n        return root;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319428379","body":"```java\r\nclass Solution {\r\n    class Node {\r\n        int row, col;\r\n        TreeNode node;\r\n        public Node(TreeNode node, int row, int col) {\r\n            this.node = node;\r\n            this.row = row;\r\n            this.col = col;\r\n        }\r\n    }\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        traverse(root, 0, 0);\r\n        Collections.sort(nodes, (Node a, Node b) -> {\r\n            if(a.col == b.col && a.row == b.row) return a.node.val - b.node.val;\r\n            if(a.col == b.col) return a.row - b.row;\r\n            return a.col - b.col;\r\n        });\r\n        \r\n        LinkedList<List<Integer>> ans = new LinkedList<>();\r\n        int preCol = Integer.MIN_VALUE;\r\n        for(int i = 0; i < nodes.size(); i++){\r\n            Node curNode = nodes.get(i);\r\n            if(curNode.col != preCol) {\r\n                ans.add(new LinkedList<>());\r\n                preCol = curNode.col;\r\n            }\r\n            ans.getLast().add(curNode.node.val);\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    ArrayList<Node> nodes = new ArrayList<>();\r\n    public void traverse(TreeNode root, int row, int col){\r\n        if(root == null) return;\r\n        nodes.add(new Node(root, row, col));\r\n        traverse(root.left, row+1, col-1);\r\n        traverse(root.right, row+1, col+1);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320811040","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for(int i = 0; i < nums.length; i++){\r\n            if(map.containsKey(target - nums[i])) return new int[]{ map.get(target - nums[i]), i};\r\n            map.put(nums[i], i);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321021930","body":"```java\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        HashMap<Integer, Integer> map = new HashMap<>();\r\n        for(int num : nums) {\r\n            map.put(num, map.getOrDefault(num, 0)+1);\r\n        }\r\n        //build max heap\r\n        PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o2.getValue() - o1.getValue());\r\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()) {\r\n            queue.offer(entry);\r\n        }\r\n        int[] ans = new int[k];\r\n        int index = 0;\r\n        while(!queue.isEmpty() && index < k){\r\n            ans[index++] = queue.poll().getKey();\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321613154","body":"```java\r\nclass Solution {\r\n    public int numberOfBoomerangs(int[][] points) {\r\n        int ans = 0;\r\n        for (int[] p : points) {\r\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n            for (int[] q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\r\n            }\r\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\r\n                int m = entry.getValue();\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323110155","body":"```java\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        int[] map = new int[256];\r\n        Arrays.fill(map, -1);\r\n        int ans = 0;\r\n        int pre = 0;\r\n        for(int i = 0; i < s.length(); i++){\r\n            char c = s.charAt(i);\r\n            pre = Math.min(pre + 1, i - map[c]);\r\n            ans = Math.max(ans, pre);\r\n            map[c] = i;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324206879","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int totalLen = s.length();\r\n        int len = words[0].length();\r\n        int n = words.length;\r\n        if (n*totalLen == 0){\r\n            return result;\r\n        }\r\n        HashMap<String,Integer> wordMap = new HashMap<>();\r\n        for (String word:words) {\r\n            int value = wordMap.getOrDefault(word, 0);\r\n            wordMap.put(word,value+1);\r\n        }\r\n        \r\n        for (int i = 0; i <totalLen-n*len+1; i++) {\r\n          \r\n            Map<String,Integer> hasWords = new HashMap<>();\r\n            int num = 0;\r\n            while (num < n){\r\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\r\n                if (wordMap.containsKey(currWord)){\r\n                    int value = hasWords.getOrDefault(currWord,0);\r\n                    hasWords.put(currWord,value+1);\r\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n                num++;\r\n            }\r\n            if (num == n){\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326029332","body":"```java\r\n\r\nclass Solution {\r\n    public int subarraysDivByK(int[] nums, int k) {\r\n        int n = nums.length;\r\n        int[] s = new int[n + 1];\r\n        for(int i = 1; i <= n; i++){\r\n            s[i] = s[i - 1] + nums[i - 1];\r\n        }\r\n        Map<Integer, Integer> cnt = new HashMap<>();\r\n        cnt.put(0, 1);\r\n        int res = 0;\r\n        for(int i = 1; i <= n; i++){\r\n            int r = (s[i] % k  + k) % k;\r\n            res += cnt.getOrDefault(r, 0);\r\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327175561","body":"```java\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        return slow;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327736088","body":"```java\r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int j = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (nums[i] != nums[j]) {\r\n                nums[++j] = nums[i];\r\n            }\r\n        }\r\n        return j + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328211738","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int left = 0;\r\n        int right = nums.length - 1;\r\n        while (left < right - 1) {\r\n            int mid = left + (right - left) / 2;\r\n            if (nums[mid] == target) {\r\n                return mid;\r\n            } else if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid;\r\n            }\r\n        }\r\n        if (nums[left] >= target) {\r\n            return left;\r\n        }\r\n        if (nums[right] >= target) {\r\n            return right;\r\n        }\r\n        return nums.length;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328693590","body":"```java\r\n\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        if(nums == null || k < 1 || nums.length < k){\r\n            return null;\r\n        }\r\n\r\n        LinkedList<Integer> qmax = new LinkedList<>();\r\n        int[] result = new int[nums.length - k + 1];\r\n\r\n        int index = 0;\r\n\r\n        for(int R = 0; R < nums.length; R++){\r\n            while (!qmax.isEmpty() && nums[qmax.peekLast()] <= nums[R]){\r\n                qmax.pollLast();\r\n            }\r\n            qmax.addLast(R);\r\n            if(qmax.peekFirst() == R - k){\r\n                qmax.pollFirst();\r\n            }\r\n            if(R >= k - 1){\r\n                result[index++] = nums[qmax.peekFirst()];\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329829345","body":"```java\r\nclass Solution {\r\n    public int findJudge(int N, int[][] trust) {\r\n        if (trust.length < N - 1) \r\n            return -1;\r\n        \r\n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\r\n        \r\n        for (int[] t : trust) {\r\n            trustScores[t[1]]++;\r\n            trustScores[t[0]]--;\r\n        }\r\n        \r\n        for (int i = 1; i <= N; i++) {\r\n            if (trustScores[i] == N - 1)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330914681","body":"```java\r\nclass Solution {\r\n\r\n    private boolean ok = true;\r\n    private boolean[] color;\r\n    private boolean[] visited;\r\n\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        // 图节点编号从 1 开始\r\n        color = new boolean[n + 1];\r\n        visited = new boolean[n + 1];\r\n        // 转化成邻接表表示图结构\r\n        List<Integer>[] graph = buildGraph(n, dislikes);\r\n\r\n        for (int v = 1; v <= n; v++) {\r\n            if (!visited[v]) {\r\n                traverse(graph, v);\r\n            }\r\n        }\r\n        return ok;\r\n    }\r\n\r\n    // 建图函数\r\n    private List<Integer>[] buildGraph(int n, int[][] dislikes) {\r\n        // 图节点编号为 1...n\r\n        List<Integer>[] graph = new LinkedList[n + 1];\r\n        for (int i = 1; i <= n; i++) {\r\n            graph[i] = new LinkedList<>();\r\n        }\r\n        for (int[] edge : dislikes) {\r\n            int v = edge[1];\r\n            int w = edge[0];\r\n            // 「无向图」相当于「双向图」\r\n            // v -> w\r\n            graph[v].add(w);\r\n            // w -> v\r\n            graph[w].add(v);\r\n        }\r\n        return graph;\r\n    }\r\n\r\n    // 和之前判定二分图的 traverse 函数完全相同\r\n    private void traverse(List<Integer>[] graph, int v) {\r\n        if (!ok) return;\r\n        visited[v] = true;\r\n        for (int w : graph[v]) {\r\n            if (!visited[w]) {\r\n                color[w] = !color[v];\r\n                traverse(graph, w);\r\n            } else {\r\n                if (color[w] == color[v]) {\r\n                    ok = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333067339","body":"## Code\r\n```java\r\npublic int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        List<List<Integer>> groupItem = new ArrayList<>();//项目分组\r\n        for(int i = 0;i < n + m;i++){//初始化小组\r\n            groupItem.add(new ArrayList<>());\r\n        }\r\n  \t\t\tint gId = m;//新的组号从m开始\r\n        for(int i = 0;i < group.length;i++){\r\n            if(group[i] == -1)group[i] = gId++;//没有id的加上组id\r\n            groupItem.get(group[i]).add(i);//同一组的放在一起\r\n        }\r\n        List<List<Integer>> graphInGroup = new ArrayList<>();//组内拓扑关系\r\n        List<List<Integer>> graphOutGroup = new ArrayList<>();//组间拓扑关系\r\n        for(int i = 0;i < n + m;i++){//初始化拓扑关系\r\n            graphOutGroup.add(new ArrayList<>());\r\n            if(i >= n)continue;\r\n            graphInGroup.add(new ArrayList<>());\r\n        }\r\n        List<Integer> groupId = new ArrayList<>();//所有组id\r\n        for(int i = 0;i < n + m;i++){\r\n            groupId.add(i);\r\n        }\r\n  \t\t\t// 需要拓扑排序 所以结点的入度必不可少 两个数组分别维护不同结点的入度\r\n        int[] degInGroup = new int[n];//组内 结点入度 （组内项目入度）\r\n        int[] degOutGroup = new int[n + m];//组间 结点入度（小组入度）\r\n\r\n        for(int i = 0;i < beforeItems.size();i++){//遍历关系\r\n            int curGroupId = group[i];//当前项目i所属的小组id\r\n            List<Integer> beforeItem = beforeItems.get(i);\r\n            for(Integer item : beforeItem){\r\n                if(group[item] == curGroupId){//同一组 修改组内拓扑\r\n                    degInGroup[i]++;// 组内结点的入度+1\r\n                    graphInGroup.get(item).add(i);//item 在 i之前\r\n                }else{\r\n                    degOutGroup[curGroupId]++;// 小组间的结点入度 + 1\r\n                    graphOutGroup.get(group[item]).add(curGroupId);// group[item] 小组 在 curGroupId 之前\r\n                }\r\n            }\r\n        }\r\n  \t\t\t//组间拓扑排序，也就是小组之间的拓扑排序，需要的参数 小组结点的入度degOutGroup，所有的小组groupId，组间的拓扑关系图graphOutGroup\r\n        List<Integer> outGroupTopSort = topSort(degOutGroup,groupId,graphOutGroup);\r\n        if(outGroupTopSort.size() == 0)return new int[0];//无法拓扑排序 返回\r\n\r\n        int[] res = new int[n];\r\n        int index = 0;\r\n        for(Integer gid : outGroupTopSort){//遍历排序后的小组id\r\n            List<Integer> items = groupItem.get(gid);//根据小组id 拿到这一小组中的所有成员\r\n            if(items.size() == 0)continue;\r\n          \t//组内拓扑排序，需要的参数 组内结点的入度degInGroup，组内的所有的结点groupItem.get(gid)，组内的拓扑关系图graphInGroup\r\n            List<Integer> inGourpTopSort = topSort(degInGroup,groupItem.get(gid),graphInGroup);\r\n            if(inGourpTopSort.size() == 0)return new int[0];//无法拓扑排序 返回\r\n            for(int item : inGourpTopSort){//排序后，依次的放入答案集合当中\r\n                res[index++] = item;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n\r\n    public List<Integer> topSort(int[] deg, List<Integer> items,List<List<Integer>> graph){\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for(Integer item:items){\r\n            if(deg[item] == 0)queue.offer(item);\r\n        }\r\n        List<Integer> res = new ArrayList<>();\r\n        while(!queue.isEmpty()){\r\n            int cur = queue.poll();\r\n            res.add(cur);\r\n            for(int neighbor: graph.get(cur)){\r\n                if(--deg[neighbor] == 0){\r\n                    queue.offer(neighbor);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : new ArrayList<>();\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334868235","body":"```java\r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0,y=0;\r\n        char[] c = moves.toCharArray();\r\n        for(char each:c){\r\n            if(each-'U' == 0){\r\n                y--;\r\n            }else if(each - 'D' == 0){\r\n                y++;\r\n            }else if(each - 'L' == 0){\r\n                x--;\r\n            }else if(each - 'R' == 0){\r\n                x++;\r\n            }\r\n        }\r\n\r\n        if(x == 0 && y ==0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336039582","body":"```java\r\nclass Solution {\r\n    public int[] getOrder(int[][] _tasks) {\r\n        int n = _tasks.length;\r\n        // 编号，进入时间，耗时\r\n        int[][] tasks = new int[n][3];\r\n        for (int i = 0; i < n; i++) {\r\n            tasks[i] = new int[]{i, _tasks[i][0], _tasks[i][1]};\r\n        }\r\n        Arrays.sort(tasks, (a, b) -> a[1] - b[1]);\r\n        // 耗时，编号\r\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            return a[1] - b[1];\r\n        });\r\n        int[] ans = new int[n];\r\n        for (int i = 0, cnt = 0, time = 1; cnt < n;) {\r\n            while (i < n && tasks[i][1] <= time) {\r\n                sortTasks.offer(new int[]{tasks[i][2], tasks[i][0]});\r\n                i++;\r\n            }\r\n            if (sortTasks.isEmpty()) {\r\n                time = tasks[i][1];\r\n                continue;\r\n            }\r\n            int[] cur = sortTasks.poll();\r\n            ans[cnt++] = cur[1];\r\n            time += cur[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336337977","body":"```java\r\nclass Solution {\r\n    public int numberOfRounds(String startTime, String finishTime) {\r\n        int shour = Integer.parseInt(startTime.substring(0, 2));\r\n        int smin = Integer.parseInt(startTime.substring(3));\r\n        int fhour = Integer.parseInt(finishTime.substring(0, 2));\r\n        int fmin = Integer.parseInt(finishTime.substring(3));\r\n\r\n        if (fhour == shour && fmin < smin) fhour += 24;\r\n        if (fhour < shour) fhour += 24;\r\n\r\n        smin = (smin + 14) / 15 * 15;\r\n        if (smin == 60) {\r\n            smin = 0;\r\n            shour++;\r\n        }\r\n\r\n        fmin = fmin / 15 * 15;\r\n\r\n        int total = (fhour - shour) * 60 + fmin - smin;\r\n        return total >= 0 ? total / 15 : 0;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336758324","body":"```python\r\nclass Solution:\r\n    def minCharacters(self, A: str, B: str) -> int:\r\n        ca = collections.Counter(A)\r\n        cb = collections.Counter(B)\r\n        # ca 中严格大于 cb 的最小操作数\r\n        def greater_cost(ca, cb):\r\n            ans = float(\"inf\")\r\n            # 枚举 ca 中的最小值\r\n            for i in range(1, 26):\r\n                count = 0\r\n                # 将 ca 中小于最小值的都进行一次操作\r\n                for j in range(i):\r\n                    count += ca[chr(97 + j)]\r\n                # 将 cb 中大于等于最小值的都进行一次操作（注意这里的等号）\r\n                for j in range(i, 26):\r\n                    count += cb[chr(97 + j)]\r\n                ans = min(ans, count)\r\n            return ans\r\n\r\n        def equal_cost(ca, cb):\r\n            ans = float(\"inf\")\r\n            for i in range(26):\r\n                ans = min(ans, len(A) + len(B) - ca[chr(97 + i)] - cb[chr(97 + i)])\r\n            return ans\r\n\r\n        return min(greater_cost(ca, cb), greater_cost(cb, ca), equal_cost(ca, cb))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338914372","body":"```python\r\nclass Solution:\r\n    def sortArray(self, N):\r\n        def quicksort(A, I, J):\r\n            if J - I <= 1: return\r\n            p = partition(A, I, J)\r\n            quicksort(A, I, p), quicksort(A, p + 1, J)\r\n        \r\n        def partition(A, I, J):\r\n            A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I\r\n            for j in range(I,J):\r\n                if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1\r\n            A[J-1], A[i] = A[i], A[J-1]\r\n            return i\r\n        \r\n        quicksort(N,0,len(N))\r\n        return N\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340489292","body":"```java\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int l = 0, r = x, ans = -1;\r\n        while (l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            if ((long) mid * mid <= x) {\r\n                ans = mid;\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342186402","body":"```java\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int l=1,r=n;\r\n        while(l<r){\r\n            int mid=l+(r-l)/2;\r\n            if(isBadVersion(mid))r=mid;\r\n            else{l=mid+1;}\r\n        }\r\n        return l;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343993233","body":"```java\r\nclass Solution(object):\r\n    def reversePairs(self, nums):\r\n        \"\"\"\r\n        :type nums: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        s = []\r\n        count = 0\r\n        for i in reversed(xrange(len(nums))):\r\n            count += bisect.bisect_left(s,nums[i])\r\n            bisect.insort_left(s,nums[i]*2)\r\n        return count\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345144439","body":"```python\r\nclass Solution:\r\n    def solve(self, nums):\r\n        nums.sort()\r\n        N = len(nums)\r\n        if N <= 3:\r\n            return 0\r\n        LIGHTS = 3\r\n        # 这里使用的是直径，因此最终返回需要除以 2\r\n        def possible(diameter):\r\n            start = nums[0]\r\n            end = start + diameter\r\n            for i in range(LIGHTS):\r\n                idx = bisect_right(nums, end)\r\n                if idx >= N:\r\n                    return True\r\n                start = nums[idx]\r\n                end = start + diameter\r\n            return False\r\n\r\n        l, r = 0, nums[-1] - nums[0]\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if possible(mid):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l / 2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345492604","body":"```JAVA\r\nclass Solution {\r\n    public int flipgame(int[] fronts, int[] backs) {\r\n        Set<Integer> set = new HashSet<>();\r\n        for(int i = 0; i < fronts.length; i++){\r\n            if(fronts[i] == backs[i]){\r\n                set.add(fronts[i]);\r\n            }\r\n        }\r\n        int res = Integer.MAX_VALUE;\r\n        for(int n : fronts){\r\n            if(!set.contains(n)){\r\n                res = Math.min(res, n);\r\n            }\r\n        }\r\n        for(int n : backs){\r\n            if(!set.contains(n)){\r\n                res = Math.min(res, n);\r\n            }\r\n        }\r\n        return res == Integer.MAX_VALUE ? 0 : res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346036230","body":"```java\r\nclass Solution {\r\n    private static final int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\r\n\r\n    public int swimInWater(int[][] grid) {\r\n        int n = grid.length;\r\n\r\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(i -> grid[i[0]][i[1]]));\r\n        minHeap.offer(new int[] {0, 0});\r\n\r\n        boolean[][] visited = new boolean[n][n];\r\n        int[][] dist = new int[n][n];\r\n        for (int[] row : dist)\r\n            Arrays.fill(row, n * n);\r\n\r\n        dist[0][0] = grid[0][0];\r\n\r\n        while (!minHeap.isEmpty()) {\r\n            int[] v = minHeap.poll();\r\n            int x = v[0];\r\n            int y = v[1];\r\n            if (visited[x][y]) continue;\r\n\r\n            visited[x][y] = true;\r\n            if (x == n - 1 && y == n - 1) return dist[n - 1][n - 1];\r\n\r\n            for (int[] dir : dirs) {\r\n                int row = x + dir[0];\r\n                int col = y + dir[1];\r\n                if (row >= 0 && row < n && col >= 0 && col < n\r\n                    && Math.max(dist[x][y], grid[row][col]) < dist[row][col]) {\r\n                    dist[row][col] = Math.max(dist[x][y], grid[row][col]);\r\n                    minHeap.offer(new int[] {row, col});\r\n                }\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347892716","body":"```java\r\nclass Solution {\r\n    public int maxVowels(String s, int k) {\r\n        int n = s.length();\r\n        int vowel_count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            vowel_count += isVowel(s.charAt(i));\r\n        }\r\n        int ans = vowel_count;\r\n        for (int i = k; i < n; ++i) {\r\n            vowel_count += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\r\n            ans = Math.max(ans, vowel_count);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' ? 1 : 0;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350584886","body":"```java\r\nclass Solution {\r\n    private double total=0;\r\n    private double below=0.0;\r\n    public double new21Game(int N, int K, int W) {\r\n\r\n        count(0 , N, K, W);\r\n        return below/total;\r\n    }\r\n    public void count(int temp , int N , int K , int W){\r\n        if(temp>=K){\r\n            total++;\r\n            if(temp<=N){\r\n                below++;\r\n            }\r\n            return;\r\n        }else{\r\n            for(int i=1 ; i<=W ; i++){\r\n                count(temp+i , N , K , W);\r\n            }\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352718515","body":"```java\r\npublic List<Integer> findAnagrams(String s, String p) {\r\n    int sLen = s.length();\r\n    int pLen = p.length();\r\n    List<Integer> res = new ArrayList<>();\r\n    int[] pCounts = new int[26];\r\n    for (int i = 0; i < pLen; i++) {\r\n        pCounts[p.charAt(i) - 'a']++;\r\n    }\r\n\r\n    int left = 0;\r\n    int right = 0;\r\n    while (right < sLen) \r\n        int inWin = s.charAt(right) - 'a'\r\n        pCounts[inWin]--;\r\n        while (pCounts[inWin] < 0) {\r\n            int outWin = s.charAt(left++) - 'a';\r\n            pCounts[outWin]++;\r\n        }\r\n\r\n        if (right - left + 1 == pLen) {\r\n            res.add(left);\r\n        }\r\n\r\n        right++;\r\n    }\r\n\r\n    return res;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1356086698","body":"```java\r\nclass Solution:\r\n    def minWindow(self, s: str, t: str) -> str:\r\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\r\n        k = 0\r\n        ret, ans = inf, \"\"\r\n        for r in range(N):\r\n            counter[s[r]] += 1\r\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\r\n                k += 1\r\n            while k == len(ct):\r\n                if r - l + 1 < ret:\r\n                    ans = s[l:r+1]\r\n                ret = min(r - l + 1, ret)\r\n                counter[s[l]] -= 1\r\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\r\n                    k -= 1\r\n                l += 1\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356087035","body":"```python\r\nclass Solution:\r\n    def solve(self, A, target):\r\n        if not A and not target: return 0\r\n        target = sum(A) - target\r\n        ans = len(A) + 1\r\n        i = t = 0\r\n\r\n        for j in range(len(A)):\r\n            t += A[j]\r\n            while i <= j and t > target:\r\n                t -= A[i]\r\n                i += 1\r\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\r\n        return -1 if ans == len(A) + 1 else ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356720974","body":"```java\r\nclass Solution {\r\n    public List<String> readBinaryWatch(int turnedOn) {\r\n        List<String> res = new ArrayList<>();\r\n        for (int i = 0; i < 12; i++) {\r\n            for (int j = 0; j < 60; j++) {\r\n                if (Integer.bitCount(i) + Integer.bitCount(j) == turnedOn) {\r\n                    StringBuilder sb = new StringBuilder();\r\n                    sb.append(i);\r\n                    sb.append(\":\");\r\n                    if (j < 10) sb.append(0);\r\n                    sb.append(j);\r\n                    res.add(sb.toString());\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357159120","body":"```java\r\npublic int totalNQueens(int n) {\r\n    List<Integer> ans = new ArrayList<>();\r\n    boolean[] cols = new boolean[n]; \r\n    boolean[] d1 = new boolean[2 * n]; \r\n    boolean[] d2 = new boolean[2 * n]; \r\n   return backtrack(0, cols, d1, d2, n, 0);\r\n}\r\n\r\nprivate int backtrack(int row, boolean[] cols, boolean[] d1, boolean[] d2, int n, int count) { \r\n    if (row == n) {\r\n        count++;\r\n    } else {\r\n        for (int col = 0; col < n; col++) {\r\n            int id1 = row - col + n; \r\n            int id2 = row + col;\r\n            if (cols[col] || d1[id1] || d2[id2])\r\n                continue;\r\n            cols[col] = true;\r\n            d1[id1] = true;\r\n            d2[id2] = true;\r\n            count = backtrack(row + 1, cols, d1, d2, n, count);\r\n            cols[col] = false;\r\n            d1[id1] = false;\r\n            d2[id2] = false;\r\n        }\r\n\r\n    }\r\n    return count;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358906814","body":"```java\r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        int rows = grid.length;\r\n        int cols = grid[0].length;\r\n        int maxArea = 0;\r\n\r\n        for (int i = 0; i < rows; i++)\r\n            for (int j = 0; j < cols; j++)\r\n                if (grid[i][j] == 1)\r\n                    maxArea = Math.max(maxArea, getArea(grid, i, j));\r\n\r\n        return maxArea;\r\n    }\r\n\r\n    private int getArea(int[][] grid, int x, int y) {\r\n        grid[x][y] = 0;\r\n        int area = 1;\r\n        \r\n        for (int[] dir : DIRS) {\r\n            int x1 = x + dir[0];\r\n            int y1 = y + dir[1];\r\n            \r\n            if (x1 >= 0 && x1 < grid.length && y1 >= 0 && y1 < grid[0].length\r\n                    && grid[x1][y1] == 1)\r\n                area += getArea(grid, x1, y1);\r\n        }\r\n        \r\n        return area;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361401489","body":"```java\r\nclass Solution {\r\n    static int[] dx = {-1, 0, 1, 0};\r\n    static int[] dy = {0, 1, 0, -1};\r\n    int n;\r\n    int[][] grid;\r\n\r\n    public int maxDistance(int[][] grid) {\r\n        this.n = grid.length;\r\n        this.grid = grid;\r\n        int ans = -1;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < n; ++j) {\r\n                if (grid[i][j] == 0) {\r\n                    ans = Math.max(ans, findNearestLand(i, j));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public int findNearestLand(int x, int y) {\r\n        boolean[][] vis = new boolean[n][n];\r\n        Queue<int[]> queue = new LinkedList<int[]>();\r\n        queue.offer(new int[]{x, y, 0});\r\n        vis[x][y] = true;\r\n        while (!queue.isEmpty()) {\r\n            int[] f = queue.poll();\r\n            for (int i = 0; i < 4; ++i) {\r\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\r\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\r\n                    continue;\r\n                }\r\n                if (!vis[nx][ny]) {\r\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\r\n                    vis[nx][ny] = true;\r\n                    if (grid[nx][ny] == 1) {\r\n                        return f[2] + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362641366","body":"```java\r\nclass Solution {\r\n\tpublic int findShortestCycleContainingTargetNode(List<List<Integer>> graph, int target) {\r\n\t\tint N = graph.size();\r\n\t\tQueue<Integer> q = new ArrayDeque<>();\r\n\t\tboolean[] visited = new boolean[N];\r\n\r\n\t\tq.offer(target);\r\n\t\tvisited[target] = true; \r\n\r\n\t\tint res = 0, step = 0;\r\n\t\twhile (!q.isEmpty()) {\r\n\t\t\tstep++;\r\n\t\t\tint sz = q.size();\r\n\t\t\tfor (int i = 0; i < sz; i++) {\r\n\t\t\t\tint cur = q.poll();\r\n\t\t\t\tfor (int next : graph.get(cur)) {\r\n\t\t\t\t\tif (!visited[next]) {\r\n\t\t\t\t\t\tq.offer(visited);\r\n\t\t\t\t\t\tvisited[next] = true;\r\n\t\t\t\t\t} else if (next == target) {\r\n\t\t\t\t\t\treturn step;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363668795","body":"```java\r\nclass Solution {\r\n    record Info(TreeNode node, int col, int row) {}\r\n    \r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        PriorityQueue<Info> pq = new PriorityQueue<>((a, b) \r\n                                                     -> a.col != b.col? \r\n                                                        a.col - b.col : a.row != b.row? \r\n                                                        a.row - b.row : a.node.val - b.node.val);\r\n        traverse(root, pq, 0, 0);\r\n        while (!pq.isEmpty()) {\r\n            List<Integer> tmp = new ArrayList<>();\r\n            Info cur = pq.poll();\r\n            tmp.add(cur.node.val);\r\n            int curCol = cur.col;\r\n            while (!pq.isEmpty() && pq.peek().col == curCol) {\r\n                tmp.add(pq.poll().node.val);\r\n            }\r\n            res.add(tmp);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    private void traverse(TreeNode cur, PriorityQueue<Info> pq, int col, int row) {\r\n        if (cur == null) return;\r\n        pq.offer(new Info(cur, col, row));\r\n        traverse(cur.left, pq, col - 1, row + 1);\r\n        traverse(cur.right, pq, col + 1, row + 1);\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364479870","body":"class Solution {\r\n    public int minCostClimbingStairs(int[] cost) {\r\n        int n = cost.length;\r\n        int[] dp = new int[n];//dp[n]代表爬到第n个台阶支付的最小费用\r\n        dp[0] = 0;//爬到第0个台阶花费0\r\n        dp[1] = 0;//爬到第一个台阶花费0\r\n        for(int i = 2 ; i < n ; i++){\r\n            dp[i] = Math.min( dp[i - 1] + cost[i - 1] , dp[i - 2] + cost[ i - 2]);\r\n        }\r\n        //爬到最后第一个台阶或最后第二个台阶，再详细对比\r\n        return Math.min(dp[ n - 1 ] + cost[n - 1] , dp[n - 2] + cost[n - 2] );\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364637127","body":"```java\r\nclass Solution {\r\n    public int rob(int[] nums) {\r\n        \r\n        int n = nums.length;\r\n        if(n == 1)return nums[0];\r\n\r\n        int[] dp = new int[n];//表示前i个房屋能偷到的最高金额\r\n        dp[0] = nums[0];\r\n        dp[1] = Math.max(nums[0] , nums[1]);\r\n        for(int i = 2 ; i < n ; i++){\r\n            dp[i] = Math.max( dp[ i-1 ]  ,dp[i - 2] + nums[i] );\r\n        }\r\n        return dp[n - 1];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365004347","body":"```java\r\nclass Solution {\r\n    public int findNumberOfLIS(int[] nums) {\r\n        int n = nums.length, maxLen = 0, ans = 0;\r\n        int[] dp = new int[n];\r\n        int[] cnt = new int[n];\r\n        for (int i = 0; i < n; ++i) {\r\n            dp[i] = 1;\r\n            cnt[i] = 1;\r\n            for (int j = 0; j < i; ++j) {\r\n                if (nums[i] > nums[j]) {\r\n                    if (dp[j] + 1 > dp[i]) {\r\n                        dp[i] = dp[j] + 1;\r\n                        cnt[i] = cnt[j]; // 重置计数\r\n                    } else if (dp[j] + 1 == dp[i]) {\r\n                        cnt[i] += cnt[j];\r\n                    }\r\n                }\r\n            }\r\n            if (dp[i] > maxLen) {\r\n                maxLen = dp[i];\r\n                ans = cnt[i]; // 重置计数\r\n            } else if (dp[i] == maxLen) {\r\n                ans += cnt[i];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365821756","body":"```JAVA\r\nclass Solution {\r\n    public int longestCommonSubsequence(String text1, String text2) {\r\n        int m = text1.length(), n = text2.length();\r\n        int[][] f = new int[m+1][n+1];\r\n        for (int i = 1; i <= m; i++) {\r\n            for (int j = 1; j <= n; j++) {\r\n                if (text1.charAt(i-1) == text2.charAt(j-1)) {\r\n                    f[i][j] = f[i-1][j-1] + 1;\r\n                } else {\r\n                    f[i][j] = Math.max(f[i-1][j], f[i][j-1]);\r\n                }\r\n            }\r\n        }\r\n        return f[m][n];\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366162807","body":"```java\r\nclass Solution {\r\n    public int uniquePaths(int m, int n) {\r\n        int[] pre = new int[n];\r\n        int[] cur = new int[n];\r\n        Arrays.fill(pre, 1);\r\n        Arrays.fill(cur,1);\r\n        for (int i = 1; i < m;i++){\r\n            for (int j = 1; j < n; j++){\r\n                cur[j] = cur[j-1] + pre[j];\r\n            }\r\n            pre = cur.clone();\r\n        }\r\n        return pre[n-1]; \r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367139711","body":"```java\r\nclass Solution {\r\n    public double knightProbability(int n, int k, int row, int column) {\r\n        int[][] dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {-1, -2}, {1, -2}, {-2, -1}};\r\n        double[][] lastStep = new double[n][n];\r\n        lastStep[row][column] = 1;\r\n\r\n        for (; k > 0; k--) {\r\n            double[][] currentStep = new double[n][n];\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < n; j++) {\r\n                    for (int[] dir : dirs) {\r\n                        int x = i + dir[0];\r\n                        int y = j + dir[1];\r\n                        if (x < 0 || x >= n || y < 0 || y >= n) continue;\r\n                        currentStep[x][y] += lastStep[i][j] / 8.0;\r\n                    }\r\n                }\r\n            }\r\n            lastStep = currentStep;\r\n        }\r\n\r\n        double res = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                res += lastStep[i][j];\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367831469","body":"```python\r\nclass Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        import functools\r\n        if  desiredTotal <= maxChoosableInteger: return True\r\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal: return False\r\n        \r\n        @functools.lru_cache(None)\r\n        def dfs(used, desiredTotal):\r\n            for i in range(maxChoosableInteger):\r\n                cur = 1 << i\r\n                if cur & used == 0:\r\n                    if desiredTotal <= i + 1 or not dfs(cur | used, desiredTotal - i - 1):\r\n                        return True\r\n            return False\r\n        \r\n        return dfs(0, desiredTotal)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368181554","body":"```java\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        int sum=0;\r\n        for(int x=0;x<nums.size();x++) sum+=nums[x];\r\n        vector<bool> f(sum+1);\r\n        if(sum%2!=0) return false;\r\n        sum/=2;\r\n        f[0]=1;\r\n       for(int x=0;x<nums.size();x++){\r\n            for(int j=sum;j>=nums[x];j--){\r\n                f[j]=f[j]|f[j-nums[i]];\r\n            }\r\n        }\r\n        \r\n    return f[sum];\r\n\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368398985","body":"```java\r\nclass Solution {\r\n    Map<String, Integer> memory = new HashMap<>();\r\n    public int findTargetSumWays(int[] nums, int target) {\r\n        return dfs(nums, target, 0, 0);\r\n    }   \r\n    public int dfs(int[] nums, int target, int sum, int index) {\r\n        String key = index + \"-\" + sum;\r\n        if (memory.containsKey(key)) return memory.get(key);\r\n        if (index == nums.length) {\r\n            memory.put(key, sum == target ? 1 : 0);\r\n            return memory.get(key);\r\n        }\r\n        int ans = dfs(nums, target, sum + nums[index], index + 1) + dfs(nums, target, sum - nums[index], index + 1);\r\n        memory.put(key, ans);\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368619258","body":"```python\r\nclass Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        f = [inf] * (amount + 1)\r\n        f[0] = 0\r\n        for i, v in enumerate(coins):\r\n            for j in range(v, amount + 1):\r\n                f[j] = min(f[j], f[j - v] + 1)\r\n        \r\n        return f[-1] if f[-1] != inf else -1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369443729","body":"```java\r\nclass Solution {\r\n    public int change(int amount, int[] coins) {\r\n        int[] dp = new int[amount + 1];\r\n        dp[0] = 1;\r\n        for (int coin : coins) {\r\n            for (int i = coin; i <= amount; i++) {\r\n                if (i - coin >= 0) {\r\n                    dp[i] += dp[i - coin];\r\n                }\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1371100798","body":"```java\r\nclass Solution {\r\n    public int findContentChildren(int[] g, int[] s) {\r\n        int res = 0;\r\n        Arrays.sort(g);\r\n        Arrays.sort(s);\r\n        int i = 0, j = 0;\r\n        while (i < g.length && j < s.length) {\r\n            if (g[i] <= s[j]) {\r\n                res++;\r\n                i++;\r\n                j++;\r\n            } else if (g[i] > s[j]) {\r\n                j++;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371866287","body":"```java\r\nclass Solution: #time: O(NlogN) :: sort space:O(1)\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        real_end, cnt = float('-inf'), 0\r\n        for srt, end in sorted(intervals, key=lambda x: x[1]):\r\n            if srt >= real_end: \r\n                real_end = end\r\n            else: \r\n                cnt += 1\r\n        return cnt\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374748913","body":"```java\r\nclass Solution {\r\n    public int numTrees(int n) {\r\n        // use a memo array to save previously calculated results\r\n        int[] trees = new int[n + 1];\r\n        // base case：there is only one unique tree for a tree with no node\r\n        trees[0] = 1;\r\n        // fill in the memo array\r\n        for (int i = 1; i <= n; i++) {\r\n            // calculate the number of non-root nodes\r\n            int nonroot = i - 1;\r\n            // divide these non-root nodes into two BST, \r\n            // one with j nodes, one with k = nonroot - j nodes\r\n            for (int j = 0; j <= nonroot / 2; j++) {\r\n                int k = nonroot - j;\r\n                // k == j, number of nodes in left tree is equal to \r\n                // the number of nodes in right tree, we cannot swap left and right trees\r\n                // use multification rule to calculate total number of different trees\r\n                // then use addition rule to add them up\r\n                if (k == j) trees[i] += trees[k] * trees[j];\r\n                // k != j, we can swap left and right trees, so times 2\r\n                else trees[i] += 2 * trees[k] * trees[j];\r\n            }\r\n        }\r\n        return trees[n];\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374748725","body":"```java\r\n    public ListNode mergeKLists(ListNode[] lists) {\r\n        PriorityQueue<ListNode> q = new PriorityQueue<>((a, b) -> a.val - b.val);\r\n        ListNode res = new ListNode();\r\n        ListNode cur = res;\r\n\r\n        for(ListNode listNode : lists){\r\n            if(listNode != null){\r\n                q.offer(listNode);\r\n            }\r\n        }\r\n\r\n        while(!q.isEmpty()){\r\n            ListNode tmp = q.poll();\r\n            cur.next = tmp;\r\n            cur = cur.next;\r\n            if(tmp.next != null){\r\n                q.offer(tmp.next);\r\n            }\r\n        }\r\n\r\n        return res.next;\r\n    }\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376880864","body":"```java\r\nclass Solution {\r\n    public int[] singleNumber(int[] nums) {\r\n        int xorsum = 0;\r\n        for (int x : nums)\r\n            xorsum ^= x;\r\n        int lsb = (xorsum == Integer.MIN_VALUE? xorsum : xorsum & (-xorsum));\r\n        int type1 = 0, type2 = 0;\r\n        for (int x : nums) {\r\n            if ((x & lsb) != 0)\r\n                type1 ^= x;\r\n            else\r\n                type2 ^= x;\r\n        }\r\n        return new int[] {type1, type2};\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297858805","body":"### 思路\n&ensp;&ensp;&ensp;&ensp;模拟竖式的加法, 得到每个数组的最低位, 从最低位开始加\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> a, b;\n        for (int i = num.size() - 1; i >= 0; i--) a.push_back(num[i]);\n        while (k != 0) {\n            b.push_back(k % 10);\n            k /= 10;\n        }\n        vector<int> temp;\n        int t = 0;\n        for (int i = 0; i < a.size() || i < b.size(); i++) {\n            if (i < a.size()) t += a[i];\n            if (i < b.size()) t += b[i];\n            temp.push_back(t % 10);\n            t /= 10;\n        }\n        if (t) temp.push_back(1);\n        vector<int> ans;\n        for (int i = temp.size() - 1; i >= 0; i--) ans.push_back(temp[i]);\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299666978","body":"### [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n### 思路 1 两次遍历\r\n\r\n* 第一次遍历记录满足条件字符下标 `k` : \r\n  - 1.  满足条件, 更新左边界 `k`\r\n  - 2.  不满足条件 , 直接填入 `k` (左边满足条件的下标 or 左边不存在满足的下标)  \r\n\r\n  此时 `k` 停留在最后一个满足条件的位置 (题目数据保证 `c` 在 `s` 中至少出现一次)\r\n\r\n* 第二次遍历时记录右边满足条件的下标 :\r\n  - 1. 满足条件, 更新右边界 `k`\r\n  - 2. 不满足条件, 填入 ___当前下标 `i` 和左边界的距离 `i - ans[i]`___  和  ___右边界 `k` 的距离 `i - k`___ 的最小值\r\n    - 当 `k` 被更新后, `i`继续向左移动 , 会造成 `i - k` 为负值, 所以需要加上绝对值\r\n    - 若使用 `k - i` , 当 `k` 没有停留在 `s.size() - 1` , 依旧有可能 `k - i < 0`, 故仍需要绝对值\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n, -1);\r\n        int k = -n;\r\n        // get the left distance\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = k;\r\n        }\r\n        // get the right distance then compare with left distance \r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = min(i - ans[i], abs(i - k));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(2N) -> O(N)\r\n- 空间复杂度：O(N)\r\n\r\n-------\r\n\r\n### 思路 2 一次遍历\r\n\r\n* 对思路 1 的优化\r\n  - `l` 为左边界 , `r` 为右边界\r\n  - `i` 从头遍历数组 , `j` 从尾遍历数组\r\n  - 遇到满足条件的情况分别更新 `l` , `r` \r\n  - 若 `i >= l` 说明当前下标左边有符合条件的 `c` ; 同理 , `j <= r` 则右边有\r\n  - 取最小值min\r\n  - 由于 `i` , `j` 指针相遇后仍继续移动 , 可以做到不遗漏\r\n\r\n\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(), INT_MAX);\r\n        int l = s.size(), r = -1, n = s.size();\r\n        for (int i = 0; i < s.size(); i++) {\r\n            int j = n - 1 - i;\r\n            if (s[i] == c) l = i;\r\n            if (s[j] == c) r = j;\r\n            if (i >= l) ans[i] = min(ans[i], i - l);\r\n            if (j <= r) ans[j] = min(ans[j], r - j);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301572039","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\n### 思路\n模拟题, 用 vector 模拟栈, `size` 表示当前栈大小  \n需要注意的是, `increment(int k, int val)` 的 `k` 可能超过 `size`\n### 代码 (cpp)\n```cpp\nclass CustomStack {\n\npublic:\n    int size = 0, max = 0;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (size < max) {\n            stack.push_back(x);\n            size++;\n        }\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        size = size - 1;\n        int ret = stack[size];\n        stack.pop_back();\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; i++) {\n            stack[i] += val;\n        }\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302928618","body":"### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)\n### 思路 1: 双栈\n* 使用 `num` 栈记录重复次数 ; `str` 栈记录要重复的字符 ; \n* `n` 为当前数字, `ans` 为解码后的字符\n  - 当 `c >= '0' && c <= '9'` 时 , 更新数字 `n`\n  - 当 `c == 'a' && c <= 'z'` 时, 更新 `ans`\n  - 当 `c == '['` 时, 为了保留当前信息, 处理`[`后信息, 故将 `num` 压入当前数字, `n` 置为 0 ; `str` 压入当前字符, `ans = \"\"`\n  - 当 `c == ']'` 时, `ans` 已经为最近的`[`和当前`]`内的字符, 得到重复次数 `t = num.top()`, \n  将当前字符按照 `t` 添加到外层字符 `str.top()` 后, 完成了部分解码, 更新 `ans`, 将栈内元素弹出\n  \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> num;\n        int n = 0;\n        stack<string> str;\n        string ans = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                num.push(n);\n                n = 0;\n                str.push(ans);\n                ans = \"\";\n            } else if (c == ']') {\n                int t = num.top();\n                num.pop();\n                for (int i = 0; i < t; i++) {\n                    str.top() += ans;\n                }\n                ans = str.top();\n                str.pop();\n            } else {\n                ans += c;\n            }\n        }\n        return ans;\n    }\n\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n---\n\n### 思路 2: 栈 + 递归\n\n* 仅遇到`[`和`]`时和思路 1 不同  \n    - 当 `c == '['` 时, 递归处理后续字符, 得到返回值 `sub`, 按次数添加`sub`, `n`置为0\n    - 当 `c == ']'` 时, 说明此级别的 `'[]'`内字符已处理完\n\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string helper(stack<char> &stack) {\n        int n = 0;\n        string ret = \"\";\n        while (!stack.empty()) {\n            char c = stack.top();\n            stack.pop();\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                string sub = helper(stack);\n                for (int i = 0; i < n; i++) {\n                    ret += sub;\n                }\n                n = 0;\n            } else if (c == ']'){\n                break;\n            } else {\n                ret += c;\n            }\n        }\n        return ret;\n    }\n    \n    string decodeString(string s) {\n        stack<char> stack;\n        for (int i = s.size() - 1; i >= 0; i--)\n            stack.push(s[i]);\n        string ret = helper(stack);\n        return ret;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304377408","body":"### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/submissions/)\n### 思路\n使用两个栈模拟队列\n### 代码 (cpp)\n```cpp\nclass MyQueue {\npublic:\n    stack<int> input;\n    stack<int> output;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n            output.pop();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n            output.pop();\n        }\n        return ret;\n    }\n    \n    int peek() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n        }\n        return ret;\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734017","body":"### [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n### 思路\n先将原数组复制且排序得到`clone`, 比较`arr`和`clone`, 如果在`[0,i]`范围内, 出现的数字频率一致, 那么就有1种分法\n* 使用哈希表对`arr[i]`进行计数:   \n    - 处理`arr[i]`时, 对`map[arr[i]]`进行计数加一\n    - 处理`clone[i]`时, 对`map[clone[i]]`进行计数减一\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // 已经排序的数组\n        vector<int> clone = arr;\n        sort(clone.begin(), clone.end());\n        \n        int ans = 0, window = 0;\n        // 使用哈希表进行计数\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < arr.size(); i++) {\n            map[arr[i]]++;\n            if (map[arr[i]] == 0) window--;\n            else if (map[arr[i]] == 1) window++;\n\n            map[clone[i]]--;\n            if (map[clone[i]] == 0) window--;\n            else if (map[clone[i]] == -1) window++;\n\n            if (window == 0) ans++;\n        }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304996119","body":"### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n### 思路\n* 遍历两次\n  - 第一次遍历得到链表长度`size`并构成环形链表\n  - 第二次得到`size - k - 1`个结点, 在此处将链表断开即可\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == NULL || head->next == NULL) {\n            return head;\n        }\n        \n        int size = 1;\n        ListNode* cur = head;\n        while (cur->next != NULL) {\n            cur = cur->next;\n            size++;\n        }\n        cur->next = head;\n\n        k %= size;\n        for (int i = size - k - 1; i > 0; i--) {\n            head = head->next;\n        }\n\n        cur = head->next;\n        head->next = NULL;\n\n        return cur;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306710782","body":"### [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n### 思路 1: 迭代\n#### 添加傀儡节点`dummy`后不用考虑边界问题\n* 两两反转节点需要四个指针在手里\n  1. a : 局部头节点 (用于连接反转后的头)\n  2. b : 反转的第一个节点\n  3. c : 反转的第二个节点\n  4. d : 局部尾节点 (被反转后的尾连接)\n* 步骤 :\n  1. a 指向 c ( c 为反转后的头) \n  2. c 指向 b (反转)\n  3. b 指向 d ( b 为反转后的尾)\n  4. 更新 a 为 b ( 下一步的局部头节点) ; 更新 b 为 `a->next`\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* dummy = new ListNode(-1);\n        dummy->next = head;\n        ListNode *a = dummy, *b = head;\n        while (b != nullptr && b->next != nullptr) {\n            ListNode* c = b->next;\n            ListNode* d = c->next;\n            a->next = c;\n            c->next = b;\n            b->next = d;\n            a = b;\n            b = a->next;\n        }\n\n        return dummy->next;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n-----\n### 思路 2: 递归\n* 递归三部曲:\n  1. 终止条件 : 当前节点或下一节点为空\n  2. 返回值 : 反转后的部分头节点\n  3. 本层处理问题 : 两两反转节点\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) {\n            return head;\n        }\n\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        \n        return next;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308969710","body":"### [109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)\n### 思路 双指针\n由于链表有序, 只要找到了中间节点, 就得到了二叉搜索树的根节点, 如此再递归处理左右的链表  \n* 递归三部曲:\n    1. 终止条件 : 当前节点或下一节点为空\n    2. 返回值 : 构造出的树的根节点\n    3. 本层处理问题 : 找到当前要处理的链表的中间节点, 链表左边为树的左分支, 右边为右分支  \n\n**注意事项 :** 一定要记得将找到的中间节点和原链表断开\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        TreeNode *root;\n        if (head == nullptr) return nullptr;\n        else if (head->next == nullptr) {\n            root = new TreeNode(head->val);\n            return root;\n        }\n\n        ListNode *fast = head, *slow = head, *pre = head;\n        // 让 slow 指向中间节点\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n\n        while (pre->next != slow) pre = pre->next;\n        root = new TreeNode(slow->val);\n        pre->next = nullptr; // 从中间断开链表, 防止递归时链表长度不变\n        // 递归处理\n        root->left = sortedListToBST(head);\n        root->right = sortedListToBST(slow->next);\n\n        return root;\n\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(logn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309019670","body":"### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n### 思路 双指针\n每次移动步长为 1, 只要当一条链表走到尾就从另一条的链表头开始走  \n如此, 两指针行走的路程相同, 在速度相同的情况下, 两指针一定会相遇\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        if (!headA || !headB) return nullptr;\n        ListNode *a = headA, *b = headB;\n        while (a != b) {\n            a = a == nullptr ? headB : a->next;\n            b = b == nullptr ? headA : b->next;\n        }\n        return a;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311242253","body":"### [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n### 思路 快慢指针\n令快指针`fast`步长为2, 慢指针`slow`步长为1  \n假设链表有环, 记链表头到开始入环的第一个节点之前的节点路程为`x`, 整个环路长度为`cycle`, 快慢指针相遇点 到 入环的第一个节点的路程为`y`  \n由于`fast`速度是`slow`两倍, 就有式子`2 * (x + cycle -y) = x + n * cycle - y`  \n化简得`x = (n - 2) * cycle + y` 由于`cycle`是环路长度, 可以忽略, 得到`x = y`  \n即相遇后慢指针`slow`从头出发, 快指针`fast`在相遇点出发, 步长都为1, 会再次在入环点相遇\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head, *fast = head;\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n            if (fast == slow) break;\n        }\n\n        if (fast == nullptr || fast->next == nullptr) return nullptr;\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312353230","body":"### [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/description/)\n### 思路\n用`list`来维护关键字的新旧, `map`来记录关键字的键值对  \n#### 小技巧: 由于put时也会对元素新旧产生影响, 可以在put时调用get\n### 代码 (Java)  \n```java\nclass LRUCache {\n\n    private HashMap<Integer, Integer> map;\n    private ArrayList<Integer> list;\n    private int max;\n\n    public LRUCache(int capacity) {\n        max = capacity;\n        map = new HashMap<>();\n        list = new ArrayList<>();\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            for (int i = 0; i < list.size(); i++) {\n                if (list.get(i) == key) {\n                    list.remove(i);\n                    list.add(key);\n                    break;\n                }\n            }\n            return map.get(key);\n        }\n        else return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (this.get(key) == -1) {\n            if (list.size() == max) {\n                int rm = list.get(0);\n                list.remove(0);\n                map.remove(rm);\n            }\n            list.add(key);\n        }\n        \n        map.put(key, value);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312634905","body":"### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) return 0;\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313638573","body":"### [100. 相同的树](https://leetcode.cn/problems/same-tree/)\n### 思路\nDFS\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        else if (p == nullptr || q == nullptr) return false;\n        else if (p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(min(m,n)) (m, n为树的节点数)\n- 空间复杂度：O(min(m,n))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314032294","body":"### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)\n### 思路 DFS\n* 递归三部曲:\n    1. 终止条件 : 已经到达叶子节点 (左右子树为空)\n    2. 返回值 : 本题不用返回, 全局变量`ans`加上当前`cur`即可\n    3. 本层处理问题 : 更新`cur`(cur * 10 + 左/右子树的值)\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int ans;\n    void help(TreeNode *root, int cur) {\n        if (root->left == nullptr && root->right == nullptr) {\n            ans += cur;\n        } else {\n            if (root->left != nullptr)\n                help(root->left, cur * 10 + root->left->val);\n            if (root->right != nullptr)\n                help(root->right, cur * 10 + root->right->val);\n        }\n\n    }\n    int sumNumbers(TreeNode* root) {\n        if (root == nullptr) return 0;\n\n        help(root, root->val);\n\n        return ans;\n    }\n        \n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(height)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316281368","body":"### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)\n### 思路\n层序遍历, 返回最后一层的第一个元素即可\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> queue;\n        vector<int> list;\n        queue.push(root);\n        while (!queue.empty()) {\n            list.clear();\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                auto cur = queue.front();\n                queue.pop();\n                list.push_back(cur->val);\n                if (cur->left) queue.push(cur->left);\n                if (cur->right) queue.push(cur->right);\n            }\n        }\n        return list[0];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318540980","body":"### [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)\n### 思路 DFS\n* 序列化: 通过前序遍历构造字符串  \n    - 节点为空, 追加 `\"null,\"`\n    - 节点不为空, 追加 `to_string(root->val) + \",\"` // (`\",\"`别忘)  \n* 反序列化: 由于序列化是前序遍历, 反序列化也要前序遍历  \n通过`stringstream`来过滤序列化的分隔符, 使用队列`queue`来存取值  \n#### 本次增长的知识:\n- 熟悉cpp中`stringstream`的使用\n- 字符串和整型之间的转化通过方法`to_string()`和`stoi()`\n### 代码 (cpp)\n```cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if (!root) return \"null,\";\n        string ret = to_string(root->val) + \",\";\n        ret += serialize(root->left);\n        ret += serialize(root->right);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream ss(data);\n        string temp;\n        queue<string> queue;\n        while (getline(ss, temp, ',')) {\n            queue.push(temp);\n        }\n        return pre(queue);\n    }\n\n    TreeNode* pre(queue<string> &queue) {\n        string val = queue.front();\n        queue.pop();\n        if (val == \"null\") return nullptr;\n\n        auto root = new TreeNode(stoi(val));\n        root->left = pre(queue);\n        root->right = pre(queue);\n        return root;\n    }\n\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320208785","body":"### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)\n### 思路 \nDFS\n#### 本次增长的知识:  \n`multiset`的使用, `pair`的使用\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void dfs(TreeNode* root, int x, int y, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        dfs(root->left, x + 1, y - 1, mp);\n        dfs(root->right, x + 1, y + 1, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        dfs(root, 0, 0, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320910037","body":"### [1. 两数之和](https://leetcode.cn/problems/two-sum/)\n### 思路\nhash表, 键值对中键为`nums[i]`, 值为`i`, 如果`target - nums[i]`存在就返回 \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> mp;\n        for (int i = 0; i < nums.size(); i++) {\n            auto iter = mp.find(target - nums[i]);\n            if (iter != mp.end()) {\n                return {iter->second, i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162148","body":"### [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)\n### 思路\n1. 用hashmap记录每个数出现的次数  \n2. 创建大小为k的小根堆, 遍历hashmap, 如果`mp[key]` 大于堆顶元素, 则弹出\n#### 需要的知识:\n小根堆 + 哈希表\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        for (int elem : nums) mp[elem]++;\n\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        for (auto &[a, b] : mp) {\n            if (q.size() < k) {\n                q.push(make_pair(b, a));\n            } else {\n                if (b > q.top().first) {\n                    q.pop();\n                    q.push(make_pair(b, a));\n                }\n            }\n        }\n\n        vector<int> ans;\n        while (q.size()) {\n            ans.push_back(q.top().second);\n            q.pop();\n        }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlongk)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322250501","body":"### [447. 回旋镖的数量](https://leetcode.cn/problems/number-of-boomerangs/)\n### 思路\n题目只要求回旋镖的数量, 其实就是求三元组`(i, j, k)`中, 与`i`距离相等的`(j, k)`组合个数为多少  \n通过hashmap, 求出其他点和当前点的距离, 以`{distance, count}`存储  \n因为排列个数为 A(n, 2) ,所以`ans += cnt * (cnt - 1);`\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> mp;\n            for (int j = 0; j < points.size(); j++) {\n                if (j == i) continue;\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n                int dist = x * x + y * y;\n                mp[dist]++;\n            }\n            for (auto [dist, cnt] : mp) {\n                ans += cnt * (cnt - 1);\n            }\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323863438","body":"### [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)\n### 思路 滑动窗口\n用hashmap记录字符出现的次数  \n右指针不断移动, 如果右指针出现重复字符, 左指针移动, 减小窗口并减少对应字符出现次数\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int ans = 0;\n        unordered_map<char, int> mp;\n        for (int l = 0, r = 0; r < s.size(); r++) {\n            char right = s[r];\n            mp[right]++;\n            char left = s[l];\n            while (mp[right] > 1) {\n                mp[left]--;\n                left = s[++l];\n            }\n            ans = max(ans, r - l + 1);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325298086","body":"### [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/)\n### 思路\n滑动窗口 + 哈希表\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        unordered_map<string, int> search;\n        for (auto &word : words) ++search[word];\n        int n = s.size(), m = words.size(), len = words[0].size();\n        for (int i = 0, j = 0; i < n - m * len + 1; ++i) {\n            unordered_map<string, int> sub; \n            for (j = 0; j < m; ++j) {\n                auto word = s.substr(i + j * len, len);\n                if (!search.count(word)) break; \n                if (++sub[word] > search[word]) break;\n            }\n            if (j == m) res.push_back(i);\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326628158","body":"### [974. 和可被 K 整除的子数组](https://leetcode.cn/problems/subarray-sums-divisible-by-k/)\n### 思路\n这一题使用前缀和暴力会超时, 故考虑更好的方法: 前缀和 + 同余定理\n同余定理 : 如果两个数的差能被K整除，就说明这两个数 mod K得到的结果相同\n如果有n个数 mod K 的余数相同, 那么有C(n, 2)个数可以被 K 整除\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int ans = 0, sum = 0, n = nums.size();\n        unordered_map<int, int> mp;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int mod = sum >= 0 ? sum % k : (k - (-sum) % k) % k;\n            mp[mod]++;\n        }\n        \n        for (auto &[k, v] : mp) \n            if (!k) ans += v;\n            else ans += v * (v - 1) / 2;\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327612231","body":"### [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)\n### 思路\n快慢指针\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        auto fast = head, slow = head;\n        int step = 0;\n        while (fast) {\n            if (step % 2 == 1) slow = slow->next;\n            fast = fast->next;\n            step++;\n        }\n        return slow;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328049704","body":"### [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)\n### 思路\n双指针  \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        if (nums.empty()) return 0;\n        if (nums.size() == 1) return 1;\n        int len = nums.size();\n        int i = 0, j = 1, n = nums.size();\n        while (j < n) {\n            if (nums[i] == nums[j]) {\n                while (j < n && nums[j] == nums[i]) j++;\n                len = len - j + i + 1;\n            }\n            if (j < n) nums[++i] = nums[j++];\n        }\n        return i + 1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328237383","body":"### [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)\n### 思路\n二分\n### 代码 (cpp)\n模板1\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (nums[mid] >= target) r = mid;\n            else l = mid + 1;\n        }\n        return nums[l] >= target ? l : l + 1;\n    }\n};\n```\n模板2\n```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n        while (l < r) {\n            int mid = (l + r + 1) >> 1;\n            if (nums[mid] <= target) l = mid;\n            else r = mid - 1;\n        }\n        return nums[l] >= target ? l : l + 1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329331895","body":"### [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)\n### 思路\n维护一个单调队列, 每次滑动窗口时添加队头元素\n### 代码 (cpp)\n```cpp\nclass Solution {\nprivate:\n    class MyQueue {\n    public:\n        deque<int> q; \n        void pop(int value) {\n            if (!q.empty() && value == q.front()) {\n                q.pop_front();\n            }\n        }\n       \n        void push(int value) {\n            while (!q.empty() && value > q.back()) {\n                q.pop_back();\n            }\n            q.push_back(value);\n\n        }\n        \n        int front() {\n            return q.front();\n        }\n    };\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        MyQueue q;\n        vector<int> result;\n        for (int i = 0; i < k; i++) {\n            q.push(nums[i]);\n        }\n        result.push_back(q.front()); \n        for (int i = k; i < nums.size(); i++) {\n            q.pop(nums[i - k]); \n            q.push(nums[i]); \n            result.push_back(q.front());\n        }\n        return result;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330467524","body":"### [997. 找到小镇的法官](https://leetcode.cn/problems/find-the-town-judge/description/)\n### 思路\n考点为图, 成员为出度, 被相信的人为入度, 寻找入度为`n - 1`的人, 即为法官\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int a[1001];\n    int findJudge(int n, vector<vector<int>>& trust) {\n        for (vector<int> t : trust) {\n            a[t[0]]--;\n            a[t[1]]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (a[i] == n - 1) return i;\n        }\n        return -1;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332386307","body":"### [886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/description/)\r\n### 思路\r\n#### 方法1 : 反向点 + 并查集  \r\n- 反向点的建立: 对于集合`A`中每个点`x`, 建立反向点`x + n`, 如此反向点在另一集合`B`中\r\n- 每次取`dislikes[i]`中点`(a,b)`,将`(a, b + n)`和`(b, a + n)`联通\r\n- 如果`A`中的点`(a,b)`联通, 必然是通过反向点的连接,无法将所有点分为两类\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int p[4010];\r\n    int find(int x) {\r\n        if (p[x] != x) p[x] = find(p[x]);\r\n        return p[x];\r\n    }\r\n\r\n    void union_(int i, int j) {\r\n        p[find(i)] = p[find(j)];\r\n    }\r\n\r\n    bool connected(int i, int j) {\r\n        return find(i) == find(j);\r\n    }\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        for (int i = 1; i <= 2 * n; i++) p[i] = i;\r\n        for (vector<int> dis : dislikes) {\r\n            int a = dis[0], b = dis[1];\r\n            if (connected(a, b)) return false;\r\n            union_(a, b + n);\r\n            union_(b, a + n);\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n + m) (m为dislikes的长度)\r\n- 空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333969295","body":"### [1203. 项目管理](https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/)\n#### 思路\n拓扑排序\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> topSort(vector<int> &deg, vector<vector<int>> &graph, vector<int> &items) {\n        queue<int> q;\n        for (auto item : items) {\n            if (deg[item] == 0) q.push(item);\n        }\n        vector<int> ret;\n        while (!q.empty()) {\n            int u = q.front();\n            q.pop();\n            ret.push_back(u);\n            for (auto &v : graph[u]) {\n                if (--deg[v] == 0) q.push(v);\n            }\n        }\n        return ret.size() == items.size() ? ret : vector<int> {};\n    }\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n\n        vector<int> id;\n        for (int i = 0; i < n + m; i++) {\n            id.push_back(i);\n        }\n\n        int leftId = m;\n        for (int i = 0; i < n; i++) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].push_back(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].push_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].push_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            //按组的topo序逐个进行内部排序\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.push_back(item);\n            }\n        }\n        return ans;\n\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(m + n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335408682","body":"### [657. 机器人能否返回原点](https://leetcode.cn/problems/robot-return-to-origin/description/)\n#### 思路\n模拟题\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (char c : moves) {\n            if (c == 'U') y += 1;\n            else if (c == 'D') y -= 1;\n            else if (c == 'L') x -= 1;\n            else if (c == 'R') x += 1;\n        }\n        return x == 0 && y == 0;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336187518","body":"### [1834. 单线程 CPU](https://leetcode.cn/problems/single-threaded-cpu/description/)\n#### 思路\n小根堆\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size(), ptr = 0;\n        vector<int> res;\n        vector<int> idx(n);\n        iota(idx.begin(), idx.end(), 0);\n        sort(idx.begin(), idx.end(), [&](int i, int j){return tasks[i][0] < tasks[j][0];});\n        long long t = 0;\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        while(res.size() < n) {\n            if(q.size()) {\n                auto cur = q.top();\n                q.pop();\n                t += cur.first;\n                res.push_back(cur.second);\n                while(ptr < n && tasks[idx[ptr]][0] <= t) {\n                    q.push({tasks[idx[ptr]][1],idx[ptr]});\n                    ptr ++ ;\n                }\n            } else {\n                t = tasks[idx[ptr]][0];\n                while(ptr < n && tasks[idx[ptr]][0] <= t) {\n                    q.push({tasks[idx[ptr]][1],idx[ptr]});\n                    ptr ++ ;\n                }\n            }\n        }\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336448792","body":"### [1904. 你完成的完整对局数](https://leetcode.cn/problems/the-number-of-full-rounds-you-have-played/description/)\n#### 思路\n将时间转换为分钟进行计算\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int t1 = stoi(loginTime.substr(0, 2)) * 60 + stoi(loginTime.substr(3, 5));\n        int t2 = stoi(logoutTime.substr(0, 2)) * 60 + stoi(logoutTime.substr(3, 5));\n        if (t1 > t2) t2 += 24 * 60;\n        t2 = t2 / 15 * 15;\n        return (t2 - t1) / 15;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337613570","body":"```cpp\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int n = a.size(), m = b.size();\n        int cnta[26] = {0}, cntb[26] = {0};\n        \n        for(char c : a){\n            cnta[c - 'a']++;\n        }\n        for(char c : b){\n            cntb[c - 'a']++;\n        }\n        \n        int ans = n + m - cnta[0] - cntb[0];\n        for(int i = 1, suma = 0, sumb = 0; i < 26; ++i){\n            suma += cnta[i - 1], sumb += cntb[i - 1];\n            int resA = suma + m - sumb;\n            int resB = sumb + n - suma;\n            ans = min({ans, resA, resB, n + m - cnta[i] - cntb[i]});\n        }\n        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339089212","body":"#### 思路\n快速排序\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n\n    void quick_sort(vector<int>& q, int l, int r) {\n        if (l >= r) return;\n        int x = q[(l + r) >> 1], i = l - 1, j = r + 1;\n        while (i < j) {\n            do i++; while (q[i] < x);\n            do j--; while (q[j] > x);\n            if (i < j) swap(q[i], q[j]);\n        }\n        quick_sort(q, l, j);\n        quick_sort(q, j + 1, r);\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        quick_sort(nums, 0, nums.size() - 1);\n        return nums;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341169837","body":"#### 思路\n二分\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x <= 1) return x;\n        int l = 0, r = x;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (mid > x / mid) r = mid;\n            else l = mid + 1;\n        }\n        return l - 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342924173","body":"#### 思路\n二分\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        long l = 1, r = n;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (isBadVersion(mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344456996","body":"### [493. 翻转对](https://leetcode.cn/problems/reverse-pairs/description/)\n#### 思路\n归并排序变题\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int find_reversed_pairs(vector<int>& nums,int& left,int& right){\n        int res = 0,mid = left + (right-left)/2;\n        int i = left,j = mid+1;\n        for(;i <= mid;i++){\n            while(j <= right && (long)nums[i] > 2*(long)nums[j]) {\n                res += mid - i + 1;\n                j++;\n            }\n        }\n        return res;\n    }\n    \n    int merge_sort(vector<int>& nums,int nums_sorted[],int left,int right){\n        if(left >= right) return 0;\n        int mid = left + (right-left) / 2;\n        \n        int res = merge_sort(nums,nums_sorted,left,mid) + \n                  merge_sort(nums,nums_sorted,mid+1,right) + \n                  find_reversed_pairs(nums,left,right);\n        \n        int i = left,j = mid+1,ind = left;\n        \n        while(i <= mid && j <= right){\n            if(nums[i] <= nums[j]) nums_sorted[ind++] = nums[i++];\n            else nums_sorted[ind++] = nums[j++];\n        }\n        while(i <= mid) nums_sorted[ind++] = nums[i++];\n        while(j <= right) nums_sorted[ind++] = nums[j++];\n        \n        for(int ind = left; ind <= right; ind++) nums[ind] = nums_sorted[ind];\n    \n        return res;\n    }\n    \n    int reversePairs(vector<int>& nums) {\n        if(nums.empty()) return 0;\n        int nums_sorted[nums.size()];\n        memset(nums_sorted,0,sizeof(nums_sorted));\n        return merge_sort(nums,nums_sorted,0,nums.size()-1);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345289973","body":"```cpp\nclass Solution {\npublic:\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        sort(houses.begin(),houses.end());\n        sort(heaters.begin(),heaters.end());\n        int ans = 0;\n        int h = 0;\n        for(int i=0;i<houses.size();i++){\n            while(h+1<heaters.size() && abs(houses[i]-heaters[h])>=abs(houses[i]-heaters[h+1])) \n                h++;\n            ans = max(ans,abs(houses[i]-heaters[h]));\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345581624","body":"```cpp\nclass Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n=nums.size(), l=0, r=nums[n-1]-nums[0];\n        while(l <= r){\n            int m=(l+r)/2, cnt=0;\n            for(int i=0,j=0;j<n;j++){\n                while(nums[j]-nums[i] > m)\n                    i++;\n                cnt += j-i;\n            }\n            if(cnt >= k)\n                r = m-1;\n            else\n                l = m+1;\n        }\n        return l;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346737760","body":"### [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/description/)\n#### 思路\n二分 + dfs\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    typedef pair<int, int> PII;\n    int dirs[4][2] = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n    int swimInWater(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int l = 0, r = n * n;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (dfs(grid, mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n\n    bool dfs(vector<vector<int>> &grid, int time) {\n        if (time < grid[0][0]) return false;\n        int n = grid.size();\n        vector<vector<bool>> vis(n, vector<bool>(n, false));\n        queue<PII> que;\n        que.push({0, 0});\n        vis[0][0] = true;\n        while (!que.empty()) {\n            auto [i, j] = que.front();\n            que.pop();\n            for (auto dir : dirs) {\n                int x = i + dir[0];\n                int y = j + dir[1];\n                if (x < 0 || y < 0 || x >= n || y >= n) continue;\n                if (grid[x][y] > time || vis[x][y] == true) continue;\n                vis[x][y] = true;\n                que.push({x, y});\n            }\n        }\n        return vis[n - 1][n - 1];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n^2 * logn)\n- 空间复杂度：O(n^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348083658","body":"### [1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)\n#### 思路\n滑动窗口\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool check(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n\n    int maxVowels(string s, int k) {\n        queue<char> que;\n        int ans = 0, cur = 0;\n        for (char c : s) {\n            que.push(c);\n            if (que.size() > k) {\n                char del = que.front();\n                que.pop();\n                if (check(del)) cur -= 1;\n            }\n            if (check(c)) cur += 1, ans = max(ans, cur);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351640136","body":"#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (k == 0)\n            return 1.0;\n\n        double d[k+maxPts];\n        memset(d, 0, sizeof(d));\n        for (int i = k; i <= n & i < k + maxPts; ++i)\n            d[i] = 1.0;\n        \n\n        d[k-1] = 1.0*min(n-k+1, maxPts) / maxPts;\n        for (int i = k - 2; i >= 0; --i)\n            d[i] = d[i+1] - (d[i+maxPts+1]-d[i+1])/ maxPts;\n        \n        return d[0];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352751399","body":"### [438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)\n#### 思路\n使用数组来标记字母出现次数, 之后使用滑动窗口来记录定长下的字母频率\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int m = s.size(), n = p.size();\n        vector<int> ans;\n        if (n > m) return ans;\n        vector<int> ss(26, 0);\n        vector<int> pp(26, 0);\n        for (int i = 0; i < n; i++) {\n            ss[s[i] - 'a']++;\n            pp[p[i] - 'a']++;\n        }\n        if(ss == pp) ans.push_back(0);\n        for (int i = n; i < m; i++) {\n            ss[s[i - n] - 'a']--;\n            ss[s[i] - 'a']++;\n            if (ss == pp) ans.push_back(i - n + 1);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1355116460","body":"#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        vector<int> cnt(128, 0);\n        for (char c : t) cnt[c]++;\n\n        int need = t.size();\n        int size = s.size() + 1;\n        int start = 0;\n        int l = 0;\n        for (int r = 0; r < s.size(); r++) {\n            char c = s[r];\n            if (cnt[c] > 0) need--;\n\n            cnt[c]--;\n\n            if (need != 0) continue;\n\n            while (l < r && cnt[s[l]] < 0) {\n                cnt[s[l]]++; \n                l++;\n            }\n\n            if (r - l + 1 < size) {\n                size = r - l + 1;\n                start = l;\n            }\n\n            cnt[s[l]]++;\n            l++;\n            need++;\n        }\n\n        return size != s.size() + 1 ? s.substr(start, start + size) : \"\";\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356315079","body":"### [1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)\n#### 思路\n记数组里所有元素的和为`sum`, 要将`x`减到 0, 等价于`sum`子串和等于`sum - x`  \n题目要求的是最小操作数, 那么就寻找满足条件的最大子串长度\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int target = 0;\n        for (int num : nums) target += num;\n        target -= x;\n\n        int sum = 0, len = -1;\n        for (int l = 0, r = 0; r < nums.size(); r++) {\n            sum += nums[r];\n            while (l <= r && sum > target) sum -= nums[l++];\n            if (sum == target) len = max(len, r - l + 1);\n        }\n\n        return len == -1 ? -1 : nums.size() - len;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356821065","body":"### [401. 二进制手表](https://leetcode.cn/problems/binary-watch/description/)\n#### 思路\n暴力枚举\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int count(int n) {\n        int ret = 0;\n        while (n) {\n            n = n & (n - 1);\n            ret++;\n        }\n        return ret;\n    }\n    vector<string> readBinaryWatch(int turnedOn) {\n        vector<string> ans;\n        for (int i = 0; i < 12; i++) \n            for (int j = 0; j < 60; j++) {\n                if (count(i) + count(j) == turnedOn) {\n                    string h = to_string(i);\n                    string min = to_string(j);\n                    string temp = h + \":\" + (j < 10 ? \"0\" + min : min);\n                    ans.push_back(temp);\n                }\n            }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357376360","body":"#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> v;\n    unordered_map<int, int> m;\n    int ans = 0;\n    void dfs(int row, int n) {\n        if (row > n) {\n            ans++;\n            return;\n        }\n\n        for (int j = 1; j <= n; j++) {\n            if (m.find(j) == m.end()) { \n                int condition = 1;\n                for (int k = 1; k < row; k++) { \n                    if (k - v[k] == row - j || k + v[k] == row + j) {\n                        condition = 0;\n                        break;\n                    }\n                }\n                if (condition == 1) {\n                    v[row] = j;\n                    m[j]++;\n                    dfs(row + 1, n);\n                    v[row] = 0;\n                    m.erase(j);\n                }\n            }\n        }\n    }\n    int totalNQueens(int n) {\n        v.resize(n + 5);\n        dfs(1, n);\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359169613","body":"### [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/description/)\n#### 思路\ndfs\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n\n    int ans = 0, row, col;\n    int dirs[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        row = grid.size();\n        col = grid[0].size();\n        vector<vector<bool>> vis(row, vector<bool>(col, false));\n        for (int i = 0; i < row; i++) \n            for (int j = 0; j < col; j++) {\n                if (grid[i][j] == 1 && !vis[i][j])\n                    ans = max(ans, dfs(i, j, grid, vis));\n            }\n        return ans;\n    }\n    int dfs(int i, int j, vector<vector<int>>& grid, vector<vector<bool>>& vis) {\n        if (i < 0 || j < 0 || i == row || j == col || vis[i][j]) return 0;\n        int area = 0;\n        if (grid[i][j] == 1) {\n            vis[i][j] = true;\n            area++;\n            for (auto dir : dirs) {\n                int x = i + dir[0];\n                int y = j + dir[1];\n                area += dfs(x, y, grid, vis);\n            }\n        }\n        return area;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361540339","body":"#### 代码 (py)\r\n```python\r\nclass Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        n = len(grid)\r\n        queue = collections.deque((i, j) for i in range(n) for j in range(n) if grid[i][j])\r\n        if len(queue) == 0 or len(queue) == n * n:\r\n            return -1\r\n        else:\r\n            while queue:\r\n                i, j = queue.popleft()\r\n                for p, q in ((0, 1), (0, -1), (1, 0), (-1, 0)):\r\n                    x, y = i + p, j + q\r\n                    if 0 <= x < n and 0 <= y < n and not grid[x][y]:\r\n                        grid[x][y] = grid[i][j] + 1\r\n                        queue.append((x, y))\r\n            return grid[i][j] - 1\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362402299","body":"```java\nimport java.util.*;\nclass Solution {\n    public int solve(int[][] graph, int target) {\n        Queue<Integer> queue = new LinkedList<>();\n        Set<Integer> visited = new HashSet<>();\n        queue.offer(target);\n        int res = 0;\n        while(!queue.isEmpty()){\n            res++;\n            int size = queue.size();\n            for(int i = 0; i < size; i++){\n                int cur = queue.poll();\n                for(int nxt : graph[cur]){\n                    if(nxt == target){\n                        return res;\n                    }\n                    if(visited.contains(nxt)){\n                        continue;\n                    }\n                    visited.add(nxt);\n                    queue.offer(nxt);\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363777370","body":"### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/description/)\n#### 思路\n本题可以理解为以根节点为(0, 0), 向左为(x + 1, y - 1), 向右为(x + 1, y + 1)  \ny值越小(列越靠前), x越小(层考前)的先入列  \n使用 map + multiset, y权重大于x, 以y值映射键值对(x, val)  \n通过前序遍历整颗树\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n\n    typedef map<int, multiset<pair<int, int>>> MAP;\n\n    void dfs(int x, int y, TreeNode* root, MAP &mp) {\n        if (!root) return ;\n        mp[y].insert({x, root->val});\n        dfs(x + 1, y - 1, root->left, mp);\n        dfs(x + 1, y + 1, root->right, mp);\n    }\n\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        MAP mp;\n        dfs(0, 0, root, mp);\n        vector<vector<int>> ans;\n        for (auto &[a, b] : mp) {\n            vector<int> temp;\n            for (auto &e : b) {\n                temp.push_back(e.second);\n            }\n            ans.push_back(temp);\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364545176","body":"### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)\n#### 思路\n动态规划, 每一步只取前两步的最小, 答案在最后两个结果中取最小可以忽略奇偶\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> q(n);\n        q[0] = cost[0], q[1] = cost[1];\n        for (int i = 2; i < n; i++) {\n            q[i] = min(q[i - 1], q[i - 2]) + cost[i];\n        }\n        return min(q[n - 1], q[n - 2]);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364696504","body":"### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/description/)\n#### 思路\n如果偷当前家, 就也偷取n - 2家, 不偷, 则考虑n - 1\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return nums[0];\n        vector<int> dp(n + 1);\n        dp[0] = 0, dp[1] = nums[0];\n        for (int i = 2; i <= n; i++) {\n            dp[i] = max(dp[i - 2] + nums[i - 1], dp[i - 1]);\n        }\n        return dp[n];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365252828","body":"#### 代码 (java)\n```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n], g = new int[n];\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            f[i] = g[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        g[i] = g[j];\n                    } else if (f[i] == f[j] + 1) {\n                        g[i] += g[j];\n                    }\n                }\n            }\n            max = Math.max(max, f[i]);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (f[i] == max) ans += g[i];\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365949030","body":"### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/description/)\n#### 思路\n动态规划\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.size(), n = text2.size();\n        vector<vector<int>> dp(m + 1, vector(n + 1, 0));\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1[i - 1] == text2[j - 1]) \n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                else \n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n * m)\n- 空间复杂度：O(n * m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366550172","body":"### [62. 不同路径](https://leetcode.cn/problems/unique-paths/description/)\n#### 思路\n路径问题\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m, vector(n, 0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n * m)\n- 空间复杂度：O(n * m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367417544","body":"### code(java)\r\n```java\r\nclass Solution {\r\n\r\n    private static final int[][] DIRS = {{1, 2}, {2, 1}, \r\n    {-1, 2}, {2, -1}, {1, -2}, {-2, 1}, {-1, -2}, {-2, -1}};\r\n\r\n    public double knightProbability(int n, int k, int row, int column) {             \r\n        double[][][] memo = new double[n][n][k + 1];\r\n        return dfs(n, k, row, column, memo);\r\n    }\r\n\r\n    public double dfs(int n, int k, int i, int j, double[][][] memo) {\r\n        // 走出边界\r\n        if (i < 0 || j < 0 || i >= n || j >= n) {\r\n            return 0;\r\n        }\r\n        // k 步走完了还没超出边界，这一步的概率是1，还需要乘上前面的 k 个 1/8\r\n        if (k == 0) {\r\n            return 1;\r\n        }\r\n        // 缓存中存在，直接返回\r\n        if (memo[i][j][k] != 0) {\r\n            return memo[i][j][k];\r\n        }\r\n        // 每一个方向的概率都是 1/8\r\n        double ans = 0;\r\n        for (int[] dir : DIRS) {\r\n            ans += dfs(n, k - 1, i + dir[0], j + dir[1], memo) / 8.0;\r\n        }\r\n        memo[i][j][k] = ans;\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367974804","body":"#### code(java)\n```java\nclass Solution {\n    public static boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n        int[] dp = new int[1 << maxChoosableInteger];\n        Arrays.fill(dp, -1);\n        return dfs(desiredTotal, 0, maxChoosableInteger, dp) == 1;\n    }\n\n    public static int dfs(int total, int state, int max, int[] dp) {\n        if (dp[state] != -1) return dp[state];\n        for (int i = 0; i < max; i++) {\n            if (((state >> i) & 1) == 1) continue;\n            if (total <= i + 1) return dp[state] = 1; \n            if (dfs(total - i - 1, state | (1 << i), max, dp) == 0) return dp[state] = 1; \n        }\n        return dp[state] = 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368242258","body":"### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/description/)\n#### 思路\n动态规划\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int len = nums.size();\n        int sum = 0;\n        for (int e : nums) sum += e;\n        if (sum & 1 == 1) return false;\n        int target = sum >> 1;\n        vector<vector<bool>> dp(len, vector<bool>(target + 1, false));\n        if (nums[0] <= target) dp[0][nums[0]] = true;\n        for (int i = 1; i < len; i++) {\n            for (int j = 0; j < target + 1; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (nums[i] == j) {\n                    dp[i][j] = true;\n                    continue;\n                } else if (nums[i] < j) {\n                    dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n                }\n            }\n        }\n        return dp[len - 1][target];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n * sum / 2)\n- 空间复杂度：O((n * sum / 2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368391921","body":"```java\nclass Solution {\n\n    public  int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int n : nums) {\n            sum += n;\n        }\n        if ((sum - target) % 2 != 0 || (sum - target) < 0) return 0;\n        int minus = (sum - target) / 2;\n        //if (minus == 0) return 1;\n        int[][] dp = new int[nums.length + 1][minus + 1];\n\n        for (int i = 0; i <= nums.length; ++i) {\n            dp[i][0] = 1;\n        }\n        // dp[i][j] 前i个数 和为j的组合数\n        for (int i = 1; i <= nums.length; ++i) {\n            for (int j = 0; j <= minus;++j) {\n                if (j - nums[i - 1] >= 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[nums.length][minus];\n    }   \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1369047054","body":"```cpp\nclass Solution {\npublic:\n    int INF = 0x3f3f3f3f;\n    int coinChange(vector<int>& coins, int amount) {\n        int n = coins.size();\n        vector<int> f(amount + 1);\n        for (int i = 1; i <= amount; i++) f[i] = INF;\n        for (int i = 1; i <= n; i++) {\n            int val = coins[i - 1];\n            for (int j = val; j <= amount; j++) {\n                f[j] = min(f[j], f[j - val] + 1);\n            }\n        }\n        return f[amount] == INF ? -1 : f[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369923003","body":"```cpp\nint f[5010];\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        memset(f, 0, sizeof(f));\n        f[0] = 1;\n        for(int & coin: coins){\n            for(int i = 1; i <= amount; ++i)\n                if(i - coin >= 0)\n                    f[i] += f[i - coin]; \n        }\n        return f[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1373123245","body":"```cpp\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(), g.end());\n        sort(s.begin(), s.end());\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (ans < g.size() && g[ans] <= s[i]) ans++;\n        }\n        return ans;\n    }\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372367009","body":"```cpp\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if (intervals.size() == 0) return 0;\n        sort(intervals.begin(), intervals.end(), cmp);\n        int count = 1;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.size(); i++) {\n            if (end <= intervals[i][0]) {\n                end = intervals[i][1];\n                count++;\n            }\n        }\n        return intervals.size() - count;\n    }\n\n    static bool cmp (const vector<int>& a, const vector<int>& b) {\n        return a[1] < b[1];\n    }\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373342708","body":"### [881. 救生艇](https://leetcode.cn/problems/boats-to-save-people/description/)\n#### 思路\n贪心, 优先让最小的和最大的匹配\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& p, int limit) {\n        sort(p.begin(), p.end());\n        int i = 0, j = p.size() - 1, ans = 0;\n        while (i <= j) {\n            if (p[i] + p[j] <= limit) i++;\n            j--;\n            ans++;\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374514437","body":"### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)\n#### 思路\n二叉搜索树的性质: 左子树小于根节点, 右子树大于根节点  \n对于 1 ~ n 的节点, 对于节点 i , 其左边 1 ~ i-1可能有x种可能, 其右边 i ~ n可能有y种可能  \n根据乘法原理可得, 以i为根节点的树有 x*y 种可能\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int numTrees(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++)\n            for (int j = 1; j <= i; j++)\n                dp[i] += dp[j - 1] = dp[i - j];\n\n        return dp[n];\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374848720","body":"### [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)\n#### 思路 1 小根堆\n将所有链表头节点指针加入小根堆, 每次在傀儡节点后 通过移动`tail`指针, 添加堆顶元素`cur`, 如果`cur`后含有节点, 则加入堆中 \n#### 代码 (cpp)\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    struct cmp { //结构体 cmp 重载 ()函数\n        bool operator()(ListNode *a, ListNode *b) {\n            return a->val > b->val; // 小根堆\n        }\n    };\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        priority_queue<ListNode*, vector<ListNode*>, cmp> q;\n\n        for (ListNode *list : lists) \n            if (list != nullptr)\n                q.push(list);\n\n        ListNode *dummy = new ListNode(0), *tail = dummy;\n        while (!q.empty()) {\n            ListNode *cur = q.top(); q.pop();\n            tail->next = cur;\n            tail = tail->next;\n            if (cur->next != nullptr) //if (cur->next)\n                q.push(cur->next);\n        }\n        \n        return dummy->next;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogk)\n- 空间复杂度：O(k)\n---","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375748277","body":"#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    unordered_map<int,vector<int>> mp;\n    vector<int> beautifulArray(int n) {\n        vector<int> ans;\n        if(n == 1){\n            ans.push_back(1);\n            return ans;\n        }\n        if(mp.count(n)) return mp[n];\n        int odd = (n + 1) / 2;\n        int even = n / 2;\n        vector<int> left = beautifulArray(odd);\n        vector<int> right = beautifulArray(even);\n    \n        for(auto &val : left){\n            ans.push_back(val * 2 - 1);\n        }\n\n        for(auto &val : right){\n            ans.push_back(val * 2);\n        }\n        mp[n] = ans;\n        return ans;\n    }\n   \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377144880","body":"### [260. 只出现一次的数字 III]()\n#### 思路\n- 原理: \n  1. a ^ a = 0  \n  2. a ^ 0 = a\n\n假设数组中仅出现一次的数字为 x, y\n那么将数组全部异或之后, 得到 x_or =  x ^ y, 找到 x_or 的二进制中第一次出现 1 的下标 f, f 可划分 x 和 y \n接下来再次遍历数组, 按照当前数字`num & f`分为两类, 两类中的数字全部异或即可分别得到 x 和 y\n#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        vector<int> ans(2, 0);\n        int x_or = 0;\n        for (int num : nums) x_or ^= num;\n        \n        int f = 1;\n        while ((f & x_or) == 0) f <<= 1;\n\n        for (int num : nums) {\n            if (num & f) ans[0] ^= num;\n            else ans[1] ^= num;\n        }\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378912231","body":"#### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> ans;\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n  = nums.size();\n        vector<int> t;\n        for (int i = 0; i < (1 << n); i++) {\n            t.clear();\n            for (int j = 0; j < n; j++) {\n                if (i & (1 << j)) t.push_back(nums[j]);\n            }\n            ans.push_back(t);\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380580412","body":"#### 代码 (cpp)\n```cpp\n#define TRIE_MAX_CHAR_NUM 26\n\nstruct TrieNode {\n\tTrieNode *child[TRIE_MAX_CHAR_NUM];\n\tbool is_end;\n\tTrieNode() :is_end(false) {\n\t\tfor (int i = 0; i < TRIE_MAX_CHAR_NUM; i++) {\n\t\t\tchild[i] = 0;\n\t\t}\n\t}\n};\n\nclass Trie {\npublic:\n    /** Initialize your data structure here. */\n    Trie() { }\n    \n    ~Trie() {\n\t\tfor (int i = 0; i < _node_vec.size(); i++) {\n\t\t\tdelete _node_vec[i];\n\t\t}\n\t}\n    /** Inserts a word into the trie. */\n    void insert(string word) {\n        TrieNode *ptr = &_root;\n        int index=0;\n        while (word[index]) {\n            int pos = word[index] - 'a';\n            if (!ptr->child[pos]) {\n                ptr->child[pos] = new_node();\n            }\n            ptr = ptr->child[pos];\n            index++;\n        }\n        ptr->is_end = true;\n    }\n    \n    /** Returns if the word is in the trie. */\n    bool search(string word) {\n        TrieNode *ptr = &_root;\n        int index=0;\n        while (word[index]) {\n            int pos = word[index] - 'a';\n            if (!ptr->child[pos]) {\n                return false;\n            }\n            ptr = ptr->child[pos];\n            index++;\n        }\n        return ptr->is_end;\n    }\n    \n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        TrieNode *ptr = &_root;\n        int index=0;\n        while (prefix[index]) {\n            int pos = prefix[index] - 'a';\n            if (!ptr->child[pos]) {\n                return false;\n            }\n            ptr = ptr->child[pos];\n            index++;\n        }\n        return true;\n    }\n    \nprivate:\n    TrieNode *new_node() {\n        TrieNode *node = new TrieNode();\n        _node_vec.push_back(node);\n        return node;\n    }\n    vector<TrieNode*>_node_vec;\n    TrieNode _root;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381620752","body":"```cpp\nclass MapSum {\npublic:\n    static const int N = 3010;\n    int son[N][26];\n    int idx;\n    int cnt[N];\n    unordered_map<string, int> M;\n    MapSum() {\n        idx = 0;\n        memset(cnt, 0, sizeof cnt);\n        memset(son, 0, sizeof son);\n    }\n    \n    void insert(string key, int val) {\n        int p = 0;\n        for(int i = 0; i < key.size(); i++){\n            int u = key[i] - 'a';\n            if (!son[p][u]) son[p][u] = ++idx;\n            p = son[p][u];\n            if (M.count(key)) cnt[p] += (val - M[key]);\n            else cnt[p] += val;            \n        }\n        M[key] = val;\n    }\n    \n    int sum(string prefix) {\n        int p = 0;\n        for(int i = 0; i < prefix.size(); i++){\n            int u = prefix[i] - 'a';\n            if (!son[p][u]) return 0;\n            p = son[p][u];\n        }\n        return cnt[p];\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382822132","body":"```\nclass Solution {\npublic:\n    struct Trie{\n         int smallIndex;\n         Trie* next[26];\n         Trie(){ \n             smallIndex=-1;\n             memset(next,0,sizeof(next));\n         }\n    };\n    vector<vector<int>> res;\n    Trie* root=new Trie();\n    void insert(string s,int s_index){\n        Trie*  node=root;\n        for(auto ch:s){\n            if(node->next[ch-'a']==NULL){\n                node->next[ch-'a']=new Trie();\n            }\n            node=node->next[ch-'a'];\n        }\n        node->smallIndex=s_index; \n    }\n\n    void search(string subBig,int index){ \n        Trie* node=root;\n        for(auto ch:subBig){\n            if(node->next[ch-'a']==NULL) return;\n            node=node->next[ch-'a'];\n            if(node->smallIndex!=-1){ \n                res[node->smallIndex].push_back(index);\n            }           \n        }\n    }\n\n\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        res.resize(smalls.size());\n        for(int i=0;i<smalls.size();i++){ \n            insert(smalls[i],i);\n        }\n        for(int i=0;i<big.size();i++){ \n            string subBig=big.substr(i);\n            search(subBig,i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383185276","body":"### 思路\n使用并查集, 初始有n个, 每连接两个没有连接的, ans--\n\n### code\n```cpp\nclass Solution {\npublic:\n    int ans, a[210];\n\n    void init(int n) {\n        for (int i = 0; i < n; i++) a[i] = i;\n    }\n\n    int find(int x) {\n        if (x != a[x]) a[x] = a[find(a[x])];\n        return a[x];\n    }\n\n    void connect(int i, int j) {\n        int x = find(i), y = find(j);\n        if (x == y) return;\n        a[x] = y;\n        ans--;\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int row = isConnected.size();\n        int col = isConnected[0].size();\n        init(row);\n        ans = row;\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < col; j++) {\n                if (isConnected[i][j]) connect(i, j);\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297896968","body":"### 思路\n第一眼感觉跟第二题很像，从最后一位开始加，记录进位状态，数组先结束，检查k是否有值；k结束，检查数组是否还有值；\n后来发现进位状态可以合并回 k，详见代码。\n\n### 代码\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int x = num[i] + k % 10;\n            ans.add(x % 10);\n            k /= 10;\n            k += x / 10;\n        }\n        for (; k > 0; k /= 10) {\n            ans.add(k % 10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299396343","body":"### 思路\r\n\r\n根据题意，两次遍历；第一次从左往右，找到每个位置左侧最近的；第二次从右往左，找到右侧最近的；\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] cs = s.toCharArray();\r\n        int[] ans = new int[cs.length];\r\n        Arrays.fill(ans, cs.length + 1);\r\n        int j = -1;\r\n        for(int i = 0; i < cs.length; i++){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = i - j;\r\n            }\r\n        }\r\n        j = -1;\r\n        for(int i = cs.length - 1; i >= 0; i--){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = Math.min(ans[i], j - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 时空分析\r\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301801372","body":"### 思路\n直接模拟 \n\n### 代码\n\n```java\nclass CustomStack {\n    private int[] stack;\n    private int size;\n    private int cur;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = maxSize;\n        cur = -1;\n    }\n   \n    public void push(int x) {\n        if(cur + 1 == size){\n            return;\n        }\n        stack[++cur] = x;\n    }\n    \n    public int pop() {\n        if(cur < 0){\n            return -1;\n        }\n        return stack[cur--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= cur; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度\n时间复杂度：O(1) inc O(k)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303446549","body":"## 思路\n递归，返回内部字符串 和 计算到了哪个位置；每次遇到[ 就进入下层，遇到 ] 就发返回；\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        char[] str = s.toCharArray();\n        return process(str, 0).res;\n    }\n\n    private Info process(char[] str, int index){\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        while(index < str.length){\n            char c = str[index];\n            if(c >= '0' && c <= '9'){\n                count = count * 10 + (c - '0');\n            }else if(c == '['){\n                Info info = process(str, index + 1);\n                while(count > 0){\n                    sb.append(info.res);\n                    count--;\n                }\n                index = info.index;\n            }else if(c == ']'){\n                return new Info(sb.toString(), index);\n            }else {\n                sb.append(c);\n            }\n            index++;\n        }\n        return new Info(sb.toString(), index);\n    }\n}\n\nclass Info{\n    String res;\n    Integer index;\n\n    Info(String res, Integer index){\n        this.res = res;\n        this.index = index;\n    }\n}\n\n```\n\n### 时空分析\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304371003","body":"## 思路\n\n## 代码\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> data = new Stack<>();\n    private Stack<Integer> help = new Stack<>();\n    public MyQueue() {\n\n    }\n    public void push(int x) {\n        data.push(x);\n    }\n    \n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        return help.pop();\n    }\n    \n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        return help.peek();\n    }\n    \n    public boolean empty() {\n        pushToHelp();\n        return help.isEmpty();\n    }\n\n    private void pushToHelp(){\n        if(help.isEmpty()){\n            while(!data.isEmpty()){\n                help.push(data.pop());\n            }\n        }\n    }\n}\n```\n\n## 复杂度分析\nO(1), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780145","body":"### 思路\n用栈保存所有段的最大值；\n逐个比较数组中每个数组，如果比当前栈顶元素小，那么肯定属于之前顶段，然后取栈顶和当前数的最大值再次放入栈；\n最后返回栈的长度即为分段的个数；\n\n### 代码\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int n : arr){\n            int t = n;\n            while(!stack.isEmpty() && stack.peek() > n){\n                t = Math.max(t, stack.pop());\n            }\n            stack.push(t);\n        }\n        return stack.size();\n    }\n}\n\n\n```\n\n### 时空分析\nO(n), O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305415816","body":"## 思路\n1,先数出总长度（同时将将首尾链接），确定需要断开的位置；\n2,走到需要断开的位置，断开即可；\n\n## 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        int n = 1;\n        ListNode cur = head;\n        while(cur.next != null){\n            cur = cur.next;\n            n++;\n        }\n\n        k = k % n;\n        if(k == 0){\n            return head;\n        }\n\n        cur.next = head;\n\n        for(int i = 0; i < n - k; i++){\n            cur = cur.next;\n        }\n        ListNode ret = cur.next;\n        cur.next = null;\n        return ret;\n    }\n}\n```\n\n## 时空分析\n\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306462524","body":"### 代码\n```java\nclass Solution {\n    ///  a b c\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode a = head;\n        ListNode b = a.next;\n        a.next = swapPairs(a.next.next);\n        b.next = a;\n        return b;\n    }\n}\n\n```\n\n\n### 时空分析\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308050143","body":"### 思路\r\n\r\n利用快慢指针查找中点，递归构建左右树即可。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        return build(head, null);\r\n    }\r\n\r\n    private TreeNode build(ListNode head, ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast != tail && fast.next != tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode node = new TreeNode(slow.val);\r\n        node.left = build(head, slow);\r\n        node.right = build(slow.next, tail);\r\n        return node;\r\n    }\r\n}\r\n\r\n```\r\n\r\n### 时空分析\r\nO(n * logn) , O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310265726","body":"### 思路\n从两个链表分别走，一个到头，就换到另一条；直到两个相等为止，相等有两种情况，第一种，两个都到null相等，则没有交点，第二种，两个相交相等，则相等点就是交点；\n\n### 代码\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n        ListNode p1 = headA;\n        ListNode p2 = headB;\n        while(p1 != p2){\n            p1 = p1 == null ? headB : p1.next;\n            p2 = p2 == null ? headA : p2.next;\n        }\n        return p1;\n    }\n```\n\n### 时空\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311278007","body":"## 思路\n查找入环点标准解法\n## 代码\n\n```java\n    public ListNode detectCycle(ListNode head) {\n        if(head == null || head.next == null){\n            return null;\n        }\n        ListNode fast = head.next.next;\n        ListNode slow = head.next;\n\n        while(fast != null && fast.next != null && fast != slow){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        if(fast == null || fast.next == null){\n            return null;\n        }\n\n        fast = head;\n        while(fast != slow){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312477550","body":"### 代码\n```java\nclass LRUCache {\n\n    class Node{\n        int k;\n        int v;\n        Node pre;\n        Node next;\n        Node(int _k, int _v){\n            k = _k;\n            v = _v;\n        }\n    }\n\n    int n;\n    Node head;\n    Node tail;\n    Map<Integer, Node> map;\n\n    public LRUCache(int capacity) {\n        n = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if(map.containsKey(key)){\n            Node node = map.get(key);\n            refresh(node);\n            return node.v;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        Node node = null;\n        if(map.containsKey(key)){\n            node = map.get(key);\n            node.v = value;\n        }else{\n            if(map.size() == n){\n                Node del = tail.pre;\n                map.nextemove(del.k);\n                delete(del);\n            }\n            node = new Node(key, value);\n            map.put(key, node);\n        }\n        refresh(node);\n    }\n\n    void refresh(Node node){\n        delete(node);\n        node.next = head.next;\n        node.pre = head;\n        head.next.pre = node;\n        head.next = node;\n    }\n\n    void delete(Node node){\n        if(node.pre != null){\n            Node left = node.pre;\n            left.next = node.next;\n            node.next.pre = left;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727922","body":"## 代码\n```java\n\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        if(root.left == null && root.right == null){\n            return 1;\n        }\n        int left = maxDepth(root.left);\n        int right = maxDepth(root.right);\n        return Math.max(left, right) + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313245169","body":"```java\n\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null ^ q == null){\n            return false;\n        }\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314947084","body":"```java\n    private int res = 0;\n\n    public int sumNumbers(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        process(root, sb);\n        return res;\n    }\n\n    private void process(TreeNode root, StringBuilder sb){\n        if(root.left == null && root.right == null){\n            sb.append(root.val);\n            res += Integer.parseInt(sb.toString());\n            sb.deleteCharAt(sb.length() - 1);\n            return;\n        }\n\n        if(root.left != null){\n            sb.append(root.val);\n            process(root.left, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n\n        if(root.right != null){\n            sb.append(root.val);\n            process(root.right, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316217197","body":"### 思路\n按层遍历，更新每一层的第一个值（最左值）；\n\n```java\n    public int findBottomLeftValue(TreeNode root) {\n        if(root == null){\n            return -1;\n        }\n        int res = root.val;\n        Deque<TreeNode> deque = new ArrayDeque<>();\n        deque.add(root);\n        while(!deque.isEmpty()){\n            int size = deque.size();\n            for(int i = 0; i < size; i++){\n                TreeNode node = deque.poll();\n                if(i == 0){\n                    res = node.val;\n                }\n                if(node.left != null){\n                    deque.add(node.left);\n                }\n                if(node.right != null){\n                    deque.add(node.right);\n                }\n            }\n        }\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318557828","body":"```java\n\npublic class Codec {\n    StringBuilder builder = new StringBuilder();\n    public String serialize(TreeNode root) {\n        toString(root);\n        return builder.toString();\n    }\n    private void toString(TreeNode root) {\n        if (root == null) {\n            builder.append(',');\n        } else {\n            builder.append(root.val).append(',');\n            toString(root.left);\n            toString(root.right);\n        }\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) {\n            return null;\n        }\n        String[] str = data.split(\",\");\n        return dfs(str);\n    }\n    private int idx = 0;\n    private TreeNode dfs(String[] str) {\n        if (idx > str.length - 1 || str[idx].length() == 0) {\n            idx++;\n            return null;\n        }\n        TreeNode root = new TreeNode(Integer.parseInt(str[idx++]));\n        root.left = dfs(str);\n        root.right = dfs(str);\n        return root;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319887952","body":"## 思路\n构造数据结构，map；key是节点，value是一个 x，y ，val 的数组；深度遍历将所有节点存入map；\n根据题意，先按列/再按行/再按值排序；\n最后取出结果；\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    private Map<TreeNode, int[]> map = new HashMap<>();\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root, new int[]{0, 0, root.val});\n        dfs(root);\n        List<int[]> list = new ArrayList<>(map.values());\n        Collections.sort(list, (a, b) -> {\n            if(a[0] != b[0]){\n                return a[0] - b[0];\n            }else if(a[1] != b[1]){\n                return a[1] - b[1];\n            }else{\n                return a[2] - b[2];\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = list.size();\n        for(int i = 0; i < n;){\n            List<Integer> col = new ArrayList<>();\n            int j = i;\n            while(j < n && list.get(i)[0] == list.get(j)[0]){\n                col.add(list.get(j++)[2]);\n            }\n            ans.add(col);\n            i = j;\n        }\n        return ans;\n    }\n\n    private void dfs(TreeNode root){\n        if(root == null){\n            return;\n        }\n        int[] xyz = map.get(root);\n        int col = xyz[0];\n        int row = xyz[1];\n        int val = xyz[2];\n        if(root.left != null){\n            map.put(root.left, new int[]{col - 1, row + 1, root.left.val});\n            dfs(root.left);\n        }\n        if(root.right != null){\n            map.put(root.right, new int[]{col + 1, row + 1, root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n\n```\n\n### 时空分析\n\n深度遍历 O(n), 排序 O(logn)，整体 O(nlogn);\nO(n);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320857729","body":"梦开始的地方\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(map.containsKey(target - nums[i])){\n                return new int[]{i, map.get(target - nums[i])};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321031470","body":"## 思路\n\n小根堆维护k个最大值；\nmap记录值对应的次数；\n\n```java\n\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for(int n :  nums){\n            map.put(n, map.getOrDefault(n, 0) + 1);\n        }\n        PriorityQueue<Integer> queue = new PriorityQueue<>((a, b) -> {\n            return map.get(a) - map.get(b);\n        });\n        for(Integer key : map.keySet()){\n            if(queue.size() < k){\n                queue.add(key);\n            }else if(map.get(key) > map.get(queue.peek())){\n                queue.add(key);\n                queue.remove();\n            }\n        }\n        int[] res = new int[k];\n        int i = 0;\n        while(!queue.isEmpty()){\n            res[i++] = queue.poll();\n        }\n        return res;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321509371","body":"## 分别计算每个点中，其他所有点跟他的距离，然后取距离相同的点算总数；\n\n```java\n\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        for(int i = 0; i < points.length; i++){\n            Map<Integer, Integer> map = new HashMap<>();\n            for(int j = 0; j < points.length; j++){\n                if(i != j){\n                    int dx = points[i][0] - points[j][0];\n                    int dy = points[i][1] - points[j][1];\n                    int dist = dx * dx + dy * dy;\n                    map.put(dist, map.getOrDefault(dist, 0) + 1);\n                }\n            }\n            for(Integer dist : map.keySet()){\n                res += map.get(dist) * (map.get(dist) - 1);\n            }\n        }\n        return res;\n    }\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323107635","body":"```java\n \nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[256];\n        Arrays.fill(map, -1);\n        int ans = 0;\n        int pre = 0;\n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            pre = Math.min(pre + 1, i - map[c]);\n            ans = Math.max(ans, pre);\n            map[c] = i;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325105566","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList();\n        if (s == null || s.length() == 0 || words == null || words.length == 0){\n             return res;\n        }\n        int n = s.length();\n        int m = words.length;\n        int w = words[0].length();\n\n        //预处理，统计 words 中每个单词的数量\n        Map<String, Integer> total = new HashMap();\n        for (String word : words) {\n            total.put(word, total.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < w; ++i) {\n            HashMap<String, Integer> wd = new HashMap<>();\n            // 统计窗口内单词在 words 中出现的次数\n            int cnt = 0; \n            for (int j = i; j + w <= n; j += w) {\n                //窗口已经满，需要去掉窗口最左边的单词，才能在窗口中添加新的单词\n                if (j >= i + w * m) {\n                    //获取窗口最左边的单词\n                    String word = s.substring(j - m * w, w + j - m * w); \n                    //去除窗口最左边的单词\n                    wd.put(word, wd.get(word) - 1); \n                    if (total.get(word) != null && wd.get(word) < total.get(word))\n                        cnt--;\n                }\n                String word = s.substring(j, j + w); \n                wd.put(word, wd.getOrDefault(word, 0) + 1); //在窗口最右边添加新的单词\n                if (total.get(word) != null && wd.get(word) <= total.get(word)){\n                    cnt++;\n                }\n                if (cnt == m){\n                    res.add(j - (m - 1) * w);\n                }\n            }\n        }\n        return res; \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325853659","body":"```java\n\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int n = nums.length;\n        int[] s = new int[n + 1];\n        for(int i = 1; i <= n; i++){\n            s[i] = s[i - 1] + nums[i - 1];\n        }\n        Map<Integer, Integer> cnt = new HashMap<>();\n        cnt.put(0, 1);\n        int res = 0;\n        for(int i = 1; i <= n; i++){\n            int r = (s[i] % k  + k) % k;\n            res += cnt.getOrDefault(r, 0);\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327144079","body":"```java\n\n\n    public ListNode middleNode(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n        ListNode fast = head.next;\n        ListNode slow = head;\n        while(fast.next != null && fast.next.next != null){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow.next;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328032537","body":"```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int slow = 0;\n        for(int i = 1; i < nums.length; i++){\n            if(nums[i] != nums[slow]){\n                nums[++slow] = nums[i];\n            }\n        }\n        return slow + 1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328150819","body":"```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328597638","body":"```java\n\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || k < 1 || nums.length < k){\n            return null;\n        }\n\n        LinkedList<Integer> qmax = new LinkedList<>();\n        int[] result = new int[nums.length - k + 1];\n\n        int index = 0;\n\n        for(int R = 0; R < nums.length; R++){\n            while (!qmax.isEmpty() && nums[qmax.peekLast()] <= nums[R]){\n                qmax.pollLast();\n            }\n            qmax.addLast(R);\n            if(qmax.peekFirst() == R - k){\n                qmax.pollFirst();\n            }\n            if(R >= k - 1){\n                result[index++] = nums[qmax.peekFirst()];\n            }\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330319740","body":"```java\n\n    public int findJudge(int n, int[][] trust) {\n        int[] map = new int[n + 1];\n        int[] out = new int[n + 1];\n        for(int[] t : trust){\n            map[t[1]]++;\n            out[t[0]]++;\n        }\n        for(int i = 1; i <= n; i++){\n            if(map[i] == n - 1 && out[i] == 0){\n                return i;\n            }\n        }\n        return -1;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332084838","body":"```java\nclass Solution {\n    int N = 2010, M = 2 * 10010;\n    int[] he = new int[N], e = new int[M], ne = new int[M], color = new int[N];\n    int idx;\n    void add(int a, int b) {\n        e[idx] = b;\n        ne[idx] = he[a];\n        he[a] = idx++;\n    }\n    boolean dfs(int u, int cur) {\n        color[u] = cur;\n        for (int i = he[u]; i != -1; i = ne[i]) {\n            int j = e[i];\n            if (color[j] == cur) return false;\n            if (color[j] == 0 && !dfs(j, 3 - cur)) return false;\n        }\n        return true;\n    }\n    public boolean possibleBipartition(int n, int[][] ds) {\n        Arrays.fill(he, -1);\n        for (int[] info : ds) {\n            int a = info[0], b = info[1];\n            add(a, b); add(b, a);\n        }\n        for (int i = 1; i <= n; i++) {\n            if (color[i] != 0) continue;\n            if (!dfs(i, 1)) return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333712936","body":"```java\n\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        Map<Integer, Integer> groupCnt = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int v = group[i];\n            if (v == -1) {\n                groupCnt.put(m, 1);\n                group[i] = m++;\n            } else {\n                groupCnt.put(v, groupCnt.getOrDefault(v, 0) + 1);\n            }\n        }\n        int[] d1 = new int[m];\n        int[] d2 = new int[n];\n        Map<Integer, List<Integer>> g1 = new HashMap<>();\n        Map<Integer, List<Integer>> g2 = new HashMap<>();\n        for (int i = 0; i < beforeItems.size(); i++) {\n            List<Integer> be = beforeItems.get(i);\n            for (int j : be) {\n                d2[i]++;\n                g2.computeIfAbsent(j, l -> new ArrayList<>()).add(i);\n                int a = group[i];\n                int b = group[j];\n                if (a != b) {\n                    d1[a]++;\n                    g1.computeIfAbsent(b, l -> new ArrayList<>()).add(a);\n                }\n            }\n        }\n        Queue<Integer> q = new LinkedList<>();\n        for (int i = 0; i < m; i++) {\n            if (d1[i] == 0) {\n                q.add(i);\n            }\n        }\n        int cnt = 0;\n        int cur = 0;\n        Map<Integer, Integer> pos = new HashMap<>();\n        while (q.size() > 0) {\n            int t = q.poll();\n            pos.put(t, cur);\n            System.out.println(t);\n            cur += groupCnt.getOrDefault(t, 0);\n            for (int j : g1.getOrDefault(t, Collections.emptyList())) {\n                d1[j]--;\n                if (d1[j] == 0) {\n                    q.add(j);\n                }\n            }\n            cnt++;\n        }\n        if (cnt != m) {\n            return new int[]{};\n        }\n        cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (d2[i] == 0) {\n                q.add(i);\n            }\n        }\n        int[] res = new int[n];\n        while (q.size() > 0) {\n            int t = q.poll();\n            cnt++;\n            int k = group[t];\n            res[pos.get(k)] = t;\n            pos.put(k, pos.get(k) + 1);\n            for (int j : g2.getOrDefault(t, Collections.emptyList())) {\n                d2[j]--;\n                if (d2[j] == 0) {\n                    q.add(j);\n                }\n            }\n        }\n        if (cnt != n) {\n            return new int[]{};\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335188447","body":"```java\n    public boolean judgeCircle(String moves) {\n        int x = 0;\n        int y = 0;\n        for(int i = 0; i < moves.length(); i++){\n            char c = moves.charAt(i);\n            if(c == 'U'){\n                x--;\n            }else if(c == 'D'){\n                x++;\n            }else if(c == 'L'){\n                y--;\n            }else if(c == 'R'){\n                y++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336162157","body":"```java\n\nclass Solution {\n    public int[] getOrder(int[][] ts) {\n        int n = ts.length;\n        // 将 ts 转存成 nts，保留任务编号\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) {\n            nts[i] = new int[]{ts[i][0], ts[i][1], i};\n        }\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) {\n                return a[1] - b[1];\n            }else{\n                return a[2] - b[2];\n            }\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n        \t// 如果当前任务可以添加到「队列」中（满足入队时间）则进行入队\n            while (j < n && nts[j][0] <= time) {\n                q.add(nts[j++]);\n            }\n            if (q.isEmpty()) {\n\t            // 如果当前「队列」没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n            \t// 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336347486","body":"```java\n\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        String[] loginS = loginTime.split(\":\");\n        String[] logoutS = logoutTime.split(\":\");\n        int sh = Integer.parseInt(loginS[0]);\n        int sm = Integer.parseInt(loginS[1]);\n        int lh = Integer.parseInt(logoutS[0]);\n        int lm = Integer.parseInt(logoutS[1]);\n\n        int s = sh * 60 + sm;\n        int e = lh * 60 + lm;\n        int d = s < e ? 0 : 1;\n\n        if(sm == 0){\n            sm = 0;\n        }else if(sm <= 15){\n            sm = 15;\n        }else if(sm <= 30){\n            sm = 30;\n        }else if(sm <= 45){\n            sm = 45;\n        }else if(sm <= 60){\n            sm = 0;\n            sh += 1;\n        }\n        if(lm < 15){\n            lm = 0;\n        }else if(lm < 30){\n            lm = 15;\n        }else if(lm < 45){\n            lm = 30;\n        }else{\n            lm = 45;\n        }\n        s = sh * 60 + sm;\n        e = lh * 60 + lm + d * 24 * 60;\n        System.out.println(s);\n        return Math.max(0, (e - s) / 15);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1339279474","body":"```java\r\n\r\nclass Solution {\r\n    public int minCharacters(String a, String b) {\r\n        int n = a.length();\r\n        int m = b.length();\r\n        int ans = Integer.MAX_VALUE;\r\n        int[] c1 = new int[26];\r\n        int[] c2 = new int[26];\r\n        for (char c : a.toCharArray()){\r\n            c1[c - 'a']++;\r\n        }\r\n        for (char c : b.toCharArray()){\r\n            c2[c - 'a']++;\r\n        }\r\n        for (int i = 0; i < 26; i++) {\r\n            int ca = n - c1[i], cb = m - c2[i];\r\n            ans = Math.min(ans, ca + cb);\r\n            if (i == 0) {\r\n                continue;\r\n            }\r\n            int r1 = 0;\r\n            int r2 = 0;\r\n            for (int j = i; j < 26; j++) {\r\n                r1 += c1[j];\r\n            }\r\n            for (int j = 0; j < i; j++) {\r\n                r1 += c2[j];\r\n            }\r\n            for (int j = i; j < 26; j++) {\r\n                r2 += c2[j];\r\n            }\r\n            for (int j = 0; j < i; j++) {\r\n                r2 += c1[j];\r\n            }\r\n            ans = Math.min(ans, Math.min(r1, r2));\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339298385","body":"```java\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        int n = nums.length;\n        int max = nums[0];\n        int min = max;\n        for(int i : nums){\n            if(i > max){\n                max = i;\n            }else if(i < min){\n                min = i;\n            }\n        }\n        int len = max - min + 1;\n        int[] bucket = new int[len];\n        for(int i : nums){\n            bucket[i - min]++;\n        }\n        for(int i = 0, j = 0; i < bucket.length; i++){\n            while(bucket[i] > 0){\n                nums[j++] = i + min;\n                bucket[i]--;\n            }\n        }\n        return nums;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340958620","body":"```java\n\nclass Solution {\n    public int mySqrt(int x) {\n        long ans = -1;\n        long l = 0;\n        long r = x;\n        while(l <= r){\n            long mid = l + ((r - l) >> 1);\n            long a = mid * mid;\n            if(a <= x){\n                l = mid + 1;\n                ans = mid;\n            }else{\n                r = mid - 1;\n            }\n        }\n\n        return (int)ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342749849","body":"```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 0;\n        int right = n;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(isBadVersion(mid)){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344229933","body":"```java\nclass Solution {\n    public int reversePairs(int[] nums) {\n        return mergeSort(nums, 0, nums.length - 1);\n    }\n\n    private int mergeSort(int[] nums, int left, int right){\n        if(left >= right){\n            return 0;\n        }\n        int mid = left + (right - left) / 2;\n        int res = 0;\n        res += mergeSort(nums, left, mid);\n        res += mergeSort(nums, mid + 1, right);\n\n        for(int i = left, j = mid + 1; i <= mid; i++){\n            while(j <= right && 1L * nums[i] > 2L * nums[j]){\n                res += mid - i + 1;\n                j++;\n            }\n        }\n        int i = left;\n        int j = mid + 1;\n        int[] tmp = new int[right - left + 1];\n        int id = 0;\n        while(i <= mid && j <= right){\n            if(nums[i] <= nums[j]){\n                tmp[id++] = nums[i++];\n            }else{\n                tmp[id++] = nums[j++];\n            }\n        }\n        while(i <= mid){\n            tmp[id++] = nums[i++];\n        }\n        while(j <= right){\n            tmp[id++] = nums[j++];\n        }\n        for(int k = left; k <= right; k++){\n            nums[k] = tmp[k - left];\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345270451","body":"```java\n\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        int l = 0, r = (int) 1e9;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(houses, heaters, mid)) {\n                r = mid;\n            }else{\n                l = mid + 1;\n            }\n        }\n        return r;\n    }\n    boolean check(int[] houses, int[] heaters, int x) {\n        int n = houses.length, m = heaters.length;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < m && houses[i] > heaters[j] + x){\n                j++;\n            }\n            if (j < m && heaters[j] - x <= houses[i] && houses[i] <= heaters[j] + x) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345453645","body":"```java\nclass Solution {\n    public int flipgame(int[] fronts, int[] backs) {\n        Set<Integer> set = new HashSet<>();\n        for(int i = 0; i < fronts.length; i++){\n            if(fronts[i] == backs[i]){\n                set.add(fronts[i]);\n            }\n        }\n        int res = Integer.MAX_VALUE;\n        for(int n : fronts){\n            if(!set.contains(n)){\n                res = Math.min(res, n);\n            }\n        }\n        for(int n : backs){\n            if(!set.contains(n)){\n                res = Math.min(res, n);\n            }\n        }\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346453181","body":"## 思路\n\n答案范围在0到n * n - 1 范围内，并且整个区间具有二段性，可以用二分；然后用 dfs 检查二分的结果是否正确即可。\n\n```java\n\nclass Solution {\n    public int swimInWater(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                min = Math.min(min, grid[i][j]);\n                max = Math.max(max, grid[i][j]);\n            }\n        }\n        int left = min;\n        int right = max;\n        int res = 0;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(check(grid, mid)){\n                res = mid;\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return res;\n    }\n\n    private boolean check(int[][] grid, int mid){\n        if(grid[0][0] > mid){\n            return false;\n        }\n        boolean[][] map = new boolean[grid.length][grid[0].length];\n        return dfs(grid, mid, map, 0, 0);\n    }\n\n    int[] dx = new int[]{0, 1, 0, -1};\n    int[] dy = new int[]{1, 0, -1, 0};\n\n    private boolean dfs(int[][] grid, int mid, boolean[][] map, int x, int y){\n        map[x][y] = true;\n        if(x == grid.length - 1 && y == grid[0].length - 1){\n            return true;\n        }\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            if(nx < grid.length && nx >= 0 && ny < grid[0].length && ny >= 0 && grid[nx][ny] <= mid && !map[nx][ny]){\n                if(dfs(grid, mid, map, nx, ny)){\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348545592","body":"```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int cnt = 0;\n        int left = 0;\n        int right = 0;\n        while(right < s.length() && right < k){\n            cnt += isNeed(s.charAt(right)) ? 1 : 0;\n            right++;\n        }\n        int max = cnt;\n        while(right < s.length()){\n            cnt -= isNeed(s.charAt(left)) ? 1 : 0;\n            cnt += isNeed(s.charAt(right)) ? 1 : 0;\n            right++;\n            left++;\n            max = Math.max(max, cnt);\n        }\n        return max;\n    }\n\n    private boolean isNeed(char c){\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351338524","body":"```java\nclass Solution {\n    public double new21Game(int N, int K, int maxPts) {\n        if (K == 0) {\n            return 1.0;\n        }\n        double dp [] = new double[20010];\n        for (int i = K; i <= N; i++) {\n            dp[i] = 1;\n        }\n        for (int i = 1; i <= maxPts; i++){\n            dp[K - 1] += dp[K - 1 + i] / maxPts;\n        }\n        for (int i = K - 2; i >= 0; i--){\n            dp[i] = dp[i + 1] + (dp[i + 1] - dp[i + maxPts + 1]) / maxPts;\n        }\n        return dp[0];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353024816","body":"```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n\n        char[] str = s.toCharArray();\n        char[] ptn = p.toCharArray();\n\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n\n        List<Integer> ans = new ArrayList<>();\n\n        for(int i = 0; i < ptn.length; i++){\n            pCount[ptn[i] - 'a']++;\n            sCount[str[i] - 'a']++;\n        }\n\n        if(Arrays.equals(sCount, pCount)){\n            ans.add(0);\n        }\n\n        for(int i = 0; i < str.length - ptn.length; i++){\n            sCount[str[i] - 'a']--;\n            sCount[str[i + ptn.length] - 'a']++;\n            if(Arrays.equals(sCount, pCount)){\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354792394","body":"```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        char[] str = s.toCharArray();\n        char[] ts = t.toCharArray();\n        \n\n        int[] map = new int[256];\n\n        for(char c : ts){\n            map[c]++;\n        }\n        int right = 0;\n        int left = 0; \n        int ansL = -1;\n        int ansR = -1;\n        int minLen = Integer.MAX_VALUE;\n        int all = ts.length;\n        while(right != str.length){\n            map[str[right]]--;\n            if(map[str[right]] >= 0){\n                all--;\n            }\n            if(all == 0){\n                while(map[str[left]] < 0){\n                    map[str[left++]]++;\n                }\n                if(minLen > right - left + 1){\n                    minLen = right - left + 1;\n                    ansL = left;\n                    ansR = right;\n                }\n            }\n            right++;\n        }\n\n        return minLen == Integer.MAX_VALUE ? \"\" : s.substring(ansL, ansR + 1);\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356264040","body":"```java\n\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n        int ans = 0, sum = 0;\n        for (int i = n - k; i < n; i++) {\n            sum += cardPoints[i];\n        }\n        ans = Math.max(ans, sum);\n        for (int l = n - k, r = 0; r < k; r++) {\n            sum -= cardPoints[l++];\n            sum += cardPoints[r];\n            ans = Math.max(ans, sum);\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356798565","body":"```java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> ans = new ArrayList<String>();\n        for (int i = 0; i < 1024; ++i) {\n            int h = i >> 6, m = i & 63;\n            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {\n                ans.add(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357708602","body":"### 打表可行？ \r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int totalNQueens(int n) {\r\n        int[] result = {1,0,0,2,10,4,40,92,352};\r\n        return result[n - 1];\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359344776","body":"```java\n\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int ans = 0;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    ans = Math.max(ans, process(i, j, grid));\n                }\n            }\n        }\n        return ans;\n    }\n\n    private int process(int x, int y, int[][] grid){\n        if(x < 0 || x >= grid.length || y < 0 || y >= grid[0].length || grid[x][y] == 0){\n            return 0;\n        }\n        int res = 1;\n        grid[x][y] = 0;\n        res += process(x + 1, y, grid);\n        res += process(x, y + 1, grid);\n        res += process(x - 1, y, grid);\n        res += process(x, y - 1, grid);\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361350503","body":"### 思路\n\n宽度优先遍历\n先将所有陆地入队，然后一圈一圈的遍历，同时记录每一次遍历的点，最后一个遍历到的点就是最远的海洋，并且一定是最近的陆地扩散到的。\n\n```java\n\nclass Solution {\n    public int maxDistance(int[][] grid) {\n\n        int[] dx = new int[] {1, 0, -1, 0};\n        int[] dy = new int[] {0, 1, 0, -1};\n\n        Queue<int[]> queue = new ArrayDeque<>();\n        int m = grid.length;\n        int n = grid[0].length;\n        for(int i = 0; i < m; i++){\n            for(int j = 0; j < n; j++){\n                if(grid[i][j] == 1){\n                    queue.offer(new int[]{i, j});\n                }\n            }\n        }\n\n        int[] point = null;\n        boolean hasOcean = false;\n        while(!queue.isEmpty()){\n            point = queue.poll();\n            int x = point[0];\n            int y = point[1];\n            for(int i = 0; i < 4; i++){\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                if(nx < 0 || nx >= m || ny < 0 || ny >= n || grid[nx][ny] != 0){\n                    continue;\n                }\n                grid[nx][ny] = grid[x][y] + 1;\n                hasOcean = true;\n                queue.offer(new int[]{nx, ny});\n            }\n        }\n\n        if(point == null || !hasOcean){\n            return -1;\n        }\n\n        return grid[point[0]][point[1]] - 1;\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362779718","body":"```java\nclass Solution {\n    public int maxScore(int[] nums) {\n        int n = nums.length;\n        int[][] g = new int[n][n];\n        // 预计算gcd\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                g[i][j] = gcd(nums[i], nums[j]);\n            }\n        }\n\n        int[] pos = new int[n];\n        int[] DP = new int[1 << n];\n        for (int s = 3; s < DP.length; s++) {\n            int d = 0;\n            for (int i = 0; i < n; i++) {\n                if ((s & (1 << i)) != 0) pos[d++] = i;\n            }\n            if ((d & 1) != 0) continue;\n            \n            for (int i = 0; i < d; i++) {\n                for (int j = i + 1; j < d ; j++) {\n                    int t = (s &~(1<<pos[i])) &~(1<<pos[j]);\n                    DP[s] = Math.max(DP[s], (d >> 1) * g[pos[i]][pos[j]] + DP[t]);\n                }\n            }\n        }\n        return DP[DP.length - 1];\n    }\n\n    private int gcd(int x, int y) {\n        if (x == 0) return y;\n        if (y == 0) return x;\n        return x < y ? gcd(y % x, x) : gcd(x % y, y);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363811850","body":"```java\n\nclass Solution {\n    public int finalValueAfterOperations(String[] operations) {\n        int res = 0;\n        for(String o : operations){\n            char c = o.charAt(1);\n            if(c == '-'){\n                res--;\n            }else if(c == '+'){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364530864","body":"```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n + 1];\n        dp[0] = cost[0];\n        dp[1] = cost[1];\n        for(int i = 2; i < n; i++){\n            dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];\n        }\n        return Math.min(dp[n - 1], dp[n - 2]);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364666687","body":"```java\nclass Solution {\n    public int rob(int[] nums) {\n\n        if(nums == null || nums.length == 0){\n            return 0;\n        }\n\n        int N = nums.length;\n        if(N == 1){\n            return nums[0];\n        }\n        if(N == 2){\n            return Math.max(nums[0], nums[1]);\n        }\n\n        int[] dp = new int[nums.length + 1];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for(int i = 2; i < nums.length; i++){\n            dp[i] = Math.max(Math.max(dp[i - 1], nums[i]), dp[i - 2] + nums[i]);\n        }\n\n        return dp[N - 1];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365109550","body":"```java\n\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        if (n <= 1) {\n            return n;\n        }\n        int[] dp = new int[n];\n        for(int i = 0; i < dp.length; i++) {\n            dp[i] = 1;\n        }\n        int[] count = new int[n];\n        for(int i = 0; i < count.length; i++) {\n            count[i] = 1;\n        }\n\n        int maxCount = 0;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        count[i] = count[j];\n                    } else if (dp[j] + 1 == dp[i]) {\n                        count[i] += count[j];\n                    }\n                }\n                if (dp[i] > maxCount) {\n                    maxCount = dp[i];\n                }\n            }\n        }\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            if (maxCount == dp[i]) {\n                result += count[i];\n            }\n        }\n        return result;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365772542","body":"```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        int res = 0;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\n                if(text1.charAt(i - 1) == text2.charAt(j - 1)){\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                } \n            }\n        }\n        return dp[m][n];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366648809","body":"```java\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for(int i = 0; i < m; i++){\n            dp[i][0] = 1;\n        }\n        for(int i = 0; i < n; i++){\n            dp[0][i] = 1;\n        }\n        for(int i = 1; i < m; i++){\n            for(int j = 1; j < n; j++){\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n\n        return dp[m - 1][n - 1];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367159403","body":"## 超时版本\n\n```java\n\nclass Solution {\n\n    private int[][] dx = new int[][]{{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {1, -2}, {-1, -2}, {-2, -1}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        return dfs(n, k, row, column);\n    }\n\n    private double dfs(int n, int k, int i, int j){\n        if(i < 0 || j < 0 || i >= n || j >= n){\n            return 0;\n        }\n        if(k == 0){\n            return 1;\n        }\n\n        double ans = 0;\n        for(int[] d : dx){\n            ans += dfs(n, k - 1, i + d[0], j + d[1]) / 8.0;\n        }\n        return ans;\n    }\n}\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367927492","body":"```java\nclass Solution {\n\n    private int[] dp;\n    private int n;\n    private int m;\n\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        n = maxChoosableInteger;\n        m = desiredTotal;\n        if(n * (n + 1) / 2 < m){\n            return false;\n        }\n        dp = new int[1 << n + 1];\n        Arrays.fill(dp, -1);\n        return process(0) == 1;\n    }\n\n    private int process(int x){\n        if(dp[x] != -1){\n            return dp[x];\n        }\n        int sum = 0;\n        for(int i = 0; i < n; i++){\n            if((x >> i & 1) == 1){\n                sum += i + 1;\n            }\n        }\n        for(int i = 0; i < n; i++){\n            if((x >> i & 1) == 1){\n                continue;\n            }\n            if(sum + i + 1 >= m){\n                dp[x] = 1;\n                return 1;\n            }\n            if(process(x + (1 << i)) == 0){\n                dp[x] = 1;\n                return 1;\n            }\n        }\n        dp[x] = 0;\n        return 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1369605047","body":"```java\r\nclass Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int n = nums.length;\r\n        if (n < 2) {\r\n            return false;\r\n        }\r\n        int sum = 0, maxNum = 0;\r\n        for (int num : nums) {\r\n            sum += num;\r\n            maxNum = Math.max(maxNum, num);\r\n        }\r\n        if (sum % 2 != 0) {\r\n            return false;\r\n        }\r\n        int target = sum / 2;\r\n        if (maxNum > target) {\r\n            return false;\r\n        }\r\n        boolean[] dp = new boolean[target + 1];\r\n        dp[0] = true;\r\n        for (int i = 0; i < n; i++) {\r\n            int num = nums[i];\r\n            for (int j = target; j >= num; --j) {\r\n                dp[j] |= dp[j - num];\r\n            }\r\n        }\r\n        return dp[target];\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368408684","body":"```java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        if(nums == null){\n            return 0;\n        }\n        return process(nums, 0, target);\n    }\n\n    private int process(int[] nums, int index, int target){\n        if(index == nums.length){\n            return target == 0 ? 1 : 0;\n        }\n        return process(nums, index + 1, target + nums[index]) + process(nums, index + 1, target - nums[index]);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368868104","body":"```java\nclass Solution {\n    public int coinChange(int[] coins, int m) {\n        int[] dp = new int[m + 1];\n        Arrays.fill(dp, m + 1);\n        dp[0] = 0;\n        for(int v : coins){\n            for(int j = v; j <= m; j++){\n                dp[j] = Math.min(dp[j], dp[j - v] + 1);\n            }\n        }\n        if(dp[m] > m){\n            return -1;\n        }\n        return dp[m];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369367879","body":"```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for(int coin : coins){\n            for(int i = coin; i <= amount; i++){\n                dp[i] += dp[i - coin]; \n            }\n        }\n        return dp[amount];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370394050","body":"```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int ans = 0;\n        int idx = 0;\n        for(int i = 0; i < g.length; i++){\n            while(idx < s.length && g[i] > s[idx]){\n                idx++;\n            }\n            if(idx < s.length && g[i] <= s[idx]){\n                ans++;\n                idx++;\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372119340","body":"```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] q) {\n        Arrays.sort(q, (a, b) -> a[1] - b[1]);\n        int res = 1;\n        int r = q[0][1];\n        for(int i = 1; i < q.length; i++){\n            if(q[i][0] >= r){\n                res++;\n                r = q[i][1];\n            }\n        }\n\n        return q.length - res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373658507","body":"```java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        if(people == null || people.length == 0 || limit < 0){\n            return -1;\n        }\n\n        Arrays.sort(people);\n        if(people[people.length - 1] > limit){\n            return -1;\n        }\n\n        int lessR = -1;\n        for(int i = people.length - 1; i >=0; i--){\n            if(people[i] <= limit / 2){\n                lessR = i;\n                break;\n            }\n        }\n\n        if(lessR == -1){\n            return people.length;\n        }\n\n        int L = lessR;\n        int R = lessR + 1;\n        int noUsed = 0;\n        while(L >= 0){\n            int solved = 0;\n            while(R < people.length && people[L] + people[R] <= limit){\n                R++;\n                solved++;\n            }\n            if(solved == 0){\n                noUsed++;\n                L--;\n            }else{\n                L = Math.max(-1, L - solved);\n            }\n        }\n\n        return people.length - 1 - lessR + ((noUsed + 1) >> 1);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374465653","body":"```java\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n+1];\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for(int i = 2; i < n + 1; i++)\n            for(int j = 1; j < i + 1; j++){\n                dp[i] += dp[j-1] * dp[i-j];\n            }\n                \n        \n        return dp[n];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374684039","body":"```java\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> q = new PriorityQueue<>((a, b) -> a.val - b.val);\n        ListNode res = new ListNode();\n        ListNode cur = res;\n\n        for(ListNode listNode : lists){\n            if(listNode != null){\n                q.offer(listNode);\n            }\n        }\n\n        while(!q.isEmpty()){\n            ListNode tmp = q.poll();\n            cur.next = tmp;\n            cur = cur.next;\n            if(tmp.next != null){\n                q.offer(tmp.next);\n            }\n        }\n\n        return res.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375596840","body":"```java\nclass Solution {\n    public int[] beautifulArray(int n) {\n        if(n == 1){\n            return new int[]{1};\n        }\n        int[] left = beautifulArray((n + 1) / 2);\n        int[] right = beautifulArray(n / 2);\n        int[] res = new int[n];\n        int idx = 0;\n        for(int x : left){\n            res[idx++] = x * 2 - 1;\n        }\n        for(int x : right){\n            res[idx++] = x * 2;\n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377267930","body":"```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int x = 0;\n        for (int num : nums) {\n            x ^= num;\n        }\n        // 防止溢出\n        int a = (x == Integer.MIN_VALUE ? x : x & (-x));\n        int t1 = 0;\n        int t2 = 0;\n        for (int num : nums) {\n            if ((num & a) != 0) {\n                t1 ^= num;\n            } else {\n                t2 ^= num;\n            }\n        }\n        return new int[]{t1, t2};\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378711183","body":"```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        process(res, path, nums, 0);\n        return res;\n    }\n\n    private void process(List<List<Integer>> res, List<Integer> path, int[] nums, int index){\n        if(nums.length == index){\n            res.add(new ArrayList<>(path));\n            return;\n        }\n\n        path.add(nums[index]);\n        process(res, path, nums, index + 1);\n        path.remove(path.size() - 1);\n        process(res, path, nums, index + 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380218991","body":"```java\nclass Trie {\n\n    class Node{\n        Node[] nexts;\n        boolean end;\n\n        public Node(){\n            nexts = new Node[26];\n            end = false;\n        }\n    }\n\n    Node root;\n\n    public Trie() {\n        root = new Node();\n    }\n    \n    public void insert(String word) {\n        Node cur = root;\n        for(int i = 0; i < word.length(); i++){\n            int ne = word.charAt(i) - 'a';\n            if(cur.nexts[ne] == null){\n                cur.nexts[ne] = new Node();\n            }\n            cur = cur.nexts[ne];\n        }\n        cur.end = true;\n    }\n    \n    public boolean search(String word) {\n        Node cur = getNode(word);\n        return cur != null && cur.end;\n    }\n    \n    public boolean startsWith(String prefix) {\n        return getNode(prefix) != null;\n    }\n\n    private Node getNode(String s){\n        Node cur = root;\n        for(int i = 0; i < s.length(); i++){\n            int n = s.charAt(i) - 'a';\n            if(cur.nexts[n] == null){\n                return null;\n            }\n            cur = cur.nexts[n];\n        }\n        return cur;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381779747","body":"```java\nclass MapSum {\n\n    private Node node;\n\n    private Map<String, Integer> map;\n\n    public MapSum() {\n        node = new Node();\n        map = new HashMap<>();\n    }\n    \n    public void insert(String key, int val) {\n        Node cur = node;\n        int last = map.getOrDefault(key, 0);\n        map.put(key, val);\n        val = val - last;\n        for(int i = 0; i < key.length(); i++){\n            int c = key.charAt(i) - 'a';\n            Node next = cur.nexts[c];\n            if(next == null){\n                cur.nexts[c] = new Node();\n            }\n            next = cur.nexts[c];\n            next.val = next.val + val;\n            cur.nexts[c] = next;\n            cur = next;\n        }\n    }\n    \n    public int sum(String prefix) {\n        Node cur = node;\n        for(int i = 0; i < prefix.length(); i++){\n            cur = cur.nexts[prefix.charAt(i) - 'a'];\n            if(cur == null){\n                return 0;\n            }\n        }\n        return cur.val;\n    }\n}\n\nclass Node{\n    Node[] nexts;\n    int val;\n    boolean end;\n    public Node(){\n        nexts = new Node[26];\n        val = 0;\n        end = false;\n    }\n}\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum obj = new MapSum();\n * obj.insert(key,val);\n * int param_2 = obj.sum(prefix);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382705729","body":"```java\nclass Solution {\n\n    class Trie{\n        TrieNode root;\n        public Trie(String[] words){\n            root = new TrieNode();\n            for(String word : words){\n                TrieNode node = root;\n                for(char w : word.toCharArray()){\n                    int i = w - 'a';\n                    if(node.next[i] == null){\n                        node.next[i] = new TrieNode();\n                    }\n                    node = node.next[i];\n                }\n                node.end = word;\n            }\n        }\n\n        public List<String> search(String str){\n            TrieNode node = root;\n            List<String> res = new ArrayList<>();\n            for(char c : str.toCharArray()){\n                int i = c - 'a';\n                if(node.next[i] == null){\n                    break;\n                }\n                node = node.next[i];\n                if(node.end != null){\n                    res.add(node.end);\n                }\n            }\n            return res;\n        }  \n    }\n\n    class TrieNode{\n        String end;\n        TrieNode[] next = new TrieNode[26];\n    }\n\n\n    public int[][] multiSearch(String big, String[] smalls) {\n        Trie trie = new Trie(smalls);\n        Map<String, List<Integer>> map = new HashMap<>();\n        for(int i = 0; i < big.length(); i++){\n            List<String> matchs = trie.search(big.substring(i));\n            for(String word : matchs){\n                List<Integer> list = map.getOrDefault(word, new ArrayList<>());\n                list.add(i);\n                map.put(word, list);\n            }\n        }\n        \n        int[][] res = new int[smalls.length][];\n        for(int i = 0; i < smalls.length; i++){\n            List<Integer> list = map.get(smalls[i]);\n            if(list == null){\n                res[i] = new int[0];\n                continue;\n            }\n            int size = list.size();\n            res[i] = new int[size];\n            for(int j = 0; j < size; j++){\n                res[i][j] = list.get(j);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383152142","body":"```java\nclass Solution {\n    public int findCircleNum(int[][] isConnected) {\n        int cities = isConnected.length;\n        boolean[] visited = new boolean[cities];\n        int provinces = 0;\n        for (int i = 0; i < cities; i++) {\n            if (!visited[i]) {\n                dfs(isConnected, visited, cities, i);\n                provinces++;\n            }\n        }\n        return provinces;\n    }\n\n    public void dfs(int[][] isConnected, boolean[] visited, int cities, int i) {\n        for (int j = 0; j < cities; j++) {\n            if (isConnected[i][j] == 1 && !visited[j]) {\n                visited[j] = true;\n                dfs(isConnected, visited, cities, j);\n            }\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297908504","body":"更喜欢这种一个循环的写法，虽然多了一个判断\n\n**Code**\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n\n        int i = num.length - 1;\n        while (k > 0 || i >= 0) {\n            if (i >= 0)\n                k += num[i];\n\n            ans.add(0, k % 10);\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299444396","body":"**Code**\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n\n        int i = 0;\n        for (int t = 0; t < s.length(); t++) {\n            while (s.charAt(t) == c && i < t) {\n                ans[i] = t - i;\n                i++;\n            }\n        }\n\n        i = s.length() - 1;\n        for (int t = s.length() - 1; t >= 0; t--) {\n            while (s.charAt(t) == c && i > t) {\n                ans[i] = ans[i] == 0 ? i - t : Math.min(ans[i], i - t);\n                i--;\n            }\n        }\n\n        for (i = 0; i < s.length(); i++)\n            if (s.charAt(i) == c) ans[i] = 0;\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301777110","body":"**code**\n\n```java\nclass CustomStack {\n    private final int[] stack;\n    private int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top == stack.length - 1) return;\n        \n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top == -1) return -1;\n        \n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++)\n            stack[i] += val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302899706","body":"**code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Character> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c != ']') deque.addFirst(c);\n            else {\n                StringBuilder sb = new StringBuilder();\n                while (!deque.isEmpty() && Character.isLetter(deque.getFirst()))\n                    sb.insert(0, deque.removeFirst());\n\n                String sub = sb.toString();\n                deque.removeFirst(); // remove '['\n\n               sb = new StringBuilder();\n               while (!deque.isEmpty() && Character.isDigit(deque.getFirst()))\n                   sb.insert(0, deque.removeFirst());\n\n               int count = Integer.parseInt(sb.toString());\n\n                for (char ch : sub.repeat(count).toCharArray())\n                    deque.addFirst(ch);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!deque.isEmpty())\n            sb.append(deque.removeLast());\n\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304501376","body":"**code**\n\n```java\nclass MyQueue {\n    Deque<Integer> stackA;\n    Deque<Integer> stackB;\n\n    public MyQueue() {\n        stackA = new ArrayDeque<>();\n        stackB = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        stackA.push(x);\n    }\n\n    public int pop() {\n        transfer();\n        return stackB.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return stackB.peek();\n    }\n\n    public boolean empty() {\n        return stackA.isEmpty() && stackB.isEmpty();\n    }\n    \n    private void transfer() {\n        if (!stackB.isEmpty()) return;\n        \n        while (!stackA.isEmpty())\n            stackB.push(stackA.pop());\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304707450","body":"**thought**\n\nSplit the array into blocks as many as possible and the largest number in the left block should be less than the largest number in the right one.\n\n---\n\n**code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            int largest = num;\n            while (!stack.isEmpty() && stack.getFirst() > num)\n                largest = Math.max(largest, stack.removeFirst());\n            \n            stack.addFirst(largest);\n        }\n        \n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305153752","body":"**code**\n\n```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        \n        Deque<ListNode> stack = new ArrayDeque<>();\n        ListNode cur = head;\n        while (cur != null) {\n            stack.addFirst(cur);\n            cur = cur.next;\n        }\n\n        k %= stack.size();\n\n        while (k > 0) {\n            cur = stack.removeFirst();\n            cur.next = head;\n            head = cur;\n            stack.getFirst().next = null;\n            k--;\n        }\n        \n        return head;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307265697","body":"**code**\n\n```java\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode next = head.next;\n        head.next = swapPairs(next.next);\n        next.next = head;\n        return next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308150895","body":"**code**\n\n\n```java\n    private ListNode cur;\n\n    public TreeNode sortedListToBST(ListNode head) {\n        int length = 0;\n        for (ListNode p = head; p != null; p = p.next) length++;\n\n        cur = head;\n        return buildTree(0, length - 1);\n    }\n\n    private TreeNode buildTree(int left, int right) {\n        if (left > right) return null;\n\n        int mid = (left + right) >>> 1;\n\n        TreeNode leftTree = buildTree(left, mid - 1);\n\n        TreeNode root = new TreeNode(cur.val);\n        cur = cur.next;\n\n        TreeNode rightTree = buildTree(mid + 1, right);\n        root.left = leftTree;\n        root.right = rightTree;\n\n        return root;\n    }\n    \n//    approach 2\n//    public TreeNode sortedListToBST(ListNode head) {\n//        List<Integer> list = new ArrayList<>();\n//        for (ListNode cur = head; cur != null; cur = cur.next)\n//            list.add(cur.val);\n//\n//        return buildTree(list, 0, list.size() - 1);\n//    }\n//\n//    private TreeNode buildTree(List<Integer> list, int left, int right) {\n//        if (left > right) return null;\n//\n//        int mid = left + (right - left) / 2;\n//        TreeNode root = new TreeNode(list.get(mid));\n//        root.left = buildTree(list, left, mid - 1);\n//        root.right = buildTree(list, mid + 1, right);\n//\n//        return root;\n//    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309675840","body":"**code**\n\n```java\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode nodeA = headA;\n        ListNode nodeB = headB;\n\n        while (nodeA != nodeB) {\n            nodeA = nodeA == null ? headB : nodeA.next;\n            nodeB = nodeB == null ? headA : nodeB.next;\n        }\n\n        return nodeA;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311135510","body":"**thought**\n\n      a     b \n    -----------| <- They will meet at here   \n        |      |\n        -------| c    Thanks to @FlipN9\n\n    2 * slow pointer travel distance = fast pointer travel distance\n    => 2 * (a + b) = a + (b + c) + b (if the circle is big enough)\n    => a = c\n    otherwise \n    => 2 * (a + b) = a + N * (b + c) + b\n    => a + b = N * (b + c)\n    => a = (N - 1) * b + N * c\n    => claim K = N - 1\n    => a = K * b + (K + 1) * c\n    => a = K * (b + c) + c\n\n**code**\n\n```java\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        do {\n            if (fast == null || fast.next == null) return null;\n            slow = slow.next;\n            fast = fast.next.next;\n        } while (slow != fast);\n\n        slow = head;\n        while (slow != fast) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312400703","body":"**thought**\n\nDoubly Linked List with Map\n\n**code**\n\n```java\nclass LRUCache {\n    private final Map<Integer, DLinkedNode> cache;\n    private final DLinkedList list;\n    private final int capacity;\n\n    public LRUCache(int capacity) {\n        cache = new HashMap<>();\n        list = new DLinkedList();\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n\n        DLinkedNode node = cache.get(key);\n        list.moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            DLinkedNode node = cache.get(key);\n            node.value = value;\n            list.moveToHead(node);\n        } else {\n            if (capacity == cache.size())\n                cache.remove(list.removeTail().key);\n\n            DLinkedNode node = new DLinkedNode(key, value);\n            cache.put(key, node);\n            list.addToHead(node);\n        }\n    }\n}\n\nclass DLinkedList {\n    private final DLinkedNode dummyHead;\n    private final DLinkedNode dummyTail;\n\n    public DLinkedList() {\n        this.dummyHead = new DLinkedNode();\n        this.dummyTail = new DLinkedNode();\n        dummyHead.next = dummyTail;\n        dummyTail.prev = dummyHead;\n    }\n\n    public void addToHead(DLinkedNode node) {\n        node.prev = dummyHead;\n        node.next = dummyHead.next;\n        dummyHead.next.prev = node;\n        dummyHead.next = node;\n    }\n\n    public void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    public DLinkedNode removeTail() {\n        DLinkedNode tail = dummyTail.prev;\n        removeNode(tail);\n        return tail;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}\n\nclass DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode next;\n    DLinkedNode prev;\n\n    public DLinkedNode() {}\n\n    public DLinkedNode(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312665996","body":"**code**\n\n```java\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313385232","body":"**code**\n\n```java\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null) return false;\n\n        if (q.val != p.val) return false;\n\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315216589","body":"**code**\n\n```java\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode root, int path) {\n        if (root == null) return 0;\n\n        path = path * 10 + root.val;\n        if (root.left == null && root.right == null) return path;\n\n        return dfs(root.left, path) + dfs(root.right, path);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316501662","body":"**code**\n\n```java\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        queue.add(root);\n        int leftMost = root.val;\n        \n        while (!queue.isEmpty()) {\n            leftMost = queue.element().val;\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode cur = queue.remove();\n                \n                if (cur.left != null) queue.add(cur.left);\n                if (cur.right != null) queue.add(cur.right);\n            }\n        }\n        \n        return leftMost;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318218683","body":"**code**\n\n```java\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        buildString(root, sb);\n        return sb.toString();\n    }\n\n    private void buildString(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append('X').append(',');\n            return;\n        }\n\n        sb.append(root.val).append(',');\n        buildString(root.left, sb);\n        buildString(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        Deque<String> nodes = Arrays.stream(data.split(\",\")).collect(Collectors.toCollection(ArrayDeque::new));\n        return buildTree(nodes);\n    }\n\n    private TreeNode buildTree(Deque<String> nodes) {\n        String s = nodes.removeFirst();\n        if (s.equals(\"X\")) return null;\n\n        TreeNode node = new TreeNode(Integer.parseInt(s));\n        node.left = buildTree(nodes);\n        node.right = buildTree(nodes);\n\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319481473","body":"**code**\n\n```java\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Map<Integer, List<int[]>> map = new TreeMap<>();\n\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        Queue<Integer> queueOfCol = new ArrayDeque<>();\n        queue.add(root);\n        queueOfCol.add(0);\n\n        int y = 0;\n        while (!queue.isEmpty()) {\n            for (int i = queue.size(); i > 0; i--) {\n                TreeNode cur = queue.remove();\n                int x = queueOfCol.remove();\n\n                map.computeIfAbsent(x, e -> new ArrayList<>()).add(new int[] {y, cur.val});\n\n                if (cur.left != null) {\n                    queue.add(cur.left);\n                    queueOfCol.add(x - 1);\n                }\n\n                if (cur.right != null) {\n                    queue.add(cur.right);\n                    queueOfCol.add(x + 1);\n                }\n            }\n            y++;\n        }\n\n        List<List<Integer>> ans = new ArrayList<>(map.size());\n        for (var list : map.values()) {\n            list.sort((a, b) -> a[0] != b[0] ? Integer.compare(a[0], b[0]) : Integer.compare(a[1], b[1]));\n\n            List<Integer> cur = new ArrayList<>();\n            for (var val : list) cur.add(val[1]);\n\n            ans.add(cur);\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320817041","body":"**code**\n\n```java\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i]))\n                return new int[] {map.get(target - nums[i]), i};\n\n            map.put(nums[i], i);\n        }\n        \n        return new int[0];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321119925","body":"**code**\n\n```java\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (var num : nums)\n            count.put(num, count.getOrDefault(num, 0) + 1);\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n\n        for (var e : count.entrySet()) {\n            int[] p = {e.getKey(), e.getValue()};\n            if (k > minHeap.size())\n                minHeap.add(p);\n            else if (p[1] > minHeap.element()[1]) {\n                minHeap.remove();\n                minHeap.add(p);\n            }\n        }\n        \n        return minHeap.stream().mapToInt(e -> e[0]).toArray();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321300991","body":"**code**\n\n```java\n    public int numberOfBoomerangs(int[][] points) {\n        if (points.length < 3) return 0;\n\n        int n = points.length;\n        int res = 0;\n\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            map.clear();\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n\n                int x = points[i][0] - points[j][0];\n                int y = points[i][1] - points[j][1];\n\n                int dist = x * x + y * y;\n                map.put(dist, map.getOrDefault(dist, 0) + 1);\n            }\n\n            for (int cnt : map.values())\n                res += cnt * (cnt - 1);\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322959802","body":"**code**\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] map = new int[128];\n        Arrays.fill(map, -1);\n        int maxLen = 0;\n\n        for (int right = 0, left = 0; right < s.length(); right++) {\n            char c = s.charAt(right);\n            if (map[c] != -1)\n                left = Math.max(left, map[c]);\n\n            maxLen = Math.max(maxLen, right - left + 1);\n            map[c] = right + 1;\n        }\n\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324587340","body":"**code**\n\n```java\n    public List<Integer> findSubstring(String s, String[] words) {\n        int sLen = s.length();\n        int n = words.length;\n        int wLen = words[0].length();\n\n        if (sLen < n * wLen) return List.of();\n\n        Map<String, Integer> counts = new HashMap<>();\n        for (String word : words)\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\n\n        List<Integer> ans = new ArrayList<>();\n\n        for (int i = 0; i <= sLen - n * wLen; i++) {\n            String sub = s.substring(i, i + n * wLen);\n            if (isConcat(sub, counts, wLen))\n                ans.add(i);\n        }\n\n        return ans;\n    }\n\n    private boolean isConcat(String sub, Map<String, Integer> counts, int wordLen) {\n        Map<String, Integer> seen = new HashMap<>();\n        for (int i = 0; i < sub.length(); i += wordLen) {\n            String sWord = sub.substring(i, i + wordLen);\n            if (!counts.containsKey(sWord)) return false;\n            \n            seen.put(sWord, seen.getOrDefault(sWord, 0) + 1);\n            if (seen.get(sWord) > counts.get(sWord)) return false;\n        }\n\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326929374","body":"**code**\n\n```java\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        long sum = 0L;\n        for (var num : nums) sum += num;\n        int mod = (int) ((sum % p + p) % p);\n        \n        if (mod == 0) return 0;\n        \n        int n = nums.length;\n        int ans = n;\n        sum = 0L;\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0 , -1);\n\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            int curM = (int) ((sum % p + p) % p);\n            map.put(curM, i);\n            \n            int targetM = curM - mod + (curM >= mod ? 0 : p);\n            if (map.containsKey(targetM))\n                ans = Math.min(ans, i - map.get(targetM));\n        }\n        \n        return ans == n ? -1 : ans;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934765","body":"**code**\n\n```java\n    public ListNode middleNode(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        return slow;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327979446","body":"**code**\n\n```java\n    public int removeDuplicates(int[] nums) {\n        int i = 0;\n        int j = 0;\n        while (i < nums.length) {\n            if (nums[i] == nums[j]) i++;\n            else {\n                j++;\n                nums[j] = nums[i];\n            }\n        }\n\n        return j + 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161843","body":"**code**\n\n```java\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target)\n                left = mid + 1;\n            else \n                right = mid;\n        }\n        \n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328411531","body":"**code**\n\n```java\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        Deque<Integer> queue = new ArrayDeque<>(k);\n\n        for (int i = 0; i < n; i++) {\n            if (!queue.isEmpty() && queue.getFirst() <= i - k)\n                queue.removeFirst();\n\n            while (!queue.isEmpty() && nums[queue.getLast()] < nums[i])\n                queue.removeLast();\n\n            queue.addLast(i);\n\n            if (i >= k - 1) res[i - k + 1] = nums[queue.getFirst()];\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330308452","body":"**thought**\n\nstar graph\n\n**code**\n\n```java\n    public int findJudge(int n, int[][] trust) {\n        int[] degrees = new int[n + 1];\n\n        for (int[] t : trust) {\n            degrees[t[0]]--;\n            degrees[t[1]]++;\n        }\n\n        for (int i = 1; i <= n; i++)\n            if (degrees[i] == n - 1) return i;\n        \n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331469161","body":"**code**\n\n```java\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] colors = new int[n]; // 0: hasn't to be visited yet\n        var graph = buildGraph(dislikes, n);\n\n        for (int i = 0; i < n; i++)\n            if (colors[i] == 0 && !setColor(graph, colors, i, 1))\n                return false;\n        \n        return true;\n    }\n\n    private List<List<Integer>> buildGraph(int[][] dislikes, int n) {\n        List<List<Integer>> graph = new ArrayList<>(n);\n        for (int i = 0; i < n; i++)\n            graph.add(new ArrayList<>());\n        \n        for (var edge : dislikes) {\n            int v = edge[0] - 1;\n            int w = edge[1] - 1;\n            graph.get(v).add(w);\n            graph.get(w).add(v);\n        }\n        \n        return graph;\n    }\n\n    private boolean setColor(List<List<Integer>> graph, int[] colors, int node, int color) {\n        if (colors[node] != 0) return colors[node] == color;\n        \n        colors[node] = color;\n        for (var neighbor : graph.get(node))\n            if (!setColor(graph, colors, neighbor, -color)) return false;\n        \n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333771130","body":"**code**\n\n```java\npublic int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n        \n        List<List<Integer>> groupAdj = new ArrayList<>(m);\n        List<List<Integer>> itemAdj = new ArrayList<>(n);\n\n        for (int i = 0; i < m; i++)\n            groupAdj.add(new ArrayList<>());\n\n        for (int i = 0; i < n; i++)\n            itemAdj.add(new ArrayList<>());\n\n        int[] groupsInDegree = new int[m];\n        int[] itemsInDegree = new int[n];\n\n        for (int i = 0; i < group.length; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj.get(beforeGroup).add(currentGroup);\n                    groupsInDegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int item : beforeItems.get(i)) {\n                itemAdj.get(item).add(i);\n                itemsInDegree[i]++;\n            }\n        }\n\n        var groupsList = topologicalSort(groupAdj, groupsInDegree, m);\n        if (groupsList.isEmpty()) return new int[0];\n\n        var itemsList = topologicalSort(itemAdj, itemsInDegree, n);\n        if (itemsList.isEmpty()) return new int[0];\n\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (int item : itemsList)\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n\n        List<Integer> res = new ArrayList<>();\n        for (int groupId : groupsList) {\n            if (!groups2Items.containsKey(groupId)) continue;\n            res.addAll(groups2Items.get(groupId));\n        }\n\n        return res.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<List<Integer>> adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>(n);\n        Queue<Integer> queue = new ArrayDeque<>(n);\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0)\n                queue.offer(i);\n        }\n\n        while (!queue.isEmpty()) {\n            int front = queue.poll();\n            res.add(front);\n            for (int successor : adj.get(front)) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0)\n                    queue.offer(successor);\n            }\n        }\n\n        return res.size() == n ? res : List.of();\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334786168","body":"**code**\n\n```java\n    public boolean judgeCircle(String moves) {\n        int[] coordinate = new int[2];\n        for (int i = 0; i < moves.length(); i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') coordinate[0]++;\n            else if (move == 'D') coordinate[0]--;\n            else if (move == 'L') coordinate[1]++;\n            else if (move == 'R') coordinate[1]--;\n        }\n        \n        return coordinate[0] == 0 && coordinate[1] == 0;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336115660","body":"**code**\n\nfirst edition\n\n```java\nclass Solution {\n    private static class Task {\n        private final int idx;\n        private final int enqueueTime;\n        private final int processingTime;\n        private Task(int idx, int enqueueTime, int processingTime) {\n            this.idx = idx;\n            this.enqueueTime = enqueueTime;\n            this.processingTime = processingTime;\n        }\n    }\n\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        LinkedList<Task> taskList = new LinkedList<>();\n        for (int i = 0; i < n; i++)\n            taskList.addLast(new Task(i, tasks[i][0], tasks[i][1]));\n\n        taskList.sort((a, b) -> {\n            if (a.enqueueTime != b.enqueueTime) return a.enqueueTime - b.enqueueTime;\n            if (a.processingTime != b.processingTime) return a.processingTime - b.processingTime;\n            return a.idx - b.idx;\n        });\n\n        PriorityQueue<Task> pq = new PriorityQueue<>((a, b) -> {\n            if (a.processingTime != b.processingTime) return a.processingTime - b.processingTime;\n            return a.idx - b.idx;\n        });\n\n        int finishTime = taskList.getFirst().enqueueTime;\n        int[] res = new int[n];\n        pq.offer(taskList.removeFirst());\n        int idx = 0;\n        \n        while (!pq.isEmpty()) {\n            var currentTask = pq.poll();\n            res[idx] = currentTask.idx;\n            idx++;\n            finishTime = Math.max(finishTime, currentTask.enqueueTime) + currentTask.processingTime;\n\n            while (!taskList.isEmpty() && taskList.getFirst().enqueueTime <= finishTime)\n                pq.offer(taskList.removeFirst());\n            \n            if (pq.isEmpty() && !taskList.isEmpty()) pq.offer(taskList.removeFirst());\n        }\n\n        return res;\n    }\n}\n```\n\n\nsecond edition\n\n```java\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        // {idx, enqueue time, processing time}\n        int[][] taskArr = new int[n][3];\n        for (int i = 0; i < n; i++)\n            taskArr[i] = new int[] {i, tasks[i][0], tasks[i][1]};\n\n        Arrays.sort(taskArr, (a, b) -> {\n            if (a[1] != b[1]) return a[1] - b[1];\n            if (a[2] != b[2]) return a[2] - b[2];\n            return a[0] - b[0];\n        });\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[2] != b[2] ? a[2] - b[2] : a[0] - b[0]);\n        int[] res = new int[n];\n        int curTime = taskArr[0][1];\n        int resIdx = 0;\n        int idx = 1;\n        minHeap.offer(taskArr[0]);\n\n        while (!minHeap.isEmpty()) {\n            var task = minHeap.poll();\n            res[resIdx] = task[0];\n            resIdx++;\n            curTime = Math.max(curTime, task[1]) + task[2];\n\n            while (idx < n && (taskArr[idx][1] <= curTime || minHeap.isEmpty())) {\n                minHeap.offer(taskArr[idx]);\n                idx++;\n            }\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336414239","body":"**code**\n\n```java\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int loginH = Integer.parseInt(loginTime.substring(0, 2));\n        int loginM = Integer.parseInt(loginTime.substring(3, 5));\n        int logoutH = Integer.parseInt(logoutTime.substring(0, 2));\n        int logoutM = Integer.parseInt(logoutTime.substring(3, 5));\n\n        int res = 0;\n        if (loginH > logoutH || loginH == logoutH && loginM > logoutM) {\n            res += (23 - loginH + logoutH) * 4;\n        } else {\n            res += (logoutH - loginH - 1) * 4;\n        }\n        res += (60 - loginM) / 15;\n        res += logoutM / 15;\n\n        return Math.max(res, 0);\n    }\n```\n\n```java\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        int loginMinutes = Integer.parseInt(loginTime.substring(0, 2)) * 60 + Integer.parseInt(loginTime.substring(3, 5));\n        int logoutMinutes = Integer.parseInt(logoutTime.substring(0, 2)) * 60 + Integer.parseInt(logoutTime.substring(3, 5));\n        \n        if (logoutMinutes < loginMinutes) \n            logoutMinutes += 24 * 60;\n        \n        logoutMinutes = logoutMinutes / 15 * 15;\n        return Math.max((logoutMinutes - loginMinutes) / 15, 0);\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336783283","body":"**code**\n\n```java\n    public int minCharacters(String a, String b) {\n        int an = a.length();\n        int[] aCount = new int[26];\n        for (int i = 0; i < an; i++)\n            aCount[a.charAt(i) - 'a']++;\n\n        int bn = b.length();\n        int[] bCount = new int[26];\n        for (int i = 0; i < bn; i++)\n            bCount[b.charAt(i) - 'a']++;\n\n        int ans = Integer.MAX_VALUE;\n        int aSum = 0;\n        int bSum = 0;\n        for (int i = 0; i < 25; i++) { // exclude 'z'\n            aSum += aCount[i];\n            bSum += bCount[i];\n\n            ans = Math.min(\n                    Math.min(ans, an - aCount[i] + bn - bCount[i]),\n                    Math.min(aSum + bn - bSum, an - aSum + bSum) // a > b & a < b\n            );\n        }\n\n        ans = Math.min(ans, an - aCount[25] + bn - bCount[25]);\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338674190","body":"**code**\n\nquicksort\n\n```java\n    public int[] sortArray(int[] nums) {\n        quicksort(nums);\n        return nums;\n    }\n\n    private void insertionSort(int[] nums, int left, int right) {\n        for (int i = left + 1; i < right + 1; i++) {\n            int temp = nums[i];\n            int j;\n            for (j = i; j > left && temp < nums[j - 1]; j--)\n                nums[j] = nums[j - 1];\n\n            nums[j] = temp;\n        }\n    }\n\n    private void quicksort(int[] nums) {\n        quicksort(nums, 0, nums.length - 1);\n    }\n\n    private void quicksort(int[] nums, int begin, int end) {\n        if (end - begin <= 7) {\n            insertionSort(nums, begin, end);\n            return;\n        }\n\n        int pivot = partition(nums, begin, end);\n        quicksort(nums, begin, pivot - 1);\n        quicksort(nums, pivot + 1, end);\n    }\n\n    private int partition(int[] nums, int left, int right) {\n        int mid = left + (right - left) / 2;\n        if (nums[left] > nums[mid]) swap(nums, left, mid);\n        if (nums[left] > nums[right]) swap(nums, left, right);\n        if (nums[mid] > nums[right]) swap(nums, mid, right);\n        swap(nums, left, mid);\n\n        int pivot = nums[left];\n        int lo = left + 1;\n        int hi = right;\n\n        while (true) {\n            //    while (lo <= hi && nums[lo] < pivot) lo++;\n            //    while (lo <= hi && nums[hi] > pivot) hi--;\n            //    while (lo <= right && nums[lo] < pivot) lo++;\n            //    while (hi > left && nums[hi] > pivot) hi--;\n\n            //    if (lo > hi) break;\n\n            while (nums[lo] < pivot) lo++;\n            while (nums[hi] > pivot) hi--;\n\n            if (lo >= hi) break;\n            swap(nums, lo, hi);\n            lo++;\n            hi--;\n        }\n\n        swap(nums, left, hi);\n        return hi;\n    }\n\n    private void swap(int[] nums, int idx1, int idx2) {\n        if (idx1 == idx2) return;\n\n        int temp = nums[idx1];\n        nums[idx1] = nums[idx2];\n        nums[idx2] = temp;\n    }\n```\n\n\nmergesort\n\n```java\n    public int[] sortArray(int[] nums) {\n        quicksort(nums);\n        return nums;\n    }\n\n    private void insertionSort(int[] nums, int left, int right) {\n        for (int i = left + 1; i < right + 1; i++) {\n            int temp = nums[i];\n            int j;\n            for (j = i; j > left && temp < nums[j - 1]; j--)\n                nums[j] = nums[j - 1];\n\n            nums[j] = temp;\n        }\n    }\n    \n    private void mergesort(int[] nums) {\n        int[] aux = new int[nums.length];\n        mergesort(nums, aux, 0, nums.length - 1);\n    }\n\n    private void mergesort(int[] nums, int[] aux, int begin, int end) {\n        if (end - begin <= 7) {\n            insertionSort(nums, begin, end);\n            return;\n        }\n\n        int mid = begin + (end - begin) / 2;\n        mergesort(nums, aux, begin, mid);\n        mergesort(nums, aux, mid + 1, end);\n\n        if (nums[mid] <= nums[mid + 1]) return;\n\n        merge(nums, aux, begin, mid, end);\n    }\n\n    private void merge(int[] nums, int[] aux, int lo, int mid, int hi) {\n        int i = lo;\n        int j = mid + 1;\n\n        System.arraycopy(nums, lo, aux, lo, hi - lo + 1);\n\n        for (int k = lo; k <= hi; k++) {\n            if (i > mid) nums[k] = aux[j++];\n            else if (j > hi) nums[k] = aux[i++];\n            else if (aux[j] < aux[i]) nums[k] = aux[j++];\n            else nums[k] = aux[i++];\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340282278","body":"**thought**\n\nNewton's method : Xn - f(Xn) / f'(Xn) = Xn+1  \nf(Xn) => x^2 - a\n\n**code**\n\nNewton's method\n\n```java\n    public int mySqrt(int x) {\n        long s = x;\n        while (s * s > x)\n            s = (s + x / s ) / 2;\n\n        return (int) s;\n    }\n```\n\nbinary search\n\n```java\n    public int mySqrt(int x) {\n        if (x <= 1) return x;\n\n        int left = 1;\n        int right = x;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (mid > x / mid)\n                right = mid;\n            else \n                left = mid + 1;\n        }\n        \n        return left - 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341898751","body":"**code**\n\n```java\n    public int firstBadVersion(int n) {\n        int left = 1;\n        int right = n;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            if (isBadVersion(mid))\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343961075","body":"**code**\n\n1. mergesort\n2. binary indexed tree\n\n\n```java\n    private int count;\n\n    public int reversePairs(int[] nums) {\n        count = 0;\n        mergesort(nums, new int[nums.length], 0, nums.length);\n        return count;\n    }\n\n    private void mergesort(int[] nums, int[] aux, int left, int right) {\n        if (left >= right) return;\n\n        int mid = left + (right - left) / 2;\n        mergesort(nums, aux, left, mid);\n        mergesort(nums, aux, mid + 1, right);\n\n        merge(nums, aux, left, mid, right);\n    }\n\n    private void merge(int[] nums, int[] aux, int left, int mid, int right) {\n        System.arraycopy(nums, left, aux, left, right - left + 1);\n\n        int end = mid + 1;\n        for (int i = left; i <= mid; i++) {\n            while (end <= right && nums[i] / 2.0 > nums[end]) end++;\n            count += end - mid - 1;\n        }\n\n        int lo = left;\n        int hi = mid + 1;\n        for (int i = left; i <= right; i++) {\n            if (lo > mid) nums[i] = aux[hi++];\n            else if (hi > right) nums[i] = aux[lo++];\n            else if (aux[lo] > aux[hi]) nums[i] = aux[hi++];\n            else nums[i] = aux[lo++];\n        }\n    }\n```\n\n```java\n    public int reversePairs(int[] nums) {\n        int n = nums.length;\n        int[] sorted = Arrays.copyOf(nums, n);\n        Arrays.sort(sorted);\n        int[] bit = new int[n + 1];\n\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            int index = getLastSmallerEqualPos(sorted, 2L * nums[i]);\n            res += i - query(bit, index + 1);\n            index = getLastSmallerEqualPos(sorted, nums[i]);\n            update(bit, index + 1);\n        }\n\n        return res;\n    }\n\n    private void update(int[] bit, int index) {\n        while (index < bit.length) {\n            bit[index]++;\n            index += lowbit(index);\n        }\n    }\n\n    private int query(int[] bit, int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += bit[index];\n            index -= lowbit(index);\n        }\n\n        return sum;\n    }\n\n    private int lowbit(int x) {\n        return x & (-x);\n    }\n\n    /**\n     * arr = {1, 3, 7, 7, 7, 8}\n     * getLastSmallerEqualPos(arr, 7) = 4\n     */\n    private int getLastSmallerEqualPos(int[] sorted, long searched) {\n        int left = 0;\n        int right = sorted.length;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (searched + 1 <= sorted[mid])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left - 1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345195940","body":"**code**\r\n\r\n1. 796 Minimum Light Radius\r\n2. 475 Heaters\r\n3. 475 Heaters\r\n\r\n```java\r\n    public double findRadius(int[] lights) {\r\n        Arrays.sort(lights);\r\n        int left = 0;\r\n        int right = (lights[lights.length - 1] - lights[0] + 2) / 3;\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            if (feasible(lights, mid))\r\n                right = mid;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n\r\n        return left / 2.0;\r\n    }\r\n\r\n    private boolean feasible(int[] lights, int diameter) {\r\n        int lightDist = lights[0] + diameter;\r\n        for (int i = 0; i < 3; i++) {\r\n            int idx = Arrays.binarySearch(lights, lightDist);\r\n            if (idx < 0) idx = -idx - 1;\r\n            if (idx >= lights.length) return true;\r\n\r\n            lightDist = lights[idx] + diameter;\r\n        }\r\n\r\n        return false;\r\n    }\r\n```\r\n\r\n```java\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        int res = 0;\r\n        Arrays.sort(heaters);\r\n        for (int house : houses) {\r\n            int rightHeater = binarySearch(heaters, house);\r\n            int leftHeater = rightHeater - 1;\r\n            int leftDist = leftHeater < 0 ? Integer.MAX_VALUE : house - heaters[leftHeater];\r\n            int rightDist = rightHeater >= heaters.length ? Integer.MAX_VALUE : heaters[rightHeater] - house;\r\n            int curDist = Math.min(leftDist, rightDist);\r\n            res = Math.max(res, curDist);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n\r\n    private int binarySearch(int[] nums, int target) {\r\n        int left = 0;\r\n        int right = nums.length;\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            if (nums[mid] > target)\r\n                right = mid;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n\r\n        return left;\r\n    }\r\n```\r\n\r\n```java\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        Arrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n\r\n        int left = 0;\r\n        int right = Math.max(houses[houses.length - 1] - houses[0], heaters[heaters.length - 1]);\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n\r\n            if (feasible(houses, heaters, mid))\r\n                right = mid;\r\n            else \r\n                left = mid + 1;\r\n        }\r\n        \r\n        return left;\r\n    }\r\n\r\n    private boolean feasible(int[] houses, int[] heaters, int radius) {\r\n        for (int i = 0, j = 0; i < houses.length; i++) {\r\n            while (j < heaters.length && houses[i] > heaters[j] + radius) j++;\r\n            if (j < heaters.length && houses[i] >= heaters[j] - radius && houses[i] <= heaters[j] + radius)\r\n                continue;\r\n\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345488756","body":"**code**\n\n```java\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n\n        int left = 0;\n        int right = nums[nums.length - 1] - nums[0];\n\n        while (left < right) {\n            int mid = (left + right) >>> 1;\n            \n            if (enough(nums, mid, k))\n                right = mid;\n            else \n                left = mid + 1;\n        }\n        \n        return left;\n    }\n\n    private boolean enough(int[] nums, int dist, int k) {\n        int count = 0;\n        int left = 0;\n        int right = 0;\n        while (left < nums.length || right < nums.length) {\n            while (right < nums.length && nums[right] - nums[left] <= dist)\n                right++;\n\n            count += right - left - 1;\n            left++;\n        }\n\n        return count >= k;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345784683","body":"**code**\r\n\r\n1. binary search + dfs\r\n2. dijkstra\r\n\r\n```java\r\nclass Solution {\r\n    private static final int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\r\n    \r\n    public int swimInWater(int[][] grid) {\r\n        int n = grid.length;\r\n        int left = grid[0][0];\r\n        int right = n * n - 1;\r\n\r\n        while (left < right) {\r\n            int mid = left + (right - left) / 2;\r\n            if (feasible(grid, 0, 0, new boolean[n][n], mid))\r\n                right = mid;\r\n            else\r\n                left = mid + 1;\r\n        }\r\n\r\n        return left;\r\n    }\r\n    \r\n    private boolean feasible(int[][] grid, int x, int y, boolean[][] visited, int depth) {\r\n        visited[x][y] = true;\r\n        for (var dir : dirs) {\r\n            int row = x + dir[0];\r\n            int col = y + dir[1];\r\n            if (row >= 0 && row < grid.length && col >= 0 && col < grid.length\r\n                && !visited[row][col] && grid[row][col] <= depth) {\r\n                if (row == grid.length - 1 && col == grid.length - 1) return true;\r\n\r\n                if (feasible(grid, row, col, visited, depth)) return true;\r\n            }\r\n        }\r\n        \r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass Solution {\r\n    private static final int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\r\n\r\n    public int swimInWater(int[][] grid) {\r\n        int n = grid.length;\r\n\r\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(i -> grid[i[0]][i[1]]));\r\n        minHeap.offer(new int[] {0, 0});\r\n\r\n        boolean[][] visited = new boolean[n][n];\r\n        int[][] dist = new int[n][n];\r\n        for (int[] row : dist)\r\n            Arrays.fill(row, n * n);\r\n\r\n        dist[0][0] = grid[0][0];\r\n\r\n        while (!minHeap.isEmpty()) {\r\n            int[] v = minHeap.poll();\r\n            int x = v[0];\r\n            int y = v[1];\r\n            if (visited[x][y]) continue;\r\n\r\n            visited[x][y] = true;\r\n            if (x == n - 1 && y == n - 1) return dist[n - 1][n - 1];\r\n\r\n            for (int[] dir : dirs) {\r\n                int row = x + dir[0];\r\n                int col = y + dir[1];\r\n                if (row >= 0 && row < n && col >= 0 && col < n\r\n                    && Math.max(dist[x][y], grid[row][col]) < dist[row][col]) {\r\n                    dist[row][col] = Math.max(dist[x][y], grid[row][col]);\r\n                    minHeap.offer(new int[] {row, col});\r\n                }\r\n            }\r\n        }\r\n\r\n        return -1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347624213","body":"**code**\n\n```java\n    public int maxVowels(String s, int k) {\n        int res = 0;\n        int cnt = 0;\n        Set<Character> vowels = Set.of('a', 'e', 'i', 'o', 'u');\n        for (int i = 0; i < s.length(); i++) {\n            cnt += vowels.contains(s.charAt(i)) ? 1 : 0;\n\n            if (i >= k) cnt -= vowels.contains(s.charAt(i - k)) ? 1 : 0;\n\n            res = Math.max(res, cnt);\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350647267","body":"**code**\n\n```java\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) return 1;\n\n        double[] dp = new double[k + maxPts];\n        double sum = 0;\n        for (int i = k; i < k + maxPts; i++) {\n            if (i <= n) dp[i] = 1;\n            sum += dp[i];\n        }\n\n        for (int i = k - 1; i >= 0; i--) {\n            dp[i] = sum / maxPts;\n            sum = sum - dp[i + maxPts] + dp[i];\n        }\n\n        return dp[0];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353315075","body":"class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        if (p.length() > s.length()) return List.of();\n\n        List<Integer> ans = new ArrayList<>();\n\n        int[] counts = new int[26];\n        for (int i = 0; i < p.length(); i++) {\n            counts[p.charAt(i) - 'a']++;\n            counts[s.charAt(i) - 'a']--;\n        }\n\n        if (allZero(counts)) ans.add(0);\n\n        for (int i = 0; i < s.length() - p.length(); i++) {\n            counts[s.charAt(i) - 'a']++; // pull out\n            counts[s.charAt(i + p.length()) - 'a']--; // push in\n            if (allZero(counts)) ans.add(i + 1);\n        }\n        \n        return ans;\n    }\n\n    private boolean allZero(int[] counts) {\n        for (int c : counts)\n            if (c != 0) return false;\n\n        return true;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354337910","body":"**code**\n\n```java\n    public String minWindow(String s, String t) {\n        if (t.length() > s.length()) return \"\";\n\n        int[] cnt = new int[128];\n        for (int i = 0; i < t.length(); i++)\n            cnt[t.charAt(i)]++;\n\n        int need = t.length();\n        int size = s.length() + 1;\n        int start = 0;\n        int l = 0;\n        for (int r = 0; r < s.length(); r++) {\n            char c = s.charAt(r);\n            if (cnt[c] > 0) need--;\n\n            cnt[c]--; // push in\n\n            if (need != 0) continue;\n\n            while (l < r && cnt[s.charAt(l)] < 0) {\n                cnt[s.charAt(l)]++; // pull out\n                l++;\n            }\n\n            if (r - l + 1 < size) {\n                size = r - l + 1;\n                start = l;\n            }\n\n            cnt[s.charAt(l)]++;\n            l++;\n            need++;\n        }\n\n        return size != s.length() + 1 ? s.substring(start, start + size) : \"\";\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356109359","body":"**code**\n\n```java\n    public int minOperations(int[] nums, int x) {\n        int target = 0;\n        for (int num : nums) target += num;\n        target -= x;\n\n        int sumOfWindow = 0;\n        int maxLen = -1;\n        for (int right = 0, left = 0; right < nums.length; right++) {\n            sumOfWindow += nums[right];\n            while (left <= right && sumOfWindow > target) {\n                sumOfWindow -= nums[left];\n                left++;\n            }\n\n            if (sumOfWindow == target)\n                maxLen = Math.max(maxLen, right - left + 1);\n        }\n\n        return maxLen != -1 ? nums.length - maxLen : -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356722975","body":"**code**\n\n```java\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++) {\n                if (bitCount(i) + bitCount(j) == turnedOn)\n                    res.add(i + \":\" + (j <= 9 ? \"0\" + j : j));\n            }\n        }\n\n        return res;\n    }\n\n    private int bitCount(int num) {\n        int count = 0;\n        while (num > 0) {\n            num = num & (num - 1); // num -= num & (-num);\n            count++;\n        }\n\n        return count;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357160300","body":"**code**\n\n```java\n    public int totalNQueens(int n) {\n        char[][] board = new char[n][n];\n        for (char[] row : board) Arrays.fill(row, '.');\n\n        return nQueensBacktrack(n, 0, board);\n    }\n\n    private int nQueensBacktrack(int n, int row, char[][] board) {\n        if (n == row) {\n            return 1;\n        }\n\n        int count = 0;\n        for (int col = 0; col < n && row < n; col++) {\n            if (!feasible(n, board, row, col)) continue;\n\n            board[row][col] = 'Q';\n            count += nQueensBacktrack(n, row + 1, board);\n            board[row][col] = '.';\n        }\n        \n        return count;\n    }\n\n    private boolean feasible(int n, char[][] board, int row, int col) {\n        for (int i = row - 1; i >= 0; i--)\n            if (board[i][col] == 'Q') return false;\n\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--)\n            if (board[i][j] == 'Q') return false;\n\n        for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++)\n            if (board[i][j] == 'Q') return false;\n\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358798765","body":"1. union find\n2. dfs\n\n**code**\n\n```java\nclass Solution {\n    private final static int[][] dirs = {{1, 0}, {0, 1}};\n    private int[] parent;\n    private int[] size;\n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (m == 1 && n == 1) return grid[0][0];\n\n        parent = new int[m * n];\n        size = new int[m * n];\n        for (int i = 0; i < m * n; i++) {\n            parent[i] = i;\n            size[i] = 1;\n        }\n\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] != 1) continue;\n\n                ans = Math.max(ans, grid[i][j]);\n                \n                for (int[] dir : dirs) {\n                    int i2 = i + dir[0];\n                    int j2 = j + dir[1];\n\n                    if (i2 >= 0 && i2 < m && j2 >= 0 && j2 < n && grid[i2][j2] == 1)\n                        ans = Math.max(ans, union(i * n + j, i2 * n + j2));\n                }\n            }\n        }\n        \n        return ans;\n    }\n\n    private int find(int p) {\n        if (parent[p] != p) parent[p] = find(parent[p]);\n        return parent[p];\n    }\n\n    private int union(int p, int q) {\n        int pRoot = find(p);\n        int qRoot = find(q);\n        if (pRoot == qRoot) return size[pRoot];\n\n        if (size[pRoot] >= size[qRoot]) {\n            parent[qRoot] = pRoot;\n            size[pRoot] += size[qRoot];\n            return size[pRoot];\n        } else {\n            parent[pRoot] = qRoot;\n            size[qRoot] += size[pRoot];\n            return size[qRoot];\n        }\n    }\n}\n```\n\n```java\n    public int maxAreaOfIsland(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int maxArea = 0;\n\n        for (int i = 0; i < rows; i++)\n            for (int j = 0; j < cols; j++)\n                if (grid[i][j] == 1)\n                    maxArea = Math.max(maxArea, getArea(grid, i, j));\n\n        return maxArea;\n    }\n\n    private int getArea(int[][] grid, int x, int y) {\n        grid[x][y] = 0;\n        int area = 1;\n        \n        for (int[] dir : DIRS) {\n            int x1 = x + dir[0];\n            int y1 = y + dir[1];\n            \n            if (x1 >= 0 && x1 < grid.length && y1 >= 0 && y1 < grid[0].length\n                    && grid[x1][y1] == 1)\n                area += getArea(grid, x1, y1);\n        }\n        \n        return area;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361556433","body":"**code**\n1. bfs\n2. dijkstra\n\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int maxDistance(int[][] grid) {\n        int n = grid.length;\n        boolean[][] seen = new boolean[n][n];\n        Queue<int[]> queue = new ArrayDeque<>(n * n);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[] {i, j});\n                    seen[i][j] = true;\n                }\n            }\n        }\n        \n        if (queue.size() == 0 || queue.size() == n * n) return -1;\n\n        int dist = 0;\n        while (!queue.isEmpty()) {\n            dist++;\n            for (int size = queue.size(); size > 0; size--) {\n                var coordinate = queue.poll();\n                for (int[] dir : DIRS) {\n                    int x = coordinate[0] + dir[0];\n                    int y = coordinate[1] + dir[1];\n                    if (x >= 0 && x < n && y >= 0 && y < n && !seen[x][y] && grid[x][y] == 0) {\n                        queue.offer(new int[] {x, y});\n                        seen[x][y] = true;\n                    }\n                }\n            }\n        }\n\n        return dist - 1;\n    }\n```\n\n```java\n    private static final int[][] DIRS = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n\n    public int maxDistance(int[][] grid) {\n        int n = grid.length;\n        int[][] dist = new int[n][n];\n        Queue<int[]> queue = new PriorityQueue<>(n * n, Comparator.comparingInt(a -> a[0]));\n        boolean[][] seen = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = Integer.MAX_VALUE;\n                if (grid[i][j] == 1) {\n                    dist[i][j] = 0;\n                    queue.offer(new int[] {0, i, j});\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            var p = queue.poll();\n            int x = p[1];\n            int y = p[2];\n\n            if (seen[x][y]) continue;\n            seen[x][y] = true;\n\n            for (int[] dir : DIRS) {\n                int nx = p[1] + dir[0];\n                int ny = p[2] + dir[1];\n                if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\n                if (p[0] + 1 < dist[nx][ny]) {\n                    dist[nx][ny] = p[0] + 1;\n                    queue.offer(new int[] {dist[nx][ny], nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j)\n                if (grid[i][j] == 0)\n                    ans = Math.max(ans, dist[i][j]);\n\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362293310","body":"**code**\n\n```java\n    public int findShortestCircleContainingTarget(List<List<Integer>> graph, int target) {\n        Queue<Integer> queue = new ArrayDeque<>();\n        Set<Integer> seen = new HashSet<>();\n        queue.offer(target);\n\n        int len = 0;\n        while (!queue.isEmpty()) {\n            len++;\n            for (int size = queue.size(); size > 0; size--) {\n                var cur = queue.poll();\n                seen.add(cur);\n\n                for (var next : graph.get(cur)) {\n                    if (!seen.contains(next))\n                        queue.offer(next);\n                    else if (next == target)\n                        return len;\n                }\n            }\n        }\n\n        return -1;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363544307","body":"**code**\n\n```java\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        Map<Integer, List<int[]>> map = new TreeMap<>();\n        Queue<TreeNode> queue = new ArrayDeque<>();\n        Queue<Integer> queueOfCol = new ArrayDeque<>();\n        queue.offer(root);\n        queueOfCol.offer(0);\n\n        int row = 0;\n        while (!queue.isEmpty()) {\n            for (int size = queue.size(); size > 0; size--) {\n                var cur = queue.poll();\n                var col = queueOfCol.poll();\n                assert col != null;\n\n                map.computeIfAbsent(col, i -> new ArrayList<>()).add(new int[] {row, cur.val});\n\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                    queueOfCol.offer(col - 1);\n                }\n\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                    queueOfCol.offer(col + 1);\n                }\n            }\n            \n            row++;\n        }\n\n        List<List<Integer>> ans = new ArrayList<>(map.size());\n        map.values().forEach(list -> {\n            list.sort((a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\n            List<Integer> cur = new ArrayList<>();\n            list.forEach(v -> cur.add(v[1]));\n\n            ans.add(cur);\n        });\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364454357","body":"**code**\n\n```java\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n + 1];\n\n        for (int i = 2; i <= n; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        \n        return dp[n];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364623519","body":"**code**\n\n```java\n    public int rob(int[] nums) {\n        int n = nums.length;\n        if (n == 1) return nums[0];\n        \n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n\n        return dp[n - 1];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364957812","body":"**code**\n\n```java\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] f = new int[n];\n        int[] g = new int[n];\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            f[i] = g[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (f[i] < f[j] + 1) {\n                        f[i] = f[j] + 1;\n                        g[i] = g[j];\n                    } else if (f[i] == f[j] + 1) {\n                        g[i] += g[j];\n                    }\n                }\n            }\n\n            max = Math.max(max, f[i]);\n        }\n\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (f[i] == max) ans += g[i];\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365577786","body":"**code**\n\n```java\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n\n        int[] dp = new int[n + 1];\n        for (int j = 1; j <= m; j++) {\n            int prev = dp[0];\n            for (int i = 1; i <= n; i++) {\n                int tmp = dp[i];\n                if (text1.charAt(j - 1) == text2.charAt(i - 1))\n                    dp[i] = prev + 1;\n                else\n                    dp[i] = Math.max(dp[i], dp[i - 1]);\n\n                prev = tmp;\n            }\n        }\n\n        return dp[n];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366339676","body":"**code**\n\n```java\n    public int uniquePaths(int m, int n) {\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[j] = dp[j - 1] + dp[j];\n            }\n        }\n\n        return dp[n - 1];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367058813","body":"**code**\n\n```java\nclass Solution {\n    private static final int[][] DIRS = new int[][]{{-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {-2, 1}, {-2, -1}, {2, 1}, {2, -1}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        return dfs(n, row, column, k, new double[n][n][k + 1]);\n    }\n\n    private double dfs(int n, int x, int y, int k, double[][][] memo) {\n        if (x < 0 || x >= n || y < 0 || y >= n) return 0D;\n\n        if (k == 0) return 1D;\n\n        if (memo[x][y][k] != 0) return memo[x][y][k];\n\n        double ans = 0D;\n\n        for (int[] dir : DIRS) {\n            ans += dfs(n, x + dir[0], y + dir[1], k - 1, memo) / 8D;\n        }\n        \n        memo[x][y][k] = ans;\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367752885","body":"**code**\n\n```java\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger >= desiredTotal)\n            return true;\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal)\n            return false;\n\n        return dfs(0, 0, maxChoosableInteger, desiredTotal, new int[1 << 21]);\n    }\n\n    private boolean dfs(int state, int sum, int maxChoosableInteger, int desiredTotal, int[] visited) {\n        if (visited[state] == 1) return true;\n        if (visited[state] == 2) return false;\n\n        for (int num = 1; num <= maxChoosableInteger; num++) {\n            if (((state >> num) & 1) == 1) continue;\n\n            if (sum + num >= desiredTotal) {\n                visited[state] = 1;\n                return true;\n            }\n\n            if (!dfs(state | (1 << num), sum + num, maxChoosableInteger, desiredTotal, visited)) {\n                visited[state] = 1;\n                return true;\n            }\n        }\n\n        visited[state] = 2;\n        return false;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1379868685","body":"**code**\n1. memorization search\n2. bottom up dp\n\n```java\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n\n        if ((sum & 1) == 1) return false;\n\n        return dfs(nums, sum / 2, 0, new Boolean[nums.length][sum / 2 + 1]);\n    }\n\n    private boolean dfs(int[] nums, int sum, int index, Boolean[][] dp) {\n        if (index == nums.length || sum < 0) return false;\n\n        if (dp[index][sum] != null) return dp[index][sum];\n\n        if (sum == 0) {\n            dp[index][sum] = true;\n            return true;\n        }\n\n        for (int i = index; i < nums.length; i++) {\n            if (dfs(nums, sum - nums[i], i + 1, dp)) {\n                dp[i][sum] = true;\n                return true;\n            } else \n                dp[i][sum] = false;\n        }\n\n        dp[index][sum] = false;\n        return dp[index][sum];\n    }\n```\n\n```java\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n        if ((sum & 1) == 1) return false;\n\n        int n = nums.length;\n        int target = sum / 2;\n        boolean[] dp = new boolean[target + 1];\n\n        dp[0] = true;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = target; j >= nums[i]; j--) {\n                dp[j] |= dp[j - nums[i]];\n            }\n        }\n\n        return dp[target];\n    }\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368413074","body":"**code**\n\n```java\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int num : nums) sum += num;\n        if ((sum + target) % 2 != 0 || sum < Math.abs(target)) return 0;\n\n        int positive = (sum + target) / 2;\n\n        int n = nums.length;\n        int[] dp = new int[positive + 1];\n        dp[0] = 1;\n\n        for (int num : nums) {\n            for (int j = positive; j >= num; j--) {\n                dp[j] += dp[j - num];\n            }\n        }\n\n        return dp[positive];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368712770","body":"**code**\n\n```java\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i - coin < 0) continue;\n\n                dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n            }\n        }\n\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369437486","body":"**code**\n\n```java\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        \n        return dp[amount];\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370400785","body":"**code**\n\n```java\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0;\n        int j = 0;\n        while (i < g.length && j < s.length) {\n            if (g[i] <= s[j]) i++;\n            j++;\n        }\n\n        return i;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372193364","body":"**code**\n\n```java\n    public int eraseOverlapIntervals(int[][] intervals) {\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[1]));\n\n        int res = 0;\n        int i = 0;\n        while (i < intervals.length) {\n            int j = i + 1;\n            int cur = intervals[i][1];\n            while (j < intervals.length && cur > intervals[j][0]) {\n                j++;\n                res++;\n            }\n\n            i = j;\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373535514","body":"**code**\n\n```java\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n\n        int res = 0;\n        int left = 0;\n        int right = people.length - 1;\n        while (left <= right) {\n            if (people[left] + people[right] <= limit) {\n                left++;\n            }\n            right--;\n            res++;\n        }\n\n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374443751","body":"**code**\n\n```java\n    public int numTrees(int n) {\n        return dfs(n, new int[n + 1]);\n    }\n\n    private int dfs(int n, int[] dp) {\n        if (n == 0 || n == 1) return 1;\n\n        if (dp[n] != 0) return dp[n];\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            count += dfs(i - 1, dp) * dfs(n - i, dp);\n        }\n        \n        dp[n] = count;\n        return count;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374693329","body":"**code**\n\n1. dive and conquer\n2. min heap\n\n```java\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) return null;\n\n        return mergeKLists(lists, 0, lists.length - 1);\n    }\n\n    private ListNode mergeKLists(ListNode[] lists, int begin, int end) {\n        if (begin >= end) return lists[begin];\n\n        int mid = (begin + end) >>> 1;\n        ListNode left = mergeKLists(lists, begin, mid);\n        ListNode right = mergeKLists(lists, mid + 1, end);\n        return mergeList(left, right);\n    }\n\n    private ListNode mergeList(ListNode left, ListNode right) {\n        ListNode dummny = new ListNode(-1);\n        var cur = dummny;\n\n        while (left != null && right != null) {\n            if (right.val < left.val) {\n                cur.next = right;\n                right = right.next;\n            } else {\n                cur.next = left;\n                left = left.next;\n            }\n\n            cur = cur.next;\n        }\n\n        cur.next = left != null ? left : right;\n\n        return dummny.next;\n    }\n```\n\n```java\n    public ListNode mergeKLists(ListNode[] lists) {\n        var minHeap = new PriorityQueue<ListNode>(Comparator.comparingInt(a -> a.val));\n\n        for (var head : lists)\n            if (head != null) minHeap.offer(head);\n\n        ListNode dummy = new ListNode(-1);\n        var cur = dummy;\n        while (!minHeap.isEmpty()) {\n            cur.next = minHeap.poll();\n\n            cur = cur.next;\n            if (cur.next != null) minHeap.offer(cur.next);\n        }\n\n        return dummy.next;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375074016","body":"**code**\n\n```java\n    public int[] beautifulArray(int n) {\n        int[] arr = new int[n];\n        Arrays.fill(arr, 1);\n        part(arr, 0, n - 1);\n        return arr;\n    }\n    \n    private void part(int[] arr, int lo, int hi) {\n        if (hi <= lo) return;\n        \n        int mid = (lo + hi) >>> 1;\n        part(arr, lo, mid);\n        part(arr, mid + 1, hi);\n\n        for (int i = lo; i <= mid; i++) {\n            arr[i] = 2 * arr[i] - 1;\n        }\n\n        for (int i = mid + 1; i <= hi; i++) {\n            arr[i] = 2 * arr[i];\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376758676","body":"**code**\n\n```java\n    public int[] singleNumber(int[] nums) {\n        int xor = 0;\n        for (int num : nums) xor ^= num;\n        \n        int num1 = 0;\n        int lowbit = xor & (-xor);\n        for (int num : nums) {\n            if ((num & lowbit) == 0) num1 ^= num;\n        }\n        \n        return new int[] {xor ^ num1, num1};\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378806920","body":"平时回溯写得多，状态压缩写的少了\n\n**code**\n\n```java\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n\n        for (int i = 0; i < (1 << nums.length); i++) {\n            List<Integer> sub = new ArrayList<>();\n\n            for (int j = 0; j < nums.length; j++) {\n                if (((1 << j) & i) != 0)\n                    sub.add(nums[j]);\n            }\n            \n            res.add(sub);\n        }\n        \n        return res;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379776657","body":"**code**\n\n```java\nclass Trie {\n    private final Trie[] children;\n    private boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;\n    }\n\n    public void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                node.children[idx] = new Trie();\n\n            node = node.children[idx];\n        }\n\n        node.isEnd = true;\n    }\n\n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n\n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null)\n                return null;\n\n            node = node.children[idx];\n        }\n\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381278923","body":"**code**\n\n```java\nclass MapSum {\n    private final MapSum[] children;\n    private final Map<String, Integer> map;\n    private int val;\n\n    public MapSum() {\n        children = new MapSum[26];\n        map = new HashMap<>();\n        val = 0;\n    }\n\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        MapSum node = this;\n        for (char c : key.toCharArray()) {\n            int idx = c - 'a';\n\n            if (node.children[idx] == null)\n                node.children[idx] = new MapSum();\n\n            node = node.children[idx];\n            node.val += delta;\n        }\n    }\n\n    public int sum(String prefix) {\n        MapSum node = this;\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n\n            if (node.children[idx] == null) return 0;\n\n            node = node.children[idx];\n        }\n\n        return node.val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382669568","body":"**code**\n\n```java\n    public int[][] multiSearch(String big, String[] smalls) {\n        Trie trie = new Trie();\n\n        for (int i = 0; i < smalls.length; i++)\n            trie.insert(smalls[i], i);\n\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < smalls.length; i++)\n            ans.add(new ArrayList<>());\n\n        for (int i = 0; i < big.length(); i++) {\n            for (var id : trie.prefixIDs(big.substring(i))) {\n                ans.get(id).add(i);\n            }\n        }\n\n        return ans.stream()\n                .map(arr -> arr.stream().mapToInt(i -> i).toArray())\n                .toArray(int[][]::new);\n    }\n\n    private static class Trie {\n        private final Trie[] children;\n        private boolean isEnd;\n        private int id;\n\n        private Trie() {\n            children = new Trie[26];\n            isEnd = false;\n            id = -1;\n        }\n\n        private void insert(String word, int id) {\n            if (word.isBlank()) return;\n\n            Trie node = this;\n            for (char c : word.toCharArray()) {\n                int idx = c - 'a';\n                if (node.children[idx] == null)\n                    node.children[idx] = new Trie();\n\n                node = node.children[idx];\n            }\n\n            node.isEnd = true;\n            node.id = id;\n        }\n\n        private List<Integer> prefixIDs(String search) {\n            Trie node = this;\n            List<Integer> ids = new ArrayList<>();\n            for (char c : search.toCharArray()) {\n                int idx = c - 'a';\n\n                if (node.isEnd) ids.add(node.id);\n\n                if (node.children[idx] == null) return ids;\n\n                node = node.children[idx];\n            }\n\n            if (node.isEnd) ids.add(node.id);\n            return ids;\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383042802","body":"**code**\n1. dfs\n2. union find\n\n```java\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (visited[i]) continue;\n            \n            dfs(isConnected, i, visited);\n            count++;\n        }\n        \n        return count;\n    }\n    \n    private void dfs(int[][] isConnected, int i, boolean[] visited) {\n        for (int j = 0; j < isConnected.length; j++) {\n            if (isConnected[i][j] == 1 && !visited[j]) {\n                visited[j] = true;\n                dfs(isConnected, j, visited);\n            }\n        }\n    }\n```\n\n```java\n    private int[] parent;\n    private int[] rank;\n\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        parent = new int[n];\n        rank = new int[n];\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (isConnected[i][j] == 1)\n                    count = union(i, j) ? count + 1 : count;\n\n        return n - count;\n    }\n\n    private int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    private boolean union(int p, int q) {\n        int qRoot = find(q);\n        int pRoot = find(p);\n\n        if (qRoot == pRoot) return false;\n        \n        if (rank[pRoot] >= rank[qRoot])\n            parent[qRoot] = parent[pRoot];\n        else\n            parent[pRoot] = parent[qRoot];\n\n        if (rank[pRoot] == rank[qRoot])\n            rank[pRoot]++;\n        \n        return true;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297909848","body":"## 思路\n从最后一位开始模拟加法运算，低位数字在数组原地保存，超出数组长度的先存到一个栈里，最后先从栈里弹出高位，最后遍历数组得到低位\n\n## 代码\n``` Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        int n = nums.length;\n        int add = 0;\n        List<Integer> ans = new ArrayList<>();\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0 || k > 0; i--, k /= 10) {\n            int sum = (i >= 0 ? nums[i] : 0) + k % 10 + add;\n            int cur = sum % 10;\n            add = sum / 10;\n            if (i >= 0) nums[i] = cur;\n            else stack.push(cur);\n        }\n        if (add != 0) stack.push(add);\n        while (!stack.isEmpty()) ans.add(stack.poll());\n        for (int num : nums) ans.add(num);\n        return ans;\n    }\n} \n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299437009","body":"## 思路\n两次遍历：从头到尾扫描，标记前面最近的c的位置lc，用当前id减去lc作为答案；从尾到头扫描，标记后面最近的c的位置rc，用当前rc减去当前id，取第一次扫描和当前计算结果的最小值\n\n## 代码\n``` Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int lc = -n;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) lc = i;\n            ans[i] = i - lc;\n        }\n        int rc = 2 * n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) rc = i;\n            ans[i] = Math.min(ans[i], rc - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301743466","body":"## 思路 \n1. 基本思路：用数组模拟栈，栈底增量操作可以通过遍历实现\n2. 优化：用一个同样规模的数组保存从此位置到栈底的增量，当pop栈顶元素时，将此增量向栈底增量传递，不要忘记同时需要清零此位置的增量，类似差分数组的思想。\n\n## 代码\n```  Java\nclass CustomStack {\n    int[] stack;\n    int top = -1;\n    int[] topAdd;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        topAdd = new int[maxSize];\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top + 1 < maxSize) stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        if (top - 1 >= 0) topAdd[top-1] += topAdd[top];\n        int res = topAdd[top] + stack[top];\n        topAdd[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int pos = Math.min(k - 1, top);\n        if (pos == -1) return;\n        topAdd[pos] += val;\n    }\n}\n\n```\n\n## 复杂度\n* 时间复杂度：O(1)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303030423","body":"## 思路\n当遇到左括号时，需要用栈保存前面的解码结果，即用到一个字符串栈，同时需要保存前面的次数，即用到一个数量栈；遇到右括号时，数量栈顶为当前字符串的重复次数。\n\n## 代码\n``` Java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> cStack = new ArrayDeque<>();\n        Deque<Integer> numStack = new ArrayDeque<>();\n        int num = 0;\n        String ans = \"\";\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } \n            else if (Character.isLetter(c)) {\n                ans += c;\n            }\n            else if (c == '[') {\n                numStack.push(num);\n                num = 0;\n                cStack.push(ans);\n                ans = \"\";\n            }\n            else if (c == ']') {\n                int cnt = numStack.pop();\n                String str = cStack.pop();\n                for (int i = 1; i <= cnt; i++) {\n                    str += ans;\n                }\n                ans = str;\n            }\n        }\n        return ans;\n    }\n}\n\n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304392085","body":"## 思路\n一个栈模拟队列尾部，负责进入元素；一个栈模拟队列头部，负责出元素；头栈没有元素时，将尾栈的元素全部弹入头栈\n## 代码\n``` Java\nclass MyQueue {\n    Deque<Integer> tail;\n    Deque<Integer> head;\n\n    public MyQueue() {\n        tail = new ArrayDeque<>();\n        head = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        tail.push(x);\n    }\n    \n    public int pop() {\n        tailToHead();\n        return head.pop();\n    }\n    \n    public int peek() {\n        tailToHead();\n        return head.peek();\n    }\n\n    public void tailToHead() {\n        if (!head.isEmpty()) return; \n        while (!tail.isEmpty()) {\n            head.push(tail.pop());\n        }\n    }\n    \n    public boolean empty() {\n        return tail.isEmpty() && head.isEmpty();\n    }\n}\n```\n## 复杂度\n* 时间：O(1)\n* 空间：O(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309905733","body":"## 思路\n双指针，将两个链表拼起来走，当两个指针相等时停止。当有相交点时，在首个相交点停止；当没有相交点时，会在最后的空指针位置停止\n## 代码\n``` Java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p = headA, q = headB;\n        while (p != q) {\n            if (p == null) p = headB;\n            else p = p.next;\n            if (q == null) q = headA;\n            else q = q.next;\n        }\n        return p;\n    }\n}\n```\n## 复杂度\n* 时间：o(n)\n* 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311162575","body":"## 思路\r\n快慢指针，设起始点到环入口的距离，环入口点到快慢指针相遇点的距离，快慢指针相遇点到环入口点的距离分别为为a、b、c，则有a + b + n * (b + c) = 2 * (a + b), 由此可以推出 a = c + (n - 1) * (b + c), 即从起始点出发，和慢指针相遇点即为环的入口点\r\n## 代码\r\n``` Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return head;\r\n        ListNode slow = head, fast = head.next;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            if (fast != null) fast = fast.next;\r\n            if (fast != null) fast = fast.next;\r\n        }\r\n        if (slow == null) return null;\r\n        ListNode ans = head;\r\n        slow = slow.next; // 注意需要踏上这一步，长度才开始生效。\r\n        while (ans != slow) {\r\n            ans = ans.next;\r\n            slow = slow.next;\r\n        }\r\n        return ans;\r\n    }\r\n} \r\n```\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312406696","body":"## 思路\n1. 根据key值得到value，需要一个map\n2. 模拟一个队列，头部是最久未访问的，尾部是刚刚访问的，需要O(1)来移动元素，因此需要一个双向链表\n\n## 代码\n``` Java\nclass LRUCache {\n    class Node {\n        Node pre, next;\n        int val;\n        int key;\n        Node (int key, int value) {\n            this.val = value;\n            this.key = key;\n        }\n    }\n\n    int capacity;\n    Map<Integer, Node> map = new HashMap<>();\n    Node head = new Node(-1, -1);\n    Node tail = head;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n    }\n\n    public void delete(int key) {\n        Node cur = map.get(key);\n        Node pre = cur.pre;\n        if (cur == tail) {\n            tail = pre;\n            return;\n        }\n        Node next = cur.next;\n        next.pre = pre;\n        pre.next = next;\n    }\n\n    public void addLast(Node cur) {\n        cur.next = tail.next;\n        tail.next = cur;\n        cur.pre = tail;\n        tail = tail.next;\n    }\n\n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node cur = map.get(key);\n            delete(key);\n            addLast(cur);\n            return cur.val;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            map.get(key).val = value;\n            Node cur = map.get(key);\n            delete(key);\n            addLast(cur);\n            return;\n        }\n        if (map.size() >= capacity) {\n            Node cur = head.next;\n            delete(cur.key);\n            map.remove(cur.key);\n        }\n        Node cur = new Node(key, value);\n        addLast(cur);\n        map.put(key, cur);\n    }\n}\n```\n\n\n## 复杂度\n* 时间：O(n)\n* 空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312608854","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n``` java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312875542","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n``` java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null || q == null) return p == q;\r\n        return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n* 时间：O(n)\r\n* 空间：O(h)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320705484","body":"``` java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (map.containsKey(target - nums[i])) {\r\n                return new int[]{i, map.get(target - nums[i])};\r\n            }\r\n            map.put(nums[i], i);\r\n        }\r\n        return new int[0];\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320997172","body":"``` java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        int n = nums.length;\n        Map<Integer,Integer> map = new HashMap<>();\n        for (int num : nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (int key : map.keySet()) {\n            if (minHeap.size() < k) {\n                minHeap.offer(new int[]{key, map.get(key)});\n            } else {\n                if (map.get(key) > minHeap.peek()[1]) {\n                    minHeap.poll();\n                    minHeap.offer(new int[]{key, map.get(key)});\n                }\n            }\n        }\n        int[] ans = new int[k];\n        int cnt = 0;\n        while (!minHeap.isEmpty()) {\n            ans[cnt++] = minHeap.poll()[0];\n        }\n        return ans;\n\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323625071","body":"``` Java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int n = s.length(), ans = 0;\n        int[] letters = new int[128];\n        for (int i = 0, j = 0; j < n; j++) {\n            letters[s.charAt(j)]++;\n            while (!check(letters)) {\n                letters[s.charAt(i++)]--;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans;\n\n    }\n    public boolean check(int[] letters) {\n        for (int i = 0; i < letters.length; i++) {\n            if (letters[i] > 1) return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328007007","body":"class Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length, k = 0;\n        for (int j = 0; j < n; j++) {\n            if (j > 0 && nums[j] == nums[j - 1]) continue;\n            nums[k++] = nums[j];\n        }\n        return k;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328176708","body":"``` Java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        // 找到第一个大于等于它的位置\n        int left = 0, right = n;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329947319","body":"``` Java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int edgNum = trust.length;\n        int[] believed = new int[n + 1];\n        int[] believe = new int[n + 1];\n        for (int[] e : trust) {\n            int u = e[0], v = e[1];\n            believed[v]++;\n            believe[u]++;\n        }\n        for (int i = 1; i <= n; i++) {\n            if (believe[i] == 0 && believed[i] == n - 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n} \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336022018","body":"``` Java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        // 模拟获得顺序，或者说排序\n        int n = tasks.length;\n        // 进入的时间，耗时，编号\n        PriorityQueue<int[]> waitTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            else if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        // 耗时，编号\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\n            if (a[0] != b[0]) return a[0] - b[0];\n            return a[1] - b[1];\n        });\n        for (int i = 0; i < n; i++) {\n            waitTasks.offer(new int[]{tasks[i][0], tasks[i][1], i});\n        }\n        int[] ans = new int[n];\n        int cnt = 0, time = 1;\n        while (!waitTasks.isEmpty()) {\n            boolean allNotInTime = true;\n            while (!waitTasks.isEmpty() && waitTasks.peek()[0] <= time) {\n                allNotInTime = false;\n                int[] cur = waitTasks.poll();\n                sortTasks.add(new int[]{cur[1], cur[2]});\n            }\n            if (allNotInTime && sortTasks.isEmpty()) {\n                int[] cur = waitTasks.poll();\n                sortTasks.add(new int[]{cur[1], cur[2]});\n            }\n            int[] cur = sortTasks.poll();\n            ans[cnt++] = cur[1];\n            time = Math.max(time, tasks[cur[1]][0]) + cur[0];\n        }\n        while (!sortTasks.isEmpty()) {\n            ans[cnt++] = sortTasks.poll()[1];\n        }\n        return ans;\n    }\n} \n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337077463","body":"``` Java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int[] fa = new int[26];\n        int[] fb = new int[26];\n        for (char c : a.toCharArray()) {\n            fa[c-'a']++;\n        }\n        for (char c : b.toCharArray()) {\n            fb[c-'a']++;\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 都变成i\n            ans = Math.min(ans, a.length() - fa[i] + b.length() - fb[i]);\n            if (i == 0) continue;\n            // a<b\n            int tmp1 = 0;\n            for (int j = i; j < 26; j++) tmp1 += fa[j];\n            for (int j = 0; j < i; j++) tmp1 += fb[j];\n            // a>b\n            int tmp2 = 0;\n            for (int j = 0; j < i; j++) tmp2 += fa[j];\n            for (int j = i; j < 26; j++) tmp2 += fb[j];\n            ans = Math.min(ans, Math.min(tmp1, tmp2));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338623612","body":"``` Java\n// 快排\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        quickSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n    public void quickSort(int[] nums, int start, int end){\n        if(start < end){\n            int mid = partition(nums, start, end);\n            quickSort(nums, start, mid - 1);\n            quickSort(nums, mid + 1, end);\n        }\n    }\n\n    public int partition(int[] nums, int start, int end){\n        int rdm = new Random().nextInt(end - start + 1) + start;\n        swap(nums, rdm, end);\n        int small = start - 1;\n        for(int i = start; i < end; i++){\n            if(nums[i] < nums[end]){\n                small++;\n                swap(nums, small, i);\n            }\n        }\n        small++;\n        swap(nums, small, end);\n        return small;\n    }\n\n    public void swap(int[] nums, int a, int b){\n        int tmp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = tmp;\n    }\n}\n\n// 堆排\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        int[] ans = Arrays.copyOf(nums, nums.length);\n        heapSort(nums, ans, 0, nums.length - 1);\n        return ans;\n    }\n\n    public void heapSort(int[] nums, int[] ans, int start, int end) { \n        if (start < end) {\n            int mid = (end + start) / 2;\n            heapSort(ans, nums, start, mid);\n            heapSort(ans, nums, mid + 1, end);\n            merge(nums, ans, start, mid, end);\n        }\n    }\n\n    public void merge(int[] nums, int[] ans, int start, int mid, int end) {\n        int cnt = start, p = start, q = mid + 1;\n        while (p <= mid && q <= end) {\n            if (nums[p] < nums[q]) {\n                ans[cnt++] = nums[p];\n                p++;\n            } else {\n                ans[cnt++] = nums[q];\n                q++;\n            }\n        }\n        while (p <= mid) ans[cnt++] = nums[p++];\n        while (q <= end) ans[cnt++] = nums[q++];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340966467","body":"``` Java\nclass Solution {\n    public int mySqrt(int x) {\n        // 小于等于的最后一个\n        int left = 0, right = x;\n        while (left < right) {\n            int mid = (right + left + 1) / 2; // x>4时肯定区中间数左边的范围，因此不会越界\n            if (mid <= x / mid) left = mid;\n            else right = mid - 1;\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341813852","body":"``` java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n; \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) right = mid;\n            else left = mid + 1;\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344219063","body":"``` Java\nclass Solution {\n    int[] tmp;\n    int ans;\n    public int reversePairs(int[] nums) {\n        tmp = new int[nums.length];\n        mergeSort(nums, 0, nums.length - 1);\n        return ans;\n    }\n    public void mergeSort(int[] nums, int start, int end) {\n        if (start == end) return;\n        int mid = (start + end) / 2;\n        mergeSort(nums, start, mid);\n        mergeSort(nums, mid + 1, end);\n        for (int i = start; i <= end; i++) tmp[i] = nums[i];\n        for (int i = start, l = mid; i <= mid; i++) {\n            while (l + 1 <= end && (long)tmp[i] > 2L * (long)tmp[l + 1]) l++;\n            ans += l - mid;\n        }\n        int cnt = start, p = start, q = mid + 1;\n        while (p <= mid || q <= end) {\n            if (p > mid) nums[cnt++] = tmp[q++];\n            else if (q > end || tmp[p] <= tmp[q]) nums[cnt++] = tmp[p++];\n            else nums[cnt++] = tmp[q++];\n        }  \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345131485","body":"``` java\r\n// leetcode 475\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        // 二分 + 滑动窗口\r\n        Arrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n        int left = 0, right = (int)(1e9);\r\n        while (left < right) {\r\n            int mid = (left + right) / 2;\r\n            if (isCheck(houses, heaters, mid)) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    public boolean isCheck(int[] houses, int[] heaters, int cover) {\r\n        int n = houses.length, cnt = 0, m = heaters.length;\r\n        for (int l = 0, r = 0, i = 0; i < m; i++) {\r\n            int lo = heaters[i] - cover, hi = heaters[i] + cover;\r\n            while (l < n && houses[l] < lo) l++;\r\n            while (r < n && houses[r] <= hi) r++;\r\n            cnt += r - l;\r\n            l = r;\r\n        }\r\n        return cnt == n;\r\n    } \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345473053","body":"``` Java\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        int n = nums.length;\n        Arrays.sort(nums);\n        int left = 0, right = (int)(1e6);\n        while (left < right) {\n            int mid = (left + right + 1) / 2;\n            int cnt = 0; // 小于mid的数量\n            for (int i = 0, j = 1; j < n; j++) {\n                while (nums[j] - nums[i] >= mid) i++;\n                cnt += j - i;\n            }\n            if (cnt >= k) right = mid - 1;\n            else left = mid;\n        }\n        return left;\n    }\n}\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356229260","body":"``` java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n        int ans = 0, sum = 0;\n        for (int i = n - k; i < n; i++) {\n            sum += cardPoints[i];\n        }\n        ans = Math.max(ans, sum);\n        for (int l = n - k, r = 0; r < k; r++) {\n            sum -= cardPoints[l++];\n            sum += cardPoints[r];\n            ans = Math.max(ans, sum);\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358892477","body":"``` java\nclass Solution {\n    int ans = 0;\n    int[][] move = {{-1,0},{1,0},{0,-1},{0,1}};\n    int[] tmp = new int[1];\n    int m, n;\n    public int maxAreaOfIsland(int[][] grid) {\n        m = grid.length; n = grid[0].length;\n        boolean[][] visited = new boolean[m][n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    tmp[0] = 0;\n                    dfs(i, j, tmp, visited, grid);\n                }\n            }\n        }\n        return ans;\n    }\n    public void dfs(int i, int j, int[] s, boolean[][] visited, int[][] grid) {\n        visited[i][j] = true;\n        grid[i][j] = 0;\n        s[0]++;\n        ans = Math.max(ans, s[0]);\n        for (int[] mv : move) {\n            int x = i + mv[0], y = j + mv[1];\n            if (x >= 0 && x < m && y >= 0 && y < n && !visited[x][y] && grid[x][y] == 1) {\n                dfs(x, y, s, visited, grid);\n            }\n        }\n    }\n}\n// 做成了麻花\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365544041","body":"``` java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] f = new int[m+1][n+1];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (text1.charAt(i-1) == text2.charAt(j-1)) {\n                    f[i][j] = f[i-1][j-1] + 1;\n                } else {\n                    f[i][j] = Math.max(f[i-1][j], f[i][j-1]);\n                }\n            }\n        }\n        return f[m][n];\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366553709","body":"``` java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] f = new int[m+1][n+1];\n        f[1][1] = 1;\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (i == 1 && j == 1) continue;\n                f[i][j] = f[i-1][j] + f[i][j-1];\n            }\n        }\n        return f[m][n];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367058654","body":"``` java\nclass Solution {\n    int[][] move = {{-2,-1},{-2,1},{-1,-2},{-1,2},{1,-2},{1,2},{2,-1},{2,1}};\n    double[][][] f;\n    public double knightProbability(int n, int k, int row, int column) {\n        f = new double[n][n][k];\n        return dfs(n, 0, k, row, column);\n    }\n\n    public double dfs(int n, int cnt, int k, int i, int j) {\n        if (i < 0 || j < 0 || i >= n || j >= n) {\n            return 0;\n        }\n        if (cnt == k) {\n            return 1.0;\n        }\n        if (f[i][j][cnt] != 0) {\n            return f[i][j][cnt];\n        }\n        double ans = 0;\n        for (int[] mv : move) {\n            ans += dfs(n, cnt + 1, k, i + mv[0], j + mv[1]) / 8.0;\n        }\n        f[i][j][cnt] = ans; \n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367903557","body":"``` java\nclass Solution {\n    Map<Integer, Boolean> memory = new HashMap<>();\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\n        return dfs(maxChoosableInteger, desiredTotal, 0, 0);\n    }\n    public boolean dfs(int maxChoosableInteger, int desiredTotal, int select, int sum) {\n        if (!memory.containsKey(select)) {\n            boolean status = false;\n            for (int i = 0; i < maxChoosableInteger; i++) {\n                if (((select >> i) & 1) == 0) {\n                    if (sum + i + 1 >= desiredTotal) {\n                        status = true;\n                        break;\n                    }\n                    if (!dfs(maxChoosableInteger, desiredTotal, select | (1 << i), sum + i + 1)) {\n                        status = true;\n                        break;\n                    }\n                }\n            }\n            memory.put(select, status);\n        }\n        return memory.get(select);\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368317207","body":"``` java\nclass Solution {\n    Map<String, Integer> memory = new HashMap<>();\n    public int findTargetSumWays(int[] nums, int target) {\n        return dfs(nums, target, 0, 0);\n    }   \n    public int dfs(int[] nums, int target, int sum, int index) {\n        String key = index + \"-\" + sum;\n        if (memory.containsKey(key)) return memory.get(key);\n        if (index == nums.length) {\n            memory.put(key, sum == target ? 1 : 0);\n            return memory.get(key);\n        }\n        int ans = dfs(nums, target, sum + nums[index], index + 1) + dfs(nums, target, sum - nums[index], index + 1);\n        memory.put(key, ans);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368616156","body":"``` java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int n = coins.length;\n        int[] f = new int[amount + 1];\n        Arrays.fill(f, amount + 1);\n        f[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i >= coins[j]) f[i] = Math.min(f[i], f[i-coins[j]] + 1);\n            }\n        }\n        return f[amount] == amount + 1 ? -1 : f[amount];\n\n        \n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369318480","body":"``` java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] f = new int[amount + 1];\n        f[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                f[i] += f[i-coin];\n            }\n        }\n        return f[amount];\n\n\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373079499","body":"``` java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int n = people.length, ans = 0;\n        for (int i = 0, j = n-1; i <= j;) {\n            if (people[i] + people[j] <= limit) {\n                i++;\n                j--;\n            } else {\n                j--;\n            }\n            ans++;\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374467032","body":"虽然做过的题，但是这次总算能完全自己写出来了，记忆化搜索，直接dp还是想不到\n\n``` java\nclass Solution {\n    int[] f = new int[20];\n    public int numTrees(int n) {\n        if (n == 0 || n == 1) return 1;\n        if (f[n] != 0) return f[n]; \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans += numTrees(i) * numTrees(n-1-i);\n        }\n        f[n] = ans;\n        return ans;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374679487","body":"## 思路\n归并排序分治的思想，把左边归并，把右边归并，然后再合起来\n\n## 代码\n``` java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) return null;\n        return mergeSort(lists, 0, lists.length);\n    }\n\n    public ListNode mergeSort(ListNode[] lists, int start, int end) {\n        if (start + 1 == end) return lists[start];\n        int mid = (start + end) / 2;\n        ListNode left = mergeSort(lists, start, mid);\n        ListNode right = mergeSort(lists, mid, end);\n        return merge(left, right);\n    }\n\n    public ListNode merge(ListNode left, ListNode right) {\n        ListNode p = left, q = right;\n        ListNode dummy = new ListNode(-1);\n        ListNode tail = dummy;\n        while (p != null && q != null) {\n            if (p.val < q.val) {\n                tail.next = p;\n                p = p.next;\n            } else {\n                tail.next = q;\n                q = q.next;\n            }\n            tail = tail.next;\n        }\n        tail.next = p == null ? q : p;\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375009829","body":"## 思路\n1. 从条件入手，得出前面排奇数，后面排偶数，因为奇数+偶数≠偶数\n2. 推导漂亮数组线性变换后仍是漂亮数组\n3. 分治，先排前面的奇数(线性转换)，再排后面的偶数(线性转换)\n4. 递归漂亮数组时记忆化搜索去重\n\n## 代码\n``` java\nclass Solution {\n    Map<Integer, int[]> memory = new HashMap<>();\n    public int[] beautifulArray(int n) {\n        memory.put(1, new int[]{1});\n        return f(n);\n    }\n    public int[] f(int n) {\n        if (memory.containsKey(n)) return memory.get(n);\n        int[] ans = new int[n];\n        int id = 0, oddCnt = (n + 1) / 2, evenCnt = n / 2;\n        for (int num : f(oddCnt)) {\n            ans[id++] = num * 2 - 1;\n        }\n        for (int num : f(evenCnt)) {\n            ans[id++] = num * 2;\n        }\n        memory.put(n, ans);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376924681","body":"``` java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int xor = 0;\n        for (int num : nums) xor ^= num;\n        int pos = -1;\n        for (int i = 0; i < 32 && pos == -1; i++) {\n            if (((1 << i) & xor) != 0) pos = i;\n        }\n        int[] ans = new int[2];\n        for (int num : nums) {\n            if (((1 << pos) & num) != 0) ans[0] ^= num;\n            else ans[1] ^= num;\n        }\n        return ans;\n    }\n}\n\n\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378104131","body":"``` java\n\n\nclass Solution {\n    List<List<Integer>> ans = new ArrayList<>();\n    public List<List<Integer>> subsets(int[] nums) {\n        dfs(nums, 0, new ArrayList<>());\n        return ans;\n    }\n    public void dfs(int[] nums, int i, List<Integer> tmp) {\n        if (i == nums.length) {\n            ans.add(new ArrayList<>(tmp));\n            return;\n        }\n        dfs(nums, i + 1, tmp);\n        tmp.add(nums[i]);\n        dfs(nums, i + 1, tmp);\n        tmp.remove(tmp.size()-1);\n\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379666155","body":"``` java\nclass Trie {\n\n    class Node {\n        Node[] childs;\n        boolean end;\n        Node() {\n            childs = new Node[26];\n        }\n    }\n\n    Node root;\n\n    public Trie() {\n        root = new Node();\n    }\n    \n    public void insert(String word) {\n        Node cur = root;\n        for (char c : word.toCharArray()) {\n            Node next = cur.childs[c-'a'];\n            if (next == null) {\n                cur.childs[c-'a'] = new Node();\n            }\n            cur = cur.childs[c-'a'];\n        }\n        cur.end = true;\n    }\n    \n    public boolean search(String word) {\n        Node cur = root;\n        for (char c : word.toCharArray()) {\n            Node next = cur.childs[c-'a'];\n            if (next == null) return false;\n            cur = cur.childs[c-'a'];\n        }\n        return cur.end;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node cur = root;\n        for (char c : prefix.toCharArray()) {\n            Node next = cur.childs[c-'a'];\n            if (next == null) return false;\n            cur = cur.childs[c-'a'];\n        }\n        return true;\n\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381214776","body":"``` java\n// 字典树\nclass MapSum {\n\n    class Node{\n        Node[] childs;\n        int val = 0;\n        Node() {\n            childs = new Node[26];\n        }\n    }\n\n    Node root;\n\n    public MapSum() {\n        root = new Node();\n    }\n    \n    public void insert(String key, int val) {\n        Node cur = root;\n        for (char c : key.toCharArray()) {\n            if (cur.childs[c-'a'] == null) {\n                cur.childs[c-'a'] = new Node();\n            }\n            cur = cur.childs[c-'a'];\n        }\n        cur.val = val;\n    }\n    \n    public int sum(String prefix) {\n        Node cur = root;\n        for (char c : prefix.toCharArray()) {\n            if (cur.childs[c-'a'] == null) {\n                return 0;\n            }\n            cur = cur.childs[c-'a'];\n        }\n        return dfs(cur);\n    }\n\n    public int dfs(Node cur) {\n        if (cur == null) return 0;\n        int ans = 0;\n        ans += cur.val;\n        for (Node next : cur.childs) {\n            ans += dfs(next);\n        }\n        return ans;\n    }\n}\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum obj = new MapSum();\n * obj.insert(key,val);\n * int param_2 = obj.sum(prefix);\n */\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382633618","body":"先写一个暴力法\n``` java\nclass Solution {\n    public int[][] multiSearch(String big, String[] smalls) {\n        List<List<Integer>> ans = new ArrayList<>();\n        int n = big.length();\n        for (String small : smalls) {\n            int len = small.length();\n            if (len == 0) continue;\n            List<Integer> tmp = new ArrayList<>();\n            for (int l = 0, r = len - 1; r < n; l++, r++) {\n                if (check(big, small, l, r)) tmp.add(l);\n            }\n            ans.add(tmp);\n        }\n        int[][] res = new int[smalls.length][0];\n        for (int i = 0; i < ans.size(); i++) {\n            res[i] = new int[ans.get(i).size()];\n            for (int j = 0; j < ans.get(i).size(); j++) {\n                res[i][j] = ans.get(i).get(j);\n            }\n        }\n        return res;\n    }\n\n    public boolean check(String big, String small, int start, int end) {\n        int cnt = 0;\n        for (int i = start; i <= end; i++) {\n            if (big.charAt(i) != small.charAt(cnt++)) return false;\n        }\n        return true;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1382966331","body":"``` java\n// 后面再回来补个并查集解法\nclass Solution {\n    int[][] g;\n    int n;\n    boolean[] visited;\n    public int findCircleNum(int[][] isConnected) {\n        g = isConnected;\n        n = isConnected.length;\n        visited = new boolean[n];\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                dfs(i);\n                ans++;\n            }\n        }\n        return ans;\n    }\n    public void dfs(int i) {\n        visited[i] = true;\n        for (int j = 0; j < n; j++) {\n            if (g[i][j] == 1 && !visited[j]) dfs(j);\n        }\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297912515","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        ###思路：类似于两数之和，将num和k从后面开始竖式相加，然后反转最后得到的数组即可\n\n        ###代码：\n        res=[]\n        n1=len(num)-1\n        carry=0\n        while n1>=0 or k !=0 or carry!=0:\n            x=num[n1] if n1>=0 else 0\n            y=k%10 if k!=0 else 0\n            \n            sum = x+y+carry\n            res.append(sum%10)\n            carry=int(sum/10)\n\n            n1-=1\n            k=int(k/10)\n\n        return res[::-1]\n\n        ###复杂度：时间复杂度O(n);空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299465487","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        ###思路，左右指针分别计算c的两侧的距离\n\n        ###代码\n        n=len(s)\n        res=[n+1]*n\n        idx=-1\n        for i in range(0,n,1):\n            if s[i]==c:\n                idx=i\n            if idx!=-1:\n                res[i]=i-idx\n        idx=n\n        for i in range(n-1,-1,-1):\n            if s[i]==c:\n                idx=i\n            if idx!=n:\n                res[i]=min(res[i],idx-i)\n\n        return res\n\n        ###复杂度：时间复杂度是O(N),遍历两次，空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301559873","body":"###用栈的思想\n###规定出长度\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[0]*maxSize\n        self.top=-1\n\n    def push(self, x: int) -> None:\n        if self.top!=len(self.stack)-1:\n            self.top+=1\n            self.stack[self.top]=(x)\n\n\n\n    def pop(self) -> int:\n        if self.top==-1:\n            return -1\n        self.top-=1\n        return self.stack[self.top+1]\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim=min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i]+=val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302870700","body":"        # ###思想：想法是栈，如果每次一个新的[，就入栈之前的字符串，当遇到]，便进行计算\n\n        ###代码：\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c==\"[\":\n                stack.append([multi,res])\n                multi,res=0,\"\"\n\n            elif c==\"]\":\n                cur_multi,last_res=stack.pop()\n                res=last_res+cur_multi*res\n            \n            elif '0'<=c<='9':\n                multi=multi*10+int(c)\n            \n            else:\n                res+=c\n            \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304382862","body":"###思路：利用双栈，当队列出元素时，队列头后面的元素放进辅助栈里面\nclass MyQueue:\n\n    def __init__(self):\n        self.stack=[]\n        self.asstack=[]\n\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if not self.asstack:\n            while self.stack:\n                self.asstack.append(self.stack.pop())\n            return self.asstack.pop()\n        else:\n            return self.asstack.pop()\n\n    def peek(self) -> int:\n        ans=self.pop()\n        self.asstack.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n    \n        if not self.stack and not self.asstack:\n            return True\n        else:\n            return False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304730315","body":"        ###单调栈\n        ###如果是非递增的，只能分成1块\n        ###如果是非递减的，可以分为n块，n为长度\n        ###因此用单调栈依次存储最大的\n\n        ###代码\n        stack=[]\n        for cur in arr:\n\n            if stack and stack[-1]>cur:\n                cmp=stack[-1]\n                while stack and stack[-1]>cur:\n                    stack.pop()\n                stack.append(cmp)\n            else:\n                stack.append(cur)\n        \n        return len(stack)\n\n        ###复杂度：时间复杂度O(N),空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305498634","body":"        ###思路：双指针，第一个指针先走k步，第二个指针开始出发，然后第一个指针走到最后，第二个指针正好到倒数n-k处\n        ###代码\n        if not head:\n            return None        \n        n=1\n        p=head\n        while p and p.next:\n            p=p.next\n            n+=1\n        fast,slow= head,head\n        k %=n\n        if k==0: return head\n        for i in range(0,k):\n            fast=fast.next\n        \n        while fast.next:\n            fast=fast.next\n            slow=slow.next\n        \n        res=None\n        res=slow.next\n        slow.next=None\n        fast.next=head\n    \n        return res\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306529162","body":"class Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ###本题有点像k个一组翻转链表\n        if not head or not head.next:\n            return head         \n        pre=None\n        tail=head\n        for i in range(2):\n            if not tail:\n                return head\n            tail=tail.next\n        \n        cur=head\n        while cur!=tail:\n            temp=cur.next\n            cur.next=pre\n            pre=cur\n            cur=temp\n        head.next=self.swapPairs(tail)\n    \n        return pre\n\n        # #\n        if not head or not head.next:\n            return head     \n        next=head.next\n        head.next=self.swapPairs(next.next)\n        next.next=head\n        return next  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308166964","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        ###参照LC108将有序数组转换为二叉搜索树\n        ###首先是递归的思想，\n        pre=head\n        nums=[]\n        while pre:\n            nums.append(pre.val)\n            pre=pre.next \n        def craet(left,right):\n            if left>right:\n                return None\n            mid=(left+right)//2\n            root=TreeNode(nums[mid])\n\n            root.left=craet(left,mid-1)\n            root.right=craet(mid+1,right)\n\n            return root\n           \n        return craet(0,len(nums)-1) \n        ###这种写法需要数组存储，需要额外的空间\n\n        ###因此考虑链表的写法\n        ###用快慢指针找到中点，然后递归左右\n        def medium(left,right):\n            fast,slow=left,left\n            while fast!=right and fast.next!=right:\n                fast=fast.next.next\n                slow=slow.next\n            return slow\n        \n        def creat(left,right):\n            if left==right:\n                return None\n            mid=medium(left,right)\n            root=TreeNode(mid.val)\n            root.left=creat(left,mid)\n            root.right=creat(mid.next,right)\n            return root\n        \n        return creat(head,None)\n\n        ###如果i想要节省时间，可以一次遍历得到长度\n        pre=head\n        self.head=head\n        num=0\n        while pre:\n            num+=1\n            pre=pre.next\n        \n        def creat(left,right):\n            if left>right:\n                return None\n            mid=(left+right)//2\n            root=TreeNode()\n            root.left=creat(left,mid-1)\n            root.val=self.head.val\n            self.head=self.head.next\n            root.right=creat(mid+1,right)\n\n            return root\n        return creat(0,num-1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309652267","body":"class Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        ###双指针想法，两个指针分别从两个链表的头遍历，当前链表遍历完后遍历下一个，如果两个相遇，则意味着存在相交节点\n        \n        pre1=headA\n        pre2=headB\n        while pre1 != pre2:\n            pre1=pre1.next if pre1 else headB\n            pre2=pre2.next if pre2 else headA\n        return pre1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311146812","body":"\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        ###思路，快慢指针，相遇则说明有环,然后fast再从头走，再次相遇即是环的第一个节点\n        if not head:\n            return None\n        slow,fast=head,head\n        while slow and fast:\n            slow=slow.next\n            if fast.next:\n                fast=fast.next.next\n            else:return None\n        \n            if slow==fast:\n                break\n        fast=head\n        while slow and slow!=fast:\n            slow=slow.next\n            fast=fast.next\n        return slow\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312403113","body":"#构建双向链表\nclass Node:\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.pre = None\n        self.next = None\n        \nclass LRUCache:\n    def __init__(self, capacity: int):\n        #双向链表头尾\n        self.size = 0\n        self.head = None\n        self.tail = None\n\n        self.size = capacity \n\n        #哈希表记录key值\n        self.mp = dict()\n\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail\n        self.tail.pre = self.head   \n    #将节点插入表头函数\n    def insertFirst(self, node: Node):\n        node.pre = self.head\n        node.next = self.head.next\n        self.head.next.pre = node\n        self.head.next = node\n    \n    #移到表头函数\n    def moveToHead(self, node: Node):\n        #已经到了表头\n        if node.pre == self.head:  \n            return\n        #将节点断开，取出来\n        node.pre.next = node.next\n        node.next.pre = node.pre\n        #插入第一个前面\n        self.insertFirst(node)\n    \n    #删去表尾函数，最近最少使用\n    def removeLast(self):\n        #哈希表去掉key\n        self.mp.pop(self.tail.pre.key)\n        #断连该节点\n        self.tail.pre.pre.next = self.tail; \n        self.tail.pre = self.tail.pre.pre\n    \n    #插入函数\n    def put(self, key: int, val: int):\n        #没有见过这个key，新值加入\n        if key not in self.mp:\n            node = Node(key, val)\n            self.mp[key] = node\n            #超出大小，移除最后一个\n            if self.size <= 0:\n                self.removeLast()\n            #大小还有剩余\n            else:\n                #大小减1\n                self.size -= 1 \n            #加到链表头\n            self.insertFirst(node); \n        #哈希表中已经有了，即链表里也已经有了\n        else:\n            self.mp[key].val = val\n            #访问过后，移到表头\n            self.moveToHead(self.mp[key])\n    \n    #获取数据函数\n    def get(self, key: int) -> int:\n        #找不到返回-1\n        res = -1\n        #哈希表中找到\n        if key in self.mp:\n            #获取\n            res = self.mp[key].val\n            #访问过后移到表头\n            self.moveToHead(self.mp[key])\n        return res\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312636790","body":"class Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n\n        ###思路：层序遍历的思路，然后返回长度\n\n        ###长度：\n        if not root:\n            return 0\n        \n        now=[root]\n        res=[]\n        while now:\n            temp=[]\n            next=[]\n            for cur in now:\n                temp.append(cur.val)\n                if cur.left:\n                    next.append(cur.left)\n                if cur.right:\n                    next.append(cur.right)\n\n            res.append(temp)\n            now=next\n\n        return len(res)\n\n        ###递归法\n        if not root:\n            return 0\n        \n        return 1+max(self.maxDepth(root.left),self.maxDepth(root.right))\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313249187","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        ###思路：两个树按同一遍历顺序遍历，然后比较节点值，或者结构\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val!=q.val:\n            return False\n\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314669384","body":"class Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,cur):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return cur*10+root.val\n\n            cur=cur*10+root.val\n            \n            return dfs(root.left,cur)+dfs(root.right,cur)\n        \n        return dfs(root,0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316145196","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        ###思路：层序遍历，最后一层最左边的节点\n\n        ###代码\n        \n        stack=[root]\n        result=0\n        while stack:\n            next=[]\n            # cur=stack.pop()\n            for i in range(len(stack)):\n                if i==0:\n                    result=stack[i].val\n                cur=stack[i]\n                if cur.left:\n                    next.append(cur.left)\n                if cur.right:\n                    next.append(cur.right)\n            stack=next\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317978532","body":"class Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ans=''              \n        stack=[root]\n        while stack:\n            next=[]\n            for cur in stack:\n                if cur:\n                    ans+=str(cur.val)+','\n                    next.append(cur.left)\n                    next.append(cur.right)  \n                else:\n                    ans+='#,'\n            stack=next\n        print('ans',ans,ans[:-1])\n        return ans[:-1]           \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n        # 已经有 root 了，因此从 1 开始\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            if lv != '#':\n                l = TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n                \n            i+=2\n        return root    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319472167","body":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ###定义一个哈希表，\n        seen=collections.defaultdict(\n            lambda:collections.defaultdict(list)\n        )\n\n        def dfs(root,y=0,x=0):\n            if not root:\n                return\n            seen[y][x].append(root.val)\n            dfs(root.left,y-1,x+1)\n            dfs(root.right,y+1,x+1)\n    \n        dfs(root)\n        res=[]\n        for y in sorted(seen):\n            temp=[]\n            for x in sorted(seen[y]):\n                temp+= sorted(v for v in seen[y][x])\n            \n            res.append(temp)\n        \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320816673","body":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n\n        ###哈希表\n        ###\n        record=dict()\n\n        for idc,value in enumerate(nums):\n            if target-value in record:\n                return [record[target-value],idc]\n            record[value]=idc\n        \n        return []","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321071340","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n\n        # count = collections.Counter(nums)\n        # return [item[0] for item in count.most_common(k)]\n\n        import random\n        count = collections.Counter(nums)\n        new_num=list(count.items())\n        l=0\n        r=len(new_num)-1\n        def partion(new_num,k,l,r):\n            idc=random.randint(l,r)\n            new_num[idc],new_num[r]=new_num[r],new_num[idc]\n            less=l-1\n            pivot=new_num[r][1]\n            i=l\n            while i<=r:\n                if new_num[i][1]>=pivot:\n                    new_num[i],new_num[less+1]=new_num[less+1],new_num[i]\n                    less+=1\n                i+=1\n\n            if less==k-1:\n                return new_num[:k]\n            \n            elif less>k-1:\n                return partion(new_num,k,l,less-1)\n            else:\n                return partion(new_num,k,less+1,r)\n        \n        topk=partion(new_num,k,l,r)\n        return [item[0] for item in topk]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321340951","body":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ###本题的重点是计算数量，对于某个确定的距离，计算有多少个符合，当抽出两个时有多少种情况\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            print('m',m)\n            for count in m.values():\n                ans += count * (count-1)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322902008","body":"        n=len(s)\n        left=0\n        lookup=set()\n        max_len=0\n        cur_len=0\n        for i in range(n):\n            cur_len+=1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                \n                left+=1\n                cur_len-=1\n            if cur_len>max_len:\n                max_len=cur_len\n\n            lookup.add(s[i])\n        return max_len","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325879690","body":"class Solution1:\n    def subarraysDivByK(self, nums, k) :\n        record={0:1}\n        total=0     \n        ans=0\n\n        for num in nums:\n            total+=num\n            mod=total%k\n            if mod not in record:\n                record[mod]=0\n            ans+=record[mod]\n            record[mod]+=1\n        \n        # for num,num_f in record.items():\n        #     ans+=num_f*(num_f-1)//2\n            \n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326942234","body":"class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow,fast=head,head\n        while fast and fast.next:\n            slow=slow.next\n            fast=fast.next.next\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327992322","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ##双指针\n        if not nums:\n            return 0\n        n=len(nums)\n        slow,fast=1,1\n        while fast<n:\n            if nums[fast]!=nums[fast-1]:\n                nums[slow]=nums[fast]\n                slow+=1\n            fast+=1\n        return slow","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328148994","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        ###二分查找\n\n        left,right=0,len(nums)-1\n        while left<=right:\n            mid=(left+right)//2\n            if nums[mid]>target:\n                right=mid-1\n            elif nums[mid]<target:\n                left=mid+1\n            else:\n                return mid\n        return right+1\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328440727","body":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        # ###暴力法\n        if k==0: return []\n        res=[]\n        for r in range(k-1,len(nums)):\n            res.append(max(nums[r-k+1:r+1]))\n        return  res\n\n        ###双向队列解法，由于暴力法超时\n        if k==0: return nums\n        res=[]\n        from collections import deque\n        queue=deque()\n        #第一个窗口\n        for i in range(k):\n            while len(queue)!=0 and nums[i]>nums[queue[-1]]:\n                queue.pop()\n            queue.append(i)\n        \n        for i in range(k,len(nums)):\n            res.append(nums[queue[0]])\n            #已经不是当前窗口了\n            while len(queue)!=0 and queue[0]<i-k+1:\n                queue.popleft()\n            #对于当前窗口保存最大值\n            while len(queue)!=0 and nums[queue[-1]]<nums[i]:\n                queue.pop()\n            queue.append(i)\n        \n        res.append(nums[queue[0]])\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329964127","body":"class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n + 1)\n        out_degree = [0] * (n + 1)\n        for a, b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1, n + 1):\n            if in_degree[i] == n - 1 and out_degree[i] == 0:\n                return i\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331530571","body":"class Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n\n        graph = [[0] * N for i in range(N)]\n        colors = [0] * N\n        for a, b in dislikes:\n            graph[a - 1][b - 1] = 1\n            graph[b - 1][a - 1] = 1\n\n        def dfs(graph, colors, i, color, N):\n            colors[i] = color\n            for j in range(N):\n                # dislike eachother\n                if graph[i][j] == 1:\n                    if colors[j] == color:\n                        return False\n                    if colors[j] == 0 and not dfs(graph, colors, j, -1 * color, N):\n                        return False\n            return True\n\n\n        for i in range(N):\n            if colors[i] == 0 and not dfs(graph, colors, i, 1, N):\n                return False\n        return True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333021012","body":"class Solution:\n    # def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n            # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1336099893","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        #模拟的思想\n        x,y=0,0\n        for move in moves:\n            if move=='L':\n                x-=1\n            elif move=='R':\n                x+=1\n            elif move=='U':\n                y+=1\n            elif move=='D':\n                y-=1\n        \n        return x==0 and y==0","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336109164","body":"class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336301757","body":"class Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        # 转化为分钟\n        t0 = 60 * int(loginTime[:2]) + int(loginTime[3:])\n        t1 = 60 * int(logoutTime[:2]) + int(logoutTime[3:])\n        if t1 < t0:\n            # 此时 finishTime 为第二天\n            t1 += 1440\n        # 第一个小于等于 finishTime 的完整对局的结束时间\n        if t0 % 15!=0:\n            t0 = (t0 // 15 + 1) * 15\n        t1 = t1 // 15 * 15\n        print(t0,t1)\n        return max(0, (t1 - t0)) // 15","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336614287","body":"class Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        ans = len(A) + len(B)\n        for i in range(26):\n            ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340295466","body":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        ###二分查找\n        left,right=0,x\n        ans=-1\n        while left<=right:\n            mid=(left+right)//2\n            if mid*mid<=x:\n                ans=mid\n                left=mid+1\n            else:\n                right=mid-1\n            \n        return ans\n\n        ###牛顿迭代\n        if x == 0:\n            return 0\n        \n        C, x0 = float(x), float(x)\n        while True:\n            xi = 0.5 * (x0 + C / x0)\n            if abs(x0 - xi) < 1e-7:\n                break\n            x0 = xi\n        \n        return int(x0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341847140","body":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        ###寻找左边界\n        left=1\n        right=n\n        while left<=right:\n            mid=(left+right)//2\n            if isBadVersion(mid):\n                right=mid-1\n            else:\n                left=mid+1\n            \n        return left","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1344979317","body":"(供暖期那题\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n\n        houses.sort()\n        heaters.sort()\n\n        def possible(diameter):\n            # 上一次能够加热的最右端坐标\n            last_right = 0\n            # 遍历每个取暖器\n            for heater in heaters:\n                # 二分查询取暖器加热半径能够覆盖最左边的房子编号\n                left = bisect.bisect_left(houses, heater - diameter)\n                # 如果最左边不能跟上一次最右边重叠，表示不能覆盖加热\n                if left > last_right:\n                    return False\n                # 更新当前取暖器加热半径能够覆盖最右边的房子编号\n                last_right = bisect.bisect_right(houses, heater + diameter)\n                # 如果已经到达最后一个房子，表示已经全部覆盖完了\n                if last_right >= len(houses):\n                    return True\n            return False\n            \n        l, r = 0, max(houses[-1], heaters[-1])\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345472538","body":"class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def possible(diff):\n            res=0\n            i=0\n            for j in range(1,len(nums)):\n                while nums[j]-nums[i]>diff:\n                    i+=1\n                res+=j-i\n            return res\n        nums.sort()\n        l,r=0,nums[-1]-nums[0]\n        while l<=r:\n            mid=(l+r)//2\n            if possible(mid)>=k:\n                r=mid-1\n            else:\n                l=mid+1\n        return l","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351229833","body":"        dp = [0] * (k + maxPts)\n        win_sum = 0\n        for i in range(k, k + maxPts):\n            if i <= n:\n                dp[i] = 1\n            win_sum += dp[i]\n\n        for i in range(k - 1, -1, -1):\n            dp[i] = win_sum / maxPts\n            win_sum += dp[i] - dp[i + maxPts]\n        return dp[0]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352453726","body":"class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        ###滑动窗口\n        n,m=len(s),len(p)\n        \n        cnt=collections.Counter(p)\n        need=m\n        res=[]\n        for right in range(n):\n            ch=s[right]\n            if ch in cnt:\n                if cnt[ch]>0:\n                    need-=1\n                cnt[ch]-=1\n            \n            left=right-m\n            if left>=0:\n                ch=s[left]\n                if ch in cnt:\n                    if cnt[ch]>=0:\n                        need+=1\n                    cnt[ch]+=1\n\n            if need==0:\n                # res.append(right-m+1)\n                res.append(left+1)\n        \n        return res\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354304643","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ###思路是滑动窗口：\n\n        ###代码：\n        if s==t:\n            return s\n        n1,need=len(s), len(t)\n        if n1<need:\n            return \"\"\n        \n        cnt=collections.Counter(t)\n        \n        start,end=0,-1\n        min_len=n1+1\n        left,right=0,0\n\n        for right in range(n1):\n            ch =s[right]\n            if ch in cnt:\n                if cnt[ch]>0:\n                    need-=1\n                cnt[ch]-=1\n        \n            while need==0:\n                if right-left+1<min_len:    #出现了更短的子串\n                    min_len=right-left+1\n                    start,end=left,right\n                \n                ch=s[left]\n                if ch in cnt:\n                    if cnt[ch]>=0:\n                        need+=1\n                    cnt[ch]+=1\n                left+=1\n            \n        return s[start:end+1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356268980","body":"class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        #共n张，移除k张，求n-k的最小值\n        #相当于求这个n个数字滑动窗口长度为n-k的最小值\n        n=len(cardPoints)\n        window_len=n-k\n        cnt=sum(cardPoints[:window_len])\n        min_sum=cnt\n        for i in range(window_len,n):\n            cnt=cnt + cardPoints[i]-cardPoints[i-window_len]\n            min_sum=min(min_sum,cnt)\n        return sum(cardPoints)-min_sum\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356671317","body":"class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        #枚举的方法\n        ans = list()\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn:\n                    ans.append(f\"{h}:{m:02d}\")\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357478489","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        if not n: return []\n        board = [['.'] * n for _ in range(n)]\n        res = []\n        def isVaild(board,row, col):\n            #判断同一列是否冲突\n            for i in range(len(board)):\n                if board[i][col] == 'Q':\n                    return False\n            # 判断左上角是否冲突\n            i = row -1\n            j = col -1\n            while i>=0 and j>=0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            # 判断右上角是否冲突\n            i = row - 1\n            j = col + 1\n            while i>=0 and j < len(board):\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n\n        def backtrack(board, row, n):\n            # 如果走到最后一行，说明已经找到一个解\n            if row == n:\n                temp_res = []\n                for temp in board:\n                    temp_str = \"\".join(temp)\n                    temp_res.append(temp_str)\n                res.append(temp_res)\n            for col in range(n):\n                if not isVaild(board, row, col):\n                    continue\n                board[row][col] = 'Q'\n                backtrack(board, row+1, n)\n                board[row][col] = '.'\n        backtrack(board, 0, n)\n        return len(res)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360631213","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n\n        n = len(grid)\n        steps = -1\n        queue = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        \n        while len(queue) > 0:\n            for _ in range(len(queue)): \n                x, y = queue.pop(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n                \n        return steps\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362295589","body":"class Solution:\n    def solve(self, graph, target):\n        q = collections.deque([target])\n        visited = set()\n        steps = 0\n        while q:\n            for i in range(len(q)):\n                cur = q.popleft()\n                visited.add(cur)\n                for neighbor in graph[cur]:\n                    if neighbor not in visited:\n                        q.append(neighbor)\n                    elif neighbor == target:\n                        return steps + 1\n            steps += 1\n        return -1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363538178","body":"#垂序遍历\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ###定义一个哈希表，\n        seen=collections.defaultdict(\n            lambda:collections.defaultdict(list)\n        )\n\n        def dfs(root,y=0,x=0):\n            if not root:\n                return\n            seen[y][x].append(root.val)\n            dfs(root.left,y-1,x+1)\n            dfs(root.right,y+1,x+1)\n    \n        dfs(root)\n        res=[]\n        for y in sorted(seen):\n            temp=[]\n            for x in sorted(seen[y]):\n                temp+= sorted(v for v in seen[y][x])\n            \n            res.append(temp)\n        \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364450764","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        n = len(cost)\n        dp = [0] * (n + 1)\n        for i in range(2, n + 1):\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n        return dp[n]","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364805926","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n=len(nums)\n        if n<=1:\n            return n\n        dp=[1]*n\n        count=[1]*n\n        maxCount=0\n\n        for i in range(1,n):\n            for j in range(i):\n                if nums[i]>nums[j]:\n                    if dp[j]+1 > dp[i]:\n                        dp[i]=dp[j]+1\n                        count[i]=count[j]\n                    elif dp[j] + 1 == dp[i] :\n                        count[i] += count[j]\n                if dp[i] > maxCount:\n                    maxCount = dp[i]\n        res=0\n        for i in range(n):\n            if dp[i]==maxCount:\n                res+=count[i]\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365854275","body":"class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        n1=len(text1)+1\n        n2=len(text2)+1\n        dp=[[0 for _ in range(n2)] for _ in range(n1)]\n\n        for i in range(1,n1):\n            for j in range(1,n2):\n                if text1[i-1]==text2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]+1\n                else:\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1])\n        \n        return dp[-1][-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366660556","body":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        # ###动态规划\n        dp = [[1 for i in range(n)] for j in range(m)]\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j]\n        return dp[m - 1][n - 1]\n\n        # ###节省空间\n        cur = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                cur[j] += cur[j-1]\n        return cur[-1]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367692877","body":"class Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        # 定义状态：“马” 仍留在棋盘上的概率 dp[i][j]： 位置(i, j)有马的概率\n        dp = [[0] * n for _ in range(n)]\n        #初始化\n        dp[row][column] = 1\n        for _ in range(k):\n            nxt = [[0] * n for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    #dp记录当前概率，nxt记录移动一次以后的概率 nxt[x][y] += dp[i][j] / 8 其中，(x, y) 是移动后位置，(i, j)  \n                    #是移动前位置 也就是说 (i, j) 有1/8的概率移动到 (x, y)\n                    for x, y in ((i + 2, j + 1), (i + 2, j - 1), (i - 2, j + 1), (i - 2, j - 1), \n                                (i + 1, j + 2), (i - 1, j + 2), (i + 1, j - 2), (i - 1, j - 2)):\n                        if 0 <= x < n and 0 <= y < n:\n                            nxt[x][y] += dp[i][j] / 8\n            dp = nxt\n        return sum(map(sum, dp))\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367884425","body":"class Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        ###暴力法\n        if desiredTotal <= maxChoosableInteger:\n            return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal:\n            return False\n        # picked 用于保存当前已经选择过的数。\n        # acc 表示当前累计的数字和\n        def backtrack(picked, acc):\n            if acc >= desiredTotal:\n                return False\n            if len(picked) == maxChoosableInteger:\n                # 说明全部都被选了，没得选了，返回 False， 代表输了。\n                return False\n            for n in range(1, maxChoosableInteger + 1):\n                if n not in picked:\n                    picked.add(n)\n                    # 对方有一种情况赢不了，我就选这个数字就能赢了，返回 true，代表可以赢。\n                    if not backtrack(picked, acc + n):\n                        picked.remove(n)\n                        return True\n                    picked.remove(n)\n            return False\n\n        # 初始化集合，用于保存当前已经选择过的数。\n        return backtrack(set(), 0)\n        \n        ###dfs法\n        #特殊情况判定，如果maxChoosableInteger对应的所有数之和小于desiredTotal则永远无法赢\n        if (1+maxChoosableInteger)*maxChoosableInteger//2<desiredTotal:\n            return False\n        @cache\n        #dfs函数是当前可选择的数字，已选择的数字之和\n        def dfs(state,choosed_sum):\n            #遍历当前可选数字\n            for x in range(maxChoosableInteger):\n                #需要根据state确定x是否已使用\n                if (1<<x)&state:\n                    continue\n                #如果选择X后sum大于desiredTotal\n                if choosed_sum+x+1>=desiredTotal or not dfs((1<<x)|state,choosed_sum+x+1):\n                    return True\n            return False\n        return dfs(0,0)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368156164","body":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n\n        n=len(nums)\n        target=sum(nums)\n        if target%2 !=0: return False\n        target=target//2\n        #10001是因为200个100的总和为20000\n        dp=[0]* 10001\n        for i in range(n):\n            for j in range(target,nums[i] - 1,-1):\n                 dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n        return target==dp[target]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368385341","body":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        \n        Sum=sum(nums)\n        #cnt表示用到加法的数字\n        cnt=(Sum+target)//2\n        if (Sum+target)%2!=0: return 0\n        if abs(target)>Sum: return 0\n        dp=[0]*(cnt+1)\n        dp[0]=1\n        for i in range(len(nums)):\n            for j in range(cnt,nums[i]-1,-1):\n                dp[j]+=dp[j-nums[i]]\n        \n        return dp[cnt]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1369738728","body":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp=[amount+1]*(amount+1)\n        dp[0]=0\n        for i in range(len(coins)):\n            for j in range(coins[i],amount+1):\n                dp[j]=min(dp[j], dp[j-coins[i]]+1)\n        \n        return dp[amount] if dp[amount]<amount+1 else -1\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369747355","body":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0]*(amount + 1)\n        dp[0] = 1\n        # 遍历物品\n        for i in range(len(coins)):\n            # 遍历背包\n            for j in range(coins[i], amount + 1):\n                dp[j] += dp[j - coins[i]]\n        return dp[amount]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370386015","body":"class Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        ###逆序，先考虑大胃口\n        g.sort()\n        s.sort()\n        start,count=len(s)-1,0\n        for idc in range(len(g)-1,-1,-1):\n            if start>=0 and g[idc]<=s[start]:\n                count+=1\n                start-=1\n        return count\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371631006","body":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n=len(intervals)\n        if n==0:\n            return 0\n        intervals.sort(key=lambda x:x[1])\n        count=1         #记录非交叉区间的个数\n        end=intervals[0][1]     #记录区间分割点\n        for i in range(1,n):\n            if end<=intervals[i][0]:\n                count+=1\n                end=intervals[i][1]\n        return n-count\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373011684","body":"class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        ###双指针思想，先放最重的，再看能否放最轻的\n        people.sort()\n        l,r=0,len(people)-1\n        res=0\n\n        while l<r:\n            total=people[l] + people[r]\n            if total>limit:\n                r-=1\n                res+=1\n            else:\n                r-=1\n                l+=1\n                res+=1\n        if l==r:\n            return res+1\n        return res\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374390763","body":"class Solution:\n    def numTrees(self, n: int) -> int:\n        dp=[1,1]+[0]*n\n\n        for i in range(2,n+1):\n            for j in range(1,i+1):\n                dp[i]+=dp[j-1]*dp[i-j]\n        return dp[n]\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374691182","body":"class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        if not lists:return\n\n        def merge2Lists(l1,l2):#两有序链表合并\n            if not l1:return l2\n            if not l2:return l1\n            dummpy=ListNode(-1)\n            temp=dummpy\n            while l1 and l2:\n                if l1.val<l2.val:\n                    temp.next=l1\n                    l1=l1.next\n                else:\n                    temp.next=l2\n                    l2=l2.next\n                temp=temp.next\n            if l1:\n                temp.next=l1\n            if l2:\n                temp.next=l2\n            \n            return dummpy.next\n\n\n        def helper(l,r):#二分法 使所有链表两两合并\n            if l==r:return lists[l]\n            n=len(lists)\n            mid=(l+r)//2\n\n            l1=helper(l,mid)\n            l2=helper(mid+1,r)\n\n            return merge2Lists(l1,l2)\n\n        return helper(0,len(lists)-1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375003210","body":"class Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        #本来第一开始想到的也是分治法\n        #但是想到的是LC439翻转对那种题\n        #本题还是有很强的技巧性，仿射变换\n        def dp(n):\n            if n == 1:\n                return [1]\n            ans = []\n            # [1,n] 中奇数比偶数多1或一样\n            for a in dp(n - n // 2):\n                ans += [a * 2 - 1]\n            for b in dp(n // 2):\n                ans += [b * 2]\n            return ans\n\n        return dp(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1378115128","body":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        #位运算\n        xor = a = b = 0\n        right_bit = 1\n        length = len(nums)\n        for i in nums:\n            xor ^= i\n        while right_bit & xor == 0:\n            right_bit <<= 1\n        for i in nums:\n            if right_bit & i:\n                a ^= i\n            else:\n                b ^= i\n        return [a, b]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378126270","body":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        path=[]\n        paths=[]\n\n        def backtrack(nums,start_index):\n            paths.append(path[:])\n            if start_index==len(nums):\n                return\n            for i in range(start_index,len(nums)):\n                path.append(nums[i])\n                backtrack(nums,i+1)\n                path.pop()\n        \n        backtrack(nums,0)\n        return paths","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379714409","body":"class Trie:\n    def __init__(self):\n        self.children = [None] * 26\n        self.isEnd = False\n    \n    def searchPrefix(self, prefix: str) -> \"Trie\":\n        node = self\n        for ch in prefix:\n            ch = ord(ch) - ord(\"a\")\n            if not node.children[ch]:\n                return None\n            node = node.children[ch]\n        return node\n\n    def insert(self, word: str) -> None:\n        node = self\n        for ch in word:\n            ch = ord(ch) - ord(\"a\")\n            if not node.children[ch]:\n                node.children[ch] = Trie()\n            node = node.children[ch]\n        node.isEnd = True\n\n    def search(self, word: str) -> bool:\n        node = self.searchPrefix(word)\n        return node is not None and node.isEnd\n\n    def startsWith(self, prefix: str) -> bool:\n        return self.searchPrefix(prefix) is not None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1382712912","body":"class MapSum:\n    def __init__(self):\n        self.map = {}\n        self.prefixmap = {}\n\n    def insert(self, key: str, val: int) -> None:\n        delta = val\n        if key in self.map:\n            delta -= self.map[key]\n        self.map[key] = val\n        for i in range(len(key)):\n            currprefix = key[0:i+1]\n            if currprefix in self.prefixmap:\n                self.prefixmap[currprefix] += delta\n            else:\n                self.prefixmap[currprefix] = delta\n\n    def sum(self, prefix: str) -> int:\n        if prefix in self.prefixmap:\n            return self.prefixmap[prefix]\n        else:\n            return 0","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382715401","body":"class Trie:\n    def __init__(self, words):\n        self.d = {}\n        for word in words:\n            t = self.d\n            for w in word:\n                if w not in t:\n                    t[w] = {}\n                t = t[w]\n            t['end'] = word\n    \n    def search(self, s):\n        t = self.d\n        res = []\n        for w in s:\n            if w not in t:\n                break\n            t = t[w]\n            if 'end' in t:\n                res.append(t['end'])\n        return res\n\nclass Solution:\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n        trie = Trie(smalls)\n        hit = collections.defaultdict(list)\n\n        for i in range(len(big)):\n            matchs = trie.search(big[i:])\n            for word in matchs:\n                hit[word].append(i)\n        \n        res = []\n        for word in smalls:\n            res.append(hit[word])\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297927660","body":"## 思路\n\n模拟\n\n## 代码\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        def getDigit(i):\n            if i < 0:\n                return 0\n            return num[i]\n        overflow = 0\n        i = len(num) - 1\n        res = []\n        while i >= 0 or k > 0 or overflow:\n            n = getDigit(i) + k % 10 + overflow\n            k //= 10\n            overflow = n // 10\n            i -= 1\n            res.append(n % 10)\n        res.reverse()\n        return res\n\n ```\n\n## 复杂度分析\n\nn = len(num), m = log10(k)\n\n- 时间: O(max(m, n))\n- 空间: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299550536","body":"## 思路\r\n\r\n正反遍历  \r\n以正向遍历为例, dp[i]表示s[i]距离上一个c的距离，如果s[i] == c 那么, dp[i] = 0, 否则 dp[i] = dp[i - 1] + 1  \r\n反向遍历同理, 由于dp[i]已经存储了正向遍历的结果, 在s[i] != c时还需要取下最小值  \r\n\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        dp = [float('inf')] * n\r\n\r\n        def getDp(i):\r\n            if i < 0 or i >= n:\r\n                return float('inf')\r\n            return dp[i]\r\n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = getDp(i - 1) + 1\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = min(dp[i], getDp(i + 1) + 1)\r\n        return dp\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn = len(s)\r\n\r\n时间: O(n)\r\n空间: O(1) 除了返回值\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305497430","body":"## 思路\n\n1. 先遍历一遍，获取链表长度和tail节点。  \n2. 把头结点循环移动到尾结点。  \n\n\n## 代码\n\n```python3\n\nclass Solution:\n    def getLenAndTail(self, head: Optional[ListNode]) -> int:\n        n = 0\n        node = head\n        tail = head\n        while node:\n            n += 1\n            tail = node\n            node = node.next\n        return n, tail\n\n\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        n, tail = self.getLenAndTail(head)\n        if n <= 1:\n            return head\n        k = n - (k % n)\n        for i in range(k):\n            next = head.next\n            head.next = None\n            tail.next = head\n            tail = tail.next\n            head = next\n        return head\n\n```\n\n## 复杂度分析\n\nn = 链表长度  \n\n- Time: O(n)\n- Space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306722644","body":"## 思路\n\n画图\n\n## 代码\n\n```python3\n\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummyHead = ListNode(next=head)\n        node0, node1, node2 = dummyHead, head, head.next\n        while node0 and node1 and node2:\n            node1.next = node2.next\n            node2.next = node1\n            node0.next = node2\n            node0 = node1\n            node1 = node1.next\n            node2 = node1.next if node1 is not None else None\n        return dummyHead.next\n\n```\n\n\n## 复杂度分析\n\nn = 链表长度\n\n- Time: O(n)\n- Time: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308100237","body":"## Idea\n\ndivide and conquer\n\n\n## Code\n\n```python3\n\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode], dummy_head=ListNode()) -> Optional[TreeNode]:\n        if not head:\n            return None\n        dummy_head.next = head\n        prev, slow, fast = dummy_head, head, head\n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n        prev.next = None\n        root = TreeNode(val=slow.val)\n        root.left = self.sortedListToBST(dummy_head.next)\n        root.right = self.sortedListToBST(slow.next)\n        return root\n\n ```\n\n ## Complexity\n\n n = 链表长度  \n\n - Time: O(nlogn) 递归logn层，每层都需要遍历链表节点  \n - Space: O(logn) 递归栈空间  \n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312932584","body":"## 思路\r\n\r\n分治，根节点相等，且左右子树相等  \r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if p is None or q is None:\r\n            return p is None and q is None\r\n        return p.val == q.val \\\r\n               and self.isSameTree(p.left, q.left) \\\r\n               and self.isSameTree(p.right, q.right)\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn = min(p.size, q.size)\r\n\r\n- Time: O(n) 遍历每个节点\r\n- Space: O(n) 树的高度\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321789318","body":"## 思路  \n\n遍历，利用dict统计  \n\n## 代码  \n\n```python3\n\nfrom typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def dist(self, pointA: List[int], pointB: List[int]) -> int:\n        xa, ya = pointA\n        xb, yb = pointB\n        return (xa - xb) ** 2 + (ya - yb) ** 2\n\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n < 3:\n            return 0\n        ans = 0\n        for i in range(n):\n            distCounter = defaultdict(lambda : 0)\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = self.dist(points[i], points[j])\n                distCounter[dist] += 1\n            for dist, count in distCounter.items():\n                if count > 1:\n                    ans += count * (count - 1)\n        return ans\n\n```\n\n## 复杂度分析\n\nn = points.length\n\n- Time: O(n^2) 双层循环遍历所有点\n- Space: O(n) dict占用空间\n\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328161091","body":"## 思路\n\n二分\n\n## 代码\n\n```python3\n\nfrom typing import List\n\n\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        if nums[0] > target:\n            return 0\n        if nums[n - 1] < target:\n            return n\n        l, r = 0, n - 1\n        while l + 1 < r:\n            m = (l + r) // 2\n            if nums[m] < target:\n                l = m\n            else:\n                r = m\n        if nums[l] == target:\n            return l\n        else:\n\n```\n\n## 复杂度分析\n\n- Time: O(logn)\n- Space: O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330039845","body":"## 思路\n\n出度为0，入度为n - 1\n\n\n## 代码\n\n```java\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] outDegrees = new int[n + 1];\n        int[] inDegrees = new int[n + 1];\n        for (int[] ab : trust) {\n            outDegrees[ab[0]] += 1;\n            inDegrees[ab[1]] += 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n## 复杂度分析\n\nm = trust.length\n\n- Time: O(m + n)\n- Space: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297956718","body":"思路\r\n在数组中从后往前遍历，一边遍历一边将k的个位数加进去并判断是否有进位，然后将k的个位数移除掉，循环往复。\r\n最后判断k或者进位是否有值，如有就进行相加并判断是否有进位，循环往复。没有则直接返回\r\n\r\n代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int index = num.size() - 1;\r\n        int agg = 0;\r\n        for (; index >= 0; index--) {\r\n            num[index] = num[index] + (k%10) + agg;\r\n            k = k / 10;\r\n            if (num[index] >= 10) {\r\n                agg = 1;\r\n                num[index] -= 10;\r\n            }else {\r\n                agg = 0;\r\n            }\r\n        }\r\n        if (agg == 0 && k == 0) {\r\n            return num;\r\n        }else {\r\n            while (k > 9 || agg > 0) {\r\n                auto sum = (k%10) + agg;\r\n                k = k / 10;\r\n                if (sum > 9) {\r\n                    sum = sum - 10;\r\n                    agg = 1;\r\n                }else {\r\n                    agg = 0;\r\n                }\r\n                num.insert(num.begin(), sum);    \r\n            }\r\n            if (k > 0) {\r\n                num.insert(num.begin(), k);\r\n            }\r\n            return num;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299510329","body":"思路\n遍历每个值，分别寻找左边和右边最近的给定字符，再取最小值即可。\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result{};\n        const char* p = s.data();\n        auto max_index = s.length() - 1;\n        if (max_index == 0) {\n            result.push_back(0);\n            return result;\n        }\n        for (auto i = 0; i <= max_index; i++) {\n            if (p[i] == c) {\n                result.push_back(0);\n                continue;\n            }\n            for (auto j = i + 1; ; j++) {\n                if (j > max_index) {\n                    result.push_back(max_index + 1);\n                    break;\n                }\n                 if (p[j] == c) {\n                     result.push_back(j - i);\n                     break;\n                 }\n                 \n            }\n            for (auto z = i - 1; z >= 0; z --) {\n                if (p[z] == c && result.back() > (i - z)) {\n                    result.pop_back();\n                    result.push_back(i - z);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n时间空间均为 O(N), O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301726919","body":"思路\r\n新建一个vector来进行模拟栈的操作；\r\n因为push进去的每个值不大于1000，可以利用多出来的位数进行存放increment的值，pop当前值时发现这个值携带increment的值，就向下传递下去，可以把increment操作优化到O1；\r\n\r\n代码\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int> base{} ;\r\n    int value_limit = 1000;\r\n    int flag = 0b10000000000;\r\n    int size_limit = 0;\r\n    int top = -1;\r\n    int mask = 0b1111111111;\r\n    CustomStack(int maxSize) {\r\n        size_limit = maxSize - 1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top >= size_limit) {\r\n            return;\r\n        }\r\n        top++;\r\n        base.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (top < 0) return -1;\r\n        int value = base.back();\r\n        base.pop_back();\r\n        top--;\r\n        if ((value & flag) == flag) {\r\n            int add_val = value >> 11;\r\n            value = (value & mask) + add_val;\r\n            if (top >= 0) {\r\n                if ((base[top] & flag) == flag) {\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }else {\r\n                    base[top] = base[top] | flag;\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        return value;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int index = min(k - 1, top);\r\n        if (index < 0) return;\r\n        int top_value = base[index];\r\n        if (top_value & flag == 1) {\r\n            base[index] = top_value + (val << 11);\r\n        }else {\r\n            top_value = top_value | flag;\r\n            base[index] = top_value + (val << 11);\r\n        }\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */rement(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：increment的操作是O(1)，其他操作是O(1)。\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303794752","body":"思路\n将每个字符压入栈，如果遇到']'时弹出栈中内容到temp中，直到遇到'['才结束；如果遇到的是数字，则用add栈记录下来，与遇到'['出现时进行处理即可。\n\n代码\n```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<char> stack{};\n        vector<char> temp{};\n        vector<int> add{};\n        int sum = 0;\n        for (size_t i = 0; i < s.size(); i++) {\n            if (std::isdigit(s[i])) {\n                sum *= 10;\n                int n = s[i] - '0';\n                sum += n;\n                continue;\n            }else if (sum > 0) {\n                add.push_back(sum);\n                sum = 0;\n            }\n            \n            if (s[i] == ']') {\n                while(!stack.empty()) {\n                    auto c = stack.back();\n                    stack.pop_back();\n                    if (c != '[') {\n                        temp.push_back(c);\n                    }else {\n                        int times = add.back();\n                        for (size_t i = 0; i < times; i++) {\n                            stack.insert(stack.end(), temp.rbegin(), temp.rend());\n                        }\n                        add.pop_back();\n                        temp.clear();\n                        break;\n                    }\n                }\n            }else {\n                stack.push_back(s[i]);\n            }\n        }\n        string result{};\n        result.assign(stack.begin(), stack.end());\n        return result;\n    }\n};\n```\n复杂度\n时间复杂度：$O(n)$，需要遍历一遍字符\n空间复杂度：$O(3n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304555068","body":"思路\r\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    vector<int> s1{};\r\n    vector<int> s2{};\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        s1.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        int result = s2.back();\r\n        s2.pop_back();\r\n        return result;\r\n    }\r\n    \r\n    int peek() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        return s2.back();\r\n    }\r\n    \r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304793302","body":"用栈存放每一个分块的最大值，最后栈的数量即为分块的数量。\r\n当给出的数比最后一个块的最大值大，表示这个数可以自己当一个块；\r\n当给出的数比最后一个块的最大值小，表示这个数要融入它们；\r\n在上一条的基础上，如果这个数比倒数第二个块的最大值小，继续融合，直到遇到某个块的最大值比这个数小才停止。\r\n\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st{};\r\n        for (auto & i: arr) {\r\n            if (st.empty() || i >= st.top()) {\r\n                st.emplace(i);\r\n            }else {\r\n                auto t = st.top();\r\n                st.pop();\r\n                while (!st.empty() && st.top() > i) {\r\n                    st.pop();\r\n                }\r\n                st.emplace(t);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305721073","body":"思路\r\n把问题转换为找倒数第几个的问题；需要解决移动次数比链表长度长的问题；\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0) return head;\r\n        ListNode* result = new ListNode();\r\n        ListNode* pre_node = head;\r\n        ListNode* key_node = head;\r\n        int times = 0;\r\n        int size = 0;\r\n        for (int i = 0; i < k; i++) {\r\n            if (key_node == nullptr) {\r\n                size = i;\r\n                break;\r\n            }\r\n            key_node = key_node->next;\r\n        }\r\n        if (size == 0 && key_node == nullptr) return head;\r\n        if (size != 0) {\r\n            // 需要取模\r\n            k = k % size;\r\n            key_node = head;\r\n            for (int i = 0; i < k; i++) {\r\n                key_node = key_node->next;\r\n            }\r\n        }\r\n        \r\n\r\n        while (key_node->next != nullptr) {\r\n            key_node = key_node->next;\r\n            pre_node = pre_node->next;\r\n        }\r\n        key_node->next = head;\r\n        result->next = pre_node->next;\r\n        pre_node->next = nullptr;\r\n        return result->next;\r\n    }\r\n};\r\n```\r\n};\r\n复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307043818","body":"思路\r\n哨兵+两两交换+处理边界情况\r\n代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) return head;\r\n        ListNode* result = new ListNode();\r\n        result->next = head;\r\n        auto soilder = result;\r\n        ListNode* post_node;\r\n        ListNode* after_node;\r\n\r\n        do{\r\n            post_node = soilder;\r\n            after_node = soilder->next->next;\r\n            \r\n\r\n            post_node->next->next  = after_node->next;\r\n            after_node->next = post_node->next;\r\n            post_node->next = after_node;\r\n\r\n            soilder = after_node->next;\r\n            \r\n        }while(soilder->next != nullptr && soilder->next->next != nullptr);\r\n\r\n        return result->next;\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308641542","body":"思路\n使用快慢指针找到二叉树的根节点，中点左边的值构造左子树，右边的值构造右子树；最后递归链表生成二叉树。\n\n代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if (head == nullptr)  return nullptr;\n        if (head->next == nullptr) {\n            TreeNode* t = new TreeNode(head->val);\n            return t;\n        }\n        auto root = build(head, nullptr);\n        return root;\n    }\n\nprivate:\n    ListNode* getMin(ListNode* head, ListNode* end) {\n        if (head == end || head->next == end) return head;\n        auto slow = head;\n        auto fast = head;\n        while (fast != end && fast->next != end) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n\n    TreeNode* build(ListNode* begin, ListNode* end) {\n        if (begin == end) return nullptr;\n        auto list_node = getMin(begin, end);\n        if (list_node == end) return nullptr;\n        TreeNode* t = new TreeNode(list_node->val);\n        t->left = build(begin, list_node);\n        t->right = build(list_node->next, end);\n        return t;\n    }\n};\n```\n复杂度\n时间: O(nlogn)\n空间: O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309918133","body":"思路\n走a链表+b链表 = 走b链表+a链表\n判断某个节点便利a、b链表后遇到几次结尾，如果超过2次说明没有节点\n代码\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        auto a = headA;\n        auto b = headB;\n        int times = 0;\n        while (times <= 2) {\n            if (a == nullptr) {\n                times++;\n                a = headB;\n            }\n            if (b == nullptr) {\n                times++;\n                b = headA;\n            }\n            if (a == b) {\n                return a;\n            }\n            a = a->next;\n            b = b->next;\n        }\n        return nullptr;\n    }\n};\n```\n复杂度分析\n\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311556759","body":"解题思路\n从head开始快慢指针，快指针每次两步，慢指针每次一步，第一次相遇时将快指针回到head，改为每次前进一步，第二次相遇点为环起始点\n\n代码实现\n```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if (head == nullptr || head->next == nullptr) return nullptr;\n\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (true) {\n            if (fast == nullptr || fast->next == nullptr) return nullptr;\n            slow = slow->next;\n            fast = fast->next->next;\n            if (slow == fast) break;\n        }\n        fast = head;\n        while (fast != slow) {\n            fast = fast->next;\n            slow = slow->next;\n        }\n        return fast;\n    }\n};\n```\n复杂度分析\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312653275","body":"思路\r\n递归\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n复杂度\r\n时间：O(n)\r\n空间：递归栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313124725","body":"思路\n递归\n\n代码\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) return true;\n        if (p == nullptr || q == nullptr || p->val != q->val) return false;\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n    }\n};\n```\n复杂度\n时间：o(n)\n空间：o(n) n为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315301734","body":"思路\r\n深度优先搜索，当前值 * 2 加上 左子树的值 加上 右子树的值，递归当前操作，最后返回即可。\r\n\r\n代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int prevSum) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root->val;\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root->left, sum) + dfs(root->right, sum);\r\n        }\r\n    }\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n\r\n```\r\n复杂度\r\nTime: $O(n)$, n是二叉树节点个数\r\nSpace: $O(n)$, n是二叉树节点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316935701","body":"思路\nBFS，记录每层最左元素，遍历结束，记录的为最后一层最左元素值\n\n代码\n```\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ret;\n        queue<TreeNode *> q;\n        q.push(root);\n        while (!q.empty()) {\n            auto p = q.front();\n            q.pop();\n            if (p->right) {\n                q.push(p->right);\n            }\n            if (p->left) {\n                q.push(p->left);\n            }\n            ret = p->val;\n        }\n        return ret;\n    }\n};\n```\n复杂度分析\n\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321822469","body":"思路\n遍历，利用dict统计\n\n代码\n```\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n```\n复杂度分析\n\nTime: O(n^2) 双层循环遍历所有点\nSpace: O(n) dict占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323641414","body":"思路\r\n队列+滑动窗口（队列维护不同元素的组成，取最长时的数字）\r\n\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_map<char, int>hashMap;\r\n        int maxSub = 0, l = 0, r = 0;\r\n        while(r < s.size()){\r\n            if(hashMap.count(s[r])>0){\r\n                int last_pos = hashMap[s[r]];\r\n                if(last_pos >= l && last_pos <= r)\r\n                    l = last_pos + 1;\r\n            }            \r\n            maxSub = max(maxSub, r-l+1);\r\n            hashMap[s[r]] = r;\r\n            r++;\r\n        }\r\n        return maxSub;\r\n    }\r\n};\r\n复杂度分析\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(S)$\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326206364","body":"```\r\nclass Solution {\r\n    public int subarraysDivByK(int[] nums, int k) {\r\n        int n = nums.length;\r\n        int[] s = new int[n + 1];\r\n        for(int i = 1; i <= n; i++){\r\n            s[i] = s[i - 1] + nums[i - 1];\r\n        }\r\n        Map<Integer, Integer> cnt = new HashMap<>();\r\n        cnt.put(0, 1);\r\n        int res = 0;\r\n        for(int i = 1; i <= n; i++){\r\n            int r = (s[i] % k  + k) % k;\r\n            res += cnt.getOrDefault(r, 0);\r\n            cnt.put(r, cnt.getOrDefault(r, 0) + 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327403137","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        if (head->next == nullptr) return head;\r\n        auto slow = head;\r\n        auto fast = head;\r\n        while (fast != nullptr && fast->next != nullptr) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328255956","body":"```\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int n = nums.size();\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left <= right) {\r\n            int mid = ((right - left) >> 1) + left;\r\n            if (target <= nums[mid]) {\r\n                ans = mid;\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329252990","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        deque<int> q;\r\n        for (int i = 0; i < k; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n        }\r\n\r\n        vector<int> ans = {nums[q.front()]};\r\n        for (int i = k; i < n; ++i) {\r\n            while (!q.empty() && nums[i] >= nums[q.back()]) {\r\n                q.pop_back();\r\n            }\r\n            q.push_back(i);\r\n            while (q.front() <= i - k) {\r\n                q.pop_front();\r\n            }\r\n            ans.push_back(nums[q.front()]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330467959","body":"```\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332028927","body":"```\nclass Solution {\npublic:\n    int parent[4010];\n    int find(int x) {\n        return x == parent[x] ? x : parent[x] = find(parent[x]);\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        for (int i = 0; i <= n*2; i++) {\n            parent[i] = i;\n        }\n        for( auto & i: dislikes) {\n            int x = find(i[0]), y = find(i[1]);\n            if (x == y) return false;\n            parent[find(x + n)] = y;\n            parent[find(y + n)] = x;\n        }\n        return true;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335040796","body":"```\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (const auto& move: moves) {\n            if (move == 'U') {\n                y--;\n            }\n            else if (move == 'D') {\n                y++;\n            }\n            else if (move == 'L') {\n                x--;\n            }\n            else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336172013","body":"```\nclass Solution {\nprivate:\n    using PII = pair<int, int>;\n    using LL = long long;\n\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n = tasks.size();\n        vector<int> indices(n);\n        iota(indices.begin(), indices.end(), 0);\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\n            return tasks[i][0] < tasks[j][0];\n        });\n\n        vector<int> ans;\n        // 优先队列\n        priority_queue<PII, vector<PII>, greater<PII>> q;\n        // 时间戳\n        LL timestamp = 0;\n        // 数组上遍历的指针\n        int ptr = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            // 如果没有可以执行的任务，直接快进\n            if (q.empty()) {\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\n            }\n            // 将所有小于等于时间戳的任务放入优先队列\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\n                ++ptr;\n            }\n            // 选择处理时间最小的任务\n            auto&& [process, index] = q.top();\n            timestamp += process;\n            ans.push_back(index);\n            q.pop();\n        }\n        \n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336420409","body":"```\nclass Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        // 转化为分钟\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if (t1 < t0){\n            // 此时 finishTime 为第二天\n            t1 += 1440;\n        }\n        // 第一个小于等于 finishTime 的完整对局的结束时间\n        t1 = t1 / 15 * 15;\n        return max(0, (t1 - t0)) / 15;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337556016","body":"```\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int n = a.size(), m = b.size();\n        vector<int> va(26, 0), vb(26, 0);\n        for(char c : a) va[c - 'a']++;\n        for(char c : b) vb[c - 'a']++;\n        \n        int ret = n + m;\n        \n        // 第一种情况\n        int case1 = n + m;\n        for(int i = 0; i < 25; i++) {\n            // 以第 i 个字母为临界(字符a可取，b不可取)\n            int cur = 0;\n            for(int j = i + 1; j < 26; j++) cur += va[j];\n            for(int j = 0; j <= i; j++) cur += vb[j];\n            case1 = min(case1, cur);\n        }\n        ret = min(ret, case1);\n        \n        // 第二种情况\n        int case2 = n + m;\n        for(int i = 0; i < 25; i++) {\n            // 以第 i 个字母为临界(字符b可取，a不可取)\n            int cur = 0;\n            for(int j = i + 1; j < 26; j++) cur += vb[j];\n            for(int j = 0; j <= i; j++) cur += va[j];\n            case2 = min(case2, cur);\n        }\n        ret = min(ret, case2);\n        \n        // 第三种情况\n        int case3 = n + m;\n        for(int i = 0; i < 26; i++) {\n            int cur = 0;\n            for(int j = 0; j < 26; j++) {\n                if(j == i) continue;\n                cur += va[j] + vb[j];\n            }\n            case3 = min(case3, cur);\n        }\n        ret = min(ret, case3);\n        return ret;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339310381","body":"```\nclass Solution {\n    int partition(vector<int>& nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[r]);\n        return i + 1;\n    }\n    int randomized_partition(vector<int>& nums, int l, int r) {\n        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums[r], nums[i]);\n        return partition(nums, l, r);\n    }\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\n        if (l < r) {\n            int pos = randomized_partition(nums, l, r);\n            randomized_quicksort(nums, l, pos - 1);\n            randomized_quicksort(nums, pos + 1, r);\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        srand((unsigned)time(NULL));\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340891053","body":"```\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x == 0) {\n            return 0;\n        }\n\n        double C = x, x0 = x;\n        while (true) {\n            double xi = 0.5 * (x0 + C / x0);\n            if (fabs(x0 - xi) < 1e-7) {\n                break;\n            }\n            x0 = xi;\n        }\n        return int(x0);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342835006","body":"```\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) { // 循环直至区间左右端点相同\n            int mid = left + (right - left) / 2; // 防止计算时溢出\n            if (isBadVersion(mid)) {\n                right = mid; // 答案在区间 [left, mid] 中\n            } else {\n                left = mid + 1; // 答案在区间 [mid+1, right] 中\n            }\n        }\n        // 此时有 left == right，区间缩为一个点，即为答案\n        return left;\n    }\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345276224","body":"```\nclass Solution {\npublic:\n    int findRadius(vector<int> &houses, vector<int> &heaters) {\n        int ans = 0;\n        sort(heaters.begin(), heaters.end());\n        for (int house: houses) {\n            int j = upper_bound(heaters.begin(), heaters.end(), house) - heaters.begin();\n            int i = j - 1;\n            int rightDistance = j >= heaters.size() ? INT_MAX : heaters[j] - house;\n            int leftDistance = i < 0 ? INT_MAX : house - heaters[i];\n            int curDistance = min(leftDistance, rightDistance);\n            ans = max(ans, curDistance);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356263002","body":"```\nclass Solution {\npublic:\n    int maxScore(vector<int>& cardPoints, int k) {\n        int n = cardPoints.size();\n        // 滑动窗口大小为 n-k\n        int windowSize = n - k;\n        // 选前 n-k 个作为初始值\n        int sum = accumulate(cardPoints.begin(), cardPoints.begin() + windowSize, 0);\n        int minSum = sum;\n        for (int i = windowSize; i < n; ++i) {\n            // 滑动窗口每向右移动一格，增加从右侧进入窗口的元素值，并减少从左侧离开窗口的元素值\n            sum += cardPoints[i] - cardPoints[i - windowSize];\n            minSum = min(minSum, sum);\n        }\n        return accumulate(cardPoints.begin(), cardPoints.end(), 0) - minSum;\n    }\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359185962","body":"```\nclass Solution {\n    int dfs(vector<vector<int>>& grid, int cur_i, int cur_j) {\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\n            return 0;\n        }\n        grid[cur_i][cur_j] = 0;\n        int di[4] = {0, 0, 1, -1};\n        int dj[4] = {1, -1, 0, 0};\n        int ans = 1;\n        for (int index = 0; index != 4; ++index) {\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n            ans += dfs(grid, next_i, next_j);\n        }\n        return ans;\n    }\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.size(); ++i) {\n            for (int j = 0; j != grid[0].size(); ++j) {\n                ans = max(ans, dfs(grid, i, j));\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364938305","body":"```\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int> &nums) {\n        int n = nums.size(), maxLen = 0, ans = 0;\n        vector<int> dp(n), cnt(n);\n        for (int i = 0; i < n; ++i) {\n            dp[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j]; \n                    } else if (dp[j] + 1 == dp[i]) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                ans = cnt[i]; \n            } else if (dp[i] == maxLen) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365752900","body":"```\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.at(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.at(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366674668","body":"```\r\nclass Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        cur = [1] * n\r\n        for i in range(1, m):\r\n            for j in range(1, n):\r\n                cur[j] += cur[j-1]\r\n        return cur[-1]\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367934409","body":"```\nclass Solution {\npublic:\n    unordered_map<int, bool> memo;\n\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {\n            return false;\n        }\n        return dfs(maxChoosableInteger, 0, desiredTotal, 0);\n    }\n\n    bool dfs(int maxChoosableInteger, int usedNumbers, int desiredTotal, int currentTotal) {\n        if (!memo.count(usedNumbers)) {\n            bool res = false;\n            for (int i = 0; i < maxChoosableInteger; i++) {\n                if (((usedNumbers >> i) & 1) == 0) {\n                    if (i + 1 + currentTotal >= desiredTotal) {\n                        res = true;\n                        break;\n                    }\n                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {\n                        res = true;\n                        break;\n                    }\n                }\n            }\n            memo[usedNumbers] = res;\n        }\n        return memo[usedNumbers];\n    }\n};\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368708077","body":"```\r\nclass Solution {\r\n    public int coinChange(int[] coins, int amount) {\r\n        int max = amount + 1;\r\n        int[] dp = new int[amount + 1];\r\n        for (int i = 0; i < dp.length; i++) {\r\n            dp[i] = max;\r\n        }\r\n        dp[0] = 0;\r\n        for (int i = 1; i <= amount; i++) {\r\n            for (int j = 0; j < coins.length; j++) {\r\n                if (coins[j] > i) {\r\n                    continue;\r\n                }\r\n                dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\r\n            }\r\n        }\r\n        return dp[amount] >= max ? -1 : dp[amount];\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1371000213","body":"```\r\nclass Solution {\r\npublic:\r\n    int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end());\r\n        sort(s.begin(), s.end());\r\n        int m = g.size(), n = s.size();\r\n        int count = 0;\r\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\r\n            while (j < n && g[i] > s[j]) {\r\n                j++;\r\n            }\r\n            if (j < n) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378817305","body":"```\r\nfunc subsets(nums []int)( ans [][]int) {\r\n    set := []int{}\r\n    var dfs func(int)\r\n    dfs = func(cur int,) {\r\n        if cur == len(nums) {\r\n            ans = append(ans, append([]int(nil), set...))\r\n            return\r\n        }\r\n        set = append(set, nums[cur])\r\n        dfs(cur + 1)\r\n        set = set[:len(set) - 1]\r\n        dfs(cur + 1)\r\n    }\r\n    dfs(0)\r\n    return ans;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297965292","body":"```\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const reversed = num.reverse()\n    for(let i=0;i<reversed.length;i++){\n        const x = reversed[i]\n        k += x\n        reversed[i] = k % 10\n        k = (k/10) >> 0\n    }\n    while(k){\n        reversed.push(k%10)\n        k = (k/10) >> 0\n    }\n    return reversed.reverse()\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299502222","body":"function shortestToChar(s: string, c: string): number[] {\n    const n=s.length\n    let res=new Array(n).fill(Infinity)\n    for(let i=0,j=-1;i<n;i++){\n        if(s[i]===c) j=i\n        if(j !== -1) res[i] = i -j\n    }\n    for(let i=n-1,j=-1;i>=0;i--){\n        if(s[i] === c) j=i\n        if(j!=-1) res[i]=Math.min(res[i],j-i)\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595767","body":"```\nclass CustomStack {\n  protected stack: number[] = []\n  protected max: number = Infinity\n\n  constructor(maxSize: number) {\n    this.max = maxSize\n  }\n\n  push(x: number): void {\n    if (this.stack.length === this.max) return\n    this.stack.push(x)\n  }\n\n  pop(): number {\n    if (this.stack.length === 0) return -1\n    return this.stack.pop()!\n  }\n\n  increment(k: number, val: number): void {\n    const n = this.stack.length\n    if (k > n) k = n\n    for (let i = 0; i < k; i++) {\n      this.stack[i] += val\n    }\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302885382","body":"```\nfunction decodeString(s: string): string {\n  let res = ''\n  let count = 0\n  let stack: [string, number][] = []\n\n  const sArr = s.split('')\n  for (const c of sArr) {\n    if (c === '[') {\n      stack.push([res, count])\n      count = 0\n      res = ''\n    } else if (c === ']') {\n      const ans = stack.pop()!\n      const chars = ans[0]\n      const times = ans[1]\n      let temp = ''\n      for (let i = 0; i < times; i++) {\n        temp += res\n      }\n      res = chars + temp\n    } else if (c <= '9' && c >= '0') {\n      count = count * 10 + parseInt(c)\n    } else {\n      res += c\n    }\n  }\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304420330","body":"```\nclass MyQueue {\n    q: number[];\n  s: number[];\n  constructor() {\n    this.q = [];\n    this.s = [];\n  }\n\n  push(x: number): void {\n    this.q.push(x);\n  }\n\n  pop(): number {\n    while (this.q.length > 1) {\n      this.s.push(this.q.pop()!);\n    }\n    const res = this.q.pop();\n    while (this.s.length) {\n      this.q.push(this.s.pop()!);\n    }\n    return res!;\n  }\n\n  peek(): number {\n    return this.q[0];\n  }\n\n  empty(): boolean {\n    return this.q.length === 0;\n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304712804","body":"```\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack = []\n  for (const c of arr) {\n    let t = c\n    while (stack.length && stack[stack.length - 1] > c) {\n      t = Math.max(t, stack[stack.length - 1])\n      stack.pop()\n    }\n    stack.push(t)\n  }\n  return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304978809","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if(!head) return null\n    let h = head, length = 0\n    while(h){\n        length++\n        h=h.next\n    }\n    k = k % length\n    if(length === 1 || k===length || k === 0 ) return head \n    \n    let newH = head\n    let count = 0\n    while(count !== length - k){\n        newH=newH.next\n        count ++\n    }\n    let newTail = head\n    count = 0\n    while(count !== length-k-1){\n        newTail=newTail.next\n        count ++\n    }\n    if (newTail.next) newTail.next=null\n    \n    let h2 = newH\n    while(h2&&h2.next){\n        h2=h2.next\n    }\n    \n    h2.next=head\n    return newH\n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306482795","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction swapPairs(head: ListNode | null): ListNode | null {\n    if(!head) return null\n    const dummy = new ListNode(-1, head)\n    let h = dummy\n    while(h.next && h.next.next){\n        const a = h.next,b=h.next.next\n        h.next=b\n        a.next=b.next\n        b.next=a\n        h=a\n    }\n    return dummy.next\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308188377","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\n    if(!head) return null\n    const arr = []\n    let h=head\n    while(h){\n        arr.push(h.val)\n        h=h.next\n    }\n    const build = (nums,l,r) =>{\n        if(l>r) return null\n        const mid = parseInt(String((l+r) / 2))\n        let root = new TreeNode(nums[mid])\n        root.left=build(nums,l,mid-1)\n        root.right=build(nums,mid+1,r)\n        return root\n        \n    }\n    return build(arr,0,arr.length-1)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309929801","body":"```\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n  let p1: ListNode | null = headA;\n  let p2: ListNode | null = headB;\n  while (p1 !== p2) {\n    p1 = (p1 === null) ? headB : p1.next;\n    p2 = (p2 === null) ? headA : p2.next;\n  }\n  return p1;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311135165","body":"```\nfunction detectCycle(head: ListNode | null): ListNode | null {\n    if(!head || !head.next) return null\n    let quick=head.next, slow=head\n    while(quick){\n        quick=quick.next\n        slow=slow.next\n        \n        if(!quick) return null\n        \n        quick=quick.next\n        \n        if(quick===slow) {\n            slow = head\n            quick = quick.next\n            while(quick !== slow){\n                slow=slow.next\n                quick=quick.next\n            }\n            return slow\n        }\n      \n    }\n    return null\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312316338","body":"```\nclass LinkNode {\n  key: number;\n  val: number;\n  left: LinkNode | null;\n  right: LinkNode | null;\n  constructor(\n    key: number,\n    val: number,\n    left?: LinkNode | null,\n    right?: LinkNode | null\n  ) {\n    this.key = key;\n    this.val = val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\n\nclass LRUCache {\n  // 容量\n  n: number;\n  // 当前容量\n  curN: number;\n  // 哈希表\n  hash: { [key: number]: LinkNode } = {};\n  // 虚拟左节点\n  L: LinkNode;\n  // 虚拟右节点\n  R: LinkNode;\n\n  // 删除节点\n  remove(p: LinkNode) {\n    if (p.right) p.right.left = p.left;\n    if (p.left) p.left.right = p.right;\n    this.curN -= 1;\n  }\n\n  // 增加节点\n  insert(p: LinkNode) {\n    p.right = this.L.right;\n    p.left = this.L;\n    if (this.L.right) {\n      this.L.right.left = p;\n      this.L.right = p;\n    }\n    this.curN += 1;\n  }\n\n  constructor(capacity: number) {\n    this.n = capacity;\n    this.curN = 0;\n    this.L = new LinkNode(-1, -1);\n    this.R = new LinkNode(-1, -1);\n    this.L.right = this.R;\n    this.R.left = this.L;\n  }\n\n  get(key: number): number {\n    const p = this.hash[key];\n    if (!p) return -1;\n    this.remove(p);\n    this.insert(p);\n    return p.val;\n  }\n\n  put(key: number, value: number): void {\n    const p = this.hash[key];\n    if (p) {\n      p.val = value;\n      this.remove(p);\n      this.insert(p);\n    } else {\n      //满载\n      if (this.curN === this.n) {\n        let rN = this.R.left!;\n        this.remove(rN);\n        delete this.hash[rN.key];\n      }\n      let newP = new LinkNode(key, value);\n      this.hash[key] = newP;\n      this.insert(newP);\n    }\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312735403","body":"```\nfunction maxDepth(root: TreeNode | null): number {\n    if(!root) return 0\n    const l=maxDepth(root.left)\n    const r=maxDepth(root.right)\n    return Math.max(l,r)+1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313106267","body":"```\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n    if(!p&&!q) return true\n    if ((p&&!q) || (q&&!p) || (p.val!==q.val)) return false\n    return isSameTree(p.left,q.left) &&isSameTree(p.right,q.right)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314825253","body":"```\nfunction sumNumbers(root: TreeNode | null): number {\n    let ans=0\n    const dfs=(r:TreeNode, num:number)=>{\n        num=num*10+r.val\n        if(!r.left && !r.right) ans += num\n        if(r.left) dfs(r.left,num)\n        if(r.right) dfs(r.right,num)\n    }\n    dfs(root,0)\n    return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316203628","body":"```\nfunction findBottomLeftValue(root: TreeNode | null): number {\n    let depth=0,ans=0\n    const dfs=(r: TreeNode | null, d: number)=>{\n       if(d>depth) {\n            depth=d\n            ans=r.val\n        }\n        if(r.left) dfs(r.left,d+1)\n        if(r.right) dfs(r.right,d+1)\n    }\n    dfs(root,1)\n    return ans\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317926165","body":"```\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\n/*\n * Encodes a tree to a single string.\n */\nfunction serialize(root: TreeNode | null): string {\n    let path =''\n    const dfs = (r: TreeNode | null)=>{\n        if(!r) {\n            path += '#,'\n            return\n        } \n        path += `${r.val},`\n        dfs(r.left)\n        dfs(r.right)\n    }\n    dfs(root)\n    return path\n};\n\n/*\n * Decodes your encoded data to tree.\n */\nfunction deserialize(data: string): TreeNode | null {\n    let u = 0;\n  const dfs = (d: string): TreeNode | null => {\n    if (d[u] === \"#\") {\n      u += 2;\n      return null;\n    } else {\n      let k = u;\n      while (d[u] !== \",\") u += 1;\n      const root = new TreeNode(Number(d.substring(k, u)));\n      u += 1;\n      root.left = dfs(d);\n      root.right = dfs(d);\n      return root;\n    }\n  };\n  return dfs(data);\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319447742","body":"```\n/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\n\nfunction verticalTraversal(root: TreeNode | null): number[][] {\n    const m = new Map()\n    const dfs=(r,x,y)=>{\n        if(!r) return\n        if(m.has(y)){\n            let temp = m.get(y)\n            m.set(y,[...temp, [x,r.val]])\n        }else{\n            m.set(y,[[x,r.val]])\n        }\n        dfs(r.left,x+1,y-1)\n        dfs(r.right,x+1,y+1)\n    }\n    dfs(root,0,0)\n    const mapAsc = new Map([...m].sort((a,b)=>a[0]-b[0]))\n    let res = []\n    mapAsc.forEach((value,key) => {\n       const valAsc = value.sort((a,b)=>a[0]!==b[0] ?a[0]-b[0]:a[1]-b[1])\n       let temp = valAsc.map(item=>item[1])\n       res.push(temp)\n    });\n    \n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320902329","body":"```\nfunction twoSum(nums: number[], target: number): number[] {\n    const m = new Map<number,number>()\n    for(let i=0;i<nums.length;i++){\n        const num = nums[i]\n        if(m.has(num)) return [m.get(num),i]\n        else  m.set(target-num,i)\n    }\n    return [-1,-1]\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321021378","body":"```\nfunction topKFrequent(nums: number[], k: number): number[] {\n    const m = new Map<number,number>()\n    for(const num of nums){\n        m.set(num, 1+(m.has(num)?m.get(num)+1:0))   \n    }\n    const arr = Array.from(m)\n    const arrSorted = arr.sort((a,b)=>b[1]-a[1])\n    const kArr =arrSorted.slice(0,k)\n    return kArr.map(item=>item[0])\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322854011","body":"```\nfunction lengthOfLongestSubstring(s: string): number {\n    const l=s.length\n    if(l<2) return l\n    let max = 0\n    let sub = ''\n    for(let i=0;i<l;i++){\n        const c=s[i]\n        if(!sub.includes(c)) sub+=c\n        else{\n            max=Math.max(sub.length, max)\n            const j=sub.indexOf(c)\n            sub=sub.slice(j+1)\n            sub+=c\n        }\n    }\n    return Math.max(sub.length,max)\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324722242","body":"```\nfunction findSubstring(s: string, words: string[]): number[] {\n    let res=[]\n    const n=s.length,m=words.length,w=words[0].length\n    let tot=new Map<string,number>()\n    for(const word of words){\n        tot.set(word,1+(tot.has(word)?tot.get(word)!:0))\n    }\n    for(let i=0;i<w;i++){\n        let wd = new Map<string,number>()\n        let cnt=0\n        for(let j=i;j+w<=n;j+=w){\n            if(j>=i+m*w){\n                let word=s.substring(j-m*w,j-m*w+w)\n                wd.set(word,(wd.has(word)?wd.get(word)!:1)-1)\n                if(tot.has(word) && wd.get(word) < tot.get(word)) cnt--\n            }\n            let word=s.substring(j,j+w)\n            wd.set(word,1+(wd.has(word)?wd.get(word)!:0))\n           if(tot.has(word) && wd.get(word) <= tot.get(word)) cnt++\n            if(cnt === m) res.push(j-(m-1)*w)\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325870457","body":"```\nfunction subarraysDivByK(nums: number[], k: number): number {\n    const n = nums.length\n    let s=new Array(n+1).fill(0)\n    for(let i=1;i<=n;i++) s[i]=s[i-1]+nums[i-1]\n    let m=new Map<number,number>()\n    m.set(0,1)\n    let res=0\n    for(let i=1;i<=n;i++){\n        const r = ((s[i] % k + k) % k) >> 0\n        if(m.has(r)) res+=m.get(r)\n        m.set(r, (m.has(r)?m.get(r):0)+1)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326922813","body":"```\nfunction middleNode(head: ListNode | null): ListNode | null {\n    if(!head || !head.next) return head\n    let s=head, q=head.next\n    while(q){\n        s=s.next\n        if(!q.next) return s\n        q=q.next.next\n    }\n    return s  \n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328184536","body":"```\nfunction searchInsert(nums: number[], target: number): number {\n    if (target < nums[0]) return 0\n    let l=0,r=nums.length-1\n    while(l<r){\n        const mid=(l+r+1) >> 1\n        if(nums[mid] ===  target) return mid\n        else{\n            if(nums[mid]<target) l=mid\n            else r=mid-1\n        }\n    }\n    return nums[l] === target ? l : l + 1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328513491","body":"```\nfunction maxSlidingWindow(nums: number[], k: number): number[] {\n    let res=[],q=[]\n    for(let i=0;i<nums.length;i++){\n        if(q.length&&i-k+1>q[0]) q.shift()\n        while(q.length && nums[i] > nums[q[q.length - 1]]) q.pop()\n        q.push(i)\n        if(i>=k-1) res.push(nums[q[0]])\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330448621","body":"```\nfunction findJudge(n: number, trust: number[][]): number {\n    let din=new Array(n+1).fill(0), dout=new Array(n+1).fill(0)\n    for(const p of trust){\n        let a=p[0],b=p[1]\n        din[b]++\n        dout[a]++\n    }\n    let res = -1\n    for(let i=1;i<=n;i++){\n        if(!dout[i] && din[i]===n-1){\n            if(res!==-1) return -1\n            res=i\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332045874","body":"```\nfunction possibleBipartition(n: number, dislikes: number[][]): boolean {\n    let g=new Array(n), color=new Array(n).fill(0)\n    for(let i=0;i<n;i++){\n        g[i]=[]\n    }\n    \n    for(const e of dislikes){\n        let a=e[0]-1,b=e[1]-1\n        g[a].push(b)\n        g[b].push(a)\n    }\n    \n    const dfs=(u:number,c:number)=>{\n        color[u]=c\n        for (const v of g[u]){\n            if(color[v]){\n                if(color[v] === c) return false\n            }else if(!dfs(v,3-c)){\n                return false\n            }\n        }\n        return true\n    }\n    \n    for(let i=0;i<n;i++){\n        if(!color[i] && !dfs(i,1)) return false\n    }\n    return true\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333133829","body":"```\nfunction sortItems(\n  n: number,\n  m: number,\n  group: number[],\n  beforeItems: number[][]\n): number[] {\n  //  n 个项目和  m 个小组\n  // 预处理\n  for (let i = 0; i < group.length; i++) {\n    if (group[i] == -1) {\n      group[i] = m;\n      m++;\n    }\n  }\n\n  const groupAdj: number[][] = Array(m)\n    .fill(undefined)\n    .map(() => Array());\n  const itemAdj: number[][] = Array(n)\n    .fill(undefined)\n    .map(() => Array());\n\n  let groupInDegree: number[] = Array(m).fill(0);\n  let itemInDegree: number[] = Array(n).fill(0);\n\n  for (let i = 0; i < group.length; i++) {\n    let curGroup = group[i];\n    for (let beforeItem of beforeItems[i]) {\n      let beforeGroup = group[beforeItem];\n      if (beforeGroup != curGroup) {\n        groupAdj[beforeGroup].push(curGroup);\n        groupInDegree[curGroup]++;\n      }\n    }\n  }\n  for (let i = 0; i < n; i++) {\n    for (let item of beforeItems[i]) {\n      itemAdj[item].push(i);\n      itemInDegree[i]++;\n    }\n  }\n  // 得到组和项目的拓扑排序结果\n  let groupResult: number[] = topoLogicalSort(groupAdj, groupInDegree, m);\n  if (groupResult.length == 0) {\n    return [];\n  }\n  let itemResult = topoLogicalSort(itemAdj, itemInDegree, n);\n  if (itemResult.length == 0) {\n    return [];\n  }\n  let group2Items: Map<number, number[]> = new Map();\n  for (let item of itemResult) {\n    let key = group[item];\n    if (group2Items.has(key)) {\n      group2Items.get(group[item]).push(item);\n    } else {\n      group2Items.set(key, [item]);\n    }\n  }\n\n  let result: number[] = Array();\n  for (let group of groupResult) {\n    let items = group2Items.get(group) ?? [];\n    result = result.concat(items);\n  }\n  return result;\n}\n\nfunction topoLogicalSort(\n  adj: number[][],\n  inDegree: number[],\n  n: number\n): number[] {\n  let result: number[] = [];\n  let queue: number[] = [];\n  for (let i = 0; i < n; i++) {\n    if (inDegree[i] == 0) {\n      queue.push(i);\n    }\n  }\n  while (queue.length != 0) {\n    let front = queue.shift();\n    result.push(front);\n    for (let successor of adj[front]) {\n      inDegree[successor]--;\n      if (inDegree[successor] == 0) {\n        queue.push(successor);\n      }\n    }\n  }\n  if (result.length == n) {\n    return result;\n  }\n  return [];\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334717409","body":"```\nfunction judgeCircle(moves: string): boolean {\n    let x=0,y=0\n    for(let i=0;i<moves.length;i++){\n        const c=moves[i]\n        if(c==='L'){\n            x++\n        }else if(c==='R'){\n            x--\n        }else if(c==='U'){\n            y++\n        }else if(c==='D'){\n            y--\n        }\n    }\n    return !x&&!y\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336022555","body":"```\nvar getOrder = function(tasks) {\n    const res=[];\n    const queue = new MinPriorityQueue(); \n    tasks = tasks.map((task, index) => ({\n        index,\n        start: task[0],\n        time: task[1]\n    }))\n    tasks.sort((a, b) => b.start - a.start);\n    let time = 0;\n    while(tasks.length || !queue.isEmpty()){\n        if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\n            time = tasks[tasks.length - 1].start\n        }\n        while (tasks.length > 0 && tasks[tasks.length - 1].start <= time) {\n            const task = tasks.pop();\n            queue.enqueue(task, task.time * 100000 + task.index)\n        }\n        const { element } = queue.dequeue()\n        time += element.time;\n        res.push(element.index);\n    }\n    return res;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336369435","body":"```\nfunction numberOfRounds(loginTime: string, logoutTime: string): number {\n    const t1str=loginTime.split(':'),t2str=logoutTime.split(':')\n    const h1=t1str[0],m1=t1str[1],h2=t2str[0],m2=t2str[1]\n    let t1=60*parseInt(h1)+parseInt(m1), t2=60*parseInt(h2)+parseInt(m2)\n    if(t1>t2) t2+=24*60\n    t2 = ((t2 / 15) | 0) * 15\n    return (Math.max(0, (t2 - t1)) / 15) | 0\n}; \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336703733","body":"```\nfunction minCharacters(a: string, b: string): number {\n    let da = new Array(26).fill(0);\n    let db = new Array(26).fill(0);\n    let an = a.length, bn = b.length\n    for(let i=0;i<an;i++) {\n        da[a.charCodeAt(i) - 97] ++;\n    }\n    for(let i=0;i<bn;i++) {\n        db[b.charCodeAt(i) - 97] ++;\n    }\n    let asum = 0, bsum = 0, res = Number.MAX_SAFE_INTEGER;\n    for(let i = 0 ; i < 25 ; i ++) {\n        asum += da[i];\n        bsum += db[i];\n        res = Math.min(res, an+bn-da[i]-db[i], an-asum+bsum, bn-bsum+asum);\n    }\n    return Math.min(res, an+bn-da[25]-db[25]);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338645898","body":"```\nconst qs=(nums,l,r)=>{\n    if(l>=r) return \n    let std=nums[l],i=l-1,j=r+1\n    while(i<j){\n        while(nums[++i]<std);\n        while(nums[--j]>std);\n        if(i<j) [nums[i],nums[j]] = [nums[j],nums[i]] \n    }\n    qs(nums,l,j)\n    qs(nums,j+1,r)\n}\n\nfunction sortArray(nums: number[]): number[] {\n    qs(nums,0,nums.length-1)\n    return nums\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340297176","body":"```\nfunction mySqrt(x: number): number {\n    if(x===0) return x\n    let l=0,r=x\n    while(l<r){\n        let mid = ((l+r+1) / 2) |0\n        if(mid*mid > x){\n            r=mid-1\n        }else{\n           l=mid\n        }\n    }\n    return l\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342381820","body":"```\nvar solution = function(isBadVersion: any) {\n\n    return function(n: number): number {\n        let l=0,r=n\n        while(l<r){\n            let mid=((r + l + 1) / 2) | 0\n            if(!isBadVersion(mid)) l=mid\n            else r=mid-1\n        }\n        return isBadVersion(l) ? l : l+1\n        \n    };\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343866535","body":"```\nfunction reversePairs(nums: number[]): number {\n    let w=[]\n    const ms=(l,r):number=>{\n        if(l>=r) return 0\n        let mid= l+r >> 1\n        let res=ms(l,mid)+ms(mid+1,r)\n        for(let i=l,j=mid+1;i<=mid;i++){\n            while(j<=r && nums[j]*2<nums[i]) j++\n            res += j-(mid+1)\n        }\n        w.length=0\n        let i=l,j=mid+1\n        while(i<=mid&&j<=r){\n            if(nums[i]<=nums[j]) w.push(nums[i++])\n            else w.push(nums[j++])\n        }\n        while(i<=mid) w.push(nums[i++])\n        while(j<=r) w.push(nums[j++])\n        for(let i=l,j=0;j<w.length;i++,j++) nums[i]=w[j]\n        return res\n    }\n    return ms(0,nums.length-1)\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345952951","body":"```\nfunction swimInWater(grid: number[][]): number {\n    let g = grid,n=grid.length,st=[]\n    const dx = [-1, 0, 1, 0]\n    const dy = [0, 1, 0, -1]\n\n    const dfs=(x,y,mid)=>{\n        if(x===n-1 && y===n-1) return true\n        st[x][y]=true\n        for(let i=0;i<4;i++){\n            let a=dx[i]+x,b=dy[i]+y\n            if(a>=0&&a<n&&b>=0&&b<n&&g[a][b]<=mid&&!st[a][b]){\n                if(dfs(a,b,mid)) return true\n            }\n        }\n        return false\n    }\n\n    const check=(mid:number)=>{\n        if(g[0][0]>mid) return false\n        st=Array.from(new Array(n)).map(() => new Array(n).fill(false))\n        return dfs(0,0,mid)\n    }\n\n    let l=0,r=n*n-1\n    while(l<r){\n        let mid=l+r>>1\n        console.log(mid,check(mid))\n        if(check(mid)) r=mid\n        else l=mid+1\n    }\n    return l\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347782498","body":"```\nfunction maxVowels(s: string, k: number): number {\n    const t =['a', 'e', 'i', 'o',  'u']\n    const isVowel=(c:string) => t.indexOf(c) !== -1\n    let l=0,r=0,cnt=0\n    for(;r<k;r++){\n        if(isVowel(s[r])) cnt++\n    }\n    let max=cnt\n    for(;r<s.length;r++){\n        if(isVowel(s[l])) cnt--\n        if(isVowel(s[r])) cnt++\n        max=Math.max(max,cnt)\n        l++\n    }\n    return max\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350726080","body":"```\nfunction new21Game(n: number, k: number, maxPts: number): number {\n    if(k===0) return 1.0\n    let dp=new Array(k+maxPts).fill(0.0)\n    for(let i=k;i<=n&&i<k+maxPts;i++){\n        dp[i]=1.0\n    }\n    dp[k-1]=Math.min(n-k+1,maxPts) / maxPts\n    for(let i=k-2;i>=0;i--){\n        dp[i]=dp[i+1]-(dp[i+maxPts+1]-dp[i+1])/maxPts\n    }\n    return dp[0]\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352514306","body":"```\nfunction findAnagrams(s: string, p: string): number[] {\n    const m=new Map<string,number>()\n    for(let i=0;i<p.length;i++){\n        m.set(p[i],1+(m.has(p[i])?m.get(p[i]):0))\n    }\n    let l=0,r=0,res=[]\n    while(r<p.length){\n        if(m.has(s[r])){\n            m.set(s[r],m.get(s[r])-1)\n        }\n        r++\n    }\n    const vs = Array.from(m).map(m=>m[1])\n    if(vs.every(item=>item===0)) res.push(l)\n    while(r<s.length){\n        if(m.has(s[l])) m.set(s[l],1+(m.has(s[l])?m.get(s[l]):0))\n        l++\n        if(m.has(s[r])) m.set(s[r],m.get(s[r])-1)\n        r++\n        const vs = Array.from(m).map(m=>m[1])\n        if(vs.every(item=>item===0)) res.push(l)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354095657","body":"```\nfunction minWindow(s: string, t: string): string {\n  if (s.length < t.length) return ''\n  if(s===t) return s\n  const ht = new Map<string, number>()\n  const hs = new Map<string, number>()\n\n  t.split('').forEach(c => ht.set(c, 1 + (ht.get(c) ?? 0)))\n\n  let res = ''\n  let cnt = 0\n  const sArr = s.split('')\n  for (let i = 0, j = 0; i < sArr.length; i++) {\n    const c = sArr[i]\n    hs.set(c, 1 + (hs.get(c) ?? 0))\n    if (!ht.has(c)) continue\n\n    if (ht.get(c)! >= hs?.get(c)!) {\n      cnt++\n    }\n      \n    while (!ht.has(sArr[j]) || hs.get(sArr[j])! > ht.get(sArr[j])!) {\n      hs.set(sArr[j], hs.get(sArr[j])! - 1)\n      j++\n    }\n\n    if (cnt >= t.length) {\n      if (res === '' || res.length > i - j + 1) {\n        res = sArr.slice(j, i + 1).join('')\n      }\n    }\n  }\n\n  return res\n              \n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356622949","body":"```\nfunction readBinaryWatch(turnedOn: number): string[] {\nconst ans = [];\n    for (let h = 0; h < 12; ++h) {\n        for (let m = 0; m < 60; ++m) {\n            if (h.toString(2).split('0').join('').length + m.toString(2).split('0').join('').length === turnedOn) {\n                ans.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n            }\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358785886","body":"```\nfunction maxAreaOfIsland(grid: number[][]): number {\n    let n=grid.length,\n    m=grid[0].length,\n    g=grid,\n    res=0\n    const dx=[-1,0,1,0],dy=[0,1,0,-1]\n    const dfs=(x,y)=>{\n        let tmp=1\n        g[x][y]=0\n        for(let i=0;i<4;i++){\n            let a=dx[i]+x,b=dy[i]+y\n            if(a>=0&&a<n&&b>=0&&b<m&&g[a][b]===1){\n               tmp += dfs(a,b)\n            }\n        }\n        return tmp\n    }\n    for(let i=0;i<n;i++){\n        for(let j=0;j<m;j++){\n            if(g[i][j]===1){\n                res=Math.max(res, dfs(i,j))\n            }\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360837592","body":"```\nfunction maxDistance(grid: number[][]): number {\n  const dx = [-1, 0, 1, 0], dy = [0, 1, 0, -1]\n  let g = grid, n = g.length\n  let q = []\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < n; j++) {\n      if (g[i][j]) {\n        q.push([i, j])\n      }\n    }\n  }\n  if (q.length === 0 || q.length === n * n) {\n    return -1;\n  }\n  let t: number[] = [];\n  while (q.length > 0) {\n    t = q.shift()!\n    for (let i = 0; i < 4; i++) {\n      const x = dx[i] + t[0], y = dy[i] + t[1]\n      if (x < 0 || x >= n || y < 0 || y >= n || g[x][y] !== 0) continue\n      g[x][y] = g[t[0]][t[1]] + 1\n      q.push([x, y])\n    }\n  }\n  return g[t[0]][t[1]] - 1\n};\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364423873","body":"```\nfunction minCostClimbingStairs(cost: number[]): number {\n    const n=cost.length\n    let dp=new Array(n+1)\n    dp[0]=dp[1]=0\n    for(let i=2;i<=n;i++){\n        dp[i]=Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])\n    }\n    return dp[n]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364636079","body":"```\nfunction rob(nums: number[]): number {\n    const n=nums.length\n    let f=new Array(n+1).fill(0),g=new Array(n+1).fill(0)\n    for(let i=1;i<=n;i++){\n        f[i]=g[i-1]+nums[i-1]\n        g[i]=Math.max(f[i-1],g[i-1])\n    }\n    return Math.max(f[n],g[n])\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297971841","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 解题思路\n模拟加法运算规则，从低位往高位每个数位依次运算。\\\n从数组中获取数位信息，直接`num[index]`\\\n从数字`k`中获得数位信息，每次进行`k % 10`\\\n运算时注意进位，每次将数位计算结果存入链表前端。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int carry = 0;\n        int n = num.length;\n        int index = n - 1; // record the index of array num that currently used in calculation\n        int dk = 0; // record the digit from k\n        int dn = 0; // record the digit from num\n\n        while (k > 0) {\n            dk = k % 10; // get the next digit from k\n            dn = 0;\n            if (index >= 0) {\n                dn = num[index--];\n            }\n            res.add(0, (carry + dk + dn) % 10); // insert the result digit to the front of the linked list\n            carry = (carry + dk + dn) / 10; // calculate carry digit\n            k /= 10; // move left to one digit\n        }\n        // when all the digits in k are used in calculation, while there are still digits in num that are not used\n        // continue to record the digits in num to res\n        while (index >= 0) {\n            res.add(0, (carry + num[index]) % 10);\n            carry = (carry + num[index]) / 10;\n            index--;\n        }\n        // if there is a carry not equal to 0, need to add one more digit for the carry\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(max(n, logk)), 创建链表储存结果，链表长度为两个长度最大值","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299441621","body":"### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 解题思路\n字符串遍历问题\\\n遍历两次字符串：\\\n第一次正向遍历从左至右，计算每个字符和左边出现的特殊字符的最近距离；\\\n第二次反向遍历从右至左，计算每个字符和右边出现的特殊字符的最近距离，并把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        Arrays.fill(res, n); // fill initial values, distance cannot be longer than n\n        // traverse from the left, calculate the distance between current letter and the nearest c on its left\n        int left = -1;\n        for (int i = 0; i < n; i++) {\n            char cur = s.charAt(i);\n            if (cur == c) {\n                res[i] = 0;\n                left = i;\n            } else {\n                if (left == -1) {\n                    continue;\n                } else {\n                    res[i] = i - left;\n                }\n            }\n        }\n        // traverse from the right, calculate the distance between current letter and the nearest c on its right\n        int right = n;\n        for (int j = n - 1; j >= 0; j--) {\n            char cur = s.charAt(j);\n            if (cur == c) {\n                res[j] = 0;\n                right = j;\n            } else {\n                if (right == n) {\n                    continue;\n                } else {\n                    res[j] = Math.min(res[j], right - j);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数为2倍字符串长度\n- 空间复杂度：O(1)，没有额外开空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301694371","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 解题思路\n用数组来实现栈，设置变量`size`记录数组当前长度，用来快速判断栈是否已满，并且快速查找栈顶元素。\\\n用模拟实现`Increment`，更新数组中符合条件（下标在`0`到`min(k, size) - 1`)的所有元素\n\n### 代码（方法1）\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            return stack[--size];\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        // update the elements in the stack by incrementing val\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(k)\n- 空间复杂度：O(maxSize)\n\n### 代码（方法2）\n`Increment`操作时间复杂度高，可优化。没有必要在`Increment`操作中更新所有的元素。\\\n可以用另一个数组`inc`记录每次`Increment`操作时的增加值，增加值只记录到从栈底开始最后一个被增加的位置。因为出栈操作在栈顶，每次我们可以求出栈顶元素被增加的值，并且顺势更新出栈后下一个栈顶元素的增加值，这样时间复杂度就可以降到O(1)\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int[] inc;  // record the increment value\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            size--;\n            int res = stack[size] + inc[size];\n            // calculate the increment value for the element on the top of the stack after pop\n            if (size > 0) {\n                inc[size - 1] += inc[size];\n            }\n            // reset the increment value, cannot put inside if condition\n            inc[size] = 0;\n            return res;\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        if (k > 0) {\n            // record the increment value at the position k - 1, all the elements with index 0 to k - 1 were incremented\n            inc[k - 1] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(1)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303792321","body":"### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n### [官方题解](https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/)\n\n### 解题思路\n用栈来解决。重复的部分满足格式`k[encoded_string]`，先将除`]`外的字符入栈，遇到`]`说明重复的部分出现，先出栈字母，再出栈`[`，最后出栈数字。根据数字将重复部分重新入栈。最后出栈所有字符获得字符串即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c); // push characters into stack if it is not ']'\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n\t\t\t\t// get the repeated characters\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n\t\t\t\t// pop '[' from stack\n                stack.pop();\n\n                sb = new StringBuilder();\n\t\t\t\t// get the repeated times\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n\t\t\t\t// push the repeated characters back into stack\n                while (count > 0) {\n                    for (char element: sub.toCharArray()) {\n                        stack.push(element);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n令字符串长度为n\n- 时间复杂度：O(n)，需要遍历字符串\n- 空间复杂度：O(n)，创建栈储存字符","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304423074","body":"### 解题思路\n创建两个栈`in`和`out`分别储存input和output，`in`栈元素出栈然后入栈得到`out`栈，顺序相反，可以实现FIFO。当有元素入列时，push进`in`栈。当有元素出列时，先看`out`栈是否非空，如果为空将`in`栈中元素导入到`out`栈中，然后出列。\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty为O(1)，pop和peek平均O(1)，最坏O(n)\n- 空间复杂度：O(n)，使用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725202","body":"### 解题思路\n使用单调栈。令`currentMax`为对应排序块中最大元素，我们在栈中只存`currentMax`，则所存的`currentMax`单调递增。如果新元素小于前面块的`currentMax`，新元素需要和前面的块合并，我们需要更新栈中保留的`currentMax`。最后返回栈的长度即为最多块数。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && stack.peek() > arr[i]){\n                int currentMax = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                        stack.pop();\n                }\n                stack.push(currentMax);\n            }\n            else {\n                stack.push(arr[i]);\n            }    \n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n令n为数组长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305106769","body":"### 解题思路\n先将链表链接成环，之后再找到旋转之后的head，在head的前一个node和head之间断开\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode current = head;\n        ListNode previous = head;\n\n        if (head == null) return head;\n\n        int length = 1;\n\n        // find current tail and connect it to head\n        while (current.next != null) {\n            current = current.next;\n            length++;\n        }\n        current.next = head;\n\n        current = head;\n        // find the new head\n        for (int i = 0; i < length - k % length; i++) {\n            previous = current;\n            current = current.next;\n        }\n        // set the previous node as tail\n        previous.next = null;\n        return current;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306574844","body":"### 解题思路\n用`node1`和`node2`记录两个相邻的需要交换的nodes，同时记录`node1`之前node和`node2`之后node，按照交换后的顺序连接起来这4个nodes即可。注意最后要检查null pointer。\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode node1 = head;\n        ListNode node2 = head.next;\n        ListNode pre = null;\n        head = node2;\n\n        while (node1 != null && node2 != null) {\n            ListNode temp = node2.next;\n            node2.next = node1;\n            node1.next = temp;\n            if (pre != null) pre.next = node2;\n            pre = node1;\n            if (temp == null) break;\n            else {\n                node1 = temp;\n                node2 = temp.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308285918","body":"### 解题思路\n因为要转化为高度平衡的二叉搜索树，所以在链表中选择根节点时要保证左右两边的链表长度差距不大于1。根据此条件，问题转化为链表找中点问题。递归即可求出二叉搜索树。\n\n### 代码\n\n```java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) return null;\n        if (head.next == null) return new TreeNode(head.val);\n\n        ListNode left = head;\n        ListNode pre = null;\n        ListNode right = null;\n\n        ListNode fast = head;\n        ListNode slow = head;\n\n        // find midpoint\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            pre = slow;\n            slow = slow.next;\n        }\n        // slow is the midpoint, set as subtree's root\n        right = slow != null ? slow.next : null;\n        pre.next = null;\n\n        return new TreeNode(slow.val, sortedListToBST(left), sortedListToBST(right));\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309799635","body":"### 解题思路\n从两个链表的头headA和headB同时出发遍历链表，当链表A遍历结束后从headB出发继续遍历，当链表B遍历结束后从headA出发继续遍历。\\\n假设两个链表有交点，链表A从headA到交点的长度为A，链表B从headB到交点的长度为B，交点之后的长度为C。当两者相遇时，都走过了(A + B + C)的长度，相遇点即为交点。\\\n如果两个链表没有交点，则遍历完两个链表都走过了(A + B)的长度，此时返回null，表示无交点。\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode cur1 = headA;\n        ListNode cur2 = headB;\n        while (cur1 != cur2) {\n            cur1 = cur1 == null ? headB: cur1.next;\n            cur2 = cur2 == null ? headA: cur2.next;\n        }\n        return cur1;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311204590","body":"### 解题思路\n\n快慢指针。`fast`每次前进两格，`slow`每次前进一格。如果无环则`fast`率先到达尾部null。如果有环，则在相遇时重置`fast`为`head`，每次前进一格，再次相遇节点即为开始入环的第一个节点。\n\n### 代码\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) return null;\n        ListNode fast = head;\n        ListNode slow = head;\n\n        do {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == null || fast.next == null) return null;\n        } while (fast != slow);\n\n        fast = head;\n        while (fast != slow) {\n            fast = fast.next;\n            slow = slow.next;\n        }       \n        return fast;\n    }\n}\n```\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312379906","body":"### 解题思路\n使用哈希表和双向链表，哈希表可以在O(1)时间快速查找对应节点，双向链表可以在知道节点位置的情况下在O(1)时间移动和删除节点\n\n### 代码\n\n```java\nclass LRUCache {\n\n    class DListNode {\n        int key;\n        int val;\n        DListNode pre;\n        DListNode next;\n        DListNode() {}\n        DListNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n\n    private int size;\n    private int cap;\n    private DListNode head;\n    private DListNode tail;\n    private Map<Integer, DListNode> cache = new HashMap<>();\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n        head = new DListNode();\n        tail = new DListNode();\n        head.next = tail;\n        tail.pre = head;\n    }\n    \n    public int get(int key) {\n        if (!cache.containsKey(key)) return -1;\n        DListNode node = cache.get(key);\n        moveToHead(node);\n        return node.val;\n    }\n    \n    public void put(int key, int value) {       \n        if (cache.containsKey(key)) {\n            DListNode node = cache.get(key);\n            node.val = value;\n            moveToHead(node);\n        }    \n        else {\n            DListNode newNode = new DListNode(key, value);\n            size++;\n            cache.put(key, newNode);\n            if (size > cap) {\n                cache.remove(tail.pre.key);\n                removeNode(tail.pre);\n                size--;           \n            }           \n            addToHead(newNode);\n        }          \n    }\n\n    private void addToHead(DListNode node) {\n        node.pre = head; \n        node.next = head.next;\n        head.next.pre = node;\n        head.next = node;              \n    }\n\n    private void removeNode(DListNode node) {\n        if (node.pre == null || node.next == null) return;\n        node.pre.next = node.next;\n        node.next.pre = node.pre;      \n    }\n\n    private void moveToHead(DListNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n```\n\n**复杂度分析**\n\n令n为容量capacity\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)，使用哈希表和双向链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312656486","body":"### 解题思路\n递归，base case是`root == null`，此时最大深度为0。其余条件下比较左右子树的最大深度，取较大者+1。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n```\n**复杂度分析**\n令n为二叉树节点数\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312843030","body":"### 解题思路\n递归，每个节点分别判断节点是否都为空，是否节点值相等，两个左子树是否相等，两个右子树是否分别相等。\n\n### 代码\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        else if (p == null || q == null) return false;\n        else if (p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314805948","body":"### 解题思路\nDFS, 每走完一条路径到叶子节点则将此路径代表的数字加到`res`中。\n\n### 代码\n\n```java\nclass Solution {\n    private int res;\n\n    public int sumNumbers(TreeNode root) {\n        dfs(root, 0);\n        return res;\n    }\n\n    private void dfs(TreeNode root, int last) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            res += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left, last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316348309","body":"### 解题思路\nBFS，返回最后一层的第一个节点的值即为树左下角的值。\n\n### 代码\n\n```java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res = 0;\n        Deque<TreeNode> queue = new ArrayDeque<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            res = queue.peek().val;\n            for (int i = 0; i < size; i++) {\n                TreeNode cur = queue.poll();\n                if (cur.left != null) {\n                    queue.offer(cur.left);\n                }\n                if (cur.right != null) {\n                    queue.offer(cur.right);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为树的节点数\n- 空间复杂度：O(q)，q为队列长度，最坏情况是满二叉树（full binary tree），底层节点数约为n/2，空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1319284761","body":"### 解题思路\r\nBFS\r\n- 序列化：用BFS遍历树，不管node的左右子节点是否存在，都加到队列中；在节点出队时，如果节点不存在，在返回的String中加入\"null\"，如果节点存在，加入节点值的字符串形式。现在末尾处的多余的null还出现在字符串中，有待优化。\r\n- 反序列化：同样使用BFS，利用队列新建二叉树。将data转化字符串数组，然后遍历，只要不为null则将节点按顺序加入二叉树中，同时将节点入队，队列为空时遍历完毕，返回根节点。\r\n\r\n### 代码\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode(int x) { val = x; }\r\n * }\r\n */\r\npublic class Codec {\r\n\r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        if (root == null) return \"\";\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append(\"[\");\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (node != null) {\r\n                sb.append(\"\" + node.val); // convert to string\r\n                sb.append(\",\");\r\n                queue.offer(node.left);\r\n                queue.offer(node.right);\r\n            }\r\n            else {\r\n                sb.append(\"null,\");\r\n            }\r\n        }\r\n        sb.deleteCharAt(sb.length() - 1);\r\n        sb.append(\"]\");      \r\n        return sb.toString();  \r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        if (\"\".equals(data)) return null;\r\n\r\n        String[] datalist = data.substring(1, data.length() - 1).split(\",\");\r\n        TreeNode root = new TreeNode(Integer.parseInt(datalist[0]));\r\n        Deque<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int i = 1;\r\n        while (!queue.isEmpty()) {\r\n            TreeNode node = queue.poll();\r\n            if (!\"null\".equals(datalist[i])) {\r\n                node.left = new TreeNode(Integer.parseInt(datalist[i]));\r\n                queue.offer(node.left);\r\n            }\r\n            i++;\r\n            if (!\"null\".equals(datalist[i])) {\r\n                node.right = new TreeNode(Integer.parseInt(datalist[i]));\r\n                queue.offer(node.right);\r\n            }\r\n            i++;\r\n        }        \r\n        return root;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，n为树的节点数\r\n- 空间复杂度：O(q)，q为队列长度，最坏情况是满二叉树，O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319531997","body":"### 解题思路\nBFS + 哈希表 + 排序。用一个哈希表储存整个树在不同列的节点值的数组。用BFS对树逐层进行遍历，每一层用另一个哈希表储存该层出现的在不同列的节点值的数组，将数组中的节点值按从小到大排好序后，合并到整棵树的哈希表中。最后将哈希表转换格式输出结果。\n\n### 代码\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n\n        Map<Integer, List<Integer>> map = new TreeMap<>(); // treemap will sort the keys\n        Deque<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0));\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            Map<Integer, List<Integer>> levelMap = new HashMap<>(); // use a map to track node values from the same row and same column\n            List<Integer> values;\n            List<Integer> levelVals;\n            // traverse nodes at each level\n            for (int i = 0; i < size; i++) {\n                Pair<TreeNode, Integer> nodePair = queue.poll();                \n                TreeNode node = nodePair.getKey();\n                int col = nodePair.getValue();\n                // add node values from the same column to the list of the map\n                if (!levelMap.containsKey(col)) {\n                    levelVals = new ArrayList<>();\n                }\n                else {\n                    levelVals = levelMap.get(col);\n                }\n                levelVals.add(node.val);\n                levelMap.put(col, levelVals);\n\n                if (node.left != null) {\n                    queue.offer(new Pair<>(node.left, col - 1));\n                }\n                if (node.right != null) {\n                    queue.offer(new Pair<>(node.right, col + 1));\n                }\n            }\n            // add results obtained from this row to the result map\n            for (int col: levelMap.keySet()) {\n                if (!map.containsKey(col)) {\n                    values = new ArrayList<>();\n                }\n                else {\n                    values = map.get(col);\n                }\n                \n                levelVals = levelMap.get(col);\n                Collections.sort(levelVals); // sort the node values from the same column and same row\n                values.addAll(levelVals); // combine values from the same column\n                map.put(col, values);\n            }   \n        }\n        \n        for (int col: map.keySet()) {\n            res.add(map.get(col));\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320829334","body":"### 解题思路\n哈希表。建立哈希表储存数字和其对应的索引，对数组进行一次遍历，每次先查哈希表看表中有无`target - nums[i]`，如果有则返回结果，如果没有在将当先数字和其索引存入哈希表。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int[] res = new int[2];\n\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(target - nums[i])) {\n                res[0] = map.get(target - nums[i]);\n                res[1] = i;\n                break;\n            }\n            else {\n                map.put(nums[i], i);\n            }\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320955789","body":"### 解题思路\n方法一：哈希表+桶排序。哈希表储存数字和对应出现次数。从最后一个桶开始往前遍历取k个元素。\n\n方法二：哈希表+堆排序。哈希表储存数字和对应出现次数。建立一个容量为k的最小堆。遍历哈希表，将表中元素存入最小堆中。当堆的容量超过k时，去除堆顶出现次数最少的元素。最后返回堆中对应的k个数字即可。\n\n### 代码\n方法一：\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num: nums) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer>[] bucket = new List[nums.length + 1]; // from 0 to nums.length\n        LinkedList<Integer> res = new LinkedList<>(); // specify to use linked list instead of general list\n\n        for (int num: map.keySet()) {\n            int count = map.get(num);\n            if (bucket[count] == null) {\n                bucket[count] = new LinkedList<Integer>();\n            }\n            bucket[count].add(num);\n        }\n\n        for (int i = nums.length; i >= 0; i--) {\n            if (bucket[i] != null) {\n                for (int num: bucket[i]) {\n                    res.add(num);\n                }\n            }\n        }\n\n        int[] ans = new int[k];\n        for (int i = 0; i < k; i++) {\n            ans[i] = res.removeFirst();\n        }\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)，n为数组长度\n\n方法二：\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> counts = new HashMap<>();\n        for (int n: nums) {\n            counts.put(n, counts.getOrDefault(n, 0) + 1);\n        }\n        int[] res = new int[k];\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(\n            (a, b) -> counts.get(a) - counts.get(b)\n        );\n        for (int key: counts.keySet()) {\n            minHeap.offer(key);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            res[i] = minHeap.poll();\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogk)，n为数组长度，k为堆的容量\n- 空间复杂度：O(n)，n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321489200","body":"### 解题思路\n确定中心点，然后用哈希表记录不同距离对应的点的个数，用排列组合公式求出回旋镖个数，最后加总求得总数。\n\n### 代码\n\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int num = 0;\n        Map<Double, Integer> map = new HashMap<>();\n        for (int i = 0; i < points.length; i++) {\n            int[] base = points[i];\n            for (int j = 0; j < points.length; j++) {\n                int[] cur = points[j];\n                double d = Math.pow(cur[0] - base[0], 2.0) + Math.pow(cur[1] - base[1], 2.0);\n                map.put(d, map.getOrDefault(d, 0) + 1);\n            }\n            for (double d: map.keySet()) {\n                int count = map.get(d);\n                num += count * (count - 1);\n            }\n            map.clear();\n        }\n        return num;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323149925","body":"### 解题思路\n滑动窗口，哈希表。建立哈希表储存字符。使用变量`start`记录无重复字符串的起始点，用变量`end`记录当前遍历的位置，用`max`记录当前最长无重复字符串的长度。遍历字符串，每次找到左边第一个满足条件的`start`的位置，如果遇到重复字符，向右移动`start`直到重复字符从哈希表里删除，每次更新`max`。遍历结束返回`max`即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<>();\n        int start = 0;\n        int max = 0;\n        for (int end = 0; end < s.length(); end++) {\n            char cur = s.charAt(end);\n            while (set.contains(cur)) {\n                char prev = s.charAt(start);\n                set.remove(prev);\n                start++;\n            }\n            max = Math.max(max, end - start + 1);\n            set.add(cur);\n        }\n        return max;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324549480","body":"### 解题思路\n哈希表。建立初始哈希表储存串联所有单词的子串的单词和对应出现次数。遍历字符串`s`确定子串起始点。每次先复制初始的哈希表，然后从起始点开始截取长度为`words[i].length`的子字符串，看该子字符串是否出现在哈希表中。如果没出现，则将起始点后移一位。如果出现，更新哈希表，出现次数减1，次数为0时则将Key从哈希表中删除。重复次循环继续截取长度为`words[i].length`的子字符串，直到哈希表为空。如果循环结束哈希表为空，表示子串中所有单词全部找到，将起始点存放到结果数组中，将起始点后移继续遍历。最后返回结果数组。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> res = new ArrayList<>();\n        int slen = s.length();\n        int num = words.length;\n        int wlen = words[0].length();\n        if (slen < num * wlen) return res;\n\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String word: words) {\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\n        }\n\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i <= slen - num * wlen; i++) {\n            String sub = \"\";\n            int start = i;         \n            map.putAll(wordMap);\n            do {\n                sub = s.substring(start, start + wlen);\n                if (!map.containsKey(sub)) break;\n                int count = map.get(sub) - 1;\n                if (count == 0) map.remove(sub);\n                else map.put(sub, count);\n                start += wlen;\n            } while (!map.isEmpty());\n\n            if (map.isEmpty()) res.add(i);\n            map.clear();\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：令n为字符串`s`的长度，m为`words`的长度，l为每个单词的长度。如果将`substring()`函数操作数定为1，则为O(mn)。如果将`substring()`函数操作数定为l，则为O(mnl)\n- 空间复杂度：O(m)，每次需要用到一个长度为m的哈希表。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325944885","body":"### 解题思路\n计算数组`nums`的前缀和，然后求除k的余数（注意负数的特殊情况），用哈希表记录相同余数的前缀和的数目，根据同余定理，相同余数的前缀和相减即可得到整除k的subarray，每次求出以当前元素为最后元素的满足条件的subarray的数量，加总求和即为最终结果。\n\n### 代码\n```java\nclass Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        int res = 0;\n        Map<Integer, Integer> counts = new HashMap<>();\n        counts.put(0, 1);\n        int sum = 0;\n        for (int n: nums) {\n            sum += n;\n            int residue = sum % k >= 0 ? sum % k : k + sum % k;\n            int cur = counts.getOrDefault(residue, 0);\n            res += cur;\n            counts.put(residue, cur + 1);\n        }\n        return res;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326841401","body":"### 解题思路\n双指针。设置快慢双指针，初始值都设为head，慢指针每次移动1，快指针每次移动2，直到快指针到达尾部`fast == null || fast.next == null`，返回慢指针即为中点。\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为链表长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327954564","body":"### 解题思路\n双指针。读写指针。指针`i`用来做读操作，遍历整个数组。指针`j`用来做写操作，记录前一个无重复的元素的位置。每次遇到不重复的元素则更新`nums[++j]`。最后返回`j+1`即为删除后数组的新长度。\n\n### 代码\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int j = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] != nums[j]) {\n                nums[++j] = nums[i];\n            }\n        }\n        return j + 1;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328098273","body":"### 解题思路\n二分查找。找左边第一个大于等于`target`的元素的下标，即为结果。如果没有这样的元素，则`target`应该插入到数组最后，返回`nums.length`。\n\n### 代码\n\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while (left < right - 1) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        if (nums[left] >= target) {\n            return left;\n        }\n        if (nums[right] >= target) {\n            return right;\n        }\n        return nums.length;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(log n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328395029","body":"### 解题思路\n单调队列。不需要储存窗口内所有的元素。如果新进入的元素比前面的大，可以直接将前面的元素移除。这样每一时刻我们都会得到一个单调递减队列，队首元素为最大值。\n具体做法：入队列。然后移除失效元素，包括(1) 超出窗口范围的元素，(2) 队列尾部小于当前值的元素。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        Deque<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < k; i++) {\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.offerLast(i);\n        }\n        int n = nums.length;\n        int[] res = new int[n - k + 1];\n        res[0] = nums[queue.peekFirst()];\n        for (int i = k; i < n; i++) {\n            while (!queue.isEmpty() && nums[i] > nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.offerLast(i);\n            if (queue.peekFirst() < i - k + 1) {\n                queue.pollFirst();\n            }\n            res[i - k + 1] = nums[queue.peekFirst()];\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(k)，需要队列，队列中不超过k元素","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330106634","body":"### 解题思路\n信任关系可以用图来表示。每个顶点表示不同的人，每条有向边表示信任关系，从表示信任的人到被信任的人。因为法官不相信任何人，而每个人都信任法官，所以法官的入度为`n-1`，出度为`0`。找到这样条件的顶点即可。\n\n### 代码\n\n```java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        if (trust.length == 0 && n == 1) return 1;\n        int[] deg = new int[n + 1]; // use array to store the difference of indegree and outdegree\n        for (int i = 0; i < trust.length; i++) {\n            deg[trust[i][0]]--; // outdegree\n            deg[trust[i][1]]++; // indegree\n        }\n        for (int i = 1; i < n + 1; i++) {\n            if (deg[i] == n - 1) return i;\n        }\n        return -1;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为人数\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331634291","body":"### 解题思路\nDFS, 染色法。根据题目信息建立邻接表来表示图。然后进行DFS，看每条边相邻两个点是否都能够染上不同颜色（颜色表示：0表示为染色，1表示染红色，-1表示染蓝色，变到相反颜色乘-1即可）。\n\n### 代码\n\n```java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    int[] colors;\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        graph = new ArrayList[n + 1];\n        for (int i = 0; i <= n; i++) {\n            graph[i] = new ArrayList<Integer>();\n        }\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        colors = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            if (colors[i] == 0 && !dfs(i, 1)) return false;\n        }\n        return true;        \n    }\n\n    private boolean dfs(int node, int color) {\n        if (colors[node] != 0) return colors[node] == color;\n        colors[node] = color;\n        for (int next: graph[node]) {\n            if (colors[next] == 0 && !dfs(next, -color)) return false;\n            if (colors[next] == color) return false;\n        }\n        return true;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n + m)，n为顶点数，m为边数\n- 空间复杂度：O(n + m)，使用邻接表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333067025","body":"### 解题思路\n拓扑排序，BFS。分别对组和项目进行拓扑排序。然后根据组和项目的一对多对应关系，合并成最终的拓扑排序结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 1. label the unassigned projects, group = -1\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 2. initiate adjacent list for group and project\n        List<Integer>[] groupGraph = new ArrayList[m];\n        List<Integer>[] itemGraph = new ArrayList[n];\n        for (int i = 0; i < m; i++) groupGraph[i] = new ArrayList<>();\n        for (int i = 0; i < n; i++) itemGraph[i] = new ArrayList<>();\n\n        // 3. build graphs and get indegree information\n        int[] groupIndegree = new int[m];\n        int[] itemIndegree = new int[n];\n\n        int len = group.length; // m changed\n        for (int i = 0; i < len; i++) {\n            int curGroup = group[i];\n            for (int beforeItem: beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != curGroup) {\n                    groupGraph[beforeGroup].add(curGroup);\n                    groupIndegree[curGroup]++;\n                }\n            }\n        } \n\n        for (int i = 0; i < n; i++) {\n            for (int item: beforeItems.get(i)) {\n                itemGraph[item].add(i);\n                itemIndegree[i]++;\n            }\n        }\n\n        // 4. Get topo sort results\n        List<Integer> groupList = tpsort(groupGraph, groupIndegree, m);\n        if (groupList.size() == 0) return new int[0];\n        List<Integer> itemList = tpsort(itemGraph, itemIndegree, n);\n        if (itemList.size() == 0) return new int[0];\n\n        // 5. create map from group to project\n        Map<Integer, List<Integer>> map = new HashMap<>();\n        for (int item: itemList) {\n            map.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 6. get the final project topo sort result\n        List<Integer> res = new ArrayList<>();\n        for (int groupId: groupList) {\n            List<Integer> items = map.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n \n    }\n\n    private List<Integer> tpsort(List<Integer>[] graph, int[]indegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Deque<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 0) queue.offer(i);\n        }\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            res.add(node);\n            for (int next: graph[node]) {\n                indegree[next]--;\n                if (indegree[next] == 0) {\n                    queue.offer(next);\n                }\n            }\n        }\n        if (res.size() == n) return res;\n        return new ArrayList<>();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(m + n)\n- 空间复杂度：O(m + n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334747154","body":"### 解题思路\n模拟。最后看返回的坐标是否为(0, 0)。\n\n### 代码\n\n```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336105669","body":"### 解题思路\n模拟+排序+小顶堆。先将tasks二维数组转化为三维数组，另加入原始index，因为返回结果时要使用index。将三维数组按enqueueTime排序。再建立小顶堆来储存可执行的任务项。遍历三维数组，将任务开始时间满足条件（不大于当前时间）的所有任务放入小顶堆，如果没有符合条件的任务，重置当前时间。然后通过小顶堆选出合适任务，将原始index放入结果数组，更新当前时间。照此循环直至所有任务都排好序放入结果数组。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        // convert 2D array to 3D array to store original index information\n        int[][] indices = new int[tasks.length][3];\n        for (int i = 0; i < tasks.length; i++) indices[i] = new int[]{tasks[i][0], tasks[i][1], i};\n        // sort the 3D array according to enqueueTime\n        Arrays.sort(indices, new Comparator<int[]>() {\n            public int compare(int[] t1, int[] t2) {\n                return t1[0] - t2[0];\n            }\n        });\n        // create min-heap to store the tasks ready to execute\n        PriorityQueue<int[]> heap = new PriorityQueue<>(new Comparator<int[]>() {\n            public int compare(int[] t1, int[] t2) {\n                if (t1[0] == t2[0]) return t1[1] - t2[1];\n                return t1[0] - t2[0];\n            }\n        });\n\n        int time = 0;\n        int[] res = new int[tasks.length];\n        int num = 0;\n        \n        for (int i = 0; i < res.length; i++) {\n            // no task is ready for current time, reset time\n            if (num < indices.length && time < indices[num][0] && heap.isEmpty()) time = indices[num][0]; \n            // put the ready tasks into heap\n            while (num < indices.length && time >= indices[num][0]) {\n                heap.offer(new int[]{indices[num][1], indices[num][2]});\n                num++;\n            }\n            int[] cur = heap.poll();\n            time += cur[0];\n            res[i] = cur[1];\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)，n为数组长度，主要为排序和小顶堆耗时\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336323468","body":"### 解题思路\n模拟。先把时间从String转化为int。在判断finishTime是否大于startTime，如果不是，finishTime加上24。然后把开始时间向上计算得到最接近的15分钟，把结束时间向下计算得到最接近的15分钟。按照分钟差值计算对局数。注意edge case：时间相隔不到15分钟，按照此法计算最后会得-1，需要改为0。\n\n### 代码\n\n```java\nclass Solution {\n    public int numberOfRounds(String startTime, String finishTime) {\n        int shour = Integer.parseInt(startTime.substring(0, 2));\n        int smin = Integer.parseInt(startTime.substring(3));\n        int fhour = Integer.parseInt(finishTime.substring(0, 2));\n        int fmin = Integer.parseInt(finishTime.substring(3));\n\n        if (fhour == shour && fmin < smin) fhour += 24;\n        if (fhour < shour) fhour += 24;\n\n        smin = (smin + 14) / 15 * 15;\n        if (smin == 60) {\n            smin = 0;\n            shour++;\n        }\n\n        fmin = fmin / 15 * 15;\n\n        int total = (fhour - shour) * 60 + fmin - smin;\n        return total >= 0 ? total / 15 : 0;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336525623","body":"### 解题思路\n枚举。先遍历字符串，获得每个字母出现的次数，存入26个元素的数组中。然后分别考虑三种情况。第一二种情况，考虑各种可能性，下标可能从1到25，分别求出cost。第三种情况则找到相同下标出现元素个数最多的，即为最小cost。最后三种情况的最小cost比较，返回最小值。\n\n### 代码\n\n```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int[] aletters = new int[26], bletters = new int[26];\n        // count the number of each letter in a\n        for (char c: a.toCharArray()) {\n            aletters[c - 'a']++;\n        }\n        // count the number of each letter in b\n        for (char d: b.toCharArray()) {\n            bletters[d - 'a']++;\n        }\n        int res = a.length() + b.length() - equalCostMax(aletters, bletters); // this is the cost to change a and b to the same letter\n        res = Math.min(res, greaterCostMin(aletters, bletters)); // compare with the cost making every letter in a greater than b\n        res = Math.min(res, greaterCostMin(bletters, aletters)); // compare with the cost making every letter in b greater than a\n        return res;\n    }\n\n    private int greaterCostMin(int[] arr1, int[] arr2) {\n        // make all numbers in arr1 greater than all numbers in arr2\n        int res = Integer.MAX_VALUE;\n        // consider each possible minimal letter in the String/minimal number in the Array (from b to z, 1 to 25)\n        for (int i = 1; i < 26; i++) {\n            int count = 0;\n            // add the numbers smaller than i from arr1 into count, these need to be changed\n            for (int j = 0; j < i; j++) {\n                count += arr1[j];\n            }\n            // add the numbers greater than i from arr2 into count, these need to be changed\n            for (int j = i; j < 26; j++) {\n                count += arr2[j];\n            }\n            res = Math.min(res, count);\n        }\n        return res;\n    }\n\n    private int equalCostMax(int[] arr1, int[] arr2) {\n        // make all numbers in arr1 and arr2 equal to the same number\n        int res = -1;\n        for (int i = 0; i < 26; i++) {\n            int count = arr1[i] + arr2[i];\n            res = Math.max(res, count);\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(m + n)，m为a的长度，n为b的长度\n- 空间复杂度：O(1)，创建两个数组储存a和b的各字母出现次数，长度均为常数26","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338774985","body":"### 解题思路\n快速排序。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuickSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    private void randomizedQuickSort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuickSort(nums, l, pos - 1);\n            randomizedQuickSort(nums, pos + 1, r);\n        }\n    }\n\n    private int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // random index for pivot\n        swap(nums, i, r); // move the pivot to the right\n        return partition(nums, l, r);\n    }\n\n    private int partition(int[] nums, int l, int r) {\n        int i = l - 1;\n        int pivot = nums[r];\n        for (int j = l; j < r; j++) {\n            if (nums[j] > pivot) continue;\n            else {\n                i++; // i used to point to the position storing the value less than pivot\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1; // pivot is at the correct position\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340333432","body":"### 解题思路\n二分法。寻找最右边的满足条件的值。\n\n### 代码\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x;\n        int mid = 0;\n        int ans = -1;\n        while (l <= r) {\n            mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) { // convert to long to avoid overflow\n                ans = mid;\n                l = mid + 1;\n            }\n            else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(logx)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341928742","body":"### 解题思路\n二分法，寻找最左边的满足条件的值。因为题目中说一定有满足条件的值出现，所有可以省去检查边界的部分。\n\n### 代码\n\n```java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (isBadVersion(mid)) r = mid - 1;\n            else l = mid + 1;\n        }\n        return l;        \n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(logn)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344876195","body":"### 解题思路\r\n分治，归并排序变种题。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int reversePairs(int[] nums) {\r\n        if (nums.length < 2) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.length - 1);\r\n    }\r\n\r\n    private int reversePairsRecursive(int[] nums, int left, int right) {\r\n        if (left == right) return 0;\r\n        int mid = left + (right - left) / 2;\r\n        int n1 = reversePairsRecursive(nums, left, mid);\r\n        int n2 = reversePairsRecursive(nums, mid + 1, right);\r\n        int res = n1 + n2;\r\n\r\n        int i = left, j = mid + 1;\r\n        while (i <= mid) {\r\n            while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\r\n                j++;\r\n            }\r\n            res += j - (mid + 1);\r\n            i++;\r\n        }\r\n\r\n        int[] sorted = new int[right - left + 1];\r\n        int p1 = left, p2 = mid + 1;\r\n        int p = 0;\r\n        while (p1 <= mid || p2 <= right) {\r\n            if (p2 > right) {\r\n                sorted[p++] = nums[p1++];\r\n            }\r\n            else if (p1 > mid) {\r\n                sorted[p++] = nums[p2++];\r\n            }\r\n            else {\r\n                if (nums[p1] <= nums[p2]) {\r\n                    sorted[p++] = nums[p1++];\r\n                }\r\n                else {\r\n                    sorted[p++] = nums[p2++];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int k = 0; k < sorted.length; k++) {\r\n            nums[left + k] = sorted[k];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345292768","body":"### 解题思路\n能力二分。\n\n### 代码\n\n```java\nclass Solution {\n    public double solve(int[] nums) {\n        Arrays.sort(nums);\n        int streetLength = nums[nums.length - 1] - nums[0];\n        int low = 0, high = streetLength / 3 + 1;\n        while (low + 1 < high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(nums, mid, 3)) {\n                high = mid;\n            } else {\n                low = mid;\n            }\n        }\n        if (isPossible(nums, low, 3)) {\n            return low / 2D;\n        }\n        return high / 2D;\n    }\n\n    private boolean isPossible(int[] nums, int diameter, int lightNumber) {\n        int lightDiameter = -1;\n        int currentLightNum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > lightDiameter) {\n                currentLightNum++;\n                lightDiameter = nums[i] + diameter;\n            }\n            if (currentLightNum > lightNumber) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345464435","body":"### 解题思路\n排序 + 二分。\n\n### 代码\n\n```java\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            int cnt = 0;\n            for (int j = 0; j < n; j++) {\n                int i = binarySearch(nums, j, nums[j] - mid);\n                cnt += j - i;\n            }\n            if (cnt >= k) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    public int binarySearch(int[] nums, int end, int target) {\n        int left = 0, right = end;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345946422","body":"### 解题思路\n能力二分+DFS。解空间为[0, max]，按照题目max = n * n - 1。每次二分，判断从起点(0, 0)能否有一条路径不经过大于mid值的点到达终点(n, n)，可以通过DFS来判断。最后返回最左边满足条件的点即为最终结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n        int l = 0, r = n * n - 1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            int[][] visited = new int[n][n];\n            if (dfs(grid, 0, 0, visited, mid)) r = mid - 1;\n            else l = mid + 1;\n        }\n        return l;\n    }\n\n    private boolean dfs(int[][] grid, int row, int col, int[][] visited, int mid) {\n        int n = grid.length;\n        if (row < 0 || row > n - 1 || col < 0 || col > n - 1) return false;\n        else if (grid[row][col] > mid || visited[row][col] == 1) return false;\n        \n        if (row == n - 1 && col == n - 1) return true;\n        visited[row][col] = 1;\n        return dfs(grid, row + 1, col, visited, mid) || dfs(grid, row - 1, col, visited, mid) || dfs(grid, row, col + 1, visited, mid) || dfs(grid, row, col - 1, visited, mid);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(NlogMax)，N为grid的大小，Max为grid中最大值\n- 空间复杂度：O(N)，N为grid的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347727910","body":"### 解题思路\n滑动窗口。窗口大小固定为k。先检查最开始的k个字符，算出元音字符的数目。然后每次向后移动一位，检查刚出窗口和刚入窗口的两个字符，算出更新的元音数目。每次更新最大值，最后返回结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int count = 0;\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s.charAt(i))) {\n                count++;\n            }\n        }\n        int max = count;\n        for (int j = 1; j <= s.length() - k; j++) {\n            if (isVowel(s.charAt(j - 1))) {\n                count--;\n            }\n            if (isVowel(s.charAt(j + k - 1))) {\n                count++;\n            }\n            max = Math.max(max, count);\n        }\n        return max;\n    }\n\n    private boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为字符串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350341822","body":"### 解题思路\n动态规划+滑动窗口。参考官方题解\n如果用dp[i]表示当前分数为i的情况下，爱丽丝的分数不超过n的概率，则dp[i] = (dp[i + 1] + dp[i + 2] + ... + dp[i + maxPts]) / maxPts，这就是动态转移方程，从后往前遍历。\n每次求sum过程中仅变化左右两侧的数，中间维持不变，用滑动窗口降低时间复杂度。\n\n### 代码\n\n```java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts) return 1;\n        double dp[] = new double[n + 1];\n        double wsum = 1, res = 0;\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            dp[i] = wsum / maxPts;\n            if (i < k) wsum += dp[i];\n            else res += dp[i];\n\n            if (i - maxPts >= 0) wsum -= dp[i - maxPts];\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(k + maxPts)\n- 空间复杂度：O(k + maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352599098","body":"### 解题思路\n滑动窗口。用长度为26的数组记录字符串p中每个字符出现的次数。然后设置宽度为字符串长度`p.length()`的滑动窗口，求出字符串s出现在滑动窗口内的各个字符串出现次数，记录到数组中。如果该数组和字符串p的数组相等，则表示异位词出现。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int slen = s.length();\n        int plen = p.length();\n        List<Integer> res = new ArrayList<>();\n        if (slen < plen) return res;\n        int[] letters = new int[26];\n        for (char c : p.toCharArray()) {\n            letters[c - 'a']++;\n        }\n        String pletters = Arrays.toString(letters);     \n        int[] word = new int[26];\n        for (int i = 0; i < plen; i++) {\n            word[s.charAt(i) - 'a']++;\n        }\n        if (Arrays.equals(letters, word)) res.add(0);\n        for (int i = 1; i <= slen - plen; i++) {\n            int pre = s.charAt(i - 1) - 'a';\n            int post = s.charAt(i + plen - 1) - 'a';\n            word[pre]--;\n            word[post]++;\n            if (Arrays.equals(letters, word)) res.add(i);\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为s的长度\n- 空间复杂度：O(1)，需要两个长度为26的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354151567","body":"### 解题思路\n滑动窗口+哈希表。用哈希表储存字符串t中字符出现频率信息。然后用变量`match`记录已经子串中已经对应上的字符数量。如果`match == t.length()`则说明t中字符已经被全部对应，符合条件的子字符串已经找到。寻找字符串时候用可变大小滑动窗口。定义左右指针，起始点为0。然后先移动右指针扩大窗口，找到t中对应字符则哈希表中字符数量减1，字符数量不小于0的同时match加1，如此循环直到右指针越界。当窗口内的子字符串符合条件时，开始移动左指针缩小窗口，如果当前字符在t中出现，则哈希表中字符数量加1，字符数量大于0的同时match减1，如此循环直到窗口内的子字符串无法符合条件。\n\n### 代码\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        int slen = s.length();\n        int tlen = t.length();\n\n        if (slen < tlen) return \"\";\n        String res = \"\";\n        Map<Character, Integer> map = new HashMap<>();\n        // calculate the frequency of each character in t\n        for (char c : t.toCharArray()) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        int min = slen + 1, match = 0; // use match to check whether substring in s contains all the characters in t\n        int l = 0, r = 0;\n        while (r < slen) {\n            // move r to find characters until match == tlen\n            char c = s.charAt(r);\n            if (map.containsKey(c)) {\n                int val = map.get(c) - 1;\n                if (val >= 0) match++;\n                map.put(c, val);\n            }\n\n            while (match == tlen) {\n                // record possible result, if the length of substring is smaller than current min\n                if (r - l + 1 < min) {\n                    min = r - l + 1;\n                    res = s.substring(l, r + 1);\n                }\n                // move l to decrease the size of the substring\n                char d = s.charAt(l);\n                if (map.containsKey(d)) {\n                    int val = map.get(d) + 1;\n                    if (val > 0) match--; // if val > 0, then one of this character is missing, we will need to find it in the later part of the string\n                    map.put(d, val);\n                }\n                l++;\n            }\n            r++;\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N + K)，N为字符串s长度，K为字符串t长度\n- 空间复杂度：O(S)，S为哈希表大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356053532","body":"### 解题思路\n滑动窗口+前缀和。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int len = cardPoints.length;\n        int[] preSum = new int[len + 1];\n        for (int i = 1; i <= len; i++) {\n            preSum[i] = preSum[i - 1] + cardPoints[i - 1];\n        }\n\n        int max = 0;\n        for (int i = 0; i <= k; i++) {\n            int score = preSum[i] + preSum[len] - preSum[len - k + i];\n            max = Math.max(score, max);\n        }\n        return max;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356647046","body":"### 解题思路\n枚举。按照题意，对于有效的时间，小时的取值范围时0-11，分钟的取值范围是0-59。总共720种可能。我们对这720种可能组合逐一判定，看是否满足亮灯个数要求。如果满足要求，则按照字符串要求格式存入数组中。最后返回数组即可。判断亮灯个数是要看二进制数中1的个数，这里调用`Integer.bitCount(int num)`函数，可以直接得到1的个数。\n\n### 代码\n\n```java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++) {\n                if (Integer.bitCount(i) + Integer.bitCount(j) == turnedOn) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(i);\n                    sb.append(\":\");\n                    if (j < 10) sb.append(0);\n                    sb.append(j);\n                    res.add(sb.toString());\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)，双层循环总共运行720次，为常数\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357212157","body":"### 解题思路\n回溯+集合。用三个集合分别记录列和两条对角线信息。每行放置一个皇后，找到合适的列，保证该列没有其他皇后，并且两个对角线方向没有其他皇后。如果n个皇后放置完毕则方案数加1。判断是否在同一对角线上比较难想。\n\n### 代码\n\n```java\nclass Solution {\n    public int totalNQueens(int n) {\n        Set<Integer> cols = new HashSet<>(); // check column index. Direction: |\n        Set<Integer> diag1 = new HashSet<>(); // check diagonal. Direction: \\  row1 - col1 == row2 - col2\n        Set<Integer> diag2 = new HashSet<>(); // check diagonal. Direction: /  row1 + col1 == row2 + cols\n        return backtrack(n, 0, cols, diag1, diag2);\n    }\n\n    private int backtrack(int n, int row, Set<Integer> cols, Set<Integer> diag1, Set<Integer> diag2) {\n        if (row == n) return 1;\n        int count = 0;\n        // there can only be one queen in each row.\n        // check each column position in the current row.\n        for (int col = 0; col < n; col++) {\n            if (!cols.contains(col) && !diag1.contains(row - col) && !diag2.contains(row + col)) {\n                cols.add(col);\n                diag1.add(row - col);\n                diag2.add(row + col);\n                count += backtrack(n, row + 1, cols, diag1, diag2);\n                // backtrack\n                cols.remove(col);\n                diag1.remove(row - col);\n                diag2.remove(row + col);\n            }\n        }\n        return count;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n!)，排列问题，第一行n个选择，第二行n - 1个选择，。。。\n- 空间复杂度：O(n)，递归层数为n，同时集合大小也为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358721454","body":"### 解题思路\nDFS。对二维数组进行遍历，遇到陆地（值为1）的时候开始DFS搜索周围4个方向，看是否有连成片的陆地，同时将该位置的值设为0，记为已经访问过，避免重复。以此为基础将DFS进行下去，直到周围没有陆地为止，这样就求出了陆地的面积。遍历的时候不断更新最大值。遍历结束返回即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int max = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) continue;\n                max = Math.max(max, dfs(grid, i, j));\n            }\n        }\n        return max;\n    }\n\n    private int dfs(int[][] grid, int row, int col) {\n        int m = grid.length, n = grid[0].length;\n        // index not valid\n        if (row < 0 || row >= m || col < 0 || col >= n) return 0;\n        // visited or in water\n        if (grid[row][col] == 0) return 0;\n        // marked current land as visited\n        grid[row][col] = 0;\n        return 1 + dfs(grid, row - 1, col) + dfs(grid, row + 1, col) + dfs(grid, row, col - 1) + dfs(grid, row, col + 1);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(m * n)，遍历整个数组，每次dfs操作为O(1)\n- 空间复杂度：O(m * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1362184590","body":"### 解题思路\r\n遍历数组，对每一个海洋位置进行BFS，算出到达陆地的最近距离，同时记录当前距离的最大值。遍历结束返回最大值即可。可以转换思路从陆地开始遍历。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    int[] dx = {1, -1, 0, 0};\r\n    int[] dy = {0, 0, 1, -1};\r\n\r\n    public int maxDistance(int[][] grid) {\r\n        int n = grid.length;\r\n        int max = -1;\r\n        for (int i = 0; i < n; i++) {\r\n            for (int j = 0; j < n; j++) {\r\n                if (grid[i][j] == 0) {\r\n                    max = Math.max(max, bfs(grid, i, j));\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n\r\n    private int bfs(int[][] grid, int row, int col) {\r\n        int n = grid.length;\r\n        Deque<int[]> queue = new LinkedList<>(); // information stored in the queue, {x, y, distance}\r\n        boolean[][] visited = new boolean[n][n];\r\n        queue.offer(new int[]{row, col, 0});\r\n        visited[row][col] = true;\r\n        while (!queue.isEmpty()) {\r\n            int[] cur = queue.poll();\r\n            // iterate 4 directions\r\n            for (int i = 0; i < 4; i++) {\r\n                int x = cur[0] + dx[i];\r\n                int y = cur[1] + dy[i];\r\n                // check whether index is valid\r\n                if (!(x >= 0 && x < n && y >= 0 && y < n)) continue;\r\n                // check whether new position is visited, if not, put in the queue\r\n                if (!visited[x][y]) {\r\n                    queue.offer(new int[]{x, y, cur[2] + 1});\r\n                    visited[x][y] = true;\r\n                    // return distance if reaching a land\r\n                    if (grid[x][y] == 1) return cur[2] + 1;\r\n                }\r\n            }\r\n        }\r\n        return -1;      \r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(n^4)，总共进行n^2次BFS，最坏情况是全部为海洋，每次BFS的时间复杂度为O(n^2)，总共为O(n^4)。\r\n- 空间复杂度：O(n^2)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1363002975","body":"### 参考官方解答，BFS\r\n\r\n```java\r\npublic int findShortestCircleContainingTarget(List<List<Integer>> graph, int target) {\r\n    Queue<Integer> queue = new ArrayDeque<>();\r\n    Set<Integer> seen = new HashSet<>();\r\n    queue.offer(target);\r\n\r\n    int len = 0;\r\n    while (!queue.isEmpty()) {\r\n        len++;\r\n        for (int size = queue.size(); size > 0; size--) {\r\n            var cur = queue.poll();\r\n            seen.add(cur);\r\n\r\n            for (var next : graph.get(cur)) {\r\n                if (!seen.contains(next))\r\n                    queue.offer(next);\r\n                else if (next == target)\r\n                    return len;\r\n            }\r\n        }\r\n    }\r\n\r\n    return -1;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363647962","body":"### 解题思路\nBFS + 哈希表 + 排序。用一个哈希表储存整个树在不同列的节点值的数组。用BFS对树逐层进行遍历，每一层用另一个哈希表储存该层出现的在不同列的节点值的数组，将数组中的节点值按从小到大排好序后，合并到整棵树的哈希表中。最后将哈希表转换格式输出结果。\n\n### 代码\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        if (root == null) return res;\n\n        Map<Integer, List<Integer>> map = new TreeMap<>(); // treemap will sort the keys\n        Deque<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0));\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            Map<Integer, List<Integer>> levelMap = new HashMap<>(); // use a map to track node values from the same row and same column\n            List<Integer> values;\n            List<Integer> levelVals;\n            // traverse nodes at each level\n            for (int i = 0; i < size; i++) {\n                Pair<TreeNode, Integer> nodePair = queue.poll();                \n                TreeNode node = nodePair.getKey();\n                int col = nodePair.getValue();\n                // add node values from the same column to the list of the map\n                if (!levelMap.containsKey(col)) {\n                    levelVals = new ArrayList<>();\n                }\n                else {\n                    levelVals = levelMap.get(col);\n                }\n                levelVals.add(node.val);\n                levelMap.put(col, levelVals);\n\n                if (node.left != null) {\n                    queue.offer(new Pair<>(node.left, col - 1));\n                }\n                if (node.right != null) {\n                    queue.offer(new Pair<>(node.right, col + 1));\n                }\n            }\n            // add results obtained from this row to the result map\n            for (int col: levelMap.keySet()) {\n                if (!map.containsKey(col)) {\n                    values = new ArrayList<>();\n                }\n                else {\n                    values = map.get(col);\n                }\n                \n                levelVals = levelMap.get(col);\n                Collections.sort(levelVals); // sort the node values from the same column and same row\n                values.addAll(levelVals); // combine values from the same column\n                map.put(col, values);\n            }   \n        }\n        \n        for (int col: map.keySet()) {\n            res.add(map.get(col));\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364477713","body":"### 解题思路\nDP。临界条件是`minCosts[0] = 0, minCosts[1] = 0`。状态转移方程是`minCosts[i] = min(minCosts[i - 2] + cost[i - 2], minCosts[i - 1] + cost[i - 1])`，即上到Step i的花费为从Step(i - 2)上两步的花费和从Step(i - 1)上一步的花费的最小值。\n\n### 代码\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        // Use an array of size n + 1 to store the minimum costs\n        int[] minCosts = new int[n + 1];\n        // Base cases: we can either start from index 0 or index 1, no costs for these\n        minCosts[0] = 0;\n        minCosts[1] = 0;\n        for (int i = 2; i < n + 1; i++) {\n            // minimum cost at step i is the smaller one of the cost climing 2 steps from step (i - 2) and the cost climing 1 step from step (i - 1)\n            minCosts[i] = Math.min(minCosts[i - 2] + cost[i - 2], minCosts[i - 1] + cost[i - 1]);\n        }\n        return minCosts[n];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364609209","body":"### 解题思路\n动态规划。用`maxAmt[i]`来记录选择第i个房子作为最后偷窃的房子时能偷窃到的最高金额，那么在第i个房子之前，小偷只能偷第(i - 2)或者(i - 3)个房子，状态转移方程为`maxAmt[i] = max(maxAmt[i - 3] + nums[i], maxAmt[i - 2] + nums[i])`，其中i > 2。对于i = 1和i = 2我们分别讨论，i = 1时为nums[0], i = 2时为max(nums[0], nums[1])。 \n\n### 代码\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        int n = nums.length;\n        // base cases\n        if (n == 1) return nums[0];\n        if (n == 2) return Math.max(nums[0], nums[1]);\n        // use an array to store the maxAmt when robbing the ith house as the last one\n        int[] maxAmt = new int[n];\n        // inital states, when n >= 3\n        maxAmt[0] = nums[0];\n        maxAmt[1] = nums[1];\n        maxAmt[2] = nums[0] + nums[2];\n        for (int i = 3; i < n; i++) {\n            // if the ith house is to be robbed, then (i-1)th house must not be robbed. Only choices are robbing (i - 2)th house or (i - 3)th house as previous last house, because they are not adjacent to the ith house\n            maxAmt[i] = Math.max(maxAmt[i - 3] + nums[i], maxAmt[i - 2] + nums[i]);\n        }\n        // the maximum amount could be either choosing the last house or the second last house as the last robbing target\n        return Math.max(maxAmt[n - 2], maxAmt[n - 1]);\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(n)，因为用数组储存之前结果，可以优化到O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364906082","body":"### 解题思路\n动态规划。定义两个数组，`len[i]`用来储存以nums[i]结尾的LIS的最大长度，`count[i]`用来储存以nums[i]结尾的最大长度LIS的个数。每次遍历下标在0到i - 1之间的元素nums[j]，如果nums[j]小于当前元素nums[i]，则说明我们可以把nums[i]加到以nums[j]结尾的LIS上形成长度+1的LIS。继续判断，如果`len[i] < len[j] + 1`说明该以nums[i]结尾的该长度的LIS是第一次出现，将count[i]设成count[j]；如果`len[i] == len[j] + 1`说明该长度的LIS之前出现过，将count[i]更新加入count[j]。遍历同时不断更新最大长度max。最后遍历len和count数组，将所有长度为max的LIS个数求和即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] len = new int[n], count = new int[n]; // length of LIS and total counts of LIS at different index\n        int max = 1;\n        for (int i = 0; i < n; i++) {\n            // initialize arrays, each number can form a LIS of length 1\n            len[i] = count[i] = 1;\n            for (int j = 0; j < i; j++) {\n                // find a LIS which can be formed by appending nums[i]\n                if (nums[j] < nums[i]) {\n                    if (len[i] < len[j] + 1) { // find the LIS at this length for the first time\n                        len[i] = len[j] + 1; // update the length\n                        count[i] = count[j]; // update the count of LIS\n                    }\n                    else if (len[i] == len[j] + 1) { // find another LIS with the same length\n                        count[i] += count[j]; // combine the counts\n                    }\n                }\n            }\n            max = Math.max(max, len[i]);\n        }\n        int res = 0;\n        // search for LIS with length of max, add up to get the final result\n        for (int i = 0; i < n; i++) {\n            if (len[i] == max) res += count[i];\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365640437","body":"### 解题思路\n动态规划。定义二维数组dp，`dp[i][j]`表示从头开始的长度为i的text1的子字符串和从头开始长度为j的text2的子字符串的LCS的长度。状态转移方程：分为两种情况，如果对应index上的字符相同，那么`dp[i][j] = dp[i - 1][j - 1] + 1`，如果对应index上的字符不同，那么`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。用双层循环最后求得`dp[text1.length()][text2.length()]`即为最终结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int len1 = text1.length();\n        int len2 = text2.length();\n        int[][] dp = new int[len1 + 1][len2 + 1];\n        // dp[i][j] corresponds to the length of LCS between the substring of text1 starting at index 0 with length i and the substring of text2 starting at index 0 with length j\n\n        char[] arr1 = text1.toCharArray();\n        char[] arr2 = text2.toCharArray();\n\n        for (int i = 1; i <= len1; i++) {\n            for (int j = 1; j <= len2; j++) {\n                // if characters in text1 and text 2 are the same\n                if (arr1[i - 1] == arr2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }\n                // if characters are different\n                else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[len1][len2];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(m * n)，m为text1的长度，n为text2的长度\n- 空间复杂度：O(m * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366343513","body":"### 解题思路\n动态规划。题目规定机器人只能向下或向右移动，所以到达最上面一行的任意一个格子只有1种路径（向右走），到达最左边一列的任意一个格子只有1种路径（向下走）。状态转移方程：对于其他格子，可以从该格子的上方格子向下走或左边格子向右走到达，路径数等于上方格子路径数和左边格子路径数之和, `path[i][j] = path[i - 1][j] + path[i][j - 1]`。最后返回右下角格子的结果`path[m - 1][n - 1]`即可。\n\n### 代码\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] path = new int[m][n];\n        // Base cases:\n        // top row, can only move left, there is only one way to get to the point\n        Arrays.fill(path[0], 1);\n        // left column, can only move down, there is only one way to get to the point\n        for (int i = 0; i < m; i++) {\n            path[i][0] = 1;\n        }\n        // calculate the path for other points\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                // number of paths for the point = number of paths for the point above it\n                // + number of paths for the point to the left of it\n                path[i][j] = path[i - 1][j] + path[i][j - 1];\n            }\n        }\n        return path[m - 1][n - 1];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(m * n)\n- 空间复杂度：O(m * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367098809","body":"### 解题思路\n动态规划。参考题解。用二维数组储存到达该格子的概率。这里用到两个二维数组，`dp`用于储存移动之前的概率情况，`dpTemp`用于储存移动一步之后的概率状况。遍历二维数组`dp`，找到移动之前概率不为0的格子，由此格子出发找到8个可能到达的格子，如果新到达的格子坐标在范围（0 - n）中，说明格子在板子上，更新`dpTemp`数组中对应坐标的概率，加上`dp / 8`。遍历结束后，我们更新状态，`dp = dpTemp`。按照此方式循环k次，最后得到的`dp`数组中的概率值即为最终值。将所有概率值求和，最后即为棋子还在板子上的概率。\n\n### 代码\n\n```java\nclass Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        // save the possible moving directions into an array\n        int[][] dir = {{-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1}};\n        // use a 2D array to store the probability to move to the cell\n        double[][] dp = new double[n][n];\n        dp[row][column] = 1; // set the initial probability as 1\n        \n        // simulate the moving process, calculate the probability after each move, repeat for k times\n        for (int step = 1; step <= k; step++) {\n            // use a different 2D array to save the temporary probability after each move, easy to update\n            // also we will need to refer to previous state to calculate the new state, \n            // we would not like to overwrite previous state\n            double[][] dpTemp = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    double prob = dp[i][j];\n                    // only need to do the calculation starting from cell with probability > 0\n                    if (prob > 0) {\n                        // update the probability of 8 possible cells\n                        for (int m = 0; m < 8; m++) {\n                            int newRow = i + dir[m][0];\n                            int newCol = j + dir[m][1];\n                            // if still on the board after move, store probability results in dpTemp\n                            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                                dpTemp[newRow][newCol] += prob / 8;\n                            }\n                        }\n                    }\n                }\n            }\n            dp = dpTemp; // update dp when one move is done, status in dpTemp will be set as previous state\n        }\n        double res = 0; // use double here\n        // calculate the total probability\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                res += dp[i][j];\n            }\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(kn^2)，循环k次，每次遍历n*n的数组\n- 空间复杂度：O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367982262","body":"### 解题思路\n参考官方题解和yanglr的题解。状压动态规划 + 回溯 + 位运算。用二进制数表示状态。用Boolean数组储存不同状态的结果，使用记忆化搜索。\n\n边界情况：最大可选数字大于等于累计和，必胜；所有可选数字和小于累计和，必败。\n一般情况：第一位玩家先手。第一位玩家选完之后，第二位玩家变成先手情况（状态转移）。如果第一位玩家在当前状态下可以获胜，或者可以让下一轮第二位玩家必败，则第一位玩家必胜。如果遍历各种情况第一位玩家都无法胜利，则必败。\n\n### 代码\n\n```java\nclass Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        // two special cases\n        // 1. if maxChoosableInteger >= desiredTotal, play1 can win with only one move\n        if (maxChoosableInteger >= desiredTotal) return true;\n        // 2. if sum of all available integers at the beginning of the game is less than desiredTotal,\n        // play1 cannot win\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;\n        // use a memo array to store the results of possible states (number represented by 20 bits)\n        // use Boolean here as the default value is null, cannot use boolean because its default value is false\n        // and we cannot know whether it is filled\n        Boolean[] dp = new Boolean[(1 << maxChoosableInteger) - 1]; // length = 2^maxChoosableInteger - 1\n        return dfs(maxChoosableInteger, desiredTotal, 0, dp);\n    }\n\n    private boolean dfs(int maxChoosableInteger, int total, int state, Boolean[] dp) {\n        // if the result of the state is in the array, directly return the result\n        if (dp[state] != null) return dp[state];\n        // check each available integer and fill the array\n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int temp = 1 << (i - 1); // record the integer to be added to the state\n            // if current integer is not added in the state\n            if ((temp & state) == 0) { // the corresponding bit in the state is 0\n                // if adding i will reach or exceed the total \n                // or we can make sure the player2 cannot win after this move, then player1 can win \n                if (total - i <= 0 || !dfs(maxChoosableInteger, total - i, state | temp, dp)) { \n                    dp[state] = true;\n                    return true;\n                }\n            }\n        }\n        // otherwise, player1 will not win\n        dp[state] = false;\n        return false;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(2^N)，N为maxChoosableInteger\n- 空间复杂度：O(2^N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1370437128","body":"### 解题思路\r\n动态规划。首先求数组和sum，如果和为奇数，必然无法分成两个等和子集，返回false。如果和为偶数，则考虑是否需要将对应元素放入子集中从而达到和为sum/2。此题便转化为0-1背包问题。用二维数组表示状态，`dp[i][j]`表示能否用下标从0到i的元素达到和为j。状态转移方程：对于`dp[i][j]`，考虑不选当前元素`nums[i]`，则结果为`dp[i - 1][j]`；如果选择当前元素`nums[i]`，则结果为`dp[i - 1][j - nums[i]]`，注意`j >= nums[i]`。两者做或运算即为`dp[i][j]`结果。遍历数组按照下标从小到大顺序填表，最后返回结果`dp[nums.length - 1][sum / 2]`即可。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public boolean canPartition(int[] nums) {\r\n        int sum = 0;\r\n        for (int num : nums) {\r\n            sum += num;\r\n        }\r\n        // if sum is odd, the array cannot be partitioned into two subsets\r\n        if (sum % 2 == 1) return false;\r\n\r\n        // convert to 0-1 Knapsack problem\r\n        int target = sum / 2;\r\n        int len = nums.length;\r\n        // dp[i][j] represents whether we can use elements from index 0 to i to form a subset with sum j\r\n        boolean[][] dp = new boolean[len][target + 1];\r\n        // fill in base case\r\n        for (int i = 0; i < len; i++) {\r\n            dp[i][0] = true; // if sum is 0, we can form a subset without any elements\r\n        }\r\n\r\n        for (int i = 1; i < len; i++) {\r\n            for (int j = 1; j <= target; j++) {\r\n                // consider whether choosing nums[i] or not\r\n                dp[i][j] = j >= nums[i] ? dp[i - 1][j - nums[i]] || dp[i - 1][j] : dp[i - 1][j];\r\n            }\r\n        }\r\n        return dp[len - 1][target];\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(m * n)，m为sum / 2，n为数组长度\r\n- 空间复杂度：O(m * n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368291818","body":"### 解题思路\n动态规划。我们将所有取正号的数字的和叫做positive，所有取负号的数字的和叫做negative，所有数组的和sum = positive + negative，我们想要达到的target = positive - negative，此题转化为0-1背包问题，我们找到能够组成和为positive的不同子数组的数目即可。接下来求解positive，结合sum和target的公式，positive = (sum + target) / 2。注意特殊情况的判断，sum + target不能为奇数，同时sum要大于等于target的绝对值（positive >= 0 and negative >= 0)。\n\n这里压缩状态，用一维数组dp[j]表示总和为j的不同子数组的个数，状态转移方程：dp[j] = dp[j] + dp[j - nums[i]]。注意这里要用倒序遍历j，因为我们需要未更新的dp[j - nums[i]]来进行计算。\n\n### 代码\n\n```java\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        \n        if (sum < Math.abs(target)) return 0;\n        // sum = positive + negative\n        // target = positive - negative\n        if ((sum + target) % 2 == 1) return 0;\n\n        int positive = (sum + target) / 2;\n        // convert to 0-1 Knapsack problem\n        int[] dp = new int[positive + 1];\n        dp[0] = 1;\n        \n        for (int i = 0; i < nums.length; i++) {\n            for (int j = positive; j >= 0; j--) {\n                // use reverse order. If we use the normal order, dp[j - nums[i]] has already been updated\n                if (j >= nums[i]) dp[j] = dp[j] + dp[j - nums[i]];\n            }\n        }\n        return dp[positive];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(positive * n)，positive为正数的和，n为数组长度\n- 空间复杂度：O(positive)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369465858","body":"### 解题思路\n动态规划。此题为完全背包问题，因为硬币数量没有限制。用一维数组dp[i]表示达到amount = i的不同方法数。状态转移方程是dp[i] = dp[i] + dp[i - coin]，起始状态为dp[0] = 1，amount = 0是一个硬币也不取即可，此为1种方法。注意我们便利的时候i是从小到大遍历的，不会出现重复计算的情况。\n\n### 代码\n\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        // base case: amount = 0, no coins selected, dp[0] = 1\n        dp[0] = 1;\n        for (int coin : coins) {\n            // iterate i in increasing order, will not have repeated cases\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n * amount), n为数组长度\n- 空间复杂度：O(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370436288","body":"### 解题思路\n贪心。我们只能把不小于孩子胃口值的饼干给孩子，并且每块饼干最多只能给1个孩子。我们可以分别对孩子们按胃口值从小到大排序，对饼干按尺寸从小到大排序，将排好序的两个数组同时向后遍历，优先满足胃口值小的孩子。最后返回结果即可。\n\n### 代码\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        // sort g and s, easy to compare\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int gidx = 0, sidx = 0;\n        int res = 0;\n        while (gidx < g.length && sidx < s.length) {\n            // we can assign the cookie\n            if (g[gidx] <= s[sidx]) {\n                res++;\n                gidx++;\n                sidx++;\n            }\n            // we cannot assign the cookie, check next cookie\n            else {\n                sidx++;\n            }\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)，因为要排序\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371837046","body":"### 解题思路\n贪心。先将intervals排序，按end从小到大排，相同end按start从小到大排。注意不能先按start排，有可能出现start小但end特别大的区间，造成错误结果。然后找重复区间个数：用双指针遍历排好序的intervals，双指针起始`l = 0, r = 1`，增加r，找到跟下标为l的interval不重叠的第一个区间，重叠区间判断条件`intervals[l][1] > intervals[r][0]`，用res记录此过程中出现的重复区间数。找到不重复区间后更新`l = r, r = r + 1`继续遍历，直到r越界为止。最后返回res即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        int len = intervals.length;\n        if (len < 2) return 0;\n        // sort the intervals based on end then start, \n        // this ensures that we can keep as many intervals as possible, like meeting scheduling problem\n        Arrays.sort(intervals, (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]);\n        int res = 0;\n        int l = 0, r = 1;\n        while (r < len) {\n            // overlap occurs when the second interval's end is smaller than the first interval's end\n            while (r < len && intervals[l][1] > intervals[r][0]) {\n                res++;\n                r++;\n            }\n            if (r == len) break;\n            // check the next pair\n            l = r;\n            r++;\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)，n为intervals数组长度，因为需要排序\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374364596","body":"### 解题思路\n分治。根据二叉搜索树的性质，二叉搜索树的子树也为二叉搜索树。对于一个节点数为i的二叉搜索树，我们可以先选定一个节点为根，其余i - 1个节点可以分别拆成两个子二叉搜索树，按照乘法原理我们将两个子树的不同种类数相乘，即可得到当前子树分配情况下二叉搜索树的种类数，然后我们考虑所有拆分可能，相加合并结果，最终即可得到节点数为i的二叉搜索树的不同种类数。因为计算时我们要知道所有比i小的二叉搜索树的种类数，所以建立memo数组`trees`来储存以前结果减少重复计算。注意起始条件，节点数为0的二叉搜索树个数为`trees[0] = 1`。\n\n### 代码\n\n```java\nclass Solution {\n    public int numTrees(int n) {\n        // use a memo array to save previously calculated results\n        int[] trees = new int[n + 1];\n        // base case：there is only one unique tree for a tree with no node\n        trees[0] = 1;\n        // fill in the memo array\n        for (int i = 1; i <= n; i++) {\n            // calculate the number of non-root nodes\n            int nonroot = i - 1;\n            // divide these non-root nodes into two BST, \n            // one with j nodes, one with k = nonroot - j nodes\n            for (int j = 0; j <= nonroot / 2; j++) {\n                int k = nonroot - j;\n                // k == j, number of nodes in left tree is equal to \n                // the number of nodes in right tree, we cannot swap left and right trees\n                // use multification rule to calculate total number of different trees\n                // then use addition rule to add them up\n                if (k == j) trees[i] += trees[k] * trees[j];\n                // k != j, we can swap left and right trees, so times 2\n                else trees[i] += 2 * trees[k] * trees[j];\n            }\n        }\n        return trees[n];\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376747598","body":"### 解题思路\n位运算。运用到异或运算的性质: `A ^ A = 0, 0 ^ A = A`。因为题目中说数组中只有两个只出现一次的数字，先进行全数组异或运算，算出这两个只出现一次的数字的异或结果。之后对数组进行分组希望将这两个数字分到不同的组里。因为`1 ^ 0 = 1`，我们从低位开始往高位找异或运算结果中第一个出现1的数位，按照此数位进行分组，两个数字一定不在一组，其余数字在各组中一定成对出现，再次进行组内元素异或运算即可求得结果。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int[] res = new int[2];\n        int xor = 0;\n        // perform xor for all the nums, xor = unique1 ^ unique2\n        for (int num : nums) {\n            xor ^= num;\n        }\n        // find the first different digit between unique1 and unique2\n        // starting from least significant digit\n        int mask = 1;\n        while ((xor & mask) == 0) {\n            mask = mask << 1;\n        }\n        // divide the nums into two groups, one has 0 at the corresponding digit\n        // and one has 1 at the corresponding digit\n        // unique1 and unique2 must be in two different groups\n        for (int num : nums) {\n            if ((num & mask) == 0) {\n                res[0] ^= num;\n            }\n            else {\n                res[1] ^= num;\n            }\n        }\n        return res;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(n)，n为数组长度\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379839225","body":"### 解题思路\n前缀树。做法参考讲义，先建立TrieNode类，再建立Trie类，各种方法的实现类似DFS，insert是按照word的字母顺序从Trie的根节点出发建节点，每个在word中出现的字母是其前一个字母的children，建节点的时候更新`precount`用来记录prefix个数的变量，最后节点全部构建完成更新表示word结尾的节点的`count`值。search和startsWith需要把Trie的节点和word或者prefix的对应位置的字母相比较，需要满足所有节点都存在，同时对应的`precount`和`count`值都大于0。\n\n### 代码\n\n```java\nclass Trie {\n\n    class TrieNode {\n        int count; // count number of words ending at current TrieNode\n        int precount; // count number of words that has a prefix ending at current TrieNode\n        TrieNode[] children;\n\n        public TrieNode() {\n            children = new TrieNode[26]; // word and prefix contains only of lowercase English letters\n            count = 0;\n            precount = 0;\n        }\n    }\n\n    TrieNode root; // starting from root\n\n    public Trie() {\n        root = new TrieNode(); // initiate a root\n    }\n    \n    public void insert(String word) {\n        TrieNode node = root; // use node to track the current TrieNode\n        // check each letter in word\n        for (int i = 0; i < word.length(); i++) {\n            char letter = word.charAt(i);\n            // check whether a node for current letter exists in the Trie, if not create a TrieNode\n            if (node.children[letter - 'a'] == null) {\n                node.children[letter - 'a'] = new TrieNode();\n            }\n            node = node.children[letter - 'a']; // move to the TrieNode representing current letter\n            node.precount++; // increment precount of the TrieNode\n        }\n        node.count++; // after word is inserted in the Trie, increment the count\n    }\n    \n    public boolean search(String word) {\n        TrieNode node = root;\n        // check each letter in word\n        for (int i = 0; i < word.length(); i++) {\n            char letter = word.charAt(i);\n            // if letter does not show up in the corresponding position\n            if (node.children[letter - 'a'] == null) {\n                return false;\n            }\n            node = node.children[letter - 'a']; // move to next TrieNode\n        }\n        // check whether there is word ending at the node respresenting the last letter of the word\n        return node.count > 0;\n    }\n    \n    public boolean startsWith(String prefix) {\n        TrieNode node = root;\n        // check each letter in prefix\n        for (int i = 0; i < prefix.length(); i++) {\n            char letter = prefix.charAt(i);\n            // if letter does not show up in the corresponding position\n            if (node.children[letter - 'a'] == null) {\n                return false;\n            }\n            node = node.children[letter - 'a']; // move to next TrieNode\n        }\n        // check whether there is word starting with the prefix\n        return node.precount > 0;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */\n```\n**复杂度分析**\n- 时间复杂度：insert和search为O(len(word))，startsWith为O(len(prefix))\n- 空间复杂度：O(T)，T为Trie的总节点数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297979089","body":"### 思路：\n从后往前遍历数组，与k的末位进行逐位相加，若和大于10，则进1(通过提前加到除以10的k上实现)，最后再将剩余的k加到答案上。\n\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>(); // 每次在头部插入，用链表\n        int add = 0;\n        for (int i = num.length - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k += 1 ; // 完成了进1的操作\n                sum -= 10;\n            }\n            ans.addFirst(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ans.addFirst(k % 10);\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度：\n- 时间复杂度：O(n)，遍历一遍数组\n- 空间复杂度：O(1)，除了答案的数组外没用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301813145","body":"### 思路：\n用数组实现栈。top指示栈顶元素所在位置，初始值为-1。\n### 代码：\n```java\nclass CustomStack {\n    int max;\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        max = maxSize;\n        top = -1;\n        stack = new int[max];\n    }\n\n    public void push(int x) {\n        if (top < max - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top != -1) {\n            return stack[top--];\n        } else return -1;\n    }\n\n    public void increment(int k, int val) {\n        int increment = Math.min(k - 1, top);\n        for (int i = 0; i <= increment; i++) stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n### 复杂度：\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的时间复杂度为 O(1)，inc 操作的时间复杂度为 O(k)。\n- 空间复杂度：使用了一个辅助数组，O(maxSize）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304388460","body":"### 思路：\n使用两个栈，一个进行入队操作，一个进行出队操作。\n### 代码：\n```java\nimport java.util.*;\n\nclass MyQueue {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stack1.addLast(x);\n    }\n\n    public int pop() {\n        if (stack2.size() != 0) return stack2.removeLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();\n        }\n        return -1;\n    }\n\n    public int peek() {\n        if (stack2.size() != 0) return stack2.getLast();\n        else if (stack1.size() != 0) {\n            return stack1.getFirst();\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return stack1.size() == 0 && stack2.size() == 0;\n    }\n}\n\n/*\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n### 复杂度：\n- 时间复杂度：push 和empty 为 O(1)，pop 和peek 为均摊O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304749708","body":"### 思路：\n右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量。\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        // 右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。\n        // 用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量\n        for (int num : arr) {\n            if (!stack.isEmpty()&&num<stack.getLast()){\n            // 当前数小于栈顶数，说明会打乱前面已有的排序块\n                Integer head = stack.removeLast();\n                // 此时的出栈元素是新排序块的最大值，用head记录\n                while(!stack.isEmpty()&&num< stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度：\n- 时间复杂度：O(n)，其中 nn 是输入数组 arr 的长度。需要遍历一遍数组，入栈的操作最多为 n 次。\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305448019","body":"### 思路：\n数组存储节点，重新建链\n### 代码：\n```java\nimport java.util.LinkedList;\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head==null) return null;\n        LinkedList<Integer> stack = new LinkedList<>();\n        ListNode res = null;\n        ListNode tail = null;\n        ListNode cur = head;\n        int n = 0;\n        while (cur != null) {\n            n++;\n            stack.addLast(cur.val);\n            cur = cur.next;\n        }\n        int rotateNum = k % n;\n        int oriNum = n - rotateNum;\n        cur = head;\n        while (oriNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(cur.val);\n                tail = res;\n            } else {\n                tail.next = new ListNode(cur.val);\n                tail = tail.next;\n            }\n            cur = cur.next;\n        }\n        while (rotateNum-- > 0) {\n            if (res == null) {\n                res = new ListNode(stack.removeLast());\n            } else {\n                ListNode temp = new ListNode(stack.removeLast());\n                temp.next = res;\n                res = temp;\n            }\n        }\n        return res;\n    }\n}\n```\n### 复杂度：\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297988060","body":"#### 思路\r\n以 [2,1,5], k = 806 为例。 末尾开始遍历 806 + 5 = 811， 811 % 10 = 1， 1 留在当前位， 将k 更新为 811 / 10 进入下一位，重复计算得到结果.\r\n#### code\r\n```js\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let res = []\r\n\r\n    for (let i = num.length -  1; i >= 0; i--) {\r\n        res.unshift((num[i] + k) % 10)\r\n\r\n        k = Math.floor((num[i] + k) / 10)\r\n    }\r\n\r\n    while (k > 0) {\r\n         res.unshift( k % 10)\r\n         k = Math.floor(k / 10)\r\n    }\r\n\r\n\r\n    return res\r\n};\r\n```\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299768042","body":"#### 思路\n滑动窗口\n\n#### code\n```js\nvar shortestToChar = function(S, C) {\n    let l  = S[0] === C ? 0 : Infinity\n    let r = S.indexOf(C)\n    let res = []\n\n    for (let i = 0; i < S.length; i++) {\n        // 计算字符到当前窗口左右边界的最小距离\n        res[i] = Math.min(Math.abs(i - l), Math.abs(r - i))\n\n        // 遍历完了当前窗口后，将窗口右移\n        if (i === r) {\n            l = r\n            r = S.indexOf(C, l + 1)\n        }\n    }\n    return res\n};\n````\n\n#### 复杂度分析\n- 时间复杂度：O(n)，其中 n 为字符串长度。\n- 空间复杂度：O(n)，其中 n 为字符串长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301883798","body":"> ### 解题思路\r\n> 模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n> \r\n> ### 代码\r\n> \r\n> ```javascript\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>   this.stack = new Array();   // [empty, ...]\r\n>   this.maxSize = maxSize;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>   // 最大长度限制\r\n>   if(this.stack.length<this.maxSize){\r\n>     this.stack.push(x);\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>   // 栈顶为空的 =》 -1\r\n>   if(this.stack.length===0){\r\n>     return -1;\r\n>   }\r\n>   let val = this.stack.pop();\r\n>   return val;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>   let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n>   for(let i=0;i<n;i++){\r\n>     this.stack[i] += val;\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n> \r\n> ### 复杂度\r\n> 时间: push/pop 都为O(1), increment需要O(k)\r\n> 空间: O(N) 一个栈的长度\r\n\r\n\r\n> @A-pricity\r\n> ```\r\n> /**\r\n>     利用数组来模拟栈\r\n>     注意：\r\n>         1.当栈元素个数等于 maxSize 时不允许继续入栈；\r\n>         2.当栈为空时，出栈操作返回 -1；\r\n>         3.当栈非空，出栈操作发返回栈顶值\r\n>         4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\r\n> \r\n>  */\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>     this.list = []\r\n>     this.maxSize = maxSize\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>     if(this.list.length < this.maxSize){\r\n>         this.list.push(x)\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>     const item = this.list.pop()\r\n>     return item === void 0 ? -1 : item\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>     for (let i = 0; i < k && i < this.list.length; i++) {\r\n>         this.list[i] += val\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304972654","body":"## 思路\n\n1. 获取单链表的倒数第N + 1 与倒数第N个节点\n2. 将倒数第N + 1个节点的next指向null\n3. 将链表尾节点的next指向head\n4. 返回倒数第N个节点\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head\n    let count = 0, now = head\n    while(now){\n        now = now.next\n        count++\n    }\n    k = k % count\n    let fast = head, slow = head;\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```\n\n## 复杂度分析\n\n时间复杂度：$O(N)$\n空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306517484","body":"\r\n### 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    const dummy = new ListNode(null, head);\r\n    let prev = dummy;\r\n    let cur = prev.next;\r\n\r\n    while (cur && cur.next) {\r\n        const next = cur.next;\r\n        cur.next = next.next;\r\n        next.next = cur;\r\n        prev.next = next;\r\n\r\n        prev = cur;\r\n        cur = cur.next;\r\n    }\r\n    return dummy.next;\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308356933","body":"\n ### 思路\n\n \n ### 代码\n ```javascript\n var sortedListToBST = function(head) {\n     var makeTree = function(head, tail){\n         if(head === tail) return null;\n         const middleNode = getMiddleNode(head, tail);\n         const node = new TreeNode(middleNode.val);\n         node.left = makeTree(head, middleNode);\n         node.right = makeTree(middleNode.next, tail);\n         return node;\n     }\n \n     return makeTree(head, null);\n };\n \n var getMiddleNode = function(head, tail) {\n     if (!head) return null;\n     let fast = head;\n     let slow = head;\n     while (fast !== tail) {\n         fast = fast.next\n         if(fast!== tail){\n             fast = fast.next\n             slow = slow.next;\n         }\n     }\n     return slow;\n }; \n ```\n ### 复杂度\n 时间：O(nlogn) 递归logn次，每次遍历链表\n 空间：O(logn)  递归栈空间\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311429658","body":"## 思路\n- 遍历整个链表,同时将每个节点都插入哈希表,\n- 如果当前节点在哈希表中不存在,继续遍历,\n- 如果存在,那么当前节点就是环的入口节点\n\n```js\nlet data = new Set();\nwhile (head) {\n  if (data.has(head)) {\n    return head;\n  } else {\n    data.add(head);\n  }\n  head = head.next;\n}\nreturn null;\n```\n\n## 复杂度分析\n\n时间复杂度：$O(N)$\n空间复杂度：$O(N)$\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313352395","body":"\n\n## 思路\n比较两棵树的结构，可以对两棵树同时进行层级遍历，在遍历中比较节点，如果有不同的节点就提前退出。\n\n需要注意的是遍历过程中空节点也要入列。\n\n## 代码\nJavaScript Code\n\n```js\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function (p, q) {\n    const queueP = [p];\n    const queueQ = [q];\n\n    while (queueP.length && queueQ.length) {\n        let lenP = queueP.length;\n        let lenQ = queueQ.length;\n\n        // 如果两棵树同一层的节点数都不同，肯定不是同一棵树\n        if (lenP !== lenQ) return false;\n\n        while (lenP-- && lenQ--) {\n            const nodeP = queueP.shift();\n            const nodeQ = queueQ.shift();\n\n            // 两个节点都是 null, 直接继续比较下一个节点\n            if (!nodeP && !nodeQ) continue;\n            // 遇到不同的节点，说明不是同一棵树，提前返回\n            if (!nodeP || !nodeQ || nodeP.val !== nodeQ.val) return false;\n\n            // 将下一层的节点入列，空节点也要入列\n            queueP.push(nodeP.left, nodeP.right);\n            queueQ.push(nodeQ.left, nodeQ.right);\n        }\n    }\n    return true;\n};\n```\n\n## 复杂度分析\n时间复杂度：$O(N)$，N 为二叉树的节点数。\n空间复杂度：$O(logN)$，N 为二叉树的节点数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298004206","body":"### 思路\n\n1、先转成数字再相加，遇到大数直接溢出了\n2、逐位相加\n\n### 代码\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int,0)\n    // 逐位相加\n    for i := len(num) - 1; i>=0; i--{\n        sum := num[i] + k % 10\n        k /= 10\n        if sum >= 10 {\n            k++ // 进位\n            sum -= 10 // 减掉 10\n        }\n        res = append(res, sum)\n    }\n    for k != 0 { // 如果有剩余的接着加\n        res = append(res, k % 10)\n        k /= 10\n    }\n\n    // reverse\n    for i:=0; i<len(res) /2; i++ {\n        res[i], res[len(res)-i-1] = res[len(res) - i -1], res[i]\n    }\n\n    return res\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1303783495","body":"### 思路\r\n\r\n遍历记录\r\n\r\n### 代码\r\n\r\n```go\r\n\r\nimport \"math\"\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tcslice := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\t// 记录 index\r\n\t\t\tcslice = append(cslice, i)\r\n\t\t}\r\n\t}\r\n\r\n\tvar getMin func(index int) int\r\n\tgetMin = func(index int) int {\r\n\t\tans := math.MaxInt64\r\n\t\tfor i := 0; i < len(cslice); i++ {\r\n\t\t\tans = getMinValue(getAbs(cslice[i], index), ans)\r\n\t\t}\r\n\r\n\t\treturn ans\r\n\t}\r\n\r\n\tres := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tres = append(res, getMin(i))\r\n\t}\r\n\r\n\treturn res\r\n}\r\n\r\nfunc getMinValue(a, b int) int {\r\n\tif a > b {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n\r\nfunc getAbs(a, b int) int {\r\n\tif a-b > 0 {\r\n\t\treturn a - b\r\n\t}\r\n\treturn b - a\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302260513","body":"### 思路\n\n数组实现\n\n### 代码\n\n```go\n// 使用数组实现即可\n\ntype CustomStack struct {\n\tnums []int\n\tsize int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tnums: make([]int, 0),\n\t\tsize: maxSize,\n\t}\n}\n\nfunc (c *CustomStack) Push(x int) {\n\tif len(c.nums) >= c.size {\n\t\tlog.Println(\"size overflow\")\n\t\treturn\n\t}\n\n\tc.nums = append(c.nums, x)\n\treturn\n}\n\nfunc (c *CustomStack) Pop() int {\n\tif len(c.nums) <= 0 {\n\t\treturn -1\n\t}\n\tlength := len(c.nums)\n\tvalue := c.nums[length-1]\n\tc.nums = c.nums[:length-1]\n\treturn value\n}\n\nfunc (c *CustomStack) Increment(k int, val int) {\n\tif k > len(c.nums) {\n\t\tk = len(c.nums)\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tc.nums[i] += val\n\t}\n\treturn\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n\n```\n\n\n### 复杂度分析\n\n- 时间复杂度：push: O(1), pop: O(1), inc: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303610428","body":"### 思路\r\n\r\n用栈实现\r\n\r\n### 代码\r\n\r\n```go\r\npackage issue9\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc decodeString(s string) string {\r\n\tptr := 0\r\n\tvar stk []string\r\n\r\n\tvar getDigits func() string\r\n\tgetDigits = func() string {\r\n\t\t// 获取数字\r\n\t\tret := \"\"\r\n\t\tfor ; s[ptr] >= '0' && s[ptr] <= '9' && ptr < len(s); ptr++ {\r\n\t\t\tret += string(s[ptr])\r\n\t\t}\r\n\t\treturn ret\r\n\t}\r\n\r\n\tvar getString func(v []string) string\r\n\tgetString = func(v []string) string {\r\n\t\treturn strings.Join(v, \"\")\r\n\t}\r\n\r\n\tfor ptr < len(s) {\r\n\t\tcur := s[ptr]\r\n\t\tif cur >= '0' && cur <= '9' { // 获取数字\r\n\t\t\tdigits := getDigits()\r\n\t\t\tstk = append(stk, digits)\r\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n\t\t\tstk = append(stk, string(cur))\r\n\t\t\tptr++\r\n\t\t} else { // 右花括号\r\n\t\t\tvar sub []string\r\n\t\t\tfor stk[len(stk)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stk[len(stk)-1])\r\n\t\t\t\tstk = stk[:len(stk)-1] // 出栈\r\n\t\t\t}\r\n\t\t\tstk = stk[:len(stk)-1] // 将 \"[\" pop 出栈\r\n\t\t\t// 逆序\r\n\t\t\tfor i := 0; i < len(sub)/2; i++ {\r\n\t\t\t\tsub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\trepTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n\t\t\tstk = stk[:len(stk)-1] // 将数字 pop 出栈\r\n\t\t\tt := strings.Repeat(getString(sub), repTime)\r\n\t\t\tstk = append(stk, t) // 重新入栈\r\n\t\t\tptr++\r\n\t\t}\r\n\t}\r\n\r\n\treturn getString(stk)\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298039156","body":"思路\r\n1. 把array转成数字，然后加k，stackoverflow\r\n2. 从后往前加，用tenth表示进位。Edge case如果K的digit数比array大，剩下的要加入进去。Tenth又变成edgecase，如果K剩下的加进去还要在check一遍if tenth==1.\r\n3. 在变k的时候把进位加上去，即 k/10 + tenth\r\n\r\n代码\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<Integer>();\r\n        int tenth =0;\r\n        for(int i=num.length-1; i>=0; i--){\r\n            int curr = k%10 + num[i];\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n        while(k !=0){\r\n            int curr = k%10;\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n\r\n        return result; }\r\n```\r\n复杂度分析\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299363320","body":"思路\r\n1. 用一个list继续 index of c，然后用双指针。Time O(N), Space O(n)\r\n2. 左边遍历一边，右边便利一遍，取min\r\n3. 初试min只设置一个就好了，不用左右都设置，数字可以取10001，因为prompt说s.length最大是10^4\r\n\r\n代码\r\n```\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int prev = 10001;\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = Math.abs(i- prev);\r\n            \r\n        }\r\n        prev = 10001;\r\n        //System.out.println(Arrays.toString(answer));\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //System.out.println(right);\r\n            answer[i] = Math.min(answer[i], Math.abs(i - prev));\r\n        }\r\n        return answer;\r\n    }\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)， N  = 字符串的长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302316149","body":"思路\r\n1. 最开始使用arraylist，后来发现array才是最简便的\r\n2. 用一个tail variable keep track stack size\r\n3. stack bottom是array的0，top是最后，别搞反了\r\n代码\r\n```\r\nclass CustomStack {\r\n    int tail;\r\n    int[] arr;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        tail =-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail >= arr.length-1){\r\n            return;\r\n        }\r\n        tail++;\r\n        arr[tail] = x;        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail<0){\r\n            return -1;\r\n        }\r\n        int val = arr[tail];\r\n        tail--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        //System.out.println(arr);\r\n        int threshold = Math.min(arr.length, k);\r\n\r\n        for(int i=0; i<threshold; i++){\r\n            arr[i]+=val;\r\n        }\r\n        //System.out.println(arr);\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n时间：push 和pop是O(1)，inc是O(K)\r\n空间：O(N) N代表maxsize\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303000815","body":"思路\r\n1. 用了一种非常离谱非常麻烦的方法，一个栈记录数字，一个栈记录letter，遇到 \"]\"时pop出repeat string，再pop一个数字做repeat, 有很多edge case，比如如何check是数字，check两个栈的size\r\n2. java 好像对双引号or单引号很敏感，单引号的时候做character比较会有error\r\n代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        String str = \"\";\r\n        Stack<String> letter = new Stack<>();\r\n        Stack<Integer> nums = new Stack<>();\r\n        String num = \"\";\r\n        for(int i=0; i<s.length(); i++){\r\n            \r\n            \r\n            if(Character.isDigit(s.charAt(i))){\r\n                num= num + s.charAt(i);\r\n                System.out.println(\"[get num \" + num);\r\n            }else if(s.charAt(i) == '['){\r\n                if(num.length()>0){\r\n                    nums.push(Integer.parseInt(num));\r\n                    System.out.println(\"[[nums push \"+ Integer.parseInt(num));\r\n                    num = \"\";\r\n                }\r\n                \r\n                letter.push(\" \");\r\n            }else if(s.charAt(i) == ']'){\r\n                String sub = \"\";\r\n                while(letter.peek() != \" \"){\r\n                    sub = letter.pop() + sub;\r\n                }\r\n                letter.pop();\r\n                if(nums.size() >0){\r\n                    letter.push(sub.repeat(nums.pop()));\r\n                    System.out.println(\"repeat \"+ sub);\r\n                }else{\r\n                    letter.push(sub);\r\n                    System.out.println(\"purer push \"+ sub);\r\n                }\r\n                \r\n            }else{\r\n                letter.push(String.valueOf(s.charAt(i)));\r\n                System.out.println(\"final else\"+ s.charAt(i));\r\n            }\r\n        }\r\n        while(!letter.isEmpty()){\r\n            str=  letter.pop() + str;\r\n        }\r\n        return str;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304422600","body":"思路\r\n1.用两个stack，一个是正常的stack用来加push的东西，一个是reverseStack，pop的顺序会和queue一样\r\n2.如果reverse stack里面有东西，优先peek or pop reverse stack里的东西。\r\n3.如果reverse stack里没有东西了，先把stack里面的element放进去，再peek or push\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> reverseStack;\r\n    public MyQueue() {\r\n        stack = new Stack<>();\r\n        reverseStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.pop();\r\n        }\r\n        while(stack.size() >1){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.peek();\r\n        }\r\n        while(!stack.isEmpty()){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return reverseStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return reverseStack.isEmpty() && stack.isEmpty();\r\n    }\r\n}\r\n```\r\n复杂度\r\n时间： push O(1), pop和peek不确定，我感觉average也是O(1）？\r\n空间： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831846","body":"思路\r\n1. sort array，如果他能单独分块，那么在这之前的element是和sorted一样\r\n\r\n代码\r\n```\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // deep copy\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int result = 0;\r\n        int nonZero =0;\r\n        for(int i=0; i<arr.length; i++){\r\n            int x = arr[i];\r\n            int y = sorted[i];\r\n            \r\n            map.put(x, map.getOrDefault(x,0)+1);\r\n            if(map.get(x) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(x)==1){\r\n                nonZero++;\r\n            }\r\n            map.put(y, map.getOrDefault(y,0)-1);\r\n            if(map.get(y) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(y)==-1){\r\n                nonZero++;\r\n            }\r\n            \r\n            if(nonZero ==0){\r\n                result++;\r\n            }\r\n            \r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\nO（N）\r\nO（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305222973","body":"思路\r\n1. 和求单链表的倒数第 N 个节点很像\r\n2. loop一遍找到list的length和tail node\r\n3. 除了k遍以后list不变，其他的case都是tail node连接到head node，所以我们唯一需要找的就是那一个node.next变成null了\r\n4. 返回的时候除了list不变的情况，返回的是prev.next的值，记得先存一下\r\n代码\r\n```\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head ==null) return head;\r\n        ListNode curr = head;\r\n        ListNode prev = null;\r\n        ListNode tail =null;\r\n        ListNode result = null;\r\n        int count = 0;\r\n        while(curr !=null){\r\n            tail = curr;\r\n            curr=curr.next;\r\n            count++;\r\n        }\r\n        int rotate = count - k % count;\r\n        curr = head;\r\n        for(int i=0; i<rotate; i++){\r\n            prev = curr;\r\n            curr = curr.next;\r\n        }\r\n        result = head;\r\n        if(prev != null){\r\n            tail.next= head;\r\n            result = prev.next;\r\n            prev.next = null;\r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\n时间 O(N)\r\n空间O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308324575","body":"思路\r\n1.用slow,fast pointer找到linkedlist最中间的数字作为root\r\n2.recursive on left right\r\n3. 区间为[head,tail), tail 不算在里面\r\n4. base case为head==tail，tail初始为null\r\n代码\r\n```\r\npublic TreeNode helper(ListNode head, ListNode tail){\r\n        if(head ==tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast.next != tail && fast.next.next !=tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(head, slow);\r\n        root.right = helper(slow.next, tail);\r\n        \r\n        return root;\r\n            \r\n    }\r\n```\r\n复杂度分析\r\n时间O（NlogN）一共logN level，树的高度 每一个level traverse 的node加起来traverse N次，所以是nlogn\r\n空间O（logn）因为是height-balanced ，树的高度为logn","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310000166","body":"思路\r\n1. l1->l2, l2->l1 如果有重合说明又intersect，否则没有\r\n代码\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        \r\n        while(p1 != p2){\r\n            if(p1 ==null){\r\n                p1 = headB;  \r\n            }else{\r\n                p1 = p1.next;\r\n            }\r\n            if(p2 ==null){\r\n                p2 = headA;\r\n                \r\n            }else{\r\n                p2 = p2.next;\r\n            }\r\n            \r\n            \r\n        }\r\n        return p1;\r\n    }\r\n}\r\n复杂度分析\r\n时间 O(M+N) 两个list长度\r\n空间 O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311873459","body":"思路\r\n1.hashset存，check之前有没有\r\n2. two pointers，需要一点点数学prove\r\n代码\r\n```\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while(fast !=null && fast.next !=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(slow == fast){\r\n                break;\r\n            }\r\n        }\r\n        if(fast == null || fast.next==null){\r\n            return null;\r\n        }\r\n        \r\n        fast = head;\r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n```\r\n复杂度分析\r\n时间 O（N）\r\n空间 O（1）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312658813","body":"思路\r\n1. base case： root是null， height为0\r\n2. recursive case： 找到left 和right的height， root height = Math.max(left, right)+1\r\n代码\r\n```\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root.left)+1;\r\n        int right = maxDepth(root.right)+1;\r\n        \r\n        return Math.max(left, right);\r\n    }\r\n```\r\n复杂度分析\r\n时间O(N)，iterate through 每一个node\r\n空间O(N)，recurive worst case，tree look like a single linkedlist，stack上压了n个node","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298054211","body":"# 思路\n从后往前逐个相加\n# 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n - 1;i >= 0;i--){\n            int a = num[i] + k % 10; // 得到k的个位\n            k /= 10; //去掉k的个位\n            if(a >= 10){\n                k++; // k的十位  + 1\n                a -= 10; // 进位之后a得-10\n            }\n            res.add(a);\n        }\n        for(;k > 0;k /= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300463292","body":"# 思路\n数组的两次遍历，s[i]到c左右两侧的最近距离 左-右\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] arr = new int[n];\n        int index = -n;   // 给一个较大的值，用于辅助标记 c 的位置\n        for(int i = 0 ; i < n;i++){\n            if(s.charAt(i) == c) // s当前下标的数字== c\n                index = i;\n            arr[i] = Math.abs(i - index); // 数组中存的为 相对与index（-n）的位置\n        }\n        for(int i = n - 1; i >= 0;i--){\n            if(s.charAt(i) == c)\n                index = i;\n            arr[i] = Math.min(arr[i], Math.abs(i - index)); // 矫正位置信息\n        }\n        return arr;\n    }\n}\n```\n# 复杂度\n- 时间：o(n)  遍历字符串s\n- 空间：o(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302017173","body":"# 思路\n  让栈中元素可见：设置栈顶top\n# 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303750267","body":"# 思路\n字符串 + 栈\n# 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        // 遍历字符串（转char字符串）\n        for(char c : s.toCharArray()){\n            if(c != ']'){ // 没到最后就一直向栈中压\n                stack.push(c);\n            }else{\n                // 数组中的数已经全部进栈，取出字符串\n                StringBuilder sb = new  StringBuilder();\n                // 看栈中是不是字母\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0,stack.pop());\n                \n                String s1 = sb.toString();\n                stack.pop(); // 此时栈中就剩下一个‘[’,弹出\n\n                // 获取倍数\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                     sb.insert(0,stack.pop());\n                }\n                   \n\n               int count = Integer.valueOf(sb.toString());  // 倍数\n\n                // 将倍数 x 字符\n                while(count  > 0 ){\n                    for(char c1 : s1.toCharArray()){\n                        stack.push(c1);\n                    }\n                    count--;\n                    }\n                }\n        }\n        // 将栈中数据取出\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty())\n            res.insert(0,stack.pop());\n        return res.toString();\n    }\n}\n    \n```\n# 复杂度\n- 时间 o(n)\n- 空间 o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561267","body":"#### 思路\n> 理解栈先进后出的特性\n#### 代码\n```java\nclass MyQueue {\n\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new Stack<>(); // 负责进栈\n        stackOut = new Stack<>(); // 负责出栈\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {    \n        dumpstackIn();\n        return stackOut.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        dumpstackIn();\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n\n    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中\n    private void dumpstackIn(){\n        if (!stackOut.isEmpty()) return; \n        while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n        }\n    }\n}\n\n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304825468","body":"#### 思路\n> 单调栈\n#### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.getLast()){\n                int cur = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            }else{\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}  \n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305743764","body":"# 思路\n>  快慢指针\n>  关键点：k = k % 链表长度\n# 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) return head;\n        int count = 0;\n        ListNode ct = head;\n        while(ct != null){ // 对head中的元素计数\n            ct = ct.next;\n            count++;\n        }\n        k = k % count;\n        ListNode low = head;\n        ListNode fast = head;\n        while(fast.next != null){\n            if(k-- <= 0){\n                low = low.next;   \n            }\n            fast = fast.next;\n        }\n        fast.next = head;\n        ListNode res = low.next;\n        low.next = null;\n\n        return res;\n    }\n \n}\n```\n# 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307407059","body":"### 思路\n>  关注最小子结构 递归\n### 代码\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null) return head;\n        // 递归调用\n       ListNode cur = head.next;\n       head.next = swapPairs(cur.next); // 1-->(4-->3)\n       cur.next = head; // 2-->1\n       return cur;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308977409","body":"### 思路\n> 快慢指针找中点（根），中点左侧为左子树，右侧为右子树；递归调用\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        //判断链表是否为空\n        if(head == null) return null;\n        return dfs(head,null);\n    }\n    private TreeNode dfs(ListNode head,ListNode tail){\n        // 终止条件\n        if(head == tail) return null;\n        // 定义快慢指针\n        ListNode fast = head;\n        ListNode low = head;\n        // 快指针一次跳2下 慢指针跳一下\n        while(fast != tail && fast.next != tail){\n            fast = fast.next.next;\n            low = low.next;\n        }\n        TreeNode root = new TreeNode(low.val);\n        root.left = dfs(head,low);\n        root.right = dfs(low.next,tail);\n        return root;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(nlogn)\n- 空间：o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309992882","body":"### 思路\n> 双指针 \n指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：\na+(b−c) \n指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：\nb+(a−c) \n如下式所示，此时指针 A , B 重合，并有两种情况：\n a + (b - c) = b + (a - c)\n若两链表 有 公共尾部 (即 c>0 ) ：指针 A , B 同时指向「第一个公共节点」node 。\n若两链表 无 公共尾部 (即 c=0 ) ：指针 A , B 同时指向 null\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n      // 双指针\n      ListNode A = headA,B = headB;\n      while( A != B){\n          A = A != null ? A.next : headB;\n          B = B != null ? B.next : headA;\n      }\n      return A;\n    }\n}\n\n\n```\n### 复杂度\n- 时间：o(n)   o(a+ b)\n- 空间：o(1)   常数空间的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311722014","body":"### 思路\n> 快慢指针，找到交点之后，将快指针放回head，步长变1\n### 代码\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if(head == null) return null;\n        ListNode fast = head;\n        ListNode low = head;\n        while(fast != null){\n            low = low.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }else{\n                return null;\n            }\n            if(fast == low){\n                ListNode fast1 = head;\n                while(fast1 != low){\n                    fast1 =fast1.next;\n                    low = low.next;\n                }\n                return fast1;\n            }\n        }\n        return null;\n      \n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312473582","body":"### 思路\n>  哈希表，双向链表\n### 代码\n```java\n class LRUCache {\n    class DLinkedNode{\n        int key,value;\n        DLinkedNode prev,next;\n        public DLinkedNode(){}\n        public DLinkedNode(int key1,int value1){\n            key = key1;\n            value = value1;\n        }\n    }\n    private Map<Integer,DLinkedNode> cache = new HashMap<Integer,DLinkedNode>();\n    private int size,cap;\n    private DLinkedNode head,tail;\n\n    public LRUCache(int capacity) {\n        size = 0;\n        cap = capacity;\n\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n         DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n       \n        moveToHead(node);\n        return node.value;\n\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            //made a newNode if it does not exist\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addToHead(newNode);\n            ++size;\n            if (size > cap) {\n                DLinkedNode removedTail = removeTail();\n                cache.remove(removedTail.key);\n                --size;\n            }\n        } else {\n            node.value = value;\n            moveToHead(node);\n        }\n\n    }\n    private void addToHead(DLinkedNode node){\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;                       \n    }\n\n    private void removeNode(DLinkedNode node){\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n   \n```\n### 复杂度\n- 时间：o(1)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312727466","body":"### 思路\n> 递归\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.right),maxDepth(root.left)) + 1;\n    }\n}\n```\n### 复杂度\n- 时间:o(n) n为节点数\n- 空间:o(n) n为节点数，此时树退化为链表","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313116393","body":"### 思路\n> 递归 \n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }else if(p == null || q == null){\n            return false;\n        }\n        if(q.val != p.val){\n            return false;\n        }\n        return isSameTree(q.left,p.left) && isSameTree(p.right,q.right);\n\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)   n为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265421","body":"### 思路\n> 递归，dfs\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int ans;\n    public int sumNumbers(TreeNode root) {\n        dfs(root,0);\n        return ans;       \n    }\n    public void dfs(TreeNode root,int last){\n        \n        if(root == null) return;\n        if(root.left == null && root.right == null){\n            ans += last * 10 + root.val;\n            return;\n        }\n        dfs(root.left,last * 10 + root.val);\n        dfs(root.right, last * 10 + root.val);\n    }\n}\n\n```\n### 复杂度\n- 空间：o(n)其中 n 是二叉树的节点个数。对每个节点访问一次。\n- 时间：o(n)其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317113630","body":"### 思路\n> dfs 用一个数去接收最后的值\n### 代码\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int curheight = 0;\n    int val = 0;\n    public int findBottomLeftValue(TreeNode root) {\n        int curheight = 0;\n        dfs(root,0);\n        return val;\n    }\n    public void dfs(TreeNode root,int height){\n        if(root == null) return;\n        height++;\n        dfs(root.left,height);\n        dfs(root.right,height);\n        if(height > curheight){\n            curheight = height;\n           val =  root.val;\n        }\n    }\n}\n```\n\n### 复杂度\n- 空间：O(n)\n- 时间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318811406","body":"### 思路\n> 序列化：将空节点当做普通节点入队即可\n> 反序列化：使用三个指针指向数组（bfs）的1 2 3 p1指针每次移动1步，p2、p3每次移动2位\n    p1.left = p2 ; p1.right = p3\n### 代码\n```java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n\n   \n```\n### 复杂度\n- 时间：o(N) n为节点数\n- 空间：o(n) n为树的节点总数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319884753","body":"### 思路\n> dfs + 哈希表 + 排序\n### 代码\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n      // x {y : [val,val,...]}\n    Map<TreeNode,int[]> map = new  HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n    map.put(root, new int[]{0,0,root.val}); // root的位置为（0,0,val）\n       // 坐标集合以 x 坐标分组\n     // dfs 遍历节点并记录每个节点的坐标\n    dfs(root);\n    List<int[]> list = new ArrayList<>(map.values());\n  // 得到所有节点坐标后，先按 x 坐标升序排序\n    // 再给 x 坐标相同的每组节点坐标分别排序\n    // y 坐标相同的，按节点值升序排\n      // 否则，按 y 坐标降序排\n    Collections.sort(list,(a,b)->{  // lamda表达式定义排序规则\n        if(a[0] != b[0]) return a[0] - b[0];\n        if(a[1] != b[1]) return a[1] - b[1];\n        return a[2] - b[2];\n    });\n    int n = list.size();\n    List<List<Integer>> ans = new ArrayList<>();\n    // 将list中的值放到ans中\n     for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) \n                tmp.add(list.get(j++)[2]);\n            ans.add(tmp);\n            i = j;\n        }\n    return ans;\n    }\n    public void dfs(TreeNode root){\n        if(root == null) return;\n        int[] arr = map.get(root);\n        //初始化 x ，y\n        int x = arr[0];\n        int y =  arr[1];\n        int val = arr[2];\n        if(root.left != null){\n            // 坐标迭代\n            map.put(root.left,new  int[]{x - 1,y + 1,root.left.val});\n            dfs(root.left);\n        }\n         if(root.right != null){\n            map.put(root.right,new int[]{x + 1,y + 1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n    \n```\n### 复杂度\n- 时间：o(NlogN)   \n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320882414","body":"### 思路\n> 哈希表   target-num\n### 代码\n```java\n class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // 哈希表\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target - nums[i],i);\n        }\n        return new int[]{};\n    }\n}   \n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321160057","body":"### 思路\n> 哈希表 + 堆排序\n### 代码\n```java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n// 哈希表  + 将每个数及其对应的个数放进去\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for(int  num : nums){\n            map.put(num,map.getOrDefault(num,0) + 1);// 有相同的数就+ 1\n        }\n        // 堆\n        PriorityQueue<int[]> queue =  new PriorityQueue<int[]>(new Comparator<int[]>(){\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];  // 定义比较器规则：出现次数多的在前面\n            }\n        });\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){ // 将map中的值对应起来放在set中\n            int num = entry.getKey(), count = entry.getValue();\n            if(queue.size() == k){ //有k个\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            }else{\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        //将堆中的数组的num放在ret中\n        for(int i = 0;i < k; i++){\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n```\n### 复杂度\n- 时间：o(nlogn)  n为数组长度\n- 空间：o(n)  n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322222948","body":"### 思路\n> 哈希表 \n\t两点间距离计算方法\n\t排列组合 \n### 代码\n```java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1); \n            }\n        }\n        return ans;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(n²)  n为数组长度\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323705850","body":"### 思路\n> 哈希表 + 滑动窗口\n### 代码\n```java\nclass Solution {\n    \n    public int lengthOfLongestSubstring(String s) {\n        Set<Character> set = new HashSet<Character>();\n        int n = s.length();\n        // 右指针  -1 \n        int rightK = -1, ans = 0;\n        // i 为左指针\n        for(int i = 0; i < n; ++i){\n            if(i != 0){\n                set.remove(s.charAt(i - 1));\n            }\n            while(rightK + 1 < n && !set.contains(s.charAt(rightK + 1))){\n                set.add(s.charAt(rightK + 1));\n                ++rightK;\n            }\n            ans = Math.max(ans,rightK - i + 1);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)   n为字符串长度\n- 空间：o(n)   n为字符集元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325284921","body":"### 思路\n> 哈希表 + 双指针 \n### 代码\n```java\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n \n```\n### 复杂度\n- 时间：o(n*m*k)\n- 空间：o(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326609020","body":"### 思路\n> 同余定理  +  前缀和\n### 代码\n```java\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        m[0] = 1;\n        int sum = 0, ans = 0;\n        for(int i : nums) {\n            sum += i;\n            int mod = (sum % k + k) % k;   // 非负\n            if(m.count(mod)) {\n                ans += m[mod];\n            }\n            m[mod]++;\n        }\n        return ans;\n    }\n};\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327622332","body":"```java\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n```\n- 时间复杂度：o(n)\n- 空间复杂度：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328065918","body":"### 思路\n> 读写双指针\n### 代码\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // 读p写p1指针\n        int p = 0, p1 = 0;\n        while(p1 < nums.length){\n            if(nums[p] != nums[p1]){\n                p++;\n                nums[p] = nums[p1];\n            }\n            p1++;\n        }\n        return p + 1;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328269644","body":"### 思路\n> 二分\n### 代码\n```java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        // 二分\n        if(nums.length == 0) return -1;\n        int left = 0,right = nums.length -1; // 指针指向下标\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(target < nums[mid]){\n                right = mid - 1;\n            }else if(target > nums[mid]){\n                left = mid + 1;\n            }else{\n                return mid;\n            }\n        }\n        return left;\n    }\n}\n```\n### 复杂度\n- 时间：o(logn)   n为数组长度\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329106318","body":"### 思路\n> 数组--->双端队列（移除 超出窗口范围的数索引`大于 i - k + 1的元素` + `如果小于当前元素就出队列`）\n### 代码\n```java\n    class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        //创建滑动窗口个数的数组\n        int[] ans = new int[nums.length - k + 1];\n        //创建双端队列\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for(int i = 0;i < nums.length;i++){\n\n            if(!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            while(!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);//队列尾部添加元素\n            if(i - k + 1 >= 0) ans[i-k+1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)\n- 空间：o(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330669911","body":"### 思路\n> 找到入度为 n-1 出度为0的点\n易错点： 从1到n编号\n### 代码\n```java\n class Solution {\n    public int findJudge(int n, int[][] trust) {\n       int[] arr =  new int[n + 1];\n       for(int[] eg : trust){\n           int x = eg[0];\n           int y = eg[1];\n           arr[y]++;\n           arr[x]--;\n       }\n       for(int i = 1;i < n+1;i++){\n           if(arr[i] == n - 1){\n               return i;\n           }\n       }\n       return -1;\n    }\n}\n```\n### 复杂度\n- 时间：o(n)  n为数组长度\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332315403","body":"```java\nclass Solution {\n    ArrayList<Integer>[] graph;\n    Map<Integer, Integer> color;\n\n    public boolean possibleBipartition(int N, int[][] dislikes) {\n        graph = new ArrayList[N+1];\n        for (int i = 1; i <= N; ++i)\n            graph[i] = new ArrayList();\n\n        for (int[] edge: dislikes) {\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n\n        color = new HashMap();\n        for (int node = 1; node <= N; ++node)\n            if (!color.containsKey(node) && !dfs(node, 0))\n                return false;\n        return true;\n    }\n\n    public boolean dfs(int node, int c) {\n        if (color.containsKey(node))\n            return color.get(node) == c;\n        color.put(node, c);\n\n        for (int nei: graph[node])\n            if (!dfs(nei, c ^ 1))\n                return false;\n        return true;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333949739","body":"```java\nclass Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335383632","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for(char m : moves.toCharArray()){\n            if(m == 'R'){\n                x++;\n            }else if(m == 'L'){\n                x--;\n            }else if(m == 'U'){\n                y++;\n            }else if(m == 'D'){\n                y--;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336184855","body":"```java\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[] ans = new int[n];\n        int[][] extTasks = new int[n][3];\n        for(int i = 0; i < n; i++) {\n            extTasks[i][0] = i;\n            extTasks[i][1] = tasks[i][0];\n            extTasks[i][2] = tasks[i][1];\n        }\n        Arrays.sort(extTasks, (a,b)->a[1] - b[1]);\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>((a, b) -> a[2] == b[2] ? a[0] - b[0] : a[2] - b[2]);\n        int time = 0;\n        int ai = 0;\n        int ti = 0;\n        while(ai < n) {\n            while(ti < n && extTasks[ti][1] <= time) {\n                pq.offer(extTasks[ti++]);\n\n            }\n            if(pq.isEmpty()) {\n                time = extTasks[ti][1];\n                continue;\n            }\n            int[] bestFit = pq.poll();\n            ans[ai++] = bestFit[0];\n            time += bestFit[2];\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336449486","body":"```java\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\n        // 将所有时间转换为分钟数\n        int start = Integer.parseInt(loginTime.substring(0,2)) * 60 + Integer.parseInt(loginTime.substring(3,5));\n        int end = Integer.parseInt(logoutTime.substring(0,2))* 60 + Integer.parseInt(logoutTime.substring(3,5));\n        //判断是否超过了一天\n        if(start > end) end += 24 * 60;\n         // 那么如何判断在这个时间段内[startMM, finishMM]经历了多少个完整对局呢？\n        // 1. 将开始时间替换为第一场完整游戏开始的时间\n        // 2. 将结束时间替换为最后一场完整游戏结束的时间\n        // 3. 将两个全部替换\n        // 替换后可能会出现开始时间大于结束时间的情况，此时代表没有一局完整的游戏\n        if( start % 15 != 0){\n            start += 15 - start %15;\n            end -= end % 15;\n        }\n        int res = Math.max(0,end - start) / 15;\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337541177","body":"```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339571530","body":"### 思路\n> 三路快排\n### 代码\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuicksort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void randomizedQuicksort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuicksort(nums, l, pos - 1);\n            randomizedQuicksort(nums, pos + 1, r);\n        }\n    }\n\n    public int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums, r, i);\n        return partition(nums, l, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(nlogn)\n- 空间：o(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341018044","body":"### 思路\n> 二分查找\n### 代码\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n\n```\n### 复杂度\n- 时间：o(logx)\n- 空间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342883105","body":"```java\n/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while(left < right){\n            int mid  = left + (right - left) /2;\n            if(isBadVersion(mid)){\n                right = mid;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344446601","body":"> 归并\n```java\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345255132","body":"```java\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        int ans = 0;\n        Arrays.sort(heaters);\n        for (int house : houses) {\n            int i = binarySearch(heaters, house);\n            int j = i + 1;\n            int leftDistance = i < 0 ? Integer.MAX_VALUE : house - heaters[i];\n            int rightDistance = j >= heaters.length ? Integer.MAX_VALUE : heaters[j] - house;\n            int curDistance = Math.min(leftDistance, rightDistance);\n            ans = Math.max(ans, curDistance);\n        }\n        return ans;\n    }\n\n    public int binarySearch(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        if (nums[left] > target) {\n            return -1;\n        }\n        while (left < right) {\n            int mid = (right - left + 1) / 2 + left;\n            if (nums[mid] > target) {\n                right = mid - 1;\n            } else {\n                left = mid;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345585057","body":"```java\nclass Solution {\n    public int solve(int[] nums, int k) {\n        Arrays.sort(nums);\n        int absMin = 0;\n        int absMax = nums[nums.length-1] - nums[0];\n\n        while (absMin <= absMax) {\n            int absMid = (absMin + absMax) / 2;\n            if (count_not_greater(nums, absMid) <= k) {\n                absMin = absMid + 1;\n            } else {\n                absMax = absMid - 1;\n            }\n        }\n\n        return absMin;\n    }\n\n    private long count_not_greater(int[] nums, int targetDiff) {\n        long count = 0;\n\n        int l = 0;\n        for (int r=1; r<nums.length; r++) {\n            while (nums[r] - nums[l] > targetDiff) {\n                l++;\n            }\n\n            count += r - l;\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346688309","body":"```java\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int m=grid.size();\n        int n=grid[0].size();\n        UnionFind uf(m*n);\n        vector<tuple<int,int,int>>edge;\n        for(int i=0;i<m;i++)\n        for(int j=0;j<n;j++){\n            int id=i*n+j;\n            if(i>0)edge.emplace_back(max(grid[i][j],grid[i-1][j]),id,id-m);\n            if(j>0)edge.emplace_back(max(grid[i][j],grid[i][j-1]),id,id-1);\n        }\n        sort(edge.begin(),edge.end());\n        int res=0;\n        for(auto&[v,x,y]:edge){\n            uf.merge(x,y);\n            if(uf.connected(0,n*n-1)){\n                res=v;\n                break;\n            }\n        }\n        return res;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348733930","body":"```java\nclass Solution {\n    public int maxVowels(String s, int k) {\n        // hash表存字母\n        if(s == null || s.length() < k) return 0;\n\n        int res = 0;\n        Set<Character> set = new HashSet<>(){{\n            add('a');\n            add('e');\n            add('i');\n            add('o');\n            add('u');\n            }};\n        // 从左往右判断第一个窗口\n        for(int i = 0;i< k;i++){\n            if(set.contains(s.charAt(i))) res++;\n        }\n\n        int cur = res;\n        for(int i = 1; i < s.length() -k + 1;i++){\n            if(set.contains(s.charAt(i - 1))) cur--;\n            if(set.contains(s.charAt(i + k - 1))) cur++;\n            res = Math.max(res,cur);\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351380355","body":"```java\nclass Solution {\n     public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1;\n        double dp[] = new double[N + 1],  Wsum = 1, res = 0;\n        dp[0] = 1;\n        for (int i = 1; i <= N; ++i) {\n            dp[i] = Wsum / W;\n            if (i < K) Wsum += dp[i]; else res += dp[i];\n            if (i - W >= 0) Wsum -= dp[i - W];\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353135190","body":"```java\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        int sLen = s.size(), pLen = p.size();\n\n        if (sLen < pLen) {\n            return vector<int>();\n        }\n\n        vector<int> ans;\n        vector<int> sCount(26);\n        vector<int> pCount(26);\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s[i] - 'a'];\n            ++pCount[p[i] - 'a'];\n        }\n\n        if (sCount == pCount) {\n            ans.emplace_back(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s[i] - 'a'];\n            ++sCount[s[i + pLen] - 'a'];\n\n            if (sCount == pCount) {\n                ans.emplace_back(i + 1);\n            }\n        }\n\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354656310","body":"```java\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n            need=collections.defaultdict(int)\n            for c in t:\n                need[c]+=1\n            needCnt=len(t)\n            i=0\n            res=(0,float('inf'))\n            for j,c in enumerate(s):\n                if need[c]>0:\n                    needCnt-=1\n                need[c]-=1\n                if needCnt==0:       \n                    while True:      \n                        c=s[i] \n                        if need[c]==0:\n                            break\n                        need[c]+=1\n                        i+=1\n                    if j-i<res[1]-res[0]:   \n                        res=(i,j)\n                    need[s[i]]+=1  \n                    needCnt+=1\n                    i+=1\n            return '' if res[1]>len(s) else s[res[0]:res[1]+1]\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356817295","body":"```java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> ans = new  ArrayList<String>();\n        for(int h =0 ; h < 12 ;h++){\n            for(int m = 0;m < 60;m++){\n                if(Integer.bitCount(h) + Integer.bitCount(m) == turnedOn)\n                    ans.add(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n            }\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357865282","body":"```java\nclass Solution {\n    public int totalNQueens(int n) {\n        int[] rows = new int[n];\n        return process(0, rows, n);\n    }\n\n    private int process(int i, int[] rows, int n){\n        if(i == n){\n            return 1;\n        }\n        int res = 0;\n        for(int j = 0; j < n; j++){\n            if(isValid(rows, i, j)){\n                rows[i] = j;\n                res += process(i + 1, rows, n);\n            }\n        }\n        return res;\n    }\n\n    private boolean isValid(int[] rows, int i, int j){\n        for(int k = 0; k < i; k++){\n            if(rows[k] == j || Math.abs(i - k) == Math.abs(j - rows[k])){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359589287","body":"```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int maxArea = 0;\n        for(int i = 0;i < grid.length;i++){\n            for(int j = 0;j < grid[0].length;j++){\n                if(grid[i][j] != 0){\n                    int[] cur_max = new int[1];\n                    dfs(grid,i,j,cur_max);\n                    maxArea = Math.max(cur_max[0],maxArea);\n                }\n            }\n        }\n        return maxArea;\n    }\n    public void dfs(int[][] grid,int row,int col,int[] curArea){\n        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == 0){\n            return;\n        }\n        grid[row][col] = 0;\n        curArea[0] += 1;\n        // 上下左右\n        dfs(grid,row -1,col,curArea);\n        dfs(grid,row +1,col,curArea);\n        dfs(grid,row,col + 1,curArea);\n        dfs(grid,row,col - 1,curArea);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361459706","body":"```java\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        final int INF = 1000000;\n        int[] dx = {-1, 0, 1, 0};\n        int[] dy = {0, 1, 0, -1};\n        int n = grid.length;\n        int[][] d = new int[n][n];\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] status1, int[] status2) {\n                return status1[0] - status2[0];\n            }\n        });\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                d[i][j] = INF;\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    d[i][j] = 0;\n                    queue.offer(new int[]{0, i, j});\n                }\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[1] + dx[i], ny = f[2] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (f[0] + 1 < d[nx][ny]) {\n                    d[nx][ny] = f[0] + 1;\n                    queue.offer(new int[]{d[nx][ny], nx, ny});\n                }\n            }\n        }\n\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, d[i][j]);\n                }\n            }\n        }\n\n        return ans == INF ? -1 : ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362910570","body":"```java\nclass Solution:\n    def solve(self, graph, target):\n        q = collections.deque([target])\n        visited = set()\n        steps = 0\n        while q:\n            for i in range(len(q)):\n                cur = q.popleft()\n                visited.add(cur)\n                for neighbor in graph[cur]:\n                    if neighbor not in visited:\n                        q.append(neighbor)\n                    elif neighbor == target:\n                        return steps + 1\n            steps += 1\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1364019716","body":"```java\nclass Solution {\n      // x {y : [val,val,...]}\n    Map<TreeNode,int[]> map = new  HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n    map.put(root, new int[]{0,0,root.val}); // root的位置为（0,0,val）\n       // 坐标集合以 x 坐标分组\n     // dfs 遍历节点并记录每个节点的坐标\n    dfs(root);\n    List<int[]> list = new ArrayList<>(map.values());\n  // 得到所有节点坐标后，先按 x 坐标升序排序\n    // 再给 x 坐标相同的每组节点坐标分别排序\n    // y 坐标相同的，按节点值升序排\n      // 否则，按 y 坐标降序排\n    Collections.sort(list,(a,b)->{  // lamda表达式定义排序规则\n        if(a[0] != b[0]) return a[0] - b[0];\n        if(a[1] != b[1]) return a[1] - b[1];\n        return a[2] - b[2];\n    });\n    int n = list.size();\n    List<List<Integer>> ans = new ArrayList<>();\n    // 将list中的值放到ans中\n     for (int i = 0; i < n; ) {\n            int j = i;\n            List<Integer> tmp = new ArrayList<>();\n            while (j < n && list.get(j)[0] == list.get(i)[0]) \n                tmp.add(list.get(j++)[2]);\n            ans.add(tmp);\n            i = j;\n        }\n    return ans;\n    }\n    public void dfs(TreeNode root){\n        if(root == null) return;\n        int[] arr = map.get(root);\n        //初始化 x ，y\n        int x = arr[0];\n        int y =  arr[1];\n        int val = arr[2];\n        if(root.left != null){\n            // 坐标迭代\n            map.put(root.left,new  int[]{x - 1,y + 1,root.left.val});\n            dfs(root.left);\n        }\n         if(root.right != null){\n            map.put(root.right,new int[]{x + 1,y + 1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364544838","body":"```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n+1];\n        dp[0] = dp[1] = 0;\n        for(int i = 2;i <= n;i++){\n            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);\n        }\n        return dp[n];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364698992","body":"```java\nclass Solution {\n    public int rob(int[] nums) {\n        //判断数组是否为空\n        if(nums == null || nums.length == 0){\n            return 0;\n        }\n        int length = nums.length;\n        if(length == 1){\n            return nums[0];\n        }\n        // 初始化\n        \n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n\n        //遍历顺序\n        for(int i = 2; i < length; i++){\n            dp[i] = Math.max((dp[i - 2] + nums[i]),dp[i - 1]);\n        }\n\n        return dp[length -1];\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365177759","body":"```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n       if(nums == null || nums.length == 0){\n           return 0;\n       } \n       // 定义dp【】\n       int length = nums.length;\n       int[] dp = new int[length];\n       // 初始化整个dp数组全为1 \n       Arrays.fill(dp,1);\n       int res = 1;\n       //遍历\n       for(int i = 1; i < length ; i++){\n           for(int j = 0 ; j < i;j++){\n               if(nums[j] < nums[i]) dp[i] = Math.max(dp[j] + 1,dp[i]);\n           }\n           res = Math.max(res,dp[i]);\n       }\n       return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365877268","body":"```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length();\n        int n = text2.length();\n        //初始化\n        int[][] dp = new int[m + 1][n + 1];\n        //遍历顺序\n        for(int i = 1; i <= m;i++){\n            for(int j = 1;j <= n;j++){\n                if(text1.charAt(i - 1) == text2.charAt(j - 1)){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                    dp[i][j] = Math.max(dp[i - 1][j],dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366665422","body":"```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        // 定义dp\n        int[] dp = new int[n];\n        // 遍历\n       Arrays.fill(dp,1);\n        for(int i = 1 ; i < m;i++){\n            for(int j = 1; j < n ; j++){\n                 dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n        return dp[n-1];\n\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367410285","body":"```java\n\nclass Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] dp = new double[k + 1][n][n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (int[] dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367978542","body":"```java\nclass Solution {\n    public static boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n        int[] dp = new int[1 << maxChoosableInteger];\n        Arrays.fill(dp, -1);\n        return dfs(desiredTotal, 0, maxChoosableInteger, dp) == 1;\n    }\n\n    public static int dfs(int total, int state, int max, int[] dp) {\n        if (dp[state] != -1) return dp[state];\n        for (int i = 0; i < max; i++) {\n            if (((state >> i) & 1) == 1) continue;\n            if (total <= i + 1) return dp[state] = 1; \n            if (dfs(total - i - 1, state | (1 << i), max, dp) == 0) return dp[state] = 1; \n        }\n        return dp[state] = 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368242981","body":"```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true;\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            for (int j = target; j >= num; --j) {\n                dp[j] |= dp[j - num];\n            }\n        }\n        return dp[target];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368450573","body":"```java\nclass Solution {\n    int count = 0;\n\n    public int findTargetSumWays(int[] nums, int target) {\n        backtrack(nums, target, 0, 0);\n        return count;\n    }\n\n    public void backtrack(int[] nums, int target, int index, int sum) {\n        if (index == nums.length) {\n            if (sum == target) {\n                count++;\n            }\n        } else {\n            backtrack(nums, target, index + 1, sum + nums[index]);\n            backtrack(nums, target, index + 1, sum - nums[index]);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1369005065","body":"```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        // 自底向上的动态规划\n        if(coins.length == 0){\n            return -1;\n        }\n\n        // memo[n]的值： 表示的凑成总金额为n所需的最少的硬币个数\n        int[] memo = new int[amount+1];\n        // 给memo赋初值，最多的硬币数就是全部使用面值1的硬币进行换\n        // amount + 1 是不可能达到的换取数量，于是使用其进行填充\n        Arrays.fill(memo,amount+1);\n        memo[0] = 0;\n        for(int i = 1; i <= amount;i++){\n            for(int j = 0;j < coins.length;j++){\n                if(i - coins[j] >= 0){\n                    // memo[i]有两种实现的方式，\n                    // 一种是包含当前的coins[i],那么剩余钱就是 i-coins[i],这种操作要兑换的硬币数是 memo[i-coins[j]] + 1\n                    // 另一种就是不包含，要兑换的硬币数是memo[i]\n                    memo[i] = Math.min(memo[i],memo[i-coins[j]] + 1);\n                }\n            }\n        }\n\n        return memo[amount] == (amount+1) ? -1 : memo[amount];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369849130","body":"```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370936633","body":"```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int m = g.length, n = s.length;\n        int count = 0;\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\n            while (j < n && g[i] > s[j]) {\n                j++;\n            }\n            if (j < n) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372168379","body":"```java\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals.length == 0) {\n            return 0;\n        }\n        \n        Arrays.sort(intervals, new Comparator<int[]>() {\n            public int compare(int[] interval1, int[] interval2) {\n                return interval1[0] - interval2[0];\n            }\n        });\n\n        int n = intervals.length;\n        int[] f = new int[n];\n        Arrays.fill(f, 1);\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (intervals[j][1] <= intervals[i][0]) {\n                    f[i] = Math.max(f[i], f[j] + 1);\n                }\n            }\n        }\n        return n - Arrays.stream(f).max().getAsInt();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373777785","body":"```java\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i = 0, j = people.length - 1;\n        int res = 0;\n        \n        while(i <= j){\n            if(people[i] + people[j] <= limit)\n                i++;\n            j--;\n            res++;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374487405","body":"```java\n class Solution {\n        /*\n        dp[i] = i个不同的数组成的二叉搜索数的个数\n        假设 i = 5\n        当根节点等于 1 时 ，其余数字都比1大，只能在右边 dp[i] += dp[4]\n        当根节点等于 2 时，左边有一个1比2小，右边有三个比2大的数字 dp[i] += dp[1] * dp[3]\n        当根节点等于 3 时，左边有两个数比3小，右边有两个数比3大的数字 dp[i] += dp[2] * dp[2]\n        ...\n        知道根节点等于5，左边有4个数字比5小，只能放在5的左边,dp[i] += dp[4]\n         */\n        public int numTrees(int n) {\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n            dp[1] = 1;\n            for (int i = 2; i <= n; i++) {\n                for (int j = 1; j <= i; j++) {\n                    int leftNum = dp[j - 1];\n                    int rightNum = dp[i - j];\n                    dp[i] += leftNum * rightNum;\n                }\n            }\n            return dp[n];\n        }\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374837037","body":"```java\npublic ListNode mergeTwoLists(ListNode a, ListNode b) {\n    if (a == null || b == null) {\n        return a != null ? a : b;\n    }\n    ListNode head = new ListNode(0);\n    ListNode tail = head, aPtr = a, bPtr = b;\n    while (aPtr != null && bPtr != null) {\n        if (aPtr.val < bPtr.val) {\n            tail.next = aPtr;\n            aPtr = aPtr.next;\n        } else {\n            tail.next = bPtr;\n            bPtr = bPtr.next;\n        }\n        tail = tail.next;\n    }\n    tail.next = (aPtr != null ? aPtr : bPtr);\n    return head.next;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375501245","body":"```java\nclass Solution {\n    Map<Integer, int[]> memo = new HashMap();\n    public int[] beautifulArray(int n) {\n        memo.put(1, new int[]{1});\n        return dp(n);\n    }\n    private int[] dp(int n) {\n        if (memo.get(n) != null) {\n            return memo.get(n);\n        }\n        int[] res = new int[n];\n        int i = 0;\n        for (int x : dp((n + 1) / 2)) {\n            res[i++] = 2 * x - 1;\n        }\n        for (int x : dp(n / 2)) {\n            res[i++] = 2 * x;\n        }\n        memo.put(n, res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377235812","body":"```java\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int xorsum = 0;\n        for (int num : nums) {\n            xorsum ^= num;\n        }\n        // 防止溢出\n        int lsb = (xorsum == Integer.MIN_VALUE ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num : nums) {\n            if ((num & lsb) != 0) {\n                type1 ^= num;\n            } else {\n                type2 ^= num;\n            }\n        }\n        return new int[]{type1, type2};\n    }\n}\n```\n- 时间复杂度o(n) n为数组长度\n- 空间复杂度o(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378799046","body":"```java\nclass Solution {\n    List<Integer> t = new ArrayList<Integer>();\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> subsets(int[] nums) {\n        int n = nums.length;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            t.clear();\n            for (int i = 0; i < n; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    t.add(nums[i]);\n                }\n            }\n            ans.add(new ArrayList<Integer>(t));\n        }\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380343963","body":"```java\nclass Trie {\n    private Trie[] children;\n    private boolean isEnd;\n\n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;\n    }\n    \n    public void insert(String word) {\n        Trie node = this;\n        for (int i = 0; i < word.length(); i++) {\n            char ch = word.charAt(i);\n            int index = ch - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new Trie();\n            }\n            node = node.children[index];\n        }\n        node.isEnd = true;\n    }\n    \n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n    \n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n\n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (int i = 0; i < prefix.length(); i++) {\n            char ch = prefix.charAt(i);\n            int index = ch - 'a';\n            if (node.children[index] == null) {\n                return null;\n            }\n            node = node.children[index];\n        }\n        return node;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381969749","body":"```java\nclass MapSum {\n    Map<String, Integer> map;\n\n    public MapSum() {\n        map = new HashMap<>();\n    }\n    \n    public void insert(String key, int val) {\n        map.put(key,val);\n    }\n    \n    public int sum(String prefix) {\n        int res = 0;\n        for (String s : map.keySet()) {\n            if (s.startsWith(prefix)) {\n                res += map.get(s);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382822207","body":"```java\nclass Solution {\n    private Node root = new Node();\n    public int[][] multiSearch(String big, String[] smalls) {\n        int n = smalls.length;\n        List<Integer>[] res = new List[n];\n        for(int i = 0 ; i < n ; i++)\n            res[i] = new ArrayList<>();\n        for(int i = 0 ; i < smalls.length; i++)\n            insert(smalls[i], i);\n\n        for(int i = 0 ; i < big.length(); i++){\n\n            Node tmp = root;\n\n            for(int j = i ; j < big.length(); j++){\n                if(tmp.children[big.charAt(j) - 'a'] == null)\n                    break;\n\n                tmp = tmp.children[big.charAt(j) - 'a'];\n\n                if(tmp.isWord)\n                    res[tmp.id].add(i);\n            }\n        }\n        int[][] ret = new int[n][];\n\n        for(int i = 0 ; i < n ; i++){\n\n            ret[i] = new int[res[i].size()];\n\n            for(int j = 0 ; j < ret[i].length; j++)\n                ret[i][j] = res[i].get(j);\n        }\n\n        return ret;\n    }\n\n    private void insert(String word, int id){\n\n        Node tmp = root;\n\n        for(int i = 0; i < word.length(); i++){\n\n            if(tmp.children[word.charAt(i) - 'a'] == null)\n                tmp.children[word.charAt(i) - 'a'] = new Node();\n\n            tmp = tmp.children[word.charAt(i) - 'a'];\n        }\n\n        tmp.isWord = true;\n        tmp.id = id;\n    }\n\n    class Node {\n\n        Node[] children;\n        boolean isWord;\n        int id;\n\n        public Node() {\n\n            children = new Node[26];\n            isWord = false;\n            id = 0;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383165436","body":"```java\nclass Solution {\n    public int findCircleNum(int[][] isConnected) {\n        int n = isConnected.length;\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        for(int i = 0; i < n; i++){\n            if(!visited[i]){\n                dfs(isConnected, visited, i);\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public void dfs(int[][] isConnected, boolean[] visited, int i){\n        for(int j = 0; j < isConnected.length; j++){\n            if(isConnected[i][j] == 1 && !visited[j]){\n                visited[j] = true;\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298075373","body":"> # 思路\n> 从后往前逐位将数字加在一起,若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中.\n> # 代码\n> ```c++\n>class Solution {\n>public:\n>    vector<int> addToArrayForm(vector<int>& num, int k) {\n>       vector<int> res;\n>\n>      int n = num.size();\n>       for (int i = n - 1; i >= 0; --i) {\n>            int sum = num[i] + k % 10;\n>            k /= 10;\n>           if (sum >= 10) {\n>                k++;\n>               sum -= 10;\n>            }\n>           res.push_back(sum);\n>        }\n>        for (; k > 0; k /= 10) {\n>            res.push_back(k % 10);\n>       }\n>       reverse(res.begin(), res.end());\n>       return res;\n>      }\n>   }\n\n> ```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299513514","body":"\n> \n> ## 思路\n> 1、从当前下标出发，分别向左、右两个方向去寻找目标字符c  \n> 2、只在一个方向找到的话，直接计算字符距离  \n> 3、两个方向都找到的话，取两个距离的最小值  \n> \n> ## 代码\n> ```c++\n> \n>class Solution {  \n>public:    \n>    vector<int> shortestToChar(string S, char C) {  \n>        vector<int> res(S.length());  \n>\n>        for (int i = 0; i < S.length(); i++) {  \n>            if (S[i] == C) continue;  \n>\n>            int left = i;  \n>           int right = i;  \n>            int dist = 0;  \n>\n>            while (left >= 0 || right <= S.length() - 1) {  \n>                if (S[left] == C) {   \n>                  dist = i - left;    \n>                    break;  \n>                }  \n>                if (S[right] == C) {  \n>                    dist = right - i;  \n>                   break;  \n>                }  \n>\n>              if (left > 0) left--;  \n>                if (right < S.length() - 1) right++;  \n>            }  \n>\n>            res[i] = dist;  \n>        }  \n>\n>        return res;  \n>    }  \n>};  \n> \n> ```\n> \n> ## 复杂度分析\n> n*n，n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301691388","body":"> ### 思路\n> 用 vector 模拟栈，使用一个数组去保存数字  \n> push和pop都要注意为空的边缘情况，并且k大小可能超过size  \n> ### 代码 (cpp)\n>```cpp  \n>class CustomStack {  \n>public:  \n>    int max;  \n>    vector<int>stack;  \n>    CustomStack(int maxSize) {  \n>       max=maxSize;  \n>    }  \n>    \n>    void push(int x) {  \n>        if(stack.size()<max){  \n>            stack.push_back(x);  \n >           return ;  \n>        }\n>    }\n>    \n >   int pop() {  \n>        if(stack.empty()){  \n>            return -1;  \n>        }  \n>        int val=stack.back();  \n>        stack.pop_back();  \n>        return val;  \n>    }\n>    \n>    void increment(int k, int val) {  \n>        for(int i=0;i<k&&i<stack.size();i++){  \n>            stack[i]+=val;  \n>        }  \n>        return ;  \n>    }  \n>  };     \n>```  \n> **复杂度分析**  \n> - 时间复杂度：O(N)  \n> - 空间复杂度：O(N)  \n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303528403","body":"> ### 思路\n> \n>  利用一个数字栈与一个符号栈来处理，首先遍历整个字符串，如果当前的字符为数字，字母或者左括号，直接进栈，如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，取出栈顶的数字，根据字符串构造出新的字符串并进栈\n> ### 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    string decodeString(string s) {     \n>        stack<int> st_num;   //数字栈  \n>        string symbol;    \n>        int num=0;   \n>        for(int i=0;i<s.size();i++)\n>        {\n>            if(s[i]>='0'&&s[i]<='9'){   \n>                num=s[i]-'0'+num*10;  \n>            }else if(s[i]=='['){      \n>                st_num.push(num);  \n >               num=0;  \n>                symbol+=s[i];  \n>            }else if(s[i]==']'){     \n>               int j=symbol.size()-1;  \n>                string tmp_string;  \n>                while(symbol[j]!='[')  \n>                {  \n>                    tmp_string+=symbol[j];  \n >                   symbol.pop_back();  \n>                    j--;  \n>                }  \n >               symbol.pop_back();  \n>                int tmp_num=st_num.top();  \n>                st_num.pop();  \n>                reverse(tmp_string.begin(),tmp_string.end());  \n>                for(int k=0;k<tmp_num;k++)  \n>                {  \n>                    symbol+=tmp_string;  \n>                }  \n>            }else{   \n>                symbol+=s[i];  \n>            }  \n>        }  \n>        return symbol;  \n>    }  \n> };   \n> ```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304518091","body":"> # 思路\n> \n> 将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n> \n> # 代码\n> ```C++\n>class MyQueue {  \n>public:  \n>    stack<int>stIn;  \n>    stack<int>stOut;  \n>    MyQueue() {  \n>\n>    }  \n>    \n>    void push(int x) {  \n>        stIn.push(x);  \n>    }  \n>    \n>    int pop() {  \n>      if(stOut.empty()){  \n>            while(!stIn.empty()){  \n>                stOut.push(stIn.top());  \n>               stIn.pop();  \n>            }  \n>        }  \n>        int result = stOut.top();  \n>        stOut.pop();  \n>        return result;  \n>    }  \n>    \n>    int peek() {  \n>        int res=this->pop();  \n>        stOut.push(res);  \n>        return res;  \n>\n>    }  \n>    \n>    bool empty() {  \n>       return  stOut.empty()&&stIn.empty();  \n>\n>    }  \n>};  \n> ```\n> # 复杂度分析\n> \n>- 时间复杂度：O(1)  \n>- 空间复杂度：O(n)   \n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734667","body":"> ### 思路\n> 使用单调栈。我们可以用一个栈来存储这些分块的最大值。最后得到的栈的大小，也就是最多能完成排序的块。\n> \n> ### 代码\n> \n> ```c++  \n>class Solution {  \n>public:  \n>    int maxChunksToSorted(vector<int>& arr) {  \n>        stack<int> stk;  \n>        for (int& v : arr) {  \n>            if (stk.empty() || stk.top() <= v)  \n>                stk.push(v);  \n>            else {  \n>                int mx = stk.top();  \n>              stk.pop();  \n>                while (!stk.empty() && stk.top() > v) stk.pop();  \n>                stk.push(mx);  \n>            }  \n>        }  \n>        return stk.size();  \n>    } \n> };   \n> ```\n> \n> **复杂度分析**\n> \n> - 时间复杂度：O(n)\n> - 空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305353026","body":"> # 思路\n>  首先遍历整个链表，求出链表的长度n，并找出链表的尾节点tail。  \n> 令 k = k % n，然后再次从头节点head开始遍历，找到第n - k个节点p，那么1 ~ p是链表的前 n - k个节点，p+1 ~ n是链表的后k个节点。    \n>  将链表的后k个节点和前 n - k个节点拼接到一块，并让head指向新的头节点(p->next)，新的尾节点即p节点的next指针指向null。    \n> 最后返回链表的新的头节点head  \n>```c++\n>\n>class Solution {\n>public:  \n>    ListNode* rotateRight(ListNode* head, int k) {  \n>        if(!head || !k)  return head;  \n>        int n = 0;       \n>        ListNode* tail;   \n>        for(ListNode* p = head; p ; p = p->next){  \n>            tail = p;  \n>            n++;  \n>        }  \n>        k %= n;    \n>        ListNode* p = head;  \n>        for(int i = 0; i < n - k - 1; i++)   p = p->next;   \n>        tail->next = head;  \n>        head = p->next;  \n>        p->next = nullptr;  \n>        return head;  \n>    }\n> };   \n>```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306653224","body":"> # 思路\n>1、建立一个虚拟头结点 dummy  \n>2、定义p = dummy，a = p->next，b = a->next  \n>3、遍历整个链表,将p的next指针指向b,将a的next指向b->next,将b的next指向a.  \n> \n> # 代码\n> ```c++\n>class Solution {  \n>public:  \n>    ListNode* swapPairs(ListNode* head) {  \n>        ListNode*  dummy = new ListNode(-1);   \n>        dummy->next = head; \n>        for(auto p = dummy; p->next && p->next->next; )  \n>        {  \n>            auto a = p->next, b = a->next;  \n>           p->next = b;  \n>            a->next = b->next;   \n>            b->next = a;  \n>            p = a;  \n>        }  \n>        return dummy->next;  \n>    }  \n>  };  \n> ```\n> # 复杂度分析\n>- 时间复杂度O(n)  \n>- 空间复杂度O(n)   \n>\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308455876","body":"> ### 思路\n> 用两个指针，一块一慢，快的每次走两步，慢的每次走一步.这样当快指针遍历结束时，慢指针指向的也就是链表的中间位置。这时候把中间位置的结点的值作为二叉搜索树当前结点的值.  \n>用pre指针指向慢指针指向的前一个位置，当每次使用完慢指针时，以便断开链表.  \n>\n> ### 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    TreeNode* sortedListToBST(ListNode* head) {  \n>       TreeNode* root;  \n>        if(!head) return NULL;   \n>        if(!head->next){   \n>            root = new TreeNode(head->val);  \n>            return root;  \n>        }   \n>        ListNode *slow = head;     \n>        ListNode *fast = head;     \n>        ListNode *prev = head;   \n>        while(fast != NULL && fast->next != NULL){   \n>            fast = fast->next->next;  \n>            slow = slow->next;  \n>       }  \n>        while(prev->next!=slow){   \n>            prev = prev->next;  \n>        }  \n>        root = new TreeNode(slow->val);  \n>        ListNode * right_head = slow->next;  \n>        prev->next = NULL;   \n>        root->left = sortedListToBST(head);  \n>        root->right = sortedListToBST(right_head);  \n>\n>        return root;  \n>    }  \n> };  \n> ```\n> \n> **复杂度分析**\n> - 时间复杂度：O(nlogn)\n> - 空间复杂度：O(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310043771","body":"> ### 思路\n>首先判断链表headA 和 headB 是否为空，如果其中至少有一个链表为空，则两个链表一定不相交，返回 null  \n>当链表headA 和 headB 都不为空时，创建两个指针A 和 B，初始时分别指向两个链表的头节点headA 和 headB，然后将两个指针依次遍历两个链表的每个节点。  \n>\n> \n> ```c++  \n> public class Solution {\n>      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {  \n>      if (headA == nullptr || headB == nullptr) {  \n>           return nullptr;  \n>        }  \n>      ListNode *A = headA, *B = headB;  \n>       while( A != B){  \n>          A = A != nullptr ? A->next : headB;  \n>          B = B != nullptr ? B->next : headA;  \n>       }  \n>       return A;  \n>     }  \n> };  \n> \n> \n> ```\n> ### 复杂度\n> - 时间复杂度:o(a+ b)  \n> - 空间复杂度:o(1)    \n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312304737","body":"> ## 基本思路：\n>双向链表加哈希  \n> \n>\n> ## 步骤：  \n> \n> 1. put：若key存在，则修改对应的value，同时将key对应的节点放到双链表的最左侧。若key不存在，那么在双链表的最左侧插入一个节点。如果超过容量，那么就删除双链表最右侧的节点。\n> 2. get：用哈希表判断key是否存在,若key存在，则返回对应的value，同时将key对应的节点放到双链表的最左侧，否则返回-1\n> \n> \n> \n> ## 代码：\n> \n> ```c++\n> class LRUCache {  \n>public:  \n>    struct Node{  \n>        int key,value;  \n>        Node* left ,*right;  \n>        Node(int _key,int _value): key(_key),value(_value),left(NULL),right(NULL){}  \n>    }*L,*R;  \n>    int n;  \n>    unordered_map<int,Node*>hash;  \n>    void remove(Node* p)  \n>    {  \n>        p->right->left = p->left;  \n>        p->left->right = p->right;  \n>    }  \n>    void insert(Node *p)  \n>    {  \n>        p->right = L->right;  \n>        p->left = L;   \n>       L->right->left = p;  \n>        L->right = p;   \n>    }  \n>   LRUCache(int capacity) {  \n>        n = capacity;  \n>        L = new Node(-1,-1),R = new Node(-1,-1);  \n>        L->right = R;  \n>        R->left = L;      \n>    }  \n>    \n>    int get(int key) {  \n>        if(hash.count(key) == 0) return -1;  \n>        auto p = hash[key];  \n>        remove(p);  \n>        insert(p);  \n>        return p->value;  \n>    }  \n>    \n>    void put(int key, int value) {  \n>        if(hash.count(key))   \n>        {  \n>            auto p = hash[key];  \n>            p->value = value;  \n>            remove(p);  \n>            insert(p);  \n>        }  \n>        else   \n>        {  \n>            if(hash.size() == n)  \n>            {  \n>                auto  p = R->left;  \n>                remove(p);  \n>                hash.erase(p->key);   \n>                delete p;       \n>            auto p = new Node(key,value);    \n>            hash[key] = p;  \n>            insert(p);  \n>        }  \n>    }  \n>  };  \n> ```\n> \n> \n> \n> ## 复杂度分析：\n> \n> - 时间复杂度：O(1)    \n> - 空间复杂度：O(1)   \n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313184437","body":"> ## 思路\n> \n> \n> 递归  \n> \n> ## 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    bool background(TreeNode* left, TreeNode* right) {  \n>        if (left == NULL && right != NULL) return false;  \n>        else if (left != NULL && right == NULL) return false;  \n>        else if (left == NULL && right == NULL) return true;  \n>        else if (left->val != right->val) return false;  \n>        else return background(left->left, right->left) && background(left->right, right->right);  \n>  \n>    }  \n>    bool isSameTree(TreeNode* p, TreeNode* q) {  \n>        return background(p, q);  \n>    }  \n>  };  \n> ```\n> \n> ## 复杂度\n> \n> \n> - 时间复杂度：O(min(m,n))\n> - 空间复杂度：O(min(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314920606","body":"> ## 思路\n> \n>DFS 从根节点递归遍历整棵树，当遍历到叶节点时，将路径表示的数累加。  \n> \n> ## 代码\n> \n> \n> ```c++\n>class Solution {  \n>public:  \n>    int res = 0;  \n>    int sumNumbers(TreeNode* root) {  \n>        dfs(root, 0);  \n>        return res;  \n>    }  \n>    void dfs(TreeNode* root, int number)  \n>    {    \n>        number = number * 10 + root->val;  \n>        if(!root->left && !root->right)  res += number;    \n>        if(root->left)  dfs(root->left,number);\t  \t\t\n>        if(root->right) dfs(root->right,number);\t     \n>    }  \n> };  \n> \n> ```\n> \n> **复杂度分析**\n> \n> - 时间复杂度：O(n)\n> - 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318753064","body":"> ### 思路\n> \n> DFS\n> \n> ### 代码\n> \n> ```c++\n> class Codec {    \n>public:  \n>    void rserialize(TreeNode* root, string& str) {  \n>\n>        if (root == NULL) str += \"None,\";  \n>        else {  \n>            str += to_string(root->val) + \",\";  \n>            rserialize(root->left, str);  \n>            rserialize(root->right, str);  \n>        }        \n>    }  \n>    string serialize(TreeNode* root) {  \n>        string ret;  \n>        rserialize(root, ret);  \n>        return ret;  \n>    }  \n>\n>    TreeNode* rdeserialize(list<string>& dataArray) {  \n>        if(dataArray.front() == \"None\") {  \n>            dataArray.erase(dataArray.begin());  \n>            return NULL;  \n>        }  \n>\n>        TreeNode* root = new TreeNode(stoi(dataArray.front()));  \n>        dataArray.erase(dataArray.begin());  \n>        root->left = rdeserialize(dataArray);  \n>        root->right = rdeserialize(dataArray);  \n>        return root;  \n>    }  \n>\n>    TreeNode* deserialize(string data) {  \n>        list<string> dataArray;  \n>        string str;  \n>       for (auto& c : data) {    \n>            if (c == ',') {  \n>                dataArray.push_back(str);  \n>                str.clear();  \n>            } else {    \n>               str.push_back(c);  \n>            }  \n>        }   \n>        if (!str.empty()) {  \n>            dataArray.push_back(str);  \n>            str.clear();  \n>        }  \n>        return rdeserialize(dataArray);  \n>    }  \n>   };  \n> ```\n> \n> ### 复杂度分析\n> \n> 时间复杂度：O(N)  \n> 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319727379","body":"> ### 思路\n>通过 DFS 求出每个点的坐标，之后我们只需对坐标进行排序即可  \n>   \n> ### 代码\n> ```c++\n>class Solution {  \n>public:  \n>    struct Node {  \n>        int x, y, val;  \n>        Node() {}  \n>        Node(int a, int b, int c) : x(a), y(b), val(c) {}  \n>        bool operator < (Node node) const {  \n>            if(y != node.y) return y > node.y;  \n>           else if(x != node.x) return x > node.x;    \n>            return val > node.val;  \n>        }    \n>    };  \n>    map <int, priority_queue <Node> > ss;  \n>    vector <vector<int>> ans;  \n>\n>    void dfs(int x, int y, TreeNode *root) {  \n>        if(!root) return ;  \n>        ss[y].push({x, y, root->val});  \n>       dfs(x + 1, y - 1, root->left);  \n>        dfs(x + 1, y + 1, root->right);  \n>        return ;  \n>    }  \n>    vector<vector<int>> verticalTraversal(TreeNode* root) {  \n>        if(!root) return ans;  \n>        dfs(0, 0, root);  \n>        for(auto &[x, y] : ss) {  \n>            ans.push_back(vector<int>());  \n>            while(!y.empty()) {  \n>                ans.back().push_back(y.top().val);  \n>                y.pop();  \n>            }  \n>        }  \n>        return ans;  \n>    }  \n>   };   \n> ```\n> \n> ### 复杂度\n> 时间复杂度：O(nlog(n))  \n> 空间复杂度 ：O(n）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298076219","body":"思路\r\n1.  num转成数字，与k相加，再转成数组，空间复杂度O（n），时间复杂度O（n）\r\n2.  k每次取最后一位数字，直接与num数组从后向前相加，注意进位，空间负责度减小到O（n）\r\n\r\n代码\r\n```javascript```\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let kleft = k;\r\n    let i = num.length-1;\r\n    while(kleft || i>=0) {\r\n        const lastNum = kleft%10;\r\n        if (i<0) {\r\n        // k位数较多，依次取出，加到数组头部\r\n            num.unshift(lastNum);\r\n            kleft = Math.floor(kleft/10);\r\n            continue;\r\n        }\r\n        // 数组位数更多时\r\n        num[i] += lastNum;\r\n        if (num[i] >= 10 ){         // 进位\r\n            num[i] = num[i]%10;\r\n            const up = 1;\r\n        //  数组位置不够\r\n            if (i == 0) {\r\n                num.unshift(up);\r\n                i++;// 长度变长了\r\n            } else {\r\n                num[i-1] += up;\r\n            }\r\n        }\r\n        kleft = Math.floor(kleft/10);\r\n        i--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n复杂度：K的次数为常数级别\r\nTime: O（n）\r\nSpace:  O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300395771","body":"思路\r\n1.  暴力解法，遍历s每个字符，每次遍历，再遍历一次最近的c\r\n2. 用空间换时间，左右各遍历一次s，从左遍历时，当前存储左边最近一个c的index，右边同理。最后比较左右哪个小。\r\n\r\n\r\n代码\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n    let leftIdex = -1;\r\n    const leftArr = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        if (s[i] === c) {\r\n            leftIdex = i;\r\n        } \r\n        leftArr[i] = leftIdex;\r\n    }\r\n    const rightArr = [];\r\n    let rightIndex = -1;\r\n    for(let i=s.length-1;i>=0;i--) {\r\n        if (s[i] === c) {\r\n            rightIndex = i;\r\n        } \r\n        rightArr[i] = rightIndex;\r\n    }\r\n    const res = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        const left = Math.abs(leftArr[i] - i);\r\n        const right = Math.abs(rightArr[i] - i);\r\n        if (leftArr[i] === -1) {\r\n            res[i] = right;\r\n        } else if (rightArr[i] === -1) {\r\n            res[i] = left;\r\n        } else {\r\n            res[i] =  Math.min(left, right);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n复杂度分析：三次存储是常数级别，省略\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\np.s. 应该可以优化成只存一次，不用三次，第二次遍历的时候直接相加。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302054753","body":"### 思路\r\n1. 用数组模拟栈\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.total = 0;\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length === this.maxSize) return this.stack;\r\n    return this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.pop() || -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(var i = 0; i<k; i++ ){\r\n        if(this.stack[i]) this.stack[i] += val;\r\n    }\r\n    return this.stack;\r\n};\r\n\r\n\r\n ```\r\n### 复杂度： \r\n时间复杂度：\r\npush：O(1)\r\npop：O(1)\r\nincrement：O(k)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303709487","body":"### 思路\r\n把字符压到栈里，遇到 ] 出栈到 [  组成字符，继续出栈到非数字，组成数字，拼接字符串，当作一个完整字符，压栈，继续遍历\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n        continue;\r\n    }\r\n    let temStr = '';\r\n    while (stack[stack.length - 1] !== '[') {\r\n         temStr = stack.pop() + temStr;\r\n    }\r\n\r\n    stack.pop();\r\n\r\n    let numStr = '';\r\n    while (stack.length && isNumber(stack[stack.length - 1])) {\r\n        numStr =  stack.pop() + numStr;\r\n    }\r\n    const res = temStr.repeat(Number(numStr));\r\n    stack.push(res);\r\n  }\r\n  return stack.join('')\r\n};\r\n\r\nconst isNumber = (chr) => {\r\n  const num = Number(chr);\r\n  return num >=0 && num <=9;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n),\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304564384","body":"### 思路\r\n1. 入队的时候，push到数字开头（用两个栈来回装元素），反过来的队列，这样pop和peek可以直接用出栈操作\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    const tempStack = [];\r\n    while(this.stack.length) {\r\n        tempStack.push(this.stack.pop());\r\n    }\r\n    tempStack.push(x);\r\n    while(tempStack.length) {\r\n        this.stack.push(tempStack.pop());\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length-1]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度\r\n时间 push O(N), pop/peak/empty O(1)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304732911","body":"### 思路\r\n因为需要按块生序，所以用单调栈。单调栈存块最大值，比最大值小，则变成一个块。\r\n块最多是每个值一个块。\r\n\r\n### 代码\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack = [arr[0]];\r\n    for(let i = 1;i < arr.length;i++) {\r\n        if (arr[i] - stack[stack.length-1] >= 0) {\r\n            stack.push(arr[i]);\r\n        }\r\n\r\n        const max = stack.pop();\r\n        while(stack.length && stack[stack.length-1] > arr[i]) {\r\n            stack.pop()\r\n        }\r\n        stack.push(max);\r\n    }\r\n\r\n    return stack.length;\r\n\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305687396","body":"### 思路\r\n先找到旋转点，如果 k 小于链表长度，则旋转点是第 length-k，如果 大于链表长度是 length - k%length。通过快慢指针找到这个点。\r\n然后翻转：左边指针为null，尾部指针指向head，head指针指向旋转点.next.\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next || !k) return head;\r\n    let headNode = head;\r\n    let len = 1;\r\n    while (headNode.next) {\r\n        headNode = headNode.next;\r\n        len++;\r\n    }\r\n    let point = len - k % len;\r\n    if (point === len) {\r\n        return head;\r\n    }\r\n\r\n    // 尾指向头\r\n    headNode.next = head;\r\n    // 遍历相距距离\r\n    while (point) {\r\n        headNode = headNode.next;\r\n        point--;\r\n    }\r\n\r\n    const ret = headNode.next;\r\n    headNode.next = null;// 断掉\r\n    return ret;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306669500","body":"### 思路\r\n准备一个返回链表。遍历原链表，每遍历2个节点，断开，内部交换两个节点，再链接上返回链表。\r\n\r\n### 代码\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    let resNode = new ListNode();\r\n    let resTail = resNode;\r\n    let resHead = resNode;\r\n    let moveHead = head;\r\n    let moveTail = head;\r\n\r\n    while(moveTail) {\r\n        // 遍历两个节点\r\n        moveTail = moveTail.next;\r\n        if (!moveTail) {\r\n            resTail.next = moveHead;\r\n            return resHead.next;\r\n        }\r\n        // 断开\r\n        const temp = moveTail.next;\r\n        moveTail.next = null;\r\n       // 内部交换\r\n        reverse = swap(moveHead);\r\n        // 加入返回链表尾部\r\n        resTail.next = reverse;\r\n        // 尾指针移动到最后，即第二个节点。\r\n        resTail = reverse.next;\r\n        // 继续遍历后两个节点\r\n        moveHead = temp;\r\n        moveTail = temp;\r\n    }\r\n\r\n    return resHead.next;\r\n\r\n};\r\n\r\nvar swap = function(head) {\r\n    if (!head) return null;\r\n    if (!head.next) return\r\n    let resHead = head;\r\n    const temp = resHead.next;\r\n    resHead.next = null;\r\n    temp.next = resHead;\r\n    resHead = temp;\r\n    return resHead;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308102322","body":"### 思路\r\n因为左右平衡，所以链表的中间的节点是搜索二叉树的根节点，左右各自又为搜索二叉树，递归得出\r\n\r\n### 代码\r\n```javascript\r\nvar sortedListToBST = function(head) {\r\n    var makeTree = function(head, tail){\r\n        if(head === tail) return null;\r\n        const middleNode = getMiddleNode(head, tail);\r\n        const node = new TreeNode(middleNode.val);\r\n        node.left = makeTree(head, middleNode);\r\n        node.right = makeTree(middleNode.next, tail);\r\n        return node;\r\n    }\r\n\r\n    return makeTree(head, null);\r\n};\r\n\r\nvar getMiddleNode = function(head, tail) {\r\n    if (!head) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while (fast !== tail) {\r\n        fast = fast.next\r\n        if(fast!== tail){\r\n            fast = fast.next\r\n            slow = slow.next;\r\n        }\r\n    }\r\n    return slow;\r\n}; \r\n```\r\n### 复杂度\r\n时间：O(nlogn) 递归logn次，每次遍历链表\r\n空间：O(logn)  递归栈空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309084594","body":"### 思路\r\n求两个链表的长度，计算出差值k。两个链表遍历，长的先走k补，补齐差距，之后同步向后走，遇到相等的则是交点\r\n\r\n### 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let lenA = 0;\r\n    let getLenAHead = headA;\r\n    while(getLenAHead) {\r\n        lenA++;\r\n        getLenAHead = getLenAHead.next;\r\n    }\r\n\r\n    let lenB = 0;\r\n    let getLenBHead = headB;\r\n    while(getLenBHead) {\r\n        lenB++;\r\n        getLenBHead = getLenBHead.next;\r\n    }\r\n\r\n    let fastLen = Math.abs(lenA - lenB);\r\n    let resHeadFast = lenA > lenB ? headA : headB;\r\n    let resHeadSlow = lenA > lenB ? headB : headA;\r\n\r\n    while(fastLen) {\r\n        resHeadFast = resHeadFast.next;\r\n        fastLen--;\r\n    }\r\n\r\n    while(resHeadFast) {\r\n        if (resHeadFast === resHeadSlow) {\r\n            return resHeadFast;\r\n        }\r\n        resHeadFast = resHeadFast.next;\r\n        resHeadSlow = resHeadSlow.next;\r\n    }\r\n\r\n    return null;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n) \r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310649876","body":"### 思路\r\n1. 通过哈希表存储节点，遍历链表，如果遇到相同的node，即为入口。空间和时间复杂度O(n)\r\n2. 快慢指针遍历链表，快指针是慢指针走过节点的2倍，当相遇时，经过推导，相遇节点到入环的距离和 head到入环的距离相等。所以从head和相遇节点各自移动到相等，则是入环节点\r\n\r\n### 代码\r\n```javascript\r\nvar detectCycle = function(head) {\r\n    let fast = hasCycle(head);\r\n    if (!fast) return null;\r\n\r\n    let slow = head;\r\n    while(slow) {\r\n        if (slow === fast) return slow;\r\n        slow = slow.next;\r\n        fast = fast.next;\r\n    }\r\n    return null;\r\n};\r\n\r\nvar hasCycle = function(head) {\r\n    if (!head) return false;\r\n\r\n    let slow = head;\r\n    let fast = head;\r\n    while(fast && fast.next) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n        if (fast === slow) return fast;\r\n    }\r\n    return null;\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312494007","body":"### 思路\r\n哈希存储节点，使得get为O(1)，双向链表按最近访问关联节点，使得快速添加/更新/删除。\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar DLinkedNode = function(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.prev = null\r\n    this.next = null\r\n}\r\nvar LRUCache = function(capacity) {\r\n    this.map = {};\r\n    this.size = 0;\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n\r\n    this.head = new DLinkedNode(-1, -1)\r\n    this.tail = new DLinkedNode(-1, -1)\r\n    this.head.prev = null\r\n    this.head.next = this.tail\r\n    this.tail.prev = this.head\r\n    this.tail.next = null\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if (this.size == 0) {\r\n        return -1 \r\n    }\r\n    const node = this.map.get(key);\r\n    if (!node) {\r\n        return -1;\r\n    } \r\n    this.removeNode(node);\r\n    this.addNodeAtHead(node);\r\n    return node.value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    const node = this.map.get(key);\r\n    if  (node != null) {\r\n        node.value = value\r\n        this.removeNode(node)\r\n        this.addNodeAtHead(node)\r\n        return\r\n    }\r\n   \r\n    if (this.size === this.capacity) {\r\n        this.map.delete(this.tail.prev.key)\r\n        this.removeNode(this.tail.prev)\r\n        this.size--;\r\n    }\r\n    const newNode = new DLinkedNode(key, value);\r\n    this.map.set(key,newNode);\r\n    this.addNodeAtHead(newNode);\r\n    this.size++;\r\n};\r\nLRUCache.prototype.addNodeAtHead = function(node) {\r\n    this.head.next.prev = node;\r\n    node.next = this.head.next;\r\n    this.head.next = node;\r\n    node.prev = this.head;\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node) {\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：get O(1), put:O(1)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312532567","body":"### 思路\r\nroot节点深度为1，广度优先遍历树的节点，每次遍历当前节点和最大深度比较，然后把子节点压入队列，子节点深度=当前节点深度+1，\r\n\r\n### 代码\r\n```javascript\r\nvar maxDepth = function(root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        depth: 1\r\n    });\r\n    let max = -Infinity\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        const depth = temp.depth;\r\n        max = Math.max(depth, max);\r\n\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n) 每个节点访问一次\r\n空间：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312933517","body":"### 思路\r\ndfs ，递归比较，结束条件：都为空是相等，一个为空不相等，都不为空值不同为不想等。\r\n\r\n### 代码\r\n```javascript\r\nvar isSameTree = function(p, q) {\r\n    if (!q && !p) return true;\r\n    if (!q || !p) return false;\r\n    if (q.val !== p.val) return false;\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(min(n,m)) 遍历\r\n空间：O(min(m,n)) 递归栈空间最差是节点数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314086377","body":"### 思路\r\n深度优先或者广度优先遍历，遍历到子节点时，把父节点信息到带到子节点，遍历到叶节点时，即可收集到从根节点到叶节点的路径，记录数组。最后加总\r\n\r\n### 代码\r\ndfs\r\n```javascript\r\nvar sumNumbers = function(root) {\r\n   let result = []\r\n    if (root == null) {\r\n        return result\r\n    }\r\n    let dfs = (node, path) => {\r\n        path.push(node.val)\r\n        if (node.left == null && node.right == null) {\r\n            result.push([...path].join(''))\r\n            path.pop()\r\n            return\r\n        }\r\n        if (node.left != null) {\r\n            dfs(node.left, path)\r\n        }\r\n        if (node.right != null) {\r\n            dfs(node.right, path)\r\n        }\r\n        path.pop()\r\n    }\r\n    dfs(root, [], 0);\r\n\r\n    let sum = 0;\r\n    for(let i=0;i<result.length;i++) {\r\n        sum += parseInt(result[i]);\r\n    }\r\n\r\n    return sum;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n) 每个节点访问一次\r\n空间：O(h) 递归栈的深度即树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315597848","body":"### 思路\r\n广度优先遍历，每个节点记录深度，记录最大深度，当出现新的最大深度时，同时记录值。因为左边是第一个入队的值，所以只记这一次就可以。\r\n\r\n### 代码\r\n```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        depth: 0// 层级遍历的同时，根据返回要求，用相同depth去把同层收集起来\r\n    });\r\n    let res;\r\n    let maxDepth = -1;\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        const depth = temp.depth;\r\n        if (depth > maxDepth) {\r\n            res = temp.node.val;\r\n            maxDepth = depth;\r\n        }\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                depth: temp.depth+1\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317932792","body":"### 思路\r\n使用dfs 前序遍历\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val) {\r\n *     this.val = val;\r\n *     this.left = this.right = null;\r\n * }\r\n */\r\n\r\n/**\r\n * Encodes a tree to a single string.\r\n *\r\n * @param {TreeNode} root\r\n * @return {string}\r\n */\r\n\r\nvar serialize = function(root) {\r\n    return dfsSerialize(root, '');\r\n};\r\n\r\nfunction dfsSerialize(root, str) {\r\n    if (root === null) {\r\n        str += \"null,\";\r\n    } else {\r\n        str += root.val + \",\";\r\n        str = dfsSerialize(root.left, str);\r\n        str = dfsSerialize(root.right, str);\r\n    }\r\n    return str;\r\n}\r\n\r\n/**\r\n * Decodes your encoded data to tree.\r\n *\r\n * @param {string} data\r\n * @return {TreeNode}\r\n */\r\nvar deserialize = function(data) {\r\n    const arr = data.split(',')\r\n    return dfsDeserialize(arr);\r\n};\r\n\r\nfunction dfsDeserialize(arr) {\r\n    const node = arr.shift();\r\n    if (node === 'null') {\r\n        return null;\r\n    }\r\n\r\n    const root = new TreeNode(parseInt(node));\r\n    root.left = dfsDeserialize(arr);\r\n    root.right = dfsDeserialize(arr);\r\n    return root;\r\n}\r\n\r\n/**\r\n * Your functions will be called as such:\r\n * deserialize(serialize(root));\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319573646","body":"### 思路\r\n遍历节点，拿到坐标值，按横坐标排序，再按纵坐标排序，最后按值排序，然后遍历数组，按横坐标分组输出\r\n\r\n### 代码\r\n```javascript\r\nvar verticalTraversal = function(root) {\r\n    if (!root) return[];\r\n    const orderNode = preorderTraversal(root);\r\n    orderNode.sort((a,b) => {\r\n        if (a.x !== b.x) {\r\n            return a.x > b.x ? 1:-1 ;\r\n        }\r\n        if (a.y !== b.y) {\r\n            return a.y > b.y ? 1:-1 \r\n        }\r\n        return a.val > b.val ? 1:-1\r\n    });\r\n    if (orderNode.length === 1) return [orderNode[0].val]\r\n\r\n    let res = [];\r\n    let left = 0;\r\n    let right = 1;\r\n    orderNode.push({\r\n        val: -Infinity,\r\n        x: Infinity,\r\n        y: Infinity,\r\n    })\r\n    while(right < orderNode.length) {\r\n        if (orderNode[left].x !== orderNode[right].x) {\r\n            const arr = orderNode.slice(left, right).map(item => item.val);\r\n            res.push(arr);\r\n            left = right;\r\n            continue\r\n        }\r\n        right++;\r\n    }\r\n    return res;\r\n};\r\n\r\nvar preorderTraversal = function (root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        x:0,\r\n        y:0,\r\n    });\r\n    const res = [];\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        res.push({\r\n            val: temp.node.val,\r\n            x: temp.x,\r\n            y: temp.y,\r\n        });\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                x: temp.x-1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                x: temp.x+1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间 O(nlog(n))，排序需要O(nlogn)\r\n空间 O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320231602","body":"### 思路\r\n遍历数组，用hash存储遇到的值，如果遇到target-当前值，在hash中有，说明找到了\r\n\r\n```javascript\r\nvar twoSum = function(nums, target) {\r\n    const map = {};\r\n    for(let i=0;i<nums.length;i++) {\r\n        if (map[target-nums[i]] !== undefined) return [i, map[target-nums[i]]]\r\n        map[nums[i]] = i;\r\n    }\r\n    return []\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320920014","body":"### 思路\r\n记录每个元素出现的频率，用小顶堆选出topk，大于堆顶可入选\r\n### 代码\r\n```javascript\r\nvar topKFrequent = function(nums, k) {\r\n    // value -> count\r\n    const counts = {};\r\n    for(let i=0;i<nums.length;i++) {\r\n        if (counts[nums[i]] !== undefined) {\r\n            counts[nums[i]] += 1;\r\n        } else {\r\n            counts[nums[i]] = 1;\r\n        }\r\n    }\r\n\r\n    let queue = new MinPriorityQueue({priority: node => node.count})\r\n    for (let num in counts) {\r\n        const count = counts[num];\r\n        if (queue.size() < k) {\r\n            queue.enqueue(QElement(num, count))\r\n        } else {\r\n            if (queue.front().element.count < count) {\r\n                queue.dequeue();\r\n                queue.enqueue(QElement(num, count))\r\n            }\r\n        } \r\n    }\r\n\r\n    let result = [];\r\n    for (let i=0; i < k; ++i) {\r\n        result.push(queue.dequeue().element.val)\r\n    }\r\n    return result\r\n};\r\n\r\nfunction QElement (num, count) {\r\n    return {\r\n        val: num === undefined ? 0 : num, \r\n        count: count === undefined ? 0 : count, \r\n    }\r\n}\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：0(nlogn) n为哈希遍历，logn为堆排序\r\n空间：O(n+k)  哈希+堆","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321485975","body":"### 思路\r\n暴力解法，枚举所有点到点的距离。每个点，到其它点的距离，如果有重复的，那么这几个线段求排列组合An2的个数，最后加总\r\n\r\n### 代码\r\n```javascript\r\nvar numberOfBoomerangs = function(points) {\r\n    let res = 0;\r\n    for(let i=0;i<points.length;i++) {\r\n        const curPoint = points[i];\r\n        const disMap = {};\r\n        for(let j=0;j<points.length;j++) {\r\n            const secondPoint = points[j];\r\n            // 计算所有点的距离\r\n            const dis = (curPoint[0] - secondPoint[0]) * (curPoint[0] - secondPoint[0]) + (curPoint[1] - secondPoint[1]) * (curPoint[1] - secondPoint[1]);\r\n            // 记录距离都有什么值\r\n            disMap[dis] = disMap[dis] === undefined ? 1 : disMap[dis]+1;\r\n        }\r\n        let count = 0;\r\n        Object.values(disMap).forEach((disCount) => {\r\n            count += disCount * (disCount-1);// 值为1也可以满足\r\n        });\r\n        res += count;\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n^2) ,两层遍历\r\n空间：O(n) hash ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322937155","body":"### 思路\r\n用双指针遍历，指针之间是不重复元素，记录最长长度。hash存储遇到的值，可以判断right最新的值是否重复，如果重复，则当前字符串的判断结束，左指针向前移动并删除hash存储，直到指针间无重复，进入下一个无重复字符串区间。\r\n\r\n### 代码\r\n```javascript\r\nvar lengthOfLongestSubstring = function(s) {\r\n    if (s.length<=1) return s.length;\r\n    let left = 0;\r\n    let right = 1;\r\n    const map = new Map();\r\n    map.set(s[0], 1);\r\n    let max= 0;\r\n    while(right < s.length) {\r\n        if(map.get(s[right])) {\r\n            map.delete(s[left]);\r\n            left++;\r\n            continue;\r\n        }\r\n        map.set(s[right], 1);\r\n        right++;\r\n        max = Math.max(max, right-left);\r\n    }\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间: O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324478042","body":"### 思路\r\n把word存一个map，记录出现次数，遍历s，每次遍历，当作以当前字符为开头的，是否满足条件：每隔一个word长度判断是否存在map中且数量符合。\r\n\r\n```javascript\r\nvar findSubstring = function(s, words) {\r\n     if(!s || !words.length) return [];\r\n    const wordsCount = words.length;\r\n    const oneLen = words[0].length\r\n    const len = wordsCount * oneLen;\r\n    if (len> s.length) return [];\r\n\r\n\r\n    const wordMap = {};\r\n    for(let i=0;i<words.length;i++) {\r\n       if(wordMap[words[i]] === undefined) {\r\n            wordMap[words[i]] = 1\r\n        } else {\r\n            wordMap[words[i]] +=1;\r\n        }\r\n    }\r\n    \r\n    const res = []\r\n    for(let i=0;i<s.length;i++) {\r\n        let tempNum = 0;\r\n        const tempMap = { ...wordMap };\r\n        let j = i;\r\n        while(tempNum < wordsCount){\r\n            const str = s.substring(j, j + oneLen);\r\n            if (!tempMap[str]) break;\r\n            tempMap[str] -=1;\r\n            tempNum++;\r\n            j = j + oneLen;\r\n        }\r\n       \r\n        if (tempNum === wordsCount){\r\n            res.push(i)\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间 O(s.length*k) k=s长度/word长度遍历一次\r\n空间 O(m×n) 单词长度*单词个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325881095","body":"### 思路\r\nhash 记录取模结果，如果加和遇到相同的取模结果，则认为中间这段是符合预期的，个数取决于结果相同的个数。\r\n注意负数取模的纠正\r\n### 代码\r\n\r\n```javascript\r\nvar subarraysDivByK = function(nums, k) {\r\n    let count = 0, sum = 0;\r\n    let map = {} ;\r\n    map[0] = 1;\r\n    for (let i = 0; i < nums.length; i++) {\r\n        sum += nums[i];\r\n        const mod = (sum % k + k) % k\r\n        if (map[mod])\r\n            count += map[mod];\r\n        map[mod] = (map[mod]|| 0) + 1;\r\n    }\r\n    return count;\r\n};\r\n```\r\n### 复杂度\r\n时间 0（n）\r\n空间O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327038791","body":"### 思路\r\n快慢双指针，快指针走两步，慢指针走一步，走到头，慢指针指向中间节点\r\n\r\n### 代码\r\n```javascript\r\nvar middleNode = function(head) {\r\n    if (!head) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while (fast && fast.next) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n    return slow;\r\n};     \r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327998044","body":"### 思路\r\n快慢双指针，快指针找不重复数字，覆盖到慢指针前面，慢指针移动一位。最后不重复的都移动到了慢指针前面了。\r\n\r\n### 代码\r\n```javascript\r\nvar removeDuplicates = function(nums) {\r\n    for(var slow = 0, fast= 1; fast<nums.length; fast++){\r\n        if (nums[fast] !== nums[slow]) {\r\n            nums[++slow] = nums[fast];\r\n        }\r\n    }\r\n    return slow+1;\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间 O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328073524","body":"### 思路\r\n二分查找\r\n\r\n### 代码\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let low = 0;\r\n    let high = nums.length - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n        if (nums[mid] == target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            low = mid + 1\r\n        } else {\r\n            high = mid - 1\r\n        }\r\n    }\r\n    return low;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O（logn）\r\n空间O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328563992","body":"### 思路\r\n单调队列\r\n\r\n### 代码\r\n```javascript\r\nvar maxSlidingWindow = function(nums, k) {\r\n    const n = nums.length;\r\n    // 当前窗口最大值的index\r\n    const q = [];\r\n    // 先进入k个数字\r\n    for (let i = 0; i < k; i++) {\r\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\r\n            q.pop();\r\n        }\r\n        q.push(i);\r\n    }\r\n\r\n    const ans = [nums[q[0]]];\r\n    for (let i = k; i < n; i++) {\r\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\r\n            q.pop();\r\n        }\r\n        q.push(i);\r\n        while (q[0] <= i - k) {\r\n            // 过了窗口界限\r\n            q.shift();\r\n        }\r\n        ans.push(nums[q[0]]);\r\n    }\r\n    return ans;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329980967","body":"### 思路\r\n统计每个节点入度出度，满足条件的即为法官\r\n\r\n### 代码\r\n```javascript\r\nvar findJudge = function(n, trust) {\r\n    const giveTrust = Array(n+1).fill(0);\r\n    const gotTrust =  Array(n+1).fill(0);\r\n\r\n    for(let i=0;i<trust.length;i++) {\r\n        const one = trust[i];\r\n        gotTrust[one[1]]++;\r\n        giveTrust[one[0]]++;\r\n    }\r\n\r\n    for(let i=1;i<=n;i++) {\r\n        if (giveTrust[i] === 0 && gotTrust[i] === n-1) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331582633","body":"### 思路\r\n邻接矩阵记录不喜欢，深度遍历看是否有冲突\r\n\r\n### 代码\r\n```javascript\r\nvar possibleBipartition = function(n, dislikes) {\r\n    // 建立访问表和邻接矩阵\r\n    const color = new Array(n + 1).fill(0);\r\n    const gragh = new Array(n + 1).fill(0);\r\n    for (let i = 0; i <= n; ++i) {\r\n        gragh[i] = [];\r\n    }\r\n    for (const dislike of dislikes) {\r\n        gragh[dislike[0]].push(dislike[1]);\r\n        gragh[dislike[1]].push(dislike[0]);\r\n    }\r\n\r\n    for (let i = 1; i <= n; ++i) {\r\n        if (color[i] === 0 && hasconflictDfs(i, 1, color, gragh)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\n\r\nconst hasconflictDfs = (curnode, nowcolor, colors, gragh) => {\r\n    colors[curnode] = nowcolor;\r\n    for (const nextnode of gragh[curnode]) {\r\n        // 不喜欢被分在同一组，冲突\r\n        if (colors[nextnode] !== 0 && colors[nextnode] === colors[curnode]) {\r\n            return true;\r\n        }\r\n        if (colors[nextnode] === 0 && hasconflictDfs(nextnode, 3 ^ nowcolor, colors, gragh)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n```\r\n### 复杂度\r\n时间 O(m+n)\r\n空间O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333266085","body":"### 代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @param {number} m\r\n * @param {number[]} group\r\n * @param {number[][]} beforeItems\r\n * @return {number[]}\r\n */\r\nvar sortItems = function(n, m, group, beforeItems) {\r\n    const grahG = [], degG = new Uint16Array(n + m), idsG = [], \r\n          grahI = [], degI = new Uint16Array(n), idsI = [], r = []\r\n    for (let i = 0; i < n; i++) {\r\n        if (group[i] === -1) {\r\n            idsG[m] = m // 从组数起分配，避免重复\r\n            group[i] = m++\r\n        } else idsG[group[i]] = group[i]\r\n        if (!idsI[group[i]]) idsI[group[i]] = [] // 同组项目，放入到一起\r\n        idsI[group[i]].push(i)\r\n    }\r\n    for (let i = 0; i < n; i++) {\r\n        for (let j = 0; j < beforeItems[i].length; j++) {\r\n            const itemI = beforeItems[i][j]\r\n            if (group[i] === group[itemI]) {// 同组，收集 项目 依赖\r\n                degI[i]++\r\n                if (!grahI[itemI]) grahI[itemI] = []\r\n                grahI[itemI].push(i)\r\n            } else {// 不同组，收集 组 依赖\r\n                degG[group[i]]++\r\n                if (!grahG[group[itemI]]) grahG[group[itemI]] = []\r\n                grahG[group[itemI]].push(group[i])\r\n            }\r\n        }\r\n    }\r\n    const idsGS = tp_sort(idsG.filter(v => v !== void 0), grahG, degG) // 组排序\r\n    if (idsGS.length === 0) return []\r\n    for (let i = 0; i < idsGS.length; i++) {// 组有序，组内项目排序\r\n        if (!idsI[idsGS[i]]) continue\r\n        const idsIS = tp_sort(idsI[idsGS[i]], grahI, degI)\r\n        if (idsIS.length === 0) return []\r\n        r.push(...idsIS)\r\n    }\r\n    return r\r\n};\r\n\r\n\r\nfunction tp_sort(ids, grah, deg) {// 拓扑排序：id列表，图，入度\r\n    const q = [], r = []\r\n    for (let i = 0; i < ids.length; i++) {\r\n        if (deg[ids[i]] === 0) {\r\n            q.push(ids[i])\r\n        }\r\n    }\r\n\r\n    let start = 0\r\n    while (start < q.length) {\r\n        const n = q[start++]\r\n        r.push(n)\r\n        if (!grah[n]) continue\r\n        for (let i = 0; i < grah[n].length; i++) {\r\n            if (--deg[grah[n][i]] === 0) {\r\n                q.push(grah[n][i])\r\n            }\r\n        }\r\n    }\r\n    return r.length === ids.length ? r : []\r\n}\r\n```\r\n### 复杂度\r\n时间:O(m+n)\r\n空间:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334904978","body":"### 思路 \r\n统计走动的方向的值，相反方向相等则回回到原点\r\n\r\n### 代码\r\n```javascript\r\nvar judgeCircle = function(moves) {\r\n    let up = 0;\r\n    let down = 0;\r\n    let left = 0;\r\n    let right = 0;\r\n    for(let i=0;i<moves.length;i++) {\r\n        const move = moves[i];\r\n        switch(move) {\r\n            case 'U':\r\n                up++;\r\n                break;\r\n            case 'D':\r\n                down++;\r\n                break;\r\n            case 'L':\r\n                left++;\r\n                break;\r\n            case 'R':\r\n                right++;\r\n                break;\r\n        }\r\n    }\r\n\r\n    return up === down && left === right;\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336101394","body":"### 思路\r\n先按开始时间排序，从最早可以执行的任务开始，把可以启动的任务用优先级队列排序，优先执行时间短的，然后按下表。执行完最优先的之后，把时间推到完成的时间节点，继续检查可以执行的任务，再用优先级队列排序，执行。直到任务都完成。\r\n\r\n### 代码\r\n```javascript\r\nvar getOrder = function(tasks) {\r\n    const queue = new MinPriorityQueue()\r\n    tasks = tasks.map((task, index) => ({\r\n        index,\r\n        start: task[0],\r\n        len: task[1]\r\n    }))\r\n    tasks.sort((a, b) => b.start - a.start)// 按可加入队列时间排序\r\n    const res = []\r\n    let time = 0\r\n    while (tasks.length > 0 || !queue.isEmpty()) {\r\n        // 队列为空，且没有任务能加入队列，直接跳过时间\r\n        if (queue.isEmpty() && tasks[tasks.length-1].start > time) {\r\n            time = tasks[tasks.length-1].start\r\n        }\r\n\r\n        // 向队列中加入可执行任务\r\n        while (tasks.length > 0) {\r\n            if (tasks[tasks.length-1].start <= time) {\r\n                const task = tasks.pop()\r\n                queue.enqueue(task, task.len * 100000 + task.index)// 按时间和下标顺序排序\r\n            } else {\r\n                break\r\n            }\r\n        }\r\n\r\n        // 执行任务\r\n        const { element: task } = queue.dequeue()\r\n        time += task.len\r\n        res.push(task.index)\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度\r\n时间：O(nlogn) 优先级队列排序 和 task排序\r\n空间：O(n)优先级队列","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336325680","body":"### 思路\r\n先计算小时，返回值用小时数*4，边界值：超过24小时，h加24，如果小时相等，但分钟超过则也需要加24小时。\r\n计算分钟的差值：如果小时有距离，则用60-开始时间计算15的个数，加上结束时间15的个数。特殊情况：小时相等时，分钟按正序计算：结束减去开始+1。此时又有特殊情况，如果完全在同一个区间，则都为0；\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} loginTime\r\n * @param {string} logoutTime\r\n * @return {number}\r\n */\r\nvar numberOfRounds = function(loginTime, logoutTime) {\r\n    const start = getTime(loginTime)\r\n    const end = getTime(logoutTime)\r\n\r\n    let h = end.h - (start.h + 1);\r\n    let m = 0;\r\n    if (end.h < start.h) {\r\n        h += 24;\r\n    }\r\n    if (end.h === start.h && start.m > end.m) {\r\n        h += 24;\r\n    }\r\n    if (end.h === start.h && start.m <= end.m) {\r\n        h = 0;\r\n        m = Math.floor(end.m/15) - Math.floor(start.m/15)\r\n        if (m!==0) {\r\n            m = Math.floor(end.m/15) - Math.ceil(start.m/15)\r\n        }\r\n    } else {\r\n        m = Math.floor((60-start.m)/15) + Math.floor(end.m/15)\r\n    }\r\n\r\n    return  h*4 + m;\r\n};\r\n\r\nfunction getTime(str) {\r\n    const time = str.split(':')\r\n    return {\r\n        h: Number(time[0]),\r\n        m: Number(time[1])\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(1)\r\n空间：O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336657185","body":"### 思路\r\n统计每个字母出现的次数.遍历26个字母，统计a和b，遍历字母i 之前的字母次数和，尝试条件1：b减去这些字母出现的次数，a保留，计算变化次数，条件2相反，条件3则只计算当前字母的次数。\r\n\r\n### 代码\r\n```javascript\r\nvar minCharacters = function(a, b) {\r\n    const mapA = new Array(26).fill(0);\r\n    const mapB = new Array(26).fill(0);\r\n    for(let key in a) {\r\n        mapA[a.charCodeAt(key) - 97] ++;\r\n    }\r\n    for(let key in b) {\r\n        mapB[b.charCodeAt(key) - 97] ++;\r\n    }\r\n    let aLen = a.length;\r\n    let bLen = b.length;\r\n    let asum = 0;\r\n    let bsum = 0;\r\n    let res = Infinity;\r\n    for(let i = 0 ; i < 25 ; i ++) {\r\n        // 以字母i为分界线，计算之前的总和\r\n        asum += mapA[i];\r\n        bsum += mapB[i];\r\n        // 3种情况找最小值\r\n        res = Math.min(res, aLen-asum+bsum, bLen-bsum+asum, aLen-mapA[i] + bLen -mapB[i]);\r\n    }\r\n    // z的特殊处理\r\n    return Math.min(res, aLen+bLen-mapA[25]-mapB[25]);\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(m+n)\r\n空间O(52)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338796657","body":"### 思路\r\n快速排序\r\n\r\n### 代码\r\n```javascript\r\nvar sortArray = function(nums) {\r\n    quickSort(nums, 0, nums.length - 1);\r\n    return nums;\r\n};\r\n\r\n\r\nfunction quickSort(nums, start, end) {\r\n  if (start >= end) return;\r\n  const pivotIndex = start;\r\n  const pivot = nums[pivotIndex];\r\n  let i = start;\r\n  let j = end;\r\n  while (i <= j) {\r\n    while (nums[i] < pivot) i++;\r\n    while (nums[j] > pivot) j--;\r\n    if (i <= j) {\r\n      swap(nums, i, j);\r\n      i++;\r\n      j--;\r\n    }\r\n  }\r\n  quickSort(nums, start, j);\r\n  quickSort(nums, i, end);\r\n}\r\n\r\n\r\nfunction swap(nums, a, b) {\r\n  const temp = nums[a];\r\n  nums[a] = nums[b];\r\n  nums[b] = temp;\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间：O（nlogn）\r\n空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340295675","body":"### 思路\r\n二分查询,刚好等于或者 mid平方小于x但+1就变大了，也是目标值\r\n\r\n### 代码\r\n```javascript\r\nvar mySqrt = function(x) {\r\n    let low = 1;\r\n    let high = x;\r\n     while (low <= high) {\r\n          let mid = Math.floor((low + high) / 2);\r\n          const midSqrt = mid*mid;\r\n          if (midSqrt == x) {\r\n            return mid\r\n          } \r\n          if (midSqrt < x && (mid+1)*(mid+1) > x) {\r\n            return mid\r\n          }\r\n          if (midSqrt < x) {\r\n            low = mid + 1\r\n          } else {\r\n            high = mid - 1\r\n          }\r\n    }\r\n    return 0;\r\n};\r\n```\r\n### 复杂度\r\n时间O(logn)\r\n空间O（1）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341890197","body":"### 思路\r\n二分查找，如果是badversion，再往小试探，直到不是badversion，则最近的那个就是最早的\r\n\r\n### 代码\r\n```javascript\r\nvar solution = function(isBadVersion) {\r\n    /**\r\n     * @param {integer} n Total versions\r\n     * @return {integer} The first bad version\r\n     */\r\n    return function(n) {\r\n        let low = 0;\r\n        let high = n;\r\n        while (low <= high) {\r\n            let mid = Math.floor((low + high) / 2);\r\n            const midV = isBadVersion(mid);\r\n            if (midV) {\r\n               high = mid - 1\r\n            } else {\r\n               low = mid + 1\r\n            }\r\n        }\r\n        return low;\r\n    };\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(logn)\r\n空间O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344275853","body":"### 思路\r\n利用归并排序的过程收集翻转数。\r\n\r\n### 代码\r\n```javascript\r\nvar reversePairs = function(nums) {\r\n    let res = 0\r\n    const merge = (l, mid, r) => {\r\n// 计数\r\n        let ti = l;\r\n        let tj = mid + 1\r\n        while (ti <= mid && tj <= r) {\r\n            if (nums[ti] >  2 * nums[tj]) {\r\n                res += (mid-ti+1)\r\n                tj ++\r\n            } else {\r\n                ti ++ \r\n            }\r\n        }\r\n\r\n        // 真实排序\r\n        let tmp = new Array(r-l+1)\r\n        let i = l\r\n        let j = mid+1\r\n        let k = 0\r\n        while (i <= mid && j <= r) {\r\n            if (nums[j] < nums[i]) {\r\n                tmp[k++] = nums[j]\r\n                j++\r\n            } else {\r\n                tmp[k++] = nums[i]\r\n                i++\r\n            }\r\n        }\r\n            \r\n        while (j <= r) {\r\n            tmp[k++] = nums[j]\r\n            j++\r\n        }\r\n        while (i <= mid) {\r\n            tmp[k++] = nums[i]\r\n            i++ \r\n        }\r\n        for (i = 0; i < r-l+1; ++i) {\r\n            nums[i+l] = tmp[i]\r\n        }\r\n        return res\r\n    }\r\n    const mergeSort = (l, r) => {\r\n        if (l >= r) return\r\n        let mid = Math.floor((l + r) / 2)\r\n        mergeSort(l, mid)\r\n        mergeSort(mid+1, r)\r\n        merge(l, mid, r)\r\n    }\r\n    mergeSort(0, nums.length-1);\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(nlogn)\r\n空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345176815","body":"### 思路\r\n找到每个房子最近的左边的heater，右边的heater为左边的下一个。算出房子和两个heater的距离，选出最小加热半径。遍历所有房子。最近最左的heater可用二分查找\r\n\r\n### 代码\r\n```JavaScript\r\nvar findRadius = function(houses, heaters) {\r\n    let ans = 0;\r\n    heaters.sort((a, b) => a - b);\r\n    for (const house of houses) {\r\n        // 最近的小于house的heater\r\n        const i = search(heaters, house);\r\n        const j = i + 1;\r\n        const leftDistance = i < 0 ? Infinity : house - heaters[i];\r\n        const rightDistance = j >= heaters.length ? Infinity : heaters[j] - house;\r\n        // 左边和右边找到最近的，覆盖到就可以了\r\n        const curDistance = Math.min(leftDistance, rightDistance);\r\n        // 最大的，说明是最少需要的距离\r\n        ans = Math.max(ans, curDistance);\r\n    }\r\n    return ans;\r\n\r\n};\r\n\r\nvar search = function(nums, target) {                                    \r\n    let low = 0;\r\n    let high = nums.length - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n\r\n        if (nums[mid] <= target) {\r\n            if (mid == nums.length - 1) {\r\n                return mid;\r\n            }\r\n            if (nums[mid+1] > target) {\r\n                return mid;\r\n            }\r\n            low = mid + 1\r\n        } else {\r\n            high = mid - 1\r\n        }\r\n    }\r\n    return -1;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(nlogn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345304075","body":"### 思路\r\n满足题意的距离是在有限范围内，通过二分查找找出来。二分查找的判断标准是，在这个距离下，有k个小于等于这个距离的对儿。通过滑动窗口计算小于等于某个距离下的数对儿\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} k\r\n * @return {number}\r\n */\r\nvar smallestDistancePair = function(nums, k) {\r\n    nums.sort((a,b) => a - b);\r\n    let low = 0;\r\n    let high = nums[nums.length-1] - nums[0];\r\n    while (low <= high) {\r\n        const mid = Math.floor((high + low) / 2);\r\n        const count = getDistanceCount(nums, mid);\r\n        if (count < k) {\r\n            low = mid + 1;\r\n        } else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    return low; \r\n};\r\n\r\nfunction getDistanceCount(nums, distance) {\r\n    let l = 0;\r\n    let res = 0;\r\n    for(let i = 1;i<nums.length;i++) {\r\n        while (nums[i] - nums[l] > distance) {\r\n            l++;\r\n        }\r\n        res += i - l;\r\n    }\r\n    return res;\r\n}\r\n```\r\n### 复杂度\r\n时间：O（nlogn）二分logn，双指针logn\r\n空间：O(logn) 排序用\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345807439","body":"### 思路\r\n根据可能的值做二分查找，每个遍历到的值需满足：从左上角开始在不高于这个值的情况下，遍历到grid的右下角。\r\n\r\n### 代码\r\n```javascript\r\nvar swimInWater = function(grid) {\r\n    const nodesCount = grid.length*grid.length;\r\n    let low = 0;\r\n    let high = nodesCount - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n        if (findWhetherExistsPath(grid, mid)) {// 如果有这样一条路径的话\r\n            high = mid - 1\r\n        } else {\r\n            low = mid + 1\r\n        }\r\n    }\r\n    return low;\r\n};\r\n\r\nvar findWhetherExistsPath = function(graph, mid) {\r\n    if (graph[0][0] > mid) return false;// 一开始就大于，则不必遍历\r\n\r\n    const n = graph.length;\r\n    const visited = Array(n).fill().map(() => Array(n).fill(false))\r\n    const dfs = (i, j) => {\r\n        visited[i][j] = true\r\n        let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]\r\n        for (let k = 0; k < 4; ++k) {\r\n            let newi = i + directions[k][0]\r\n            let newj = j + directions[k][1]\r\n            if (newi >= 0 && newi < n && newj >= 0 && newj < n\r\n                && visited[newi][newj] == false && graph[newi][newj] <= mid) {\r\n                dfs(newi, newj)\r\n            }\r\n        }\r\n    }\r\n    dfs(0,0)\r\n    return visited[n-1][n-1]\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n^2logn) 二分logn，dfs：n^2\r\n空间：O（n^2） visted ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347654029","body":"### 思路\r\n滑动窗口，窗口大小为固定的k个字母，先计算第一个窗口内的值，滑动时，进入的值符合则计数+1，出去的值符合则计数-1.\r\n记录每次滑动的最大值\r\n\r\n### 代码\r\n```javascript\r\nvar maxVowels = function(s, k) {\r\n    const chs = new Set(['a', 'e', 'i', 'o', 'u']);\r\n   \r\n    let count = 0;\r\n    for(let i =0;i<k;i++) {\r\n        if (chs.has(s[i])) {\r\n            count++;\r\n        }\r\n    }\r\n\r\n    let max = count;\r\n    for(let i = k;i<s.length;i++) {\r\n        if (chs.has(s[i])) {\r\n            count++;\r\n        }\r\n        if (chs.has(s[i-k])) {\r\n            count--;\r\n        }\r\n        max = Math.max(max, count);\r\n    }\r\n\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(n)\r\n空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350422003","body":"### 思路\r\n参考官解，核心dp，用滑动窗口优化循环过程\r\n\r\n### 代码\r\n```javascript\r\nvar new21Game = function(n, k, maxPts) {\r\n    if (k == 0) {\r\n        return 1;\r\n    }\r\n    const dp = new Array(k + maxPts).fill(0);\r\n    let sum = 0;\r\n    for (let i = k; i <= n && i < k + maxPts; i++) {\r\n        dp[i] = 1;\r\n        sum += dp[i];\r\n    }\r\n\r\n    for (let i = k - 1; i >= 0; i--) {\r\n        dp[i] = sum / maxPts;\r\n        sum -= dp[i + maxPts];\r\n        sum += dp[i];\r\n    }\r\n    return dp[0];\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(wk）\r\n空间：O(w+k) w为maxPts","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352488375","body":"### 思路\r\n从头遍历每m个字母是否是异位词，通过滑动窗口遍历所有。检测方法：每个字母计数，相同长度的字符串，如果字母个数也相同，则是异位词。\r\n\r\n### 代码\r\n```javascript\r\nvar findAnagrams = function(s, p) {\r\n    const n = s.length\r\n    const m = p.length\r\n    if (m > n) {\r\n        return [] \r\n    }\r\n    const needs = new Array(26).fill(0)\r\n    for (let i = 0; i < m; ++i) {\r\n        needs[charCodeSubA(p[i])]++\r\n    }\r\n\r\n    const matched = new Array(26).fill(0)\r\n    let startp = 0\r\n    let endp = 0\r\n    const result = []\r\n    while (endp < m) {\r\n        matched[charCodeSubA(s[endp])]++\r\n        endp++ \r\n    }\r\n    if (same(needs, matched)) {\r\n        result.push(startp)\r\n    }\r\n\r\n    while (endp < n && startp < n) {\r\n        matched[charCodeSubA(s[startp])]--\r\n        matched[charCodeSubA(s[endp])]++\r\n        startp++\r\n        endp++\r\n        if (same(needs, matched)) {\r\n            result.push(startp)\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\nvar charCodeSubA = a => a.charCodeAt(0) - 'a'.charCodeAt(0)\r\n\r\nvar same = (needs, matched) => {\r\n    for (let i = 0; i < needs.length; ++i) {\r\n        if (needs[i] !== matched[i]) {\r\n            return false\r\n        } \r\n    }   \r\n    return true \r\n}\r\n```\r\n\r\n### 复杂度\r\n时间：O(n+m)\r\n空间：O(C) 26个字母","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354131837","body":"### 思路\r\n字母计数，用滑动窗口遍历字符串，只要符合条件字母，则进入窗口，一直到收集完全，记录收尾并记录最小值。之后收缩左边界，继续遍历。\r\n\r\n### 代码\r\n```javascript\r\nvar minWindow = function(s, t) {\r\n    if(t.length>s.length)return '';\r\n    const needs = {};\r\n    for(let i=0;i<t.length;i++){ // t的map\r\n        if(needs[t[i]]) {\r\n            needs[t[i]] += 1;\r\n        }else {\r\n            needs[t[i]] = 1;\r\n        }\r\n    }\r\n\r\n    let count = 0;\r\n    let left = 0;\r\n    let min = Infinity;\r\n    let head = 0;\r\n    let end = s.length-1;\r\n    for(let right = 0;right<s.length;right++){\r\n        if(needs[s[right]] !== undefined){\r\n            if (needs[s[right]]>0) {\r\n                count++;\r\n            }\r\n            needs[s[right]]--;\r\n        }\r\n        while(count === t.length){\r\n            if(right-left<min){\r\n                min = right-left;\r\n                head = left;\r\n                end = right;\r\n            }\r\n            if(needs[s[left]]!== undefined){    /* 收缩左边界 */\r\n                if( needs[s[left]]>=0){\r\n                    count--;\r\n                }\r\n                needs[s[left]]++;\r\n            }\r\n            left++;\r\n        }\r\n    }\r\n\r\n    if(min === Infinity) return '';\r\n    return s.substr(head,end-head+1)\r\n\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n+m)，s和t的长度\r\n空间：O(C) t字符集大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1355228303","body":"1423. 可获得的最大点数\r\n### 思路\r\n根据题意，需要计算左边连续m个数和，和右边k-m个数和，两边再相加的最大值。\r\n先计算从右到左，累加的值。然后从左向右遍历，测试如果m为0～k个时，左边的和，加上右边的和是多少。\r\n记录每次计算的最大值\r\n\r\n### 代码\r\n```javascript\r\nvar maxScore = function(cardPoints, k) {\r\n    // 右边和的累积\r\n    const sum = [];\r\n    for (let i = cardPoints.length-1;i >=0;i--) {\r\n        if (i === cardPoints.length-1) {\r\n            sum[i] = cardPoints[cardPoints.length-1]\r\n        } else {\r\n            sum[i] = sum[i+1] + cardPoints[i];\r\n        }\r\n    }\r\n    // 左边如果个数为0.\r\n    let max = sum[cardPoints.length- k];\r\n    let sumLeft = 0;\r\n    // 左边个数分别为1-k\r\n    for(let i=1;i<=k;i++) {\r\n        sumLeft += cardPoints[i-1];\r\n        const sumRight = i ===k ? 0 : sum[cardPoints.length- k + i];\r\n        max = Math.max(sumLeft+sumRight, max);\r\n    }\r\n\r\n    return max;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356655494","body":"### 思路\r\n列举小时可能的值，列举分钟可能的值，拼接在一起。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} turnedOn\r\n * @return {string[]}\r\n */\r\nvar readBinaryWatch = function(turnedOn) {\r\n    const res = [];\r\n    for(let i=0;i<=turnedOn;i++) {\r\n        const hour = combine([1,2,4,8],i, true);\r\n        const min = combine([1,2,4,8,16,32],turnedOn-i);\r\n        for(let h=0;h<hour.length;h++) {\r\n            for(let n=0;n<min.length;n++) {\r\n                res.push(hour[h]+':'+min[n])\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n\r\nvar combine = function(nums, k, isHour) {\r\n    if (k>nums.length) return [];\r\n\r\n    const res = [];\r\n    var combineFunc = function(count, path) {\r\n        if (path.length === k) {\r\n           const num = Number(_.sum(path));\r\n            if (isHour) {\r\n                if (num >=0 && num <= 11) {\r\n                    res.push(num);\r\n                }\r\n            } else {\r\n                if (num >=10 && num <= 59) {\r\n                    res.push(num);\r\n                }\r\n                if (num >=0 && num <= 9) {\r\n                    res.push('0'+num);\r\n                }\r\n            }\r\n            return \r\n        }\r\n        for (let i = count;i<nums.length;i++) {\r\n            path.push(nums[i]);\r\n            combineFunc(i+1, path)\r\n            path.pop();\r\n        }\r\n    }\r\n    combineFunc(0, []);\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356994158","body":"### 思路\r\n同8皇后1，遍历每个row，试探col，增加一个看看是否满足，然后再去掉。满足条件的计数+1\r\n\r\n### 代码\r\n```javascript\r\nvar totalNQueens = function(n) {\r\n    let result = 0;\r\n    let board = Array(n).fill().map(() => Array(n).fill('.'))\r\n    let backtrack = row => {\r\n        if (row == n) {\r\n            result++;\r\n            return\r\n        }\r\n        for (let col = 0; col < n; ++col) {\r\n            if (isOk(board, n, row, col)) {\r\n                board[row][col] = 'Q'\r\n                backtrack(row + 1)\r\n                board[row][col] = '.'\r\n            }\r\n        }\r\n    }\r\n    backtrack(0)\r\n    return result\r\n};\r\n\r\nlet isOk = (board, n, row, col) => {\r\n    for (let i = 0; i < n; i++) {// 检查列是否冲突\r\n        if (board[i][col] == 'Q') {\r\n            return false\r\n        }\r\n    }\r\n    let i = row - 1\r\n    let j = col + 1\r\n    while (i >= 0 && j < n) {// 检查右上对⻆线是否有冲突\r\n        if (board[i][j] == 'Q') {\r\n            return false\r\n        }\r\n        i--\r\n        j++\r\n    }\r\n    i = row - 1\r\n    j = col - 1\r\n    while (i >= 0 && j >= 0) {// 检查左上对⻆线是否有冲突\r\n        if (board[i][j] == 'Q') {\r\n            return false\r\n        }\r\n        i--\r\n        j--\r\n    }\r\n    return true\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间：O(n!)\r\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358886717","body":"### 思路\r\n找到为1的节点，深度遍历，访问过的点位计数，最后取最大。\r\n\r\n### 代码\r\n```javascript\r\nvar maxAreaOfIsland = function(grid) {\r\n    const h = grid.length\r\n    const w = grid[0].length\r\n    const visited = Array(h).fill().map(() => Array(w).fill(false))\r\n    let count = 0;\r\n    const dfs = (i, j) => {\r\n        visited[i][j] = true\r\n        let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]// 试探\r\n        for (let k = 0; k < 4; ++k) {\r\n            let newi = i + directions[k][0]\r\n            let newj = j + directions[k][1]\r\n            if (newi >= 0 && newi < h && newj >= 0 && newj < w\r\n                && visited[newi][newj] == false && grid[newi][newj] == '1') {\r\n                dfs(newi, newj)\r\n                count ++;// 访问过的+1\r\n            }\r\n        }\r\n    }\r\n\r\n    let max = 0\r\n    for (let i = 0; i < h; ++i) {\r\n        for (let j = 0; j < w; ++j) {\r\n            if (visited[i][j] != true && grid[i][j] == '1') {// 从有值的点开始dfs\r\n                count = 1;// 每次重新计数\r\n                dfs(i, j);\r\n                max = Math.max(count, max);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return max\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(w*h)\r\n空间：O(w*h)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360922152","body":"### 思路\r\n参考官方题解。计算每个格子到陆地的距离，最后从水域格子里选取最大的到陆地的距离\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[][]} grid\r\n * @return {number}\r\n */\r\nvar maxDistance = function(grid) {\r\n    const h = grid.length\r\n    const w = grid[0].length\r\n\r\n    const arr = [];\r\n    // 记录到陆地的距离\r\n    const dp = Array(h).fill().map(() => Array(w).fill(Infinity))\r\n    for (let i = 0; i < h; ++i) {\r\n        for (let j = 0; j < w; ++j) {\r\n            if (grid[i][j] == 1) {\r\n                arr.push([i, j]);\r\n                dp[i][j] = 0;// 陆地到陆地距离为0\r\n            }  \r\n        }\r\n    }\r\n\r\n     while (arr.length) {\r\n        const value = arr.pop()\r\n        let directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]// 试探\r\n        for (let k = 0; k < 4; ++k) {\r\n            let newi = value[0] + directions[k][0]\r\n            let newj = value[1] + directions[k][1]\r\n            if (newi >= 0 && newi < h && newj >= 0 && newj < w\r\n                && dp[newi][newj] > dp[value[0]][value[1]] + 1) {// 没有访问过，加入队列\r\n               dp[newi][newj] = dp[value[0]][value[1]] + 1; // 访问过了，+1：水域\r\n               arr.push([newi,newj]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    let res = -1;\r\n    for (let i = 0; i < h; ++i) {\r\n        for (let j = 0; j < w; ++j) {\r\n            if (grid[i][j] == 0 && dp[i][j] !== Infinity) { // 水域到陆地\r\n               res = Math.max(res, dp[i][j]);\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间O(n^2)\r\n空间O （N^2）\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362946608","body":"参考官方解答\r\n### 代码\r\n```javascript\r\nfunction solve(graph, target){\r\n    const arr = [target];\r\n    const visited = new Set();\r\n    let steps = 0;\r\n    while (arr.length) {\r\n        const value = arr.pop()\r\n        visited.add(value)\r\n        for(let neighbor in graph[value]){\r\n            if (!visited.has(neighbor)) {\r\n                arr.push(neighbor)\r\n            } else if(neighbor === target) {\r\n                return steps + 1 \r\n            }\r\n        }\r\n        steps += 1\r\n    }\r\n    return -1;\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363756237","body":"### 思路\r\n遍历节点，拿到坐标值，按横坐标排序，再按纵坐标排序，最后按值排序，然后遍历数组，按横坐标分组输出\r\n\r\n### 代码\r\n```javascript\r\nvar verticalTraversal = function(root) {\r\n    if (!root) return[];\r\n    const orderNode = preorderTraversal(root);\r\n    orderNode.sort((a,b) => {\r\n        if (a.x !== b.x) {\r\n            return a.x > b.x ? 1:-1 ;\r\n        }\r\n        if (a.y !== b.y) {\r\n            return a.y > b.y ? 1:-1 \r\n        }\r\n        return a.val > b.val ? 1:-1\r\n    });\r\n    if (orderNode.length === 1) return [orderNode[0].val]\r\n\r\n    let res = [];\r\n    let left = 0;\r\n    let right = 1;\r\n    orderNode.push({\r\n        val: -Infinity,\r\n        x: Infinity,\r\n        y: Infinity,\r\n    })\r\n    while(right < orderNode.length) {\r\n        if (orderNode[left].x !== orderNode[right].x) {\r\n            const arr = orderNode.slice(left, right).map(item => item.val);\r\n            res.push(arr);\r\n            left = right;\r\n            continue\r\n        }\r\n        right++;\r\n    }\r\n    return res;\r\n};\r\n\r\nvar preorderTraversal = function (root) {\r\n    if (root == null) return [];\r\n    const arr = [];\r\n    arr.push({\r\n        node: root,\r\n        x:0,\r\n        y:0,\r\n    });\r\n    const res = [];\r\n    while (arr.length != 0) {\r\n        var temp = arr.shift();\r\n        res.push({\r\n            val: temp.node.val,\r\n            x: temp.x,\r\n            y: temp.y,\r\n        });\r\n        if (temp.node.left) {\r\n            arr.push({\r\n                node: temp.node.left,\r\n                x: temp.x-1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n        if (temp.node.right) {\r\n            arr.push({\r\n                node: temp.node.right,\r\n                x: temp.x+1,\r\n                y: temp.y+1,\r\n            });\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间 O(nlog(n))，排序需要O(nlogn)\r\n空间 O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364109834","body":"### 思路\r\n动态规划爬楼梯，dp[i] = Math.min(dp[i-1] , dp[i-2])\r\n\r\n### 代码\r\n```javascript\r\nvar minCostClimbingStairs = function(cost) {\r\n    const n = cost.length;\r\n    if (n<2) return cost[0];\r\n\r\n    const dp = [];\r\n    dp[0] = 0;\r\n    dp[1] = 0;// 从第一节楼梯开始，不需要花钱\r\n    for(let i = 2; i<=n;i++) {\r\n        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])\r\n    }\r\n    return dp[n];\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：O（n）\r\n空间：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364607993","body":"### 思路\r\n动态规划，状态转移方程：二维状态表记录当前index，偷和不偷两种情况，所能得到的最大金额\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {number}\r\n */\r\nvar rob = function(nums) {\r\n    let n = nums.length\r\n    if (n == 0) {\r\n        return 0 \r\n    }\r\n    const dp = Array(n).fill(0).map(() => Array(2).fill(0))\r\n    dp[0][0] = 0;// 不偷\r\n    dp[0][1] = nums[0];// 偷\r\n    for (let i=1;i<nums.length;i++) {\r\n        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1]);// 上一个偷不偷都可以\r\n        dp[i][1] = dp[i-1][0]+nums[i];// 上一个不能偷\r\n    }\r\n\r\n    return Math.max(dp[n-1][0], dp[n-1][1]);\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(n) 可优化为O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364948075","body":"### 思路\r\n递推公式：dp[i] = 最长的长度的个数,在过程中，补充计数\r\n\r\n### 代码\r\n```javascript\r\nvar findNumberOfLIS = function(nums) {\r\n    const n = nums.length\r\n    const dp = new Array(n).fill(0)\r\n    const cnt = new Array(n).fill(0);\r\n    let res = 0;\r\n    let maxLen = 0;\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n        dp[i] = 1;// 代表到目前为止最长的长度\r\n        cnt[i] = 1;// 最长的长度的个数\r\n        for (let j = 0; j < i; ++j) {\r\n            if (nums[i] > nums[j]) {\r\n                if (dp[j] + 1 > dp[i]) {\r\n                    dp[i] = dp[j] + 1;\r\n                    cnt[i] = cnt[j]; // 之前序列个数更多，且因为所有都满足，所以把计数复制过来\r\n                } else if (dp[j] + 1 === dp[i]) {\r\n                    cnt[i] += cnt[j];// 序列个数一边多，补充计数\r\n                }\r\n            }\r\n        }\r\n        if (dp[i] > maxLen) {\r\n            maxLen = dp[i];\r\n            res = cnt[i];\r\n        } else if (dp[i] === maxLen) {\r\n            res += cnt[i];\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n^2)\r\n空间：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365565145","body":"#### 思路\r\ndp[i][j] 表示⻓度为i的t1子串和⻓度是j的t2子串的最⻓公共子序列⻓度 。递推公式：如果两个字母相等，则是上一个dp[i-1][j-1]+1，如果不相等，则取三种可能性最大的。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} text1\r\n * @param {string} text2\r\n * @return {number}\r\n */\r\nvar longestCommonSubsequence = function(text1, text2) {\r\n    const n = text1.length\r\n    const m = text2.length\r\n    // dp[i][j]表示⻓度为i的t1子串和⻓度是j的t2子串的最⻓公共子序列⻓度 \r\n    const dp = new Array(n+1).fill().map(() => new Array(m+1).fill(0));\r\n\r\n    for (let i = 1;i<=n; i++) {\r\n        for (let j = 1;j<=m;j++) {\r\n            if (text1[i-1] === text2[j-1]) {\r\n                dp[i][j] = dp[i-1][j-1] + 1;\r\n            } else {\r\n                // 3种可能\r\n                dp[i][j] = Math.max(dp[i-1][j] , dp[i][j-1], dp[i-1][j-1]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return dp[n][m];\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(nm)\r\n空间：O(nm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366323428","body":"### 思路\r\n   状态转移方程：(i,j)这个位置只有可能通过(i-1,j)和(i,j-1)两个位置过来。边界的地方可以通过一个位置过来\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} m\r\n * @param {number} n\r\n * @return {number}\r\n */\r\nvar uniquePaths = function(m, n) {\r\n    const dp = Array(m).fill().map(() => Array(n).fill(0))\r\n    for (let i = 0; i<m; i++) {\r\n        for (let j = 0; j<n; j++) {\r\n           if ( i== 0 || j== 0 ) {\r\n                dp[i][j] = 1;\r\n           } else {\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1]\r\n           }\r\n        } \r\n    }\r\n    return dp[m-1][n-1]\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(nm)\r\n空间O(nm)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367090394","body":"### 思路\r\n参考官方解答，每个格子计算出现概率，然后相加。出现概率是之前一步的八分之一，没走一次，测算一次全部格子的概率，累加\r\n\r\n### 代码\r\n```javascript\r\nvar knightProbability = function(n, k, row, column) {\r\n    const direction = [[-1, -2], [1, -2], [2, -1], [2, 1], [1, 2], [-1, 2], [-2, 1], [-2, -1]];\r\n    let dp = Array(n).fill().map(() => Array(n).fill(0));\r\n    dp[row][column] = 1;\r\n\r\n    for(let x=0;x<k; x++) {\r\n        const tempDp = Array(n).fill().map(() => Array(n).fill(0));\r\n        for(let i=0;i<n;i++) {\r\n            for(let j=0;j<n;j++) {\r\n                for (let k = 0; k < 8; ++k) {\r\n                    const newi = i + direction[k][0];\r\n                    const newj = j + direction[k][1];\r\n                    if (newi >= 0 && newi < n && newj >= 0 && newj < n) {\r\n                        tempDp[i][j] += dp[newi][newj] * 0.125;// 叠加之前的概率\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        dp = [...tempDp];\r\n    }\r\n\r\n    // 累积所有格子的概率\r\n    let res = 0;\r\n    for(let i=0;i<n;i++) {\r\n        for(let j=0;j<n;j++) {\r\n            res += dp[i][j]\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间:O(n^2*k*8)\r\n空间O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367947356","body":"### 思路\r\n复制官方题解..\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxChoosableInteger\r\n * @param {number} desiredTotal\r\n * @return {boolean}\r\n */\r\nvar canIWin = function (maxChoosableInteger, desiredTotal) {\r\n  // 如果可选值大于目标值，说明可以选一个大于的数字，直接获胜\r\n  if (maxChoosableInteger >= desiredTotal) return true;\r\n\r\n  // 全部拿完也无法到达\r\n  var sum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\r\n  if (desiredTotal > sum) return false;\r\n\r\n  // 记忆化\r\n  var dp = {};\r\n\r\n  /**\r\n   * @param {number} total 剩余的目标值\r\n   * @param {number} state 使用二进制位表示抽过的状态\r\n   */\r\n  function f(total, state) {\r\n    // 有缓存\r\n    if (dp[state] !== undefined) return dp[state];\r\n\r\n    for (var i = 1; i <= maxChoosableInteger; i++) {\r\n      var curr = 1 << i;\r\n      // 已经抽过这个数\r\n      if (curr & state) continue;\r\n      // 直接获胜\r\n      if (i >= total) return (dp[state] = true);\r\n      // 如果对方输，则自己赢\r\n      if (!f(total - i, state | curr)) return (dp[state] = true);\r\n    }\r\n\r\n    // 没有任何让对方输的方法\r\n    return (dp[state] = false);\r\n  }\r\n\r\n  return f(desiredTotal, 0);\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(2^n *n)\r\n空间：O(2^n )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368182149","body":"### 思路\r\n求合取一半设置为目标值，题目转化为哪些数组合等于目标值。\r\n状态转移方程：第i个数字决策完成之后，和为target这种状态是否成立\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @return {boolean}\r\n */\r\nvar canPartition = function(nums) {\r\n    const sum = _.sum(nums);\r\n    if (sum%2 === 1) {\r\n        return false\r\n    }\r\n\r\n    const target = sum/2;\r\n    const n = nums.length;\r\n    // 数组元素和目标和的一个大表格\r\n    // 每个值的含义是：第i个数字决策完成之后，和为target这种状态是否成立\r\n    const dp = Array(n).fill().map(() => Array(target+1).fill(false))   \r\n    dp[0][0] = true;\r\n    // 初始值\r\n    if (nums[0] <= target) {\r\n        dp[0][nums[0]] = true\r\n    }\r\n        \r\n    for(let i =1 ;i<n;i++) {\r\n        for(let j =0 ;j<=target;j++) {\r\n            if (j >= nums[i]) {\r\n                // 选还是不选\r\n                dp[i][j] = dp[i-1][j-nums[i]] || dp[i-1][j];\r\n            } else {\r\n                // 不选\r\n                dp[i][j] = dp[i-1][j];\r\n            }\r\n        }\r\n    }\r\n    return dp[n-1][target];// 返回第n个元素，和为target的状态\r\n};\r\n\r\n```\r\n### 复杂度\r\n时间：O(n*target)\r\n空间：O(n*target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368367985","body":"### 思路\r\n题目转化为哪些值目标和为target，target所有负值和，转化为0-1背包的计数问题：状态方程记录每阶段可达重量对应的装法个数。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} nums\r\n * @param {number} target\r\n * @return {number}\r\n */\r\nvar findTargetSumWays = function(nums, target) {\r\n    const sum = _.sum(nums);\r\n    if (sum< target) return 0;\r\n    const diff = sum -  target; // a +b == sum; a-b===target\r\n    if (diff % 2 !== 0) {\r\n        return 0;\r\n    }\r\n    target = diff/2;\r\n\r\n    // 相当于取哪几个数，总和为len：0-1背包问题\r\n    // 记录每阶段可达重量对应的装法个数。\r\n    const n = nums.length;\r\n    const dp = Array(n+1).fill().map(() => Array(target+1).fill(0));\r\n    dp[0][0] = 1;//target 为0，有1条路径，起始值\r\n\r\n    for(let i=1; i<=n; ++i){ //动态规划状态转移\r\n        for (let j=0; j<= target; ++j) {\r\n            if (j-nums[i-1]<0){// 判断是否有效，防止下面的方程不成立\r\n                dp[i][j]=dp[i-1][j];\r\n            } else {\r\n                dp[i][j]=dp[i-1][j]+dp[i-1][j-nums[i-1]];\r\n            }\r\n        }\r\n    }\r\n\r\n    return dp[n][target];\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n*(sum−target))\r\n空间：O(n*(sum−target))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368668899","body":"### 思路\r\n完全背包问题，最少需要多少物品的最值问题，状态转移方程: dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j-weight[i]] + 1 )\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} coins\r\n * @param {number} amount\r\n * @return {number}\r\n */\r\nvar coinChange = function(coins, amount) {\r\n    // 完全背包问题，最少需要多少物品的最值问题\r\n    const n = coins.length\r\n    // dp的值为最少硬币个数\r\n    const dp = Array(n).fill().map(() => Array(amount+1).fill(Number.MAX_SAFE_INTEGER));\r\n    // 如果只有1种硬币\r\n    for (let c = 0; c <= Math.floor(amount/coins[0]); ++c) {\r\n        dp[0][c*coins[0]] = c\r\n    }\r\n\r\n    for (let i = 1; i < n; ++i) {\r\n        for (let j = 0; j <= amount; ++j) {\r\n            let k = Math.floor(j/coins[i])\r\n            for (let c = 0; c <= k; ++c) {\r\n                const last = dp[i-1][j-c*coins[i]];\r\n                 if (last + c < dp[i][j] && last !== Number.MAX_SAFE_INTEGER) {\r\n                    dp[i][j] = last + c\r\n                }\r\n            }\r\n        }\r\n    }    \r\n\r\n    const res = dp[n-1][amount];\r\n    return res === Number.MAX_SAFE_INTEGER ? -1 : res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n*amount*k)\r\n空间：O(n*amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369838604","body":"### 思路\r\n完全背包问题，计数问题。对比零钱兑换1，初始化值为1，dp[i][j] = dp[i-1][j-c*coins[i]] \r\n\r\n### 代码\r\n```javascript\r\nvar change = function(amount, coins) {\r\n   let n = coins.length\r\n    let dp = Array(n).fill().map(() => Array(amount+1).fill(0))\r\n    for (let c = 0; c <= Math.floor(amount/coins[0]); ++c) {\r\n        dp[0][c*coins[0]] = 1\r\n    }\r\n    for (let i = 1; i < n; ++i) {\r\n        for (let j = 0; j <= amount; ++j) {\r\n            let k = Math.floor(j/coins[i])\r\n            for (let c = 0; c <= k; ++c) {\r\n                dp[i][j] += dp[i-1][j-c*coins[i]]// 加总所有可能性\r\n            } \r\n        }\r\n    }\r\n    return dp[n-1][amount]\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n*amount*k)\r\n空间：O(n*amount)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1371027330","body":"### 思路\r\n先排序，遍历孩子，匹配饼干\r\n\r\n### 代码\r\n```javascript\r\nvar findContentChildren = function(g, s) {\r\n    g.sort((a,b) => a - b);\r\n    s.sort((a,b) => a - b);\r\n\r\n    let res = 0;\r\n    let sIndex = 0;\r\n    for (let i =0;i<g.length;i++) {\r\n        for (let j = sIndex;j<s.length;j++) {\r\n            if (g[i] <= s[j]) {\r\n                sIndex = j + 1;\r\n                res ++;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间O(mlogm+nlogn) 排序开销\r\n空间：O(logm+logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372291354","body":"### 思路\r\n贪心\r\n\r\n### 代码\r\n```javascript\r\nvar eraseOverlapIntervals = function(intervals) {\r\n    if (!intervals.length) {\r\n        return 0;\r\n    }\r\n    intervals.sort((a, b) => a[1] - b[1]);\r\n\r\n    const n = intervals.length;\r\n    let right = intervals[0][1];\r\n    let res = 1;\r\n    for (let i = 1; i < n; ++i) {\r\n        if (intervals[i][0] >= right) { // 不重叠\r\n            ++res;//则选中它\r\n            right = intervals[i][1];\r\n        }\r\n    }\r\n    return n - res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间 O（n logn）排序\r\n空间 O（n logn）排序\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373618285","body":"###思路\r\n排序人，最大和最小配对，如果小于limit就算一个船，不行则最大自己算一个。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} people\r\n * @param {number} limit\r\n * @return {number}\r\n */\r\nvar numRescueBoats = function(people, limit) {\r\n    people.sort((a,b) => a-b);\r\n\r\n    let res = 0;\r\n    let right = people.length-1;\r\n    let left = 0;\r\n    while(left <=right) {\r\n        if (people[right] + people[left] <= limit) {\r\n            left ++;\r\n        }\r\n        res++;\r\n        right--;\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(nlong) 排序\r\n空间：O(nlong) 排序","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374368254","body":"### 思路\r\n顶点有n种可能，左边子树要比i小，右边要大，可能性为（i -1）* （n- i）\r\n\r\n### 代码\r\n```javascript\r\nvar numTrees = function(n) {\r\n    const map = {\r\n        0: 1,\r\n        1: 1,\r\n    };\r\n    var count = (n) => {\r\n        if (map[n]) return map[n];\r\n        let res = 0\r\n        for (let i = 1; i<= n; i++) {\r\n            res += count(i - 1) * count(n - i)\r\n        }\r\n        map[n] = res;\r\n        return res\r\n    }\r\n\r\n    return count(n)\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n^2)\r\n空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374727766","body":"### 思路\r\n分治，俩俩合并，最后合成一个。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode[]} lists\r\n * @return {ListNode}\r\n */\r\nvar mergeKLists = function(lists) {\r\n    if(!lists.length) return null;\r\n    return helper(lists, 0, lists.length - 1)\r\n};\r\n\r\nfunction helper(lists, left, right) {\r\n    if (left >= right) {\r\n        return lists[left]\r\n    }\r\n    const mid = Math.floor((left + right) / 2)\r\n    const l1 = helper(lists, left, mid)\r\n    const l2 = helper(lists, mid + 1, right)\r\n    return mergeTwoLists(l1, l2)\r\n}\r\nfunction mergeTwoLists (l1, l2) {\r\n    let prehead = new ListNode(-1);\r\n\r\n    let prev = prehead;\r\n    while (l1 != null && l2 != null) {\r\n        if (l1.val <= l2.val) {\r\n            prev.next = l1;\r\n            l1 = l1.next;\r\n        } else {\r\n            prev.next = l2;\r\n            l2 = l2.next;\r\n        }\r\n        prev = prev.next;\r\n    }\r\n    prev.next = l1 == null ? l2 : l1;\r\n    return prehead.next;\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间：O(kn*logk)\r\n空间 ：O（logk）栈空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375627856","body":"### 思路\r\n参考官方解答.从最小扩展到最大\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} n\r\n * @return {number[]}\r\n */\r\nvar beautifulArray = function (n) {\r\n  let arr = [];\r\n  arr.push(1);\r\n  while (arr.length < n) {\r\n    let tmp = [];\r\n    for (const i of arr) {\r\n        if (i * 2 - 1 <= n) {\r\n            tmp.push(i * 2 - 1)\r\n        }\r\n    };\r\n    for (const i of arr) {\r\n        if (i * 2 <= n) {\r\n            tmp.push(i * 2);\r\n        }\r\n    }\r\n    arr = tmp;\r\n  }\r\n\r\n  return arr;\r\n};\r\n```\r\n### 复杂度\r\n时间：O(nlogn)\r\n空间：O(n + logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377003781","body":"### 思路\r\n异或一次，求两数之异或。结果sum再和负sum取与，求出差异点，然后所有数通过和这个差异点与运算，相同的数字会变成1，结果会是与差异点相同和不同的两个数。\r\n### 代码\r\n ```javascript\r\nvar singleNumber = function(nums) {\r\n    let xorsum = 0;\r\n    \r\n    for (const num of nums) {\r\n        xorsum ^= num;\r\n    }\r\n    let type1 = 0, type2 = 0;\r\n    // 取出 xorsum 的二进制表示中最低位那个 1\r\n    // 说明该位上，一个数是1，另一个是0\r\n    const lsb = xorsum & (-xorsum);\r\n    for (const num of nums) {\r\n        if (num & lsb) {// 是1的一起异或，最后剩下是1的数\r\n            type1 ^= num;\r\n        } else {\r\n            type2 ^= num;\r\n        }\r\n    }\r\n    return [type1, type2];\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378662498","body":"### 思路\r\n每个数字都有两种状态，所以有 2^n 个解，把每个解都转换成二进制。找到为1的位，找到对应的num组成一个组合。\r\n\r\n### 代码\r\n```javascript\r\nvar subsets = function(nums) {\r\n    const generateOne = (s, nums) => {\r\n        // s 代表一种可能\r\n        // 要找出为1的那几个数\r\n        const arr = [];\r\n        let idx = nums.length-1;\r\n        // 求出每一位\r\n        while(s) {\r\n            if (s & 1) {// 最后一位为1\r\n                arr.unshift(nums[idx])// 加入\r\n            }\r\n            idx--;\r\n            s >>= 1;// 挪动一位\r\n        }\r\n        return arr;\r\n    }\r\n\r\n    let res = [];\r\n    let n = nums.length;\r\n    for (let i = 0; i < 2 ** n; i++) {\r\n        res.push(generateOne(i, nums));\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：O(N∗2^n)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380562968","body":"### 思路\r\n实现一个字典树\r\n\r\n### 代码\r\n```javascript\r\n\r\nvar TrieNode = function(data) {\r\n    this.data = data\r\n    this.isEnding = false\r\n    this.children = new Array(26)\r\n}\r\n\r\n\r\nvar Trie = function() {\r\n    this.root = new TrieNode('/')\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {void}\r\n */\r\nTrie.prototype.insert = function(word) {\r\n    let p = this.root\r\n    for (let c of word) {\r\n        let index = asciiDiff(c, 'a')\r\n        if (p.children[index] == null) {\r\n            p.children[index] = new TrieNode(c)\r\n        }\r\n        p = p.children[index]\r\n    }\r\n    p.isEnding = true\r\n};\r\n\r\n/** \r\n * @param {string} word\r\n * @return {boolean}\r\n */\r\nTrie.prototype.search = function(word) {\r\n    let p = this.root\r\n    for (let c of word) {\r\n        let index = asciiDiff(c, 'a')\r\n        if (p.children[index] == null) {\r\n            return false\r\n        }\r\n        p = p.children[index]\r\n    }\r\n    return p.isEnding\r\n};\r\n\r\n/** \r\n * @param {string} prefix\r\n * @return {boolean}\r\n */\r\nTrie.prototype.startsWith = function(prefix) {\r\nlet p = this.root\r\n    for (let c of prefix) {\r\n        let index = asciiDiff(c, 'a')\r\n        if (p.children[index] == null) {\r\n            return false\r\n        }\r\n        p = p.children[index]\r\n    }\r\n    return true\r\n};\r\n\r\nvar asciiDiff = (a,b) => {\r\n    return a.charCodeAt(0) - b.charCodeAt(0);\r\n}\r\n\r\n/**\r\n * Your Trie object will be instantiated and called as such:\r\n * var obj = new Trie()\r\n * obj.insert(word)\r\n * var param_2 = obj.search(word)\r\n * var param_3 = obj.startsWith(prefix)\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间：O(1)\r\n空间：O（word.length⋅26）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381333300","body":"### 思路\r\n哈希记录key-val，再记录一个前缀的key-val，val为sum，每插入一个字符串，把所有可能前缀都找出来一起更新最新值。\r\n\r\n### 代码\r\n ```javascript\r\nvar MapSum = function() {\r\n    this.map = new Map();\r\n    this.prefixmap = new Map();\r\n};\r\n\r\n/** \r\n * @param {string} key \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nMapSum.prototype.insert = function(key, val) {\r\n    const oldVal = this.map.get(key) ?? 0;\r\n    this.map.set(key, val);\r\n    for (let i = 1; i <= key.length; ++i) {\r\n        const currprefix = key.substring(0, i);\r\n        const updateVal = (this.prefixmap.get(currprefix) ?? 0) - oldVal + val;\r\n        this.prefixmap.set(currprefix, updateVal);\r\n    }\r\n};\r\n\r\n/** \r\n * @param {string} prefix\r\n * @return {number}\r\n */\r\nMapSum.prototype.sum = function(prefix) {\r\n    return this.prefixmap.get(prefix) ?? 0;\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间：O(n2)\r\n空间：O)(kn)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382706937","body":"### 思路\r\ntrie树\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} big\r\n * @param {string[]} smalls\r\n * @return {number[][]}\r\n */\r\n\r\nfunction TrieNode (data) {\r\n    this.data = data\r\n    this.smallIdx = -1;\r\n    this.children = {}\r\n}\r\n\r\nvar multiSearch = function(big, smalls) {\r\n    const res = smalls.map(() => [])\r\n    if (!big) {\r\n        return res\r\n    }\r\n    const Tree = new TrieNode('/');\r\n    let cur;\r\n    smalls.forEach((small, index) => {\r\n        cur = Tree;\r\n        for (let i = 0; i < small.length; i++) {\r\n            if (!cur.children[small[i]]) {\r\n                cur.children[small[i]] = new TrieNode(small[i])\r\n            }\r\n            cur = cur.children[small[i]]\r\n        }\r\n        cur.smallIdx = index\r\n    });\r\n\r\n    for (let i = 0; i < big.length; i++) {\r\n        let cur = Tree;\r\n        for (let j = i; j < big.length; j++) {\r\n            if (!cur.children[big[j]]) {\r\n                break\r\n            }\r\n            cur = cur.children[big[j]]\r\n            if (cur.smallIdx !== -1) {\r\n                res[cur.smallIdx].push(i)\r\n            }\r\n        }\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间 O(N^2) \r\n空间 O(S) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383079229","body":"### 思路\r\n并查集\r\n\r\n### 代码\r\n ```javascript\r\n/**\r\n * @param {number[][]} isConnected\r\n * @return {number}\r\n */\r\nvar findCircleNum = function(isConnected) {\r\n    const n = isConnected.length;\r\n    const parent = new Array(n);\r\n    for (let i = 0; i < parent.length; i++) {\r\n       parent[i] = -1;\r\n    }\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        for (var j = 0; j < n; j++) {\r\n            if (isConnected[i][j] == 1 && i != j) {\r\n                union(parent, i, j);\r\n            }\r\n        }\r\n    }\r\n\r\n    var count = 0;\r\n    for (let i = 0; i < parent.length; i++) {\r\n        // 统计独立省份\r\n        if (parent[i] == -1) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\nfunction find(parent, i) {\r\n    if (parent[i] == -1) {\r\n        return i;\r\n    }\r\n    return find(parent, parent[i]);\r\n}\r\n\r\nfunction union(parent, x, y) {\r\n    const xset = find(parent, x);\r\n    const yset = find(parent, y);\r\n    if (xset != yset) {\r\n        parent[xset] = yset;// x指向y\r\n    }\r\n}\r\n   \r\n```\r\n\r\n### 复杂度\r\n时间O（logn*N^2）\r\n空间O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298085446","body":"## 思路\n\n- 将k对应位数加到num上，并对大于10的位数继续进位\n- 出现num.length<k.length情况，对num进行扩充相加，直到k=0\n\n## 代码\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int flag = 0;\n        for(int i = 0; i < num.size() ; i++){\n            num[i] += (k % 10);\n            k /= 10;\n            if(num[i] >= 10){\n                num[i] -= 10;\n                if(i != (num.size()-1)){\n                    num[i+1]++;\n                }else{\n                    flag = 1;\n                    num.push_back(1);\n                    break;\n                }\n            }\n        }\n\n        while(k){\n            if(flag){\n                flag = 0;\n                num[num.size()-1] += (k % 10);\n                if(num[num.size()-1] >= 10){\n                    num[num.size()-1] -= 10;\n                    flag = 1;\n                    num.push_back(1);\n                }\n            }else{\n                num.push_back(k % 10);\n            }\n            k /= 10;\n        } \n        \n        reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299515911","body":"## 思路\n\n-  找出string中c出现的索引，存入book\n-  遍历s和book，计算所有可能的距离，将最小距离存入answer\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size(), 0), book;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == c)\n                book.push_back(i);\n        }\n        for(int i = 0; i < s.size(); i++){\n            int min = 10000;\n            for(int j = 0; j < book.size(); j++){\n                int dis = abs(i - book[j]);\n                if(min > dis)\n                    min = dis;\n            }\n            answer[i] = min;\n        }\n        return answer;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301911303","body":"## 思路\n\n将栈看作数组，对数组进行增加、删除、遍历\n\n## 代码\n\nC++ Code:\n\n```c++\nclass CustomStack {\nprivate:\n    int maxSize;\n    vector<int>st;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;        \n    }\n    \n    void push(int x) {\n        if(st.size() < maxSize)\n            st.push_back(x);\n    }\n    \n    int pop() {\n        if(!st.empty()){\n            int tp = st[st.size()-1];\n            st.pop_back();\n            return tp;\n        }else\n            return -1;\n    }\n    \n    void increment(int k, int val) {\n        if (st.size() < k){\n            for(vector<int>::iterator it = st.begin(); it != st.end(); it++)\n                (*it) += val; \n        }else{\n            for(vector<int>::iterator it = st.begin(); it < (st.begin() + k); it++)\n                (*it) += val; \n        }\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k)$\n- 空间复杂度：$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303248570","body":"## 思路\n\n1. 使用栈st存储pair( ]前字母，]前数字 )\n2. 遍历s，如果是字母，存入nowStr；如果是数字，存入nowNum；如果是'['，将(nowStr, nowNum)入栈，并清空nowStr和nowNum；如果是']'，说明已经找到一个完整的子串可以用来表示总长度，此时nowStr存储的是[]里字符串，此时栈顶元素出栈，atoi(st.back().second.c_str())是nowStr出现次数，st.back().first是这个出现多次的字符串前的字符串，将展开后的子串存入nowStr即为当前已经展开一次的串。\n3. 遍历结束，返回结果nowStr\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<pair<string, string>>st;\n        string nowStr, nowNum;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= 'a' && s[i] <= 'z'){\n                nowStr += s[i];\n            }else if(s[i] >= '0' && s[i] <= '9'){\n                nowNum += s[i];\n            }else if(s[i] == '['){\n                st.push_back(make_pair(nowStr, nowNum));\n                nowStr.clear();\n                nowNum.clear();\n            }else{\n                string tmp;\n                for(int j = 0; j < atoi(st.back().second.c_str()); j++)\n                    tmp += nowStr;\n                nowStr =  st.back().first + tmp;\n                st.pop_back();     \n            }\n        }\n        return nowStr;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304448576","body":"**思路**\n\n用两个栈st1, st2记录，st1记录队列push后正序，st2记录pop和peek时队列逆序用来找到队列首部元素，每次pop和peek后要将st1恢复到当前队列情况，st2清空\n\n**代码**\n\nC++ Code:\n\n```c++\nclass MyQueue {\nprivate:\n    stack<int> st1, st2; //st1正序 st2逆序\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {        \n        st1.push(x);       \n    }\n    \n    int pop() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        st2.pop();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    int peek() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    bool empty() {\n        if(st1.empty())\n            return true;\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为栈长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304782127","body":"## 思路\n\n1. 排序前每个子块和排序后中对应位置的子块中数的出现次数是一样的，用哈希表diff来记录排序前后对应子块出现频次的差值\n2. 遍历数组，当差值为0时，说明该数字在这个子块中出现频率相同，从哈希表中删除这个key，直到diff为空时，说明两个子块出现的数字是一样的，可以分块，res++\n3. 遍历结束，返回res\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int res;\n        unordered_map<int, int>diff;\n        vector<int>arr_sort = arr;\n        sort(arr_sort.begin(), arr_sort.end());\n        for(int i = 0; i < arr_sort.size(); i++){\n            int x = arr[i], y = arr_sort[i];\n            diff[x]++;\n            if(diff[x] == 0)\n                diff.erase(x);\n            diff[y]--;\n            if(diff[y] == 0)\n                diff.erase(y);\n            if(diff.empty())\n                res++;           \n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305425538","body":"## 思路\n\n1. 遍历链表，得到结点总数count（这时要注意当只有一个节点或者链表为空或者k为0时，直接返回头结点）\n2. 遍历链表，找到断开的位置count-k % count\n3. 更新头结点和尾节点，返回头结点\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(k == 0 || head == nullptr || head->next == nullptr)\n            return head;   \n        \n        int count = 1;\n        ListNode* cur = head;\n        while(cur->next != nullptr){\n            cur = cur->next;\n            count++;\n        }\n        int nodeNum = k % count;\n        \n        if(nodeNum == 0)\n            return head;\n        \n        cur->next = head;\n        for(int i = 0; i < (count - nodeNum); i++){\n            cur = cur->next;\n        }\n        head = cur->next;\n        cur->next = nullptr;\n        return head;\n\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点个数。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307325316","body":"## 思路\n\n1. 链表为空或者只有一个节点，返回head\n2. 每两个节点为一组，first为第一个节点，second为第二个节点，两个节点交换，交换后两个节点顺序为second和first，当first->next != nullptr && first->next->next != nullptr时，循环继续。(要注意的是链表存在奇数节点和偶数节点，交换次数是一样的，因此循环结束条件为是否还存在两个节点)\n3. 循环结束，返回head\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr)\n            return head;\n        \n        ListNode* first = head;\n        ListNode* second = head->next;\n        ListNode* cur = first;\n        int k = 1;             \n  \n        do{\n            if(k < 1){\n                first = first->next;\n                second = first->next;\n                cur->next = second;\n                cur = first;         \n            }\n            first->next = second->next;\n            second->next = cur;\n            if (k-- > 0)\n                head = second;\n        }while(first->next != nullptr && first->next->next != nullptr);\n        return head;\n\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为节点数。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308642286","body":"## 思路\n\n获取当前链表的中点，以链表中点为根，中点左边的值都小于它,可以构造左子树，同理构造右子树，递归上述过程\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    \n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\n        if(head == tail) return nullptr;\n        \n        ListNode* fast = head;\n        ListNode* slow = head;\n        while(fast != tail && fast->next != tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        \n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n\n        return root;\n    }\n\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(logn)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309806671","body":"## 思路\n\n当A和B相交时，从链表A和链表B头结点出发走过路径一样长。当A走到尾结点，则从headB开始；当B走到尾结点，则从headA开始。当A和B均为空时，说明不相交。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *A = headA;\n        ListNode *B = headB;\n\n        while(A != B){\n            A = A->next;\n            B = B->next;\n            if(A == nullptr && B == nullptr)\n                return nullptr;\n            if(A == nullptr)\n                A = headB;\n            if(B == nullptr)\n                B = headA;            \n        }\n        return A;\n\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311391413","body":"## 思路\n\n创建哈希表，依次遍历每个结点加入哈希表中，当发现哈希表中存在该结点，则该结点为环的入口，否则遍历结束返回null\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n       ListNode *cur = head;\n        set<ListNode*>st;\n        while(cur != nullptr){\n            if(st.find(cur) != st.end())\n                return cur;\n            st.insert(cur);\n            cur = cur->next;           \n        }\n        return nullptr;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312414670","body":"## 思路\n\n- 使用双向链表+哈希表\n- 每次在链表尾部加入新的结点，将最新访问的结点移到链表头部，哈希表中存key和结点\n- 构造函数\n  - 初始化虚拟头尾结点\n  - 链表最大容量\n  - 构造一个空哈希表\n- get\n  - 如果key在哈希表中存在，则返回该结点value，并将该结点移到链表头部\n  - key不存在，则返回-1\n- put\n  - 如果key在哈希表中存在，则更新该结点的value，并将该结点移到链表头部\n  - key不存在\n    - 如果结点数为最大容量，则删除尾结点，并删除尾结点在哈希表中值\n    - 将key和value存入新结点，将该结点移到链表头部，并存入哈希表中\n\n## 代码\n\nC++ Code:\n\n```c++\nclass DListNode {\npublic:\n    int key;\n    int value;\n    DListNode* pre;\n    DListNode* next;\n    DListNode() : key(-1), value(-1), pre(nullptr), next(nullptr) {};\n    DListNode(int k, int v) : key(k), value(v), pre(nullptr), next(nullptr) {};\n};\n\n\nclass LRUCache {\nprivate:\n    int capacity;\n    DListNode* dummy_head;\n    DListNode* dummy_tail;\n    unordered_map<int, DListNode*>mp;\n\npublic:\n    LRUCache(int capacity) {\n        this->capacity = capacity;\n        this->dummy_head = new DListNode();\n        this->dummy_tail = new DListNode();\n        this->dummy_head->next = this->dummy_tail;\n        this->dummy_tail->pre = this->dummy_head;\n    }\n\n    int get(int key) {\n        if (mp.count(key) > 0) {\n            DListNode* cur = mp[key];\n             //移除当前结点\n             cur->pre->next = cur->next;\n             cur->next->pre = cur->pre;\n             //将结点移到头部\n             DListNode* head = dummy_head->next;\n             dummy_head->next = cur;\n             cur->pre = dummy_head;\n             head->pre = cur;\n             cur->next = head;            \n            return (mp[key])->value;\n        }\n        else\n            return -1;\n    }\n\n    void put(int key, int value) {\n        if (mp.count(key) > 0) {\n            DListNode* cur = mp[key];\n            cur->value = value;\n            //移除当前结点\n            cur->pre->next = cur->next;\n            cur->next->pre = cur->pre;\n            //将结点移到头部\n            DListNode* head = dummy_head->next;\n            dummy_head->next = cur;\n            cur->pre = dummy_head;\n            head->pre = cur;\n            cur->next = head;\n        }\n        else {\n            if (mp.size() == capacity) {\n                //移除尾结点\n                DListNode* tail = dummy_tail->pre;\n                dummy_tail->pre = tail->pre;\n                tail->pre->next = dummy_tail;\n                tail->pre = tail->next = nullptr;\n                //删掉哈希表中key\n                mp.erase(tail->key);\n            }\n            DListNode* head = dummy_head->next;\n            DListNode* new_node = new DListNode(key, value);\n            //加到头部\n            dummy_head->next = new_node;\n            new_node->pre = dummy_head;\n            head->pre = new_node;\n            new_node->next = head;\n            //加入哈希表\n            mp.insert(make_pair(key, new_node));\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312678570","body":"## 思路\n\n-  用标记层的BFS\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        queue<TreeNode*> dq;\n        int depth = 0;\n        dq.push(root);\n        while(dq.size()){\n            int length = dq.size();\n            for(int i = 0; i < length; i++){\n                TreeNode* curNode = dq.front();\n                dq.pop();\n                if(curNode->left != nullptr)\n                    dq.push(curNode->left);\n                if(curNode->right != nullptr)\n                    dq.push(curNode->right);\n            }\n            depth++;\n        }\n        \n        return depth;\n    }\n};\n\n```\n\n**复杂度分析**\n\nn为结点个数\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313111628","body":"## 思路\n\n对两棵树同时做先序遍历，对每个p、q进行判断，当p、p均为空时，返回true；当p或者q有个一个为空时，返回false；当p->val != q->val时，返回false；当p->val == q->val时，对其左右结点重复上述过程。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        return preorder(p, q);\n    }\n\n    bool preorder(TreeNode* p, TreeNode* q){\n        if(p == nullptr && q == nullptr)\n            return true;\n        if(!p)\n            return false;\n        if(!q)\n            return false;\n\n        if(p->val != q->val)\n            return false;\n        else{\n            bool l = preorder(p->left, q->left);\n            bool r = preorder(p->right, q->right);\n            return l && r;\n        }        \n    }\n};\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314812049","body":"## 思路\n\ndfs，用stack记录搜索的当前路径，当为叶子结点时，计算当前路径长度，\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        stack<TreeNode*> path; \n        return dfs(root, path);\n    }\n    \n    int dfs(TreeNode* root, stack<TreeNode*> &path){        \n        if(!root) return 0;     \n        path.push(root);\n        if(!root->left && !root->right){\n            stack<TreeNode*> cur = path;\n            path.pop();\n            int sum = 0;\n            int size = cur.size();\n            for(int i = 0; i < size; i++){\n                sum += (cur.top()->val * pow(10, i));\n                cur.pop();\n            }\n            return sum;   \n        }\n\n        int l = dfs(root->left, path);\n        int r = dfs(root->right, path);\n        path.pop();\n\n        return l + r;\n        \n    }\n\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，n为结点数\n- 空间复杂度：$O(h)$，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316407509","body":"## 思路\n\nBFS，记录每层最左元素，遍历结束，记录的为最后一层最左元素值\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        return BFS(root);\n    }\n\n    int BFS(TreeNode* root){\n        int value = 0;\n        queue<TreeNode*>qe;\n        qe.push(root);\n        while(!qe.empty()){\n            int length = qe.size();\n            value = qe.front()->val;\n            for(int i = 0; i < length; i++){\n                TreeNode*cur = qe.front();\n                qe.pop();     \n                if(cur->left)\n                    qe.push(cur->left);\n                if(cur->right)\n                    qe.push(cur->right);                           \n            }\n        }\n        return value;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318269547","body":"## 思路\n\n-  BFS\n-  serialize()是注意将null加入string，结点用.分割\n-  deserialize()分为两部分\n   -  从序列化后的string中得到结点数组Nodes\n   -  分别找到父节点和其左右结点，判断是子结点是否为空，不为空则构建父节点和子节点关系，并将子节点入队列（每次父节点移动+1，子节点移动+2）\n   -  重复2，直到父节点走到末尾\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        string res;\n        queue<TreeNode*>qe;\n        qe.push(root);\n        while(!qe.empty()){\n            TreeNode*cur = qe.front();\n            qe.pop();\n            if(cur){\n                res += (to_string(cur->val) + \",\");\n                qe.push(cur->left);\n                qe.push(cur->right);\n            }else\n                res += \"#,\";\n        }\n        return res.substr(0, res.size()-1);\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        if(data == \"#\") return nullptr;\n        \n        vector<string>nodes;\n        while(data.find(\",\") != string::npos){\n            int pos = data.find(\",\");\n            int remainSize = data.size() - pos - 1;\n            nodes.push_back(data.substr(0, pos));\n            data = data.substr(pos + 1, remainSize);\n        }\n        nodes.push_back(data);\n        \n        TreeNode* root = new TreeNode(atoi(nodes[0].c_str()));\n        queue<TreeNode*>q; \n        q.push(root);\n        int index = 1;\n        while(index < nodes.size()){\n            TreeNode*cur = q.front(); //父节点指针移动+1\n            q.pop();\n            string leftval = nodes[index];\n            string rightval = nodes[index+1];\n\n            if(leftval != \"#\"){\n                TreeNode*leftNode = new TreeNode(atoi(leftval.c_str()));\n                cur->left = leftNode;\n                q.push(leftNode);\n            }\n            \n            if(rightval != \"#\"){\n                TreeNode*rightNode = new TreeNode(atoi(rightval.c_str()));\n                cur->right = rightNode;\n                q.push(rightNode);\n            }\n            index += 2; //子节点指针移动+2\n        }\n\n        return root;\n    }\n};\n\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$，n为结点个数\n- 空间复杂度：$O(Q)$，Q为序列化后结点个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1321725145","body":"## 思路\n\n1. 对树做搜索，记录每个结点的(col, row, root->val)\n2. 对结点进行排序\n3. 遍历结点，按照列，存入vector<vector<int>> res\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    \n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<tuple<int, int, int>> nodes;\n        dfs(root, nodes, 0, 0);\n        sort(nodes.begin(), nodes.end());\n        vector<vector<int>> res;\n        int last_col = 2000;\n        for(const auto& [col, row, val]: nodes){\n            if(last_col != col){\n                last_col = col;\n                res.emplace_back();\n            }\n            res.back().emplace_back(val);\n        }\n        return res;\n    }\n\n    void dfs(TreeNode* root, vector<tuple<int, int, int>>& nodes, int row, int col){\n        if(!root) return;\n        nodes.push_back(make_tuple(col, row, root->val));\n        dfs(root->left, nodes, row+1, col-1);\n        dfs(root->right, nodes, row+1, col+1);\n    }\n\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321045836","body":"## 思路\n\n遍历\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int>res;\n        for(int i = 0; i < (nums.size() - 1); i++){\n            for(int j = i + 1; j < nums.size(); j++){\n                if(target == (nums[i] + nums[j])){\n                    res.push_back(i);\n                    res.push_back(j);\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n^2)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321068678","body":"## 思路\n\n哈希表+小顶堆\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    class mycomparison {\n    public:\n        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {\n            return lhs.second > rhs.second;\n        }\n    };\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> map; \n        for (int i = 0; i < nums.size(); i++) {\n            map[nums[i]]++;\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;\n\n        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {\n            pri_que.push(*it);\n            if (pri_que.size() > k) { \n                pri_que.pop();\n            }\n        }\n\n        vector<int> result(k);\n        for (int i = k - 1; i >= 0; i--) {\n            result[i] = pri_que.top().first;\n            pri_que.pop();\n        }\n        return result;\n\n    }\n};\n\n\n```\n\n\n**复杂度分析**\n\n- 时间复杂度：$O(nlogk)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321551058","body":"## 思路\n\n-  对于每一个点i，到i距离相等的点是有一定的。对每一个点，用哈希表存储到该点相同距离点的个数，(key, value)=(距离, 点的个数)。之后对每个i，相同距离做排列，之后求和。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res = 0;\n        for (const auto& point: points){\n            unordered_map<int, int>dist_num;            \n            for(const auto& p: points){\n                int dist = (point[0] - p[0]) * (point[0] - p[0]) + (point[1] - p[1]) * (point[1] - p[1]);\n                dist_num[dist]++;\n            }\n            for(const auto& count: dist_num){\n                res += (count.second) * (count.second - 1);\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323257064","body":"## 思路\n\n哈希表+滑动窗口（哈希表记录每个字母最近一次出现的位置）\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, int>hashMap;\n        int maxSub = 0, l = 0, r = 0;\n        while(r < s.size()){\n            if(hashMap.count(s[r])>0){\n                int last_pos = hashMap[s[r]];\n                if(last_pos >= l && last_pos <= r)\n                    l = last_pos + 1;\n            }            \n            maxSub = max(maxSub, r-l+1);\n            hashMap[s[r]] = r;\n            r++;\n        }\n        return maxSub;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(S)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324707923","body":"## 思路\n\n-  哈希表hashMap存储words中字符串出现次数\n-  遍历s，取长度为word_num * word_length的子串，遍历该子串，取长度为word_length的串，将其出现次数存入哈希表temp。如果该串是串联子串，temp和hashMap的值相同，否则进入下一循环。\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        unordered_map<string, int>hashMap;\n        int word_num = words.size(), word_length = words[0].size(), s_length = s.size();\n        vector<int>res;\n        \n        for(const auto& word: words)\n            hashMap[word]++;\n        \n        for(int i = 0; i < (s_length-word_num*word_length+1); i++){\n            unordered_map<string, int>temp;\n            string cur = s.substr(i,  word_num * word_length);\n\n            int j = 0;\n            for(; j < cur.size(); j += word_length){\n                string str = cur.substr(j, word_length);\n                if(!hashMap.count(str)) break;\n                temp[str]++;\n                if(temp[str] > hashMap[str]) break;\n            }\n\n            if(j == cur.size())\n                res.push_back(i);\n        }\n\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\n\n- 时间复杂度：$O(n*m*k)$\n- 空间复杂度：$O(m)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326159967","body":"## 思路\n\n-  前缀和+哈希表\n-  遍历数组，计算数组的前缀和，将前缀和 mod k的值做为key，统计出现次数做为value\n-  遍历哈希表，对每一个key的值，排列组合\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(min(n, k))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327018666","body":"## 思路\n\n- 快慢指针\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while(fast && fast->next){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return slow;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328000921","body":"```\n\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int read = 0, write = 0;\n        while(read < nums.size()){\n            if(nums[read] != nums[write]){ \n                write++;\n                nums[write] = nums[read];\n            }\n            read++;\n        }\n        return write + 1;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328192247","body":"## 思路\n\n- 双指针+二分查找\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size()-1;\n        while(l <= r){\n            int mid = (l + r) / 2;\n            if(nums[mid] == target) return mid;\n            if(nums[mid] < target){\n                l = mid + 1;\n            }else{\n                r = mid - 1;\n            }\n        }\n        return l;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328643484","body":"## 思路\n\n-  单调递减队列q.front()为当前窗口最大值\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        vector<int>res;\n        deque<int>q; //存储nums索引,单调递减队列\n        for(int i = 0; i < nums.size(); i++){\n            //队列非空，且q.front()不在滑动窗口内\n            if(!q.empty() && (i - k + 1) > q.front()){\n                q.pop_front();\n            }\n\t\t\t//队列非空，且nums[i] > nums[q.back()]，删除队列中小于当前元素的值，保证队列递减\n            while(!q.empty() && nums[i] > nums[q.back()]){\n                q.pop_back();\n            }\n            //索引入队\n            q.push_back(i);\n\t\t\t//保存每个窗口最大值\n            if((i - k + 1) >= 0){\n                res.push_back(nums[q.front()]);\n            }\n\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(k)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330485481","body":"## 思路\n\n-  找出度为0，入度为n-1的结点\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int>in_degree(n+1, 0);\n        vector<int>out_degree(n+1, 0);\n        \n        for(const auto& tr: trust){\n            in_degree[tr[1]]++;\n            out_degree[tr[0]]++;\n        }\n\n        for(int i = 1; i <= n; i++){\n            if(in_degree[i] == (n - 1) && out_degree[i] == 0)\n                return i;\n        }\n        return -1;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332192246","body":"## 思路\n\n-  图+染色法+DFS\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>Graph(n);\n        vector<int>colors(n, 0); //0:未分组; 1:group1; -1:group2\n        \n        //构建邻接表\n        for(const auto& dis: dislikes){\n            Graph[dis[0]-1].push_back(dis[1]-1);\n            Graph[dis[1]-1].push_back(dis[0]-1);\n        }\n\n        //遍历每个人尝试分组\n        for(int i = 0; i < n; i++){\n            if(colors[i] == 0 && DFS(i, 1, Graph, colors))\n                return false;\n        }\n        return true;\n    }\n\n    //判断每个人是否和不喜欢的人分为一组\n    bool DFS(int cur, int color, vector<vector<int>>& G, vector<int>& C){\n        C[cur] = color;\n\n        //遍历cur不喜欢的人尝试分为另一组\n        for(const auto& dislike: G[cur]){\n            if(C[dislike] == 0 && DFS(dislike, -color, G, C))\n                return true;\n            if(C[dislike] == color)\n                return true;\n        }\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(V+E)$，V为图的顶点，E为图的边\n- 空间复杂度：$O(V+E)$，V为图的顶点，E为图的边","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334954653","body":"## 思路\n\n-  模拟\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for(const auto& str: moves){\n            if(str == 'R')  x++;\n            if(str == 'L')  x--;\n            if(str == 'U')  y++;\n            if(str == 'D')  y--;\n        }\n        return (x==0)&&(y==0) ;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340996989","body":"## 思路\n\n-  二分中寻找最右边的满足条件的值\n-  注意：int会越界，x=0的算数平方根为0，left从1开始\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long long left = 1, right = x, mid;\n        while(left <= right){\n            mid = (left + right) / 2;\n            if((x / mid) < mid) right = mid - 1;\n            else if((x / mid) > mid) left = mid + 1;\n            else return mid;\n        }\n        return right;\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350382617","body":"## 思路\n\ndp\n\n## 思路\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        vector<double> dp(k + maxPts);\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        dp[k - 1] = 1.0 * min(n - k + 1, maxPts) / maxPts;\n        for (int i = k - 2; i >= 0; i--) {\n            dp[i] = dp[i + 1] - (dp[i + maxPts + 1] - dp[i + 1]) / maxPts;\n        }\n        return dp[0];\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(min(n,k+maxPts))$\n- 空间复杂度：$O(k+\\textit{maxPts})$","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358978110","body":"```c++\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.size(); ++i) {\n            for (int j = 0; j != grid[0].size(); ++j) {\n                int cur = 0;\n                queue<int> queuei;\n                queue<int> queuej;\n                queuei.push(i);\n                queuej.push(j);\n                while (!queuei.empty()) {\n                    int cur_i = queuei.front(), cur_j = queuej.front();\n                    queuei.pop();\n                    queuej.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int di[4] = {0, 0, 1, -1};\n                    int dj[4] = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        queuei.push(next_i);\n                        queuej.push(next_j);\n                    }\n                }\n                ans = max(ans, cur);\n            }\n        }\n        return ans;\n    }\n};\n\n\n```\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365567807","body":"## 思路\n\n动态规划\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m = text1.length(), n = text2.length();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.at(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.at(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(mn)$\n- 空间复杂度：$O(mn)$","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369714889","body":"```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1);\n        dp[0] = 1;\n        for (int& coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n};\n\n\n\n```\n\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377281286","body":"```\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        int xorsum = 0;\n        for (int num: nums) {\n            xorsum ^= num;\n        }\n        \n        int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int num: nums) {\n            if (num & lsb) {\n                type1 ^= num;\n            }\n            else {\n                type2 ^= num;\n            }\n        }\n        return {type1, type2};\n    }\n};\n\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298094032","body":"# Leetcode 989\r\n\r\n## 思路\r\n- 数组和k从LSB开始计算，直到其中数组和k有一个到头；计算携带carry进位，当计算超过10时取余，carry取1传给下次计算；\r\n- 计算出来的值通过vec的insert函数进行头插；\r\n- 当有一个到头时，对另一个数据继续进行上述处理，直到它也到头；\r\n- 单独处理最后到头的情况。\r\n\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res_vec;\r\n        int length = num.size();\r\n        int i(1);\r\n        int carry = 0;\r\n        //第一步，计算\r\n        while((k/10 || k%10) && i<=length){\r\n            int tmp = num[length-i] + k%10 + carry;\r\n            if(tmp/10) {tmp %= 10; carry = 1;}\r\n            else carry = 0;\r\n            \r\n            res_vec.insert(res_vec.begin(), tmp);\r\n            \r\n            ++i;\r\n            k /= 10;\r\n        }\r\n        \r\n        //第二步；对剩余元素处理\r\n        if(i<=length)\r\n            while(i<=length){\r\n                int tmp = num[length-i] + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                ++i;\r\n            }\r\n        else if(k/10 || k%10)\r\n            while(k/10 || k%10){\r\n                int tmp = k%10 + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                k /= 10;\r\n            }\r\n        \r\n        \r\n        if(carry)\r\n            res_vec.insert(res_vec.begin(), 1);\r\n        \r\n        return res_vec;\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299482657","body":"# Leetcode 821\r\n\r\n## 思路\r\n基于多中心点的病毒扩散模型：将给定字符所在位置作为中心点，以此扩散边界元素，保留最小值，遇到另一个中心立刻停止扩散。也即一维的图遍历过程。\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res_vec(s.length(),10000);\r\n        vector<int> vec_slf;\r\n        //记录该字符的位置\r\n        for(int i(0); i < s.length(); ++i){\r\n            if(s[i] == c) res_vec[i] = 0;\r\n            vec_slf.insert(vec_slf.end(), i);\r\n        }\r\n        \r\n        for(auto slf: vec_slf){\r\n            int i(slf-1);\r\n            while(i >= 0) {\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i+1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                i--;\r\n            }\r\n            i = slf+1;\r\n            while(i < res_vec.size()){\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i-1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                ++i;\r\n            }\r\n        }\r\n        \r\n        return res_vec;            \r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301651250","body":"# 1381\r\n\r\n## 思路\r\n偷懒用vector实现，用arr配合index指示栈顶也可以做\r\n\r\n## 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        _maxSize = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(_vec_stk.size() < _maxSize)\r\n            _vec_stk.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(!_vec_stk.size()) return -1;\r\n        else {\r\n            int tmp = _vec_stk[_vec_stk.size() -1];\r\n            _vec_stk.pop_back();\r\n            return tmp;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(_vec_stk.size()){\r\n            int i(0);\r\n            for(auto &n: _vec_stk){\r\n                n += val;\r\n                i++;\r\n                if(i == k) break;\r\n            }\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> _vec_stk;\r\n    int _maxSize;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303164435","body":"# 394 \r\n暂时没做出来，C++的string用得不是很习惯\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res_str;\r\n        string tmp_str;\r\n        stack <int> stk;\r\n        int i(0);\r\n        int n(0);\r\n        //int k(0), count(0);\r\n        while(i < s.length()){\r\n            if((s[i]-'0' >= 0) && (s[i]-'0' <= 9)) stk.push(s[i++]);\r\n            else if(s[i] == '[') {\r\n                stk.push(s[i++]);\r\n                n++;\r\n            }\r\n            else if(s[i] == ']') {\r\n                string tmp;\r\n                while(stk.top() != '['){\r\n                    //tmp \r\n                    string tmp3;\r\n                    tmp3 += stk.top();\r\n                    tmp.insert(0, tmp3);\r\n                    stk.pop();\r\n                }\r\n                tmp_str.insert(0, tmp);\r\n                //cout << tmp_str << endl;\r\n                stk.pop();\r\n                n--;\r\n                int k(0), count(0);\r\n                while(!stk.empty() && (stk.top()-'0' >= 0) && (stk.top()-'0' <= 9)){\r\n                    int tmpn = stk.top() -'0';\r\n                    k += tmpn*pow(10,count++);\r\n                    stk.pop();\r\n                }\r\n                string tmp2(tmp_str);\r\n                k--;\r\n                while(k){\r\n                    tmp_str += tmp2;\r\n                    k--;\r\n                }\r\n                if(!n) {\r\n                    res_str.append(tmp_str);\r\n                    tmp_str.clear();\r\n                }\r\n\r\n                ++i;\r\n            }\r\n            else {\r\n                if (stk.empty()) res_str += s[i++];\r\n                else stk.push(s[i++]);\r\n            }\r\n\r\n        }\r\n\r\n        return res_str;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298123259","body":"### 思路\n\n1. num list化成int\n2. 加上k\n3. 转为list\n\n### 代码\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # if num == [0] and k == 0: return [0] \n        # x = 0\n        # out = []\n        # for i in num:\n        #     x = x*10 + i \n        # x += k\n        # while x > 0:\n        #     out.append(x % 10)\n        #     x //= 10\n        # return out[::-1]\n        return [int(a) for a in str(int(''.join(map(str,num)))+k)]\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299628742","body":"### 思路\n\n1. 从左遍历记录与最近 c的距离\n2. 从右遍历，顺便用min取最短距离\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size(), pos = -n;\n        vector<int> res(n,n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; i--) {\n            if (s[i] == c) pos = i;\n            res[i] = min(res[i], pos - i);\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302324672","body":"### 思路 \n\n...\n\n### 代码\n\n```C++\nclass CustomStack {\n    vector<int> stack;\n    int n;\npublic:\n    CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() == n) return;\n        if (stack.size() < n) stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int x=stack.back();\n        stack.pop_back();\n        return x;\n    }\n    \n    void increment(int k, int val) {\n        int x=k;\n        if(stack.size()<k)\n            x=stack.size();\n        for(int i=0;i<x;i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303028763","body":"### 思路 \n\n用stack存储，四个cases\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_string = \"\"\n        k = 0\n\n        for char in s:\n            if char == \"[\":\n                # Just finished parsing this k, save current string and k for when we pop\n                stack.append((current_string, k))\n                # Reset current_string and k for this new frame\n                current_string = \"\"\n                k = 0\n            elif char == \"]\":\n                # We have completed this frame, get the last current_string and k from when the frame \n                # opened, which is the k we need to duplicate the current current_string by\n                last_string, last_k = stack.pop(-1)\n                current_string = last_string + last_k * current_string\n            elif char.isdigit():\n                k = k * 10 + int(char)\n            else:\n                current_string += char\n\n        return current_string\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304419378","body":"### 思路 \n\npop encoding\n\n### 代码\n\n```c++\nclass MyQueue {\n    public:\n        stack<int> s1, s2;\n        MyQueue() {        }\n\n        void push(int x) {\n            s1.push(x);\n//             // Move all elements from s1 to s2\n//             while (!s1.empty()) {\n//                 s2.push(s1.top());\n//                 s1.pop();       \n//             }           \n\n//             // Push the item to s1\n//             s1.push(x); \n\n//             // Push all elements in s2 back to s1\n//             while (!s2.empty()){\n//                 s1.push(s2.top());\n//                 s2.pop();       \n//             } \n        }\n\n        int pop() {\n            if (s1.empty() && s2.empty()) {\n                cout << \"empty queue\" << endl;\n                exit(0);                                                                  }\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();           \n                }                       \n            }\n            int temp = s2.top();\n            s2.pop();\n            return temp;\n            // // pop out the top element in s1\n            // if (s1.empty()) {\n            //     cout << \"error\" << endl;\n            //     exit(0);        \n            // }           \n            // int temp = s1.top();\n            // s1.pop();\n            // return temp;\n        }\n\n        int peek() {\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();\n                }\n            }\n            return s2.top();\n            // if (s1.empty()) {\n            //     cout << \"empty queue\" << endl;\n            //     exit(0);        \n            // }           \n            // return s1.top();\n        }\n\n        bool empty() {\n            return s1.empty() && s2.empty();\n            // return s1.empty();\n        }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304727109","body":"### 思路 \n\nusing stack to store the max item for potential blocks, return the length of the stack in the end\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i,a in enumerate(arr):\n            maxi = a\n            while s and s[-1] > a:\n                maxi = max(maxi,s.pop())\n            s.append(maxi)\n        return len(s)\n```\n\n### 复杂度\n\nO(n) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305134751","body":"### 思路 \n\nCheck length -> the the # of rotation -> make as a loop -> traverse -> disconnect \n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n      \n      #check the length\n        lastNode, length = head, 1\n        while lastNode.next:\n            lastNode = lastNode.next\n            length += 1\n\n        # check the number of rotation\n        k = k % length\n\n      # setlast node point to the first node\n        lastNode.next = head\n\n      #traverse until (length - k) node\n        temp = head\n        for i in range(length - k - 1): temp = temp.next\n\n      #disconnect the first and last node\n        out = temp.next\n        temp.next = None\n\n        return out\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306756244","body":"``` python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        pre, pre.next = self, head\r\n        while pre.next and pre.next.next:\r\n            a = pre.next\r\n            b = a.next\r\n            pre.next, b.next, a.next = b, a, b.next\r\n            pre = a\r\n        return self.next\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307967276","body":"### 思路 \n\nDivide and conquer\n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head: return None\n        if not head.next: return TreeNode(head.val)\n\n        pre, slow, fast = None, head, head\n\n        # find the middle node of the linked list\n        while fast and fast.next:\n            pre = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        if pre: pre.next = None\n\n        root = TreeNode(slow.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n### 复杂度\n\nO(nlogn) / O(long)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309864117","body":"### 思路 \n\n最后的指针走相同长度可以判断有没有重叠，没有的话同时为none\n\n### 代码\n\n```python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\n        p, q = headA, headB\n        while p != q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p\n```\n\n### 复杂度\n\nO(n+m) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311375729","body":"### 思路 \n\n1. 快慢指针走，如果相遇则是在环上，没有则是没有交点\n2. 从头走head继续走slow，之后的再次相遇就是在交点\n\n### 代码\n\n```python\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break\n        else:\n            return None\n        while head != slow:\n            slow = slow.next\n            head = head.next\n        return head\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312415686","body":"### 思路 \n\n使用ordereddic， get记得更新查询的元素，set如果cap满了pop出第一个（最旧的\n\n### 代码\n\n```python\nclass LRUCache:\n\n    def __init__(self, capacity):\n        self.dic = collections.OrderedDict()\n        self.remain = capacity\n\n    def get(self, key):\n        if key not in self.dic:\n            return -1\n        v = self.dic.pop(key) \n        self.dic[key] = v   # set key as the newest one\n        return v\n\n    def put(self, key, value):\n        if key in self.dic:    \n            self.dic.pop(key)\n        else:\n            if self.remain > 0:\n                self.remain -= 1  \n            else:  # self.dic is full\n                self.dic.popitem(last=False) \n        self.dic[key] = value\n```\n\n### 复杂度\n\nO(1) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312607223","body":"### 思路 \n\n递归。从底层向上返\n\n### 代码\n\n```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312821721","body":"### 思路 \r\n\r\nBFS or recursion\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        # BFS\r\n        # queue = [(p, q)]\r\n        # while queue:\r\n        #     node1, node2 = queue.pop(0)\r\n        #     if not node1 and not node2: # no child\r\n        #         continue\r\n        #     elif None in [node1, node2]:\r\n        #         return False\r\n        #     else:\r\n        #         if node1.val != node2.val:\r\n        #             return False\r\n        #         queue.append((node1.left, node2.left))\r\n        #         queue.append((node1.right, node2.right))\r\n        # return True\r\n\r\n        #DFS\r\n        if not p and not q: return True\r\n        if not p or not q: return False\r\n        return p.val == q.val and self.isSameTree(q.left, p.left) and self.isSameTree(q.right, p.right)\r\n```\r\n\r\n### 复杂度\r\n\r\nO(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314921240","body":"### 思路 \n\n...\n\n### 代码\n\n```python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        p = {root: root.val}\n        c = dict()\n        res = 0\n        while p:\n            for node, number in p.items():\n                if node.left:\n                    c[node.left] = number*10 + node.left.val\n                if node.right:\n                    c[node.right] = number*10 + node.right.val\n                if not node.left and not node.right:\n                    res += number\n            p = c\n            c = dict()\n        return res\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315904603","body":"### 思路\n\nDFS 储存每一level的节点 最后返回最后一行最左的节点\n\n### 代码\n\n```python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        res = []\n        self.dfs(root, res, 0)\n        return res[-1][0]\n    \n    def dfs(self, root, res, level):\n        if not root: return\n        if level == len(res): res.append([])\n        res[level].append(root.val)\n        self.dfs(root.left, res, level + 1)\n        self.dfs(root.right, res, level + 1)\n```\n\n### 复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317974492","body":"### 思路\n\n抄个答案\n\n### 代码\n\n```python\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def rserialize(root, string):\n            \"\"\" a recursive helper function for the serialize() function.\"\"\"\n            # check base case\n            if root is None:\n                string += 'None,'\n            else:\n                string += str(root.val) + ','\n                string = rserialize(root.left, string)\n                string = rserialize(root.right, string)\n            return string\n        \n        return rserialize(root, '')\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        def rdeserialize(l):\n            \"\"\" a recursive helper function for deserialization.\"\"\"\n            if l[0] == 'None':\n                l.pop(0)\n                return None\n                \n            root = TreeNode(l[0])\n            l.pop(0)\n            root.left = rdeserialize(l)\n            root.right = rdeserialize(l)\n            return root\n\n        data_list = data.split(',')\n        root = rdeserialize(data_list)\n        return root\n```\n\n### 复杂度\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319515275","body":"### 思路\n\n以root为idx0，左右坐标+-1 w/ BFS\n\n### 代码\n\n```python\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        g = collections.defaultdict(list) \n        queue = [(root,0)]\n        while queue:\n            new = []\n            d = collections.defaultdict(list)\n            for node, s in queue:\n                d[s].append(node.val) \n                if node.left:  new += (node.left, s-1), \n                if node.right: new += (node.right,s+1),  \n            for i in d: g[i].extend(sorted(d[i]))\n            queue = new\n        return [g[i] for i in sorted(g)]\n```\n\n### 复杂度\n\nO(nlogn)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320778491","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ct = 0\n        ref = nums.copy()\n        while ct != len(nums)-1:\n            for i in range(len(nums)-1):\n                total = nums[ct] + nums[i+1]\n                if total == target:\n                    if nums[ct] == nums[i+1]:\n                        res = [ref.index(nums[ct])]\n                        n = ref.pop(ref.index(nums[ct]))#pop one of the numbers\n                        res += [ref.index(n)+1]\n                        return res\n                    return [ref.index(nums[ct]), ref.index(nums[i+1])]\n            nums.pop(0)\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321040139","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        import heapq\n        from collections import Counter, defaultdict\n        heap = [(-1*v1, k1) for k1,v1 in Counter(nums).items()] # O(N) to build the heap\n        heapq.heapify(heap) # O((n-k) log n). Worst case O(n log n).\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1]) # O(logN) / O((n-k) log n) for the pops\n        return result\n```\n\n### 复杂度\n\n见代码\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321342955","body":"### 思路\n\n。。。\n\n### 代码\n\n```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans=0\n        for i in points:\n            a={}\n            for j in points:\n                c=(i[0]-j[0])**2+(i[1]-j[1])**2\n                if c not in a:\n                    a[c]=1\n                else:\n                    ans+=a[c]\n                    a[c]+=1\n        return ans*2\n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323096578","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n```python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        seen = {}\n        l = 0\n        output = 0\n        for r in range(len(s)): #sliding window\n            if s[r] not in seen: # keep increasing the window size\n                output = max(output,r-l+1)\n            else:\n                if seen[s[r]] < l: # s[r] is inside the current window\n                    output = max(output,r-l+1) \n                else: # s[r] is not inside the current window\n                    l = seen[s[r]] + 1\n            seen[s[r]] = r\n        return output\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324592189","body":"### 思路\n\n（抄作业）滑动窗口+HashTable\n\n### 代码\n\n```python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        word_len = len(words[0])\n        ori_word_dict = defaultdict(int)\n\t\t\n        for word in words:\n            ori_word_dict[word] += 1\n        \n        all_word_len = len(words) * word_len\n        result = []\n        for i in range(word_len):\n            queue = deque()\n            word_dict = ori_word_dict.copy()\n            for j in range(i, len(s) - word_len + 1, word_len):\n                word = s[j:j + word_len]\n                if word_dict.get(word, 0) != 0:\n                    word_dict[word] -= 1\n                    queue.append(word)\n                    if sum(word_dict.values()) == 0:\n                        result.append(j - all_word_len + word_len)\n                        last_element = queue.popleft()\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                else:\n                    while len(queue):\n                        last_element = queue.popleft()\n                        if last_element == word:\n                            queue.append(word)\n                            break\n                        else:\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\n                            if word_dict[last_element] > ori_word_dict[last_element]:\n                                word_dict = ori_word_dict.copy()\n\n        return result\n```\n\n### 复杂度\n\nO(n*m)/O(n+m)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326854119","body":"### 思路\n\n快慢指针\n\n### 代码\n\n```python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327973991","body":"### 思路\n\n...\n\n### 代码\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        # need to check length if no mentioned\n        # if len(nums) == 0: return 0\n        x = 1\n        for i in range(len(nums)-1):\n            if nums[i] != nums[i+1]:\n                nums[x] = nums[i+1]\n                x+=1\n        return x\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328158261","body":"### 思路\n\n二分\n\n### 代码\n\n```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums)-1\n        while l <= r:\n            mid = int(l+(r-l)/2)\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return r + 1\n```\n\n### 复杂度\n\nO(logn)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328584842","body":"### 思路\r\n\r\n抄作业：2 max stacks\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        class MaxStack:\r\n            def __init__(self):\r\n                self._stack = []\r\n                self._max_stack = []\r\n\r\n            def push(self, item):\r\n                self._stack.append(item)\r\n                self._max_stack.append(\r\n                    max(item, self._max_stack[-1]) if self._max_stack else item\r\n                )\r\n\r\n            def pop(self):\r\n                self._max_stack.pop()\r\n                return self._stack.pop()\r\n\r\n            def get_max(self):\r\n                return self._max_stack[-1] if self._max_stack else int(-1e6)\r\n\r\n            def empty(self):\r\n                return not self._stack\r\n\r\n        left = MaxStack()\r\n        right = MaxStack()\r\n        answer = []\r\n\r\n        for ind in range(k):\r\n            left.push(nums[ind])\r\n\r\n        for ind in range(k, len(nums)):\r\n            if right.empty():\r\n                while not left.empty():\r\n                    right.push(left.pop())\r\n\r\n            answer.append(max(left.get_max(), right.get_max()))\r\n            left.push(nums[ind])\r\n            right.pop()\r\n        answer.append(max(left.get_max(), right.get_max()))\r\n        return answer\r\n```\r\n\r\n### 复杂度\r\n\r\n。。。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329712292","body":"### 思路\n\nGraph...\n\n### 代码\n\n```python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        trusts = [0] * (n+1)\n        for (a, b) in trust:\n            trusts[a] -= 1\n            trusts[b] += 1\n            \n        for i in range(1, len(trusts)):\n            if trusts[i] == n-1: return i\n        return -1\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331715059","body":"### 思路\n\n抄答案 / BFS\n\n### 代码\n\n```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        dislike = [[] for _ in range(n)]\n        for a, b in dislikes:\n            dislike[a-1].append(b-1)\n            dislike[b-1].append(a-1)\n\n        groups = [0] * n\n        for p in range(n):\n            if groups[p] == 0:\n                groups[p] = 1\n                q = deque([p])\n                while q: # bfs\n                    a = q.pop()\n                    for b in dislike[a]:\n                        if groups[b] == 0:\n                            groups[b] = 1 if groups[a] == 2 else 2\n                            q.appendleft(b)\n                        elif groups[a] == groups[b]:\n                            return False\n        return True\n```\n\n### 复杂度\n\n。。。\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334779521","body":"### 思路\n\n检查上/下，左/右的数量是否对等\n\n### 代码\n\n```python\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        return moves.count('U')==moves.count('D') and moves.count('R')==moves.count('L') if len(moves)%2 == 0 else False\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336037451","body":"### 思路\n\n抄答案\n\n### 代码\n\n```python\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        res = []\n        tasks = sorted([(t[0], t[1], i) for i, t in enumerate(tasks)])\n        i = 0\n        h = []\n        time = tasks[0][0]\n        while len(res) < len(tasks):\n            while (i < len(tasks)) and (tasks[i][0] <= time):\n                heapq.heappush(h, (tasks[i][1], tasks[i][2])) # (processing_time, original_index)\n                i += 1\n            if h:\n                t_diff, original_index = heapq.heappop(h)\n                time += t_diff\n                res.append(original_index)\n            elif i < len(tasks):\n                time = tasks[i][0]\n        return res\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336347817","body":"class Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        start_hour, start_min = int(loginTime[:2]), int(loginTime[3:])\n        end_hour, end_min = int(logoutTime[:2]), int(logoutTime[3:])\n        if (start_hour > end_hour) or (start_hour == end_hour and start_min > end_min):\n            end_hour += 24\n        answer = 0\n        minutes = [0, 15, 30, 45]\n        if not (start_hour == end_hour and start_min <= end_min):\n            answer += 4 * (end_hour - start_hour - 1) + 4 - bisect_left(minutes, start_min) + bisect_right(minutes, end_min) - 1\n        else:\n            for i in range(3):\n                if start_min <= minutes[i] and minutes[i + 1] <= end_min:\n                    answer += 1\n        return answer","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336931582","body":"### 思路\n\n每种方法都检查一遍，取最小值\n\n### 代码\n\n```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        def count(s):\n            arr = [0 for i in range(26)]\n            for c in s:\n                arr[ord(c) - ord('a')] += 1\n            return arr\n        \n        c1 = count(a)\n        c2 = count(b)\n        \n        def helper(c1, c2):\n            res = float('inf')\n            moveC1 = sum(c1) # move all in c1 to be less or equal\n            moveC2 = 0 # move all in c2 to be greater\n            for i in range(25):\n                moveC1 -= c1[i]\n                moveC2 += c2[i]\n                res = min(res, moveC1 + moveC2)\n            return res\n        \n        def helper3(c1, c2):\n            res = float('inf')\n            sum1 = sum(c1)\n            sum2 = sum(c2)\n            for i in range(26):\n                res = min(res, sum1 - c1[i] + sum2 - c2[i])\n            return res\n        \n        res1 = helper(c1, c2)\n        res2 = helper(c2, c1)\n        res3 = helper3(c1, c2)\n        return min([res1, res2, res3])\n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338803640","body":"### 思路\n\nQuick sort w/ 3 way\n\n### 代码\n\n```python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        if len(nums) <= 1: return nums\n\n        pivot = random.choice(nums)\n        lt = [v for v in nums if v < pivot]\n        eq = [v for v in nums if v == pivot]\n        gt = [v for v in nums if v > pivot]\n\n        return self.sortArray(lt) + eq + self.sortArray(gt)\n```\n\n### 复杂度\n\nO(nlogn) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340143193","body":"### 思路\n\nbinary search\n\n### 代码\n\n```python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x == 1: return 1\n        l, r = 0, x\n        while l <= r:\n            mid_v = l+(r-l) // 2\n            if mid_v*mid_v <= x < (mid_v+1)*(mid_v+1):\n                return mid_v\n            elif mid_v*mid_v > x:\n                r = mid_v - 1\n            else:\n                l = mid_v + 1\n```\n\n### 复杂度\n\nO(logn) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341587474","body":"### 思路\n\nbinary search\n\n### 代码\n\n```python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n == 1 and isBadVersion(n): return n\n        l, r = 1, n\n        while l <= r:\n            mid = int((l+r)/2)\n            if isBadVersion(mid):\n                if not isBadVersion(mid - 1):\n                    return int(mid)\n                r = mid - 1\n            else:\n                l = mid + 1\n```\n\n### 复杂度\n\nO(logn) / O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343885071","body":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        def h(nums):\n            if len(nums) <= 1: return nums, 0\n            mid = len(nums) // 2\n            lArr, lRes, rArr, rRes = *h(nums[:mid]), *h(nums[mid:])\n            res, rIndex = lRes + rRes, 0\n            for n in lArr:\n                while rIndex < len(rArr) and rArr[rIndex] * 2 < n: rIndex += 1\n                res += rIndex\n            return sorted(nums), res \n        return h(nums)[1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345037994","body":"### 思路\n\n（链接打不开 写了lc796）\n\ns+s中check原来的str\n\n### 代码\n\n```python\nclass Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        check=s+s\n        if len(goal)!=len(s):\n            return False \n        if goal in check:\n            return True \n        return False\n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345430234","body":"### 思路\n\n（链接打不开 写了lc822）\n\nSet\n\n### 代码\n\n```python\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set()\n        for a, b in zip(fronts, backs):\n            if a == b:\n                bad.add(a)\n        res = float('inf')\n        for a, b in zip(fronts, backs):\n            if a not in bad:\n                res = min(res, a)\n            if b not in bad:\n                res = min(res, b)\n        return res if res != float('inf') else 0\n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345927353","body":"### 思路\n\n抄答案 / Dijkstra\n\n### 代码\n\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        nums_rows = num_cols = len(grid)\n        \n        def get_neighbors(row, col):\n            delta_rows = [-1, 0, 1, 0]\n            delta_cols = [0, 1, 0, -1]\n            neighbors = []\n            for i in range(len(delta_rows)):\n                new_row = row + delta_rows[i]\n                new_col = col + delta_cols[i]\n                if new_row < 0 or new_row >= nums_rows or new_col < 0 or new_col >= num_cols:\n                    continue\n                neighbors.append((new_row, new_col))\n            \n            return neighbors\n        \n        min_heap = [(grid[0][0], (0, 0))]\n        heapq.heapify(min_heap)\n        curr_max = float('-inf')\n        visited = set()\n        while min_heap:\n            val, (row, col) = heapq.heappop(min_heap)\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            \n            if (row, col) == (nums_rows - 1, num_cols - 1):\n                return max(curr_max, grid[nums_rows - 1][num_cols - 1])\n            \n            curr_max = max(curr_max, val)\n            for neighbor in get_neighbors(row, col):\n                nr, nc = neighbor\n                heapq.heappush(min_heap, (grid[nr][nc], (nr, nc)))\n        \n        return -1  \n```\n\n### 复杂度\n\n。。。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347787112","body":"### 思路\n\nsliding window\n\n### 代码\n\n```python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        i,c,m,n=0,0,0,len(s)\n        for j in range(n):\n            if s[j] in 'aeiou':\n                c+=1\n            if j-i+1==k:\n                m=max(m,c)\n                if s[i] in 'aeiou':\n                    c-=1\n                i+=1\n        return m\n```\n\n### 复杂度\n\nO(n)/O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350415425","body":"### 思路\n\nsliding window + DP\n\n### 代码\n\n```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [0 for i in range(k)] + [1 for i in range(k, 1 + n)] + [0 for i in range(maxPts)] \n        Win = float(sum(dp[k : k + maxPts])) \n        for i in range(k-1,-1,-1):\n            dp[i] = Win / maxPts\n            Win += dp[i] - dp[i + maxPts]\n        return dp[0]\n```\n\n### 复杂度\n\nO(n)/O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354335572","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        from collections import Counter\n    \n        temp = Counter(t)\n        count = len(temp)\n\n        i, j = 0, 0\n        string = \"\"\n        mini = 10 ** 6\n\n        while j < len(s):           \n            if s[j] in temp:\n                temp[s[j]] -= 1\n                if temp[s[j]] == 0:\n                    count -= 1\n\n            while count == 0 and i <= j:\n\n                if (j - i + 1) < mini:\n                    mini = (j - i + 1)\n                    string = s[i: j + 1]\n\n                if s[i] in temp:\n                    temp[s[i]] += 1\n                    if temp[s[i]] == 1:\n                        count += 1\n\n                i += 1        \n            j += 1               \n        return string","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356124062","body":"class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        ans = [[]]\n        for n in nums:\n            new_ans = []\n            for l in ans:\n                for i in range(len(l)+1):\n                    new_ans.append(l[:i]+[n]+l[i:])\n                    if i<len(l) and l[i]==n: break              #handles duplication\n            ans = new_ans\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356893965","body":"class Solution:\n    def totalNQueens(self, n: int) -> int:\n        self.res = 0\n        self.dfs([-1]*n, 0)\n        return self.res\n\n    def dfs(self, nums, index):\n        if index == len(nums):\n            self.res += 1\n            return #backtracking\n        for i in range(len(nums)):\n            nums[index] = i\n            if self.valid(nums, index):\n                self.dfs(nums, index+1)\n\n    def valid(self, nums, n):\n        for i in range(n):\n            if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\n                return False\n        return True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358430471","body":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        def dfs(x,y):\n            if grid[x][y] == 1:\n                grid[x][y] = -1\n                res = 1\n            else:\n                return 0\n            if x + 1 < len(grid):\n                res += dfs(x+1,y) \n            if x - 1 >= 0:\n                res += dfs(x-1,y) \n            if y + 1 < len(grid[0]):\n                res += dfs(x,y+1)\n            if y - 1 >= 0:\n                res += dfs(x,y-1)\n            return res\n            \n        seen = set()\n        max_area = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    max_area = max(max_area, dfs(i,j))\n        \n        return max_area","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360940124","body":"class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        dist = [[float('inf') for _ in grid[0]] for _ in grid]\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 1:\n                    dist[i][j] = 0\n                    continue\n                if i-1 >= 0:\n                    dist[i][j] = min(dist[i-1][j]+1, dist[i][j])\n                if j-1 >= 0:\n                    dist[i][j] = min(dist[i][j-1]+1, dist[i][j])\n        maxer = -1\n        for i in range(len(grid)-1, -1, -1):\n            for j in range(len(grid[0])-1, -1, -1):\n                if grid[i][j] == 1:\n                    dist[i][j] = 0\n                    continue\n                if i+1 < len(grid):\n                    dist[i][j] = min(dist[i+1][j]+1, dist[i][j])\n                if j+1 < len(grid[0]):\n                    dist[i][j] = min(dist[i][j+1]+1, dist[i][j])\n                maxer = max(maxer, dist[i][j])\n        if maxer == float('inf'):\n            return -1\n        return maxer","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363813091","body":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        g = collections.defaultdict(list) \n        queue = [(root,0)]\n        while queue:\n            new = []\n            d = collections.defaultdict(list)\n            for node, s in queue:\n                d[s].append(node.val) \n                if node.left:  new += (node.left, s-1), \n                if node.right: new += (node.right,s+1),  \n            for i in d: g[i].extend(sorted(d[i]))\n            queue = new\n        return [g[i] for i in sorted(g)]","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365602660","body":"### 思路\n\nDP\n\n### 代码\n\n```python\nclass Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp, dpPrev = [0] * (n+1), [0] * (n+1)\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if text1[i-1] == text2[j-1]:\n                    dp[j] = dpPrev[j-1] + 1\n                else:\n                    dp[j] = max(dp[j-1], dpPrev[j])\n            dp, dpPrev = dpPrev, dp\n        return dpPrev[n]\n```\n\n### 复杂度\n\n...\t\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366189479","body":"### 思路\n\nDFS\n\n### 代码\n\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        @cache\n        def dfs(i, j):\n            if i >= m or j >= n:      return 0\n            if i == m-1 and j == n-1: return 1\n            return dfs(i+1, j) + dfs(i, j+1)\n        return dfs(0, 0)\n```\n\n### 复杂度\n\n...\t\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367095576","body":"### 思路\n\n抄答案DFS+DP\n\n### 代码\n\n```python\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        dirs = [(-2,-1),(-1,-2),(1,-2),(2,-1),(2,1),(1,2),(-1,2),(-2,1)]\n\n        @lru_cache(None)\n        def sol(i, j, k):\n            if k == 0:\n                return 1\n            curr = 0\n            for di, dj in dirs:\n                i2, j2 = i + di, j + dj\n                if 0 <= i2 < n and 0 <= j2 < n:\n                    curr += 0.125 * sol(i2, j2, k - 1)\n            return curr\n        \n        return sol(row, column, k)\n```\n\n### 复杂度\n\nO(n^2*k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367762709","body":"### 思路\n\n抄答案DFS+bitmask\n\n### 代码\n\n```python\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        @cache\n        def dfs(usedNumbers, currentTotal):\n            for i in range(1, maxChoosableInteger + 1):\n                if (usedNumbers >> i) & 1 == 0:\n                    if currentTotal + i >= desiredTotal or not dfs(usedNumbers | (1 << i), currentTotal + i):\n                        return True\n            return False\n        \n        return ((1 + maxChoosableInteger) * maxChoosableInteger) >> 1 >= desiredTotal and dfs(0, 0)\n```\n\n### 复杂度\n\n...\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368704904","body":"### 思路\n\nDP\n\n### 代码\n\n```python\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [0] + [float('inf') for i in range(amount)]\n        for i in range(1, amount+1):\n            for coin in coins:\n                if i - coin >= 0:\n                    dp[i] = min(dp[i], dp[i-coin] + 1)\n        if dp[-1] == float('inf'):\n            return -1\n        return dp[-1]\n```\n\n### 复杂度\n\n...\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369509767","body":"### 思路\n\nDP\n\n### 代码\n\n```python\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount+1)\n        dp[0] =1\n\n        for i in range(len(coins)-1,-1,-1):\n            for j in range(1,amount+1):\n                if j - coins[i] >=0:\n                    dp[j] += dp[j-coins[i]]\n                \n        return dp[amount] \n```\n\n### 复杂度\n\n...\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371204794","body":"### 思路\n\nSorting + iteration compare\n\n### 代码\n\n```python\nclass Solution: #time: O(NlogN) :: sort space:O(1)\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        real_end, cnt = float('-inf'), 0\n        for srt, end in sorted(intervals, key=lambda x: x[1]):\n            if srt >= real_end: \n                real_end = end\n            else: \n                cnt += 1\n        return cnt\n```\n\n### 复杂度\n\nO(nlogn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373013441","body":"### 思路\n\nSorting + ...\n\n### 代码\n\n```python\nclass Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        people.sort(reverse=True)\n        i, j = 0, len(people) - 1\n        while i <= j:\n            if people[i] + people[j] <= limit: j -= 1\n            i += 1\n        return i\n```\n\n### 复杂度\n\nO(nlogn)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374375682","body":"### 思路\n\nDP\n\n### 代码\n\n```python\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [1, 1]\n        for i in range(2, n + 1):\n            count = 0\n            for j in range(i):\n                count += dp[j] * dp[i - j - 1]\n            dp.append(count)\n        return dp.pop()\n```\n\n### 复杂度\n\n...\n\n参考：https://blog.csdn.net/u012501459/article/details/46622501\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374691927","body":"### 思路\n\nHeap挨个存储，最后pop建立一个有序LL\n\n### 代码\n\n```python\nimport heapq\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        ListNode.__lt__ = lambda self, other: self.val < other.val\n        h = []\n        head = tail = ListNode(0)\n        for i in lists:\n            if i: heapq.heappush(h, i)\n        while h:\n            node = heapq.heappop(h)\n            tail.next = node\n            tail = tail.next\n            if node.next: heapq.heappush(h, node.next)\n        return head.next \n```\n\n### 复杂度\n\nO(nlogK) / O(k)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375125691","body":"### 思路\n\n奇加偶才能满足条件，最后需要确保长度是n\n\n### 代码\n\n```python\nclass Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        res = [1]\n        while len(res) < n:\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\n        return [i for i in res if i <= n]\n```\n\n### 复杂度\n\n。。。\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1377867588","body":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ret = []\n        self.dfs(nums, [], ret)\n        return ret\n    \n    def dfs(self, nums, path, ret):\n        ret.append(path)\n        for i in range(len(nums)):\n            self.dfs(nums[i+1:], path+[nums[i]], ret)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379859326","body":"class TrieNode:\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_word = False\n    \nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        current = self.root\n        for letter in word:\n            current = current.children[letter]\n        current.is_word = True\n        \n\n    def search(self, word: str) -> bool:\n        current = self.root\n        for letter in word:\n            current = current.children.get(letter)\n            if current is None:\n                return False\n        return current.is_word\n\n    def startsWith(self, prefix: str) -> bool:\n        current = self.root\n        for letter in prefix:\n            current = current.children.get(letter)\n            if current is None:\n                return False\n        return True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381361060","body":"class MapSum:\n\n    def __init__(self):\n        self.dic = {}\n\n    def insert(self, key: str, val: int) -> None:\n        self.dic[key] = val\n\n    def sum(self, prefix: str) -> int:\n        out, n = 0, len(prefix)\n        for item in self.dic:\n            if item[:n] == prefix:\n                out += self.dic[item]\n        return out","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382625587","body":"### 抄答案 ###\nclass Trie:\n   def __init__(self, words):\n       self.d = {}\n       for i in range(len(words)):\n           tree = self.d\n           for char in words[i]:\n               if char not in tree:\n                   tree[char] = {}\n               tree = tree[char]\n           tree['end'] = i\n       \n   def search(self, s):\n       tree = self.d\n       res = []\n       for char in s:\n           if char not in tree:\n               return res\n           tree = tree[char]\n           if 'end' in tree:\n               res.append(tree['end'])\n       return res\n\nclass Solution:\n   def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\n       trie = Trie(smalls)\n       res = [[] for _ in range(len(smalls))]\n       for i in range(len(big)):\n           tmp = trie.search(big[i:])\n           for idx in tmp:\n               res[idx].append(i)\n       return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1382921164","body":"class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        def dfs(n) :\n            for i, v in enumerate(isConnected[n]) :\n                if v == 1 and i not in seen :\n                    seen.add(i)\n                    dfs(i)\n        \n        l = len(isConnected)\n        ans = 0\n        seen = set()\n        for i in range(l) :\n            if i not in seen :\n                dfs(i)\n                ans += 1\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298148770","body":"### 思路\n\n对每一位分别加减，\n\n### 代码\n\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        res=[]\n        i=len(num)-1\n        s=0\n        carry=0\n        while i>=0 or k!=0:\n            x=num[i] if i>=0 else 0\n            y=k % 10\n            s = x + y + carry\n            carry =s // 10\n            k //= 10\n\n            i -= 1\n            res.insert(0,s%10)\n        \n        if carry != 0:\n            res.insert(0,carry)\n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300301035","body":"### 思路\n\n从左到右，从右到左分别遍历，最后一起比较\n\n### 代码\n\n\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        tmp=-len(s)\n        index =0\n        dis_l=[0]*len(s)\n        dis_r=[0]*len(s)\n        dis=[0]*len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_l [i] = i-tmp\n\n        s=s[::-1]\n        tmp=-len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_r [i] = i-tmp\n\n        dis_r=dis_r[::-1]\n        for i in range(len(s)):\n            dis[i]=min(abs(dis_l[i]),abs(dis_r[i]))\n        return dis    \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(3N)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301583588","body":"### 思路\n>列表变栈\n### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.CustomStack = [0]*maxSize\n        self.top = -1 #栈顶为-1，表示栈空\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.CustomStack) - 1:#栈顶为总长度-1，表示栈满\n            self.top += 1\n            self.CustomStack[self.top] = x\n        \n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.CustomStack[self.top+1]\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range( min( (k) , self.top + 1 ) ):\n            self.CustomStack[i] += val\n\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302876960","body":"### 思路\n循环字符串s\n非 \"]\" 默认全部入栈\n遇到\"]\"时\n维护strs和repeat两个空字符串\n先while循环获取所有字符串，条件为stack[-1] != '[' (因为题目明确无异常场景，故此处无需判断栈是否为空)\nstrs = stack.pop() + strs\n执行一次stack.pop() 删掉“[”\n再次while循环，条件为栈存在且栈顶为数字类型的字符串（“3[a]”场景，必须判断栈不为空）\nrepeat = stack.pop() + repeat\n现在栈中压入int(repeat) * strs即可\n\n### 代码\n``` py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for i in s:\n            if i == ']':\n                strs=''\n                repeat=''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop()+repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n### 复杂度\n双O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304560480","body":"### 双栈模拟队列，每次push，pop都要把输入栈导入输出栈\n### 代码\n``` py\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819837","body":"### 代码\n``` py3\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305081132","body":"### 思路\n求长度，对于特殊的直接返回，取余求得实际旋转次数\n### 代码\n```py3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k==0 or not head or not head.next:\n            return head\n        #求长度\n        n=1\n        cur = head\n        while cur.next:\n            cur=head.next\n            n+=1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next=head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next=None\n        return ret\n```\n### 复杂度\n空间O(1),时间O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307334879","body":"### 思路\n递归，递归之后的前一个节点为head。head和头节点完成交换\n``` python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        tmp = head.next\n        head.next =  self.swapPairs( tmp.next )\n        tmp.next = head\n        return tmp \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308903375","body":"### 思路\n分治\n### 代码\n``` py\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\n            fast = slow = left\n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        \n        return buildTree(head, None)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310403568","body":"### 代码\n```py\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n                A, B = headA, headB\n        while A != B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311675535","body":"### 思路\n快慢法\n### 代码\n``` py\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n\n        fast = head\n        slow = head\n\n        if not head or not head.next:\n            return\n\n        while True:\n            if not fast or not fast.next: return\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow : \n                break\n\n        fast = head\n\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n\n        return fast\n```\n### 算法复杂度\n时间O(n),空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312334328","body":"### 代码\n``` py\nclass ListNode: \n    def __init__(self, key = 0, value = 0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.head = ListNode()\n        self.tail = ListNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.cache = dict()\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = ListNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed = self.removeTail()\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n\n    def addToHead (self,node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode (self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n    \n    def moveToHead (self,node):\n        self.removeNode(node)\n        self.addToHead(node)\n    \n    def removeTail(self) -> ListNode:\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312636466","body":"### 递归\n### 代码\n··· py\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n```\n### 复杂度\n时间O(N),空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313844898","body":"### 思路\n递归\n### 代码\n```py\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return true\n        if not p or not q:\n            return false\n        return p.val = q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n### 复杂度\n双ON","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314806465","body":"### DFS\n### 代码\n```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs (root: Optional[TreeNode], total):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return total * 10 + root.val\n            return dfs (root.left, total * 10 + root.val) +  dfs (root.right, total * 10 + root.val)\n        return dfs (root, 0)\n```\n### 复杂度\n双ON","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316186621","body":"### DFS\n### 代码\n``` py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def __init__(self):\n        self.res = 0\n        self.max_level = 0\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        self.res = root.val\n        def dfs(root,level):\n            if not root:\n                return\n            if level > self.max_level:\n                self.res = root.val\n                self.max_level = level\n            dfs (root.left, level + 1)\n            dfs (root.right, level + 1)\n        dfs (root,0)\n        return self.res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318105485","body":"### 搬运工\n### 代码\n``` py\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        ans = ''\n        queue = [root]\n        while queue:\n            node = queue.pop(0)\n            if node:\n                ans += str(node.val) + ','\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                ans += '#,'\n        print(ans[:-1])\n        return ans[:-1]\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if data == '#': return None\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        queue = [root]\n\n        i = 1\n\n        while i < len(nodes) - 1:\n            node = queue.pop(0)\n            lv = nodes[i]\n            rv = nodes[i + 1]\n            i += 2\n            if lv != '#':\n                l =TreeNode(lv)\n                node.left = l\n                queue.append(l)\n\n            if rv != '#':\n                r = TreeNode(rv)\n                node.right = r\n                queue.append(r)\n            \n        return root\n\n# Your Codec object will be instantiated and called as such:\n# ser = Codec()\n# deser = Codec()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320016078","body":"### 搬运工\n```py\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        seen = collections.defaultdict(lamda: collections.defaultdict(list))\n\n        def dfs(root, x=0, y=0):\n            if not root:\n                return\n            seen[x][y].append(root.val)\n            dfs(root.left, x-1, y+1)\n            dfs(root.right, x+1, y+1)\n        \n        dfs (root)\n        ans = []\n        for x in sorted(seen):\n            level = []\n\n            for y in sorted(seen[x]):\n\n                level += sorted(v for v in seen[x][y])\n            ans.append(level)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320805986","body":"### 思路\nmapper存储\n### 代码\n``` py\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n=len(nums)\n        mapper={}\n        for i in range(n):\n            if (target-nums[i] in mapper):\n                return [mapper[target-nums[i]] , i]\n            else:\n                mapper[nums[i]] = i\n        \n        return []\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321041923","body":"### 代码\n```py\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        return [i[0] for i in Counter(nums).most_common(k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321938021","body":"``` py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1 \n            \n            for count in m.values():\n                ans += count * (count - 1)\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323258696","body":"### 滑动窗口学习\n``` py\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:\n            return 0\n        left = 0\n        lookup = set()\n        n =len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left +=1\n                cur_len -= 1\n            if cur_len > max_len:\n                max_len= cur_len\n            lookup.add(s[i])\n        return max_len\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324929569","body":"### 滑动窗口\n### 代码\n```py\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        cnt, l = len(words), len(words[0])\n        i, j = 0, cnt * l - 1\n        ans = []\n        check = collections.Counter(words)\n        while j < len(s):\n            ss = s[i : j + 1]\n            tmp = []\n            for k in range(0, len(ss), l):\n                tmp.append(ss[k: k + l])\n            if collections.Counter(tmp) == check:\n                ans.append(i)\n            i += 1\n            j += 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325871828","body":"### 看着敲了一遍\n``` py\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327537250","body":"### 快慢指针\n### 代码\n```py\nclass Solution:\n    def middleNode(self, head: ListNode) -> ListNode:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328028361","body":"### 思路\n### 代码\n```py\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums: \n            return 0\n\n        l, r = 0, 0\n        while r < len(nums):\n            if nums[l] != nums[r]:\n                l += 1\n                nums[l] = nums[r]\n            r += 1\n        return l + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328260010","body":"### 思路\n二分\n### 代码\n``` py\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329081839","body":"### 代码\n```py\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        q = collections.deque() # 本质就是单调队列\n        ans = []\n        for i in range(len(nums)):\n            while q and nums[q[-1]] <= nums[i]: q.pop() # 维持单调性\n            while q and i - q[0] >= k: q.popleft() # 移除失效元素\n            q.append(i)\n            if i >= k - 1: ans.append(nums[q[0]])\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330663484","body":"### 代码\n``` py\nclass Solution:\n     def findJudge(self, N, trust):\n        count = [0] * (N + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, N + 1):\n            if count[i] == N - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332042257","body":"### 代码\n``` py\nclass Solution:\n    def dfs(self,graph,colors,i,color,N):\n        colors[i] = color\n        for j in range(N):\n            if graph[i][j] == 1:\n                if colors[j] == color:\n                    return False\n                if colors [j] == 0 and not self.dfs(graph, colors, j, -1 * color, N):\n                    return False\n            \n        return True\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        graph = [[0] * n for i in range(n) ]\n        colors = [0] * n\n        for a,b in dislikes:\n            graph[a-1][b-1] = 1\n            graph[b-1][a-1] = 1\n        \n        for i in range(n):\n            if colors[i] == 0 and not self.dfs(graph,colors,i,1,n):\n                return False\n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333170076","body":"class Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334669613","body":"### 代码\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y = 0;\n        for (const auto& move: moves){\n            if (move == 'U'){\n                y--;\n            }\n            else if (move == 'D'){\n                y++;\n            }\n            else if (move == 'L'){\n                x--;\n            }\n            else if (move == 'R'){\n                x++;\n            }\n        }\n        return x == 0 &&　y == 0;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336152700","body":"### 代码\n```py\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336402158","body":"### 代码\n```py\n\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\n        sh, sm = map(int, startTime.split(\":\"))\n        eh, em = map(int, finishTime.split(\":\"))\n        d = 0\n        if sh * 60 + sm > eh * 60 + em: d += 1\n        if 0 < sm <= 15:\n            sm = 15\n        elif 15 < sm <= 30:\n            sm = 30\n        elif 30 < sm <= 45:\n            sm = 45\n        elif 45 < sm <= 60:\n            sm = 0\n            sh += 1\n        if 0 <= em < 15:\n            em = 0\n        elif 15 <= em < 30:\n            em = 15\n        elif 30 <= em < 45:\n            em = 30\n        elif 45 <= em < 60:\n            em = 45\n        st = sh * 60 + sm\n        et = eh * 60 + em\n        if d == 1: et += 24 * 60\n        return max(0, (et - st)) // 15\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337298310","body":"```py\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        ans = len(A) + len(B)\n        for i in range(26):\n            ans = min(ans, len(A) + len(B) - counter_A[i] - counter_B[i])\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338775613","body":"### 归并排序\n```py\nclass Solution:\n    def merge_sort(self, nums, l, r):\n        if l == r:\n            return\n        mid = (l + r) // 2\n        self.merge_sort(nums, l, mid)\n        self.merge_sort(nums, mid + 1, r)\n        tmp = []\n        i, j = l, mid + 1\n        while i <= mid or j <= r:\n            if i > mid or (j <= r and nums[j] < nums[i]):\n                tmp.append(nums[j])\n                j += 1\n            else:\n                tmp.append(nums[i])\n                i += 1\n        nums[l: r + 1] = tmp\n\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.merge_sort(nums, 0, len(nums) - 1)\n        return nums\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340301634","body":"### 代码\n```py\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        ans, l, r = 0, 0, x\n        while l <= r:\n            mid = (l + r) // 2\n            if mid ** 2 > x:\n                r = mid - 1\n            if mid ** 2 <= x:\n                ans = mid\n                l = mid + 1\n        return int(ans)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298225704","body":"### 思路\n\n1. 将 数字 k 加至所给数组的最后一位\n2. 将该位取余，得到该位本身的值 \n3. 给该位除以10，得到该位向前一位的进数\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n\n        for(int i = n - 1;i >= 0 || k > 0;i--)\n        {\n            if(i >= 0)\n            {\n                k+=num[i];\n            }\n            res.push_back(k % 10);\n            k/=10;\n        }\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(|k| or n)，其中 |k| 为数字k的位数。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299459461","body":"### 思路\n\n1. 遍历字符串s\n2. 在遍历字符串s的每个字符s[i]时，再一次对s进行遍历，在内层的每次遍历中判断该字符是否等于c并计算出该字符c与外层当前遍历的s[i]的距离\n3. 通过min变量维护每个字符s[i]到字符c的最小值\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n\n        for(int i = 0;i < s.size();i++)\n        {\n            int min = INT_MAX;\n\n            for(int j = 0;j < s.size();j++)\n            {\n                if((s[j] == c) && (abs(j - i) < min))\n                {\n                    min = abs(j - i);\n                }\n            }\n            res.push_back(min);\n        }\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n),n为字符串s的长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301729765","body":"### 思路\n\n1. 通过数组以及一个指向栈顶的指针来模拟栈\n2. 栈的增量操作：若k的值大于栈的容量，则进行栈的容量次循环；若k的值小于栈的容量，则进行k次循环\n\n### 代码\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        ownStack = new int[maxSize]();\n        this->maxSize = maxSize;\n        topPtr = -1;\n    }\n    \n    void push(int x) {\n        if(topPtr == this->maxSize - 1)\n        {\n            return;\n        }\n\n        ownStack[++topPtr] = x;\n    }\n    \n    int pop() {\n        if(topPtr == -1)\n        {\n            return -1;\n        }\n        \n        int tem = ownStack[topPtr--];\n        return tem;\n    }\n    \n    void increment(int k, int val) {\n        if(k < topPtr + 1)\n        {\n            for(int i = 0;i < k;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i = 0;i < topPtr + 1;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n    }\nprivate:\n    int* ownStack;\n    int maxSize;\n    int topPtr;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和pop操作为O(1)，increment操作为O(k or n)（n为栈中元素的个数）\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303575583","body":"### 思路\n\n1. 采用分配律的思想\n2. 用一个栈保存数字，后出现的先使用；用一个栈保存高层级（外层）的字符串\n3. 当出现左括号时，说明应该保存这一层级的数字，以及上一层级的字符串（进行push操作）；当出现右括号时，说明应该获取当前层级的数字，用来作为循环条件（即进行乘法分配），获取上一层级的字符串与当前层级的字符串进行循环拼接，得到上一层级的字符串，（使用结束进行pop操作）\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        int num = 0;\n        stack<int> nums;\n        stack<string> lesserStrs;\n\n        int len = s.size();\n        for(int i = 0;i < len;i++)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + (s[i] - '0');\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                lesserStrs.push(res);\n                res = \"\";\n                nums.push(num);\n                num = 0;\n            }\n            else if(s[i] == ']')\n            {\n                int n = nums.top();\n                nums.pop();\n                for(int i = 0;i < n;i++)\n                {\n                    lesserStrs.top() = lesserStrs.top() + res;   \n                }\n                res = lesserStrs.top();\n                lesserStrs.pop();\n            }\n        }\n\n        return res;\n    }\n};\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n),n为字符串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304428361","body":"### 思路\n\n1. 用两个栈模拟一个队列\n2. push操作：用push栈，直接进行栈的push操作；pop操作：用pop栈，本质上是对push栈进行一个反转，即栈底变栈顶，然后进行pop栈的pop操作，满足了队列先进先出的要求\n\n### 代码\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        pushConti.push(x);\n    }\n    \n    int pop() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        popConti.pop();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n\n        return qTop;\n    }\n    \n    int peek() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n        \n        return qTop;\n    }\n    \n    bool empty() {\n        if(pushConti.empty())\n        {\n            return true;\n        }\n        return false;\n    }\nprivate:\n    stack<int> pushConti;\n    stack<int> popConti;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push,empty:O(1), pop,peek:O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828585","body":"### 思路\n\n1. 由于数组升序和分块后升序的顺序是不会变的（也就是说我们一定是按顺序进行分块的，前面的还没有分块则后面的也不能分块）\n2. 采用哈希表对原数组和排序后的数组中的元素进行匹配，该元素同时出现在原数组和排序后的数组后，删除该元素，表示已匹配\n3. 只有当i前面的所有元素都匹配成功后，我们才可以进行一次分块\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> sorted = arr;//Sorted array\n        sort(sorted.begin(),sorted.end());\n\n        unordered_map<int,int> times;\n        int count = 0;\n        for(int i = 0;i < n;i++)\n        {\n            times[arr[i]]++;\n            times[sorted[i]]--;\n\n            if(times[arr[i]] == 0)\n            {\n                times.erase(arr[i]);\n            }\n\n            if(times[sorted[i]] == 0)\n            {\n                times.erase(sorted[i]);\n            }\n\n            if(times.empty())\n            {\n                count++;\n            }\n        }\n\n        return count;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305008995","body":"### 思路\n\n1. 首先排除边界情况，当list为空及realRotate为0时直接返回头节点\n2. 一般情况下，不管旋转几步，都要先将尾部节点和头部节点相连；之后，我们再找到旋转后的尾部节点，将尾部节点的下一个节点赋值给head后，再对其下一个节点置为空\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //Get size of list\n        ListNode* count = head;\n        int size = 0;\n        while(count != NULL)\n        {\n            count = count->next;\n            size++;\n        }\n\n        if(size == 0)\n        {\n            return head;\n        }\n        int realRotate = k % size;\n        if(realRotate == 0)\n        {\n            return head;\n        }\n\n        //Conect the last one with the first one\n        ListNode* last = head;\n        while(last->next != NULL)\n        {\n            last = last->next;\n        }\n        last->next = head;\n\n        //Find the last one after rotating\n        ListNode* lastAR = head;\n        size--;\n        for(int i = 0;i < size - realRotate;i++)\n        {\n            lastAR = lastAR->next;\n        }\n        head = lastAR->next;\n        lastAR->next = NULL;\n\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，遍历求list的大小\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306755286","body":"### 思路\n\n1. 链表的状态存在三种情况：（我们只关注两组相邻的节点）\n1） 从当前起只有只有两个节点\n2） 从当前起有三个节点\n3） 从当前起有四个节点\n2. 我们可以根据链表的不同的状态执行各自的程序\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(!head || !head->next)\n        {\n            return head;\n        }\n        \n        ListNode* first = head;\n        ListNode* second = first->next;\n        ListNode* secondNext = second->next;\n        head = head->next;\n        while(first)\n        {\n            second->next = first;\n            if(!secondNext)\n            {\n                //If the third node isn't existing,first node.next = NULL,return\n                first->next = NULL;\n                return head;\n            }\n            else if(!secondNext->next)\n            {\n                //If the fourth node isn't existing,first node.next = third nodde,return(third node.next = NULL)\n                first->next = secondNext;\n                return  head;\n            }\n            else\n            {\n                //If the fourth node is existing,first node.next = fourth node,and all pointer move back three places\n                first->next = secondNext->next;\n\n                first = secondNext;\n                second = first->next;\n                secondNext = second->next;\n            }\n        }\n\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308179924","body":"### 思路\n\n1. 因为该链表是有序的，我们可以采用二分的方法来形成一棵高度平衡的二叉搜索树\n2. 这里需要对该有序列表按下标的形式进行多次访问，所以我们借助有序数组来代替该有序链表\n3. 形成二叉搜索树是一个递归的过程，每次递归时，我们要在当前范围内找到中间值形成根节点，并安排它的左子节点和右子节点（它的左子节点和右子节点也是在对应范围内找到中间值），当该范围为0时，即到达了递归出口\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        vector<int> sArray;\n        while(head)\n        {\n            sArray.push_back(head->val);\n            head = head->next;\n        }\n\n        return sortedArraytToBST(sArray,0,sArray.size());\n    }\n\n    TreeNode* sortedArraytToBST(vector<int> sArray,int begin,int end)\n    {\n        if(begin == end)\n        {\n            return NULL;\n        }\n\n        int middle = (begin + end) / 2;\n        TreeNode* root = new TreeNode(sArray[middle]);\n\n        root->left = sortedArraytToBST(sArray,begin,middle);\n        root->right = sortedArraytToBST(sArray,middle + 1,end);\n\n        return root;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310186848","body":"### 思路\n\n       BF: 采用最简单的思路，在遍历listA的每个节点时，遍历一次listB，找出是否存在相等的节点地址，如存在，返回该节点地址；如不存在，返回NULL\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* temA = headA;\n        while(temA != NULL)\n        {\n            ListNode* temB = headB;\n            while(temB != NULL)\n            {\n                if(temA == temB)\n                {\n                    return temA;\n                }\n                temB = temB->next;\n            }\n            temA = temA->next;\n        }\n\n        return NULL;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(1)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311149896","body":"### 思路\n\n1. 用一个数组存储已经遍历过的，未成环的节点\n2. 在遍历每个节点时，比较该节点的下一节点与数组中存储的之前的节点，判断是否相等，如相等，则返回该节点的下一节点\n3. 遍历结束，返回NULL\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        vector<ListNode*> noloopNode;\n\n        ListNode* tem = head;\n        while(tem)\n        {\n            if(!noloopNode.empty())\n            {\n                for(ListNode* node : noloopNode)\n                {\n                    if(node == tem->next)\n                    {\n                        return node;\n                    }\n                }\n            }\n            noloopNode.push_back(tem);\n            tem = tem->next;\n        }\n\n        return NULL;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n)\n- 空间复杂度：O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312468271","body":"### 思路\n\nLRU（Least Recently Used）是一种cache替换算法，以下是一种很简单的实现思路，用另一个map来判断出近期最少使用的key值，不过时间复杂度并没有达到要要求，故超时\n\n### 代码\n\n```c++\nclass LRUCache {\npublic:\n    LRUCache(int capacity) {\n        max_size = capacity;\n    }\n    \n    int get(int key) {\n        if(m.find(key) != m.end())\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n            count[key] = 0;\n\n            return m[key];\n        }\n\n        return -1;\n    }\n    \n    void put(int key, int value) {\n        if(m.find(key) == m.end())\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n            \n            if(m.size() < max_size)\n            {\n                m[key] = value;\n                count[key] = 0;\n            }\n            else\n            {\n                map<int,int>::iterator iter = count.begin();\n                map<int,int>::iterator max_count = count.begin();\n                for(;iter != count.end();iter++)\n                {\n                    if(iter->second > max_count->second)\n                    {\n                        max_count = iter;\n                    }\n                }\n                m.erase(max_count->first);\n                count.erase(max_count->first);\n                m[key] = value;\n                count[key] = 0;\n            }\n        }\n        else\n        {\n            map<int,int>::iterator iter = count.begin();\n            for(;iter != count.end();iter++)\n            {\n                iter->second++;\n            }\n\n            m[key] = value;\n            count[key] = 0;\n        }\n    }\n\n    map<int,int> m;\n    map<int,int> count;\n    int max_size;\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：put 和 get 都为O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312726284","body":"### 思路\n\n1. 每棵子树寻求当前节点的最大深度的行为都是一样的，我们考虑使用递归的方式求解树的最大深度\n2. 当根节点为 NULL 时，即最大深度为0，返回 0；当根节点是叶子节点时，最大深度为1, 返回1；当根几点是普通节点时，最大深度为左子树和右子树二者中的最大深度加自身代表的深度，返回 max + 1\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(!root)\n        {\n            return 0;\n        }\n\n        int lSubDepth = maxDepth(root->left);\n        int rSubDepth = maxDepth(root->right);\n\n        return max(lSubDepth,rSubDepth) + 1;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313001330","body":"### 思路\n\n1. 判断两棵子树是否相同的行为是一样的，我们考虑使用递归的方式求解两棵树是否相同\n2. 当两棵树的根节点都为NULL时，返回true；当只有一棵树的根节点为NULL时，返回false；当两棵树的根节点都不为NULL，但当前节点的值不同时返回false；当两颗树的根几点都不为NULL,且当前节点的值相同时，判断这两棵树的左子树和右子树是否都相同\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q)\n        {\n            return true;\n        }\n        if((p && !q) || (!p && q))\n        {\n            return false;\n        }\n        if((p && q) && (p->val != q->val))\n        {\n            return false;\n        }\n        if((p && q) && (p->val == q->val))\n        {\n             return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n        }\n        \n        return false;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315226045","body":"### 思路\n\n1. 分析题意，根据给出示例，树的节点是类似于1->2 ,1->3这样遍历的，可以看出这是一种深度遍历\n2. 采用pre dfs，先求和，再往左，最后往右，利用一个 data member 来对最后的结果进行维护\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        sum = 0;\n        if(!root)\n        {\n            return 0;\n        }\n\n        pre_dfs(root,root->val);\n\n        return sum;\n    }\n    void pre_dfs(TreeNode* node,int tem_sum)\n    {\n        if(!node->left && !node->right)\n        {\n            sum+=tem_sum;\n            return;\n        }\n        if(node->left)\n            pre_dfs(node->left,tem_sum * 10 + node->left->val);\n        if(node->right)\n            pre_dfs(node->right,tem_sum * 10 + node->right->val);\n    }\nprivate:\n    int sum;\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316941625","body":"### 思路\n\n1. 题目让我们找树左下角的值，树的左下角的值的定义是最底层且最左边，我们首先要满足最底层这个条件\n2. 和树的层级有关，我们考虑使用层级遍历，即bfs算法\n3. 通过一个变量count 维护每个层级的大小（在插入时维护）；通过一个变量tem_res维护在遍历当前层时的最左边的值，根据队列FIFO的特点，当前层最左边的值即队头的值\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> bfs;\n        bfs.push(root);\n\n        int count = 1;\n        int tem_res = 0;\n        while(!bfs.empty())\n        {\n            int n = 0;\n            tem_res = bfs.front()->val;\n\n            for(int i = 0;i < count;i++)\n            {\n                TreeNode* tem = bfs.front();\n                if(tem->left)\n                {\n                    bfs.push(tem->left);\n                    n++;\n                }\n                if(tem->right)\n                {\n                    bfs.push(tem->right);\n                    n++;\n                }\n                bfs.pop();\n            }\n            count = n;\n        }\n\n        int res = tem_res;\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318826145","body":"### 思路\n\n1. 题目对我们的输入输出格式没有要求，我们考虑使用思路简单的前序深度遍历算法\n2. pre dfs 对二叉树进行序列化操作时，顺序为DLR；同理对二叉树进行反序列化操作时，顺序也为DLR\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        if(!root)\n        {\n            return \"null\";\n        }\n        return to_string(root->val) + \" \" + serialize(root->left) + \" \" + serialize(root->right) + \" \";\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        stringstream data_stream(data);\n        return pre_dfs(data_stream);\n    }\n    TreeNode* pre_dfs(stringstream& ss){\n        string tem;\n        ss >> tem;\n        if(tem == \"null\")\n        {\n            return NULL;\n        }\n\n        TreeNode* root = new TreeNode(stoi(tem));\n        root->left = pre_dfs(ss);\n        root->right = pre_dfs(ss);\n    \n        return root;\n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319557097","body":"### 思路\n\n1. 通过一个二维数组保存下所有节点的坐标及值信息，采用层序遍历算法\n2. 首先满足第一个要求，即从左到右；之后通过对得到的已满足第一个要求的数组进行排序，依次满足从上到下以及从小到大的要求\n\n### 代码\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> all_loc;\n        int arr[3] = {0,0,root->val};\n        vector<int> vec(arr,arr + 3);\n        all_loc.push_back(vec);\n\n        bfs(root,all_loc);\n\n        int x_min = 0;\n        int x_max = 0;\n        for(int i = 0;i < all_loc.size();i++)\n        {\n            if(all_loc[i][1] < x_min)\n            {\n                x_min = all_loc[i][1];\n            }\n            if(all_loc[i][1] > x_max)\n            {\n                x_max = all_loc[i][1];\n            }\n        }\n        cout << x_min << x_max;\n\n        vector<vector<int>> res;\n        for(int i = x_min;i <= x_max;i++)\n        {\n            vector<vector<int>> match_loc;\n            for(int j = 0;j < all_loc.size();j++)\n            {\n                if(all_loc[j][1] == i)\n                {\n                    match_loc.push_back(all_loc[j]);\n                }\n            }\n\n            for(int m = 0;m < match_loc.size();m++)\n            {\n                for(int n = m + 1;n < match_loc.size();n++)\n                {\n                    if(match_loc[n][0] < match_loc[m][0])\n                    {\n                        vector<int> tem = match_loc[m];\n                        match_loc[m] = match_loc[n];\n                        match_loc[n] = tem;\n                    }\n                    if(match_loc[n][0] == match_loc[m][0])\n                    {\n                        if(match_loc[n][2] < match_loc[m][2])\n                        {\n                            vector<int> tem = match_loc[m];\n                            match_loc[m] = match_loc[n];\n                            match_loc[n] = tem;\n                        }    \n                    }\n                }\n            }\n\n            vector<int> tem;\n            for(int k = 0;k < match_loc.size();k++)\n            {\n                tem.push_back(match_loc[k][2]);\n            }\n            res.push_back(tem);\n        }\n\n        return res;\n    }\n    \n    void bfs(TreeNode* root,vector<vector<int>>& all_loc){\n        queue<TreeNode*> nodes;\n        nodes.push(root);\n\n        while(!nodes.empty())\n        {\n            TreeNode* tem = nodes.front();\n\n            if(tem->left)\n            {\n                for(int i = 0;i < all_loc.size();i++)\n                {\n                    if(all_loc[i][2] == tem->val)\n                    {\n                        int y = all_loc[i][0];\n                        int x = all_loc[i][1];\n                        int arr[3] = {y + 1,x - 1,tem->left->val};\n                        vector<int> vec(arr,arr + 3);\n\n                        all_loc.push_back(vec);\n                        break;\n                    }\n                }\n                nodes.push(tem->left);\n            }\n\n            if(tem->right)\n            {\n                for(int i = 0;i < all_loc.size();i++)\n                {\n                    if(all_loc[i][2] == tem->val)\n                    {\n                        int y = all_loc[i][0];\n                        int x = all_loc[i][1];\n                        int arr[3] = {y + 1,x + 1,tem->right->val};\n                        vector<int> vec(arr,arr + 3);\n\n                        all_loc.push_back(vec);\n                        break;\n                    }\n                }\n                nodes.push(tem->right);\n            }\n\n            nodes.pop();\n        }\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n*n)\n- 空间复杂度：O(n*n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320780215","body":"### 思路\n\n采用哈希表带来时间复杂度为O(1)的查找\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int,int> m;\n        \n        for(int i = 0;i < nums.size();i++)\n        {\n            if(m.find(target - nums[i]) != m.end())\n                return {m[target - nums[i]],i};\n            m[nums[i]] = i;\n        }\n\n        return {};\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1326426936","body":"### 思路\r\n\r\n1. 通过哈希表保存每个数字以及其对应出现的次数\r\n2. 通过优先队列（小顶堆）保存前k个数字出现次数最多的pair（通过自己定义函数对象实现）\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int,int> cnt;\r\n        for(int i = 0;i < nums.size();i++)\r\n        {\r\n            cnt[nums[i]]++;\r\n        }\r\n\r\n        class MyGreater\r\n        {\r\n        public:\r\n            bool operator()(const pair<int,int>& p1,const pair<int,int>& p2)\r\n            {\r\n                return p1.second > p2.second;\r\n            }\r\n        };\r\n\r\n        priority_queue<pair<int,int>,vector<pair<int,int>>,MyGreater> q;\r\n        for(auto n : cnt)\r\n        {\r\n            q.push(n);\r\n            if(q.size() > k)\r\n            {\r\n                q.pop();\r\n            }\r\n        }\r\n\r\n        vector<int> res;\r\n        while(!q.empty())\r\n        {\r\n            res.push_back(q.top().first);\r\n            q.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298271102","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n=num.size();\r\n        vector<int> knum,res;\r\n        int bitsign=0;\r\n      \r\n        while(k>=1){\r\n        \r\n            knum.push_back(k-k/10*10);\r\n            k=k/10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        int t=min(num.size(),knum.size());\r\n        for(int i=0;i<t;i++){\r\n            int bit=num[i]+knum[i]+bitsign;\r\n            \r\n            if(bit>=10){\r\n                res.push_back(bit-10);\r\n                bitsign=1;}\r\n\r\n            else \r\n            {res.push_back(bit);\r\n            bitsign=0;}\r\n        }\r\n        if(num.size()>knum.size()){\r\n            for(int i=knum.size();i<num.size();i++) res.push_back(num[i]);\r\n        }\r\n        else  for(int i=num.size();i<knum.size();i++) res.push_back(knum[i]);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299919275","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=0,q=0;q<n-i||p<i;p++,q++){\n                     if(s[i+q]==c) {\n                         res.push_back(q);\n                         break;\n                         }\n                    if(s[i-p]==c){\n                        res.push_back(p);\n                        break;\n                    }\n\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301752515","body":"class CustomStack {\n    private List<Integer> stack=new ArrayList<>();\n    private int size;\n    \n\n    public CustomStack(int maxSize) {\n        size=maxSize;\n\n    }\n    \n    public void push(int x) {\n        if(stack.size()<size){\n        stack.add(x);}\n\n    }\n    \n    public int pop() {\n        return stack.isEmpty()?-1:stack.remove(stack.size()-1);\n\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<stack.size();i++){\n            stack.set(i,stack.get(i)+val);\n        }\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303098142","body":"```\r\nclass Solution:\r\n\r\n    def decodeString(self, s: str) -> str:\r\n\r\n        result = ''\r\n        string_stack = []\r\n        data = 0\r\n        for i in s:\r\n            if(i.isdigit()):\r\n                data = data*10 + int(i)\r\n\r\n            elif(i == '['):\r\n                string_stack.append([data, result])\r\n                result = ''\r\n                data = 0\r\n\r\n            elif(i.isalpha()):\r\n                result += i\r\n\r\n            elif(i == ']'):\r\n                result = string_stack[-1][1] + string_stack[-1][0] * result\r\n                string_stack.pop()\r\n        return result\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304412237","body":"```\r\npublic class MyQueue{\r\n   Stack<Integer> stack1;\r\n   Stack<Integer> stack2;\r\n```\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.pop();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.pop();\r\n        }\r\n    }\r\n\r\n    public int peek() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.peek();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.peek();\r\n        }\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty()&&stack2.isEmpty();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304660862","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int n = arr.size();\r\n        vector<int> vmin(n+1, 1e8);\r\n        vector<int> vmax(n+1, 0);\r\n        for(int i=1;i<=n;i++) vmax[i] = fmax(vmax[i-1], arr[i-1]);\r\n        for(int i=n-1;i>=0;i--) vmin[i] = fmin(vmin[i+1], arr[i]);\r\n        int ans = 1;\r\n        for(int j=1;j<n;j++){\r\n            if(vmax[j] <= vmin[j]){\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304871633","body":"`\npublic:\n    ListNode* rotateRight(ListNode* head, int k) \n    {\n     if (head == NULL || k <= 0)\n\t\treturn head;\n\tListNode *end = NULL;\n\tListNode *index = head;\n\tListNode *cur = head;\n\tint len = 1;\n\twhile (cur->next != NULL)\n\t{\n\t\tlen++;\n\t\tcur = cur->next;\n\t}\n\tend = cur;\n\t//cout << len << endl;\n\n\tint rotateTimes =  k%len;\n\tif (rotateTimes == 0)\n\t\treturn head;\n\n\t//set ring\n\tend->next = head;\n\tint step = len  - rotateTimes;\n\twhile (step > 0)\n\t{\n\t\tstep--;\n\t\tindex = index->next;\n\t\tend = end->next;\n\t}\n\tend->next = NULL;\n\n\treturn index;\n    }\n};\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306087055","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n          ListNode prev=new ListNode();\r\n          prev.next=head;\r\n          ListNode cur=prev;\r\n          while(cur.next!=null&&cur.next.next!=null){\r\n              ListNode node1=cur.next;\r\n              ListNode node2=cur.next.next;\r\n              cur.next=node2;\r\n              node1.next=node2.next;\r\n              node2.next=node1;\r\n              cur=node1;\r\n          }\r\n          return prev.next;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308495117","body":"```\nclass Solution {\n\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head,null);\n    }\n\n    public TreeNode buildTree(ListNode left,ListNode right){\n        if(left == right){\n            return null;\n        }\n        ListNode mid = getMid(left,right);\n        TreeNode root = new TreeNode();\n        root.val = mid.val;\n        root.left = buildTree(left,mid);\n        root.right = buildTree(mid.next,right);\n        return root;\n    }\n\n    public ListNode getMid(ListNode left,ListNode right){\n        ListNode slow = left;\n        ListNode fast = left;\n        while(fast != right && fast.next != right){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310514312","body":"```\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        Set<ListNode> visited = new HashSet<>();\n        ListNode temp = headA;\n        while(temp != null){\n            visited.add(temp);\n            temp = temp.next;\n        }\n        temp = headB;\n        while(temp != null){\n            if(visited.contains(temp)){\n                return temp;\n            }\n            temp = temp.next;\n        }\n        return null;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311689964","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n\r\n        if(head == NULL) return head;\r\n        ListNode* slow = head, *fast = head, *ret = head;\r\n        while(fast && fast->next != NULL)\r\n        {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if(slow == fast)\r\n            {\r\n                while(ret != slow)\r\n                {\r\n                    ret = ret-> next;\r\n                    slow = slow-> next;\r\n                }\r\n                return ret;\r\n            }\r\n        }\r\n        return NULL;\r\n}\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312251292","body":"```\nclass LRUCache {\n    private int cap;\n    private Map<Integer,Integer> map=new LinkedHashMap<>();\n\n    public LRUCache(int capacity) {\n    this.cap=capacity;\n    }\n    \n    public int get(int key) {\n        if(map.keySet().contains(key)){\n            int value=map.get(key);\n            map.remove(key);\n            map.put(key,value);\n            return value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if(map.keySet().contains(key)){\n            map.remove(key);\n        }else if(map.size()==cap){\n            Iterator<Map.Entry<Integer,Integer>> iterator=map.entrySet().iterator();\n            iterator.next();\n            iterator.remove();\n        }\n        map.put(key,value);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312610440","body":"```\r\n\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (!root) return 0;\r\n        int res = 0;\r\n        queue<TreeNode*> q{{root}};\r\n        while (!q.empty()) {\r\n            ++res;\r\n            for (int i = q.size(); i > 0; --i) {\r\n                TreeNode *t = q.front(); q.pop();\r\n                if (t->left) q.push(t->left);\r\n                if (t->right) q.push(t->right);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n`````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312960180","body":"```c++\nclass Solution{\npublic boolean isSameTree(TreeNode p, TreeNode q) {\n    return inorderTraversal(p,q);\n}\nprivate boolean inorderTraversal(TreeNode p, TreeNode q) {\n    if(p==null&&q==null){\n        return true;\n    }else if(p==null || q==null){\n        return false;\n    }\n    \n    if(!inorderTraversal(p.left,q.left)){\n        return false;\n    }\n   \n    if(p.val!=q.val){\n       return false;\n    }\n   \n    if(!inorderTraversal(p.right,q.right)){\n        return false;\n    }\n    return true;\n}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314266558","body":"```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        if(root==null) return 0;\n        dfs(root,root.val);\n         return sum;\n    }\n    int sum=0;\n    private void dfs(TreeNode root,int cursum){\n        if(root.left==null&&root.right==null){\n            sum+=cursum;\n            return;\n        }\n        if(root.left!=null){\n            dfs(root.left,cursum*10+root.left.val);\n        }\n        if(root.right!=null){\n            dfs(root.right,cursum*10+root.right.val);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316332285","body":"```Java\npublic class Solution {\n \n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> list = new ArrayList<>();\n        list.add(root);\n        TreeNode treeNode = levelSearch(list);\n        return treeNode.val;\n    }\n \n    private TreeNode levelSearch(List<TreeNode> list) {\n        List<TreeNode> nextList = new ArrayList<>();\n        for (TreeNode node : list) {\n            if (node.left != null) {\n                nextList.add(node.left);\n            }\n            if (node.right != null) {\n                nextList.add(node.right);\n            }\n        }\n        if (nextList.size() == 0) {\n            return list.get(0);\n        }\n        return levelSearch(nextList);\n    }\n \n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317994693","body":"```c++\nclass Codec {\npublic:\n \n    \n    string serialize(TreeNode* root) {\n        string str=\"\";\n        if(!root)return str;\n        search_pre(root,str);\n        return str;\n    }\n \n   \n    TreeNode* deserialize(string data) {\n        if(data.compare(\"\")==0)return nullptr;\n        TreeNode* head;\n        create_tree(head,data);\n        return head;\n    }\nprivate:\n   \n    void search_pre(TreeNode* root,string& str)\n    {\n        str+=to_string((long long)root->val);\n        str+=\",\";\n        if(root->left)search_pre(root->left,str);\n        else str+=\"null,\";\n        if(root->right)search_pre(root->right,str);\n        else str+=\"null,\";\n    }\n    \n    void create_tree(TreeNode*& root,string& str)\n    {\n        \n        int num=find_next_num(str);\n        if(num==INT_MIN)return;\n        root=new TreeNode(num);\n        create_tree(root->left,str);\n        create_tree(root->right,str);\n    }\n \n    int find_next_num(string& str)\n    {\n        int num=str.find(\",\");\n        string temp=str.substr(0,num);\n        str.erase(0,num+1);\n        if(temp.compare(\"null\")==0)return INT_MIN;//null return INT_MIN\n        else return stoi(temp);\n    }\n \n    \n    int stoi(string str)\n    {\n        bool negative=false;\n        if(str[0]=='-')\n        {\n            negative=true;\n            str.erase(0,1);\n        }\n        int n=str.length(),ans=0;\n        for(int i=0;i<n;++i)\n        {\n            ans+=(str[i]-'0')*(int)pow(10.0,n-i-1);\n        }\n        return negative?-ans:ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319344643","body":"```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes=new ArrayList<int[]>();\n        dfs(root,0,0,nodes);\n        Collections.sort(nodes,new Comparator<int[]>(){\n            public int compare(int[] a,int[] b){\n                if(a[0]!=b[0])\n                {return a[0]-b[0];}\n                else if(a[1]!=b[1]){\n                    return a[1]-b[1];\n                }\n                else {\n                    return a[2]-b[2];\n                }\n        }\n        });\n        List<List<Integer>> traversal=new ArrayList<List<Integer>>();\n        int col=Integer.MIN_VALUE;\n        int index=-1;\n        for(int[] node:nodes){\n            int curCol=node[0];\n            if(col!=curCol){\n                col=curCol;\n                traversal.add(new ArrayList<Integer>());\n                index++;\n            }\n            traversal.get(index).add(node[2]);\n        }\n        return traversal;\n\n    }\n    public void dfs(TreeNode node,int row,int col, List<int[]> nodes){\n        if(node==null)\n        return;\n        nodes.add(new int[]{col,row,node.val});\n        dfs(node.left,row+1,col-1,nodes);\n        dfs(node.right,row+1,col+1,nodes);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320806965","body":"```c\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n=nums.size();\n        vector<int> res;\n        int m=res.size();\n        for(int i=0;i<n-1;i++){\n            for(int j=i+1;j<n;j++){\n                if(nums[i]+nums[j]==target) {\n                    res.push_back(i);\n                    res.push_back(j);\n                    break;\n                    \n                }\n                \n            }\n           if(m!=0) break;\n        }\n        return res;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321008875","body":"```java\nclass Solution {\n    public List<Integer> topKFrequent(int[] nums, int k) {\n              HashMap<Integer, Integer> count = new HashMap();\n                for (int n : nums) count.put(n, count.getOrDefault(n, 0) + 1);\n         PriorityQueue<Integer> heap = new PriorityQueue<Integer>((a, b) -> count.get(a) - count.get(b));\n        for (int n : count.keySet()) {\n            heap.add(n);\n            if (heap.size() > k)\n                heap.poll();\n        }\n        List<Integer> top_k = new LinkedList();\n        while (!heap.isEmpty())\n            top_k.add(heap.poll());\n        return top_k;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321246084","body":"```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int res=0;\n        for(int i=0;i<points.size();i++) {\n            unordered_map<int,int> m;\n            for(int j=0;j<points.size();j++) {\n                int dx=points[i][0]-points[j][0];\n                int dy=points[i][1]-points[j][1];\n                m[dx*dx+dy*dy]++;\n            }\n            for(auto i:m) {\n                res+=i.second*(i.second-1);\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322870088","body":"```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n          int n=0;\n          int m=1;\n          int M=1;\n          int L=s.length();\n        while(m<L){\n            if(s[m]!=s[n]){\n                m++;\n                int t=m-n+1;\n                M=(M>t)?M:t;\n                }\n            \n            else{\n               n++;\n               m++;  \n}\n          }\n         return  M;\n       }\n    };\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1323951692","body":"```java\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        int totalLen = s.length();\n        int len = words[0].length();\n        int n = words.length;\n        if (n*totalLen == 0){\n            return result;\n        }\n        HashMap<String,Integer> wordMap = new HashMap<>();\n        for (String word:words) {\n            int value = wordMap.getOrDefault(word, 0);\n            wordMap.put(word,value+1);\n        }\n        \n        for (int i = 0; i <totalLen-n*len+1; i++) {\n          \n            Map<String,Integer> hasWords = new HashMap<>();\n            int num = 0;\n            while (num < n){\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\n                if (wordMap.containsKey(currWord)){\n                    int value = hasWords.getOrDefault(currWord,0);\n                    hasWords.put(currWord,value+1);\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\n                        break;\n                    }\n                }else {\n                    break;\n                }\n                num++;\n            }\n            if (num == n){\n                result.add(i);\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325960542","body":"```java\nclass Solution{\n    public int subarraysDivByK(int[] A, int K) {\n        int count=0;\n        int preSum=0;\n        Map<Integer,Integer> map=new HashMap<>();\n        map.put(0,1);\n        for(int a: A){\n            preSum+=a;\n\n            int currMo=(preSum%K+K)%K;\n            int preMoCount=map.getOrDefault(currMo,0);\n            \n            count+=preMoCount;\n            map.put(currMo,preMoCount+1);\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327020514","body":"```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* p=head;\n        int n=0;\n        while(p->next!=NULL){\n            n++;\n            p=p->next;\n        }\n        if(n%2!=0){\n            for(int i=0;i<=n/2+1;i++){\n                p=p->next;\n            }\n            return p;\n        }\n        else{\n         if(p!=NULL)\n         for(int i=0;i<=n/2+2;i++){\n                 p=p->next;\n            }\n            return p;\n        }\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327988198","body":"```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int n=nums.length;\n        int l=0,r=0;\n        while(r<n){\n            while(r<n&&nums[r]==nums[l]) r++;\n            if(r<n){\n                l++;\n                nums[l]=nums[r];\n            }\n        }\n        return l+1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328105749","body":"```c++\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int m=nums.size();\n               for(int i=0;i<m;i++){\n            if(nums[i]==target) return i;\n            else if(nums[i]>target) return i;\n            else continue;\n\n        }\n        return m;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328853640","body":"```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n=nums.size();\n        int max=nums[0];\n        vector<int> ans;\n        if(n==1) {\n             ans.push_back(nums[0]);\n             return ans;\n        }\n        if(k==1){\n            for(int i=0;i<n;i++){\n                ans.push_back(nums[i]);\n            }\n            return ans;\n        }\n       \n    \n        for(int i=0;i<k-1;i++){\n           if(nums[i]<nums[i+1]) max=nums[i+1];\n           else max=nums[i];\n          \n        }\n         ans.push_back(max);\n        for(int i=1,j=k;j<n;i++,j++){\n            if(nums[i]>max) max=nums[i];\n            if(nums[j]>max) max=nums[j];\n            ans.push_back(max);\n\n\n        }\n        return ans;\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330264168","body":"```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int size=trust.size();\n        vector<int> res,ans;\n        for(int i=0;i<size;i++){\n            res.push_back(trust[i][0]);\n            \n        }\n        \n        for(int i=1;i<n;i++){\n            for(int j=0;j<size;j++){\n                if(i=res[j]) break;\n                }\n            ans.push_back(i);\n        }\n        int p=ans.size();\n        if(p!=1) return -1;\n        else return ans[0];\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331625291","body":"```python\nclass Solution(object):\n    def possibleBipartition(self, N, dislikes):\n        graph = collections.defaultdict(list)\n        for u, v in dislikes: \n            graph[u].append(v)\n            graph[v].append(u)\n\n        color = {}  \n        def dfs(node, c = 0):  \n            if node in color:  \n                return color[node] == c  \n            color[node] = c \n            return all(dfs(nei, c ^ 1) for nei in graph[node]) \n\n        return all(dfs(node) for node in range(1, N+1) if node not in color) \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333565881","body":"```c++\nclass Solution {\npublic:\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        for(int i = 0; i < n; i++)\n        {\n            if(group[i] == -1)\n                group[i] = m++;\n        }\n        vector<vector<int>> itemgraph(n);\n        vector<vector<int>> groupgraph(m);\n        vector<int> itemIndegree(n, 0);\n        vector<int> groupIndegree(m, 0);\n        for(int i = 0; i < n; i++)\n        {\n            for(auto j : beforeItems[i])\n            {\n                itemgraph[j].push_back(i);\n                itemIndegree[i]++;\n                if(group[i] != group[j]) \n                {\t\n                    groupgraph[group[j]].push_back(group[i]);\n                    groupIndegree[group[i]]++;\n                }\n            }\n        }\n        vector<vector<int>> g_items(m);\n        \n        queue<int> q;\n        for(int i = 0; i < n; i++)\n            if(itemIndegree[i] == 0)\n                q.push(i);\n        int countItem = 0;\n        while(!q.empty())\n        {\n            int i = q.front();\n            q.pop();\n            countItem++;\n            g_items[group[i]].push_back(i);\n             for(auto j : itemgraph[i])\n            {\n                if(--itemIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countItem != n)\n            return {};\n        vector<int> g_order;\n        for(int i = 0; i < m; i++)\n            if(groupIndegree[i] == 0)\n                q.push(i);\n        int countgroup = 0;\n        while(!q.empty())\n        {\n            int g = q.front();\n            q.pop();\n            countgroup++;\n            g_order.push_back(g);\n            for(auto j : groupgraph[g])\n            {\n                if(--groupIndegree[j]==0)\n                    q.push(j);\n            }\n        }\n        if(countgroup != m)\n            return {};\n        vector<int> ans(n);\n        int idx = 0;\n        for(auto g : g_order)\n        {\n            for(auto i : g_items[g])\n                ans[idx++] = i;\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335053468","body":"```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int n=moves.length();\n        int x=0,y=0;\n        for(int i=0;i<n;i++){\n            if(moves[i]=='R') x++;\n            if(moves[i]=='L') x--;\n            if(moves[i]=='U') y++;\n            if(moves[i]=='D') y--;   \n        }\n        if(x==0&&y==0) return true;\n        else return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1356786453","body":"```java\r\nclass Solution(object):\r\n    def getOrder(self, tasks):\r\n        \"\"\"\r\n        :type tasks: List[List[int]]\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        from heapq import *\r\n        if not tasks:\r\n            return []\r\n \r\n        tasks = [(pair[1], index, pair[0]) for index, pair in enumerate(tasks)] \r\n        tasks.sort(key = lambda x: x[2]) \r\n \r\n        next_task_id = 0 \r\n        cur_time = tasks[0][2]\r\n        min_heap = []\r\n        res = []\r\n        while next_task_id < len(tasks) or min_heap:\r\n            while next_task_id < len(tasks) and tasks[next_task_id][2] <= cur_time:\r\n               \r\n                heappush(min_heap, tasks[next_task_id])\r\n                next_task_id += 1\r\n \r\n            if not min_heap:\r\n                \r\n                cur_time = tasks[next_task_id][2]\r\n            else\r\n                working_task = heappop(min_heap)\r\n                cur_time += working_task[0]\r\n                res.append(working_task[1])\r\n \r\n        return res\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336190238","body":"、、、Python\n\nclass Solution(object):\n    def numberOfRounds(self, loginTime, logoutTime):\n        \"\"\"\n        :type loginTime: str\n        :type logoutTime: str\n        :rtype: int\n        \"\"\"\n\n        login_hour, login_minute = loginTime.split(':')\n        start = int(login_hour) * 60 + int(login_minute)\n        logout_hour, logout_minute = logoutTime.split(':')\n        end = int(logout_hour) * 60 + int(logout_minute)\n        if start <= end:\n            return self.calc(start, end)\n        else:\n            return self.calc(start, 1440) + self.calc(0, end)\n    \n    def calc(self, start, end):\n        if start % 15 != 0:\n            start = start / 15 * 15 + 15\n        end = end / 15 * 15\n        return max(0, (end - start) / 15)\n、、、","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337465101","body":"```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        char [] ac = a.toCharArray(), bc = b.toCharArray();\n        int alen = a.length(), blen = b.length(), ans = alen + blen;\n        int [] c1 = new int[26], c2 = new int[26];\n        for (int i = 0; i < 26; i++) {\n            c1[i] = 0;\n            c2[i] = 0;\n        }\n        for (int i = 0; i < alen; i++)\n            c1[ac[i] - 'a']++;\n        for (int i = 0; i < blen; i++)\n            c2[bc[i] - 'a']++;\n        \n        int ans1 = alen - c1[0] + c2[0], ans2 = blen - c2[0] + c1[0];\n        for (int i = 1; i < 26; i++) {\n            ans = Math.min(ans, ans1);\n            ans = Math.min(ans, ans2);\n            ans1 = ans1 - c1[i] + c2[i];\n            ans2 = ans2 + c1[i] - c2[i];\n        }     \n        for (int i = 0; i < 26; i++)\n            ans = Math.min(ans, alen + blen - c1[i] - c2[i]);\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339590554","body":"```java\nclass Solution {\npublic:\n    int piv(vector<int>& nums, int l, int r) {\n        int a = nums[l], b = nums[(l+r)/2], c = nums[r];\n        if((a <= b && b <= c) || (c <= b && b <= a)) {\n            swap(nums[r], nums[(l+r)/2]);\n            return b;\n        }\n        if((b < a && a < c) || (c < a && a < b)) {\n            swap(nums[l], nums[r]);\n            return a;\n        }\n        return c;\n    }\n    void qsort(vector<int>& nums, int l, int r) {\n        if(l >= r) return;\n        int pivot = piv(nums, l, r);\n        cout<<l<<\",\"<<r<<\",\"<<pivot<<endl;\n        int less=l;\n        for(int i=l; i<r; i++) {\n            if(nums[i] < pivot) {\n                swap(nums[i], nums[less]);\n                less++;\n            }\n        }\n        int more = less;\n        for(int i=less; i<=r; i++) {\n            if(nums[i] == pivot) {\n                swap(nums[i], nums[more]);\n                more++;\n            }\n        }\n        qsort(nums, l, less-1);\n        qsort(nums, more, r);\n    }\n    vector<int> sortArray(vector<int>& nums) {\n        qsort(nums, 0, nums.size()-1);\n        // sort(nums.begin(), nums.end());\n        return nums;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341168624","body":"```java\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        for(int i=0;;i++){\n           int t=i*i;\n            if(t>x)\n            return i-1;\n        }\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342934505","body":"```javascript\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int low = 1, high = n, mid; \n        while(low < high) {\n            mid = low + ((high - low)>> 1);\n            if(isBadVersion(mid)) high = mid;\n            else low = mid + 1;    \n        }\n        return low;  \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344441475","body":"```python\r\nclass Solution {\r\npublic:\r\n    int reversePairs(vector<int>& nums) {\r\n        int left=0;\r\n        int right=nums.size()-1;\r\n        vector<int>temp(nums.size());\r\n        int res=0;\r\n        mergesort(nums,temp,left,right,res);\r\n        return res;\r\n    }\r\n\r\n    void mergesort(vector<int>&nums,vector<int>&temp,int left,int right,int &res){\r\n        if(left>=right){\r\n            return;\r\n        }\r\n        int mid=(left+right)/2;\r\n        mergesort(nums,temp,left,mid,res);\r\n        mergesort(nums,temp,mid+1,right,res);\r\n        int i=left;\r\n        int j=mid+1;\r\n        while(i<=mid&&j<=right){\r\n            if(nums[i]>(long)2*nums[j]){\r\n                res+=mid-i+1;\r\n                j++;\r\n            }\r\n            else{\r\n                i++;\r\n            }\r\n        }\r\n        i=left;\r\n        j=mid+1;\r\n        int index=0;\r\n        while(i<=mid&&j<=right){\r\n            if(nums[i]>nums[j]){\r\n                temp[index++]=nums[j++];\r\n            }\r\n            else{\r\n                temp[index++]=nums[i++];\r\n            }\r\n        }\r\n        while(i<=mid){\r\n            temp[index++]=nums[i++];\r\n        }\r\n        while(j<=right){\r\n            temp[index++]=nums[j++];\r\n        }\r\n        index=0;\r\n        while(left<=right){\r\n            nums[left++]=temp[index++];\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345146409","body":"```java\nclass Solution:\n    def rotateString(self, A: str, B: str) -> bool:\n     \n        n = len(A)\n        \n        if A ==\"\" and B ==\"\":\n            return True\n        \n        for i in range(n):\n           \n            if B == A[i:] +A[0:i]:\n                return True             \n        return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345465986","body":"```java\nclass Solution {\npublic:\n    int minabsk(vector<int>& nums,int k) {\n        int size=nums.size(),ans=0;\n        vector<int> res;\n        for(int i=0;i<size;i++){\n            for(int j=i;j<size;j++)\n            res.push_back(abs(nums[i]-nums[j]));\n        }\n        sort(res.begin(),res.end());\n        for(int i=0;i<res-1.size();i++){\n            if(res[i+1]=res[i]) continue;\n            else ans++;\n            if(ans==k) return res[i];\n        }\n        return ans;\n    }\n};\n```\n\nTC:O(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346075454","body":"```java\r\n\r\n\r\nclass Solution {\r\npublic:\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        UnionFind unionFind(n*n);\r\n        vector<int> height(n*n);\r\n        for(int loc = 0; loc < n*n; loc++) {\r\n            height[grid[loc / n][loc % n]] = loc;\r\n        }\r\n\r\n        for(int ans = 0; ans < n*n; ans++) {\r\n            int location = height[ans];\r\n            int i = location / n;\r\n            int j = location % n;\r\n            if(i+1 < n and grid[i+1][j] <= ans) {\r\n                unionFind.merge(location, (i+1)*n + j);\r\n            }\r\n            if(i-1 >= 0 and grid[i-1][j] <= ans) {\r\n                unionFind.merge(location, (i-1)*n + j);\r\n            }\r\n            if(j+1 < n and grid[i][j+1] <= ans) {\r\n                unionFind.merge(location, i*n + j+1);\r\n            }\r\n            if(j-1 >= 0 and grid[i][j-1] <= ans) {\r\n                unionFind.merge(location, i*n + j-1);\r\n            }\r\n\r\n            if(unionFind.find(0) == unionFind.find(n*n-1)) {\r\n                return ans;\r\n            }\r\n        }\r\n        return n*n-1;\r\n    }\r\n\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347633334","body":"```java\nclass Solution {\npublic:\n    int maxVowels(string s, int k) {\n        int size=s.size();\n        int max=0,l=0;\n        for(int i=0;i<k;i++){\n            if(s[i]=='a'||s[i]=='e'||s[i]=='i'|| s[i]=='o'|| s[i]=='u') l++;\n           \n        }\n        max=l;\n       \n        if(size>=1){\n        for(int i=1,j=k;j<size;j++,i++){\n            if(s[i-1]=='a'||s[i-1]=='e'||s[i-1]=='i'||s[i-1]=='o'||s[i-1]=='u') l--;\n\n            if(s[j]=='a'||s[j]=='e'||s[j]=='i'||s[j]=='o'||s[j]=='u') l++;\n              max=max>l?max:l;\n                 }\n          }\n        return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350206465","body":"```java\nclass Solution {\n    private double total=0;\n    private double below=0.0;\n    public double new21Game(int N, int K, int W) {\n\n        count(0 , N, K, W);\n        return below/total;\n    }\n    public void count(int temp , int N , int K , int W){\n        if(temp>=K){\n            total++;\n            if(temp<=N){\n                below++;\n            }\n            return;\n        }else{\n            for(int i=1 ; i<=W ; i++){\n                count(temp+i , N , K , W);\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352396217","body":"```java\npublic List<Integer> findAnagrams(String s, String p) {\n    int sLen = s.length();\n    int pLen = p.length();\n    List<Integer> res = new ArrayList<>();\n    int[] pCounts = new int[26];\n    for (int i = 0; i < pLen; i++) {\n        pCounts[p.charAt(i) - 'a']++;\n    }\n\n    int left = 0;\n    int right = 0;\n    while (right < sLen) \n        int inWin = s.charAt(right) - 'a'\n        pCounts[inWin]--;\n        while (pCounts[inWin] < 0) {\n            int outWin = s.charAt(left++) - 'a';\n            pCounts[outWin]++;\n        }\n\n        if (right - left + 1 == pLen) {\n            res.add(left);\n        }\n\n        right++;\n    }\n\n    return res;\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1353861214","body":"```python\nlass Solution:\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\n        from collections import Counter\n        t = Counter(t)\n        lookup = Counter()\n        start = 0\n        end = 0\n        min_len = float(\"inf\")\n        res = \"\"\n        while end < len(s):\n            lookup[s[end]] += 1\n            end += 1\n            #print(start, end)\n            while all(map(lambda x: lookup[x] >= t[x], t.keys())):\n                if end - start < min_len:\n                    res = s[start:end]\n                    min_len = end - start\n                lookup[s[start]] -= 1\n                start += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356056731","body":"```java\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356785267","body":"```java\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        res = []\n        def count(i):\n            res = 0\n            while i != 0:\n                i = i & (i - 1)\n                res += 1\n            return res\n        for i in range(12):\n            c = count(i)\n            if c == num:\n                res.append(\"%d:%02d\" %(i, 0))\n                continue\n            for j in range(60):\n                s = count(j)\n                if (s + c) == num:\n                    res.append(\"%d:%02d\" %(i, j))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357102097","body":"```c++\npublic int totalNQueens(int n) {\n    List<Integer> ans = new ArrayList<>();\n    boolean[] cols = new boolean[n]; \n    boolean[] d1 = new boolean[2 * n]; \n    boolean[] d2 = new boolean[2 * n]; \n   return backtrack(0, cols, d1, d2, n, 0);\n}\n\nprivate int backtrack(int row, boolean[] cols, boolean[] d1, boolean[] d2, int n, int count) { \n    if (row == n) {\n        count++;\n    } else {\n        for (int col = 0; col < n; col++) {\n            int id1 = row - col + n; \n            int id2 = row + col;\n            if (cols[col] || d1[id1] || d2[id2])\n                continue;\n            cols[col] = true;\n            d1[id1] = true;\n            d2[id2] = true;\n            count = backtrack(row + 1, cols, d1, d2, n, count);\n            cols[col] = false;\n            d1[id1] = false;\n            d2[id2] = false;\n        }\n\n    }\n    return count;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358783115","body":"```java\r\nclass Solution {\r\n   \r\n    public int maxAreaOfIsland(int[][] grid) {\r\n        if (grid.length == 0) {\r\n            return 0;\r\n        }\r\n        int row = grid.length;\r\n        int col = grid[0].length;\r\n        int maxCount = 0;\r\n        for (int i = 0; i < row; i++) {\r\n            for (int j = 0; j < col; j++) {\r\n                if (grid[i][j] == 1) {\r\n                    maxCount = Math.max(dfs(grid, i, j), maxCount);\r\n                }\r\n            }\r\n        }\r\n        return maxCount;\r\n    }\r\n\r\n    private int dfs(int[][] grid, int i, int j) {\r\n        if (i < 0 || i >= grid.length) {\r\n            return 0;\r\n        }\r\n        if (j < 0 || j >= grid[0].length) {\r\n            return 0;\r\n        }\r\n       \r\n        if (grid[i][j] == 1) {\r\n            int ans = 1;\r\n            grid[i][j] = 0;\r\n            int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\r\n            for (int[] dir : dirs) {\r\n                ans += dfs(grid, i + dir[0], j + dir[1]);\r\n            }\r\n            return ans;\r\n        }\r\n        return 0;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360388421","body":"```c\nclass Solution {\n    public int numEnclaves(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        \n\n        for(int x = 0; x < m; ++x){\n            if(grid[x][0] == 1){\n                dfs(grid, x, 0);\n            }\n\n            if(grid[x][n - 1] == 1){\n                dfs(grid, x, n - 1);\n            }\n        }\n        \n       \n        for(int y = 0; y < n; ++y){\n            if(grid[0][y] == 1){\n                dfs(grid, 0, y);\n            }\n\n            if(grid[m - 1][y] == 1){\n                dfs(grid, m - 1, y);\n            }\n        }\n\n\n        int count = 0;\n        for(int x = 0; x < m; ++x){\n            for(int y = 0; y < n; ++y){\n                if(grid[x][y] == 1){\n                    ++count;\n                }\n            }\n        }\n\n  \n        return count;\n    }\n\n    private void dfs(int[][] grid, int x, int y){\n       \n        if(x >= grid.length || x < 0 || y >= grid[0].length || y < 0 || grid[x][y] == 0){\n            return;\n        }\n        \n       \n        grid[x][y] = 0;\n        \n        \n        dfs(grid, x + 1, y);\n        dfs(grid, x - 1, y);\n        dfs(grid, x, y + 1);\n        dfs(grid, x, y - 1);\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363967431","body":"```c\npublic void preOrderTraverse2(TreeNode root) {\n\t\tLinkedList<TreeNode> stack = new LinkedList<>();\n\t\tTreeNode pNode = root;\n\t\twhile (pNode != null || !stack.isEmpty()) {\n\t\t\tif (pNode != null) {\n\t\t\t\tSystem.out.print(pNode.val+\"  \");\n\t\t\t\tstack.push(pNode);\n\t\t\t\tpNode = pNode.left;\n\t\t\t} else { //pNode == null && !stack.isEmpty()\n\t\t\t\tTreeNode node = stack.pop();\n\t\t\t\tpNode = node.right;\n\t\t\t}\n\t\t}\n\t}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364437657","body":"```c\nvar minCostClimbingStairs = function(cost) {\n    cost.push(0)\n    let arr = [cost[0],cost[1]];\n    for(let i=2;i<cost.length;i++){\n        arr[i]=Math.min(arr[i-1],arr[i-2])+cost[i];\n    }\n    return arr.pop();\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364630048","body":"```c\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int maxl=0;\n        \n        int n=nums.size();\n        if(n==1) return nums[0];\n        int maxr=0,max;\n        if(n==2 && maxr>maxl) return nums[1];\n        if(n==2 && maxr<maxl) return nums[0];\n        \n        for(int i=0;i<n;i++){\n            int curval=nums[i]+maxl;\n            if(curval>maxr) {\n                max=curval;\n                maxl=maxr;\n                maxr=max;\n                \n                \n            }\n            else{\n                max=maxr;\n                maxl=maxr;\n\n           \n               \n            }\n            \n\n        }\n        \n     return max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364878631","body":"```c\nclass Solution {\n   public int findNumberOfLIS(int[] nums) {\n        int len = nums.length;\n        if(len <2){return len;}\n        int[] dp = new int[len];\n        int res=0;\n        int maxCount=0;\n        int[] counts = new int[len];\n        for (int i = 0; i < dp.length; i++) {\n            dp[i] = 1;\n            counts[i] = 1;\n \n        }\n \n        for (int i = 0; i < nums.length; i++) {\n            for (int j = 0; j < i; j++) {\n \n                if (nums[i] >nums[j]){\n                    if (dp[j]+1 >dp[i]){\n                     \n                        counts[i]= counts[j];\n                    }else if (dp[j]+1 ==dp[i]){\n                      \n                        counts[i]+=counts[j];\n                    }\n \n                    dp[i] = Math.max(dp[i],dp[j]+1);\n                    \n                }\n \n                if (dp[i] > maxCount){ \n                    maxCount = dp[i];\n                }\n            }\n \n        }\n \n        for (int i = 0; i < dp.length; i++) {\n            if (dp[i]==maxCount){\n                res+=counts[i];\n            }\n        }\n \n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365581440","body":"```java\nclass Solution {\n    public int longestCommonSubsequence(String t1, String t2) {\n        char[] c1 = t1.toCharArray();\n        char[] c2 = t2.toCharArray();\n        int[][] dp = new int[c1.length + 1][c2.length + 1];\n        for(int i = 1; i <= c1.length; ++i){\n            for(int j = 1; j <= c2.length; ++j){\n                \n                if(c1[i - 1] == c2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                   \n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[c1.length][c2.length];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366392251","body":"```c\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> ans;\n        ans[0][0]=0;\n        for(int i=1;i<m;i++) ans[0][i]=1;\n        for(int i=1;i<n;i++) ans[i][0]=1;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                ans[i][j]=ans[i-1][j]+ans[i][j-1];\n            }\n        }\n         return ans[m][n];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1366882428","body":"```python\nclass Solution(object):\n    def knightProbability(self, N, K, r, c):\n        \"\"\"\n        :type N: int\n        :type K: int\n        :type r: int\n        :type c: int\n        :rtype: float\n        \"\"\"\n        dp = [[0 for i in range(N)] for j in range(N)]\n        dp[r][c] = 1\n        directions = [(1, 2), (1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1), (-1, 2), (-1, -2)]\n        for k in range(K):\n            new_dp = [[0 for i in range(N)] for j in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    for d in directions:\n                        x, y = i + d[0], j + d[1]\n                        if x < 0 or x >= N or y < 0 or y >= N:\n                            continue\n                        new_dp[i][j] += dp[x][y]\n            dp = new_dp\n        return sum(map(sum, dp)) / float(8 ** K)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367447199","body":"```python\r\nclass Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        import functools\r\n        if  desiredTotal <= maxChoosableInteger: return True\r\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal: return False\r\n        \r\n        @functools.lru_cache(None)\r\n        def dfs(used, desiredTotal):\r\n            for i in range(maxChoosableInteger):\r\n                cur = 1 << i\r\n                if cur & used == 0:\r\n                    if desiredTotal <= i + 1 or not dfs(cur | used, desiredTotal - i - 1):\r\n                        return True\r\n            return False\r\n        \r\n        return dfs(0, desiredTotal)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368113030","body":"```c\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum=0;\n        for(int x=0;x<nums.size();x++) sum+=nums[x];\n        vector<bool> f(sum+1);\n        if(sum%2!=0) return false;\n        sum/=2;\n        f[0]=1;\n       for(int x=0;x<nums.size();x++){\n            for(int j=sum;j>=nums[x];j--){\n                f[j]=f[j]|f[j-nums[i]];\n            }\n        }\n        \n    return f[sum];\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368350252","body":"```c++\nclass Solution {\n      int result = 0;\npublic:\n    int findTargetSumWays(vector<int>& nums, int target ) {\n    \n        findTargetSumWays(nums, target, 0, 0);\n      \n        return result;\n    }\n\n   \n   void findTargetSumWays(vector<int> nums, int S, int index, int sum) {\n       \n        if (index == nums.size()) {\n           \n            if (sum == S) {\n                result++;\n            }\n            return;\n        }\n\n        \n        findTargetSumWays(nums, S, index + 1, sum + nums[index]);\n        findTargetSumWays(nums, S, index + 1, sum - nums[index]);\n    }\n\n   \n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368663127","body":"```c\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount+1,amount*2);\n        dp[0]=0;\n        for(int i=1;i<=amount;i++){\n            for(auto x:coins){\n                if(i<x) continue;\n                dp[i]=min(dp[i],dp[i-x]+1);\n            }\n        }\n       \n       return dp[amount]==amount*2?-1:dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369306792","body":"```c\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount+1);\n        dp[0]=1;\n        for(auto x:coins){\n            for(int i=x;i<=amount;i++){\n                dp[i]=dp[i-x]+dp[i];\n            }\n        }\n\n        return dp[amount];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370613761","body":"```c\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        int m=g.size(),n=s.size(),cnt=0;\n        sort(g.begin(),g.end());\n        sort(s.begin(),s.end());\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(s[j]>=g[i]) {\n                    cnt++;\n                   s.erase(s.begin()+j);\n                   break;\n                    }\n\n            }\n        }\n        return cnt;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371715749","body":"```c\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        int n=intervals.size();\n        vector<int> dp(n,1);\n        sort(intervals.begin(),intervals.end());   // sort\n        for(int i=1;i<n;i++){\n            for(int j=i-1;j>=0;j--){\n                if(intervals[j][1]<=intervals[i][0]){   // search the first point\n                   dp[i]=dp[j]+1;                            // renew\n                   break;\n                }\n               \n            }\n            \n        }\n        sort(dp.begin(),dp.end());\n        return(n-dp[n-1]);\n \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1372956146","body":"```c\nclass Solution {    //greedy\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        int n=people.size(),ans=0;\n        sort(people.begin(),people.end());\n        for(int i=n-1;i>=0;i--){\n             if(people[i]==limit) {\n                 ans++;\n                 people.erase(people.begin()+i);\n                 n--;\n                 continue;\n                 }\n             for(int j=0;j<=i-1;j++){\n                 int cnt=0;\n                 if(people[i]+people[0]>limit){\n                     ans++;\n                    people.erase(people.begin()+i);\n                    n--;\n                    break;\n\n                 }\n                 if(people[i]+people[j]==limit){\n                     ans++;\n                    people.erase(people.begin()+i);\n                     people.erase(people.begin()+j);\n                    n--;\n                    break;\n\n                 }\n                 if(people[i]+people[j]>limit){\n                     ans++;\n                      people.erase(people.begin()+i);\n                      people.erase(people.begin()+j-1);\n                     i=n-1;\n                    \n                     break;\n                 }\n                 if(cnt==i-1){\n                    ans++;\n                      people.erase(people.begin()+i);\n                      people.erase(people.begin()+i-1); \n                      n=n-2;\n                 }\n              }\n              \n        }\n        return ans;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374119192","body":"```c\r\nclass Solution {\r\npublic:\r\n    int numTrees(int n) {\r\n     vector<int> dp(n+1);\r\n     dp[0]=1;\r\n     dp[1]=1;\r\n     for(int i=2;i<=n;i++)\r\n     {\r\n         for(int j=0;j<i;j++)\r\n         {\r\n             dp[i]+=dp[j]*dp[i-j-1];\r\n\r\n         }\r\n     }return dp[n];\r\n\r\n        \r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374644582","body":"```\nclass Solution {\nprivate:\n     ListNode* mergetwolists(ListNode* a,ListNode* b){\n         ListNode head(0),*tail=&head;\n         while(a&&b){\n             if(a->val<b->val){\n                 tail->next=a;\n                 a=a->next;\n             else{\n                 tail->next=b;\n                 b=b->next;\n                \n                \n             \n             tail=tail->next;\n         }\n         tail->next=a?a:b;\n         return head.next;\n         \n         } \npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n       for(int k=lists.size();k>1;k=(k+1)/2){\n        for(int i=0;i<k/2;i++){\n         list[i]=mergetwolists(lists[i],lists[k-1-i])   \n        }\n    }\n        return lists[0];\n\n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375092070","body":"```c\nclass Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n       if(n==1) return {1};\n       vector<int> res;\n       vector<int> s1=beautifulArray((n+1)/2);\n       vector<int> s2=beautifulArray(n/2);\n       for(auto x:s1) res.push_back(x+x-1);\n       for(auto x:s2) res.push_back(x+x);\n       return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376652710","body":"```c\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        vector<int> res;\n        int n=nums.size();\n        sort(nums.begin(),nums.end());\n        int cnt=0;\n        if(n==2){\n            if(nums[0]!=nums[1]) return nums;\n        }\n        if(nums[0]!=nums[1]){ \n            cnt++;\n            res.push_back(nums[0]);\n            }\n        \n        for(int i=0,j=1,k=2;k<nums.size();){\n           if(nums[i]!=nums[j]&&nums[j]!=nums[k]) {\n               cnt++;\n               res.push_back(nums[j]);\n               if(k==n-1) {\n                   res.push_back(nums[k]);\n                   return res;\n                }\n               i=i+1;\n               j=j+1;\n               k=k+1;\n              \n               if(cnt==2) return res;\n               continue;\n           }\n           if(k==n-1&&nums[k]!=nums[j]) {\n               res.push_back(nums[k]);\n               return res;\n               }\n           else {\n               i++;\n               j++;\n               k++;\n           }\n        }\n        return res;\n    }\n};\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1377583568","body":"```c\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        int n=nums.size();\n        vector<vector<int>> result;\n        vector<int> t;\n        for(int i=0;i<(1 << n);i++){\n           t.clear();\n           for(int j=0;j<n;j++){\n               if(i&(1<<j)){\n                   t.push_back(nums[j]);\n               }\n           }\n           result.push_back(t);\n        }\n        return result;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380597373","body":"```c\nclass Trie {\npublic:\n    vector<string> trie;   \n    Trie() {\n       \n    }\n    \n    void insert(string word) {\n     trie.push_back(word); \n    \n    }\n    \n    bool search(string word) {\n      for(int i=0;i<trie.size();i++){\n          if(trie[i]==word) return true;\n      }  \n      return false;\n    }\n    \n    bool startsWith(string prefix) {\n         if(trie.size()==0) return false;\n         for(int i=0;i<trie.size();i++){\n                 int cnt=0;\n             for(int k=0;k<prefix.length();k++){\n                 if(prefix[k]==trie[i][k]) {\n                     cnt++;\n                     continue;\n                }\n                 else break;\n             }\n             if(cnt==prefix.length()) return true;\n         }   \n         return false;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1380796876","body":"```c\nclass MapSum {\npublic:\n    map<string,int> mapsum;\n    MapSum() {\n        \n    }\n    \n    void insert(string key, int val) {\n        mapsum[key]=val;\n    }\n    \n    int sum(string prefix) {\n        int sum=0;\n     for(auto [x,val]:mapsum){\n         if(x.substr(0,prefix.length())==prefix){\n            sum+=val;\n         }\n     }    \n        return sum; \n     }   \n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382165340","body":"```c\nclass Solution {\npublic:\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        \n          int n=smalls.size();\n          vector<vector<int>> ans(n,vector<int>());\n          for(int k=0;k<n;k++){\n              for(int j=0;j<big.size();j++){\n                  for(int i=0;i<smalls[k].size();i++){\n                      if(smalls[k][i]!=big[j]) {\n                          j=j-i;\n                          break;\n                      }\n                      else j++;\n                      if(i==smalls[k].size()-1) {\n                          ans[k].push_back(j-smalls[k].length());\n                           j=j-i-1;\n                          break;\n                          \n                      }\n                  }\n              }\n          }\n          return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1382867715","body":"```c\nclass Solution {\npublic:\n    void dfs(vector<vector<int>>& isConnected, vector<int>& visited, int cities, int i) {\n        for (int j = 0; j < cities; j++) {\n            if (isConnected[i][j] == 1 && !visited[j]) {\n                visited[j] = 1;\n                dfs(isConnected, visited, cities, j);\n            }\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int cities = isConnected.size();\n        vector<int> visited(cities);\n        int provinces = 0;\n        for (int i = 0; i < cities; i++) {\n            if (!visited[i]) {\n                dfs(isConnected, visited, cities, i);\n                provinces++;\n            }\n        }\n        return provinces;\n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298276676","body":"```java\n/**\n    TC: O(max(N,logk)), N为数组的长度\n    SC: O(max(N,logk))\n*/\n\n// Method 2: 将 加数 k 整个 加入数组表示的数的最低位\n//           3 + 912 = 915, 5 留在当前这一位，将 910 / 10 = 91 以进位的形式加入下一位\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        for (int i = N - 1; i >= 0; i--){\n            int sum = num[i] + k;\n            res.add(0, sum % 10);\n            k = sum / 10;   // 更新 k 存进位 carry\n        }\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n\n// Method 1: 两个数拆解后 同时 从后往前逐位相加\nclass Solution1 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        \n        int i = N - 1;\n        int sum = 0, carry = 0;\n        while (i >= 0 || k > 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299355292","body":"```java\n/**\n    思路:     对每一个 i 从中心扩散找最近的 C     O(n^2)\n        ==>  空间换时间, 存储所有 c 的位置       O(nk), 出现 k 次\n        ==>  Greedy, 只关心最近的 C ==> 正向遍历+反向遍历\n    ------------------------------------------------------------------\n    实现:\n        两个数组 left 和 right 分别记录每个字符左/右侧出现的最后一个 C 字符的下标\n        同时比遍历这两个数组, 计算距离最小值\n\n    优化:    \n        1. 只需要最近的 C, 所以看情况可以覆盖掉第一个数组的值\n            case 1. 字符的左侧没有出现过 C 字符\n            case 2. i - left > right - i\n        2. 直接记录 C 与当前字符的距离, 而不是 C 的下标, 还可以省去最后遍历计算距离的过程\n                \n    TC: O(N), SC: O(1)      1ms\n*/\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        dist[0] = s.charAt(0) == c ? 0 : N;\n        for (int i = 1; i < N; i++) {\n            dist[i] = s.charAt(i) == c ? 0 : dist[i - 1] + 1;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            dist[i] = Math.min(dist[i], dist[i + 1] + 1);  // 左侧距离 > 右侧距离, 未遇到 C 默认距离为 N\n        }\n        return dist;\n    }\n}\n\n/**\n    sliding window: 把 c 看成 s 的分割线\n    XXXX | XXXX | XXXXXX\n    \n    TC: O(N), SC: O(1)\n*/\nclass Solution1 {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        \n        int l = s.charAt(0) == c ? 0 : N;\n        int r = s.indexOf(c);\n        for (int i = 0; i < N; i++) {\n            dist[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n            if (i == r) {\n                l = r;\n                r = s.indexOf(c, l + 1);\n            }\n        }\n        return dist;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301193737","body":"```java\n/**\n    因为 stack 的 maxSize 限定 很直观能想到用 arr 解决\n    问题在于 如果让 increment 的 TC 能从 O(k) 降到 O(1)\n    \n    可以添加一个辅助数组 add, 单独储存每个元素的增量\n        1. increment: 将栈底 k 个元素+val, 则将 add[k - 1] += val\n        2. pop: 栈顶值 + add[top], 在次之后, add[top - 1] 累加 add[top]的增量\n                    也就是. add 的值在 pop 之后会向下传递, 自身则清零\n    \n    有点像差分数组的变种\n    这样所有操作 TC 都是 O(1)\n*/\n\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    int size;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.add = new int[maxSize];\n        this.top = -1;\n        this.size = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < size - 1)\n            stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        int res = add[top] + stack[top];\n        if (top != 0) add[top - 1] += add[top];\n        add[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        // for (int i = 0; i < k && i <= top; i++) {\n        //     stack[i] += val;\n        // }\n        if (top == -1) return;\n        add[Math.min(k - 1, top)] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302804971","body":"```java\n/**\n    TC: O(n), SC: O(n)\n*/\n\n// Method 1: iterative\nclass Solution1 {\n    public String decodeString(String s) {\n        int multi = 0;\n        StringBuilder sb = new StringBuilder();\n        \n        Deque<Integer> multi_stack = new ArrayDeque<>();\n        Deque<String> chars_stack = new ArrayDeque<>();\n        \n        for (char c : s.toCharArray()) {\n            if (c >= '0' && c <= '9') {                 // 1. 倍数\n                multi = multi * 10 + (c - '0');\n            } else if (c >= 'a' && c <= 'z') {          // 2. 字符\n                sb.append(c);\n            } else if (c == '[') {                      // 3. 入栈\n                multi_stack.addLast(multi);             // 接下来[sb]要重复的次数\n                chars_stack.addLast(sb.toString());     // 之前的sb\n                multi = 0;                              // 重置临时变量\n                sb = new StringBuilder();\n            } else { // if (c == ']')                   // 4. 出栈\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = multi_stack.pollLast();\n                for (int i = 0; i < cur_multi; i++)\n                    tmp.append(sb);                     // sb * multi次\n                sb = new StringBuilder(chars_stack.pollLast() + tmp);   // 把之前的和这一次的连起来\n            }\n        }\n        return sb.toString();\n    }\n}\n\n// Method 2: recursive\n//      先解析数字 x, 解析到了左括号 [，递归向下解析后面的内容，遇到对应的右括号就返回 ]\n//      [] 解析结束后, 再继续 解析] 右边的内容\nclass Solution {\n    int i = 0;\n    public String decodeString(String s) {\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            char c = s.charAt(i);\n            i++;\n            if (Character.isLetter(c)) {\n                sb.append(c);\n            } else if (Character.isDigit(c)) {\n                count = count * 10 + (c - '0');\n            } else if (c == ']') {      \n                break;\n            } else if (c == '[') {\n                String repeat = decodeString(s);\n                while (count > 0) {\n                    sb.append(repeat);\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304345014","body":"```java\n/**\n    双栈实现 Queue\n    \n    push时压入 input 栈\n    peek 或者 peek 时, 如果 output 栈为空, 那么把 input 栈 pop 出来到 output\n    \n    TC: push: O(1), pop/peek: amortized O(1)\n    SC: O(N)\n*/\nclass MyQueue {\n    Stack<Integer> input = new Stack<>();\n    Stack<Integer> output = new Stack<>();\n\n    public MyQueue() {\n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.pop();\n    }\n    \n    public int peek() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304648451","body":"```java\n/**\n    思路: 和 769 类似\n    块的最大值呈升序排列, 维护一个单调递增栈 保存每个块的最大值\n        如果当前栈为空 || 栈顶 比当前小, 将当前元素 push 进去\n        如果当前栈非空 && 栈顶比当前大, 栈顶应该是目前块的最大值, pop 出来, \n                                    把所有比当前大的元素也 pop 出来\n                                    再把真正的最大值 pop 回去\n    TC: O(N), SC: O(N)\n*/\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] stack = new int[arr.length];\n        int top = -1;\n        for (int i : arr) {\n            if (top != -1 && stack[top] > i) {\n                int max = stack[top--];\n                while (top != -1 && stack[top] > i)\n                    top--;\n                stack[++top] =  max;\n            } else {\n                stack[++top] = i;\n            }\n        }\n        return top + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305036285","body":"```java\n/**\n    思路: 走 k 步, 由于 k 可能很大, 希望 k = k % N\n        1. 遍历, 计算链表长度N, 找到尾结点 tail\n        2. 断开两种方式\n            - 找到新的头结点, 连接旧头尾, 断开得到新的 head, 新的 tail 指向 null\n            - 先连成环, 再找到新的头尾, 断开\n            \n        (用 dummy head 的写法也很有趣)\n    TC: O(n) SC: O(1)\n*/\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int N = 0;\n        for (; fast.next != null; N++)\n            fast = fast.next;\n        for (int i = N - k % N; i > 0; i--) \n            slow = slow.next;\n\n        fast.next = dummy.next; \n        dummy.next = slow.next;\n        slow.next = null;\n    \n        return dummy.next;\n    }\n}\n\nclass Solution2 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        k %= N;\n        if (k == 0) return head;\n        tail.next = head;\n        for (int i = 0; i < N - k; i++) {\n            tail = tail.next;\n        }\n        ListNode newHead = tail.next;\n        tail.next = null;\n        return newHead;\n    }\n}\n\nclass Solution1 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        // 1. 计算链表长度, 并找到 tail 节点\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        // 2. 更新 k\n        k %= N;\n        if (k == 0) return head;\n        // 3. 因为头结点会是倒数 第k 个, 那么前面就有 N - k个节点, ptr 要移动 N - k - 1次\n        ListNode ptr = head;\n        for (int i = 0; i < N - k - 1; i++) {\n            ptr = ptr.next;\n        }\n        // 4. 先把 tail 指向原来的 head, 更新 head, 最后真正的 tail 也就是 ptr的 next 指向 null\n        tail.next = head;\n        head = ptr.next;\n        ptr.next = null;\n        return head;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305948463","body":"```java\n// 思路: 两两翻转 TC: O(n) SC: O(1)\n// 像这种多次对链表进行相同操作, iterative 的写法用 dummy 节点会很方便\n\n// recursive\nclass Solution1 {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) \n            return head;\n        \n        ListNode first = head;\n        ListNode second = head.next;\n        ListNode others = head.next.next;\n        \n        second.next = first;\n        first.next = swapPairs(others);\n        return second;\n    }\n}\n\n// iterative\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode tmp = dummy;\n        while (tmp.next != null && tmp.next.next != null) {\n            ListNode first = tmp.next;\n            ListNode second = tmp.next.next;\n            tmp.next = second;\n            first.next = second.next;\n            second.next = first;\n            tmp = first;\n        }\n        return dummy.next;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308067264","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// Approach 2: 中序遍历结果是链表本身:     TC: O(n), SC: O(logn)\n//             不直接找到中点的值, 而是构造完左子树, 指针自然指向中间结点, 再构造右子树\nclass Solution {\n    ListNode cur;\n    \n    public TreeNode sortedListToBST(ListNode head) {\n        cur = head;\n        int len = 0;\n        for (ListNode p = head; p != null; p = p.next)\n            len++;\n        return inOrderBuildTree(0, len - 1);\n    }\n    \n    private TreeNode inOrderBuildTree(int left, int right) {\n        if (left > right) return null;\n        int mid = left + (right - left) / 2;\n        \n        TreeNode leftTree = inOrderBuildTree(left, mid - 1);    // 构造左子树\n        TreeNode root = new TreeNode(cur.val);                  // 构造根节点\n        cur = cur.next;\n        TreeNode rightTree = inOrderBuildTree(mid + 1, right);  // 构造右子树\n        \n        root.left = leftTree;\n        root.right = rightTree;\n        return root;\n    }\n}\n\n// Approach 1: 快慢指针找链表中点    TC: O(nlogn), SC: O(logn)\nclass Solution1 {\n    public TreeNode sortedListToBST(ListNode head) {\n        return build(head, null);\n    }\n    \n    // 把链表左闭右开区间 [begin, end) 的节点构造成 BST\n    private TreeNode build(ListNode begin, ListNode end) {\n        if (begin == end) \n            return null; // 左闭右开 -> 空集\n        ListNode mid = getMid(begin, end);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = build(begin, mid);\n        root.right = build(mid.next, end);\n        return root;\n    }\n    \n    private ListNode getMid(ListNode begin, ListNode end) {\n        ListNode slow = begin, fast = begin;\n        while (fast != end && fast.next != end) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309225501","body":"```java\n/**\n    TC: O(N + M), SC: O(1)\n    Approach 2: 计算两 LL 的长度, 长的那个先走差值, 然后再同时走\n*/\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int lenA = 0, lenB = 0;\n        for (ListNode p = headA; p != null; p = p.next) lenA++;\n        for (ListNode p = headB; p != null; p = p.next) lenB++;\n        ListNode p1 = headA, p2 = headB;\n        if (lenA > lenB) {\n            for (int i = 0; i < lenA - lenB; i++) p1 = p1.next;\n        } else {\n            for (int i = 0; i < lenB - lenA; i++) p2 = p2.next;\n        }\n        while (p1 != p2) {\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n\n/**\n    Approach 1: 双指针 遍历AB 两个LL\n    p1 遍历完链表 A 后遍历链表 B，p2 遍历完链表 B 后开始遍历链表 A\n    这样可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1\n    \n    A:    A A C C C B B B | C C C\n    B:    B B B C C C A A | C C C\n*/\nclass Solution1 {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode p1 = headA, p2 = headB;\n        while (p1 != p2) {\n            if (p1 == null) p1 = headB;\n            else            p1 = p1.next;\n            if (p2 == null) p2 = headA;\n            else            p2 = p2.next;\n        }\n        return p1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310938224","body":"```java\n/**\n    找到 LL 环的入口, 如果无环, 返回 null\n    \n    思路: 快慢指针, 快指针有环会追上慢指针 相遇\n    \n      a     b \n    -----------|    假设慢指针走 x 步, 快指针是 2x, \n        |      |    head 到环入口有 a 个节点, 环有 b 个节点\n        -------| c          \n        \n    x = a + b, 2x = a + b + c + b \n    2a + 2b = a + c + 2b\n    a = c\n    \n    所以 当 slow fast 相遇后, 我们再额外使用一个指针 ptr 指向 head\n    ptr 和 slow 和同时移动, 他们会在环的入口处相遇\n    \n    TC: O(n), SC: O(1)\n*/\nclass Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        \n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) break;\n        }\n        // 无环\n        if (fast == null || fast.next == null)\n            return null;\n        // 有环\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312319429","body":"```java\n/**\n    LRU: 难点在于evict the least recently used key.\n    并且查询, 更新, 删除要 O(1) 完成\n    \n    那么数据结构的要求\n    1. 有时序    <== 删除最久未使用的 key\n    2. Hash     <== 快速找到某个 key 是否存在 \n    3. LL       <== 使用后更新在列表中的位置, 快速删除和添加\n    \n    既可以用LinkedHashMap直接实现, 也可以通过 hashmap 辅助双向链表实现,\n        双向链表 按 使用顺序 储存键值对, hashmap 映射 数据在链表中的位置\n    \n*/\n/**\n    Method 2: DoublyLinkedList + HashMap    60ms 95.39%\n*/\nclass LRUCache {\n    // 1. Node\n    class Node {\n        int key, val;\n        Node next, prev;\n        \n        public Node(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    // 2. DoublyLinkedList      head -- ...nodes... --tail\n    //      添加/更新在 LL 末尾, 删除任意节点, 删除 oldest 返回新的 head\n    class DLL {\n        Node head, tail;\n        int size;\n        \n        public DLL() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n            size = 0;\n        }\n        \n        public void addLast(Node x) {\n            x.next = tail;\n            x.prev = tail.prev;\n            tail.prev.next = x;\n            tail.prev = x;\n            size++;\n        }\n        \n        public void remove(Node x) {\n            x.prev.next = x.next;\n            x.next.prev = x.prev;\n            size--;\n        }\n        \n        public Node removeFirst() {\n            if (head.next == tail) return null;\n            Node first = head.next;\n            remove(first);\n            return first;\n        }\n    }\n    // 3. HashMap + DLL ==> Cache\n    // Hashmap 要存 key 在 DLL 中对应的 Node 的位置\n    private Map<Integer, Node> map;\n    private DLL cache;\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        this.map = new HashMap<>();\n        this.cache = new DLL();\n        this.capacity = capacity;\n    }\n    \n    // Return the value of the key if the key exists, \n    // otherwise return -1.\n    public int get(int key) {\n        Node node = map.get(key);\n        if (node == null) return -1;\n        updateToRecent(node);\n        return node.val;\n    }\n    \n    // Update the value of the key if the key exists. \n    // Otherwise, add the key-value pair to the cache. \n    // If the number of keys exceeds the capacity from this operation, \n    // evict the least recently used key.\n    public void put(int key, int val) {\n        Node node = map.get(key);\n        if (node == null) {\n            if (cache.size == capacity)\n                removeLeastRecent();\n            addToRecent(key, val);\n        } else {\n            removeNode(node);\n            addToRecent(key, val);\n        }\n    }\n    \n    private void updateToRecent(Node node) {\n        cache.remove(node);\n        cache.addLast(node);\n    }\n    \n    private void addToRecent(int key, int val) {\n        Node newNode = new Node(key, val);\n        cache.addLast(newNode);\n        map.put(key, newNode);\n    }\n    \n    private void removeNode(Node node) {\n        cache.remove(node);\n        map.remove(node.key);\n    }\n    \n    private void removeLeastRecent() {\n        Node leastRecent = cache.removeFirst();\n        map.remove(leastRecent.key);\n    }\n}\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache obj = new LRUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */\n\n// 78ms 82.75%\nclass LRUCache0 extends LinkedHashMap<Integer, Integer> {\n    private int capacity;\n    \n    public LRUCache0(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n    \n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n    \n    // 这个可不写\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312527943","body":"```java\n// TC: O(n), SC: O(height)\n\n// postorder\nclass Solution1 {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n\n// backtrack\nclass Solution {\n    int curDepth = 0;\n    int maxDepth = 0;\n    \n    public int maxDepth(TreeNode root) {\n        traverse(root);\n        return maxDepth;\n    }\n    \n    private void traverse(TreeNode root) {\n        if (root == null) return;\n        curDepth++;\n        maxDepth = Math.max(maxDepth, curDepth);\n        traverse(root.left);\n        traverse(root.right);\n        curDepth--;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313063316","body":"```java\n/**\n *  Preorder  TC:O(n), SC:O(h)\n * /\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null || q == null)\n            return p == q;\n        if (p.val != q.val)\n            return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314554054","body":"```java\n// TC: O(n), SC: O(h)\nclass Solution {\n    int total = 0;\n    \n    public int sumNumbers(TreeNode root) {\n        traverse(root, 0);\n        return total;\n    }\n    \n    private void traverse(TreeNode root, int curSum) {\n        if (root == null) return;\n        curSum = curSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            total += curSum;\n            return;\n        }\n        traverse(root.left, curSum);\n        traverse(root.right, curSum);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316328556","body":"```java\n/**\n    Approach 1:\n    DFS: 先左后右\n        记录遍历到的节点的 height 和 这个 height 最左边节点的值\n        如果 height 大于 curHeight, curVal = 当前节点的值, curHeight = height\n    TC: O(n), SC: O(h)\n*/\nclass Solution1 {\n    int curVal, curHeight;\n    \n    public int findBottomLeftValue(TreeNode root) {\n        curVal = 0;\n        curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n    \n    public void dfs(TreeNode root, int height) {\n        if (root == null) return;\n        height++;\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n        dfs(root.left, height);\n        dfs(root.right, height);\n    }\n}\n\n/**\n    Approach 2: \n    BFS: 先右后左\n        先放右节点再放左节点, 最后一个节点是最底层最左边的节点\n    TC: O(n)    \n    SC: O(n) --> O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树, q 最多保存 n/2 个节点\n*/\nclass Solution2 {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                TreeNode cur = q.poll();\n                if (cur.right != null) \n                    q.offer(cur.right);\n                if (cur.left != null) \n                    q.offer(cur.left);\n                res = cur.val;\n            }\n        }\n        return res;\n    }\n}\n\n/**\n    Approach 3:\n    BFS: 记录每层最左端的值\n    TC: O(n)    \n    SC: O(n) --> O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树, q 最多保存 n/2 个节点\n*/\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        int res = 0;\n        while (!q.isEmpty()) {\n            int sz = q.size();\n            for (int i = 0; i < sz; i++) {\n                TreeNode cur = q.poll();\n                if (i == 0) {\n                    res = cur.val;\n                }\n                if (cur.left != null) \n                    q.offer(cur.left);\n                if (cur.right != null) \n                    q.offer(cur.right);\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317882126","body":"```java\nimport java.util.StringTokenizer;\n/**\n    BT <==> string, 构建满二叉树, null 节点以\"#\"的形式存在于 string 中\n            \n    BFS --> 如果要建的节点是 null, 建 null; 不是 null, 建 new TreeNode(cur.val), 把节点加入 q\n            1,2,3,#,#,4,5,#,#,#,#,\n    DFS -->  注意, preorder 列表最左侧是根节点, postorder 列表最右侧是割接点, deserialize先右后左\n            1,2,#,#,3,4,#,#,5,#,#,\n    TC: O(n)    SC: O(n)\n*/\n// ---------------------- DFS ----------------------\npublic class Codec {\n    String SEP = \",\";\n    String NULL = \"#\";\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        // System.out.println(sb.toString());\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n        sb.append(root.val).append(SEP);\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        StringTokenizer st = new StringTokenizer(data, SEP);\n        return deserialize(st);\n    }\n    \n    private TreeNode deserialize(StringTokenizer st) {\n        // if (!st.hasMoreTokens()) return null; // 这一句其实写了也不会 call 到的\n        String cur = st.nextToken();\n        if (cur.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(cur));\n        root.left = deserialize(st);\n        root.right = deserialize(st);\n        return root;\n    }\n}\n\n// ---------------------- DFS: String split----------------------\n\nclass Codec2{\n    String SEP = \",\";\n    String NULL = \"#\";\n    \n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root, sb);\n        return sb.toString();\n    }\n    \n    private void serialize(TreeNode root, StringBuilder sb) {\n        if (root == null) {\n            sb.append(NULL).append(SEP);\n            return;\n        }\n        // sb.append(root.val).append(SEP);\n        serialize(root.left, sb);\n        serialize(root.right, sb);\n        sb.append(root.val).append(SEP);\n    }\n    \n    public TreeNode deserialize(String data) {\n        LinkedList<String> nodes = new LinkedList<>();\n        for (String s : data.split(SEP)) {\n            nodes.addLast(s);\n        }\n        return deserialize(nodes);\n    }\n    \n    private TreeNode deserialize(LinkedList<String> nodes) {\n        if (nodes.isEmpty()) return null;\n        /*--------前序遍历位置, 列表最左侧就是根节点-------*/\n        // String strVal = nodes.removeFirst();\n        String strVal = nodes.removeLast();\n        if (strVal.equals(NULL)) return null;\n        TreeNode root = new TreeNode(Integer.parseInt(strVal));\n        /*--------------------------------------------*/\n        // root.left = deserialize(nodes);\n        // root.right = deserialize(nodes);\n        root.right = deserialize(nodes);\n        root.left = deserialize(nodes);\n        return root;\n    }\n}\n\n// ---------------------- BFS ----------------------\n\nclass Codec1 {\n    String SEP = \",\";\n    String NULL = \"#\";\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) return \"\";\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n        while (!q.isEmpty()) {\n            TreeNode cur = q.poll();\n            // Preorder: 把值塞进去\n            if (cur == null) {\n                sb.append(NULL).append(SEP);\n                continue;\n            }\n            sb.append(cur.val).append(SEP);\n            q.offer(cur.left);\n            q.offer(cur.right);\n        }\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data.isEmpty()) return null;\n        StringTokenizer st = new StringTokenizer(data, SEP);\n        TreeNode root = new TreeNode(Integer.parseInt(st.nextToken()));\n        Queue<TreeNode> q = new ArrayDeque<>();\n        q.offer(root);\n        while (st.hasMoreTokens()) {\n            TreeNode cur = q.poll();\n            String left = st.nextToken();\n            if (!left.equals(NULL)) {\n                cur.left = new TreeNode(Integer.parseInt(left));\n                q.offer(cur.left);\n            } else {\n                cur.left = null;\n            }\n            String right = st.nextToken();\n            if (!right.equals(NULL)) {\n                cur.right = new TreeNode(Integer.parseInt(right));\n                q.offer(cur.right);\n            } else {\n                cur.right = null;\n            }\n        }\n        return root;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319445880","body":"```java\n/**\n    1. 遍历二叉树,对所有节点生成坐标\n    2. 对所有节点排序\n        - col: 从左到右\n        - row: 从上到下\n        - val: 从小到大\n    3. 将排序好的节点组装成题目要求的格式\n    \n    TC: O(nlogn)    SC: O(n)\n\n*/\n// PQ\nclass Solution2 {\n    record Info(TreeNode node, int col, int row) {}\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        PriorityQueue<Info> pq = new PriorityQueue<>((a, b) \n                                                     -> a.col != b.col? \n                                                        a.col - b.col : a.row != b.row? \n                                                        a.row - b.row : a.node.val - b.node.val);\n        traverse(root, pq, 0, 0);\n        while (!pq.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            Info cur = pq.poll();\n            tmp.add(cur.node.val);\n            int curCol = cur.col;\n            while (!pq.isEmpty() && pq.peek().col == curCol) {\n                tmp.add(pq.poll().node.val);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n    \n    private void traverse(TreeNode cur, PriorityQueue<Info> pq, int col, int row) {\n        if (cur == null) return;\n        pq.offer(new Info(cur, col, row));\n        traverse(cur.left, pq, col - 1, row + 1);\n        traverse(cur.right, pq, col + 1, row + 1);\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320607445","body":"```java\n/**\n    Approach 1: loop all combination\n    两数差i从 1...N - 1, 两数中大数从 i...N - 1遍历所有数\n    TC: (N - 1) * (N - 2) = O(N^2)  SC: O(1)\n*/\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int N = nums.length;\n        for (int i = 1; i < N; i++) {\n            for (int j = i; j < N; j++) {\n                if (nums[j] + nums[j - i] == target) {\n                    return new int[] {j, j - i};\n                }\n            }\n        }\n        return null;\n    }\n}\n\n/**\n    Approach 2: HashMap<num, index>\n    查看对于当前 num, map 中是有 complement 恰好组成 target\n        有则返回, 没有将当前<num, index>存进去\n    TC: O(N), SC: O(N)\n*/\nclass Solution1 {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] {i, map.get(complement)};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321151267","body":"```java\n/**\n    思路一: 堆      TC:O(nlogk) SC:O(n) for hashmap, O(k) for PQ\n*/\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] res = new int[k];\n        for (int i = 0; i < k; i++) {\n            res[i] = queue.poll()[0];\n        }\n        resurn ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321306204","body":"```java\n/**\n    思路: 枚举每个 point 作为 V 型的拐点, 对于其余所有到 V 距离相等的点, 选两个\n    TC: O(N^2)  SC: O(N)\n*/\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int res = 0;\n        int N = points.length;\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int[] x : points) {\n            map.clear();\n            for (int[] y : points) {\n                if (x[1] == y[1] && x[0] == y[0]) \n                    continue;\n                int xDist = x[1] - y[1], yDist = x[0] - y[0];\n                int dist = xDist * xDist + yDist * yDist;\n                int num = map.getOrDefault(dist, 0);\n                res += num * 2; // 对于之前每一个相同 dist 的数, 正反两次\n                map.put(dist, num + 1);\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322354758","body":"```java\n/**\n    思路一: 滑动窗口\n    1. 要有 memo 记录是否有重复\n    2. 从左到右遍历, 一旦遇到重复, 窗口收缩\n    3. 记录最长长度\n    \n    TC: O(N),   SC: O(1)\n*/\nclass Solution1 {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            memo[in]++;\n            while (memo[in] != 1) {\n                memo[s.charAt(l++)]--;\n            }\n            maxLen = Math.max(maxLen, r - l + 1);\n        }\n        return maxLen;\n    }\n}\n/**\n    思路二: 不用 memo 记录是否有重复, 记录 char 出现的位置 之后一位的位置\n            从而直接缩短窗口\n*/\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int N = s.length();\n        if (N <= 1) return N;\n        int[] memo = new int[128];\n        int maxLen = 0;\n        int l = 0, r = 0;\n        for (; r < N; r++) {\n            char in = s.charAt(r);\n            l = Math.max(l, memo[in]);\n            maxLen = Math.max(maxLen, r - l + 1);\n            memo[in] = r + 1;\n        }\n        return maxLen;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324578071","body":"```java\n/**\n    思路:\n    最好是可以一次遍历, 然后拿到所有的位置, 每次检查的长度为 所有 words 加起来的长度\n    \n    **滑动窗口式检查, 窗口一格格右移**\n        对于每个 word, 检查它在窗口中出现的次数 ?= words 中出现的次数\n        但是这样对于 按照单词长度倍数offset 的窗口来说, 中间的检查都是重复的    \n        \n    **优化**: 根据 起始点 在单词长度中的位置, offset=单词长度的倍数 进行偏移\n    比如说 一个单词长度为 4, 那么 048, 159, 这样检查\n        如果从头向后检查, 碰见没有出现过的 word 组合, 可以跳过之前检查的所有\n                       如果只是 freq 出现太多了, 窗口右移一个 wL, 但是这样其实还是有很多重复的检查 108ms\n        如果从后往前检查, 遇见 freq 出现次数过多或者没见过的 word 可以直接抛弃整个窗口\n                       这样写方便和快太多了 9ms\n        \n    TC: O(wN + sL * wL) ==> 1. 遍历words列表 O(wN) 2. 对于每种起始位置遍历整个 s O(sL * wL)\n    SC: O(wN)   ==> Hashmap\n*/\n\n// 对于每一个窗口从后向前\nclass Solution {\n   public List<Integer> findSubstring(String s, String[] words) {\n       List<Integer> res = new ArrayList<>();\n       \n       Map<String, Integer> wordToFreq = new HashMap<>();\n       for (String w : words) {\n           wordToFreq.put(w, wordToFreq.getOrDefault(w, 0) + 1);\n       }\n       \n       int wN = words.length;\n       int wL = words[0].length();\n       int tL = wL * wN;\n       int sL = s.length();\n       \n       if (tL > sL) return res;\n       \n       for (int k = 0; k < wL; k++) {                       // 起始点 从单词长度不同点开始\n           for (int i = k; i + tL <= sL; i+= wL) {          // 从起始点开始遍历整个 s\n               Map<String, Integer> tmp = new HashMap<>();\n               for (int j = i + tL - wL; j >= i; j -= wL) {\n                   String word = s.substring(j, j + wL);\n                   // System.out.println(word);\n                   int curFreq = tmp.getOrDefault(word, 0) + 1;\n                   int needFreq = wordToFreq.getOrDefault(word, 0);\n                   if (needFreq < curFreq) {\n                       i = j;\n                       break;\n                   } else if (j == i) {\n                       res.add(i);\n                   } else {\n                       tmp.put(word, curFreq);\n                   }\n               }\n               // System.out.println();\n           }\n       }\n       return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326021798","body":"```java\n/**\n    (allSum - rangeSum) % p == 0\n    allSum % p = rangeSum % p\n    \n    TC: O(n)    SC: O(n)\n*/\n\nclass Solution {\n    public int minSubarray(int[] nums, int p) {\n        // mod for all sum\n        int mod = 0;\n        for (int v: nums) {\n            mod = (mod + v) % p;\n        }\n        if (mod == 0) {\n            return 0;\n        }\n\n        int res = nums.length; // cannot remove the whole array\n\n        Map <Integer, Integer> map = new HashMap < > (); // mod to last idx pos\n        map.put(0, -1);\n\n        int sum = 0, diff = 0;\n        int idx = 0;\n\n        for (int v: nums) {\n            sum = (sum + v) % p;\n            diff = (sum - mod + p) % p;\n            if (map.containsKey(diff)) {\n                res = Math.min(res, idx - map.get(diff));\n            }\n            map.put(sum, idx);\n            idx++;\n        }\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326895925","body":"```java\n/**\n    TC: O(n)    SC: O(1)\n    \n    注意写法:                        even 节点个数 (不包括 null)       奇数节点 永远落在正中间\n    fast && fast.next               ==> slow 落在靠右的中间节点\n    fast.next && fast.next.next     ==> slow 落在靠左的中间结点\n    \n*/\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327688730","body":"```java\n/**\n    TC: O(n)    SC: O(1)\n    双指针: 把不同的元素 copy 到前面来 \n*/\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int N = nums.length;\n        int i = 0, j = 1;\n        for (; j < N; j++) {\n            if (nums[j] != nums[i]) {\n                nums[++i] = nums[j];    // [0..i] no duplicates\n            }\n        }\n        return i + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328075334","body":"```java\n/**\n    找左边界: 找得到 left 就是结果, 找不到 left 就是大一位的 position\n    TC: O(nlogn)    SC: O(1)\n*/\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int N = nums.length;\n        int left = 0, right = N;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        } \n        return left;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328339249","body":"```java\n/**\n    将链表 切分成大小为 k 的 chunk\n    然后 left 记录在 chunk 内从左往右的最大值, \n         right 记录 chunk 内从右往左的最大值\n    滑动窗口只需要找 right[i] 和 left[i + k - 1]的最大值\n    \n            1  3  -1  * -3  5  3  *  6  7\n    left    1  3  3     -3  5  5     6  7\n    right   3  3  -1     5  5  3     7  7\n    \n    TC: O(N)    SC: O(N) 4ms\n\n*/\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int N = nums.length;\n        int[] res = new int[N - k + 1];\n        int[] left = new int[N];\n        int[] right = new int[N];\n        for (int i = 0; i < N; i += k) {\n            int max = Integer.MIN_VALUE;\n            int rightBound = Math.min(i + k - 1, N - 1);\n            // from left to right --> \n            for (int j = i; j <= rightBound; j++) {\n                if (nums[j] > max) \n                    max = nums[j];\n                left[j] = max;\n            }\n            // from right to left <--\n            max = Integer.MIN_VALUE;\n            for (int j = rightBound; j >= i; j--) {\n                if (nums[j] > max)\n                    max = nums[j];\n                right[j] = max;\n            }\n        }\n        for (int i = 0; i < N - k + 1; i++) {\n            int j = i + k - 1;\n            res[i] = Math.max(right[i], left[j]);\n        }\n        return res;\n    }\n}\n\n/**\n    维护一个 单调递减 的 Monotonic Queue, 尾进头出\n    TC: O(n)    SC: O(k)\n    36ms\n*/\nclass Solution1 {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int N  = nums.length;\n        int[] res = new int[N - k + 1];\n        Deque<Integer> queue = new ArrayDeque<>();\n        for (int i = 0; i < N; i++) {\n            // 保证窗口内 从大到小, 如果前面的数小则需要一次弹出, 直到满足要求\n            while (!queue.isEmpty() && nums[i] >= nums[queue.peekLast()]) {\n                queue.pollLast();\n            }\n            queue.addLast(i);\n            // 判断队首的值是否在 k 的滑动窗口内\n            if (queue.peekFirst() <= i - k) {\n                queue.poll();\n            }\n            // 当增长到窗口长度为k时 保存当前窗口中最大值\n            if (i + 1 - k >= 0) {\n                res[i + 1 - k] = nums[queue.peekFirst()];\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329634637","body":"```java\n/**\n\tTC: O(n)\tSC: O(n)\n*/\nclass Solution {\n    public int findJudge(int N, int[][] trust) {\n        if (trust.length < N - 1) \n            return -1;\n        \n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\n        \n        for (int[] t : trust) {\n            trustScores[t[1]]++;\n            trustScores[t[0]]--;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (trustScores[i] == N - 1)\n                return i;\n        }\n        return -1;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330986046","body":"```java\n/**\n    DFS: 遍历边 dfs, 看 source vetex 能不能给 child color 呈不同的颜色\n    \n    1. colors:  0: unseen\n                1 和 -1 互为 opposite color \n    2. 给未 color 的出发点 默认 color 成 1\n    \n    n 个人, m 个 dislike的关系\n    TC: O(n + m)    SC: O(n + m)    18ms\n*/\nclass Solution1 {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i <= n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] e : dislikes) {\n            graph.get(e[0]).add(e[1]);\n            graph.get(e[1]).add(e[0]);\n        }\n        int[] colors = new int[n + 1];\n        for (int s = 1; s <= n; s++) {\n            if (colors[s] == 0 && !dfs(graph, s, colors, 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private boolean dfs(List<List<Integer>> graph, int s, int[] colors, int color) {\n        colors[s] = color;\n        for (int next : graph.get(s)) {\n            if (colors[next] == -color) continue;\n            if (colors[next] == color) return false;\n            if (!dfs(graph, next, colors, -color)) return false;\n        }\n        return true;\n    }\n}\n\n/**\n    DSU: 5ms\n    \n    a dislike b ==> a 和 b 互相讨厌\n            a 讨厌的人群 (包括 b) 会 share 同一个 parent\n            b 讨厌的人群 (包括 a) 会 share 同一个 parent\n            \n    TC: O(n + m * α(n))  α is inverse of the Ackermann function\n    SC: O(n)\n*/\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        DSU dsu = new DSU(n + 1);\n        \n        for (int[] d : dislikes) {\n            if (!dsu.union(d[0], d[1])) \n                return false;\n        }\n        return true;\n    }\n    \n    class DSU {\n        int[] parent;\n        int[] rival;\n        \n        public DSU(int N) {\n            parent = new int[N];\n            rival = new int[N];\n            Arrays.setAll(parent, r->r);\n        }\n        \n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        public boolean union(int a, int b) { // a dislike b\n            int pa = find(a);\n            int pb = find(b);\n            if (pa == pb) return false;\n            \n            if (rival[a] != 0)\n                parent[rival[a]] = pb;\n            else \n                rival[a] = b;\n            \n            if (rival[b] != 0)\n                parent[rival[b]] = pa;\n            else\n                rival[b] = a;\n            return true;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333299848","body":"```java\n/**\n    topological sort: \n        \n    [6(0), 3(0), 4(0), 1(-1), 5(1), 2(1), 0(-1), 7(-1)]\n    -----------------  -----  ----------  ------------\n    思路一: (这个比较巧妙)\n    将 group 和 item 的关系存在一张 graph 中\n        graph[N + groupId] 是 group\n        graph[0 ... N + 1] 是 item\n        * 对于不属于任何一组的 item, 其实没必要给它一个新组, 因为它可能会穿插在别的组之间\n    \n    对于 graph 的关系\n        item 存在先后顺序, group 也存在先后顺序\n        item --> group      indegree[group]++       根据 group 生成\n        groupA --> groupB   indegree[groupB]++;     根据 beforeItems 生成\n        \n    思路二:\n    先确定 group 的先后, 再确认 item 的先后\n    \n    TC: O(N + M)    SC: O(N + M)\n*/\nclass Solution {\n    int[] res;\n    int idx;\n    \n    public int[] sortItems(int N, int M, int[] group, List<List<Integer>> beforeItems) {\n        int[] indegree = new int[N + M];\n        List<Integer>[] graph = new ArrayList[N + M];\n        for (int i = 0; i < N + M; i++) graph[i] = new ArrayList<>();\n        // 建立 group 的 关系\n        for (int i = 0; i < N; i++) {\n            if (group[i] == -1) continue;\n            graph[N + group[i]].add(i);\n            indegree[i]++;\n        }\n        // 在 group 的基础上, 把 item 放入 group 的列表中\n        for (int i = 0; i < N; i++) {\n            for (int before : beforeItems.get(i)) { // before --> item\n                // find the groupID of i and beforeItem\n                int a = group[before] == -1? before: N + group[before];\n                int b = group[i] == -1? i : N + group[i];\n                if (a == b) { // same group\n                    graph[before].add(i);\n                    indegree[i]++;\n                } else {\n                    graph[a].add(b);\n                    indegree[b]++;\n                }\n            }\n        }\n        // topological sort\n        res = new int[N]; idx = 0;\n        for (int i = 0; i < N + M; i++) {\n            if (indegree[i] == 0)\n                dfs(N, graph, indegree, i);\n        }\n        return (idx == N) ? res : new int[]{};\n    }\n    \n    private void dfs(int N, List<Integer>[] graph, int[] indegree, int cur) {\n        if (cur < N) \n            res[idx++] = cur;\n        indegree[cur]--; // 为了使每个 cur 只触动是否加入 res 一次, 到零之后减成-1\n        for (int next : graph[cur]) {\n            if (--indegree[next] == 0)\n                dfs(N, graph, indegree, next);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334899917","body":"```java\n/**\n    TC: O(N)    SC: O(1)\n*/\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int horiz = 0;\n        int verti = 0;\n        \n        for (char i : moves.toCharArray()) {\n            if (i == 'U') verti++;\n            else if (i == 'D') verti--;\n            else if (i == 'L') horiz--;\n            else if (i == 'R') horiz++;\n        } \n        \n        return horiz == 0 && verti == 0;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336177660","body":"```java\n/**\n    task 按照 入队时间 & 任务编号 \n    TC: O(NlogN)    SC: O(N)\n*/\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int N = tasks.length;\n        // 保留任务index\n        int[][] idxedTasks = new int[N][3];\n        for (int i = 0; i < N; i++) \n            idxedTasks[i] = new int[] {tasks[i][0], tasks[i][1], i};\n        // 按照任务入队时间 排序\n        Arrays.sort(idxedTasks, (a, b) -> a[0] - b[0]);\n        // 根据题意，先按照「持续时间」排序，再根据「任务编号」排序\n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]);\n        int[] res = new int[N];\n        for (int time = 1, i = 0, resIdx = 0; resIdx < N; ) {\n            // 如果当前任务 满足入队时间 则入队\n            while (i < N && idxedTasks[i][0] <= time)\n                pq.add(idxedTasks[i++]);\n            if (pq.isEmpty()) { // 空队列, 跳转到下一个任务时间\n                time = idxedTasks[i][0];\n            } else {            // pq 非空, 出队, 并跳到该任务时间点\n                int[] cur = pq.poll();\n                res[resIdx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336329788","body":"```java\n/**\n    TC: O(1)    SC: O(1)\n*/\nclass Solution {\n    public int numberOfRounds(String startTime, String finishTime) {\n        int start = toMinutes(startTime);\n        int end = toMinutes(finishTime);\n        \n        if (start > end) \n            end += 24 * 60;\n        \n        int roundedStart = toNextQuarter(start);\n        int roundedEnd = toPreviousQuarter(end);\n        \n        return Math.max(0, (roundedEnd - roundedStart) / 15);\n    }\n    \n    public static int toMinutes(String s) {\n        return Integer.parseInt(s.substring(0, 2)) * 60\n            + Integer.parseInt(s.substring(3, 5));\n    }\n    \n    public static int toNextQuarter(int time) {\n        return ((time + 14) / 15) * 15;\n    }\n\n    public static int toPreviousQuarter(int time) {\n        return (time / 15) * 15;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337590336","body":"```java\n/**\n    分别尝试满足三种条件, 看哪种 condition 会得到 min operations\n    \n    1         a 中所有 letter 严格小于 字符 i, 将 b 中所有字符变成满足条件的 i\n    2\n    3         a 和 b 所有字符都变成 i\n    \n    TC: O(M + N)    SC: O(M + N)        \n*/\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int M = a.length(), N = b.length();\n        int res = M + N;\n        \n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        \n        for (int i = 0; i < 26; i++) {\n            res = Math.min(res, M + N - c1[i] - c2[i]); // condition 3\n            if (i > 0) {\n                c1[i] += c1[i - 1];\n                c2[i] += c2[i - 1];\n            }\n            if (i < 25) {   // 必须 为 b 保留一个字母, 然后将 a 中所有字母改变成严格小于 b, i 不能为 25\n                res = Math.min(res, M - c1[i] + c2[i]); // condition 1\n                res = Math.min(res, N - c2[i] + c1[i]); // condition 2\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338678487","body":"```java\n/**\n    MergeSort:  TC: O(nlogn)    SC: O(n)\n */\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        int N = nums.length;\n        if (N == 1) return nums;\n        int[] helper = new int[N];\n        mergeSort(nums, helper, 0, N - 1);\n        return nums;\n    }\n\n    private void mergeSort(int[] nums, int[] helper, int left, int right) {\n        if (left >= right) return;\n        int mid = left + (right - left) / 2;\n        mergeSort(nums, helper, left, mid);\n        mergeSort(nums, helper, mid + 1, right);\n        merge(nums, helper, left, mid, right);\n    }\n\n    private void merge(int[] nums, int[] helper, int left, int mid, int right) {\n        // copy nums to helper, merge from helper to nums\n        for (int i = left; i <= right; i++) {\n            helper[i] = nums[i];\n        }\n        int i = left, j = mid + 1;\n        while (i <= mid) {\n            if (j > right || helper[i] <= helper[j]) {\n                nums[left++] = helper[i++];\n            } else {\n                nums[left++] = helper[j++];\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340416060","body":"```java\n/**\n    二分      TC: O(logN) SC: O(1)\n*/\nclass Solution {\n    public int mySqrt(int x) {\n        if (x < 2) return x;\n\n        int left = 2, right = x / 2 + 1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            long num = (long) mid * mid;\n            if (num < x) \n                left = mid + 1;\n            else if (num > x)\n                right = mid;\n            else\n                return mid;\n        }\n        return left - 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341489653","body":"```java\n// TC: O(logn) O(1)\nclass Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1;\n        int right = N;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (isBadVersion(mid)) {\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343871516","body":"```java\n/**\n    Approach 1: MergeSort       TC: O(NlogN)    SC: O(N)\n*/\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 1) return 0;\n        int N = nums.length;\n        int[] helper = new int[N];\n        return mergeSort(nums, helper, 0, N - 1);\n    }\n    \n    private int mergeSort(int[] nums, int[] helper, int left, int right) {\n        if (left >= right) return 0;\n        int count = 0;\n        int mid = left + (right - left) / 2;\n        count += mergeSort(nums, helper, left, mid);\n        count += mergeSort(nums, helper, mid + 1, right);\n        count += merge(nums, helper, left, mid, right);\n        return count;\n    }\n    \n    private int merge(int[] nums, int[] helper, int left, int mid, int right) {\n        for (int i = left; i <= right; i++) \n            helper[i] = nums[i];\n        int count = 0;\n        int i = left, j = mid + 1;\n        \n        while (i <= mid) {\n            while (j <= right && (long) nums[i] > (long) nums[j] * 2) {\n                j++;\n            }\n            count += j - (mid + 1);\n            i++;\n        }\n        // sort\n        \n        i = left;\n        j = mid + 1;\n        while (i <= mid) {\n            if (j > right || helper[i] <= helper[j]) {\n                nums[left++] = helper[i++];\n                // count += j - (mid + 1);\n            } else {\n                nums[left++] = helper[j++];\n                // count += mid + 1 - i;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345292896","body":"```java\n/**\n    二分确定半径是否合规  TC: O(max(n,m)∗logL)    SC: O(logn+logm)\n*/\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        int l = 0, r = (int) 1e9;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(houses, heaters, mid))\n                r = mid;\n            else \n                l = mid + 1;\n        }\n        return r;\n    }\n    \n    private boolean check(int[] houses, int[] heaters, int radius) {\n        int N = houses.length, M = heaters.length;\n        for (int i = 0, j = 0; i < n; i++) {\n            while (j < m && houses[i] > heaters[j] + radius) \n                j++;\n            if (j < m && \n                heaters[j] - radius <= houses[i] && \n                houses[i] <= heaters[j] + radius) {\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345372315","body":"```java\n/**\n    注意: 相同距离不能合并成一项, 也要参加排序\n    \n    排序 + 二分查找 + 双指针\n    \n    思路一. 暴力计算所有数对距离 O(N^2)\n    \n    思路二. 因为排序后 数对差 有明确范围 [0, nums[N - 1] - nums[0]]\n           我们可以用二分查找来做\n           \n    TC: O(nlogn + nlogD) D: distance between 2 ele in nums\n    SC: O(logn) --> 排序的平均空间复杂度\n*/\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int N = nums.length;\n        int left = 0, right = nums[N - 1] - nums[0];\n        // ** 不断逼近 count 数等于 k 的 threshold 的左边界 \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            int count = countLessEquals(nums, N, mid);\n            if (count < k) {    // 距离 <= mid 的数对个数 < k, 扩大 threshold\n                left = mid + 1;\n            } else {            // 个数 >= k, \n                                // 1)如果 mid-1 的数对个数 = k, mid 就不是第 k 小; 2) 如果  mid-1 <k, mid 是第 k 小\n                                // 我们无法排出 mid 的可能性, 只能不断逼近左边界\n                right = mid;\n            }\n        }\n        return left;\n    }\n    \n    // 计算 <= threshold 的 pair 个数\n    private int countLessEquals(int[] nums, int N, int threshold) {\n        int count = 0;\n        for (int left = 0, right = 0; right < N; right++) {\n            while (nums[right] - nums[left] > threshold) {\n                left++;\n            }\n            // 此时满足 nums[right] - nums[left] <= threshold\n            // [left..right - 1] 和 right 里的每一个元素的「距离」都小于等于 threshold\n            // [left..right - 1] 里元素的个数为 right - left\n            count += right - left;\n        }\n        return count;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346771991","body":"```java\n/**\n    Approach 1: 二分查找 最短的等待时间, 看能不能找到一条路径\n    TC: O(N ^ 2 logN)   SC: O(N^2)\n*/\nclass Solution1 {\n    public static final int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    \n    int N;\n    int[][] grid;\n    \n    public int swimInWater(int[][] grid) {\n        this.N = grid.length;\n        this.grid = grid;\n        \n        int left = 0, right = N * N;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            boolean[][] visited = new boolean[N][N];\n            if (grid[0][0] <= mid && dfs(0, 0, visited, mid)) \n                right = mid;\n            else \n                left = mid + 1;\n        }\n        return left;\n    }\n    \n    private boolean dfs(int x, int y, boolean[][] visited, int threshold) {\n        if (x == N - 1 && y == N - 1) \n            return true;\n        visited[x][y] = true;\n        for (int[] dir : dirs) {\n            int i = x + dir[0], j = y + dir[1];\n            if (isValid(i, j) && !visited[i][j] && grid[i][j] <= threshold) \n                if (dfs(i, j, visited, threshold))\n                    return true;\n        }\n        return false;\n    }\n    \n    private boolean isValid(int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347638751","body":"```java\n/**\n    Sliding Window:     TC: O(N)    SC: O(1)\n*/\nclass Solution {\n    public int maxVowels(String s, int k) {\n        int N = s.length();\n        int cur = 0;\n        for (int i = 0; i < k; ++i) {\n            cur += isVowel(s.charAt(i));\n        }\n        int max = cur;\n        for (int i = k; i < N; ++i) {\n            cur += isVowel(s.charAt(i)) - isVowel(s.charAt(i - k));\n            max = Math.max(max, cur);\n        }\n        return max;\n    }\n    \n    public int isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ? 1 : 0;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352498300","body":"```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        int len = p.length();\n        \n        int digitsNeed = len;\n        int[] freq = new int[26];\n        for (int i = 0; i < len; i++) {\n            freq[p.charAt(i) - 'a']++;\n        }\n        \n        int left = 0;\n        for (int right = 0; right < s.length(); right++) {\n            /* ------------左侧收缩------------ */\n            while (right - left >= len) {\n                char cl = s.charAt(left);\n                if (freq[cl - 'a'] >= 0) {\n                    digitsNeed++;\n                }\n                freq[cl - 'a'] ++;\n                left++;\n            }\n            /* ------------右侧更新------------ */\n            char cr = s.charAt(right);\n            freq[cr - 'a']--;\n            if (freq[cr - 'a'] >= 0) {\n                digitsNeed--;\n            }\n            /* ------------添加结果------------ */\n            if (digitsNeed == 0) {\n                result.add(left);\n            }\n        }\n        return result;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354235132","body":"```java\nclass Solution {\n    public String minWindow(String s, String t) {        \n        if (s.length() < t.length()) return \"\";\n        \n        int minStart = 0;\n        int minLen = Integer.MAX_VALUE;\n        \n        int required = t.length();               \n        int[] count = new int['z' - 'A' + 1];             \n        \n        for (char c : t.toCharArray())\n            count[c - 'A']++; \n        \n        int l = 0, r = 0;\n        \n        while (r < s.length()) { \n            if (--count[s.charAt(r++) - 'A'] >= 0)\n                required--;\n            while (required == 0) {\n                if (minLen > r - l) {\n                    minLen = r - l;\n                    minStart = l;\n                }\n                if (count[s.charAt(l++) - 'A']++ >= 0)\n                    required++;\n            }\n        }\n        return minLen == Integer.MAX_VALUE? \"\" : s.substring(minStart, minStart + minLen);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356053820","body":"```java\n/**\n    Sliding Window: \n    由于只能从开头和末尾拿 k 张卡牌，所以最后剩下的必然是连续的 n−k 张卡牌\n    可以通过求出剩余卡牌点数之和的最小值，来求出拿走卡牌点数之和的最大值。\n    \n    TC: O(N)    SC: O(1)\n*/\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int N = cardPoints.length;\n        int windowSize = N - k;\n        int sum = 0;\n        for (int i = 0; i < windowSize; i++) {\n            sum += cardPoints[i];\n        }\n        int minSum = sum, total = sum;\n        for (int i = windowSize; i < N; i++) {\n            total += cardPoints[i];\n            sum += cardPoints[i] - cardPoints[i - windowSize];\n            minSum = Math.min(minSum, sum);\n        }\n        return total - minSum;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356634628","body":"```java\n/**\n    Approach 1: 枚举所有的 h 和 m, 计算他们的 bitCount, 看位数和是否等于 turnedOn\n                12 * 60 = 720 种组合\n    TC: O(1)    SC: O(1)\n*/\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int h = 0; h < 12; h++) {\n            for (int m = 0; m < 60; m++) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(h).append(\":\");\n                    sb.append(m < 10 ? \"0\" : \"\").append(m);\n                    res.add(new String(sb));\n                }\n            }\n        }\n        return res;\n    }\n}\n\n/**\n    Approach 2: 枚举 2^10 = 1024 种灯的开闭组合\n                高 4 位: 小时     低 6 位: 分钟, \n                若小时和分钟的值 均在合规范围内, 并且 二进制中 1 的个数为 turnedOn, 加入 res\n    TC: O(1)    SC: O(1)            \n*/\nclass Solution1 {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 1024; i++) {\n            int h = i >> 6, m = i & 63;\n            if (h < 12 && m < 60 && Integer.bitCount(i) == turnedOn) {\n                StringBuilder sb = new StringBuilder();\n                sb.append(h).append(\":\");\n                sb.append(m < 10 ? \"0\" : \"\").append(m);\n                res.add(new String(sb));\n            }\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356889277","body":"```java\n/**\n    优化: 可以用二进制 优化 int[] state\n*/  \nclass Solution {\n    public int totalNQueens(int n) {\n        return solve(n, 0, 0, 0, 0);\n    }\n\n    public int solve(int n, int row, int cols, int diag1, int diag2) {\n        if (row == n) {\n            return 1;\n        } else {\n            int count = 0;\n            /**\n                (1 << n) - 1        生成了 n 个 1, \n                ~(col | ld | rd)    分别代表了列及两个斜线的放置情况, 这里的1表示的是不能放置皇后\n            */\n            int availablePos = ((1 << n) - 1) & (~(cols | diag1 | diag2));\n            \n            while (availablePos != 0) {     // 说明bits中还有1存在，就说明遍历还没有完成\n                int pos = availablePos & (-availablePos);           // 找到 最后一位1 的位置\n                availablePos = availablePos & (availablePos - 1);   // 获得把最后一位 1 变成 0 之后的 availablePos\n                count += solve(n, row + 1, cols | pos, (diag1 | pos) << 1, (diag2 | pos) >> 1);     // cols | pos: 把所有放置皇后的列都计算出来了\n            }\n            return count;\n        }\n    }\n}\n\nclass Solution1 {\n    int N;\n    int res;\n    \n    public int totalNQueens(int n) {\n        this.N = n;\n        int[] state = new int[n];   \n        backtrack(0, state);\n        return res;\n    }\n    \n    // 一行行 fill, 如果一个 col valid, 那就填下一行\n    private void backtrack(int row, int[] state) {\n        if (row == N) {\n            res++;\n            return;\n        }\n        for (int col = 0; col < N; col++) {\n            if (isValid(row, col, state)) {\n                state[row] = col;\n                backtrack(row + 1, state);\n            }\n        }\n    }\n    \n    private boolean isValid(int row, int col, int[] state) {\n        for (int i = 0; i < row; i++) { // loop all options in the previous rows\n            if (state[i] == col || Math.abs(col - state[i]) == row - i)\n                return false;\n        }\n        return true;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359582923","body":"```java\n/**\n    dfs 返回值记录 淹没土地的个数\n    TC: O(RC)   SC: O(RC)\n*/\nclass Solution {\n    int[][] grid;\n    int R, C;\n    boolean[][] visited;\n    \n    public int maxAreaOfIsland(int[][] grid) {\n        int maxArea = 0;\n        \n        this.grid = grid;\n        this.R = grid.length;\n        this.C = grid[0].length;\n        this.visited = new boolean[R][C];\n        \n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (!visited[i][j] && grid[i][j] == 1) {\n                    maxArea = Math.max(maxArea, dfs(i, j));\n                }\n            }\n        }\n        return maxArea;\n    }\n    \n    private int dfs(int i, int j) {\n        if (i < 0 || i >= R || j < 0 || j >= C || grid[i][j] == 0 || visited[i][j])\n            return 0;\n        visited[i][j] = true;\n        return dfs(i, j + 1) + dfs(i, j - 1)\n             + dfs(i + 1, j) + dfs(i - 1, j) + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361508210","body":"```java\n/**\n    「多源最短路」\n    把所有 陆地 入队, 从各个陆地一层层向海洋扩散, 越界 or visited 过即跳过, \n                            (dist 不为 0, 陆地会是 -1, 看过的海洋会是正数)\n    每一步将新的海洋入队, 更新到目前海洋的距离, 同时记录最大的 dist\n    最后扩散到的海洋就是最远的海洋\n    \n    TC: O(N^2)  SC: O(N^2)\n*/\nclass Solution {\n    public int maxDistance(int[][] grid) {\n        int N = grid.length;\n        int[][] dirs = new int[][] {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n        int[][] dist = new int[N][N];\n        \n        int maxDist = -1;\n        Queue<int[]> q = new ArrayDeque<>();\n        \n        // add land cell to queue\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] == 1) {\n                    q.add(new int[] {i, j});\n                    dist[i][j] = -1; // land: -1, unvisited: 0, visited ocean: positive\n                }\n            }\n        }\n        \n        while (!q.isEmpty()) {\n            int[] cur = q.poll();\n            int x = cur[0], y = cur[1];\n            int step = Math.max(dist[x][y], 0);\n            for (int[] dir : dirs) {\n                int i = x + dir[0], j = y + dir[1];\n                if (i < 0 || i >= N || j < 0 || j >= N) continue;\n                if (dist[i][j] != 0) continue;\n                q.add(new int[] {i, j});\n                dist[i][j] = step + 1;\n                maxDist = Math.max(maxDist, step + 1);\n            }\n        }\n        \n        return maxDist;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362430264","body":"```java\n/**\n\tBFS\t\tTC: O(V + E)\tSC: O(V)\n*/\nclass Solution {\n\tpublic int findShortestCycleContainingTargetNode(List<List<Integer>> graph, int target) {\n\t\tint N = graph.size();\n\t\tQueue<Integer> q = new ArrayDeque<>();\n\t\tboolean[] visited = new boolean[N];\n\n\t\tq.offer(target);\n\t\tvisited[target] = true; \n\n\t\tint res = 0, step = 0;\n\t\twhile (!q.isEmpty()) {\n\t\t\tstep++;\n\t\t\tint sz = q.size();\n\t\t\tfor (int i = 0; i < sz; i++) {\n\t\t\t\tint cur = q.poll();\n\t\t\t\tfor (int next : graph.get(cur)) {\n\t\t\t\t\tif (!visited[next]) {\n\t\t\t\t\t\tq.offer(visited);\n\t\t\t\t\t\tvisited[next] = true;\n\t\t\t\t\t} else if (next == target) {\n\t\t\t\t\t\treturn step;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363567597","body":"```java\n/**\n    1. 遍历二叉树,对所有节点生成坐标\n    2. 对所有节点排序\n        - col: 从左到右\n        - row: 从上到下\n        - val: 从小到大\n    3. 将排序好的节点组装成题目要求的格式\n    \n    TC: O(nlogn)    SC: O(n)\n\n*/\n// PQ\nclass Solution2 {\n    record Info(TreeNode node, int col, int row) {}\n    \n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        PriorityQueue<Info> pq = new PriorityQueue<>((a, b) \n                                                     -> a.col != b.col? \n                                                        a.col - b.col : a.row != b.row? \n                                                        a.row - b.row : a.node.val - b.node.val);\n        traverse(root, pq, 0, 0);\n        while (!pq.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            Info cur = pq.poll();\n            tmp.add(cur.node.val);\n            int curCol = cur.col;\n            while (!pq.isEmpty() && pq.peek().col == curCol) {\n                tmp.add(pq.poll().node.val);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n    \n    private void traverse(TreeNode cur, PriorityQueue<Info> pq, int col, int row) {\n        if (cur == null) return;\n        pq.offer(new Info(cur, col, row));\n        traverse(cur.left, pq, col - 1, row + 1);\n        traverse(cur.right, pq, col + 1, row + 1);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364463500","body":"```java\n/**\n    dp[i] 为了 reach 第 i 层 花的成本\n*/ \n\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int N = cost.length;\n        int[] dp = new int[N + 1];\n        for (int i = 2; i <= N; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[N];\n    }\n}\n\nclass Solution1 {\n    public int minCostClimbingStairs(int[] cost) {\n        int downOne = 0;\n        int downTwo = 0;\n        for (int i = 2; i < cost.length + 1; i++) {\n            int temp = downOne;\n            downOne = Math.min(downOne + cost[i - 1], downTwo + cost[i - 2]);\n            downTwo = temp;\n        }\n        \n        return downOne;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364699274","body":"```java\n/**\n    TC: O(N)    SC: O(N)\n*/\nclass Solution {\n    public int rob(int[] nums) {\n        int N = nums.length;\n        int[] dp = new int[N + 1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        // 两个选择: 抢 or 不抢\n        for (int i = 2; i <= N; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        return dp[N];\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365626223","body":"```java\n/**\n    subsequence: 没有对字母顺序的要求\n    TC: O(NM)   SC: O(NM)\n*/\n\n// SC 优化 成 O(M): 滚动数组\nclass Solution {\n    public int longestCommonSubsequence(String s1, String s2) {\n        int N = s1.length(), M = s2.length();\n        int[][] dp = new int[2][M + 1];\n        for (int i = 1; i <= N; i++) {\n            int a = i & 1, b = (i - 1) & 1;\n            char c1 = s1.charAt(i - 1);\n            for (int j = 1; j <= M; j++) {\n                if (c1 == s2.charAt(j - 1))\n                    dp[a][j] = 1 + dp[b][j - 1];\n                else\n                    dp[a][j] = Math.max(dp[a][j - 1], dp[b][j]);\n            }\n        }\n        return dp[N & 1][M];\n    }\n}\n\nclass Solution1 {\n    public int longestCommonSubsequence(String s1, String s2) {\n        int N = s1.length(), M = s2.length();\n        // dp[N][M] = len of longest subseq from s1[0... N - 1] s2[0... M - 1]\n        int[][] dp = new int[N + 1][M + 1];\n        // Base case: dp[0][0] = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                if (s1.charAt(i - 1) == s2.charAt(j - 1))\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                else\n                    dp[i][j] = Math.max(dp[i][j - 1], dp[i - 1][j]);\n            }\n        }\n        return dp[N][M];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366751612","body":"```java\n/**\n    DP: 到当前这个点的 unique path 的数量\n    因为只能往右或者下, 所以 第一行和第一列 所有的 dp = 1\n    对于其它 cell, dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n    \n    TC: O(MN)   SC: O(MN)\n*/\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int i = 0; i < n; i++) dp[0][i] = 1;\n        for (int i = 0; i < m; i++) dp[i][0] = 1;\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n        return dp[m - 1][n - 1];  \n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367425465","body":"```java\n/**\n    f[i][j][step]: 从 i, j 出发, 走不超过 step 步, 最后仍留在棋盘内的概率\n    TC: O(N^2 * k * C) where C = 8 = O(N^2 * k)\n    SC: O(N^2 * k)\n*/\nclass Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n    \n    public double knightProbability(int N, int K, int row, int column) {\n        double[][][] f = new double[N][N][K + 1];\n        for (double[][] x : f)\n            for (double[] y : x)\n                y[0] = 1;\n        for (int step = 1; step <= K; step++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    for (int[] dir : dirs) {\n                        int x = i + dir[0], y = j + dir[1];\n                        if (x < 0 || x >= N || y < 0 || y >= N) continue;\n                        f[i][j][step] += f[x][y][step - 1] / 8;\n                    }\n                }\n            }\n        }\n        return f[row][column][K];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367982694","body":"```java\nclass Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= maxChoosableInteger || desiredTotal == 0)\n\t\t\treturn true;\n        if (desiredTotal > ((maxChoosableInteger * (maxChoosableInteger + 1)) / 2))\n\t\t\treturn false;\n\n\t\tif (1 + maxChoosableInteger < desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn true;\n\t\tif (1 + maxChoosableInteger == desiredTotal && desiredTotal < 2 * maxChoosableInteger)\n\t\t\treturn false; \n\n\t\tif (desiredTotal % 2 == 0 && maxChoosableInteger % 2 == 0) {\n\t\t\treturn desiredTotal / maxChoosableInteger < 4 || desiredTotal == 100 && maxChoosableInteger == 16;\n\t\t} else {\n\t\t\treturn desiredTotal % 2 == 0 || maxChoosableInteger % 2 != 0 || desiredTotal / maxChoosableInteger < 5;\n\t\t}\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368245202","body":"```java\n/**\n    TC: O(N)    SC: O(1)\n*/\nimport java.math.BigInteger;\n\npublic class Solution {\n    public boolean canPartition(int[] nums) {\n        int total = 0;\n        for (int num : nums) \n            total += num;\n        \n        if (total % 2 != 0) \n            return false;\n        \n        BigInteger state = BigInteger.ONE;\n        \n        for (int num : nums) \n            state = state.or(state.shiftLeft(num));\n        \n        return state.testBit(total / 2);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368473431","body":"```java\n/**\n    - 号的元素之和为 neg, + 的元素之和为 sum−neg, neg 和 pos 为 非负偶数\n   (sum − neg) − neg = target ==> neg = (sum - target) / 2\n   OR\n   pos - (sum - pos) = target ==> pos = (target + sum) / 2\n\n    dp[i][j]表示前i个元素有多少个目标和为j的子集。dp[0][0] = 1\n        1. 如果 j < num, 则不能选 num, dp[i][j] = dp[i-1][j]\n        2. 如果 j>= num, 如果不选 num, dp[i][j] = dp[i-1][j]\n                          如果选 num, dp[i][j] = dp[i-1][j-num]\n                          \n    由于 dp 的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，\n        去掉 dp 的第一个维度，将空间复杂度优化到 O(neg).\n    实现时，内层循环需采用倒序遍历的方式，这种方式保证转移来的是 dp[i−1][] 中的元素值。\n\n */\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        int sum = 0;\n        for (int i : nums) \n            sum += i;\n        if (target > sum || target < -sum || (target + sum) % 2 == 1)\n            return 0;\n           \n        int N = nums.length;\n        int neg = (sum - target) / 2;\n        int[] dp = new int[neg + 1];\n        // base case\n        dp[0] = 1;\n        // dp\n        for (int num : nums) {\n            for (int j = neg; j >= num; j--) {\n                dp[j] += dp[j - num];\n            }\n        }\n        return dp[neg];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368623173","body":"```java\n/**\n    S: amount, N: amount of different coins\n    TC: (SN)    SC: O(S)\n*/\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if (amount == 0) {\n            return 0;\n        }\n        int INF = amount + 1;\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, INF);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int coin: coins) {\n                if (coin <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount? -1 : dp[amount];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369306368","body":"```java\n/**\n    TC: O(amount * N)   SC: O(amount)\n*/\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                if (i - coin >= 0) {\n                    dp[i] += dp[i - coin];\n                }\n            }\n        }\n        return dp[amount];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370396983","body":"```java\n/**\n    Greedy: O(mlogm+nlogn)  SC: (logm+logn)\n*/\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        \n        int gL = g.length, sL = s.length;\n        int count = 0;\n        \n        int i = 0, j = 0;\n        while (i < gL && j < sL) {\n            if (s[j] >= g[i])\n                i++;\n            j++;\n        }\n        return i;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1372625983","body":"```java\n/**\n    因为船的 max weight of limit是固定的, 每次只能载两人\n    用双指针指向最轻 和 最重,\n    如果最重和最轻超过 limit, 最重也只能自己一艘船, people[i] <= limit \n    \n    除了默认的 MergeSort 之外, 如果用 bucket sort 然后更改 people, 能将 TC 降至 O(N)\n    \n    Approach 1 MergeSort:            TC: O(NlogN)    SC: O(1)\n    Approach 2 BucketSort & Inplace: TC: O(N)        SC: O(N)\n*/\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        int[] bucket = new int[limit + 1];\n        for (int v : people) \n            bucket[v]++;\n        int idx = 0, N = people.length;\n        for (int i = 1; i <= limit && idx < N; i++) {\n            while (bucket[i]-- > 0)\n                people[idx++] = i;\n        }\n        int l = 0, r = N - 1, res = 0;\n        while (l <= r) {\n            if (people[l] + people[r] <= limit)\n                l++;\n            r--;\n            res++;\n        }\n        return res;\n    }\n}\n\nclass Solution1 {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int N = people.length;\n        int lo = 0, hi = N - 1;\n        int res = 0;\n        while (lo <= hi) {\n            if (people[lo] + people[hi] <= limit) \n                lo++;\n            hi--;\n            res++;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374519897","body":"```java\n/**\n    当有 n 个节点时, 顶点有 n 种可能, 当 i 为根节点时, 有 f(i) 种 uniqueBST\n        G(n) = f(1) + ... + f(n)\n    --------------------------------------------------------------------\n    当 i 为根节点时, 左子树节点数为 i - 1 个, 右子树节点为 n - i\n        f(i) = G(i - 1) * G(n - i)\n    --------------------------------------------------------------------\n        G(n) = G(0) * G(n - 1) + G(1) * G(n - 2) ... + G(n - 1) * G(0)\n    \n    Base Case:\n    dp[0] = 1\n    dp[1] = 1\n*/\nclass Solution {\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {          // i 个节点\n            for (int j = 1; j <= i; j++) {      // 当 j 为根节点\n                dp[i] += dp[j - 1] * dp[i - j];\n            }\n        }\n        return dp[n];\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374705275","body":"```java\n/**\n    Approach 1: MinHeap      \n    TC: O(Nlogk)    O(logk) for every pop and insertion to pq\n    SC: O(k) for pq ==> O(1)\n*/\nclass Solution2 {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) return null;\n        // 虚拟头结点\n        ListNode dummy = new ListNode(-1);\n        ListNode p = dummy;\n        // 优先级队列，最小堆\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(\n            lists.length, (a, b)->(Integer.compare(a.val, b.val)));\n        // 将 k 个链表的头结点加入最小堆\n        for (ListNode head : lists) {\n            if (head != null) \n                pq.add(head);\n        }\n        while (!pq.isEmpty()) {\n            // 获取最小节点，接到结果链表中\n            ListNode node = pq.poll();\n            p.next = node;\n            // 将node.next重新加入pq\n            if (node.next != null) {\n                pq.add(node.next);\n            }\n            // p 指针不断前进\n            p = p.next;\n        }\n        return dummy.next;\n    }\n}\n\n/**\n    Approach 2: Divide & Conquer\n    TC: O(Nlogk)    SC: O(1)\n*/\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists.length == 0) {\n            return null;\n        }\n        return mergeHelper(lists, 0, lists.length - 1);\n    }\n\n    private ListNode mergeHelper(ListNode[] lists, int start, int end) {\n        if (start == end) {\n            return lists[start];\n        }\n\n        int mid = start + (end - start) / 2;\n        ListNode left = mergeHelper(lists, start, mid);\n        ListNode right = mergeHelper(lists, mid + 1, end);\n        return mergeTwoLists(left, right);\n    }\n\n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode p = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                p.next = l1;\n                l1 = l1.next;\n            } else {\n                p.next = l2;\n                l2 = l2.next;\n            }\n            p = p.next;\n        }\n        if (l1 != null) {\n            p.next = l1;\n        } else {\n            p.next = l2;\n        }\n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375848413","body":"```java\n/**\n    对于每个 i < j，都不存在 k 满足 i < k < j 使得  A[k] * 2 = A[i] + A[j] \n    \n    1. A[k] * 2 必为偶数, 一个简单的办法是 令 A[i] + A[j] 一个为奇数, 一个为偶数\n       A[i] 来自 left 部分 (都为奇数)       A[j] 来自 right 部分 (都为偶数)\n    \n    2. 如果 A 是一个漂亮数组 将 A 中的每一个数 x 进行 kx + b (k > 0) 的映射，其仍然为漂亮数组,\n       这样可以通过一个漂亮数组, 衍生出 为奇数 的漂亮数组 和 为偶数 的漂亮数组\n       \n    所以, 我们可以就\n       在 [1..N] 中有 (N+1)/2 个奇数和 N/2 个偶数, \n       通过 f((n+1)/2) 中每个元素进行 *2-1 映射到 f(n) 中的 (n+1)/2 个奇数元素构成的漂亮数组\n       通过 f((n)/2)   中每个元素进行 *2   映射到 f(n) 中的 (n)/2   个偶数元素构成的漂亮数组\n       \n       而对于 A[k]*2 != A[i]+A[j]， 当对 A[k], A[i], A[j] 同时乘以2, 并同时-1，并不影响不等号。\n      \n       N =  10  [1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\n            5   [1, 5, 3, 2, 4]\n            3   [1, 3, 2]\n            2   [1, 2]\n            1   [1]\n            \n       TC: O(NlogN)     SC: O(NlogN)\n*/\n\nclass Solution {\n    Map<Integer, int[]> memo;\n    \n    public int[] beautifulArray(int N) {\n        memo = new HashMap<>();\n        memo.put(1, new int[] {1}); // base case\n        return dp(N);\n    }\n    \n    public int[] dp(int N) {\n        if (memo.containsKey(N))\n            return memo.get(N);\n        \n        int[] res = new int[N];\n        // 如果n不为1，需要在 前(n+1)/2个位置放奇数 后(n)/2个位置放偶数                   \n        int i = 0;\n        for (int x : dp( (N+1)/2 ))      // n个数中有 (n+1)/2 奇数\n             res[i++] = 2 * x - 1;  \n        for (int x : dp( N/2 ))          //n个数中有 (n)/2 个偶数\n             res[i++] = 2 * x;\n        \n        memo.put(N, res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376639117","body":"```java\n/**\n    当两个数字的异或某位值为1时，必然存在两个数字在此位上的值不相同, \n    取最低有效位只是一种划分\n    可以通过获取最低有效位把两个数分开\n*/\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        int xorsum = 0;\n        for (int x : nums)\n            xorsum ^= x;\n        // 负数如果取相反数，会产生溢出，所以不能用 a & (-a) 取最低有效位\n        // INT MIN 第一位是1，其余位是0，所以它的最低有效位就是自己\n        int lsb = (xorsum == Integer.MIN_VALUE? xorsum : xorsum & (-xorsum));\n        int type1 = 0, type2 = 0;\n        for (int x : nums) {\n            if ((x & lsb) != 0)\n                type1 ^= x;\n            else\n                type2 ^= x;\n        }\n        return new int[] {type1, type2};\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1379020377","body":"```java\n/**\n    TC: O(N*2^N)    SC: O(N)\n*/\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        result.add(new ArrayList<>());\n        \n        if (nums == null || nums.length == 0) return result;\n         \n        int s = 0;\n\n        for (int n : nums){\n            s = result.size();\n            for (int i = 0; i < s; i++){\n                // 对于之前所有决定,都把当前的新 num 添进去\n                List<Integer> set = new ArrayList<>(result.get(i));\n                set.add(n);\n                result.add(set);\n                // System.out.println(set.toString());\n            }\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380566111","body":"```java\n/**\n    TC: Initialization: O(1)\n        others: O(∣S∣)   ∣S∣ 是每次插入或查询的字符串的长度。\n    SC： O(∣T∣⋅Σ)        ∣T∣ 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ=26。\n*/\nclass Trie {\n    private Trie[] children;\n    private boolean isEnd;\n    \n    public Trie() {\n        children = new Trie[26];\n        isEnd = false;          // 区分是否是一个单词的结尾\n    }\n    \n    public void insert(String word) {\n        Trie node = this;\n        for (int i = 0; i < word.length(); i++) {\n            int c = word.charAt(i) - 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n        }\n        node.isEnd = true;\n    }\n    \n    public boolean search(String word) {\n        Trie node = searchPrefix(word);\n        return node != null && node.isEnd;\n    }\n    \n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n    \n    private Trie searchPrefix(String prefix) {\n        Trie node = this;\n        for (int i = 0; i < prefix.length(); i++) {\n            int c = prefix.charAt(i) - 'a';\n            if (node.children[c] == null) {\n                return null;\n            }\n            node = node.children[c];\n        }\n        return node;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298298900","body":"### 解题思路\r\n倒序遍历num逐个与k的数组倒序相加, 设置一个进位sgn=0, 如果有进位sgn=1, 相加的时候把sgn加上\\\r\nk => [num,num...]  少的那个在左边补齐足够的0\r\n❓ 想着是否可以只相加min(num1,num2)长度的，剩下的直接原封不动复制过来，但是99999-xxx 这种怎么办啊😿\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let num2 = [...k.toString()].map(c=> +c);\r\n\r\n  if(num2.length<num.length){\r\n    num2.unshift(...new Array(num.length-num2.length).fill(0));\r\n  } else{\r\n    num.unshift(...new Array(num2.length-num.length).fill(0));\r\n  }\r\n  let n = num.length;\r\n  let sum=0;\r\n  let sgn=0;\r\n  let res=[];\r\n  for(let i=0; i<n;i++){\r\n    sum = num[n-1-i]+num2[n-1-i]+sgn;\r\n    sgn = sum>=10 ? 1: 0;\r\n    res.unshift(sum%10);\r\n  }\r\n  // for结束判断最后一位是否需要再进位\r\n  if (sgn===1){\r\n    res.unshift(1);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间空间都是O(N) ?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300671552","body":"### 解题思路\n1. 抽取出来所有目标字符c所在的索引的数组tar\n2. 每次只需要比较s中的每一位s[i]与它左右两个c的距离然后选最小; \n3. tar数组p指针和p-1控制当前s[i]最近的左右两个命中的目标点, p从1开始（0位置为dum离得非常远所以第一次命中肯定是p)，遍历s数组，当i命中了p对应的tar的值tar[p]也就是当前命中点在s里的索引，就res.push(0),然后右移p,没命中就res.push(min(i-左侧, 右侧-i))\n4. 考虑到只有一个目标的情况，所以索引数组tar左右两端加一个很远的坐标，like: -10000,10000\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n\n  let tar = [-10000];\n  for(let i=0; i<s.length; i++){\n    if(s[i]===c){\n      tar.push(i);\n    }\n  }\n  tar.push(10000);\n  let p = 1;\n  let res = [];\n  for(let i=0; i<s.length; i++){\n    if(i===tar[p]){\n      res.push(0);\n      p++;\n    } else{\n      res.push(Math.min(i-tar[p-1], tar[p]-i))\n    }\n  }\n  return res;\n};\n```\n### 复杂度\n**时间** : O(N) 两次遍历S\n**空间** : O(N) 为tar数组长度的额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301774652","body":"### 解题思路\r\n模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = new Array();   // [empty, ...]\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  // 最大长度限制\r\n  if(this.stack.length<this.maxSize){\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 栈顶为空的 =》 -1\r\n  if(this.stack.length===0){\r\n    return -1;\r\n  }\r\n  let val = this.stack.pop();\r\n  return val;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n  for(let i=0;i<n;i++){\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间: push/pop 都为O(1), increment需要O(k)\r\n空间: O(N) 一个栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303550516","body":"### 解题思路\r\n栈的使用\r\n1. 判断类型： 数字、字母、[、]\r\n  1. 数字 更新m 直接拼接\r\n  2. 字母，更新res, 直接拼接\r\n  3. [: 入栈  stack.push([res, +m])\r\n  4. ]: 出栈  res = pop出来的res +  当前res.repeat(pop出来的multi)\r\n\r\nJS的一些语法复习：\r\n1. 重复3次的str: \r\n  a. str.repeat(3)  ES6的语法\r\n  b. new Array(3).fill(str).join(\"\")\r\n  c. new Array(4).join(str)\r\n2. ASCII码:  0-9 : 48-57 ;  字母a-z: 97-122\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\nvar decodeString = function(s) {\r\n  let m = \"\";\r\n  let stack = [];\r\n  let res = \"\";\r\n  for(let i=0;i<s.length;i++){\r\n    let asc = s[i].charCodeAt();\r\n    // 数字 更新m 直接拼接\r\n    if (asc>=48 && asc<=57){\r\n      m += s[i];  \r\n    } else if(asc>=97 && asc<=122){\r\n      // 字母 更新res\r\n      res += s[i];\r\n    } else if(s[i]==='['){\r\n      // 入栈[res,m] 置空这两个\r\n      stack.push([res,+m]);\r\n      res = '';\r\n      m = '';\r\n    } else if(s[i]===']'){\r\n      // 出栈\r\n      let [beforeRes,multi] = stack.pop();\r\n      res = beforeRes+ res.repeat(multi);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n空间：O(N)\r\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304505032","body":"### 解题思路\r\n几个要注意的点\r\n1. 两个栈首先命名用stackIn和stackOut容易记\r\n2. push永远只往stackIn里\r\n3. pop时先判断stackOut是否为空，不为空直接pop(), 为空就：把stackIn的所有一股脑全部倒入stackOut里\r\n4. 判断empty时记得两个栈都要为空才行\r\n\r\n### JavaScript代码\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n  // 两个栈 sIn, sOut\r\n  this.sIn = [];   // push永远只压入到这里\r\n  this.sOut = [];   //不为空就pop()  为空就一次性倒完\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.sIn.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.pop();\r\n  } \r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.slice(-1);\r\n  }\r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.slice(-1);\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.sIn.length===0 && this.sOut.length===0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n空间：O(N) 两个栈嘛\r\n时间：push和empty很好想就是O(1)； pop和peek思路一样（举个极端例子一连串的push后pop，这时候需要倒完N个到stackOut里，但是之后的push和pop全是一次操作解决，所以其实是O(2)吧，N个操作均摊O(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829528","body":"### 解题思路\r\n1. left[i]: arr[0]-arr[i]最大值\r\n2. right[i]: arr[i]-arr[n-1]的最小值\r\n3. 遍历for(i=1; i<n; n++) 如果arr[i-1]<=arr[i] 就在arr[i]前切一刀\r\n\r\n### Js代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  let l = new Array(arr.length).fill(arr[0]);\r\n  let r = new Array(arr.length).fill(arr[arr.length-1]);\r\n\r\n  let max = arr[0];\r\n  let min= arr[arr.length-1];\r\n  \r\n  for(let i=0; i<arr.length; i++){\r\n    max = Math.max(max, arr[i]);\r\n    l[i] = max;\r\n  }\r\n  for(let i=arr.length-1; i>=0; i--){\r\n    min = Math.min(min, arr[i]);\r\n    r[i] = min;\r\n  }\r\n  \r\n  let cnt = 0;\r\n  for(let j=1; j<arr.length; j++){\r\n    if(l[j-1] <= r[j]) cnt++;\r\n  }\r\n  return cnt+1;\r\n  \r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：两个额外的数组 O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298299088","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # a = ''\n        # for i in num:\n        #     a += str(i)\n        # b = int(a)+k\n        # res = []\n        # for i in str(b):\n        #     res.append(int(i))\n        # return res\n        \n        # return list(map(int,str(int(''.join(map(str,num))) + k)))\n\n        res = []\n        i, carry = len(num) - 1, 0\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            res.append(sum % 10)\n            carry = sum // 10\n\n            i -= 1\n            k //= 10\n        if carry != 0: res.append(carry)\n        return res[::-1]\n\n        \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299676710","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # numlist = []\n        # reslist = []\n        # for i in range(len(s)):\n        #     if s[i] == c:\n        #         numlist.append(i)\n        # for j in range(len(s)):\n        #     reslist.append(min([abs(i - j) for i in numlist]))\n        # return reslist\n\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301871371","body":"class CustomStack:\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top+1]\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305611743","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or k == 0 :\r\n            return head\r\n        _len = 0\r\n        tempHead = head\r\n        while tempHead :\r\n            tempHead = tempHead.next\r\n            _len += 1\r\n        k = k % _len\r\n        former = head\r\n        latter = head\r\n        for i in range(0 , k ) :\r\n            former = former.next\r\n        while former.next :\r\n            former = former.next\r\n            latter = latter.next \r\n        former.next = head\r\n        newHead = latter.next\r\n        latter.next = None\r\n        return newHead\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311684700","body":"```\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315265960","body":"```class Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)","onTime":true},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326480353","body":" ``` class Solution:\n   def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        record = {0:1}\n        ans,total = 0,0\n        for i in nums:\n            total += i\n            m = total % k\n            l = record.get(m,0)\n            ans += l\n            record[m] = l + 1\n        return ans    \n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328978305","body":"```   class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = collections.deque()\n        res = []\n        if k < 1:\n            return res\n        for i in range (k):\n            while q and nums[i] >= nums[q[-1]]:\n                q.pop()\n            q.append(i)\n        res.append(nums[q[0]])\n        for i in range (k, n):\n            while q and q[0] <= i-k: \n                q.popleft()\n            while q and nums[q[-1]] <= nums[i]:\n                q.pop()\n            q.append(i)\n            res.append(nums[q[0]])\n        return res ```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382708","body":"# 解题思路：\n# 把列表转化成字符串，然后强制转化成int\n# 再进行正常的两个数的加法\n# 最后把结果转化成字符串，然后转化成列表\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,A))) + K)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300427307","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), -inf\n        for i, ch in enumerate(s):\n            if ch == c:\n                last = i\n            ans[i] = min(ans[i], i - last)\n        last = inf\n        for i, ch in enumerate(s[::-1]):\n            # 因为两者都有 len(s) - 1 的偏移量，可以一起去掉，减少运算            \n            # if ch == c:\n            #     last = len(s) - 1 - i\n            # ans[-1 - i] = min(ans[-1 - i], last - len(s) + 1 + i)\n            if ch == c:\n                last = -i\n            ans[-1 - i] = min(ans[-1 - i], last + i)\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301761523","body":"```\n/**\n    利用数组来模拟栈\n    注意：\n        1.当栈元素个数等于 maxSize 时不允许继续入栈；\n        2.当栈为空时，出栈操作返回 -1；\n        3.当栈非空，出栈操作发返回栈顶值\n        4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\n\n */\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize){\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const item = this.list.pop()\n    return item === void 0 ? -1 : item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303112859","body":"```\n/**\n    利用栈的思想解题\n      设置两个变量：1.res 最终结果字符串 2.num 用来计数当前字符需要重复多少次 \n      构造两个栈：1.字符栈 strStack，表示需要重复的字符 2.数字栈，需要重复的次数 \n      如果当前 str === 数字，推入数字栈 \n      如果当前 str === [,strStack、numStack 入栈，num，res 清 0 \n      如果当前 str === ],strStack、numStack 出栈，形成一次字符串 \n      其他情况 把字符加到 res 中\n */\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let numStack = [],strStack = [],res = '',num = 0;\n\n    for (let str of s) {\n        if (!isNaN(str)) {\n            num = num * 10 + parseInt(str);\n        } else if (str === '[') {\n            strStack.push(res);\n            numStack.push(num);\n            res = '';\n            num = 0;\n        } else if (str === ']') {\n            res = strStack.pop() + res.repeat(numStack.pop());\n        } else {\n            res += str;\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304500973","body":"两个栈解题，一个输入栈、一个输出栈\nvar MyQueue = function() {\n    this.stackIn = [];\n    this.stackOut = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length;\n    if(size){\n        return this.stackOut.pop();\n    }\n    while(this.stackIn.length){\n        this.stackOut.push(this.stackIn.pop());\n    }\n    return this.stackOut.pop();  \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackIn.length && !this.stackOut.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751374","body":"```\n滑动窗口\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr];\n    sorted.sort((a,b) => a-b);\n    \n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n    \n    for (let i = 0; i < arr.length; i++){\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if(sum1 == sum2){\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n    return count;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305457790","body":"```\n/**\n 解题思路：快慢指针法\n*/\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head;\n    let len = 0,now = head;\n    while(now){\n        now = now.next;\n        len++;\n    }\n    k = k % len;\n    let slow = (fast = head);\n    while(fast.next){\n        if(k-- <= 0){\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n    let res = slow.next;\n    slow.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307056244","body":"```\n/**\n * 解题思路：虚拟表头\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n    let ret = new ListNode(0,head),temp = ret;\n    while(temp.next && temp.next.next){\n        let cur = temp.next.next,pre = temp.next;\n        pre.next=cur.next;\n        cur.next=pre;\n        temp.next=cur;\n        temp=pre;\n    }\n    return ret.next;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308374038","body":"```\n解题思路：快慢指针\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    if(!head) return null;\n    return dfs(head,null);\n};\nfunction dfs(head,tail) {\n    if(head ==  tail) return null;\n    let fast = head;\n    let slow = head;\n    while(fast != tail && fast.next != tail){\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n    let root = new TreeNode(slow.val);\n    root.left = dfs(head, slow);\n    root.right = dfs(slow.next, tail);\n    return root;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309647716","body":"```\n/** \n * 解题思路：遍历两个链表，若有相同的则为相交结点\n * 通过遍历先把链表A,添加到Set集合 \n * 然后对链表B遍历，使用Set的has方法，如果包含则返回该结点，否则在循环外返回null。\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    const visited = new Set();\n    let temp = headA;\n    while(temp !== null){\n        visited.add(temp);\n        temp = temp.next;\n    }\n    temp = headB;\n    while(temp !== null){\n        if(visited.has(temp)){\n            return temp;\n        }\n        temp = temp.next;        \n    }\n    return null;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311388846","body":"```\n/ **\n * 解题思路：快慢指针法\n * 快指针和慢指针相遇在环上，则有交点，否则无交点\n * 从头继续遍历slow，再次相遇则为交点\n * 根据：\n * f=2s （快指针每次2步，路程刚好2倍）\n * f = s + nb (相遇时，刚好多走了n圈）\n * 推出：s = nb\n * 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。\n * 如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar detectCycle = function(head) {\n    if(head == null || head.next == null ) return null;\n    let fast = (slow = head);\n    do{\n        if(fast != null && fast.next != null){\n            fast = fast.next.next;\n        }else{\n            fast = null;\n        }\n        slow = slow.next;\n    }while(fast != slow);\n\n    if(fast == null) return null;\n    fast = head;\n    while(fast != slow){\n        fast = fast.next;\n        slow = slow.next;\n    }\n    return fast;\n    \n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312476252","body":"```\n/**\n * 解题思路:使用map解决\n */\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.capacity = capacity;\n    this.map = new Map();\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    let key_has = this.map.has(key);\n    if( key_has){\n       let value = this.map.get(key);\n       this.map.delete(key); // 删除原有值，重新设置，会更新位置\n       this.map.set(key,value);\n       return this.map.get(key);\n    }\n    return -1;\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    // 存在则删除\n    if(this.map.has(key)){\n        this.map.delete(key)\n    }\n    // map长度到达临界值则删除第一个\n    if(this.map.size == this.capacity){\n        // 调用map的[Symbol.iterator]生成迭代器，.next获取key\n        const { value: key,done} = this.map.keys().next();\n        this.map.delete(key);\n    }\n    this.map.set(key,value)\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313752596","body":"/**\n * 解题思路：\n * 深度优先遍历\n * 结束条件：当两棵树的当前节点都为空，return true\n * 当其中一个是null 另一个不为null,return false\n * 两个都不为空，且其值不相等，return false\n * 当满足终止条件时进行返回，不满足时分别判断左子树和右子树是否相同，其中要注意代码中的短路效应\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {boolean}\n */\nvar isSameTree = function(p, q) {\n    if(q == null && p == null) return true;\n    if(p == null || q == null) return false;\n    if(p.val != q.val) return false;\n    return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315267984","body":"```\n/**\n * 思路：递归\n * 遇到叶子节点返回，每层都在取值后*10\n * 左右相加\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    return count(root,0);\n};\n\nconst count = (cur,preSum) =>{\n\n    if(!cur) return 0;\n    let sum = preSum *10 +cur.val;\n    if(!cur.left && !cur.right) return sum;\n    else return count (cur.left,sum) + count(cur.right, sum);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316521930","body":"```\n/**\n层次遍历\n*/\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar findBottomLeftValue = function(root) {\n    let queue = [];\n    if( root === null){\n        return null;\n    }\n    queue.push(root);\n    let resNode;\n    while(queue.length){\n        let length = queue.length;\n        for(let i = 0; i < length; i++){\n            let node = queue.shift();\n            if(  i == 0){\n                resNode = node.val;\n            }\n            node.left && queue.push(node.left);\n            node.right && queue.push(node.right);\n        }\n    }\n    return resNode;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317896869","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    if (root == null) {                  // 遍历到 null 节点\n    return 'X';\n  }\n  const left = serialize(root.left);   // 左子树的序列化结果\n  const right = serialize(root.right); // 右子树的序列化结果\n  return root.val + ',' + left + ','+ right; // 按  根,左,右  拼接字符串\n\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n  const list = data.split(',');   // split成数组\n\n  const buildTree = (list) => {   // 基于list构建当前子树\n    const rootVal = list.shift(); // 弹出首项，获取它的“数据”\n    if (rootVal == \"X\") {         // 是X，返回null节点\n      return null;\n    }\n    const root = new TreeNode(rootVal); // 不是X，则创建节点\n    root.left = buildTree(list);        // 递归构建左子树\n    root.right = buildTree(list);       // 递归构建右子树\n    return root;                        // 返回当前构建好的root\n  };\n\n  return buildTree(list); // 构建的入口\n};\n\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319697151","body":"```\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar verticalTraversal = function(root) {\n    let res=[];\n    const stack = []\n    //前序遍历（迭代）\n    if(root) stack.push([root,0,0])\n    while (stack.length) {\n        const n = stack.pop()\n        let node=n[0];\n        let row=n[1];\n        let col=n[2];\n        res.push([node.val,row,col]);\n        if(node.right) stack.push([node.right,row+1,col+1])\n        if(node.left) stack.push([node.left,row+1,col-1])\n    }\n    //排序\n    res.sort((v1,v2)=>v1[2]-v2[2]||v1[1]-v2[1]||v1[0]-v2[0])\n    //合并\n    let result=[[res[0][0]]];\n    for(let i=1;i<res.length;i++){\n        if(res[i][2]!==res[i-1][2]){\n            result.push([res[i][0]]);\n        }else{\n            result[result.length-1].push(res[i][0])\n        }\n    }\n    return result\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320814363","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n       \n    let map = new Map();\n    for(let i = 0, len = nums.length; i < len; i++){\n        if(map.has(target - nums[i])){\n            return [map.get(target - nums[i]), i];\n        }else{\n            map.set(nums[i], i);\n        }\n    }\n    return [];\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321072458","body":"```\nvar topKFrequent = function(nums, k) {\n    //前k个高频元素\n    let hash = new Map();\n        //频率统计\n    for(let i of nums){\n        if(!hash.has(i)) hash.set(i,1);\n        else hash.set(i,hash.get(i)+1);\n    }\n    nums=new Array(hash.size);\n    let j=0;\n    for(let [key,value] of hash){\n        nums[j++]=[key,value];\n    }\n    getK(nums,0,nums.length-1,k);\n    let res=new Array(k);\n    for(let i=0;i<k;++i){\n        res[i] = nums[i][0];\n    }\n    return res;\n};\n\n//分治   \nvar getK = function(nums,left,right,k){\n    if(left>=right) return ;\n    let temp = quikSort(nums,left,right,k);\n    if(temp+1==k+left) return ;\n    else if(temp+1<k+left){\n        getK(nums,temp+1,right,k-(temp+1-left));  //前面的temp+1-left已经符合要求 找剩下的k-(temp+1-left)个最大元素\n    } else getK(nums,left,temp-1,k);      //继续找前k个最大元素\n    return ;\n}\n\nvar quikSort = function(nums,left,right){\n    if(left>=right) return left;\n    let pivot = nums[left];\n    let i=left,j=right;\n    while(i<j){\n        while(nums[j][1]<pivot[1] && i<j) --j;\n        nums[i] = nums[j];\n        while(nums[i][1]>=pivot[1] && i<j) ++i;\n        nums[j] = nums[i];\n        if(i==j) nums[i] = pivot;\n    }\n    return i;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321986764","body":"```\n/**\n * @param {number[][]} points\n * @return {number}\n */\nvar numberOfBoomerangs = function(points) {\n    let res = 0;\n    for(let i = 0; i < points.length;i++){\n        let map = new Map();\n        for(let j = 0; j < points.length; j++){\n            if(j !== i){\n                let distance = dis(points[i],points[j]);\n                if(map.has(distance)){\n                    map.set(distance,map.get(distance)+1);\n                }else {\n                    map.set(distance,1)\n                }\n            }\n        }\n        map.forEach((count,distance) => res += count * (count-1));\n    }\n    return res;\n};\n\nfunction dis(x, y){\n    return (y[1] - x[1])* (y[1] - x[1]) + (y[0] - x[0]) * (y[0] - x[0]); //坐标两点距离，是+不是-\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323322163","body":"```\n/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let res = 0;\n    for(let i = 0; i < s.length; i++){\n        let map = {};\n        for(let j = i; j < s.length; j++){\n            if(map[s[j]] !== undefined){\n                break;\n            }\n            map[s[j]] = true;\n            res = Math.max(res, j -i +1)\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325245343","body":"```\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    let wordlen=words[0].length;\n    let ans=[];\n    let sub=[]\n    words.sort();\n    let str1=words.toString()\n    for(let i=0;i<s.length;i++){\n        for(let j=0;j<words.length;j++){\n            sub.push(s.substr(i+wordlen*j,wordlen))\n            \n        }\n        sub.sort()\n        if(sub.toString()===str1){\n            ans.push(i)\n        }\n        sub=[]\n    }\n    return ans\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326416348","body":"```\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\nclass Solution {\n  solve(nums, k) {\n    var map = new Map();\n    map.set(0, -1);\n    var res = nums.length;\n    var target = 0;\n    var currSum = 0;\n    for (let i = 0; i < nums.length; i++) {\n      target += nums[i];\n    }\n    target = target % k;\n    for (let i = 0; i < nums.length; i++) {\n      currSum = (nums[i] + currSum) % k;\n      map.set(currSum, i);\n      var prevSum = floorMod(currSum - target, k);\n      if (map.has(prevSum)) {\n        res = Math.min(res, i - map.get(prevSum));\n      }\n    }\n    return res === nums.length ? -1 : res;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326982848","body":"```\n/**\n 解题思路：快慢指针\n 详细步骤：使用快慢指针遍历链表，慢指针走一步，快指针走两步，当快指针到达链表最后时，慢指针位于中间\n */\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar middleNode = function(head) {\n    let slow = fast = (head);\n    while(fast&&fast.next){\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return slow;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068978","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar removeDuplicates = function(nums) {\n    const n = nums.length;\n    if (n === 0) {\n        return 0;\n    }\n    let fast = 1, slow = 1;\n    while (fast < n) {\n        if (nums[fast] !== nums[fast - 1]) {\n            nums[slow] = nums[fast];\n            ++slow;\n        }\n        ++fast;\n    }\n    return slow;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328231473","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar searchInsert = function(nums, target) {\n    let left = 0,\n    right = nums.length - 1;\n    while (left <= right) {\n        const middle = (left + right) >> 1;\n        const middleValue = nums[middle];\n        if (middleValue === target) {\n        return middle;\n        } else if (middleValue < target) {\n        left = middle + 1;\n        } else {\n        right = middle - 1;\n        }\n    }\n    return left;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329110728","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number[]}\n */\nvar maxSlidingWindow = function(nums, k) {\n    let res = [];\n    let que = []; // 队列最多容纳k个数\n    for(let i = 0; i < nums.length; i++) {\n        if(que.length === 0) que.push(nums[i]);\n        else { // 维护队列\n            // 出队列就两种情况\n            // 1、 队头元素不在窗口（从队头出）\n            // 2、 当前元素大于队尾元素（从队尾出）\n            if(i - k >= 0 && nums[i - k] === que[0]) que.shift(); // 当队头元素出窗口时，弹出\n            // 当前元素若大于队尾元素，则移出，直到遇到小于的元素或者队列空了，进队\n            while(que.length > 0 && nums[i] > que[que.length - 1]){\n                que.pop();\n            }\n            que.push(nums[i]);\n        }\n        // 当滑动完k个元素之后开始提取队头元素\n        if(i >= k - 1) res.push(que[0]);\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330709478","body":"```\n/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    const count = new Array(n + 1).fill(0);\n    for (const edge of trust) {\n        const x = edge[0];\n        const y = edge[1];\n        count[y]++;\n        count[x]--;\n    }\n    for (let i = 1; i <= n; ++i) {\n        if (count[i] === n - 1) {\n        return i;\n        }\n    }\n    return -1;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332182271","body":"```\n/**\n * @param {number} n\n * @param {number[][]} dislikes\n * @return {boolean}\n */\nvar possibleBipartition = function(n, dislikes) {\n  // 用于记录是否已经染色\n  const colors = new Array(n + 1).fill(0)\n  // 用于记录每个人讨厌的人\n  const dislikeMap = new Map()\n\n  for (const [first, second] of dislikes) {\n    const firstDislike = dislikeMap.get(first) || []\n    const secondDislike = dislikeMap.get(second) || []\n    dislikeMap.set(first, (firstDislike.push(second), firstDislike))\n    dislikeMap.set(second, (secondDislike.push(first), secondDislike))\n  }\n\n  // 深度优先进行染色\n  const dfs = (curPerson, curColor) => {\n    // 染色\n    colors[curPerson] = curColor\n    // 获取讨厌的人\n    const curPersonDislike = dislikeMap.get(curPerson) || []\n\n    for (const dis of curPersonDislike) {\n      // 如果讨厌的人已经染色了，并且颜色和自己一样，那么直接返回false\n      if (colors[dis] !== 0 && colors[dis] === colors[curPerson]) return false\n      // 如果当前还没有进行染色，那么递归调用dfs\n      // curColor ^ 3 实际上就是 把 1 变 2  把 2 变 1\n      if (colors[dis] === 0 && !dfs(dis, curColor ^ 3)) return false\n    }\n    return true\n  }\n\n  for (let i = 1; i <= n; i++) {\n    // 当前还未染色，并且染色过程发生冲突，直接返回false\n    if (colors[i] === 0 && !dfs(i, 1)) {\n      return false\n    }\n  }\n  return true\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335147767","body":"```\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function(moves) {\n  let up = 0;\n  let left = 0;\n\n  for (let index = 0; index < moves.length; index++) {\n    switch (moves[index]) {\n      case \"R\":\n        left++;\n        break;\n      case \"L\":\n        left--;\n        break;\n      case \"U\":\n        up++;\n        break;\n      case \"D\":\n        up--;\n        break;\n      default:\n        break;\n    }\n  }\n\n  if (up === 0 && left === 0) {\n    return true;\n  }\n  return false;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336125228","body":"```\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nconst getOrder = function (tasks) {\n  const queue = new MinPriorityQueue()\n  tasks = tasks.map((task, index) => ({\n    index,\n    start: task[0],\n    time: task[1]\n  }))\n  tasks.sort((a, b) => b.start - a.start)\n  const answer = []\n  let time = 0\n  while (tasks.length > 0 || !queue.isEmpty()) {\n    // 队列为空，且没有任务能加入队列，直接跳过时间\n    if (queue.isEmpty() && tasks[tasks.length - 1].start > time) {\n      time = tasks[tasks.length - 1].start\n    }\n\n    // 向队列中加入可执行任务\n    while (tasks.length > 0) {\n      if (tasks[tasks.length -1].start <= time) {\n        const task = tasks.pop()\n        queue.enqueue(task, task.time * 100000 + task.index)\n      } else {\n        break\n      }\n    }\n\n    // 执行任务\n    const { element: task } = queue.dequeue()\n    time += task.time\n    answer.push(task.index)\n  }\n  return answer\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336321895","body":"```\n/**\n * @param {string} startTime\n * @param {string} finishTime\n * @return {number}\n */\n var numberOfRounds = function(startTime, finishTime) {\n    let m1 = toMinutes(startTime),m2 = toMinutes(finishTime);\n\n    if (m1 > m2) {\n        m2 += 24 * 60;\n    }\n\n    let ans = Math.floor(m2 / 15) - Math.ceil(m1 / 15);\n    return ans < 0 ? 0 : ans;\n};\n\nfunction toMinutes(time) {\n    let [h, m] = time.split(':');\n    return Number(h) * 60 + Number(m);\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337374308","body":"```\n/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    let da = new Array(26).fill(0);\n    let db = new Array(26).fill(0);\n    for(let i in a) {\n        da[a.charCodeAt(i) - 97] ++;\n    }\n    for(let i in b) {\n        db[b.charCodeAt(i) - 97] ++;\n    }\n    let an = a.length, bn = b.length, asum = 0, bsum = 0, res = Number.MAX_SAFE_INTEGER;\n    for(let i = 0 ; i < 25 ; i ++) {\n        // 前缀和计算\n        asum += da[i];\n        bsum += db[i];\n        // 找最小值\n        res = Math.min(res, an+bn-da[i]-db[i], an-asum+bsum, bn-bsum+asum);\n    }\n    // z的特殊处理\n    return Math.min(res, an+bn-da[25]-db[25]);\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339015928","body":"```\n/**\n//冒泡排序\nvar sortArray = function(nums) {    \n    for (let i =nums.length-1,temp; i >= 0;i--){\n        for(let j = 0; j < i; j++){\n            if(nums[i]<nums[j]){\n                temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n            }\n        }\n    }\n    return nums;\n}; \n*/\n\n/**\n//选择排序\nvar sortArray = function(nums) {\n    for(let i = 0,temp,min; i < nums.length; i++){\n        min = nums[i];\n        for(let j = i+1; j < nums.length; j++){\n            if(min > nums[j]){\n                temp = min;\n                min = nums[j];\n                nums[j] = temp;\n            }\n        }\n        nums[i] = min;\n    }\nreturn nums;\n}; */\n\n\n/**\n//插入排序\nvar sortArray = function(nums) {\n    for(let i = 1; i <nums.length; i++){//i前是排序好的，i后是未排序的\n        curr = nums[i]\n        let j = i - 1;//在内层循环外可以用j，就不用每次交换，直接到合适位置插入。\n        for(; j >= 0; j--){\n            if(curr >= nums[j] ){\n                break;//更快结束循环\n            }\n              nums[j+1] = nums[j];//j+1是因为curr取出来所以可以顺序覆盖\n        }\n        nums[j+1] = curr;////j+1是因为内层循环-1后才发现<0，所以退出。所以需要加回去\n    }\n    return nums;\n};\n */\n\n\n/**\n//希尔排序\nvar sortArray = function(nums) {\n    //没有math的库，但是可以用js原生的parseInt!\n    for(let gap = parseInt(nums.length/2); gap > 0; gap = parseInt(gap/2)){\n        //循环2是有几组要排序【错！】\n         //循环2是从第gap个元素，逐个对其所在组进行直接插入排序操作\n         //分组的意义不是专门分组比较，直接顺延往后走就行，而是分组的是比较对象\n         //已排序的还是在前面，比较的还是和前面的比较\n         //除了多一层gap变化的循环，内层的变化只是比较的间隔变大，由-1变-gap\n        for(let i = gap; i< nums.length;i++){\n            let j = i-gap;\n            let min = nums[i];\n            for(; j >= 0; j = j-gap ){\n                if(min >= nums[j]){\n                    break;\n                }\n                nums[j+gap]=nums[j];\n                //min的值在最内层循环的不变，是插入排序！寻找的是j位置！\n            }\n            nums[j+gap]=min;\n        }\n\n    }\n    return nums\n}; */\n\n\n/** {\n//归并排序,递归\nvar sortArray = function(nums) {\n    let len = nums.length;\n    if(len<2){//递归结束条件！\n        return nums;\n    }\n    let middle = parseInt(len/2);\n    let left = nums.slice(0,middle);\n    let right = nums.slice(middle);\n    return merge(sortArray(left), sortArray(right));\n};\n\nvar merge = function(left,right){//合并\n    let result = [];\n    while(left.length && right.length){\n        if(left[0] < right[0]){\n            result.push(left.shift());//可以对原数组进行修改\n        }else{\n            result.push(right.shift());\n        }\n    }\n\n    if(left.length == 0){\n        result = result.concat(right);//拼接\n    }\n    if(right.length == 0){\n        result = result.concat(left);\n    }\n    return result;\n};\n}*/\n\n\n/*** \n//快速排序，递归\nvar sortArray = function(nums) {\n    var len = nums.length;\n    if(len < 2){\n        return nums;\n    }\n    let curr = nums[0];\n    let left = [];\n    let right = [];\n    for(let i = 1; i < len; i++){\n        if(nums[i] < curr){\n            left.push(nums[i]);\n        }else{\n            right.push(nums[i]);\n        }\n    }\n    result = sortArray(left).concat(curr,sortArray(right));\n    return result;\n};\n*/\n\n//堆排序\nvar sortArray = function(nums) {\n   //1.构建大顶堆\n    for(let i = parseInt(nums.length/2-1);i >= 0;i--){\n        //第一个非叶子结点是nums.length/2-1！\n         //从第一个非叶子结点从下至上，从右至左调整结构\n        adjustHeap(nums, i, nums.length);\n    }\n\n     //2.调整堆结构+交换堆顶元素与末尾元素\n     for(let j = nums.length-1; j > 0; j--){\n         //将堆顶元素与末尾元素进行交换。末尾的元素们就是已经排列好的了\n         let temp = nums[0];\n         nums[0] = nums[j];\n         nums[j] = temp;\n         adjustHeap(nums, 0, j);\n     }\n     return nums;\n};\n\nvar adjustHeap = function(arr, i, len){\n    let temp = arr[i];\n    //从i结点的左子结点开始，也就是2i+1处开始\n    for(let k = i*2+1; k < len ;k= k*2+1){//k=k*2+1，去到下一层的子节点。\n    //如果左子结点小于右子结点，k指向右子结点\n        if(k+1 < len && arr[k] < arr[k+1] ){\n            k++;\n        }\n    //如果子节点k大于父节点i，将子节点值赋给父节点（不用进行交换）\n        if(arr[k] > temp){\n            arr[i] = arr[k];\n            i = k;\n        }\n        else{\n            break;\n        }\n    }\n    arr[i] = temp;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340895493","body":"```\n/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function(x) {\n    if(x < 2) return x;\n    let left = 1;\n    let right = Math.floor(x / 2);\n    while(left <= right) {\n        let mid = Math.floor(left + (right - left) / 2);\n        if(mid * mid === x) return mid;\n        if(mid * mid < x) left = mid + 1;\n        else right = mid - 1;\n    }\n    return right;\n\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342355324","body":"```\n/**\n * Definition for isBadVersion()\n * \n * @param {integer} version number\n * @return {boolean} whether the version is bad\n * isBadVersion = function(version) {\n *     ...\n * };\n */\n\n/**\n * @param {function} isBadVersion()\n * @return {function}\n */\nvar solution = function(isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function(n) {\n        let left = 0\n        let right = n\n        let mid = Math.floor(n/2)\n        while(1){\n            if(isBadVersion(mid)==true){\n                right = mid\n                mid = Math.floor(mid/2)\n            }else if(isBadVersion(mid)==false){\n                left = mid\n                mid = mid + Math.floor((right-mid)/2)\n            } \n            if(isBadVersion(left)==true&&isBadVersion(left-1)==false) return left\n            if(isBadVersion(right)==true&&isBadVersion(right-1)==false) return right\n            if(isBadVersion(mid)==true&&isBadVersion(mid-1)==false) return mid\n\n        }\n    };\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345261207","body":"```\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        # 这里使用的是直径，因此最终返回需要除以 2\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345541990","body":"```\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar smallestDistancePair = function (nums, k) {\n    let count = []\n    for (let i = 0; i < nums.length - 1; ++i)\n        for (let j = i + 1; j < nums.length; ++j) {\n            let idx = Math.abs(nums[j] - nums[i])\n            count[idx] = count[idx] == undefined ? 1 : count[idx] + 1\n        }\n    let m = 0\n    while (k > 0) {\n        k -= (count[m] == undefined ? 0 : count[m])\n        m++\n    }\n    return m-1\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346101062","body":"```\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar swimInWater = function(grid) {\n    let ARR = [[0,1],[0,-1],[1,0],[-1,0]];\n    //记录所有已经访问过的点\n    let dp = new Array(grid.length).fill(0).map(i=>new Array(grid[0].length).fill(0));\n    let result = 0;\n    let stack=[[0,0]];\n\n    while(stack.length>0){\n        let [row,col] = stack.shift();\n        //用以记录当前已经保存的所有能走的点\n        result = Math.max(result,grid[row][col]);\n\n        if(row===grid.length-1 && col===grid[0].length-1){\n            //达到终点结束遍历\n            break;\n        }\n        for(let [dr,dc] of ARR){\n            let [nr,nc] = [dr+row,dc+col];\n            if(nr<grid.length && nr>=0 && nc<grid[0].length && nc>=0 && !dp[nr][nc]){\n                dp[nr][nc]=1\n                //此处若使用二分查找插入还能对时间进行优化\n                stack.push([nr,nc,grid[nr][nc]])\n            }\n        }\n        //排序还能使用二分插入法进行优化\n        stack.sort((a,b)=>a[2]-b[2])\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347797399","body":"```\n/**\n * @param {string} s\n * @param {number} k\n * @return {number}\n */\nvar maxVowels = function(s, k) {\n  let vowel = 'aeiou', len = s.length, count = 0, max = 0, i = 0;\n  \n  for (; i < k; i++) {\n    let curr = s.charAt(i);\n    if (vowel.indexOf(curr) !== -1) count++;\n  }\n  max = Math.max(max, count);\n  \n  for (; i < len; i++) {\n    let curr = s.charAt(i),\n        last = s.charAt(i - k);\n    if (vowel.indexOf(curr) !== -1) count++;\n    if (vowel.indexOf(last) !== -1) count--;\n    max = Math.max(count, max);\n  }\n  \n  return max;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350535342","body":"```\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} maxPts\n * @return {number}\n */\nvar new21Game = function(N, K, W) {\n    let dp = new Array(N+1).fill(0);\n    let sumArr = new Array(N+1).fill(0);\n    dp[0]=1;\n    for(let n=1;n<=N;n++){\n        let left = Math.max(0,n-W);\n        let right = Math.min(n-1,K-1);\n        let p=0\n        for(let i=left;i<=right;i++){\n            p+=dp[i]/W;\n        }\n        dp[n]=p;\n        sumArr[n]=sumArr[n-1]+p;\n    }\n    let result = 0;\n    for(let i=K;i<=N;i++){\n        result+=dp[i]\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352509127","body":"```\n/**\n * @param {string} s\n * @param {string} p\n * @return {number[]}\n */\n//写法1\nvar findAnagrams = function (s, p) {\n    let need = {};//需要的字符\n    let win = {};//窗口中的字符\n    for (let a of p) {//统计异位词的数量\n        need[a] = (need[a] || 0) + 1;\n    }\n    //左右指针\n    let left = 0,\n        right = 0;\n    let val = 0;//窗口中和need中字符数量一致的字符种类\n    let res = [];\n    while (right < s.length) {\n        let c = s[right];\n        right++;//右边的字符进入窗口\n        if (need[c]) {\n            win[c] = (win[c] || 0) + 1;//当前字符在need中，更新窗口中的字符数量\n            if (win[c] == need[c]) {\n                val++;//该字符在窗口中和need中的字符匹配时，字符种类+1\n            }\n        }\n        while (right - left >= p.length) {//不断出窗口\n            if (val == Object.keys(need).length) {//如果此时窗口中的子串和p是异位词则将左边界加入res中\n                res.push(left);\n            }\n            let d = s[left];\n            left++;//出窗口\n            if (need[d]) {//如果该字符在need中 更新窗口中的字符数量 和字符种类\n                if (win[d] == need[d]) {\n                    val--;\n                }\n                win[d]--;\n            }\n        }\n    }\n    return res;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354356439","body":"```\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    let l = 0\n    let r = 0\n    const need = new Map()\n    for(let c of t){\n        need.set( c,need.has(c) ? need.get(c) + 1 : 1)\n    }\n\n    let needType = need.size\n    let res = ''\n    while(r<s.length){\n        let c = s[r]\n        if(need.has(c)){\n            need.set( c,need.get(c) -1 )\n            if( need.get(c) === 0) needType -= 1\n        }\n        \n        while(needType === 0){\n            const newRes = s.substring(l,r+1)\n            if( !res || newRes.length < res.length ) res = newRes\n\n            const c2 = s[l]\n            if(need.has(c2)){\n                need.set(c2,need.get(c2) + 1)\n                if( need.get(c2) === 1 ) needType += 1\n            }\n            l += 1\n        }\n        r += 1\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356118195","body":"```\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356825460","body":"```\n/**\n * @param {number} turnedOn\n * @return {string[]}\n */\nconst readBinaryWatch = num => {\n    const nums = [1, 2, 4, 8, 1, 2, 4, 8, 16, 32]\n    let visited = new Array(nums.length).fill(0)\n    let result = []\n\n    readBinaryWatchCore(nums, visited, result, 0, num, 0)\n\n    return result\n}\n\n/**\n * 回溯法核心方法\n * \n * @param {[Number]} nums // 灯对应的值\n * @param {[Number]} visited // 所有灯的状态 \n * @param {[string]} result // 所有时间字符串 \n * @param {Number} step // 当前点亮灯的数量\n * @param {Number} num // 灯的数量 \n * @param {Number} start // 下一盏灯范围的起始位置 \n */\nconst readBinaryWatchCore = (nums, visited, result, step, num, start) => {\n    if (step === num) {\n        result.push(date(nums, visited))\n        return\n    }\n\n    for (let i = start; i < visited.length; i++) {\n        visited[i] = 1\n\n        if (!timeValid(nums, visited)) {\n            visited[i] = 0\n            continue\n        }\n\n        readBinaryWatchCore(nums, visited, result, step + 1, num, i + 1)\n        visited[i] = 0\n    }\n}\n\n/**\n * 检查生成的时间是否有效\n * @param {[Number]} nums \n * @param {[Number]} visited \n */\nconst timeValid = (nums, visited) => {\n    let h = 0, m = 0\n    for (let i = 0; i < visited.length; i++) {\n        if (visited[i] === 0) continue\n\n        if (i < 4) h += nums[i]\n        else m += nums[i]\n    }\n\n    return h >= 0 && h <= 11 && m >= 0 && m <= 59\n}\n\n/**\n * 转成时间字符串\n * @param {[Number]} nums \n * @param {[Number]} visited \n */\nconst date = (nums, visited) => {\n    let h = 0, m = 0\n    for (let i = 0; i < visited.length; i++) {\n        if (visited[i] === 0) continue\n\n        if (i < 4) h += nums[i]\n        else m += nums[i]\n    }\n\n    return `${h}:${m < 10 ? \"0\" : \"\"}${m}`\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359136334","body":"```\n/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar maxAreaOfIsland = function(grid) {\n    const gLen = grid.length\n    if (!gLen) {\n        return 0\n    }\n    const hLen = grid[0].length\n    // 存储当前所选元素在平面内上下左右四个方向元素\n    const d = [[-1, 0], [0, 1], [1, 0], [0, -1]]\n    // 维护递归过程中，平面中元素的使用状态，每个只能使用一次\n    const used = []\n    // 保存岛屿最大面积\n    let max = 0\n    let count = 0\n    // 判断所选元素是否在二维平面内\n    const inArea = function (x, y) {\n        return x >=0 && x < grid.length && y >=0 && y < grid[0].length\n    }\n    // 递归函数，深度优先遍历，从grid[i][j]开始移动，将所有链接的陆地标记为访问过\n    const dfs = function (grid, i, j) {\n        used[i][j] = true\n        count ++\n        for (let k = 0; k < 4; k++) {\n            const newX = i + d[k][0]\n            const newY = j + d[k][1]\n            if (inArea(newX, newY) && !used[newX][newY] && grid[newX][newY] == 1) {\n                dfs(grid, newX, newY)\n            }\n        }\n    }\n    for (let i = 0; i < gLen; i++) {\n        used.push(new Array(hLen).fill(false))\n    }\n    for (let i = 0; i < gLen; i++) {\n        for (let j = 0; j < hLen; j++) {\n            if (!used[i][j] && grid[i][j] == 1) {\n                dfs(grid, i, j)\n                max = Math.max(max, count)\n                count = 0\n            }\n        }\n    }\n    return max\n};\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362894579","body":"```\nclass Solution:\n    def solve(self, graph, target):\n        q = collections.deque([target])\n        visited = set()\n        steps = 0\n        while q:\n            for i in range(len(q)):\n                cur = q.popleft()\n                visited.add(cur)\n                for neighbor in graph[cur]:\n                    if neighbor not in visited:\n                        q.append(neighbor)\n                    elif neighbor == target:\n                        return steps + 1\n            steps += 1\n        return -1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364508743","body":"```\n/**\n * @param {number[]} cost\n * @return {number}\n */\n\nvar minCostClimbingStairs = function(cost) {\n    const dp = [];\n    dp[0] = dp[1] = 0;\n    //楼梯顶为cost.length\n    for (let i = 2; i <= cost.length; i++) {\n        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[cost.length];\n};```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364667551","body":"```\n/**\n * @param {number[]} nums\n * @return {number}\n */\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    const len = nums.length;\n    if(len == 0)\n        return 0;\n    const dp = new Array(len + 1);\n    dp[0] = 0;\n    dp[1] = nums[0];\n    for(let i = 2; i <= len; i++) {\n        dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);\n    }\n    return dp[len];\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367220108","body":"```\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} row\n * @param {number} column\n * @return {number}\n */\n/**\n * @param {number} n\n * @param {number} k\n * @param {number} row\n * @param {number} column\n * @return {number}\n */\nconst DIRS = [[1, 2], [2, 1], [1, -2], [-2, 1], [2, -1], [-1, 2], [-1, -2], [-2, -1]]\nvar knightProbability = function(n, k, row, column) {\n    const dp = new Array(n).fill(0).map(() => new Array(n).fill(0).map(() => new Array(k + 1).fill(0)));\n    for(let i = 0; i < n; i++)\n        for(let j = 0; j < n; j++)\n            dp[i][j][0] = 1\n    for(let i = 1; i <= k; i++)\n        for(let r = 0; r < n; r++)\n            for(let c = 0; c < n; c++)\n                for(const dir of DIRS) {\n                    const nr = r + dir[0], nc = c + dir[1]\n                    if(nr >= 0 && nr < n && nc >= 0 && nc < n){\n                        dp[r][c][i] += dp[nr][nc][i - 1]/8\n                    }\n                }\n    return dp[row][column][k]\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367872772","body":"```\n/**\n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\n/**\n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\n\n    // 先处理边界情况\n    if (maxChoosableInteger >= desiredTotal) {\n        return true\n    } else if ((1+maxChoosableInteger)*maxChoosableInteger < 2*desiredTotal) {\n        return false\n    }\n    // } else if (maxChoosableInteger % 2 === 1) {\n    //     return false\n    // } else if (((desiredTotal-1) % (maxChoosableInteger+2) === 0 \n    // || desiredTotal % max === 0 ) \n    // && maxChoosableInteger % 2 === 0) {\n    //     return true\n    // } else {\n    //     return false\n    // }\n\n    // 还是得用dfs，深度优先搜索+记忆化存储\n    // state上用二进制的每一位表示这个数是否被使用过，1表示使用过，0表示没有使用过\n    // state = 9 (001001) 表示1、4使用过\n    // 判断当前数i+1是否已经使用过的方法:\n    // 右移位运算a >> i 相当于把a的二进制数往右移动i位，也就是a / (2^i) 取整\n    // 9 >> 3 = 1，再和1按位与（1的前面所有都是0），判断最后一位是不是1。 1 & 1 = 1， 1&2 = 0\n    // state >> i & 1 === 1， 则i+1在state中使用过，也就是state右边数第i+1位是1。\n    // 往state中更新某一个数被新使用,按位或或者相加：state & (1<<i) 比如 9 | (1<<5) = 9 & 32 = 41\n    // state和currentTotal有关联关系。对特定题目的desiredTotal 和 maxChoosableInteger, dfs(state) 的结果唯一\n    // 记忆化体现在对于计算过的特定的state的dfs结果是true还是false，要缓存起来\n    let dfsRes = new Map()\n    // 初始的state=0， currentTotal也是0\n    const dfs=(state, maxChoosableInteger, currentTotal, desiredTotal) => {\n        // console.log(`${state.toString(2)}`,{currentTotal},' 49 line')\n        if (dfsRes.has(state)) {\n            return dfsRes.get(state)\n        } else {\n            for (let i=0; i<maxChoosableInteger; i++) {\n                // 如果第i + 1个数用过了，跳过\n                if ((state >> i) & 1 === 1) {\n                    continue\n                }\n                // state = state + (1 << i) // 错了，state和currentTotal不能每次都累加\n                // currentTotal += i + 1\n                // console.log(`${state.toString(2)}`,{currentTotal})\n                if (currentTotal + i + 1 >= desiredTotal) {\n                    dfsRes.set(state, true) // 不是 state + (1 << i)\n                    // console.log('here 62')\n                    return true\n                } else if (!dfs(state + (1 << i), maxChoosableInteger, currentTotal + i + 1, desiredTotal)) { // 如果下个递归调用者最终返回是false，表示我还是能赢\n                    dfsRes.set(state, true) // 只是表示当前state当前玩家可以必胜\n                    console.log('here 66')\n                    return true\n                }\n            }\n            dfsRes.set(state, false)\n            return false\n        } \n    }\n    return dfs(0, maxChoosableInteger, 0, desiredTotal)\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368210529","body":"```\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n // 这道题可以转化成一个求容量为sum / 2的背包问题，若正好可以填满背包，就返回true\n  const sum = nums.reduce((a, b) => a + b)\n  const len = nums.length\n  if (sum % 2 || len < 2) {\n      return false\n  }\n  const half = sum / 2\n  const res = []\n  for (let i = 0; i < half + 1; i++) {\n    res[i] = nums[0] <= i ? nums[0] : 0\n  }\n  for (let i = 1; i < len; i++) {\n    for (let j = half; j >= nums[i]; j--) {\n        // 更新不同物品放入的数字最大和        \n        res[j] = Math.max(res[j], nums[i] + res[j - nums[i]])\n    }\n  }\n  // 如果背包正好填满则返回true\n  return res[half] === half\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368408233","body":"```\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n\nvar findTargetSumWays = function (nums, target) {\n    let sum = 0;\n    for (const num of nums) {\n        sum += num;\n    }\n    const diff = sum - target;\n    if (diff < 0 || diff % 2 !== 0) {\n        return 0;\n    }\n    const n = nums.length, neg = diff / 2;\n    const dp = new Array(n + 1).fill(0).map(() => new Array(neg + 1).fill(0));\n    dp[0][0] = 1;\n    for (let i = 1; i <= n; i++) {\n        const num = nums[i - 1];\n        for (let j = 0; j <= neg; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= num) {\n                dp[i][j] += dp[i - 1][j - num];\n            }\n        }\n    }\n    return dp[n][neg];\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368702415","body":"```\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nconst coinChange = (coins, amount) => {\n    if(!amount) {\n        return 0;\n    }\n\n    let dp = Array(amount + 1).fill(Infinity);\n    dp[0] = 0;\n\n    for(let i =0; i < coins.length; i++) {\n        for(let j = coins[i]; j <= amount; j++) {\n            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);\n        }\n    }\n\n    return dp[amount] === Infinity ? -1 : dp[amount];\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370779692","body":"```\n/**\n * @param {number[]} g\n * @param {number[]} s\n * @return {number}\n */\nvar findContentChildren = function(g, s) {\n    // i：胃口的索引，j：尺寸的索引\n    let [index,i,j] = [0,0,0];\n    g.sort((a,b)=>a-b);\n    s.sort((a,b)=>a-b);\n    while(i<g.length && j<s.length){\n        if(g[i] <= s[j]){ // 若是当前尺寸满足胃口，进行下一组对比\n            index++;\n            i++;\n            j++;\n        }else if(g[i] > s[j]){ // 当前尺寸不满足胃口，对比下一个尺寸\n            j++;\n        }\n    }\n    return index;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372121559","body":"```\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    intervals.sort((a, b) => {\n        return a[1] - b[1]\n    })\n\n    let count = 1\n    let end = intervals[0][1]\n\n    for(let i = 1; i < intervals.length; i++) {\n        let interval = intervals[i]\n        if(interval[0] >= end) {\n            end = interval[1]\n            count += 1\n        }\n    }\n    \n    return intervals.length - count\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373409303","body":"```\n/**\n * @param {number[]} people\n * @param {number} limit\n * @return {number}\n */\nvar numRescueBoats = (people, limit) => {\n    if ( people.sort((a,b)=>a-b)[0] >= limit )return people.length\n    let res = 0\n    for( let i = 0,j = people.length-1 ; i <= j ; people[i] + people[j] <= limit && i++ , j--){\n        res++\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374448849","body":"```\n/**\n * @param {number} n\n * @return {number}\n */\nconst numTrees = (n) => {\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1;\n  dp[1] = 1;\n  for (let i = 2; i <= n; i++) {\n    for (let j = 0; j <= i - 1; j++) {\n      dp[i] += dp[j] * dp[i - j - 1];\n    }\n  }\n  return dp[n];\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374758707","body":"```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function(lists) {\n    function transform(l, arr) {\n        while(l) {\n            arr.push(l.val);\n            l = l.next;\n        }\n    }\n\n    let arr = [];\n    let res = new ListNode(null);\n\n    lists.map(item => transform(item, arr));\n    arr.sort((a, b) => a - b);\n    for (let i = arr.length - 1; i >= 0; i--) {\n        let temp = new ListNode(null);\n        res.val = arr[i];\n        temp.next = res;\n        res = temp;\n    }\n\n    return res.next;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375303050","body":"```\n/**\n * @param {number} n\n * @return {number[]}\n */\n/**\n * @param {number} n\n * @return {number[]}\n */\nvar beautifulArray = function(n) {\n    if (n === 1) return [1];\n    return [...beautifulArray(Math.ceil(n/2)).map(i => 2*i-1), ...beautifulArray(Math.floor(n/2)).map(i => 2*i)];\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377095488","body":"```\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\nvar singleNumber = function(nums) {\n    nums.sort();\n    const stack = [nums[0]];\n    let i = 1;\n    while(i < nums.length) {\n        const cur = stack[stack.length - 1];\n        if(cur === nums[i]) {\n            stack.pop();\n        } else {\n            stack.push(nums[i]);\n        }\n        i++;\n    }\n    return stack;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378681773","body":"```\n/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    let result = []\n    let path = []\n    function backtracking(startIndex) {\n        result.push(path.slice())\n        for(let i = startIndex; i < nums.length; i++) {\n            path.push(nums[i])\n            backtracking(i + 1)\n            path.pop()\n        }\n    }\n    backtracking(0)\n    return result\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380076340","body":"```\nfunction Node(val, isEnd){\n    this.val = val\n    this.child = {}\n    this.isEnd = isEnd|| false\n}\n\nvar Trie = function() {\n    this.root = new Node()\n};\n\n\nTrie.prototype.insert = function(word) {\n    let cur = this.root\n    for (let c of word){\n        if (cur.child[c] == null) cur.child[c] = new Node(c)\n        cur = cur.child[c]\n    }\n    cur.isEnd = true;\n};\n\n\nTrie.prototype.search = function(word) {\n    let cur = this.root\n    for (let c of word){\n        if (cur.child[c] == null) return false\n        cur = cur.child[c]\n    }\n    return cur.isEnd\n};\n\n\nTrie.prototype.startsWith = function(prefix) {\n    let cur = this.root\n    for (let c of prefix){\n        if (cur.child[c] == null) return false\n        cur = cur.child[c]\n    }\n    return true\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381697429","body":"```\nconst treeNode = function() {\n    this.childNode = new Array(26).fill(0);\n    this.isEnd = false;\n    this.val = null;\n}\n\nvar MapSum = function() {\n    this.tree = new treeNode()\n};\n\n/** \n * @param {string} key \n * @param {number} val\n * @return {void}\n */\nMapSum.prototype.insert = function(key, val) {\n    let curr = this.tree;\n    for(const x of key){\n        const idx = x.charCodeAt() - 'a'.charCodeAt()\n        if(curr.childNode[idx] === 0){\n            curr.childNode[idx] = new treeNode();\n        }\n        curr = curr.childNode[idx]\n        \n    }\n    curr.isEnd = true;\n    curr.val = val;\n    // console.log(this.tree)\n};\n\n/** \n * @param {string} prefix\n * @return {number}\n */\nMapSum.prototype.sum = function(prefix) {\n    let curr = this.tree;\n    for(const x of prefix){\n        const idx = x.charCodeAt() - 'a'.charCodeAt();\n        if(curr.childNode[idx] === 0){return null}\n        curr = curr.childNode[idx];\n    }\n    if(curr === 0){return null}\n\n    function dfs(root){\n        const children = root.childNode;\n        let sum = 0;\n        if(root.isEnd){sum += root.val}\n        for(const x of children){\n            if(x !== 0){\n                sum += dfs(x)\n            }\n        }\n\n        return sum;\n    }\n    return dfs(curr)\n};```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298389769","body":"## 思路\n取`num`与数字`k`的最大长度`maxLen`，构造`maxLen`大小的切片，然后从最后遍历数组，进行累加。 最后返回的时候，判断res[0]是否等于0，否则截取res[1:]\n\n## 代码\n\n```golang\nfunc addToArrayForm(num []int, k int) []int {\n\tkLen := 0\n\ttmpK := k\n\tfor tmpK > 0 {\n\t\ttmpK /= 10\n\t\tkLen++\n\t}\n\tnumLen := len(num)\n\tmaxLen := numLen\n\tif kLen > maxLen {\n\t\tmaxLen = kLen\n\t}\n\n\tres := make([]int, maxLen+1)\n\tfor index := numLen - 1; index >= 0; index-- {\n\t\tamount := num[index] + k%10\n\t\tk /= 10\n\t\tif amount >= 10 {\n\t\t\tk++\n\t\t\tamount -= 10\n\t\t}\n\t\tres[maxLen] = amount\n\t\tmaxLen--\n\t}\n\tfor k > 0 {\n\t\tres[maxLen] = k % 10\n\t\tk /= 10\n\t\tmaxLen--\n\t}\n\tif res[0] == 0 {\n\t\treturn res[1:]\n\t}\n\treturn res\n}\n```\n\n## 复杂度分析\n\n- 空间复杂度： O(n)\n\n- 时间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302330762","body":"```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n\trecord := []int{}\r\n\tfor index := 0; index < len(s); index++ {\r\n\t\tif s[index] == c {\r\n\t\t\trecord = append(record, index)\r\n\t\t}\r\n\t}\r\n\tpreIndex := 0\r\n\tlastIndex := 0\r\n\tans := make([]int, len(s))\r\n\tfor index, _ := range s {\r\n\t\tif lastIndex < len(record)-1 {\r\n\t\t\tif index > record[lastIndex] {\r\n\t\t\t\tpreIndex = lastIndex\r\n\t\t\t\tlastIndex++\r\n\t\t\t}\r\n\t\t}\r\n\t\tans[index] = min821(abs821(record[preIndex]-index), abs821(record[lastIndex]-index))\r\n\r\n\t}\r\n\r\n\treturn ans\r\n}\r\n\r\nfunc min821(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n\r\nfunc abs821(a int) int {\r\n\tif a < 0 {\r\n\t\treturn -a\r\n\t}\r\n\treturn a\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302290290","body":"## 思路\n数组模拟\n\n## 代码实现\n```golang\ntype CustomStack struct {\n    MaxSize int\n    elems []int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        MaxSize: maxSize,\n        elems: []int{},\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.elems) < this.MaxSize {\n        this.elems = append(this.elems, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.elems) == 0 {\n        return -1\n    }\n    res := this.elems[len(this.elems) - 1]\n    this.elems = this.elems[:len(this.elems) - 1]\n    return res\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    minLen := k\n    if len(this.elems) < k {\n        minLen = len(this.elems)\n    }\n    for index :=0; index < minLen; index++ {\n        this.elems[index] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n## 复杂度\n- 时间复杂度   push / pop O(1)  increment O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303603641","body":"## 思路\n模拟栈，并且插入一个 `#` 号键作为标识符\n\n## 代码\n```golang\nfunc decodeString1(s string) string {\n\tans := []rune{}\n\n\ti := true\n\tfor _, elem := range s {\n\t\tif elem >= '0' && elem <= '9' && i {\n\t\t\tans = append(ans, '#', elem)\n\t\t\ti = false\n\t\t} else if elem == '[' {\n\t\t\ti = true\n\t\t\tans = append(ans, elem)\n\t\t} else if elem == ']' {\n\t\t\ti = true\n\t\t\ttmpStr := \"\"\n\t\t\tamountStr := \"\"\n\t\t\tflag := false\n\t\t\tfor len(ans) > 0 {\n\t\t\t\tpopElem := ans[len(ans)-1]\n\t\t\t\tans = ans[:len(ans)-1]\n\t\t\t\tif popElem == '#' {\n\t\t\t\t\tbreak\n\t\t\t\t} else if popElem == '[' {\n\t\t\t\t\tflag = true\n\t\t\t\t} else if flag {\n\t\t\t\t\tamountStr = string(popElem) + amountStr\n\t\t\t\t} else {\n\t\t\t\t\ttmpStr = string(popElem) + tmpStr\n\t\t\t\t}\n\t\t\t}\n\t\t\tamount := 1\n\t\t\tif amountStr != \"\" {\n\t\t\t\tamount, _ = strconv.Atoi(amountStr)\n\t\t\t}\n\t\t\tstr := \"\"\n\t\t\tfor index := 0; index < amount; index++ {\n\t\t\t\tstr += tmpStr\n\t\t\t}\n\t\t\tans = append(ans, []rune(str)...)\n\n\t\t} else {\n\t\t\tans = append(ans, elem)\n\t\t}\n\t}\n\treturn string(ans)\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572444","body":"```golang\ntype MyQueue struct {\n\tinStack  []int\n\toutStack []int\n}\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{}\n}\n\nfunc (this *MyQueue) Push(x int) {\n\tthis.inStack = append(this.inStack, x)\n}\n\nfunc (this *MyQueue) Pop() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\tx := this.outStack[len(this.outStack)-1]\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\n\treturn x\n}\n\nfunc (this *MyQueue) Peek() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\treturn this.outStack[len(this.outStack)-1]\n}\n\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\n}\n\nfunc (this *MyQueue) in2Out() {\n\tfor len(this.inStack) > 0 {\n\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\n\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823193","body":"```golang\r\nfunc maxChunksToSorted(arr []int) int {\r\n\tsize := len(arr)\r\n\r\n\ttmpArr := make([]int, size)\r\n\tcopy(tmpArr, arr)\r\n\tsort.Sort(sort.IntSlice(tmpArr))\r\n\tnum := 0\r\n\tsum1, sum2 := 0, 0\r\n\tfor index, value := range arr {\r\n\t\tsum1 += tmpArr[index]\r\n\t\tsum2 += value\r\n\t\tif sum1 == sum2 {\r\n\t\t\tnum++\r\n\t\t}\r\n\t}\r\n\treturn num\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305770525","body":"## 思路\r\n闭环需要进行取模运算， 2个指针间隔k个节点，向尾结点一起遍历， 较快节点达到最后一个元素停止。 fast.next=head, slower.next = newHead, slow.next=nil 断开环形\r\n\r\n## 代码\r\n```golang\r\ntype ListNode struct {\r\n\tVal  int\r\n\tNext *ListNode\r\n}\r\n\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tfast, slow, finalList := head, head, head\r\n\tnodeLen := 0\r\n\tfor finalList != nil {\r\n\t\tfinalList = finalList.Next\r\n\t\tnodeLen++\r\n\t}\r\n\r\n\tk = k % nodeLen\r\n\r\n\tfor fast.Next != nil {\r\n\t\tfast = fast.Next\r\n\t\tif k > 0 {\r\n\t\t\tk--\r\n\t\t} else {\r\n\t\t\tslow = slow.Next\r\n\t\t}\r\n\t}\r\n\r\n\tfast.Next = head\r\n\tfinalList = slow.Next\r\n\tslow.Next = nil\r\n\r\n\treturn finalList\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307371768","body":"## code\r\n```golang\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n\tif head == nil || head.Next == nil {\r\n\t\treturn head\r\n\t}\r\n\tdummy := &ListNode{\r\n\t\tNext: head,\r\n\t}\r\n\tp := dummy\r\n\tfor p.Next != nil && p.Next.Next != nil {\r\n\t\tone := p.Next\r\n\t\ttwo := p.Next.Next\r\n\t\tp.Next = one.Next\r\n\t\tone.Next = two.Next\r\n\t\ttwo.Next = one\r\n\t\tp = one.Next\r\n\t}\r\n\treturn dummy.Next\r\n}\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308879305","body":"```golang\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n\treturn treeCreate(head, nil)\r\n}\r\n\r\nfunc treeCreate(head *ListNode, tail *ListNode) *TreeNode {\r\n\tif head == tail {\r\n\t\treturn nil\r\n\t}\r\n\tfast, slow := head, head\r\n\tfor fast != tail && fast.Next != tail {\r\n\t\tfast = fast.Next.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\tleft := treeCreate(head, slow)\r\n\tright := treeCreate(slow.Next, tail)\r\n\r\n\treturn &TreeNode{\r\n\t\tVal:   slow.Val,\r\n\t\tLeft:  left,\r\n\t\tRight: right,\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310427436","body":"```golang \r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n\tone := headA\r\n\ttwo := headB\r\n\r\n\tfor one != two {\r\n\t\tif one != nil {\r\n\t\t\tone = one.Next\r\n\t\t} else {\r\n\t\t\tone = headB\r\n\t\t}\r\n\r\n\t\tif two != nil {\r\n\t\t\ttwo = two.Next\r\n\t\t} else {\r\n\t\t\ttwo = headA\r\n\t\t}\r\n\t}\r\n\treturn one\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311807261","body":"```golang\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n\tfast, slow := head, head\r\n\tfor fast != nil && fast.Next != nil {\r\n\t\tslow = slow.Next\r\n\t\tfast = fast.Next.Next\r\n\t\tif fast == slow {\r\n\t\t\tbreak\r\n\t\t}\r\n\t}\r\n\tif fast == nil || fast.Next == nil {\r\n\t\treturn nil\r\n\t}\r\n\tfast = head\r\n\tfor fast != slow {\r\n\t\tfast = fast.Next\r\n\t\tslow = slow.Next\r\n\t}\r\n\treturn fast\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312493252","body":"用的golang的list标准库。。\n```golang\ntype LRUCache struct {\n    Size int\n    l *list.List\n    Data map[int]*element\n}\n\ntype element struct{\n    Value int\n    e *list.Element\n}\n\n\nfunc Constructor(capacity int) LRUCache {\n    return LRUCache{\n        Size: capacity,\n        Data: map[int]*element{},\n        l: list.New(),\n    }\n}\n\n\nfunc (this *LRUCache) Get(key int) int {\n    if element, ok := this.Data[key]; ok{\n        this.l.MoveToBack(element.e)\n        return element.Value\n    }\n    return -1;\n}\n\n\nfunc (this *LRUCache) Put(key int, value int)  {\n    if this.Get(key) != -1{\n        this.l.MoveToBack(this.Data[key].e)\n        this.Data[key].Value = value\n    } else {\n        this.l.PushBack(key)\n        this.Data[key] = &element{\n            Value: value,\n            e: this.l.Back(),\n        }\n    }\n    if len(this.Data) > this.Size{\n        delete(this.Data, this.l.Remove(this.l.Front()).(int))\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312758709","body":"## 思路\r\n子问题就是：每个父节点的深度等于子节点最大深度+1\r\n\r\n## 代码\r\n```golang\r\nfunc maxDepth(root *TreeNode) int {\r\n\tif root == nil {\r\n\t\treturn 0\r\n\t}\r\n\r\n\treturn max104(1+maxDepth(root.Left), 1+maxDepth(root.Right))\r\n}\r\n\r\nfunc max104(a, b int) int {\r\n\tif a > b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n```\r\n## 复杂度\r\n- 空间复杂度 O(n)\r\n- 时间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313044655","body":"## 思路\r\n先判断一个节点是否相等， 然后递归调用\r\n\r\n## 代码\r\n```golang\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n\tif p == nil && q == nil {\r\n\t\treturn true\r\n\t} else if p == nil || q == nil {\r\n\t\treturn false\r\n\t}\r\n\tif p.Val != q.Val {\r\n\t\treturn false\r\n\t}\r\n\ta := isSameTree(p.Left, q.Left)\r\n\tb := isSameTree(p.Right, q.Right)\r\n\treturn a && b\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315057850","body":"## 思路\n递归实现，每往下一层，当前数字就X10， 然后将parentNum与当前节点的val相加，最后判断如果该节点时最后一个节点，那么就将该数字加到总数上\n## 代码\n```golang\nfunc sumNumbers(root *TreeNode) int {\n\tvar result int\n\tvar dfs func(node *TreeNode, parentNum int)\n\tdfs = func(node *TreeNode, parentNum int) {\n\t\tif node != nil {\n\t\t\tcurrentNum := parentNum + node.Val\n\t\t\tif node.Left == nil && node.Right == nil {\n\t\t\t\tresult += currentNum\n\t\t\t} else {\n\t\t\t\tdfs(node.Left, currentNum*10)\n\t\t\t\tdfs(node.Right, currentNum*10)\n\t\t\t}\n\t\t} else {\n\n\t\t}\n\t}\n\tdfs(root, 0)\n\treturn result\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1315618356","body":"```golang\nfunc findBottomLeftValue(root *TreeNode) int {\n\tres := root.Val\n\tmaxAmount := 0\n\tvar dfs func(node *TreeNode, amount int)\n\tdfs = func(node *TreeNode, amount int) {\n\t\tif node != nil {\n\t\t\tif node.Left == nil && maxAmount < amount+1 {\n\t\t\t\tres = node.Val\n\t\t\t\tmaxAmount = amount + 1\n\t\t\t}\n\t\t\tif node.Left != nil {\n\t\t\t\tdfs(node.Left, amount+1)\n\t\t\t}\n\t\t\tif node.Right != nil {\n\t\t\t\tdfs(node.Right, amount+1)\n\t\t\t}\n\t\t}\n\n\t}\n\tdfs(root.Left, 0)\n\tdfs(root.Right, 0)\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318842622","body":"```golang\r\ntype Codec struct {\r\n}\r\n\r\nfunc Constructor() Codec {\r\n\treturn Codec{}\r\n}\r\n\r\n// Serializes a tree to a single string.\r\nfunc (this *Codec) serialize(root *TreeNode) string {\r\n\tsp := &strings.Builder{}\r\n\tvar dfs func(node *TreeNode)\r\n\tdfs = func(node *TreeNode) {\r\n\t\tif node == nil {\r\n\t\t\tsp.WriteString(\"null,\")\r\n\t\t\treturn\r\n\t\t}\r\n\t\tsp.WriteString(strconv.Itoa(node.Val))\r\n\t\tsp.WriteString(\",\")\r\n\t\tdfs(node.Left)\r\n\t\tdfs(node.Right)\r\n\t}\r\n\tdfs(root)\r\n\treturn sp.String()\r\n}\r\n\r\n// Deserializes your encoded data to tree.\r\nfunc (this *Codec) deserialize(data string) *TreeNode {\r\n\tsp := strings.Split(data, \",\")\r\n\tvar build func() *TreeNode\r\n\tbuild = func() *TreeNode {\r\n\t\tif sp[0] == \"null\" {\r\n\t\t\tsp = sp[1:]\r\n\t\t\treturn nil\r\n\t\t}\r\n\t\tval, _ := strconv.Atoi(sp[0])\r\n\t\tsp = sp[1:]\r\n\t\treturn &TreeNode{\r\n\t\t\tVal:   val,\r\n\t\t\tLeft:  build(),\r\n\t\t\tRight: build(),\r\n\t\t}\r\n\t}\r\n\treturn build()\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320216711","body":"```golang\nfunc verticalTraversal(root *TreeNode) [][]int {\n\trecord := make(map[*TreeNode][]int)\n\n\tvalMap := make(map[int][]int)\n\tmin, max := 0, 0\n\n\tvar dfs func(node *TreeNode, point []int)\n\tdfs = func(node *TreeNode, point []int) {\n\t\tif node == nil {\n\t\t\treturn\n\t\t}\n\t\trecord[node] = point\n\t\tif _, ok := valMap[point[1]]; ok {\n\t\t\tvalMap[point[1]] = append(valMap[point[1]], node.Val)\n\t\t} else {\n\t\t\tvalMap[point[1]] = []int{node.Val}\n\t\t}\n\n\t\tif point[1] < min {\n\t\t\tmin = point[1]\n\t\t}\n\t\tif point[1] > max {\n\t\t\tmax = point[1]\n\t\t}\n\t\tdfs(node.Left, []int{point[0] + 1, point[1] - 1})\n\t\tdfs(node.Right, []int{point[0] + 1, point[1] + 1})\n\t}\n\tdfs(root, []int{0, 0})\n\tres := [][]int{}\n\n\tfor index := min; index <= max; index++ {\n\t\tvals := valMap[index]\n\t\tsort.Ints(vals)\n\t\tres = append(res, vals)\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1321157862","body":"```golang\r\nfunc twoSum(nums []int, target int) []int {\r\n    numMap := make(map[int]int)\r\n    for index, value := range nums{\r\n        if _, ok := numMap[target - value];ok{\r\n            return []int{numMap[target - value], index}\r\n        }\r\n        numMap[value] = index\r\n    }\r\n    return []int{0}\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162889","body":"```golang \r\ntype tt struct {\r\n\tnum    int\r\n\tamount int\r\n}\r\n\r\nfunc topKFrequent(nums []int, k int) []int {\r\n\trecord := make(map[int]int)\r\n\tarr := []*tt{}\r\n\tseq := 0\r\n\tfor _, num := range nums {\r\n\t\tif index, ok := record[num]; ok {\r\n\t\t\tarr[index].amount += 1\r\n\t\t} else {\r\n\t\t\trecord[num] = seq\r\n\t\t\tseq++\r\n\t\t\tarr = append(arr, &tt{\r\n\t\t\t\tnum:    num,\r\n\t\t\t\tamount: 1,\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\tsort.Slice(arr, func(i, j int) bool {\r\n\t\ta, b := arr[i], arr[j]\r\n\t\treturn a.amount > b.amount\r\n\t})\r\n\tres := make([]int, k)\r\n\tfor index := 0; index < k; index++ {\r\n\t\tres[index] = arr[index].num\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321990309","body":"```golang\nfunc numberOfBoomerangs(points [][]int) int {\n\tres := 0\n\tfor i, firstElem := range points {\n\t\thashMap := make(map[int]int)\n\t\tfor j, secondElem := range points {\n\t\t\tif i == j {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tx, y := secondElem[0]-firstElem[0], secondElem[1]-firstElem[1]\n\t\t\tdis := x*x + y*y\n\t\t\thashMap[dis]++\n\t\t}\n\t\tfor _, val := range hashMap {\n\t\t\tres += val * (val - 1)\n\t\t}\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323863894","body":"```golang\nfunc lengthOfLongestSubstring(s string) int {\n\tleft, right := 0, 0\n\tans := 0\n\thashMap := make(map[byte]int)\n\tfor right < len(s) {\n\t\ta := s[right]\n\t\tif val, ok := hashMap[a]; ok {\n\t\t\tif left < val {\n\t\t\t\tleft = val\n\t\t\t}\n\t\t}\n\t\tif ans < right-left+1 {\n\t\t\tans = right - left + 1\n\t\t}\n\t\thashMap[a] = right + 1\n\t\tright++\n\t}\n\treturn ans\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1326565240","body":"```golang\r\nfunc findSubstring(s string, words []string) []int {\r\n\tstrLen := len(s)\r\n\twordCount := len(words)\r\n\twordLen := len(words[0])\r\n\r\n\twordDict := map[string]int{}\r\n\tfor _, word := range words {\r\n\t\twordDict[word] += 1\r\n\t}\r\n\r\n\tvalidLen := wordCount * wordLen\r\n\tres := []int{}\r\n\tfor index := 0; index < strLen-validLen+1; index++ {\r\n\t\tcurrentEndIndex := index + validLen\r\n\t\tcurStr := s[index:currentEndIndex]\r\n\t\tmatchDict := map[string]int{}\r\n\r\n\t\tj := 0\r\n\t\tfor ; j < currentEndIndex-index; j += wordLen {\r\n\t\t\tword := curStr[j : j+wordLen]\r\n\t\t\tif _, ok := wordDict[word]; !ok {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tmatchDict[word] += 1\r\n\t\t\tif matchDict[word] > wordDict[word] {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif j == currentEndIndex-index {\r\n\t\t\tres = append(res, index)\r\n\t\t}\r\n\t}\r\n\treturn res\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326618573","body":"```golang\r\nfunc subarraysDivByK(nums []int, k int) int {\r\n\tm := map[int]int{\r\n\t\t0: -1,\r\n\t}\r\n\ttotal := 0\r\n\tfor _, num := range nums {\r\n\t\ttotal += num\r\n\t}\r\n\tmod := total % k\r\n\r\n\tpreTotal := 0\r\n\tans := len(nums)\r\n\tfor index, num := range nums {\r\n\t\tpreTotal += num\r\n\t\tcurMod := preTotal % k\r\n\t\ttarget := (curMod - mod + k) % k\r\n\t\tif val, ok := m[target]; ok {\r\n\t\t\tif index-val < ans {\r\n\t\t\t\tans = index - val\r\n\t\t\t}\r\n\t\t}\r\n\t\tm[curMod] = index\r\n\t}\r\n\tif ans == len(nums) {\r\n\t\treturn -1\r\n\t}\r\n\treturn ans\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327628573","body":"快慢指针\n\n```golang\nfunc middleNode(head *ListNode) *ListNode {\n\tslower, faster := head, head\n\tfor faster != nil && faster.Next != nil {\n\t\tslower = slower.Next\n\t\tfaster = faster.Next.Next\n\t}\n\treturn slower\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328069651","body":"```golang\nfunc removeDuplicates(nums []int) int {\n    index, fast := 0, 1\n    for ;fast<len(nums);fast++{\n        if nums[index] != nums[fast]{\n            index++\n            nums[index] = nums[fast]\n        }\n    }\n    return index + 1\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328269810","body":"二分查找法\n\n```golang\nfunc searchInsert(nums []int, target int) int {\n\tleft, right := 0, len(nums)-1\n\n\tfor left <= right {\n\t\tmid := left + (right-left)/2\n\t\tif nums[mid] < target {\n\t\t\tleft = mid + 1\n\t\t} else if nums[mid] > target {\n\t\t\tright = mid - 1\n\t\t} else {\n\t\t\treturn mid\n\t\t}\n\t}\n\treturn left\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329321445","body":"```golang\nfunc maxSlidingWindow(nums []int, k int) []int {\n\tif k > len(nums) {\n\t\treturn nil\n\t}\n\n\tslipArr := []int{}\n\tpush := func(i int) {\n\t\tfor len(slipArr) > 0 && nums[i] >= nums[slipArr[len(slipArr)-1]] {\n\t\t\tslipArr = slipArr[:len(slipArr)-1]\n\t\t}\n\t\tslipArr = append(slipArr, i)\n\t}\n\tfor index := 0; index < k; index++ {\n\t\tpush(index)\n\t}\n\n\tres := []int{nums[slipArr[0]]}\n\n\tfor index := k; index < len(nums); index++ {\n\t\tpush(index)\n\t\tfor slipArr[0] <= index-k {\n\t\t\tslipArr = slipArr[1:]\n\t\t}\n\t\tres = append(res, nums[slipArr[0]])\n\t}\n\treturn res\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330858688","body":"```golang\nfunc findJudge(n int, trust [][]int) int {\n\trecord := make([]int, n+1)\n\tblack := make([]int, n+1)\n\tfor _, item := range trust {\n\t\tblack[item[0]]++\n\t\trecord[item[1]]++\n\t}\n\tfor index := 1; index <= n; index++ {\n\t\tif record[index] == n-1 && black[index] == 0 {\n\t\t\treturn index\n\t\t}\n\t}\n\treturn -1\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332377548","body":"```golang\nfunc possibleBipartition(n int, dislikes [][]int) bool {\n\tok := true\n\tcolor := make([]bool, n+1)\n\tvisited := make([]bool, n+1)\n\n\tbuildGraph := func(n int, disLikes [][]int) [][]int {\n\t\tgraph := make([][]int, n+1)\n\t\tfor index := 1; index <= n; index++ {\n\t\t\tgraph[index] = []int{}\n\t\t}\n\t\tfor _, edge := range disLikes {\n\t\t\tv := edge[1]\n\t\t\tw := edge[0]\n\t\t\tgraph[v] = append(graph[v], w)\n\t\t\tgraph[w] = append(graph[w], v)\n\t\t}\n\t\treturn graph\n\t}\n\n\tvar traverse func(graph [][]int, v int)\n\ttraverse = func(graph [][]int, v int) {\n\t\tif !ok {\n\t\t\treturn\n\t\t}\n\t\tvisited[v] = true\n\t\tfor _, w := range graph[v] {\n\t\t\tif visited[w] {\n\t\t\t\tif color[w] == color[v] {\n\t\t\t\t\tok = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcolor[w] = !color[v]\n\t\t\t\ttraverse(graph, w)\n\t\t\t}\n\t\t}\n\t}\n\n\tgraph := buildGraph(n, dislikes)\n\tfor v := 1; v <= n; v++ {\n\t\tif !visited[v] {\n\t\t\ttraverse(graph, v)\n\t\t}\n\t}\n\treturn ok\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335401777","body":"```golang \nfunc judgeCircle(moves string) bool {\n\tpoint := []int{0, 0}\n\tfor _, move := range moves {\n\t\tif move == 'U' {\n\t\t\tpoint[0] += 1\n\t\t} else if move == 'D' {\n\t\t\tpoint[0] -= 1\n\t\t} else if move == 'L' {\n\t\t\tpoint[1] -= 1\n\t\t} else if move == 'R' {\n\t\t\tpoint[1] += 1\n\t\t}\n\t}\n\treturn point[0] == 0 && point[1] == 0\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336186133","body":"```golang\ntype pair struct{ t, i int }\ntype hp []pair\n\nfunc (h hp) Len() int            { return len(h) }\nfunc (h hp) Less(i, j int) bool  { a, b := h[i], h[j]; return a.t < b.t || a.t == b.t && a.i < b.i }\nfunc (h hp) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\nfunc (h *hp) Push(v interface{}) { *h = append(*h, v.(pair)) }\nfunc (h *hp) Pop() interface{}   { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }\nfunc (h *hp) push(v pair)        { heap.Push(h, v) }\nfunc (h *hp) pop() pair          { return heap.Pop(h).(pair) }\n\nfunc getOrder(a [][]int) (ans []int) {\n\tfor i := range a {\n\t\ta[i] = append(a[i], i)\n\t}\n\tsort.Slice(a, func(i, j int) bool { return a[i][0] < a[j][0] })\n\th := &hp{}\n\tfor i, cur, n := 0, 0, len(a); i < n; {\n\t\tif h.Len() > 0 {\n\t\t\tp := h.pop()\n\t\t\tans = append(ans, p.i)\n\t\t\tcur += p.t\n\t\t}\n\t\tif h.Len() == 0 && cur < a[i][0] {\n\t\t\tcur = a[i][0]\n\t\t}\n\t\tfor ; i < n && a[i][0] <= cur; i++ {\n\t\t\th.push(pair{a[i][1], a[i][2]})\n\t\t}\n\t}\n\tfor h.Len() > 0 {\n\t\tans = append(ans, h.pop().i)\n\t}\n\treturn\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336427902","body":"```golang\nfunc numberOfRounds(loginTime string, logoutTime string) int {\n\tans := 0\n\tloginArr := strings.Split(loginTime, \":\")\n\tlogoutArr := strings.Split(logoutTime, \":\")\n\tloginHour, _ := strconv.Atoi(loginArr[0])\n\tloginMinute, _ := strconv.Atoi(loginArr[1])\n\tlogoutHour, _ := strconv.Atoi(logoutArr[0])\n\tlogoutMinute, _ := strconv.Atoi(logoutArr[1])\n\n\tt0 := loginHour*60 + loginMinute\n\tt1 := logoutHour*60 + logoutMinute\n\n\tif t1 < t0 {\n\t\tt1 += 1440\n\t}\n\tt1 = t1 / 15 * 15\n\tans = (t1 - t0) / 15\n\n\treturn ans\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337594584","body":"```golang\nfunc minCharacters(a string, b string) int {\n\tm := len(a)\n\tn := len(b)\n\tans := m + n\n\tcharA := make([]int, 26)\n\tcharB := make([]int, 26)\n\tfor _, char := range a {\n\t\tcharA[char-'a'] += 1\n\t}\n\tfor _, char := range b {\n\t\tcharB[char-'a'] += 1\n\t}\n\n\tfor i := 0; i < 26; i++ {\n\t\tm1 := m - charA[i]\n\t\tn1 := n - charB[i]\n\t\tans := min1737(ans, m1+n1)\n\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tr1 := 0\n\t\tr2 := 0\n\n\t\t// a < b || b < a\n\t\tfor j := i; j < 26; j++ {\n\t\t\tr1 += charA[j]\n\t\t\tr2 += charB[j]\n\t\t}\n\t\tfor j := 0; j < i; j++ {\n\t\t\tr1 += charB[j]\n\t\t\tr2 += charA[j]\n\t\t}\n\t\tans = min1737(ans, min1737(r1, r2))\n\t}\n\n\treturn ans\n}\n\nfunc min1737(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339488948","body":"```golang\n\nfunc sortArray(nums []int) []int {\n\tif len(nums) < 2 {\n\t\treturn nums\n\t}\n\tfor i := 0; i < len(nums); i++ {\n\t\ttmp := nums[i]\n\t\tj := i\n\t\tfor ; j > 0 && nums[j-1] > tmp; j-- {\n\t\t\tnums[j] = nums[j-1]\n\t\t}\n\t\tif i != j {\n\t\t\tnums[j] = tmp\n\t\t}\n\t}\n\treturn nums\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341099839","body":"```golang\nfunc mySqrt(x int) int {\n\tl := 0\n\tr := x\n\tans := -1\n\tfor l <= r {\n\t\tmid := l + (r-l)/2\n\t\tif mid*mid <= x {\n\t\t\tans = mid\n\t\t\tl = mid + 1\n\t\t} else {\n\t\t\tr = mid - 1\n\t\t}\n\t}\n\treturn ans\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1344249424","body":"```golang\r\nfunc firstBadVersion(n int) int {\r\n\tleft := 1\r\n\tright := n\r\n\r\n\tfor left <= right {\r\n\t\tmid := left + (right-left)/2\r\n\t\tif isBadVersion(mid) {\r\n\t\t\tright = mid - 1\r\n\t\t} else {\r\n\t\t\tleft = mid + 1\r\n\t\t}\r\n\t}\r\n\treturn left\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344321068","body":"```golang\r\nfunc reversePairs(nums []int) int {\r\n\tcount := 0\r\n\ttemp := make([]int, len(nums))\r\n\r\n\tvar sort func(nums []int, lo, hi int)\r\n\tvar merge func(nums []int, lo, mid, hi int)\r\n\tsort = func(nums []int, lo, hi int) {\r\n\t\tif lo == hi {\r\n\t\t\treturn\r\n\t\t}\r\n\t\tmid := lo + (hi-lo)/2\r\n\t\tsort(nums, lo, mid)\r\n\t\tsort(nums, mid+1, hi)\r\n\r\n\t\tmerge(nums, lo, mid, hi)\r\n\t}\r\n\tmerge = func(nums []int, lo, mid, hi int) {\r\n\t\tfor i := lo; i <= hi; i++ {\r\n\t\t\ttemp[i] = nums[i]\r\n\t\t}\r\n\t\tend := mid + 1\r\n\t\tfor i := lo; i <= mid; i++ {\r\n\t\t\tfor end <= hi && nums[i] > nums[end]*2 {\r\n\t\t\t\tend++\r\n\t\t\t}\r\n\t\t\tcount += end - (mid + 1)\r\n\t\t}\r\n\t\ti := lo\r\n\t\tj := mid + 1\r\n\t\tfor p := lo; p <= hi; p++ {\r\n\t\t\tif i == mid+1 {\r\n\t\t\t\tnums[p] = temp[j]\r\n\t\t\t\tj++\r\n\t\t\t} else if j == hi+1 {\r\n\t\t\t\tnums[p] = temp[i]\r\n\t\t\t\ti++\r\n\t\t\t} else if temp[i] > temp[j] {\r\n\t\t\t\tnums[p] = temp[j]\r\n\t\t\t\tj++\r\n\t\t\t} else {\r\n\t\t\t\tnums[p] = temp[i]\r\n\t\t\t\ti++\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tsort(nums, 0, len(nums)-1)\r\n\treturn count\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345276091","body":"```golang\nfunc solve(nums []int) float32 {\n\tpossible := func(mid int) bool {\n\t\tstart := nums[0]\n\t\tend := start + mid\n\t\tfor i := 0; i < 3; i++ {\n\t\t\tindex := 0\n\t\t\tfor nums[index] <= end {\n\t\t\t\tindex++\n\t\t\t}\n\t\t\tif index >= len(nums) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tstart = nums[index]\n\t\t\tend = start + mid\n\t\t}\n\t\treturn false\n\t}\n\n\tl := 0\n\tr := nums[len(nums)-1] - nums[0]\n\tfor l <= r {\n\t\tmid := l + (r-l)/2\n\t\tif possible(mid) {\n\t\t\tr = mid - 1\n\t\t} else {\n\t\t\tl = mid + 1\n\t\t}\n\t}\n\treturn float32(l) / 2\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348726907","body":"```golang\nfunc maxVowels(s string, k int) int {\n\tans := 0\n\tl := 0\n\tr := k\n\tcount := 0\n\tfor i := 0; i < k; i++ {\n\t\telem := s[i]\n\t\tif elem == 'a' || elem == 'e' || elem == 'i' || elem == 'o' || elem == 'u' {\n\t\t\tcount++\n\t\t}\n\t}\n\tans = count\n\n\tfor r < len(s) {\n\t\tleftElem := s[l]\n\t\tnextElem := s[r]\n\t\tif leftElem == 'a' || leftElem == 'e' || leftElem == 'i' || leftElem == 'o' || leftElem == 'u' {\n\t\t\tcount--\n\t\t}\n\t\tif nextElem == 'a' || nextElem == 'e' || nextElem == 'i' || nextElem == 'o' || nextElem == 'u' {\n\t\t\tcount++\n\t\t}\n\t\tif ans < count {\n\t\t\tans = count\n\t\t}\n\t\tif ans == k {\n\t\t\treturn ans\n\t\t}\n\t\tl++\n\t\tr++\n\t}\n\treturn ans\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298393989","body":"## 思路\n- 将K和数组每一位相加，取余得出新数组每一位的数值，将相加的和作为进位。需要注意边界。\n## 代码\n```java\npublic class Solution {\n    public static List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList();\n        for(int i=num.length-1;i>=0;i--){\n            int sum = k + num[i];\n            result.add(sum%10);\n            k = sum/10;\n        }\n        if (k > 9) {\n            while(k > 9) {\n                int data = k%10;//取余\n                k = k/10;\n                result.add(data);\n            }\n            result.add(k);\n        }else if (k>0 && k<=9){\n            result.add(k);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1305452446","body":"## 思路\r\n- 栈的最大容量是确定的，可以考虑使用数组来实现，不用考虑扩容\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    private int[] data;\r\n    private int index;\r\n    public CustomStack(int maxSize) {\r\n        data = new int[maxSize];\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == data.length) {\r\n            return;\r\n        }\r\n        data[index] = x;\r\n        index++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index == 0) {\r\n            return -1;\r\n        }else{\r\n            int temp = data[index-1];\r\n            index--;\r\n            return temp;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i=0;i<k;i++) {\r\n            if(i < index) {\r\n                data[i] = data[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：push:O(1), pop:O(1),increment:O(N)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1305460621","body":"## 思路\r\n- 使用两个栈来回倒腾元素\r\n## 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new Stack();\r\n        stack2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack1.push(x);\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        } \r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        return stack1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return stack1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：push:O(1), pop:O(1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305422647","body":"## 思路\n- 先把链表成环，移动K次后断开环形链表。\n## 代码\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null){\n            return head;\n        }\n        //先成环\n        ListNode cur = head;\n        ListNode prev = new ListNode(-1);\n        prev.next = head;\n        int len = 1;\n        while(cur.next != null){\n            cur = cur.next;\n            prev = prev.next;\n            len++;\n        }\n        cur.next = head;\n        int num = len - k%len + 1;\n        while(num>0){\n            prev = prev.next;\n            cur = cur.next;\n            num--;\n        }\n        prev.next = null;\n        return cur;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306500593","body":"## 思路\n- 借助虚拟头节点，先反转前两个，然后循环此操作\n## 代码\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        //cur -> before -> after \n        ListNode dummyHead = new ListNode(-1);\n        dummyHead.next = head;\n        ListNode cur = dummyHead;\n        while(cur.next != null && cur.next.next != null) {\n            ListNode before = cur.next;\n            ListNode after  = cur.next.next;\n            cur.next = after;\n            before.next = after.next;\n            after.next = before;\n            cur = before;\n        }\n        return dummyHead.next;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310035558","body":"## 思路\n- 采用双指针，都走完A+B+C，相遇即是交点\n## 代码\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != b) {\n            if(a != null) {\n                a = a.next;\n            }else{\n                a= headB;\n            }\n            if(b != null) {\n                b = b.next;\n            }else {\n                b = headA;\n            }\n        }\n        return a;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311360914","body":"#### 思路\n- 快慢指针，快指针走两步，慢指针走一步\n#### 代码\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        //快慢指针，快指针走两步，慢指针走一步\n        ListNode fast = head;\n        ListNode slow = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if(fast == slow) {\n                //第一次相遇,继续判断\n                fast = head;\n                while (fast != slow) {\n                    fast = fast.next;\n                    slow = slow.next;\n                }\n                return fast;\n            }\n        }\n        return null;  \n    }\n}\n```\n#### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320036116","body":"## 代码\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        TreeMap<Integer, List<Integer>> map = new TreeMap<>();\n        List<List<Integer>> ans = new ArrayList<>();\n        Deque<Node> deque = new ArrayDeque<>();\n        deque.addLast(new Node(0, root));\n        while (!deque.isEmpty()) {\n            int size = deque.size();\n            Map<Integer, List<Integer>> m = new HashMap<>();\n            while (size-- > 0) {\n                Node cur = deque.pollFirst();\n                m.computeIfAbsent(cur.idx, k -> new ArrayList<>()).add(cur.node.val);\n                if (cur.node.left != null) deque.addLast(new Node(cur.idx - 1, cur.node.left));\n                if (cur.node.right != null) deque.addLast(new Node(cur.idx + 1, cur.node.right));\n            }\n            for (Integer key : m.keySet()) {\n                Collections.sort(m.get(key));\n                map.computeIfAbsent(key, k -> new ArrayList<>()).addAll(m.get(key));\n            }\n        }\n        for (Integer key : map.keySet()) ans.add(map.get(key));\n        return ans;\n    }\n\n    class Node {\n        int idx;\n        TreeNode node;\n        public Node() {\n        }\n        public Node(int _idx, TreeNode _root) {\n            this.node = _root;\n            this.idx = _idx;\n        }\n\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(NlogN)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298396077","body":"### 思路\n\n将整个加数 K加入数组表示的数的最低位，余数保留，高位数进位再相加\n\n### 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间：O（n）\n\n空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300627485","body":"### 思路\n\n~~~bash\n前后遍历，取距离最小的\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302133635","body":"### 思路\n\n~~~bash\n用一个数组来模拟栈，push操作的话，没满就把栈顶后移，pop操作的话，非空就迁移\n~~~\n\n### 代码\n\n~~~java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度： pop，push  O(1)   inc O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303215840","body":"### 思路\n\n~~~bash\n利用栈的思想，数字、字母和中括号分开，数字、字母和左括号直接进，遇到右括号的时候出栈，然后一直到遇到左括号停止，反转一下就是我们的字母队列，再去栈里面找数字就是重复的次数，然后根据新的字符串再进栈，如此循环往复即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304502487","body":"### 思路\n\n~~~bash\n将一个栈当作输入栈，用于压入push 传入的数据；另一个栈当作输出栈，用于pop 和 peek 操作。\n~~~\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794291","body":"### 思路\n\n~~~bash\n对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。\n有点儿没看懂，下去再看看。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305544918","body":"### 思路\n\n~~~bash\n把它想象成一个环，然后移动的次数对长度取模，为0那就是不变\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307079314","body":"### 思路\n\n~~~bash\n递归，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308440160","body":"### 思路\n\n~~~bash\n首先找到当前的根节点，构建根节点之后，对左右链表分别递归即可。用一个节点作为pre,pre在low前面，当low指向根节点之后跳出循环，这样可以把pre.next 设置为null\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return dfs(head);\n    }\n\n    public TreeNode dfs(ListNode head) {\n        if(head == null)\n            return null;\n        if(head.next == null)\n            return new TreeNode(head.val);\n        ListNode pre = new ListNode();\n        pre.next = head;\n        ListNode low = head, fast = head;\n        while(fast != null && fast.next != null) {\n            fast = fast.next.next;\n            low = low.next;\n            pre = pre.next;\n        }\n        pre.next = null;\n        TreeNode root = new TreeNode(low.val);\n        root.right = dfs(low.next);\n        root.left = dfs(head);\n        return root;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310435489","body":"### 思路\n\n~~~bash\n双指针，只需要考虑相交和不相交两种情况即可\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311763769","body":"### 思路\n\n~~~bash\n快慢指针，使用两个指针，一个移动1次，一个移动2次，如果存在环，那么终究会相遇\n~~~\n\n### 代码\n\n~~~java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while (fast != null) {\n            slow = slow.next;\n            if (fast.next != null) {\n                fast = fast.next.next;\n            } else {\n                return null;\n            }\n            if (fast == slow) {\n                ListNode ptr = head;\n                while (ptr != slow) {\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312490331","body":"### 思路\n\n~~~bash\n哈希+双向链表\nLRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\n没看太懂，后面再看看\n~~~\n\n### 代码\n\n~~~java\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\n    private int capacity;\n    \n    public LRUCache(int capacity) {\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    }\n\n    public int get(int key) {\n        return super.getOrDefault(key, -1);\n    }\n\n    public void put(int key, int value) {\n        super.put(key, value);\n    }\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\n        return size() > capacity; \n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312746878","body":"### 思路\n\n~~~bash\n每棵树的最大深度即为其左右子树的最大深度加一\n~~~\n\n### 代码\n\n~~~java\nint maxDepth(struct TreeNode* root){\n    if(root==NULL) return 0;\n    else\n    return fmax(maxDepth(root->left)+1,maxDepth(root->right)+1);\n}\n~~~\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313262502","body":"### 思路\n\n~~~bash\n递归，拆分\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315263476","body":"### 思路\n\n~~~bash\n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316964613","body":"### 思路\n\n~~~bash\n使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int ret = 0;\n        Queue<TreeNode> queue = new ArrayDeque<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            TreeNode p = queue.poll();\n            if (p.right != null) {\n                queue.offer(p.right);\n            }\n            if (p.left != null) {\n                queue.offer(p.left);\n            }\n            ret = p.val;\n        }\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318598675","body":"### 思路\n\n~~~bash\n没看太懂，先提交了，后面再看看。\n二叉树的序列化本质上是对其值进行编码，更重要的是对其结构进行编码。可以遍历树来完成上述任务。众所周知，我们一般有两个策略：广度优先搜索和深度优先搜索。\n~~~\n\n### 代码\n\n~~~java\npublic class Codec {\n    public String serialize(TreeNode root) {\n        return rserialize(root, \"\");\n    }\n  \n    public TreeNode deserialize(String data) {\n        String[] dataArray = data.split(\",\");\n        List<String> dataList = new LinkedList<String>(Arrays.asList(dataArray));\n        return rdeserialize(dataList);\n    }\n\n    public String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320865636","body":"### 思路\r\n\r\n~~~bash\r\n我们可以从根节点开始，对整棵树进行一次遍历，然后再根据（列，行，值）进行排序。\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~java\r\nclass Solution {\r\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\r\n        List<int[]> nodes = new ArrayList<int[]>();\r\n        dfs(root, 0, 0, nodes);\r\n        Collections.sort(nodes, new Comparator<int[]>() {\r\n            public int compare(int[] tuple1, int[] tuple2) {\r\n                if (tuple1[0] != tuple2[0]) {\r\n                    return tuple1[0] - tuple2[0];\r\n                } else if (tuple1[1] != tuple2[1]) {\r\n                    return tuple1[1] - tuple2[1];\r\n                } else {\r\n                    return tuple1[2] - tuple2[2];\r\n                }\r\n            }\r\n        });\r\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\r\n        int size = 0;\r\n        int lastcol = Integer.MIN_VALUE;\r\n        for (int[] tuple : nodes) {\r\n            int col = tuple[0], row = tuple[1], value = tuple[2];\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.add(new ArrayList<Integer>());\r\n                size++;\r\n            }\r\n            ans.get(size - 1).add(value);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        nodes.add(new int[]{col, row, node.val});\r\n        dfs(node.left, row + 1, col - 1, nodes);\r\n        dfs(node.right, row + 1, col + 1, nodes);\r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320865976","body":"### 思路\n\n~~~bash\n哈希\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321143980","body":"### 思路\n\n~~~bash\n首先遍历整个数组，并使用哈希表记录每个数字出现的次数，并形成一个「出现次数数组」。找出原数组的前 k 个高频元素，就相当于找出「出现次数数组」的前 k 大的值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> occurrences = new HashMap<Integer, Integer>();\n        for (int num : nums) {\n            occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);\n        }\n\n        // int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        PriorityQueue<int[]> queue = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] m, int[] n) {\n                return m[1] - n[1];\n            }\n        });\n        for (Map.Entry<Integer, Integer> entry : occurrences.entrySet()) {\n            int num = entry.getKey(), count = entry.getValue();\n            if (queue.size() == k) {\n                if (queue.peek()[1] < count) {\n                    queue.poll();\n                    queue.offer(new int[]{num, count});\n                }\n            } else {\n                queue.offer(new int[]{num, count});\n            }\n        }\n        int[] ret = new int[k];\n        for (int i = 0; i < k; ++i) {\n            ret[i] = queue.poll()[0];\n        }\n        return ret;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321580075","body":"### 思路\n\n~~~bash\n枚举 + 哈希表，暴力解法\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int ans = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n            for (int[] q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                cnt.put(dis, cnt.getOrDefault(dis, 0) + 1);\n            }\n            for (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\n                int m = entry.getValue();\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1324980123","body":"### 思路\r\n\r\n~~~bash\r\n滑动窗口\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~bash\r\nclass Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        if (s.length()==0) return 0;\r\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n        int max = 0;\r\n        int left = 0;\r\n        for(int i = 0; i < s.length(); i ++){\r\n            if(map.containsKey(s.charAt(i))){\r\n                left = Math.max(left,map.get(s.charAt(i)) + 1);\r\n            }\r\n            map.put(s.charAt(i),i);\r\n            max = Math.max(max,i-left+1);\r\n        }\r\n        return max;\r\n        \r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324988310","body":"### 思路\n\n~~~bash \n滑动窗口，没看太懂，先提交了\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n\n    public List<Integer> findSubstring(String s, String[] words) {\n\n        List<Integer> res = new ArrayList<>();\n\n        Map<String, Integer> map = new HashMap<>();\n\n        if (words == null || words.length == 0)\n            return res;\n\n        for (String word : words)\n            map.put(word, map.getOrDefault(word, 0) + 1);\n\n        int sLen = s.length(), wordLen = words[0].length(), count = words.length;\n\n        int match = 0;\n\n        for (int i = 0; i < sLen - wordLen * count + 1; i++) {\n\n            //得到当前窗口字符串\n            String cur = s.substring(i, i + wordLen * count);\n            Map<String, Integer> temp = new HashMap<>();\n            int j = 0;\n\n            for (; j < cur.length(); j += wordLen) {\n\n                String word = cur.substring(j, j + wordLen);\n                // 剪枝\n                if (!map.containsKey(word))\n                    break;\n\n                temp.put(word, temp.getOrDefault(word, 0) + 1);\n                // 剪枝\n                if (temp.get(word) > map.get(word))\n                    break;\n            }\n\n            if (j == cur.length())\n                res.add(i);\n        }\n\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\n\n时间复杂度: 本质上我们的算法是将 s 划分为若干了段，这些段的长度为 m * km∗k，对于每一段我们最多需要检查 n - m * kn−m∗k 次，因此时间复杂度为 O(n * m * k)O(n∗m∗k)。\n\n空间复杂度: temp 在下一次循环会覆盖上一次的 temp，因此 temp 的空间在任意时刻都不大于 O(m)O(m), 因此空间复杂度为 O(m)O(m)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326555419","body":"### 思路\n\n~~~bash\n同余定理+前缀和的巧妙结合\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327629139","body":"### 思路\n\n~~~bash\n双指针\n~~~\n\n### 代码\n\n~~~java\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode(int x) {\n        val = x;\n    }\n\n    public ListNode(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            throw new IllegalArgumentException(\"arr can not be empty\");\n        }\n        this.val = nums[0];\n        ListNode curr = this;\n        for (int i = 1; i < nums.length; i++) {\n            curr.next = new ListNode(nums[i]);\n            curr = curr.next;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder s = new StringBuilder();\n        ListNode cur = this;\n        while (cur != null) {\n            s.append(cur.val);\n            s.append(\" -> \");\n            cur = cur.next;\n        }\n        s.append(\"NULL\");\n        return s.toString();\n    }\n}\n\npublic class Solution {\n\n    public ListNode middleNode(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public static void main(String[] args) {\n        int[] arr = new int[]{1, 2, 3, 4, 5, 6};\n        // int[] arr = new int[]{1, 2, 3, 4, 5};\n        ListNode head = new ListNode(arr);\n        Solution solution = new Solution();\n        ListNode res = solution.middleNode(head);\n        System.out.println(res);\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328054596","body":"### 思路\n\n~~~bash\n双指针，数组有序，那么相同的一定相邻，要求删除重复元素，实际上就是将不重复的元素移到数组的左侧。\n~~~\n\n### 代码\n\n~~~java\n public int removeDuplicates(int[] nums) {\n    if(nums == null || nums.length == 0) return 0;\n    int p = 0;\n    int q = 1;\n    while(q < nums.length){\n        if(nums[p] != nums[q]){\n            nums[p + 1] = nums[q];\n            p++;\n        }\n        q++;\n    }\n    return p + 1;\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328249704","body":"### 思路\n\n~~~bash\n二分法\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        int n = nums.length;\n        int left = 0, right = n - 1, ans = n;\n        while (left <= right) {\n            int mid = ((right - left) >> 1) + left;\n            if (target <= nums[mid]) {\n                ans = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(logn)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328992145","body":"### 思路\n\n~~~bash\n遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums == null || nums.length < 2) return nums;\n        // 双向队列 保存当前窗口最大值的数组位置 保证队列中数组位置的数值按从大到小排序\n        LinkedList<Integer> queue = new LinkedList();\n        // 结果数组\n        int[] result = new int[nums.length-k+1];\n        // 遍历nums数组\n        for(int i = 0;i < nums.length;i++){\n            // 保证从大到小 如果前面数小则需要依次弹出，直至满足要求\n            while(!queue.isEmpty() && nums[queue.peekLast()] <= nums[i]){\n                queue.pollLast();\n            }\n            // 添加当前值对应的数组下标\n            queue.addLast(i);\n            // 判断当前队列中队首的值是否有效\n            if(queue.peek() <= i-k){\n                queue.poll();   \n            } \n            // 当窗口长度为k时 保存当前窗口中最大值\n            if(i+1 >= k){\n                result[i+1-k] = nums[queue.peek()];\n            }\n        }\n        return result;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330642336","body":"### 思路\n\n~~~bash\n图，计算各节点的入度和出度\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] inDegrees = new int[n + 1];\n        int[] outDegrees = new int[n + 1];\n        for (int[] edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332059962","body":"### 思路\n\n~~~bash\n没看太懂，先补上，回去再看下\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1335157047","body":"### 思路\r\n\r\n~~~bash\r\n没看太懂，先补卡了\r\n~~~\r\n\r\n### 代码\r\n\r\n~~~java\r\nclass Solution {\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            groupItem.add(new ArrayList<Integer>());\r\n        }\r\n\r\n        // 组间和组内依赖图\r\n        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            groupGraph.add(new ArrayList<Integer>());\r\n        }\r\n        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();\r\n        for (int i = 0; i < n; ++i) {\r\n            itemGraph.add(new ArrayList<Integer>());\r\n        }\r\n\r\n        // 组间和组内入度数组\r\n        int[] groupDegree = new int[n + m];\r\n        int[] itemDegree = new int[n];\r\n        \r\n        List<Integer> id = new ArrayList<Integer>();\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.add(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        // 给未分配的 item 分配一个 groupId\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem.get(group[i]).add(i);\r\n        }\r\n        // 依赖关系建图\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (int item : beforeItems.get(i)) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph.get(item).add(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph.get(beforeGroupId).add(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 组间拓扑关系排序\r\n        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        int[] ans = new int[n];\r\n        int index = 0;\r\n        // 组内拓扑关系排序\r\n        for (int curGroupId : groupTopSort) {\r\n            int size = groupItem.get(curGroupId).size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));\r\n            if (res.size() == 0) {\r\n                return new int[0];\r\n            }\r\n            for (int item : res) {\r\n                ans[index++] = item;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {\r\n        Queue<Integer> queue = new LinkedList<Integer>();\r\n        for (int item : items) {\r\n            if (deg[item] == 0) {\r\n                queue.offer(item);\r\n            }\r\n        }\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        while (!queue.isEmpty()) {\r\n            int u = queue.poll(); \r\n            res.add(u);\r\n            for (int v : graph.get(u)) {\r\n                if (--deg[v] == 0) {\r\n                    queue.offer(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : new ArrayList<Integer>();\r\n    }\r\n}\r\n~~~\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335153489","body":"### 思路\n\n~~~bash\n我们只需按指令模拟机器人移动的坐标即可。起始时机器人的坐标为 (0,0)(0,0)，在遍历完所有指令并对机器人进行移动之后，判断机器人的坐标是否为 (0,0)(0,0) \n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361375834","body":"### 思路\n\n~~~bash\n广度优先算法，算出每一个海洋区域的最近陆地区域，然后记录下它们的距离，然后在这些距离里面取一个最大值。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    int n;\n    int[][] grid;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int findNearestLand(int x, int y) {\n        boolean[][] vis = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{x, y, 0});\n        vis[x][y] = true;\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\n                    vis[nx][ny] = true;\n                    if (grid[nx][ny] == 1) {\n                        return f[2] + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n4)\n\n空间复杂度：O(n2)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366607214","body":"### 思路\n\n~~~bash\ndp[i][j]表示在m,n的网格中，走到i，j的位置上时有dp[i][j]条不同的路径，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[] cur = new int[n];\n        Arrays.fill(cur,1);\n        for (int i = 1; i < m;i++){\n            for (int j = 1; j < n; j++){\n                cur[j] += cur[j-1] ;\n            }\n        }\n        return cur[n-1];\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n2)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370569329","body":"### 思路\n\n~~~bash\n先对两个数组进行排序，定义初始值0，然后遍历进行比较，如果说能满足小孩，那么初始值+1，一直这么遍历到尾部即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        int res = 0;\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int i = 0, j = 0;\n        while (i < g.length && j < s.length) {\n            if (g[i] <= s[j]) {\n                res++;\n                i++;\n                j++;\n            } else if (g[i] > s[j]) {\n                j++;\n            }\n        }\n        return res;\n\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378707883","body":"### 代码\n\n~~~java\nclass Solution {\n    List<Integer> t = new ArrayList<Integer>();\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> subsets(int[] nums) {\n        int n = nums.length;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            t.clear();\n            for (int i = 0; i < n; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    t.add(nums[i]);\n                }\n            }\n            ans.add(new ArrayList<Integer>(t));\n        }\n        return ans;\n    }\n}\n~~~\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406485","body":"### 思路\r\n\r\nk和x不知道哪个位数多，先用map把两个数组存起来，然后对应位置相加，>=10就进位\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        map<int,int> nummap;\r\n        vector<int> revec;\r\n        int n=num.size(),flag=0;\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++){\r\n            nummap[i]=num[i];\r\n        }\r\n        int i=0;\r\n        while(k!=0){\r\n            nummap[i]+=k%10;\r\n            k=k/10;\r\n            i++;\r\n        }\r\n        for(auto it=nummap.begin();it!=nummap.end();it++){\r\n            if(it->second>=10&&it->first<nummap.size()-1){\r\n                it->second-=10;\r\n                it++;\r\n                it->second+=1;\r\n                it--;\r\n            }\r\n            if(it->second>=10&&it->first==nummap.size()-1){\r\n                it->second-=10;\r\n                flag++;\r\n            }\r\n            revec.push_back(it->second);\r\n        }\r\n        if(flag) revec.push_back(1);\r\n        reverse(revec.begin(),revec.end());\r\n        return revec;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299622674","body":"### 思路\r\n\r\n每个位置的字符，向前向后找离它最近的给定字符，一找到就跳出循环\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        vector<int> re;\r\n        for(int i=0;i<n;i++){\r\n            int left=i,right=i;\r\n            if(s[i]==c){\r\n                re.push_back(0);\r\n                continue;\r\n            }\r\n            left--;\r\n            right++;\r\n            while(true){\r\n                if(left<0&&right>n-1) break;\r\n                if(left>=0){\r\n                    if(s[left]==c){\r\n                        re.push_back(i-left);\r\n                        break;\r\n                    }\r\n                    left--;\r\n                } \r\n                if(right<=n-1){\r\n                    if(s[right]==c){\r\n                        re.push_back(right-i);\r\n                        break;\r\n                    }\r\n                    right++;\r\n                }\r\n            }\r\n        }\r\n        return re;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O($N^2$)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301961812","body":"### 思路\n\n用数组作为增量栈的数据结构，加一个cnt的变量，记录栈内当前的大小\n\n### 代码\n\n```C++\nclass CustomStack {\npublic:\n    vector<int> myvec;\n    int cnt=0;\n    CustomStack(int maxSize) {\n        for(int i=0;i<maxSize;i++) myvec.push_back(0);\n    }\n    \n    void push(int x) {\n        if(cnt<myvec.size()){\n            cnt++;\n            myvec[cnt-1]=x;\n        }\n    }\n    \n    int pop() {\n        if(cnt==0) return -1;\n        else{\n            int temp=myvec[cnt-1];\n            cnt--;\n            return temp;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(cnt<k) for(int i=0;i<cnt;i++) myvec[i]+=val;\n        else for(int i=0;i<k;i++) myvec[i]+=val;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：增量操作O(N)，push，pop操作O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303651417","body":"### 思路\n\n利用两个栈，一个存当前字符，一个存当前数量，遍历字符串，遇到字母，加入当前字符，遇到数字字符，当前数字*10加上当前数字字符，遇到‘[’，将当前字母和数字入栈，归0，遇到’]‘，将栈顶字母弹出，栈顶字母+栈顶数量*当前字符串=累计字符串；然后继续。\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n=s.size();\n        stack<string> stackstr;\n        stack<int> stacknum;\n        string curstr=\"\";\n        int curnum=0;\n        for(int i=0;i<n;i++){\n            if(s[i]>='0'&&s[i]<='9') curnum=curnum*10+(s[i]-'0');\n            if(s[i]>='a'&&s[i]<='z') curstr+=s[i];\n            if(s[i]=='['){\n                stackstr.push(curstr);\n                stacknum.push(curnum);\n                curstr=\"\";\n                curnum=0;\n            }\n            if(s[i]==']'){\n                string temp=curstr;\n                for(int i=0;i<stacknum.top()-1;i++) curstr+=temp;\n                curstr=stackstr.top()+curstr;\n                stackstr.pop();\n                stacknum.pop();\n            }\n        }\n        return curstr;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427396","body":"### 思路\r\n\r\n队列：先进先出，栈：先进后出；两个栈模拟队列，要弹出队头的时候把一个栈里的腾空挪到另一栈，然后几句push的时候向第一个栈push；取队列头的时候检查第二个栈是否为空。\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> mainstack,tempstack;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        mainstack.push(x);\r\n    }\r\n    \r\n    int pop(){\r\n        int temp;\r\n        if(!tempstack.empty()){\r\n            temp=tempstack.top();\r\n            tempstack.pop();\r\n        }\r\n        else{\r\n            while(!mainstack.empty()){\r\n                temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }\r\n            temp=tempstack.top();\r\n            tempstack.pop(); \r\n        }  \r\n        return temp;\r\n    }\r\n    \r\n    int peek() {\r\n        if(!tempstack.empty()) return tempstack.top();\r\n        else{\r\n            while(!mainstack.empty()){\r\n                int temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }   \r\n            return tempstack.top();\r\n        }\r\n    }\r\n    \r\n    bool empty() {\r\n        if(mainstack.empty()&&tempstack.empty()) return true;\r\n        return false;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push O(1)，pop O(N) 其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305798715","body":"### 思路\r\n\r\n两个指针，一个比另一个快k，然后一起移动两个指针，快的指针移到末尾，慢的指针的next就是新链表的头节点，然后把慢指针的next设成原来的头节点，再把慢指针的新next设为nullptr\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* newhead=head,*forward=head,*temp=head;\r\n        int count=1;\r\n        if(!head) return nullptr;\r\n        while(temp->next){\r\n            temp=temp->next;\r\n            count++;\r\n        }\r\n        k=k%count;\r\n        for(int i=0;i<k;i++){\r\n            forward=forward->next;\r\n        }\r\n        while(forward->next){\r\n            newhead=newhead->next;\r\n            forward=forward->next;\r\n        }\r\n        forward->next=head;\r\n        head=newhead->next;\r\n        newhead->next=nullptr;\r\n        \r\n        return head;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311916009","body":"### 思路\r\n\r\n环形链表，快慢指针，一定会套圈，相遇点和环入口的距离与头节点和环入口的距离相等\r\n\r\n### 代码\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* slow=head,*fast=head;\r\n        while(fast&&fast->next){\r\n            slow=slow->next;\r\n            fast=fast->next->next;\r\n            if(fast==slow){\r\n                break;\r\n            }\r\n        }\r\n        if(fast&&fast->next){\r\n            slow=head;\r\n            while(fast!=slow){\r\n                slow=slow->next;\r\n                fast=fast->next;\r\n            }\r\n            return slow;\r\n        }\r\n        \r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312502531","body":"### 思路\r\n双向链表+map 调用函数则会使用过，放表头，修改，修改key在链表中的指向\r\n### 代码\r\n```C++\r\nclass LRUCache {\r\npublic:\r\n    unordered_map<int, list<pair<int, int>>::iterator> refMap; \r\n    list<pair<int, int>> cache;\r\n    int capacity;\r\n    LRUCache(int capacity) {\r\n        this->capacity = capacity;\r\n        cache.clear();\r\n    }\r\n    \r\n    bool doesKeyExist(int key) {\r\n        return refMap.count(key) > 0;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!doesKeyExist(key)) return -1;\r\n        int oldValue = (*refMap[key]).second;\r\n        //remove the current key reference from the map\r\n        put(key, oldValue);\r\n        return oldValue;\r\n    }\r\n    \r\n    void removeExistingKeyFromCache(int key) {\r\n        cache.erase(refMap[key]);\r\n        refMap.erase(key);\r\n    }\r\n        \r\n    \r\n    void put(int key, int value) {\r\n        //check if this key exists\r\n        if (doesKeyExist(key)) {\r\n            removeExistingKeyFromCache(key);\r\n        }\r\n        cache.push_front({key, value});\r\n        refMap[key] = cache.begin();\r\n        //if capacity is full, then remove the key from back\r\n        if (capacity < (int)cache.size()) {\r\n            int lruKey = cache.back().first;\r\n            refMap.erase(lruKey);\r\n            cache.pop_back();\r\n        }\r\n        return ;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312750167","body":"### 思路\n\n递归+回溯+前序遍历\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int mymax=INT_MIN,cnt=0;\n    int maxDepth(TreeNode* root) {\n        traversal(root);\n        \n        return mymax;\n    }\n    void traversal(TreeNode* cur){\n        if(!cur){\n            if(cnt>mymax) mymax=cnt;\n            return;\n        };\n        cnt++;\n        traversal(cur->left);\n        traversal(cur->right);\n        cnt--;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313600163","body":"### 思路\n\n递归，判断左右子树是否都相同。相同：分类讨论\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p&&!q) return true;\n        if(!p&&q||!q&&p) return false;\n        if(p->val!=q->val) return false;\n        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315245707","body":"### 思路\n\n前序遍历，回溯，遇到节点，原值*10+节点值\n\n### 代码\n\n\n```C++\n\nclass Solution {\npublic:\n    int curnum=0,sum=0;\n    int sumNumbers(TreeNode* root) {\n        traversal(root);\n        \n        return sum;\n    }\n    void traversal(TreeNode* cur){\n        curnum=curnum*10+cur->val;\n        if(cur->left) traversal(cur->left);\n        if(cur->right) traversal(cur->right);\n        if(!cur->left&&!cur->right){\n            sum+=curnum;\n        }\n        curnum=(curnum-cur->val)/10;\n        return;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317141012","body":"### 思路\n\n最左叶子节点，层序遍历，用循环，用两个队列倒来倒去\n\n### 代码\n\n```C++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> curq,lastq;\n        if(!root) return 0;\n        curq.push(root);\n        while(!curq.empty()){\n            TreeNode* left=curq.front();\n            while(!curq.empty()){\n                TreeNode* temp=curq.front();\n                if(temp->left) lastq.push(temp->left);\n                if(temp->right) lastq.push(temp->right);\n                curq.pop();\n            }\n            if(lastq.empty()) return left->val;\n            while(!lastq.empty()){\n                TreeNode* temp2=lastq.front();\n                curq.push(temp2);\n                lastq.pop();\n            }\n        }\n        return 0;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320158040","body":"### 思路\n\n前序遍历，记录坐标\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    map<vector<int>,vector<int>> mymap;\n    map<int,vector<int>> newmap;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> re;\n        if(root) mymap[{0,0}].push_back(root->val);\n        traversal(root,0,0);\n    \n        for(auto it=mymap.begin();it!=mymap.end();it++){\n            vector<int> temp=it->second;\n            sort(temp.begin(),temp.end());\n            for(int i=0;i<temp.size();i++){\n                newmap[it->first[1]].push_back(temp[i]);\n            }\n        }\n        for(auto it=newmap.begin();it!=newmap.end();it++){\n            vector<int> newtemp;\n            for(int i=0;i<it->second.size();i++){\n                newtemp.push_back(it->second[i]);\n            }\n            re.push_back(newtemp);\n        }\n        return re;\n    }\n    void traversal(TreeNode* curnode,int currow,int curcol){\n        if(curnode->left){\n            mymap[{currow+1,curcol-1}].push_back(curnode->left->val);\n            traversal(curnode->left,currow+1,curcol-1);\n        }\n        if(curnode->right){\n            mymap[{currow+1,curcol+1}].push_back(curnode->right->val);\n            traversal(curnode->right,currow+1,curcol+1);\n        }\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：ON)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321162624","body":"### 思路\n\n用map\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        map<int,int> mymap;\n        int n=nums.size(),maxtemp=0,maxnum;\n        vector<int> results;\n        for(int i=0;i<n;i++){\n            if(mymap.find(nums[i])!=mymap.end()) mymap[nums[i]]++;\n            else mymap[nums[i]]=1;\n        }\n        while(k){\n            maxtemp=0;\n            for(auto it=mymap.begin();it!=mymap.end();it++){\n                if(it->second>maxtemp){\n                    maxtemp=it->second;\n                    maxnum=it->first;\n                }\n            }\n            results.push_back(maxnum);\n            mymap[maxnum]=0;\n            k--;\n        }\n        return results;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322237192","body":"### 思路\n\n三个点，循环两次，遍历每个点，再在循环内遍历和它不同的点，用map记录所有和它距离相同的点，然后用排列数求配对数\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int n=points.size();\n        int d,cnt=0;\n        for(int i=0;i<n;i++){\n            map<int,int> mymap;\n            for(int j=0;j<n;j++){\n                if(i!=j){\n                    d=pow(points[i][0]-points[j][0],2)+pow(points[i][1]-points[j][1],2);\n                    mymap[d]++;\n                }\n            }\n            for(auto &p:mymap){\n                int temp=p.second;\n                if(temp) cnt+=temp*(temp-1);\n            }\n        }\n        return cnt;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323867612","body":"### 思路\n\n滑动窗口\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        map<int,int> mymap;\n        int n=s.size(),left=0,right=0,mymax=INT_MIN;\n        while(right<n){\n            auto it=mymap.find(s[right]);\n            if(it==mymap.end()){\n                mymap[s[right]]=right;\n                right++;\n            }\n            else{\n                mymap[s[right]]=right;\n                if(mymax<right-left) mymax=right-left;\n                left=it->second+1;\n                right++;\n            }\n        }\n        return mymax;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326555643","body":"### 思路\n\n同余 前缀和\n\n### 代码\n\n\n```py\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329305839","body":"### 思路\n滑动窗口，双指针\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> maxqueue;\n        int n=nums.size();\n        vector<int> results;\n        for(int i=0;i<k;i++){\n            if(maxqueue.empty()) maxqueue.push_back(nums[i]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i]);\n            }\n        }\n        \n        for(int i=0;i<n-k;i++){\n            results.push_back(maxqueue.front());\n            //cout<<\"i=\"<<i<<\" \"<<maxqueue.front()<<\" \";\n            if(nums[i]==maxqueue.front()){\n                maxqueue.pop_front();\n            }\n            if(maxqueue.empty()) maxqueue.push_back(nums[i+k]);\n            else{\n                while(!maxqueue.empty()&&maxqueue.back()<nums[i+k]) maxqueue.pop_back();\n                maxqueue.push_back(nums[i+k]);\n                //cout<<\"i=\"<<i<<\" \"<<nums[i+k]<<\" \"<<endl;\n            }\n            //results.push_back(maxqueue.front());\n        }\n        results.push_back(maxqueue.front());\n        return results;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(k)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336390126","body":"### 思路\n\n先把时间格式转换成分钟，然后计算在多少个15分钟段里；分类讨论。\n\n### 代码\n```C++\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int starttime,endtime,re;\n        starttime=time2min(loginTime);\n        endtime=time2min(logoutTime);\n        if(starttime<endtime){\n            re=floor(endtime/15.0)-ceil(starttime/15.0);\n        }\n        else{\n            re=24*60/15-ceil(starttime/15.0)+floor(endtime/15.0);\n        }\n        \n        return max(re,0);\n    }\n    int time2min(string time){\n        int n=5,hour,min,totalmin;\n        hour=(time[0]-'0')*10+(time[1]-'0');\n        min=(time[3]-'0')*10+(time[4]-'0');\n        totalmin=hour*60+min;\n        \n        return totalmin;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342923470","body":"### 思路\n\n二分法\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int left=1,right=n,c;\n        while(left<right){\n            c=left+(right-left)/2;\n            if(isBadVersion(c)){\n                right=c;\n            }\n            else{\n                left=c+1;\n            }\n        }\n        return left;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(log_2(N))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406546","body":"### 代码(java)\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300208592","body":"### 代码\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Description: 821. 字符的最短距离\n * 两次遍历\n * @author: scott\n * @date: 2022年11月02日 19:45\n */\npublic class DayTwo821 {\n\n    public static void main(String[] args) {\n        String s = \"loveleetcode\";\n        //  测试结果\n        int[] es = shortestToChar(s, 'e');\n        System.out.println(Arrays.toString(es));\n    }\n\n\n    public static int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301722550","body":"### 代码\n\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\n/**\n * @Description: 数组模拟栈1381\n * @author: scott\n * @date: 2022年11月03日 13:46\n */\npublic class DayTHREETest1381 {\n\n    int [] stack;\n    int top;\n\n    public DayTHREETest1381(int maxSize){\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x){\n        if(top != stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    public int pop(){\n        if(top == -1){\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n\n    public void increment(int k, int val){\n        int limit = Math.min(k, top + 1);\n        for(int i  = 0; i < limit; ++i){\n            stack[i] += val;\n        }\n    }\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305493272","body":"### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306521515","body":"#### 代码一\n\n```java\n//递归思想\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        ListNode newHead = head.next;\n        head.next = swapPairs(newHead.next);\n        newHead.next = head;\n        return newHead;\n    }\n}\n```\n\n#### 代码二\n\n```java\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if(head == null || head.next == null){\n            return head;\n        }\n\n        //虚拟头节点\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n\n        //两两相邻的节点中第一个节点的前驱节点\n        ListNode cur = dummy;\n        while (cur != null && cur.next != null && cur.next.next != null){\n\n            //第一个节点\n            ListNode first = cur.next;\n            //第二个节点\n            ListNode second = cur.next.next;\n            //第三个节点 \n            ListNode third = second.next;\n            \n            cur.next = second;\n            second.next = first;\n            first.next = third;\n            \n            //将cur向后移动两位\n            cur = cur.next.next;\n        }\n        \n        return dummy.next;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308192139","body":"#### 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        return buildTree(head, null);\n    }\n\n    public TreeNode buildTree(ListNode left, ListNode right) {\n        if (left == right) {\n            return null;\n        }\n        ListNode mid = getMedian(left, right);\n        TreeNode root = new TreeNode(mid.val);\n        root.left = buildTree(left, mid);\n        root.right = buildTree(mid.next, right);\n        return root;\n    }\n\n    public ListNode getMedian(ListNode left, ListNode right) {\n        ListNode fast = left;\n        ListNode slow = left;\n        while (fast != right && fast.next != right) {\n            fast = fast.next;\n            fast = fast.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309693832","body":"#### 思路\n1、先计算两个链表的长度。2、判断两个链表最后一位是否相同不相同就返回null。3、找到两个链表长的呢一个链表。4、让长的链表先往后next，直到两个链表的长度相同为止5、这时候同时遍历两个链表，进行链表节点一对一的比较，如果相同就返回，否则继续遍历6、如果上述没有找到相交节点就返回null\n\n#### 代码\n```\n**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if(headA == null || headB == null){\n            return null;\n        }\n\n        //计算长度\n        int lenA = 0;\n        int lenB = 0;\n        ListNode curA = headA;\n        ListNode curB = headB;\n        while (curA != null){\n            lenA++;\n            curA = curA.next;\n        }\n        while (curB != null){\n            lenB++;\n            curB = curB.next;\n        }\n\n        //如果这会curA和curB不相同就证明没有相交\n        if(curA != curB){\n            return null;\n        }\n\n        //找到long的链表\n        ListNode longer = headA;\n        ListNode shorter = headB;\n        if(lenA < lenB){\n            longer = headB;\n            shorter = headA;\n        }\n\n        //让长的先将长出来的自己走完\n        for(int i = 0; i < Math.abs(lenA - lenB); i++){\n            longer = longer.next;\n        }\n\n        //这时候在进行节点的比较\n        while (longer != null && shorter != null){\n            //判断两个链表的节点是否相同\n            if(longer == shorter){\n                return longer;\n            }\n            longer = longer.next;\n            shorter = shorter.next;\n        }\n        \n        //如果上面判断完没有相同的节点，证明没有相交，返回null\n        return null;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312905699","body":"#### 思路\n方法：深度优先搜索\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\n如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。\n\n#### 代码\n```\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        } else if (p == null || q == null) {\n            return false;\n        } else if (p.val != q.val) {\n            return false;\n        } else {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        }\n    }\n}\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314730790","body":"#### 深度优先搜索的思路\n```\n深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历。\n```\n\n#### 代码\n```java\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316298302","body":"#### 代码\n```java\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318191594","body":"#### 思路：深度优先搜索\n\n#### 代码：\n```java\npublic String rserialize(TreeNode root, String str) {\n        if (root == null) {\n            str += \"None,\";\n        } else {\n            str += str.valueOf(root.val) + \",\";\n            str = rserialize(root.left, str);\n            str = rserialize(root.right, str);\n        }\n        return str;\n    }\n  \n    public TreeNode rdeserialize(List<String> dataList) {\n        if (dataList.get(0).equals(\"None\")) {\n            dataList.remove(0);\n            return null;\n        }\n  \n        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n        dataList.remove(0);\n        root.left = rdeserialize(dataList);\n        root.right = rdeserialize(dataList);\n    \n        return root;\n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319473680","body":"#### 代码\n```java\nclass Solution {\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        dfs(root, 0, 0, nodes);\n        Collections.sort(nodes, new Comparator<int[]>() {\n            public int compare(int[] tuple1, int[] tuple2) {\n                if (tuple1[0] != tuple2[0]) {\n                    return tuple1[0] - tuple2[0];\n                } else if (tuple1[1] != tuple2[1]) {\n                    return tuple1[1] - tuple2[1];\n                } else {\n                    return tuple1[2] - tuple2[2];\n                }\n            }\n        });\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        int size = 0;\n        int lastcol = Integer.MIN_VALUE;\n        for (int[] tuple : nodes) {\n            int col = tuple[0], row = tuple[1], value = tuple[2];\n            if (col != lastcol) {\n                lastcol = col;\n                ans.add(new ArrayList<Integer>());\n                size++;\n            }\n            ans.get(size - 1).add(value);\n        }\n        return ans;\n    }\n\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null) {\n            return;\n        }\n        nodes.add(new int[]{col, row, node.val});\n        dfs(node.left, row + 1, col - 1, nodes);\n        dfs(node.right, row + 1, col + 1, nodes);\n    }\n}\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325923940","body":"#### 代码\n\n```java\nimport java.util.*;\n\nclass Solution {\n\n    public int solve(int[] nums, int k) {\n\n        int tar = 0;\n\n        for (int n : nums)\n            tar += n;\n\n        tar = Math.floorMod(tar, k);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n\n        int prefix = 0, res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n\n            prefix += nums[i];\n            int mod = Math.floorMod(prefix, k);\n            map.put(mod, i);\n\n            if (map.containsKey(Math.floorMod(prefix - tar, k)))\n                res = Math.min(res, i - map.get(Math.floorMod(prefix - tar, k)));\n        }\n\n        return res == nums.length ? -1 : res;\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328438333","body":"#### 代码\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\n            public int compare(int[] pair1, int[] pair2) {\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\n            }\n        });\n        for (int i = 0; i < k; ++i) {\n            pq.offer(new int[]{nums[i], i});\n        }\n        int[] ans = new int[n - k + 1];\n        ans[0] = pq.peek()[0];\n        for (int i = k; i < n; ++i) {\n            pq.offer(new int[]{nums[i], i});\n            while (pq.peek()[1] <= i - k) {\n                pq.poll();\n            }\n            ans[i - k + 1] = pq.peek()[0];\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331786293","body":"#### 代码\n\n```java\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color = new int[n + 1];\n        List<Integer>[] g = new List[n + 1];\n        for (int i = 0; i <= n; ++i) {\n            g[i] = new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\n        color[curnode] = nowcolor;\n        for (int nextnode : g[curnode]) {\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333398711","body":"#### 代码\n\n```java\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        List<List<Integer>> groupItem = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupItem.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内依赖图\n        List<List<Integer>> groupGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n + m; ++i) {\n            groupGraph.add(new ArrayList<Integer>());\n        }\n        List<List<Integer>> itemGraph = new ArrayList<List<Integer>>();\n        for (int i = 0; i < n; ++i) {\n            itemGraph.add(new ArrayList<Integer>());\n        }\n\n        // 组间和组内入度数组\n        int[] groupDegree = new int[n + m];\n        int[] itemDegree = new int[n];\n        \n        List<Integer> id = new ArrayList<Integer>();\n        for (int i = 0; i < n + m; ++i) {\n            id.add(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem.get(group[i]).add(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (int item : beforeItems.get(i)) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph.get(item).add(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph.get(beforeGroupId).add(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        List<Integer> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return new int[0];\n        }\n        int[] ans = new int[n];\n        int index = 0;\n        // 组内拓扑关系排序\n        for (int curGroupId : groupTopSort) {\n            int size = groupItem.get(curGroupId).size();\n            if (size == 0) {\n                continue;\n            }\n            List<Integer> res = topSort(itemDegree, itemGraph, groupItem.get(curGroupId));\n            if (res.size() == 0) {\n                return new int[0];\n            }\n            for (int item : res) {\n                ans[index++] = item;\n            }\n        }\n        return ans;\n    }\n\n    public List<Integer> topSort(int[] deg, List<List<Integer>> graph, List<Integer> items) {\n        Queue<Integer> queue = new LinkedList<Integer>();\n        for (int item : items) {\n            if (deg[item] == 0) {\n                queue.offer(item);\n            }\n        }\n        List<Integer> res = new ArrayList<Integer>();\n        while (!queue.isEmpty()) {\n            int u = queue.poll(); \n            res.add(u);\n            for (int v : graph.get(u)) {\n                if (--deg[v] == 0) {\n                    queue.offer(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : new ArrayList<Integer>();\n    }\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337011475","body":"#### 代码\n\n```java\nclass Solution {\n    public int minCharacters(String a, String b) {\n        int n = a.length(), m = b.length(), ans = 0x3f3f3f3f;\n        int[] c1 = new int[26], c2 = new int[26];\n        for (char c : a.toCharArray()) c1[c - 'a']++;\n        for (char c : b.toCharArray()) c2[c - 'a']++;\n        for (int i = 0; i < 26 && ans != 0; i++) {\n            // 3\n            int ca = n - c1[i], cb = m - c2[i];\n            ans = Math.min(ans, ca + cb);\n            if (i == 0) continue;\n            int r1 = 0, r2 = 0;\n            // 1\n            for (int j = i; j < 26; j++) r1 += c1[j];\n            for (int j = 0; j < i; j++) r1 += c2[j];\n            // 2\n            for (int j = i; j < 26; j++) r2 += c2[j];\n            for (int j = 0; j < i; j++) r2 += c1[j];\n            ans = Math.min(ans, Math.min(r1, r2));\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338836070","body":"#### 代码\n\n```java\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        randomizedQuicksort(nums, 0, nums.length - 1);\n        return nums;\n    }\n\n    public void randomizedQuicksort(int[] nums, int l, int r) {\n        if (l < r) {\n            int pos = randomizedPartition(nums, l, r);\n            randomizedQuicksort(nums, l, pos - 1);\n            randomizedQuicksort(nums, pos + 1, r);\n        }\n    }\n\n    public int randomizedPartition(int[] nums, int l, int r) {\n        int i = new Random().nextInt(r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums, r, i);\n        return partition(nums, l, r);\n    }\n\n    public int partition(int[] nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums, i, j);\n            }\n        }\n        swap(nums, i + 1, r);\n        return i + 1;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340280800","body":"#### 代码\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342043235","body":"#### 代码\n\n```java\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        while (left < right) { // 循环直至区间左右端点相同\n            int mid = left + (right - left) / 2; // 防止计算时溢出\n            if (isBadVersion(mid)) {\n                right = mid; // 答案在区间 [left, mid] 中\n            } else {\n                left = mid + 1; // 答案在区间 [mid+1, right] 中\n            }\n        }\n        // 此时有 left == right，区间缩为一个点，即为答案\n        return left;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343892750","body":"#### 代码\n\n```java\nclass Solution {\n    public int reversePairs(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        return reversePairsRecursive(nums, 0, nums.length - 1);\n    }\n\n    public int reversePairsRecursive(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePairsRecursive(nums, left, mid);\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 首先统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 随后合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n}\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345755387","body":"#### 代码\n\n```java\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Solution {\n\n    // Dijkstra 算法（应用前提：没有负权边，找单源最短路径）\n\n    public int swimInWater(int[][] grid) {\n        int n = grid.length;\n\n        Queue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(o -> grid[o[0]][o[1]]));\n        minHeap.offer(new int[]{0, 0});\n\n        boolean[][] visited = new boolean[n][n];\n        // distTo[i][j] 表示：到顶点 [i, j] 须要等待的最少的时间\n        int[][] distTo = new int[n][n];\n        for (int[] row : distTo) {\n            Arrays.fill(row, n * n);\n        }\n        distTo[0][0] = grid[0][0];\n\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (!minHeap.isEmpty()) {\n            // 找最短的边\n            int[] front = minHeap.poll();\n            int currentX = front[0];\n            int currentY = front[1];\n            if (visited[currentX][currentY]) {\n                continue;\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350226669","body":"#### 代码\n\n```java\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0) {\n            return 1.0;\n        }\n        double[] dp = new double[k + maxPts];\n        for (int i = k; i <= n && i < k + maxPts; i++) {\n            dp[i] = 1.0;\n        }\n        for (int i = k - 1; i >= 0; i--) {\n            for (int j = 1; j <= maxPts; j++) {\n                dp[i] += dp[i + j] / maxPts;\n            }\n        }\n        return dp[0];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352437815","body":"#### 代码\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356741274","body":"#### 代码\n\n```java\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> ans = new ArrayList<String>();\n        for (int h = 0; h < 12; ++h) {\n            for (int m = 0; m < 60; ++m) {\n                if (Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {\n                    ans.add(h + \":\" + (m < 10 ? \"0\" : \"\") + m);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358751929","body":"#### 代码\n\n```java\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        int ans = 0;\n        for (int i = 0; i != grid.length; ++i) {\n            for (int j = 0; j != grid[0].length; ++j) {\n                int cur = 0;\n                Deque<Integer> stacki = new LinkedList<Integer>();\n                Deque<Integer> stackj = new LinkedList<Integer>();\n                stacki.push(i);\n                stackj.push(j);\n                while (!stacki.isEmpty()) {\n                    int cur_i = stacki.pop(), cur_j = stackj.pop();\n                    if (cur_i < 0 || cur_j < 0 || cur_i == grid.length || cur_j == grid[0].length || grid[cur_i][cur_j] != 1) {\n                        continue;\n                    }\n                    ++cur;\n                    grid[cur_i][cur_j] = 0;\n                    int[] di = {0, 0, 1, -1};\n                    int[] dj = {1, -1, 0, 0};\n                    for (int index = 0; index != 4; ++index) {\n                        int next_i = cur_i + di[index], next_j = cur_j + dj[index];\n                        stacki.push(next_i);\n                        stackj.push(next_j);\n                    }\n                }\n                ans = Math.max(ans, cur);\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360643549","body":"#### 代码\n\n```java\nclass Solution {\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    int n;\n    int[][] grid;\n\n    public int maxDistance(int[][] grid) {\n        this.n = grid.length;\n        this.grid = grid;\n        int ans = -1;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 0) {\n                    ans = Math.max(ans, findNearestLand(i, j));\n                }\n            }\n        }\n        return ans;\n    }\n\n    public int findNearestLand(int x, int y) {\n        boolean[][] vis = new boolean[n][n];\n        Queue<int[]> queue = new LinkedList<int[]>();\n        queue.offer(new int[]{x, y, 0});\n        vis[x][y] = true;\n        while (!queue.isEmpty()) {\n            int[] f = queue.poll();\n            for (int i = 0; i < 4; ++i) {\n                int nx = f[0] + dx[i], ny = f[1] + dy[i];\n                if (!(nx >= 0 && nx < n && ny >= 0 && ny < n)) {\n                    continue;\n                }\n                if (!vis[nx][ny]) {\n                    queue.offer(new int[]{nx, ny, f[2] + 1});\n                    vis[nx][ny] = true;\n                    if (grid[nx][ny] == 1) {\n                        return f[2] + 1;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364795556","body":"#### 代码\n\n```java\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length, maxLen = 0, ans = 0;\n        int[] dp = new int[n];\n        int[] cnt = new int[n];\n        for (int i = 0; i < n; ++i) {\n            dp[i] = 1;\n            cnt[i] = 1;\n            for (int j = 0; j < i; ++j) {\n                if (nums[i] > nums[j]) {\n                    if (dp[j] + 1 > dp[i]) {\n                        dp[i] = dp[j] + 1;\n                        cnt[i] = cnt[j]; // 重置计数\n                    } else if (dp[j] + 1 == dp[i]) {\n                        cnt[i] += cnt[j];\n                    }\n                }\n            }\n            if (dp[i] > maxLen) {\n                maxLen = dp[i];\n                ans = cnt[i]; // 重置计数\n            } else if (dp[i] == maxLen) {\n                ans += cnt[i];\n            }\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366305675","body":"#### 代码\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] f = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            f[i][0] = 1;\n        }\n        for (int j = 0; j < n; ++j) {\n            f[0][j] = 1;\n        }\n        for (int i = 1; i < m; ++i) {\n            for (int j = 1; j < n; ++j) {\n                f[i][j] = f[i - 1][j] + f[i][j - 1];\n            }\n        }\n        return f[m - 1][n - 1];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367024319","body":"#### 代码\n\n```java\nclass Solution {\n    static int[][] dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\n\n    public double knightProbability(int n, int k, int row, int column) {\n        double[][][] dp = new double[k + 1][n][n];\n        for (int step = 0; step <= k; step++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (step == 0) {\n                        dp[step][i][j] = 1;\n                    } else {\n                        for (int[] dir : dirs) {\n                            int ni = i + dir[0], nj = j + dir[1];\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n}\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368433469","body":"#### 代码\n\n```java\nclass Solution {\n    int count = 0;\n\n    public int findTargetSumWays(int[] nums, int target) {\n        backtrack(nums, target, 0, 0);\n        return count;\n    }\n\n    public void backtrack(int[] nums, int target, int index, int sum) {\n        if (index == nums.length) {\n            if (sum == target) {\n                count++;\n            }\n        } else {\n            backtrack(nums, target, index + 1, sum + nums[index]);\n            backtrack(nums, target, index + 1, sum - nums[index]);\n        }\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369311747","body":"#### java解题\n```java\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                dp[i] += dp[i - coin];\n            }\n        }\n        return dp[amount];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370392081","body":"### 代码\n\n```java\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int m = g.length, n = s.length;\n        int count = 0;\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\n            while (j < n && g[i] > s[j]) {\n                j++;\n            }\n            if (j < n) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375035044","body":"#### 代码\n\n```java\nclass Solution {\n    Map<Integer, int[]> memo;\n    public int[] beautifulArray(int N) {\n        memo = new HashMap();\n        return f(N);\n    }\n\n    public int[] f(int N) {\n        if (memo.containsKey(N))\n            return memo.get(N);\n\n        int[] ans = new int[N];\n        if (N == 1) {\n            ans[0] = 1;\n        } else {\n            int t = 0;\n            for (int x: f((N+1)/2))  // odds\n                ans[t++] = 2*x - 1;\n            for (int x: f(N/2))  // evens\n                ans[t++] = 2*x;\n        }\n        memo.put(N, ans);\n        return ans;\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378150466","body":"### 代码\n\n```java\nclass Solution {\n    List<Integer> t = new ArrayList<Integer>();\n    List<List<Integer>> ans = new ArrayList<List<Integer>>();\n\n    public List<List<Integer>> subsets(int[] nums) {\n        int n = nums.length;\n        for (int mask = 0; mask < (1 << n); ++mask) {\n            t.clear();\n            for (int i = 0; i < n; ++i) {\n                if ((mask & (1 << i)) != 0) {\n                    t.add(nums[i]);\n                }\n            }\n            ans.add(new ArrayList<Integer>(t));\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298429697","body":"### 思路\nnum和k相加，从个位开始相加，同时记录一个进位变量，将数据放入list,反转即可\n\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //获取K的每一位数，直到K/10=0\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        int i=num.length-1;\n        //记录一个进位变量\n        int carry=0;\n        while(i>=0 || k>0){\n            int a= i>=0?num[i]:0;\n            int sum = a +k%10+carry;\n            carry= sum/10;\n            i--;\n            k=k/10;\n            res.add(sum%10);\n        }\n        if(carry>0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299678058","body":"## 思路\n1.遍历字符串，获取到字符 c 的位置，放入List中\n2.定义两个指针，last和next,刚开始last和next相等，当当前指针大于next指针时，将next指向下一个字符位置，last指向上一个字符位置，将当前指针与两个指针的差值最小作为结果集的元素\n\n## 代码\n```java\nclass Solution {\n        public int[] shortestToChar(String s, char c) {\n\n            ArrayList<Integer> es = new ArrayList<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    es.add(i);\n                }\n            }\n            int z=0;\n            int next = es.get(z);\n            int last= es.get(z);\n            int[] res = new int[s.length()];\n            for (int j = 0; j < s.length(); j++) {\n                if (j > next && es.size()> ++z) {\n                    last = next;\n                    next=es.get(z);\n                }\n                    res[j] = Math.min(Math.abs(j - next), Math.abs(j - last));\n            }\n            return res;\n        }\n    }\n```\n\n**复杂度分析**\n- 时间复杂度 O(N)\n- 空间复杂度 O(N^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301609830","body":"## 思路\n- 使用数组模拟栈\n- 栈的属性,栈的最大元素个数，栈顶值（用来判断栈中元素是否满了或空了）\n- increment方法：需要比较k值和栈中元素个数\n\n##\n```java\nclass CustomStack {\n        //栈的大小\n        private int maxSize;\n        //使用数组模拟栈\n        private int[] stack;\n        //top=-1\n        private int top = -1;\n\n        public CustomStack(int maxSize) {\n            this.maxSize = maxSize;\n            stack = new int[this.maxSize];\n        }\n\n        public void push(int x) {\n            if (top != stack.length - 1) {\n                stack[++top] = x;\n            }\n        }\n\n        public int pop() {\n            if (top != -1) {\n                return stack[top--];\n            } else {\n                return -1;\n            }\n\n        }\n\n        public void increment(int k, int val) {\n            int m = Math.min(k, top + 1);\n            for (int i = 0; i < m; i++) {\n                stack[i] = stack[i] + val;\n            }\n        }\n    }\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n**复杂度分析**\n- 时间复杂度\n- 空间复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303692208","body":"## 思路\n- 声明两个栈，一个数字栈，一个字符串栈\n- 注意数字可能不是个位数，因此需要累加\n- 遇到[，表明数字结束，将数字加入栈中，同时将空字符串加入栈中，并将数字和字符串记录归0\n- 遇到],pop字符串和数字，按照数字个数组织字符串，并将新的字符串赋给buff\n\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //声明一个栈，存放数字\n        Stack<Integer> stackNum = new Stack<>();\n        //声明一个栈，存放字符\n        Stack<StringBuffer> stackStr = new Stack<>();\n        //记录数字\n        int num=0;\n        StringBuffer buff = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            if(Character.isDigit(s.charAt(i))){\n                num=num*10+s.charAt(i)-'0';\n            }else if(s.charAt(i)=='['){\n                //先将数字入栈\n                stackNum.push(num);\n                //把字符存起来\n                stackStr.push(buff);\n                //数字归0\n                num=0;\n                buff=new StringBuffer();\n\n            }else if(s.charAt(i)==']'){\n                //取出数字栈顶元素\n                Integer pop = stackNum.pop();\n                //取出栈顶的字符栈\n                StringBuffer str = stackStr.pop();\n                for (int j = 0; j < pop; j++) {\n                    str.append(buff.toString());\n                }\n                buff=str;\n            }else{\n                buff.append(s.charAt(i));\n            }\n\n        }\n\n        return buff.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397283","body":"## 思路\n- 使用两个栈，一个输入栈，一个输出栈\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\n- empty方法需要判断两个栈都为空\n\n## 代码\n```java\nclass MyQueue {\n     //一个输入栈\n        private Stack inStack;\n     //一个输出栈\n     private Stack outStack;\n    public MyQueue() {\n        this.inStack=new Stack<Integer>();\n        this.outStack=new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        //push时，将数据push近输入栈\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        int res=0;\n        //如果输出栈为空，则可以将数据从输入栈中出栈，入栈到输出栈，再pop\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return Integer.parseInt(outStack.pop().toString());\n    }\n    \n    public int peek() {\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n\n          return  Integer.parseInt(outStack.peek().toString());\n\n    }\n    \n    public boolean empty() {\n        if(outStack.empty() && inStack.empty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(1)\n- 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819345","body":"## 思路\n- 考虑使用单调栈\n- 当栈为空或者后面的数字大于栈顶值时，需要将当前元素推入栈中；\n- 同时，当后面的元素小于栈顶元素时，需要和栈中所有的元素进行比较，以便判断当前元素是加入上一个块还是把比当前元素大的块都连在一起;\n- 最后，返回栈的大小\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if(stack.empty() || num>=stack.peek()){\n                //如果栈为空，或者当前元素大于等于栈顶元素，将当前元素入栈\n                stack.push(num);\n            }else{\n                //如果新加入的数字小于栈顶元素，则需要判断:是否比倒数第二个块的数字也小，\n                //如果小的话，需要将该块加入到一起，直到它大于以前块的最大值\n                Integer maxValue = stack.pop();\n                while(!stack.empty() && stack.peek()>num){\n                    stack.pop();\n                }\n                stack.push(maxValue);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(N)\n- 空间复杂度:O(N),栈的长度最多为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305374813","body":"## 思路\n- 需要确认在什么位置截断，即确定旋转的插入点和新链表的头节点位置，链表长度-K对链表长度取模，遍历到该点后，此点的next指向新链表的头节点，并将尾节点指向头节点，并在此处将该点指向null\n\n## 关键点\n\n-  如何确定插入点的位置\n- 如果k>链表长度怎么处理\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n if (head==null) return null;\n        int i=1;\n        ListNode curr=head;\n        //获取链表的长度\n        while(curr.next!=null){\n            curr=curr.next;\n            i++;\n        }\n        k=k%i;\n        //如果k等于0，返回原链表\n        if(k==0) return head;\n        //找到要插入的位置\n        ListNode node=head;\n        int point=i-k;\n        for (int j = 1; j < point; j++) {\n            node=node.next;\n        }\n        //截断的点位处指向一个新的节点\n        ListNode newNode=node.next;\n        //成为一个循环链表\n        curr.next=head;\n        //将node.next指向null,截断\n        node.next=null;\n        return newNode;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ 遍历链表两次\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306556247","body":"\n## 思路\n- 需要明确一次交换的节点顺序；\n- 首先，确定此次交换后的头节点，即curr.next=end，同时也和pre.next连接起来\n- 其次，需要确定此次交换的尾部和未交换部分的连接，即start.next=end.next;\n- 再次，交换，即 end.next=start\n- 最后，移动curr,将curr=start,为下一次交换做准备\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n if(head==null || head.next==null){\n            return head;\n        }\n        //声明一个哑节点\n        ListNode pre=new ListNode(-1);\n        pre.next= head;、\n       //curr专门用来遍历\n        ListNode curr=pre;\n        while( curr.next!=null && curr.next.next!=null){\n            ListNode start=curr.next;\n            ListNode end=curr.next.next;\n            //确定此次翻转的头节点\n            curr.next=end;\n            //此次交换的尾部指向未交换的节点\n            start.next=end.next;\n            //交换，end的下一个指向start\n            end.next=start;\n            //移动curr,为下一次交换做准备\n            curr=start;\n        }\n        return pre.next;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308896585","body":"## 思路\n- 使用快慢指针找到中点，切断左右\n- 使用递归，利用递归的反转性，rootNode.left = sortedListToBST(head); 这样树的最左边节点就是最小值。rootNode.right = sortedListToBST(slow.next);这样树的右边第一个节点就是最大值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==null) return null;\n        else if(head.next==null) return new TreeNode(head.val);\n        ListNode curr=new ListNode();\n        curr.next=head;\n        ListNode slow=head;\n        ListNode fast=head;\n        //当fast结束时，slow就是中点，curr是slow的前一个节点\n        while(fast!=null && fast.next!=null){\n            curr=curr.next;\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        //将slow前的节点截断\n        curr.next=null;\n        //中点就是根节点\n        TreeNode rootNode = new TreeNode(slow.val);\n        rootNode.left=sortedListToBST(head);\n        rootNode.right=sortedListToBST(slow.next);\n        return rootNode;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310057975","body":"## 思路\n- 使用双指针\n- 两个指针按照相同的步长和时间前进，当链表A走到终点，下一个节点为headB，当链表B走到终点，下一个节点为headA;\n- 当两个链表有公共尾部时，两个链表节点相等的即为相交节点，假如公共节点数量为c,链表A长度为a,链表b长度为b,此时指针a走过的距离为\na+(b-c),指针b走过的距离为b+(a-c),刚好相等；如果没有公共尾部，两个最后都会指向null,此时两个指针走过的距离为a+b\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n         if (headA == null || headB == null) return null;\n            ListNode currA = headA;\n            ListNode currB = headB;\n            while (currA != currB) {\n                currA = currA == null ? headB : currA.next;\n                currB = currB == null ? headA : currB.next;\n            }\n            return currA;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(a+b)$ a和b为链表长度\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311157220","body":"## 思路\n- 考虑使用map记录节点，map中包含遍历节点时，即说明该节点就是环形链表的入口节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n         //定义一个返回的节点\n        ListNode resultNode=null;\n        //定义一个遍历节点\n        ListNode curr=head;\n        //声明一个map，用于存储节点\n        HashMap<ListNode, ListNode> map = new HashMap<ListNode, ListNode>();\n        while(curr!=null){\n            if(!map.containsKey(curr)){\n                map.put(curr,curr.next);\n            }else{\n                resultNode=curr;\n                break;\n            }\n            curr=curr.next;\n        }\n        return resultNode;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507146","body":"## 思路\n- map和双向链表\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass LRUCache {\n private HashMap<Integer,DoubleNode> map;\n        //双链表\n        private DoubleLinkList cache;\n        //最大容量\n        private int capacity;\n    public LRUCache(int capacity) {\n        this.capacity=capacity;\n        map=new HashMap<Integer,DoubleNode>();\n        cache=new DoubleLinkList();\n    }\n    \n    public int get(int key) {\n        if(!map.containsKey(key)){\n            return -1;\n        }\n        //将该key提升为最常使用\n        makeRecently(key);\n        return map.get(key).val;\n    }\n    \n    public void put(int key, int value) {\n        if(map.containsKey(key)){\n            //删除该节点，再将其加入到尾部，最近使用的节点\n            deleteKay(key);\n            addRecently(key,value);\n            return;\n        }\n        if(capacity==cache.size()){\n            //删除最久未使用的\n            removeLeastRecently();\n        }\n        //添加为最近使用的\n        addRecently(key,value);\n    }\n\n    //将某个key提升为最近使用的\n        private void makeRecently(int key){\n            DoubleNode doubleNode = map.get(key);\n            //先从链表中删除这个节点，再重新插入到尾部\n            cache.remove(doubleNode);\n            cache.addLast(doubleNode);\n        }\n        //添加最近使用的元素\n        private void addRecently(int key,int val){\n            DoubleNode node = new DoubleNode(key, val);\n            //尾部就是最近使用的元素\n            cache.addLast(node);\n            //同时再map中记录\n            map.put(key,node);\n        }\n        //删除某一个key\n        private void deleteKay(int key){\n            DoubleNode node = map.get(key);\n            //链表中删除\n            cache.remove(node);\n            //从map中删除\n            map.remove(key);\n        }\n        //删除长期未使用的元素\n        private void removeLeastRecently(){\n        //即第一个元素\n           DoubleNode node = cache.removeFirst();\n            int key = node.key;\n            map.remove(key);\n        }\n}\n//构建双链表\n    class DoubleLinkList{\n        //头尾节点\n    private DoubleNode head,tail;\n    //链表capacity\n    private int size;\n    public DoubleLinkList(){\n        //初始化双向链表的数据\n        head=new DoubleNode(0,0);\n        tail=new DoubleNode(0,0);\n        //双向链表,此时的head和tail都是哑节点，目前链表种没有元素\n        head.next=tail;\n        tail.pre=head;\n        size=0;\n    }\n    //在链表尾部添加节点x\n    public void addLast(DoubleNode x){\n        x.pre=tail.pre;\n        x.next=tail;\n        tail.pre.next=x;\n        tail.pre=x;\n        size++;\n    }\n    //删除链表种的x节点\n    public void remove(DoubleNode x){\n        x.pre.next=x.next;\n        x.next.pre=x.pre;\n        size--;\n    }\n    //删除链表中的第一个节点，并返回节点\n    public DoubleNode removeFirst(){\n        if(head.next==tail) return null;\n        DoubleNode first=head.next;\n        remove(first);\n        return first;\n    }\n    //返回链表的长度\n    public int size(){\n        return size;\n    }\n}\n    //双链表的节点类\n    class DoubleNode{\n        public int key;\n        public int val;\n        public DoubleNode next;\n        public DoubleNode pre;\n        public DoubleNode(int k,int v){\n            this.key=k;\n            this.val=v;\n        }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * LRUCache* obj = new LRUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312686900","body":"## 思路\n- 树考虑使用递归\n- 递归终止条件 节点为null,说明该节点已经是叶子节点了\n- 加上本身这一层，就是树的深度\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n if(root==null) {\n            return 0;\n        }\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313846129","body":"## 思路\n- 递归\n- 比较两个树，左子树和右子树分别相等\n- 递归的终止：p和q均为null，返回true,p或q为null，则返回false,如果p和q的值不相等也返回false\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n if(p==null && q==null){\n            return true;\n        }\n        if(p==null || q==null){\n            return false;\n        }\n        if(p.val!=q.val){\n            return false;\n        }\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315442149","body":"## 思路\n- 考虑使用dfs\n- 如何确定每一个路径上的值，当前节点的值*10+左子节点的值/右子节点的值，该值需要累计，使用sum表示\n- 递归的终止条件：当遇到叶子节点，此时该路径上的值可以返回，即该路径的最终值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n       return nodeSum(root,0);\n\n    }\n    public int nodeSum(TreeNode node,int sum){\n        if(node==null) return 0;\n        sum=sum*10+node.val;\n        if(node.left==null && node.right==null){\n            //已经是叶子节点了，可以返回该路径的最终值了\n            return sum;\n        }\n        return nodeSum(node.left,sum)+nodeSum(node.right,sum);\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317130357","body":"## 思路\n- 广度优先遍历\n- 从右往左遍历，最后一个遍历的即是最后一层的最左边节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        int res=0;\n        ArrayDeque<TreeNode> arrayDeque = new ArrayDeque<TreeNode>();\n        arrayDeque.add(root);\n        while(!arrayDeque.isEmpty()){\n            TreeNode node = arrayDeque.poll();\n            if(node.right!=null){\n                arrayDeque.add(node.right);\n            }\n            if(node.left!=null){\n                arrayDeque.add(node.left);\n            }\n            res=node.val;\n        }\n        return res;\n    }\n}\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318809651","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Codec {\n\n   public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serialize(root,sb);\n        return sb.toString();\n    }\n    \n    void serialize(TreeNode root,StringBuilder sb) {\n    \tif (root == null) {\n\t\t\tsb.append(\"null\").append(\",\");\n\t\t\treturn;\n\t\t}\n    \t\n    \tsb.append(root.val).append(\",\");\n    \t\n    \tserialize(root.left,sb);\n    \tserialize(root.right,sb);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        LinkedList<String> nodes = new LinkedList<>();\n        for (String str : data.split(\",\")) {\n\t\t\tnodes.add(str);\n\t\t}\n        return deserialize(nodes);\n    }\n    \n    public TreeNode deserialize(LinkedList<String> nodes) {\n    \tif (nodes.isEmpty()) {  //注意是数组转换为链表\n\t\t\treturn null;\n\t\t}\n    \t\n    \t//链表最左侧为根节点\n    \tString first = nodes.removeFirst();  \n    \tif (first.equals(\"null\")) {\n\t\t\treturn null;\n\t\t}\n    \tTreeNode root = new TreeNode(Integer.parseInt(first));\n    \t\n    \troot.left = deserialize(nodes);\n    \troot.right = deserialize(nodes);\n    \t\n    \treturn root;\n    \t\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320178694","body":"## 思路\n- 使用dfs遍历树\n- 注意遍历过程中将树加入到map中，map的key为TreeNode,value为列，行和节点值\n- 按照这三个排序，列从小到大，行从小到大，同行同列从小到大\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    Map<TreeNode,int[]> map=new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root,new int[]{0,0,root.val});\n        dfs(root);\n        //对map中的节点进行排序，按照列号从小到大，行号从小到大，同行同列按值排序\n        List<int[]> list=new ArrayList<>(map.values());\n        Collections.sort(list,(a,b)->{\n            if(a[0]!=b[0]) return a[0] - b[0];\n            if(a[1]!=b[1]) return a[1] - b[1];\n            return a[2]-b[2];\n        });\n        int n=list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int j=i;\n            List<Integer> tmp = new ArrayList<>();\n            while(j<n && list.get(j)[0]==list.get(i)[0]){\n                tmp.add(list.get(j++)[2]);\n\n            }\n            ans.add(tmp);\n            i=j;\n\n        }\n        return ans;\n    }\n\n    void dfs(TreeNode root){\n        if(root==null) return;\n        int[] info=map.get(root);\n        int col=info[0];\n        int row=info[1];\n        int val=info[2];\n        if(root.left!=null){\n            map.put(root.left,new int[]{col-1,row+1,root.left.val});\n            dfs(root.left);\n        }\n        if(root.right!=null){\n            map.put(root.right,new int[]{col+1,row+1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320900921","body":"public int[] twoSum(int[] nums, int target) {\n        //声明一个map,key为val,value为index\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int[] res = new int[2];\n        //遍历数组\n        for (int i = 0; i < nums.length; i++) {\n           if(map.containsKey(target-nums[i])){\n              //如果map中包含target-num[i],则该点已经找到，返回\n              //key冲突问题在此处可以解决:如果两个key相同，在此处因为已经找到，不需要再入map,因此不存在冲突\n               res[0]=map.get(target-nums[i]);\n               res[1]=i;\n               break;\n           }\n           map.put(nums[i],i);\n        }\n\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1322238251","body":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int num : nums) {\n            if(map.containsKey(num)){\n                Integer value = map.get(num);\n                map.put(num,value+1);\n            }else{\n                map.put(num,1);\n            }\n        }\n        // 遍历map，用最小堆保存频率最大的k个元素\n        PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n            @Override\n            public int compare(Integer a, Integer b) {\n                return map.get(a) - map.get(b);\n            }\n        });\n        for (Integer key : map.keySet()) {\n            if (pq.size() < k) {\n                pq.add(key);\n            } else if (map.get(key) > map.get(pq.peek())) {\n                pq.remove();\n                pq.add(key);\n            }}\n        // 取出最小堆中的元素\n\n       int[] res = new int[k];\n\n        for (int i = 0; i < k; i++) {\n            res[i]=(pq.remove());\n        }\n\n        return res;\n\n    }\n}","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322247476","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int numberOfBoomerangs(int[][] points) {\n int ans = 0;\n        for(int i=0;i<points.length;i++){\n            Map<Integer,Integer> map = new HashMap();\n            for(int j=0;j<points.length;j++){\n                int disX = points[i][0] - points[j][0];\n                int disY = points[i][1] - points[j][1];\n                int distance = disX * disX + disY * disY;\n                map.put(distance, map.getOrDefault(distance, 0) + 1);\n            }\n\n            for(int val : map.values()){\n                if(val > 1){\n                    ans += val * (val -1);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323858794","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if(s==null || s.length()==0){\n       return 0;\n   }\n   HashMap<Character,Integer> map = new HashMap<>();\n   int n = s.length();\n   int count = 0,max = 0;\n    for (int i = 0; i < n; i++) {\n        char ch = s.charAt(i);\n        if(map.containsKey(ch)){\n            i = map.get(ch);\n            map.clear();\n            count=0;\n        }else {\n            map.put(ch,i);\n            count++;\n            max = Integer.max(max,count);\n        }\n    }\n    return max;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325279116","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\nArrayList<Integer> res = new ArrayList<>();\n        if(words==null || words.length==0) return res;\n        //将words存入map\n        Map<String, Integer> map = new HashMap<>();\n        for (String word : words) {\n            map.put(word,map.getOrDefault(word,0)+1);\n        }\n        //字符串的长度\n        int length=s.length();\n        //单个word的长度\n        int wLen = words[0].length();\n        //words的个数\n        int count=words.length;\n        //按照words的总长度进行截断s\n        for (int i = 0; i < length-wLen*count+1; i++) {\n            //按照words的总长度进行截断\n            String curr = s.substring(i, i + wLen * count);\n            HashMap<String, Integer> temp = new HashMap<>();\n            //针对curr进行遍历，长度为words中每个元素的长度来遍历\n            int j = 0;\n            for (; j < curr.length(); j+=wLen) {\n                //获取单独一个word长度的字符\n                String word = curr.substring(j, j + wLen);\n                if(!map.containsKey(word)) break;\n                temp.put(word,temp.getOrDefault(word,0)+1);\n                if(temp.get(word)>map.get(word)) break;\n\n            }\n            if(j==curr.length()) res.add(i);\n\n        }\nreturn res;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326564498","body":"力扣同类型题目\nclass Solution {\n    public int subarraysDivByK(int[] A, int K) {\n        HashMap<Integer,Integer> map = new HashMap<>();\n        map.put(0,1);\n        int presum = 0;\n        int count = 0;\n        for (int x : A) {\n             presum += x;\n             //当前 presum 与 K的关系，余数是几，当被除数为负数时取模结果为负数，需修正\n             int key = (presum % K + K) % K;\n             //查询map获取key也就是余数的次数\n             if (map.containsKey(key)) {\n                 count += map.get(key);\n             }\n             //存入map当前key，也就是余数\n             map.put(key,map.getOrDefault(key,0)+1);\n        }\n        return count;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327144135","body":"## 思路\n- 快慢指针，慢指针一次走一步，快指针一次走两步\n- 重点需要注意链表节点个数，将初始指针直接定位head,无论个数是奇数还是偶数都能够指向题目要求的中间节点\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n//声明两个指针，一个慢指针，一个快指针\n        ListNode slow=head;\n        ListNode fast=head;\n        while(fast!=null && fast.next!=null){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n        return slow;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ n为链表个数\n- 空间复杂度：$O(1)$ \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328049670","body":"## 思路\n- 双指针\n- 一个读指针，一个写指针，初始位置两个指针相同，当两个指针指向的值相同时，读指针向后移动；否则，写指针向后移动，并且将当前写指针指向的值置为都指针当前指向的值\n- 注意：因为目前返回的ifast是下标，但是需要返回的是数组长度，所以返回值要+1；\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        int islow=0;\n        int ifast=0;\n       while(ifast < nums.length){\n           if(nums[islow]==nums[ifast]){\n               ++ifast;\n           }else{\n               //如果两个不相等，则将islow向后移动，并且将islow指向的值置为当前ifast的值\n               ++islow;\n               nums[islow]=nums[ifast];\n           }\n       }\n       return islow+1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ n为数组长度\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328185241","body":"## 思路\n- 二分法，双指针\n- 二分法，定义左右两个指针，找到中间指针，当target大于中间指针的值，说明中间指针左边的值都小于target,则left=mid+1;当target小于中间指针的值，说明中间指针右边的值都大于target,则right=mid-1;当中间指针的值与target值相等，则返回mid指针；\n- 直到left>=right指针循环结束\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n     \n       if(nums.length==0){\n           return -1;\n       }\n       int left=0;\n       int right=nums.length-1;\n       while(left<=right){\n           int mid=(left+right)/2;\n           if(nums[mid]>target){\n                right=mid-1;\n           }else if(nums[mid]<target){\n              left=mid+1;\n           }else if(nums[mid]==target){\n             return mid;\n           }\n       }\n       return left;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logN)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329234950","body":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        if(nums.length<2){\n            return nums;\n        }\n     //双向队列，保存当前窗口的最大值，保证队列中的值从大到小排列\n     LinkedList<Integer> queue = new LinkedList();\n     //结果\n     int[] res = new int[nums.length-k+1];\n     for(int i=0;i<nums.length;i++){\n         //队列中要保持从大到小排列，如果队尾的值小，则需要依次弹出\n         while(!queue.isEmpty()&&nums[queue.peekLast()]<=nums[i]){\n             queue.pollLast();\n         }\n         //添加当前值进入队列\n         queue.addLast(i);\n         //判断当前队列中队首的值是否有效\n         if(queue.peek()<=i-k){\n             queue.poll();\n         }\n         //当窗口长度为k时，保存当前窗口的最大值\n         if(i+1>=k){\n             res[i+1-k]=nums[queue.peek()];\n         }\n     }\n      return res; \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330694878","body":"## 思路\n- 将【ai,bi】看作一个有向图，ai->bi，ai为出度，bi为入度\n- 当入度为n-1，出度为0时，返回i\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int findJudge(int n, int[][] trust) {\n int[] in=new int[n+1];\n        int[] out=new int[n+1];\n        for (int[] ints : trust) {\n            int a=ints[0];\n            int b=ints[1];\n            //入度\n            in[b]++;\n            //出度\n            out[a]++;\n        }\n        for (int i = 1; i <=n ; i++) {\n            if(in[i]==n-1 && out[i]==0){\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(m+n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332339665","body":"## 思路\n- dfs\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean possibleBipartition(int n, int[][] dislikes) {\n        int[] color =new int[n+1];\n        List<Integer>[] g=new List[n+1];\n        for (int i = 0; i <= n; i++) {\n            g[i]=new ArrayList<Integer>();\n        }\n        for (int[] p : dislikes) {\n            g[p[0]].add(p[1]);\n            g[p[1]].add(p[0]);\n        }\n        for (int i = 0; i <=n; i++) {\n            if(color[i]==0 && !dfs(i,1,color,g)){\n                return false;\n            }\n        }\n        return true;\n    }\n    public boolean dfs(int curnode,int newcolor,int[] color,List<Integer>[] g){\n        color[curnode]=newcolor;\n        for(int nextnode:g[curnode]){\n            if(color[nextnode] !=0 && color[nextnode]==color[curnode]){\n                return false;\n            }\n            if(color[nextnode]==0 && !dfs(nextnode,3^newcolor,color,g)){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333845417","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n // 初始化，将Items分组扔进各个组的set里，将group放进一个set\n        Map<Integer, Set<Integer>> groupItems = new HashMap<>();\n        Set<Integer> groupIds = new HashSet<>();\n        int gId = m;\n        for(int i = 0; i < n; ++i){\n            if(group[i] == -1){\n                group[i] = gId++;\n            }\n            int groupId = group[i];\n            if(!groupItems.containsKey(groupId)){\n                groupItems.put(groupId, new HashSet());\n            }\n            groupItems.get(groupId).add(i);\n            groupIds.add(group[i]);\n        }\n\n        // 构造图，划分为组间的拓扑和组内item的拓扑图\n        // 数组计算各个group或item的入度，链表计算某group或item完成后可以减少哪些group或item入度\n        int[] betweenGroupInDev = new int[gId];\n        List<List<Integer>> groupNeighbours = new ArrayList<>();\n        int[] inGroupInDev = new int[n];\n        List<List<Integer>> itemNeighbours = new ArrayList<>();\n        for(int i = 0; i < n; ++i){\n            List<Integer> beforeItem = beforeItems.get(i);\n            for(int one: beforeItem){\n                if(group[i] == group[one]){\n                    // 同一个小组内，则计为组内的入度\n                    inGroupInDev[i]++;\n                    while(itemNeighbours.size() <= one){\n                        itemNeighbours.add(new ArrayList<>());\n                    }\n                    itemNeighbours.get(one).add(i);\n                }else{\n                    // 不同小组，则计为小组间的入度\n                    betweenGroupInDev[group[i]]++;\n                    while(groupNeighbours.size() <= group[one]){\n                        groupNeighbours.add(new ArrayList<>());\n                    }\n                    groupNeighbours.get(group[one]).add(group[i]);\n                }\n            }\n        }\n\n        // 开始拓扑排序，先组间拓扑排序\n        List<Integer> groupOrder = topSort(groupIds, betweenGroupInDev, groupNeighbours);\n        int[] res = new int[n];\n        if(groupOrder.size() == 0) return new int[0];\n\n        // 基于组间的拓扑顺序，对各个组内的item进行拓扑排序\n        int i = 0;\n        for(int group1: groupOrder){\n            List<Integer> itemOrder = topSort(groupItems.get(group1), inGroupInDev, itemNeighbours);\n            if(itemOrder.size() == 0) return new int[0];\n            for(int item: itemOrder){\n                res[i++] = item;\n            }\n        }\n        return res;\n    }\n\n    public List<Integer> topSort(Set<Integer> set, int[] inDev, List<List<Integer>> neighbours){\n        Deque<Integer> queue = new LinkedList<>();\n        List<Integer> res = new ArrayList<>();\n        for(int i: set){\n            if(inDev[i] == 0){\n                queue.offer(i);\n                res.add(i);\n            }\n        }\n        while(!queue.isEmpty()){\n            int cur = queue.poll();\n            if(neighbours.size() <= cur) continue;\n            for(int neighbour: neighbours.get(cur)){\n                if(--inDev[neighbour] == 0){\n                    queue.offer(neighbour);\n                    res.add(neighbour);\n                }\n            }\n        }\n        return res.size() == set.size()? res:new ArrayList<>();\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335346149","body":"## 思路\n- 上下左右，按照每个步骤进行加减即可\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public boolean judgeCircle(String moves) {\n int x=0;\n        int y=0;\n        for (char c : moves.toCharArray()) {\n            if(c=='R'){\n                x++;\n            }else if(c=='L'){\n                x--;\n            }else if(c=='U'){\n                y++;\n            }else if(c=='D'){\n                y--;\n            }\n        }\n        return x==0 && y==0;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336166798","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] getOrder(int[][] tasks) {\n        int n = tasks.length;\n        int[][] nts = new int[n][3];\n        for (int i = 0; i < n; i++) nts[i] = new int[]{tasks[i][0], tasks[i][1], i};\n        // 根据任务入队时间进行排序\n        Arrays.sort(nts, (a,b)->a[0]-b[0]);\n        // 先按照持续时间排序，再根据任务编号排序\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b)->{\n            if (a[1] != b[1]) return a[1] - b[1];\n            return a[2] - b[2];\n        });\n        int[] ans = new int[n];\n        for (int time = 1, j = 0, idx = 0; idx < n; ) {\n            // 如果当前任务满足入队时间，则进行入队\n            while (j < n && nts[j][0] <= time) q.add(nts[j++]);\n            if (q.isEmpty()) {\n                // 如果当前队列没有任务，直接跳到下个任务的入队时间\n                time = nts[j][0];\n            } else {\n                // 如果有可执行任务的话，根据优先级将任务出队（记录下标），并跳到该任务完成时间点\n                int[] cur = q.poll();\n                ans[idx++] = cur[2];\n                time += cur[1];\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336414111","body":"## 思路\n- 需要获取开始时间和结束时间的小时数和分钟数\n- 如果结束时间小于开始时间，则需要加上24小时\n- 开始时间向上取整，结束时间向下取整，/15*15\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int numberOfRounds(String loginTime, String logoutTime) {\nint res = 0;\n        int h = Integer.parseInt(loginTime.substring(0, 2));\n        int m = Integer.parseInt(loginTime.substring(3, 5));\n        int hh = Integer.parseInt(logoutTime.substring(0, 2));\n        int mm = Integer.parseInt(logoutTime.substring(3, 5));\n        if (h > hh || (h == hh && m > mm)) {\n            res += (23 - h + hh) * 4;\n        } else {\n            res += (hh - h - 1) * 4;\n        }\n        res += (60 - m) / 15;\n        res += mm / 15;\n        return res >= 0 ? res : 0;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337447718","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int minCharacters(String a, String b) {\nint len1 = a.length(), len2 = b.length(), result = len1+len2; \n        int[] countA = new int[26];\n        //统计a中的各个字母个数\n        for(int i=0;i<len1;i++)\n            countA[a.charAt(i)-'a']++;\n        int[] countB = new int[26];\n        //统计b中的各个字母个数\n        for(int i=0;i<len2;i++)\n            countB[b.charAt(i)-'a']++;\n\n        //maxCount用来统计a和b中数量最多的字母的数量\n        int cur1 = 0, cur2 = 0, maxCount = countA[25]+countB[25];\n        //从左往右依次尝试25个分割点（'z'不能作为分割点，因为找不到比'z'更大的字母了）\n        for(int i=0;i<25;i++){\n            cur1+=countA[i];\n            cur2+=countB[i];\n            result=Math.min(result,cur1+len2-cur2);\n            result=Math.min(result,cur2+len1-cur1);\n            maxCount=Math.max(maxCount,countA[i]+countB[i]);\n        }\n        //将a和b都变成只包含相同字母的方案\n        result = Math.min(result,len1+len2-maxCount);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339388260","body":"## 思路\n- 归并排序\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\nif (nums.length <= 1) {\n        return nums;\n      }\n      merge_sort_c(nums,0,nums.length-1);\n      return nums;\n    }\n\n    private void merge_sort_c(int[] nums, int left, int right) {\n      if (left >= right) {\n        return;\n      }\n\n      int point = (left+right)/2;\n      merge_sort_c(nums,left,point);\n      merge_sort_c(nums,point+1,right);\n      merge_arr(nums,left,point,right);\n    }\n\n    private void merge_arr(int[] nums, int left, int point, int right) {\n      int i = left;\n      int j = point + 1;\n      int k = 0;\n      int [] arr = new int[right-i+1];\n\n      while (i <= point && j <= right) {\n        if (nums[i] <= nums[j]) {\n          arr[k] = nums[i];\n          i += 1;\n        } else {\n          arr[k] = nums[j];\n          j += 1;\n        }\n        k += 1;\n      }\n\n      if (i == point + 1) {\n        while (j <= right) {\n          arr[k] = nums[j];\n          k += 1;\n          j += 1;\n        }\n      } else {\n        while (i <= point) {\n          arr[k] = nums[i];\n          k += 1;\n          i += 1;\n        }\n      }\n      System.arraycopy(arr,0,nums,left,arr.length);\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341124664","body":"## 思路\n- 二分法\n- 注意：向下取整\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int mySqrt(int x) {\n if (x == 0) return 0;\n            if (x == 1) return 1;\n            int left = 1;\n            int right = x / 2;\n            while (left <= right) {\n                int mid = left + (right - left) / 2;\n                //为避免乘法一处，使用除法\n                if (mid > x / mid) {\n                    right = mid - 1;\n                } else if (mid < x / mid) {\n                    left = mid+1;\n                } else {\n                    return mid;\n                }\n            }\n            return right;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(logn)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342853429","body":"public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left=1;\n        int right=n;\n        while(left<=right){\n           int mid=left+(right-left)/2;\n           if(isBadVersion(mid)){\n               right=mid-1;\n           }else{\n               left=mid+1;\n           }\n        }\n        return left;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344439849","body":"## 思路\n- 归并排序\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int reversePairs(int[] nums) {\n   if (nums.length == 0) {\n            return 0;\n        }\n        return reversePair(nums, 0, nums.length - 1);\n    }\n\n    public int reversePair(int[] nums, int left, int right) {\n        if (left == right) {\n            return 0;\n        } else {\n            int mid = (left + right) / 2;\n            int n1 = reversePair(nums, left, mid);\n            int n2 = reversePair(nums, mid + 1, right);\n            int ret = n1 + n2;\n\n            // 统计下标对的数量\n            int i = left;\n            int j = mid + 1;\n            while (i <= mid) {\n                while (j <= right && (long) nums[i] > 2 * (long) nums[j]) {\n                    j++;\n                }\n                ret += j - mid - 1;\n                i++;\n            }\n\n            // 合并两个排序数组\n            int[] sorted = new int[right - left + 1];\n            int p1 = left, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= right) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > right) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            for (int k = 0; k < sorted.length; k++) {\n                nums[left + k] = sorted[k];\n            }\n            return ret;\n        }\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345565848","body":"## 思路\r\n- 二分加双指针\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\nArrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n        int l = 0, r = (int) 1e9;\r\n        while (l < r) {\r\n            int mid = l + r >> 1;\r\n            if (check(houses, heaters, mid)) r = mid;\r\n            else l = mid + 1;\r\n        }\r\n        return r;\r\n    }\r\n    boolean check(int[] houses, int[] heaters, int x) {\r\n        int n = houses.length, m = heaters.length;\r\n        for (int i = 0, j = 0; i < n; i++) {\r\n            while (j < m && houses[i] > heaters[j] + x) j++;\r\n            if (j < m && heaters[j] - x <= houses[i] && houses[i] <= heaters[j] + x) continue;\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345569052","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int smallestDistancePair(int[] nums, int k) {\nArrays.sort(nums);\n        int l = 0, r = (int)1e6;\n        while (l < r) {\n            int mid = l + r >> 1;\n            if (check(nums, mid) >= k) r = mid;\n            else l = mid + 1;\n        }\n        return r;\n    }\n    int check(int[] nums, int x) {\n        int n = nums.length, ans = 0;\n        for (int i = 0, j = 1; i < n; i++) {\n            while (j < n && nums[j] - nums[i] <= x) j++;\n            ans += j - i - 1;\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346686343","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    private int n;\n    private int[][] grid;\n    private int[] dx = {-1, 1, 0, 0};\n    private int[] dy = {0, 0, -1, 1};\n\n    public int swimInWater(int[][] grid) {\n        n = grid.length;\n        this.grid = grid;\n        int left = Math.max(grid[0][0], grid[n - 1][n - 1]);\n        int right = n * n - 1;\n\n        while(left <= right){\n            int mid = (left + right) / 2;\n            if(dfs(mid, 0, 0, new boolean[n][n])){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n\n    private boolean dfs(int t, int x, int y, boolean[][] visited){\n        if(x == n - 1 & y == n - 1){\n            return true;\n        }\n        visited[x][y] = true;\n        for(int i = 0; i < 4; i++){\n            int nx = x + dx[i], ny = y + dy[i];\n            if(nx >= 0 && nx < n && ny >= 0 && ny < n && !visited[nx][ny] && grid[nx][ny] <= t){\n                if(dfs(t, nx, ny, visited)){\n                    return true;\n                }\n            }\n        }\n        return false;\n\n\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348707904","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxVowels(String s, int k) {\nint count = 0;\n        int length = s.length();\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s.charAt(i))) {\n                count++;\n            }\n        }\n        int maxCount = count;\n        for (int i = k; i < length; i++) {\n            if (isVowel(s.charAt(i - k))) {\n                count--;\n            }\n            if (isVowel(s.charAt(i))) {\n                count++;\n            }\n            maxCount = Math.max(maxCount, count);\n        }\n        return maxCount;\n    }\n\n    public boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';\n    }\n\n}\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352993532","body":"## 思路\n- 滑动窗口\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\nList<Integer> res = new ArrayList<>();\n        int sLen = s.length(), pLen = p.length();\n        if (sLen < pLen) {\n            return res;\n        }\n        int[] count = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            count[s.charAt(i) - 'a']++;\n            count[p.charAt(i) - 'a']--;\n        }\n        int differ = 0;\n        for (int i = 0; i < count.length; ++i) {\n            if (count[i] != 0) {\n                differ++;\n            }\n        }\n        if (differ == 0) {\n            res.add(0);\n        }\n        for (int i = 0; i < sLen - pLen; ++i) {\n            // 去除当前字母的影响前，\n            if (count[s.charAt(i) - 'a'] == 1) {\n                differ--;\n            } else if (count[s.charAt(i) - 'a'] == 0) {\n                differ++;\n            }\n            // 去除当前字母的影响\n            count[s.charAt(i) - 'a']--;\n            // 窗口向后移动一个位置前\n            if (count[s.charAt(i + pLen) - 'a'] == -1) {\n                differ--;\n            } else if (count[s.charAt(i + pLen) - 'a'] == 0) {\n                differ++;\n            }\n            // 窗口向后移动一个位置\n            count[s.charAt(i + pLen) - 'a']++;\n            if (differ == 0) {\n                res.add(i + 1);\n            }\n        }\n        return res;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354925638","body":"## 思路\n- 滑动窗口+哈希表\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    // 通过滑动窗口来解决\n    Map<Character, Integer> osiMap = new HashMap<>(); // 存储字符串t中每个字符和每个字符出现的次数\n    Map<Character, Integer> cntMap = new HashMap<>(); // 动态存储截取的字符串中每个字符包含的个数\n\n    public String minWindow(String s, String t) {\n        int tLen = t.length();\n        for (int i = 0; i < tLen; i++) {\n            char a = t.charAt(i);\n            osiMap.put(a, osiMap.getOrDefault(a, 0) + 1);\n        }\n        int sLen = s.length();\n        int l = 0, r = -1;\n        int ansL = -1, ansR = -1, len = Integer.MAX_VALUE;\n        while (r < sLen) {\n            ++r;\n            if (r < sLen && osiMap.containsKey(s.charAt(r))) {\n                cntMap.put(s.charAt(r), cntMap.getOrDefault(s.charAt(r), 0) + 1);\n            }\n            while (check() && l <= r) {\n                if (r - l + 1 < len) {\n                    len = r - l + 1;\n                    ansL = l;\n                    ansR = l + len;\n                }\n                // 判断当前开头字符是否是t中所含字符\n                if (osiMap.containsKey(s.charAt(l))) {  // 开始滑动窗口\n                    cntMap.put(s.charAt(l), cntMap.getOrDefault(s.charAt(l), 0) - 1);\n                }\n                ++l;\n            }\n        }\n        return ansL == -1 ? \"\" : s.substring(ansL, ansR);\n    }\n\n    public boolean check() {\n        for (Map.Entry<Character, Integer> entry : osiMap.entrySet()) {\n            Character key = entry.getKey();\n            Integer value = entry.getValue();\n            if (cntMap.getOrDefault(key, 0) < value) return false;\n        }\n        return true;\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356306415","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\nint n = cardPoints.length;\n        int curSum = 0;\n        for(int i=0;i<n-k;i++){\n            curSum += cardPoints[i];\n        }\n        int res = curSum;\n        //滑动窗口求n-k个连续元素的最小值\n        for(int i=n-k;i<n;i++){\n            curSum += cardPoints[i] - cardPoints[i-n+k];\n            res = Math.min(res,curSum);\n        }\n        int allSum = 0;\n        for(int num:cardPoints){\n            allSum += num;\n        }\n        //数组总和减去n-k个连续元素的最小值即为结果\n        return allSum - res;\n\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356813572","body":"## 思路\n- 回溯+dfs\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n     List<Integer> mins;\n    List<String> res;\n\n    public List<String> readBinaryWatch(int num) {\n        res = new ArrayList<>();\n        mins = new ArrayList<>();\n        for (int i = 0; i < 6 && num >= i; i++) {\n            dfs(0, 0, i, true);\n            dfs(0, 0, num - i, false);\n            mins.clear();\n        }\n        return res;\n    }\n\n    private void dfs(int st, int sum, int cnt, boolean flag) {\n        if (cnt == 0) {\n            if (flag) {\n                mins.add(sum);\n            } else {\n                if (!mins.isEmpty()) { \n                    for (int m : mins) {\n                        // res.add(String.format(\"%d:%02d\", sum, m));\n                        StringBuilder sb = new StringBuilder();\n                        sb.append(sum).append(':');\n                        if (m < 10) {\n                            sb.append('0');\n                        }\n                        sb.append(m);\n                        res.add(sb.toString());\n                    }\n                }\n            }\n            return;\n        }\n\n        for (int i = st; i < (flag ? 6 : 4); i++) {\n            int temp = (int)Math.pow(2, i);\n            if (flag && sum + temp >= 60 || !flag && sum + temp >= 12) {\n                break;\n            }\n            dfs(i + 1, sum + temp, cnt - 1, flag);\n        }\n    }\n\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357758325","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int totalNQueens(int n) {\nSet<Integer> columns = new HashSet<>();\n        Set<Integer> dis1 = new HashSet<>();\n        Set<Integer> dis2 = new HashSet<>();\n        return dfs( n, 0, columns, dis1, dis2);\n    }\n\n    public int dfs(int n, int row, Set<Integer> columns, Set<Integer> dis1, Set<Integer> dis2) {\n        if (row == n) {\n            return 1;\n        } else {\n            int count = 0;\n            for (int i = 0; i < n; i++) {\n                if (columns.contains(i)) {\n                    continue;\n                }\n                int di1 = row - i;\n                if (dis1.contains(di1)) {\n                    continue;\n                }\n                int di2 = row + i;\n                if (dis2.contains(di2)) {\n                    continue;\n                }\n                columns.add(i);\n                dis1.add(di1);\n                dis2.add(di2);\n                count += dfs(n, row+1, columns, dis1, dis2);\n                columns.remove(i);\n                dis1.remove(di1);\n                dis2.remove(di2);\n            }\n            return count;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359384993","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n //定义一个表示岛屿的面积\n        int max = 0;\n        //这两个for循环是来遍历整张二维格上的所有陆地的。\n        //i 表示行，j表示列\n        for(int i = 0;i<grid.length;i++){\n            for(int j = 0; j<grid[0].length;j++){\n                //陆地的格\n                if(grid[i][j]==1){\n                    //取出最大的面积\n                    max = Math.max(max,dfs(grid,i,j));\n                }  \n            }\n        }\n        //返回最大的陆地面积\n        return max;\n    }\n    public int  dfs(int[][] grid,int i,int j){\n        //当超出岛屿边界（上下左右）的时候，就直接退出，特别要加上当遍历到海洋的时候也要退出，\n        if(i<0||j<0 || i>=grid.length || j>= grid[0].length|| grid[i][j]==0) return 0;\n       //定义一个变量表示岛屿的面积，就是包含几个陆地\n        int sum = 1;\n        //将陆地改为海洋，防止重复陆地重复遍历。\n        grid[i][j] =0;\n        //遍历上方元素，每遍历一次陆地就加一\n        sum += dfs(grid,i+1,j);\n        //遍历下方元素\n        sum +=dfs(grid,i-1,j);\n        //遍历右边元素\n        sum +=dfs(grid,i,j+1);\n        //遍历左边元素\n        sum += dfs(grid,i,j-1);\n        return sum;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361368175","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int maxDistance(int[][] grid) {\nint[] dx = {0, 0, 1, -1};\n        int[] dy = {1, -1, 0, 0};\n\n        Queue<int[]> queue = new ArrayDeque<>();\n        int m = grid.length, n = grid[0].length;\n        // 先把所有的陆地都入队\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    queue.offer(new int[] {i, j});\n                }\n            }\n        }\n\n        // 从各个陆地开始，一圈一圈的遍历海洋，最后遍历到的海洋就是离陆地最远的海洋\n        boolean hasOcean = false;\n        int[] point = null;\n        while (!queue.isEmpty()) {\n            point = queue.poll();\n            int x = point[0], y = point[1];\n            // 取出队列的元素，将其四周的海洋入队。\n            for (int i = 0; i < 4; i++) {\n                int newX = x + dx[i];\n                int newY = y + dy[i];\n                if (newX < 0 || newX >= m || newY < 0 || newY >= n || grid[newX][newY] != 0) {\n                    continue;\n                }\n                grid[newX][newY] = grid[x][y] + 1; \n                hasOcean = true;\n                queue.offer(new int[] {newX, newY});\n            }\n        }\n\n        // 没有陆地或者没有海洋，返回-1。\n        if (point == null || !hasOcean) {\n            return -1;\n        }\n\n        // 返回最后一次遍历到的海洋的距离。\n        return grid[point[0]][point[1]] - 1;\n\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362783262","body":"public int findCircle(List<List<Integer>> graph, int target) {\n        Queue<Integer> queue = new ArrayDeque<>();\n        Set<Integer> set = new HashSet<>();\n        queue.offer(target);\n        int length = 0;\n        while (!queue.isEmpty()) {\n            length++;\n            for (int size = queue.size(); size > 0; size--) {\n                var curr = queue.poll();\n                set.add(curr);\n\n                for (var next : graph.get(curr)) {\n                    if (!set.contains(next)){\n\t\t\t\t\tqueue.offer(next);\n\t\t\t\t\t}else if (next == target){\n                        return length;\n\t\t\t\t\t\t}\n                }\n            }\n        }\n\n        return -1;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363832532","body":"思路\n使用dfs遍历树\n注意遍历过程中将树加入到map中，map的key为TreeNode,value为列，行和节点值\n按照这三个排序，列从小到大，行从小到大，同行同列从小到大\n关键点\n代码\n语言支持：Java\nJava Code:\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    Map<TreeNode,int[]> map=new HashMap<>();\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        map.put(root,new int[]{0,0,root.val});\n        dfs(root);\n        //对map中的节点进行排序，按照列号从小到大，行号从小到大，同行同列按值排序\n        List<int[]> list=new ArrayList<>(map.values());\n        Collections.sort(list,(a,b)->{\n            if(a[0]!=b[0]) return a[0] - b[0];\n            if(a[1]!=b[1]) return a[1] - b[1];\n            return a[2]-b[2];\n        });\n        int n=list.size();\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int i = 0; i < n;) {\n            int j=i;\n            List<Integer> tmp = new ArrayList<>();\n            while(j<n && list.get(j)[0]==list.get(i)[0]){\n                tmp.add(list.get(j++)[2]);\n\n            }\n            ans.add(tmp);\n            i=j;\n\n        }\n        return ans;\n    }\n\n    void dfs(TreeNode root){\n        if(root==null) return;\n        int[] info=map.get(root);\n        int col=info[0];\n        int row=info[1];\n        int val=info[2];\n        if(root.left!=null){\n            map.put(root.left,new int[]{col-1,row+1,root.left.val});\n            dfs(root.left);\n        }\n        if(root.right!=null){\n            map.put(root.right,new int[]{col+1,row+1,root.right.val});\n            dfs(root.right);\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364536594","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n+1];\n        dp[0] = dp[1] = 0;\n        for(int i = 2;i <= n;i++){\n            dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);\n        }\n        return dp[n];\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364683815","body":"## 思路\n- 动态规划\n- 由于不可以在相邻房屋偷窃，所以在当前n位置的房屋可以偷窃的最大值，要么就是n-1房屋可以偷窃的最大值，要么就是n-2位置房屋可偷窃的最大值加上当前房屋可偷窃的值，取最大值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int rob(int[] nums) {\n        int len = nums.length;\n        if(len == 0)\n            return 0;\n        int[] dp = new int[len + 1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        for(int i = 2; i <= len; i++) {\n            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i-1]);\n        }\n        return dp[len];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365233383","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        if(n == 1) return 1;\n\n        int[] dp = new int[n];\n        int[] count = new int[n];\n        Arrays.fill(dp, 1);\n        Arrays.fill(count, 1);\n        int maxLength = 0;\n\n        for(int i = 1; i < n; i++){\n            for(int j = 0; j < i; j++){\n                if(nums[i] > nums[j]){\n                    if(dp[j] + 1 > dp[i]){\n                        dp[i] = dp[j] + 1;\n                        count[i] = count[j];\n                    }else if(dp[j] + 1 == dp[i]){\n                        count[i] += count[j];\n                    }\n                }\n            }\n            maxLength = Math.max(maxLength, dp[i]);\n        }\n\n        int res = 0;\n        for(int i = 0; i < n; i++){\n            if(dp[i] == maxLength){\n                res += count[i];\n            }\n        }\n        return res;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365962512","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        char[] t1 = text1.toCharArray();\n        char[] t2 = text2.toCharArray();\n        int length1 = t1.length;\n        int length2 = t2.length;\n        int[][] dp = new int[length1+1][length2+1];\n        for (int i = 1; i < length1 +1; i++) {\n            for (int j = 1; j < length2 +1; j++) {\n                if (t1[i-1] == t2[j-1]){\n                    // 找到一个 lcs 的元素，继续往前找\n                    dp[i][j] = 1+ dp[i-1][j-1];\n                }else {\n                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[length1][length2];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366665223","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] res = new int[m][n];\n        for (int i = 0; i < m; i++) {\n            res[i][0] = 1;\n        }\n        for (int i = 0; i < n; i++) {\n            res[0][i] = 1;\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                res[i][j] = res[i - 1][j] + res[i][j - 1];\n            }\n        }\n        return res[m-1][n-1];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367400247","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        int[][] dirs = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};\n        double[][][] dp = new double[n][n][k + 1];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[i][j][0] = 1;\n            }\n        }\n        for (int z = 1; z <= k; z++) {\n            for (int x = 0; x < n; x++) {\n                for (int y = 0; y < n; y++) {\n                    for (int i = 0; i < 8; i++) {\n                        int dx = x + dirs[i][0], dy = y + dirs[i][1];\n                        if (dx >= 0 && dx < n && dy >= 0 && dy < n) {\n                            dp[x][y][z] += dp[dx][dy][z - 1] / 8;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[row][column][k];\n    }\n}\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1369031226","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(coins.length == 0){\n            return -1;\n        }\n\n        // res[n]的值： 表示的凑成总金额为n所需的最少的硬币数\n        int[] res = new int[amount+1];\n        res[0] = 0;\n        for(int i = 1; i <= amount;i++){\n            int min = Integer.MAX_VALUE;\n            for(int j = 0;j < coins.length;j++){\n                if(i - coins[j] >= 0 && res[i-coins[j]] < min){\n                    min = res[i-coins[j]] + 1;\n                }\n            }\n            \n            res[i] = min;\n        }\n\n        return res[amount] == Integer.MAX_VALUE ? -1 : res[amount];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369774147","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int change(int amount, int[] coins) {\n        int n = coins.length;\n        int[][] dp = new int[n+1][amount+1];\n        for(int i=0;i<n+1;i++){\n            dp[i][0] = 1;\n        }\n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=amount;j++){\n                if(j-coins[i-1]>=0){\n                    dp[i][j] = dp[i-1][j]+dp[i][j-coins[i-1]];\n                }else{\n                    dp[i][j] = dp[i-1][j];\n                }\n            }\n        }\n        return dp[n][amount];\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370899215","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n        int count = 0;\n        //从数组最大值开始遍历\n        for(int i = g.length-1,j = s.length-1; i >= 0 && j >= 0;){\n            if(s[j] >= g[i]){\n                count++;\n                j--;\n                i--;\n            }else{\n                i--;\n            }\n        }\n        return count;\n\n    }\n}\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373598637","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int numRescueBoats(int[] people, int limit) {\n        Arrays.sort(people);\n        int i = 0, j = people.length - 1;\n        int res = 0;\n        \n        while(i <= j){\n            if(people[i] + people[j] <= limit)\n                i++;\n            j--;\n            res++;\n        }\n        return res;\n    }\n}\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375680517","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    private void solve(int[] num, int begin, int end, int[] temp) {\n        if (end - begin <= 2) {\n            return;\n        }\n        int pos = (end - begin + 1) >> 1;\n        for (int i = begin; i < end; i += 2) {\n            temp[begin + ((i - begin) >> 1)] = num[i];\n            if (i < end - 1) {\n                temp[begin + pos + ((i - begin) >> 1)] = num[i + 1];\n            }\n        }\n        for (int i = begin; i < end; i++) {\n            num[i] = temp[i];\n        }\n        solve(num, begin, begin + pos, temp);\n        solve(num, begin + pos, end, temp);\n    }\n\n    public int[] beautifulArray(int N) {\n        int[] num = new int[N], temp = new int[N];\n        for (int i = 0; i < N; i++) {\n            num[i] = i + 1;\n        }\n        if (N <= 2) {\n            return num;\n        }\n        solve(num, 0, N, temp);\n        return num;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377222496","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n    int diff = 0;\n    for (int n : nums) {\n        diff ^= n;\n    }\n    diff = Integer.highestOneBit(diff);\n    int[] result = { 0, 0 };\n    for (int n : nums) {\n        if ((diff & n) == 0) {\n            result[0] ^= n;\n        } else {\n            result[1] ^= n;\n        }\n    }\n    return result;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378961225","body":"## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        backtrack(nums, new ArrayList<>(), ans, 0);\n        return ans;\n    }\n    public void backtrack(int[] nums, List<Integer> cur, List<List<Integer>> ans, int k) {\n        ans.add(new ArrayList<>(cur));\n        for(int i = k; i < nums.length; ++i) {\n            cur.add(nums[i]);\n            backtrack(nums, cur, ans, i + 1);\n            cur.remove(cur.size() - 1);\n        }\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298455946","body":"```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n //一开始尝试转为数字逐位相加，没考虑越界问题，部分用例没有通过。参考了题解中的一个答案修改。\nvar addToArrayForm = function(num, k) {\n    const result = [];\n    let i = num.length - 1;\n    while(i>= 0 || k > 0){\n        if(i >= 0){\n            k += num[i];\n            i--;\n        }\n        result.push(k % 10);\n        k = parseInt(k / 10);\n    }\n   \n    return result.reverse();\n};\n//时间复杂度 O(n)\n//空间复杂度 O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298543068","body":"### 思路 \n反向逐位相加\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int add = 0;\n        int sum = 0;\n        for (int i = num.length - 1; i >= 0; --i) {\n            sum = num[i] + k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        while (k > 0) {\n            sum = k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        if (add > 0) {\n            list.add(add);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300684125","body":"### 思路 \n正向、反向遍历，取最小值\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] cs = s.toCharArray();\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, s.length());\n        int last = -s.length();\n        for (int i = 0; i < s.length(); ++i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], i - last);\n        }\n        last = 2 * s.length();\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], last - i);\n        }\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308850243","body":"思路\n分治\n\n代码\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode();\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n\n复杂度\n时间 o(n)\n空间 o(logn)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312754621","body":"代码\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\n    }\n}\n复杂度分析\n令n为二叉树节点数\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320884577","body":"思路\n哈希表 target-num\n\n代码\n class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // 哈希表\n        Map<Integer,Integer> map = new HashMap<>();\n        for(int i = 0;i < nums.length;i++){\n            if(map.containsKey(nums[i])){\n                return new int[]{map.get(nums[i]),i};\n            }\n            map.put(target - nums[i],i);\n        }\n        return new int[]{};\n    }\n}   \n复杂度\n时间：o(n)\n空间：o(n)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326512842","body":"class Solution {\n    public int minSubarray(int[] nums, int p) {\n        // mod for all sum\n        int mod = 0;\n        for (int v: nums) {\n            mod = (mod + v) % p;\n        }\n        if (mod == 0) {\n            return 0;\n        }\n\n        int res = nums.length; // cannot remove the whole array\n\n        Map <Integer, Integer> map = new HashMap < > (); // mod to last idx pos\n        map.put(0, -1);\n\n        int sum = 0, diff = 0;\n        int idx = 0;\n\n        for (int v: nums) {\n            sum = (sum + v) % p;\n            diff = (sum - mod + p) % p;\n            if (map.containsKey(diff)) {\n                res = Math.min(res, idx - map.get(diff));\n            }\n            map.put(sum, idx);\n            idx++;\n        }\n        return res == nums.length ? -1 : res;\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328227780","body":"class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left = 0;\n        int right = nums.length - 1;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target){\n                return mid;\n            }else if(target < nums[mid]){\n                right = mid - 1;\n            }else{\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335247904","body":"class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (int i = 0; i < length; i++) {\n            char move = moves.charAt(i);\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341032082","body":"思路\n二分查找\n\n代码\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, ans = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                ans = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return ans;\n    }\n}\n复杂度\n时间：o(logx)\n空间：o(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345508444","body":"class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(mid):\n            cnt = 0\n            for j, num in enumerate(nums):\n                i = bisect_left(nums, num-mid, 0, j)\n                cnt += j - i\n            return cnt\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350925609","body":"class Solution {\n    private double total=0;\n    private double below=0.0;\n    public double new21Game(int N, int K, int W) {\n\n        count(0 , N, K, W);\n        return below/total;\n    }\n    public void count(int temp , int N , int K , int W){\n        if(temp>=K){\n            total++;\n            if(temp<=N){\n                below++;\n            }\n            return;\n        }else{\n            for(int i=1 ; i<=W ; i++){\n                count(temp+i , N , K , W);\n            }\n        }\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356727813","body":"class Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> res = new ArrayList<>();\n        for (int i = 0; i < 12; i++) {\n            for (int j = 0; j < 60; j++) {\n                if (Integer.bitCount(i) + Integer.bitCount(j) == turnedOn) {\n                    StringBuilder sb = new StringBuilder();\n                    sb.append(i);\n                    sb.append(\":\");\n                    if (j < 10) sb.append(0);\n                    sb.append(j);\n                    res.add(sb.toString());\n                }\n            }\n        }\n        return res;\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362871337","body":"    public int findShortestCircleContainingTarget(List<List<Integer>> graph, int target) {\n        Queue<Integer> queue = new ArrayDeque<>();\n        Set<Integer> seen = new HashSet<>();\n        queue.offer(target);\n\n        int len = 0;\n        while (!queue.isEmpty()) {\n            len++;\n            for (int size = queue.size(); size > 0; size--) {\n                var cur = queue.poll();\n                seen.add(cur);\n\n                for (var next : graph.get(cur)) {\n                    if (!seen.contains(next))\n                        queue.offer(next);\n                    else if (next == target)\n                        return len;\n                }\n            }\n        }\n\n        return -1;\n    }","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365872212","body":"class Solution {\n    public int longestCommonSubsequence(String t1, String t2) {\n        char[] c1 = t1.toCharArray();\n        char[] c2 = t2.toCharArray();\n        int[][] dp = new int[c1.length + 1][c2.length + 1];\n        for(int i = 1; i <= c1.length; ++i){\n            for(int j = 1; j <= c2.length; ++j){\n                \n                if(c1[i - 1] == c2[j - 1]){\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                }else{\n                   \n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[c1.length][c2.length];\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298566621","body":"## 思路\n从右至左逐位计算，并将每一位的计算结果更新至新数组\n\n## 复杂度\n时间复杂度 O(max(数组长度，数字位数))\n\n## 解决方案\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 创建集合保存最后输出结果\n        List<Integer> res = new ArrayList<>();\n        // 遍历计算每一位的值及进位的值，i表示数组指针，sum表示和，carry表示进位\n        int i = num.length - 1, sum = 0, carry = 0;\n        // 循环条件：两个数有一个没计算完\n        while (i >= 0 || k != 0) {\n            // 数组取一个数字\n            int x = i >= 0 ? num[i]: 0;\n            // 整数取一位数字\n            int y = k != 0 ? k % 10 : 0;\n            // 计算两数和\n            sum = x + y + carry;\n            // 进位计算\n            carry = sum / 10;\n            // 整数砍掉个位\n            k = k / 10;\n            // 数组指针右移\n            i--;\n            // 当前位计算结束\n            res.add(0, sum % 10);\n        }\n        // 若有进位，添加至0索引位\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302196513","body":"## 思路\n数组模拟栈，top模拟栈顶\n\n## 代码\n```java\nclass CustomStack {\n    private int[] stack;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int popValue = stack[top];\n        --top;\n        return popValue;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i <limit ; i++) {\n            stack[i] += val;\n\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303713221","body":"## 思路\n模拟栈\n\n## 代码\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304557568","body":"## 思路\n使用一个输入栈一个输出栈模拟队列\n\n## 复杂度分析\npush O(1)\npop O(n)\npeek O(n)\nempty O(1)\n\n## 代码\n```java\nclass MyQueue {\n    // 输入栈\n    private Stack<Integer> a;   // [1, 2, 3]\n    // 输出栈\n    private Stack<Integer> b;   // [3, 2, 1]\n\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n\n    public void push(int x) {\n        a.push(x);\n    }\n\n    public int pop() {\n        // a [1, 2, 3]   -> b [3, 2, 1] -> return b.pop() \n        // a [4] b [3, 2]\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n\n    public int peek() {\n        // 同上\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n\n    public boolean empty() {\n        // a，b其一不为空即可\n        return a.isEmpty()&&b.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305716263","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312482652","body":"```java\nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        # 使用伪头部和伪尾部节点    \n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.capacity = capacity\n        self.size = 0\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # 如果 key 存在，先通过哈希表定位，再移到头部\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            # 如果 key 不存在，创建一个新的节点\n            node = DLinkedNode(key, value)\n            # 添加进哈希表\n            self.cache[key] = node\n            # 添加至双向链表的头部\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                # 如果超出容量，删除双向链表的尾部节点\n                removed = self.removeTail()\n                # 删除哈希表中对应的项\n                self.cache.pop(removed.key)\n                self.size -= 1\n        else:\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n    \n    def addToHead(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317078818","body":"O(N)\n```java\nclass Solution {\n    int curVal = 0;\n    int curHeight = 0;\n\n    public int findBottomLeftValue(TreeNode root) {\n        int curHeight = 0;\n        dfs(root, 0);\n        return curVal;\n    }\n\n    public void dfs(TreeNode root, int height) {\n        if (root == null) {\n            return;\n        }\n        height++;\n        dfs(root.left, height);\n        dfs(root.right, height);\n        if (height > curHeight) {\n            curHeight = height;\n            curVal = root.val;\n        }\n    }\n}\n\n\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321145713","body":"```java\n    public int[] topKFrequent(int[] nums, int k) {\n        int[] res = new int[k];    // 结果数组\n        Map<Integer, Integer> map = new HashMap();\n        // 统计数组中各元素出现的次数\n        for(int num : nums){\n            if(map.containsKey(num)){\n                map.put(num, map.get(num) + 1);\n            }else{\n                map.put(num, 1);\n            }\n        }\n\n        int maxTimes = 0;    // 出现最多的元素的出现次数\n        // 找出出现次数最多的元素出现的次数\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if(entry.getValue() > maxTimes){\n                maxTimes = entry.getValue();\n            }\n        }\n\n        // 按出现次数从大到小添加到结果数组\n        while(k > 0){\n            for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n                if(entry.getValue() == maxTimes){\n                    res[k - 1] = entry.getKey();\n                    k--;\n                }\n            }\n            maxTimes--;\n        }\n\n        return res;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298569137","body":"```\nvar addToArrayForm = function(num, k) {\n    //把k转为数组\n    let numK = [];\n    do{\n            numK.unshift(parseInt(k%10));\n            k /= 10;\n        }while(k>=1);\n    //数组k与数组num从右到左逐位相加\n    let res = [];\n    let sum = 0;\n    let i=num.length-1, j=numK.length-1;\n    for(; i>=0 && j>=0; i--,j--){\n        sum = num[i] + numK[j] + sum;\n        if(sum<10){\n            res.unshift(sum);\n            sum = 0;\n        }\n        else {\n            res.unshift(parseInt(sum%10));\n            sum = 1;\n        }\n    }\n    if(i>=0){\n        for(; i>=0 ; i--){\n            num[i] += sum;\n            if(num[i] <10){\n                res.unshift(num[i]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    else if(j>=0){\n        for(; j>=0 ; j--){\n            numK[j] += sum;\n            if(numK[j] <10){\n                res.unshift(numK[j]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    if(sum === 1) res.unshift(sum);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300557981","body":"```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let length = s.length;\n    let res = new Array(length).fill(0);\n    for(let i=0,idx = -length;i<length; i++){\n        if(s[i] === c) idx = i;\n        res[i] = i - idx;\n    }\n    for(let j=length-1, idx = 2*length; j>=0; j-- ){\n        if(s[j] === c) idx = j;\n        res[j] = Math.min(res[j], idx-j);\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308754527","body":"‘’‘\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nconst sortedListToBST = (head) => {\n    if(head == null) return null;\n    let slow = head;\n    let fast = head;\n    let preSlow ;\n    // 快慢指针\n    while( fast && fast.next ){\n        preSlow = slow;\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    const res = new TreeNode(slow.val);\n    if(preSlow != null){\n        preSlow.next = null;\n        res.left = sortedListToBST(head);\n    }\n    res.right = sortedListToBST(slow.next);\n    return res;\n};\n'''","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317236188","body":"```\nvar findBottomLeftValue = function(root) {\n    let queue = [];\n    if(root===null){\n        return null;\n    }\n    queue.push(root);\n    let resNode;\n    while(queue.length){\n        let length =  queue.length;\n        for(let i=0; i<length; i++){\n            let node = queue.shift();\n            if(i===0){\n                resNode = node.val;\n            }\n            node.left&&queue.push(node.left);\n            node.right&&queue.push(node.right);\n        }\n    }\n    return resNode;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298573753","body":"\r\n### 思路\r\n\r\n本质是模拟加法的过程，用一个循环来实现，循环次数为Max(num1Len,num2Len),\r\n循环里面用下标去找到本次循环要相加的两个数，注意各用一个值标识数组的下标，要加防空，计算出当前位和进位，并更新下一次循环要用到的进位。循环结束后要判断是否需要进位\r\n\r\n#### 模板\r\n\r\n\r\n```JS\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      //根据下标找到,注意防空\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n     // 和 = A 的当前位 + B 的当前位 + 进位carry\r\n      const sum = x + y + carry\r\n      res.push(sum % 10) //当前位\r\n      carry = Math.floor(sum / 10) //进位\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  //判断还有进位吗,进位不为 0 ,加在目标值前面\r\n  if (carry) res.push(carry)\r\n```\r\n\r\n  \r\n### 代码\r\n\r\n```js\r\n var addToArrayForm = function(num1, num2) {\r\n  const res = [],num2Arr=[...num2.toString()].map((i)=>parseInt(i))\r\n  let i1 = num1.length - 1\r\n  let i2 = num2Arr.length - 1\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n\r\n      const sum = x + y + carry\r\n      res.push(sum % 10)\r\n      carry = Math.floor(sum / 10)\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  if (carry) res.push(carry)\r\n  return res.reverse()\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N)\r\n\r\n空间复杂度：O(1) 只保存了常量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300653737","body":"##### 思路\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\n##### 代码\n```js\nvar shortestToChar = function (S, C) {\n  let arr = [],\n    prevC = -Infinity,\n    map = [];\n  //清空暂存栈\n  function clear(prev, next = Infinity) {\n    for (const targetIndex of map) {\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\n      arr.push(Index);\n    }\n    map = [];\n  }\n  for (let index = 0; index < S.length; index++) {\n    const ele = S[index];\n    if (ele === C) {\n      clear(prevC, index);\n      arr.push(0);\n      prevC = index;\n    } else {\n      map.push(index);\n    }\n  }\n  if (map.length > 0) {\n    clear(prevC);\n  }\n  return arr;\n};\n```\n##### 复杂度\n时间复杂度：$O(N)$, N 为S数组长度。\n空间复杂度：$O(N)$, N 为S数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301521004","body":"#### 思路\r\n两种做法:\r\n- 常规遍历\r\n- 运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈\r\n\r\n#### 复杂度\r\n\r\n1. 常规遍历\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2.  辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n\r\n```\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303300530","body":"### 思路\r\n循环 + 栈\r\n- 遇到字母块 (lz)、数字时，入栈；\r\n- 遇到 [ 时，入栈，用来标识当前进入一个模板解析了；\r\n- 遇到 ] 时，说明当前模板遍历完了，我们可以开始解析了。**开始出栈**，把出栈的字母块都拼接起来，等出栈到 [ 时，说明当前模板解析完成了。**继续出栈一个元素，这个元素就是当前模板要重复的次数**，**把\"字母块 * 次数\"后推入栈中**。之所以要推入栈中是因为模板是可以嵌套的，当前模板的外层可以还是一个模板，所以我们要把结果放回去，继续解析外层的模板。\r\n### 代码\r\n```\r\n\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function (s) {\r\n  const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n  const stack = [];\r\n  const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n\r\n  while (reg.lastIndex < s.length) {\r\n      let token = reg.exec(s)[0];\r\n      if (token !== ']') {\r\n          // 数字，字母，左括号通通入栈\r\n          stack.push(token);\r\n      } else {\r\n          // 遇到右括号就开始出栈\r\n          let str = '';\r\n          // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n          while (peek() !== '[') {\r\n              str = stack.pop() + str;\r\n          }\r\n          // 丢掉左括号\r\n          stack.pop();\r\n          // 左括号前面的一定是模式重复的次数\r\n          const num = +stack.pop();\r\n          // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n          stack.push(str.repeat(num));\r\n      }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(S)$，S 是解析后字符串的长度。\r\n空间复杂度：$O(S)$，S 是解析后字符串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304537012","body":"\n\n#### 思路\ninStack: 写栈，入队列时存储数据于此\n\noutStack：出栈，需要出队列时将inStack的数据依次出栈后入栈到此；出栈的尾部就是入栈的头部，因而出队列就是出栈的尾部，直接pop\n\n**注意:**: 栈2为空才能补充栈1的数据，否则会打乱当前的顺序。\n\n#### 复杂度\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\n时间复杂度：O(N)，其中 N 为 栈中元素个数，因为每次我们都要倒腾一 次。\n\n\n空间复杂度：O(N)，其中 N 为 栈中元素个数，多使用了一个辅助栈，这 个辅助栈的大小和原栈的大小一样。\n\n\n\n#### 代码\n```js\nvar MyQueue = function () {\n    this.inStack = [];\n    this.outStack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack[this.outStack.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\nreturn this.outStack.length===0 && this.inStack.length===0\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304806767","body":"### 768 最多能完成的排序块\r\n\r\n#### 思路\r\n\r\n后面块中的最小值一定大于前面块的最大值,这样才能保证分块有（即局部递减，整体递增）。因此直观上，我们又会觉得是不是”只要后面有较小值，那么前面大于它的都应该在一个块里面“，实际上的确如此。 因而这里，栈只需要保存该块中最大值就可以了。（将一个减序列压缩合并成最该序列的最大的值）\r\n\r\n#### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n\r\n  const stack=[];\r\n  for (const ele of arr) {\r\n    const cur=stack[stack.length-1]\r\n    if(stack.length>0 &&  cur>ele){\r\n      while(stack.length>0 && stack[stack.length-1] > ele){\r\n        stack.pop();\r\n      }\r\n      stack.push(cur)\r\n    }else{\r\n      stack.push(ele)\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n\r\n\r\n\r\n#### 复杂度\r\n\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305786315","body":"#### 思路\n快指针比慢指针先走K步，当快指针到达终点时，慢指针正好是倒数第 k 个节点\n\n需要先求出链表的长度，再取余得到K\n\n一开始是想循环K遍(链表遍历结束就再从头遍历，但当K足够大时，遍历的次数可能超过2次，以及求倒数K个节点循环终止条件是遍历到链表尾部，此时K为负数，这里遍历过一遍后K可能为正数，需要修改终止条件)\n\n#### 代码\n```js\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0,\n    now = head;\n  while (now) {\n    now = now.next;\n    count++;\n  }\n  k = k % count;\n  let slow = (fast = head);\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res;\n};\n\n```\n\n#### 复杂度分析\n\n时间复杂度：节点最多只遍历两遍，时间复杂度为O(n)\n空间复杂度：未使用额外的空间，空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307079233","body":"##### 思路\n\n由于所有的两两交换逻辑都是一样的，因此我们**只要关注某一个两两交换**如何实现就可以了。\n\n因为要修改的是二个一组的链表节点，所以需要**操作 4 个节点**。例如：**将链表 A -> B 进行逆转，我们需要得到 A,B 以及 A 的前置节点 preA,以及 B 的后置节点 nextB**\n\n原始链表为 **preA -> A -> B -> nextB**，我们需要改为 **preA -> B -> A -> nextB**，接下来用同样的逻辑交换 nextB 以及 nextB 的下一个元素。\n\n这里的preA节点是我们创建一个空节点 preHead，让其 next 指针指向 A\n\n修改指针的顺序：\n\n1. A 节点的 next 指向 nextB:  \n\n   > 注意：不用更新nextB的指向，而是更新指向它的指针)\n\n2. B 节点的 next 指向 A\n\n3. preA 节点的 next 指向 B \n\n4. 修改preA节点和A节点，进入下一次循环\n\n##### 代码\n\n```\n/*\n * @lc app=leetcode.cn id=24 lang=javascript\n *\n * [24] 两两交换链表中的节点\n */\nfunction ListNode(val, next) {\n       this.val = (val===undefined ? 0 : val)\n      this.next = (next===undefined ? null : next)\n   }\n\n   function arrayToNodeList(list) {\n    let header = new ListNode(0)\n    let Arent = header\n    for (let i = 0; i < list.length; i++) {\n      Arent.next = { val: list[i], next: null }\n      Arent = Arent.next\n    }\n    return header.next\n  }\n  function nodeListToArray(node) {\n    const list = []\n    let header = node\n    while (header) {\n      list.push(header.val)\n      header = header.next\n    }\n    return list\n  }\n  \n\n// @lc code=start\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {ListNode}\n */\nvar swapPairs = function(head) {\n     if(!head||!head.next) return head\n     let A=head,res=head.next;\n     let prevA = new ListNode();\n      prevA.next = head;\n\n     while(A && A.next){\n      const B = A.next,nextB=B.next;\n      A.next=nextB\n      B.next=A\n      prevA.next=B\n      prevA=A\n      A=A.next\n     }\n     return res\n};\n// @lc code=end\n\nswapPairs(arrayToNodeList([1,2,3,4]))\n```\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作.\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308970652","body":"#### 思路\n- 快慢指针找到中间节点+递归+构建树结构。 \n- 链表中间节点就是根节点，根节点的左节点就是链表左边一段的中间节点\n\n#### 代码\n```js\nvar sortedListToBST = function (head) {\n  if (!head) return null;\n  return dfs(head, null);\n};\n\nfunction dfs(head, tail) {\n  if (head == tail) return null;\n  let fast = head;\n  let slow = head;\n  while (fast != tail && fast.next != tail) {\n    fast = fast.next.next;\n    slow = slow.next;\n  }\n  let root = new TreeNode(slow.val);\n  root.left = dfs(head, slow);\n  root.right = dfs(slow.next, tail);\n  return root;\n}\n```\n#### 复杂度分析\n\n令 n 为链表长度。\n\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\n\n空间复杂度：空间复杂度为O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310337400","body":"#### 思路\n哈希法:(摘自讲义)\n有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。\n遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\n\n#### 代码\n\n```\nvar getIntersectionNode = function(A, B) {\nlet data = new Set();\nwhile (A !== null) {\n  data.add(A);\n  A = A.next;\n}\nwhile (B !== null) {\n  if (data.has(B)) return B;\n  B = B.next;\n}\nreturn null;\n};\n```\n\n#### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311295223","body":"#### 双指针\n\n具体算法：\n\n定义一个 fast 指针,每次前进两步,一个 slow 指针,每次前进一步\n\n当两个指针相遇时(注意相遇不一定就相遇在环入口)，将 fast 指针重定位到链表头部,同时 fast 指针每次只前进一步，slow 指针继续前进,每次前进一步\n\n当两个指针再次相遇时,当前节点就是环的入口\n\n\n##### 代码\n```js\nif (head == null || head.next == null) return null;\nlet fast = (slow = head);\ndo {\n  if (fast != null && fast.next != null) {\n    fast = fast.next.next;\n  } else {\n    fast = null;\n  }\n  slow = slow.next;\n} while (fast != slow);\nif (fast == null) return null;\nfast = head;\nwhile (fast != slow) {\n  fast = fast.next;\n  slow = slow.next;\n}\nreturn fast;\n\n```\n##### 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312509277","body":"**思路**\n\n哈希表+双向链表\n\n题目要求操作的复杂度都是O(1)，链表本身插入和删除都能做到，但查找不行，因而需要结合哈希表来记录每个 key 对应的链表节点引用 ( 空间复杂度增加到了 O(N) )。另外，由于**移除链表节点后还需要把该节点前后的两个节点连起来**,所以这里需要用双向链表\n\n**代码**\n\n```js\nclass DoubleLinkedListNode {\n    constructor(key, value) {\n        this.key = key\n        this.value = value\n        this.prev = null\n        this.next = null\n    }\n}\n\nclass LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity\n        this.usedSpace = 0\n        // Mappings of key->node.\n        this.hashmap = {}\n        this.dummyHead = new DoubleLinkedListNode(null, null)\n        this.dummyTail = new DoubleLinkedListNode(null, null)\n        this.dummyHead.next = this.dummyTail\n        this.dummyTail.prev = this.dummyHead\n    }\n\n    _isFull() {\n        return this.usedSpace === this.capacity\n    }\n\n    _removeNode(node) {\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        node.prev = null\n        node.next = null\n        return node\n    }\n\n    _addToHead(node) {\n        const head = this.dummyHead.next\n        node.next = head\n        head.prev = node\n        node.prev = this.dummyHead\n        this.dummyHead.next = node\n    }\n\n    get(key) {\n        if (key in this.hashmap) {\n            const node = this.hashmap[key]\n            this._addToHead(this._removeNode(node))\n            return node.value\n        }\n        else {\n            return -1\n        }\n    }\n\n    put(key, value) {\n        if (key in this.hashmap) {\n            // If key exists, update the corresponding node and move it to the head.\n            const node = this.hashmap[key]\n            node.value = value\n            this._addToHead(this._removeNode(node))\n        }\n        else {\n        // If it's a new key.\n            if (this._isFull()) {\n                // If the cache is full, remove the tail node.\n                const node = this.dummyTail.prev\n                delete this.hashmap[node.key]\n                this._removeNode(node)\n                this.usedSpace--\n            }\n            // Create a new node and add it to the head.\n            const node = new DoubleLinkedListNode(key, value)\n            this.hashmap[key] = node\n            this._addToHead(node)\n            this.usedSpace++\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：各种操作平均都是 O(1)。\n- 空间复杂度：链表占用空间 O(N)，哈希表占用空间也是 O(N)，因此总的空间复杂度为 O(N)，其中 N 为容量大小，也就是题目中的 capacity。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312629335","body":"#### 思路\n  用层次遍历bfs+变量i记录遍历的深度\n\n#### 代码\n```js\nvar maxDepth = function (root) {\n  if(!root) return 0;\n  let quene = []\n  quene.push(root)\n  let i = 0\n  while (quene.length) {\n      let curLevel = quene\n      quene = [];\n      i++;\n      for (let i = 0; i < curLevel.length; i++) {\n          if (curLevel[i].left) {\n              quene.push(curLevel[i].left)\n          }\n          if (curLevel[i].right) {\n              quene.push(curLevel[i].right)\n          }\n      }\n  }\n return i;\n};\n```\n#### 复杂度\n时间复杂度：O(N)，其中 N 为节点数。\n\n空间复杂度：O(h)，其中 h 为树的深度，最坏的情况 h 等于 N，其中 N 为节点数，此时树退化到链表。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313757656","body":"#### 思路\n\n判断两棵树是否相同，只需要判断树相同位置的元素值是否相同。可以借助队列实现**层次遍历**，每次拿到两个节点时比较，注意当两个节点都为null时不能返回true( 因为还不一定),只能暂停这次循环，进行下一次。 如果不一致，直接返回 false。如果访问完都没有发现不一致就返回 true。\n\n#### 代码\n\n```js\nfunction isSameTree(p, q) {\n  let queueA = [];\n  queueA.push(p);\n  queueA.push(q);\n  while (queueA.length) {\n    const p = queueA.shift(),\n      q = queueA.shift();\n    if (p == null && q == null) {\n      continue;\n    }\n    if (p == null || q == null || p.val != q.val) {\n      return false;\n    }\n    queueA.push(p.left);\n    queueA.push(q.left);\n\n    queueA.push(p.right);\n    queueA.push(q.right);\n  }\n  return true;\n}\n```\n\n**复杂度**\n\n时间复杂度：O(N)，其中 N 为树的节点数。\n空间复杂度：O(Q)，其中 Q 为队列的长度最大值，在这里不会超过相邻两层的节点数的最大值。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315478613","body":"#### 深度优先递归DFS\n**思路**\n\n- 题目求的是根到叶子节点的值，所以只要在叶子节点这一层把每条路径的值按倍数加起来并求和就行。\n- 代码什么时候会跑到叶子节点呢？节点没有左子树和右子树的时候。\n- 这里还需要注意函数参数root可能是null,要判空\n\n**代码**\n```JS\nvar sumNumbers = function(root) {\n    return sumHelper(root, 0)\n};\n\nfunction sumHelper(root, sum){\n    if (!root) return 0;\n    const total = sum * 10 + root.val;\n    if (!root.left && !root.right) {\n        return total;\n    } else {\n        return sumHelper(root.left, total) + sumHelper(root.right, total);\n    }\n}\n\n\n```\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n#### BFS\n\n\n**思路**\n\n- 跟DFS思路一致，等到遍历到叶子节点的时候再把对应值加起来，不同的是这里把中间每一层对应的值都求出来\n\n**代码**\n```JS\nfunction sumNumbers(root) {\n  let sum = 0;\n  let curLevel = [];\n  if (root) {\n    curLevel.push(root);\n  }\n  while (curLevel.length) {\n    let nextLevel = [];\n    for (let i = 0; i < curLevel.length; i++) {\n      let cur = curLevel[i];\n      if (cur.left) {\n        cur.left.val = cur.val * 10 + cur.left.val;\n        nextLevel.push(cur.left);\n      }\n      if (cur.right) {\n        cur.right.val = cur.val * 10 + cur.right.val;\n        nextLevel.push(cur.right);\n      }\n      if (!cur.left && !cur.right) {\n        sum += cur.val;\n      }\n      curLevel = nextLevel;\n    }\n  }\n  return sum;\n}\n\n```\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317160733","body":"#### BFS\r\n\r\n**思路**\r\n\r\n- 只要记录每层最左边的节点值，遍历结束拿到的就是最后一层。\r\n\r\n- 这里有个知识点是内循环一次就是遍历一层节点，外循环的次数取决于树的层数，所以记录都是在每次内循环结束后操作。\r\n\r\n  \r\n\r\n  **代码**\r\n\r\n```\r\nvar findBottomLeftValue = function (root) {\r\n  let curLevel = [root];\r\n  let res = root.val;\r\n  while (curLevel.length) {\r\n    let nextLevel = [];\r\n    for (let i = 0; i < curLevel.length; i++) {\r\n      curLevel[i].left && nextLevel.push(curLevel[i].left);\r\n      curLevel[i].right && nextLevel.push(curLevel[i].right);\r\n    }\r\n    res = curLevel[0].val;\r\n    curLevel = nextLevel;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为树的节点数。\r\n- 空间复杂度：O(Q)，其中 Q 为队列长度，最坏的情况是满二叉树，此时和 N 同阶，其中 N 为树的节点总数\r\n\r\n#### DFS\r\n\r\n**思路**\r\n\r\n- 递归方法需要一个参数表示当前遍历到的层级以及一个变量记录当前最深的层级的值\r\n- 如何保证是左下角，而不是右下角呢，这里是利用遍历的方法都是先遍历左结点而后右节点来保证的。所以前中后序遍历都可以。\r\n\r\n```\r\n function findBottomLeftValue(root) {\r\n  let res = root.val, maxDepth = 0;\r\n  order(root.left,1)\r\n  order(root.right,1)\r\n  return res\r\n  function order(root, depth) {\r\n      if (!root) return;\r\n      if (depth > maxDepth) {\r\n          maxDepth=depth;\r\n          res = root.val;\r\n      }\r\n      order(root.left, depth + 1)\r\n      order(root.right, depth + 1)\r\n  }\r\n\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为树的节点总数。\r\n- 空间复杂度：O(h)，其中 h 为树的高度。\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318816048","body":"\n**思路**\n\nBFS\n\n**代码**\n```JS\nconst serialize = (root) => {\n  const queue = [root];\n  let res = [];\n  while (queue.length) {\n    const node = queue.shift();\n    if (node) {\n      res.push(node.val);\n      queue.push(node.left);\n      queue.push(node.right);\n    } else {\n      res.push(\"#\");\n    }\n  }\n  return res.join(\",\");\n};\n\nconst deserialize = (data) => {\n  if (data == \"#\") return null;\n\n  const list = data.split(\",\");\n\n  const root = new TreeNode(list[0]);\n  const queue = [root];\n  let cursor = 1;\n\n  while (cursor < list.length) {\n    const node = queue.shift();\n\n    const leftVal = list[cursor];\n    const rightVal = list[cursor + 1];\n\n    if (leftVal != \"#\") {\n      const leftNode = new TreeNode(leftVal);\n      node.left = leftNode;\n      queue.push(leftNode);\n    }\n    if (rightVal != \"#\") {\n      const rightNode = new TreeNode(rightVal);\n      node.right = rightNode;\n      queue.push(rightNode);\n    }\n    cursor += 2;\n  }\n  return root;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为树的节点数。\n\n- 空间复杂度：O(Q)，其中 Q 为队列长度，最坏的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320160931","body":"**思路**\n  先存着，再根据y,x，val做排序\n**代码**\n```js\n var verticalTraversal = function (root) {\n  const res = new Map([[0, [[root.val]]]])\n  proder(root.left, 1, -1)\n  proder(root.right, 1, 1)\n\n  function proder(node, row, col) {\n    if(!node) return;\n      const arr = res.get(col) || []\n      arr[row] = [...(arr[row] || []), node.val]\n      res.set(col, arr)\n      node.left && proder(node.left, row + 1, col - 1)\n      node.right && proder(node.right, row + 1, col + 1)\n  }\n  const newLocal = [...res].sort(([a], [b]) => (a - b));\n  const result = newLocal.reduce(function (total, [cur, arr]) {\n      const items = arr.map(item => item.sort((a, b) => a - b)).flat()\n      total.push(items)\n      return total;\n  }, [])\n  return result;\n};\n```\n**复杂度**\n- 时间复杂度：O(NlogN)，其中 N 为树的节点总数。\n- 空间复杂度：O(N)，其中 N 为树的节点总数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320791332","body":"### 思路\n用哈希表记录已经出现过的元素，遍历循环时判断 target - num 是否也存在 哈希表中\n### 代码\n```js\nvar twoSum = function(nums, target) {\n  const hash=new Map()\nfor (const i in nums) {\n  const jian=target-nums[i]\n  if(hash.has(jian)){\n    return [hash.get(jian),i]\n  }\n  hash.set(nums[i],i)\n}\n};\n```\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321087052","body":"#### 快速选择\r\n**思路**\r\n\r\n>基本流程如下：\r\n>\r\n>1. 首先选定一个轴心值 `p`。\r\n>2. 将数组中小于 `p` 的值移到数组左端，其他移动到数组右端。\r\n>3. 计算轴心左端的数 (包括轴心自己) 有多少，记为 `count`\r\n>4. 如果 `count` 正好为 `k`，则返回此时轴心值，此值即为第 `k` 小的数。\r\n>5. 如果左端的数 `count` 大于 `k`，说明在左端，所以只递归左边即可。\r\n>6. 如果不在左端，只递归在右边寻找。\r\n\r\n**代码**\r\n\r\n```js\r\n//\r\nvar topKFrequent = function (nums, k) {\r\n  const counts = {};\r\n  for (let num of nums) {\r\n    counts[num] = (counts[num] || 0) + 1;\r\n  }\r\n  // 【次数，值】\r\n  let pairs = Object.keys(counts).map((key) => [counts[key], key]);\r\n\r\n  select(0, pairs.length - 1, k);\r\n  return pairs.slice(0, k).map((item) => item[1]);\r\n\r\n  // 快速选择\r\n  function select(left, right, offset) {\r\n    if (left >= right) {\r\n      return;\r\n    }\r\n    const pivotIndex = partition(left, right);\r\n    if (pivotIndex === offset) {\r\n      return;\r\n    }\r\n\r\n    if (pivotIndex <= offset) {\r\n      select(pivotIndex + 1, right, offset);\r\n    } else {\r\n      select(left, pivotIndex - 1,offset);\r\n    }\r\n  }\r\n\r\n  // 拆分数组为两个part\r\n  function partition(left, right) {\r\n    const [pivot] = pairs[right];\r\n    let cur = left;\r\n    let leftPartIndex = left;\r\n    while (cur < right) {\r\n      if (pairs[cur][0] > pivot) {\r\n        swap(leftPartIndex++, cur);\r\n      }\r\n      cur++;\r\n    }\r\n    swap(right, leftPartIndex);\r\n    return leftPartIndex;\r\n  }\r\n\r\n  function swap(x, y) {\r\n    const term = pairs[x];\r\n    pairs[x] = pairs[y];\r\n    pairs[y] = term;\r\n  }\r\n};\r\n```\r\n\r\n**复杂度**\r\n\r\n- 时间复杂度: O(N), 最坏能到 O(N^2)\r\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321292094","body":"### 思路\n\n哈希表可以用于优化暴力算法。\n\n- **使用哈希表预处理点信息**：第一层循环固定取一个点，并且找出所有和点 A 距离相同的点（统计频率的套路，将距离作为哈希表的key值，相同加一）。\n\n- **n 个数取两个数的全排列种类是 {A}_n^2，也就是 n*(n-1)**。比如找到了 n 个距离为 3 的点，那么我们选择第二个点有 n 种方案，选择第三个点有(n - 1)个方案。那么固定点 A 且距离为 3 的所有可能就是 n*(n-1)种，\n\n\n\n\n### 代码\n\n```\nfunction numberOfBoomerangs(points) {\n    let ans = 0\n    for (let i = 0; i < points.length; i++) {\n        let map = {}\n        for (let j = 0; j < points.length; j++) {\n            let instance = getTance(points[i], points[j])\n            map[instance] =  map[instance] ? ++map[instance] : 1\n        }\n        for (const key in map) {\n            ans += map[key] * (map[key] - 1)\n        }\n    }\n    return ans\n}\n// 求距离，可以不用开平方根\nvar getTance = function (point1, point2) {\n    return Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2)\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N^2)，其中 N 为数组长度。\n\n- 空间复杂度：O(N)\n\n  \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323556372","body":"\r\n思路：滑动窗口+哈希表\r\n\r\n- 维护一个滑动窗口，当窗口中的字符不重复时，继续向右扩大窗口。\r\n- 当遇到重复字符 `d` 时，将窗口左侧收缩到 `d` 字符上次出现的位置 + 1（将起始位置**右移至重复字符的后一个位置**）。\r\n- 为了快速找到字符上次出现的位置，我们可以用一个哈希表来记录每个字符最新出现的位置。\r\n- 在滑动窗口遍历数组的过程中用一个变量记录窗口的最大长度。\r\n\r\n**代码**\r\n\r\n```js\r\n let lengthOfLongestSubstring = function (s) {\r\n  if (!s) return 0;\r\n  let l = 0,\r\n    max = 0;\r\n  const map = new Map();\r\n  for (let i = 0; i < s.length; i++) {\r\n    const index = map.get(s[i]);\r\n    // 如果 s[i] 曾在 [l, r] 滑动窗口中出现\r\n    // 就收缩滑动窗口左侧，把 l 指针移动到 s[i] 上次出现的位置 + 1\r\n    if (index >= l) l = index + 1;\r\n    // 更新 s[r] 出现的位置\r\n    map.set(s[i], i);\r\n    // 计算滑动窗口大小\r\n    max = Math.max(max, i - l + 1);\r\n  }\r\n  return max;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度: O(n)，n为字符串长度\r\n- 空间复杂度：O(s)，s为字符集元素个数\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324932028","body":"**思路**\r\n\r\n- 题目给的words是可以有重复项的，所以要用哈希表map1记录每项出现的次数。\r\n- 遍历s,取出子串为words.length*words[0].length(目标子串的长度),按words[0].length长度切割，用map2记录单词出现的次数，一旦次数超过map1或者单词并不存在map1中时，说明这次遍历的子串不满足条件，提前break;\r\n- 没有提前break的子串就是符合条件的，怎么获取这部分呢？可以通过判断for循环的变量是否等于循环的次数。\r\n**代码**\r\n```js\r\nvar findSubstring = function (s, words) {\r\n  const res = [], wordsLen = words[0].length, resLen = wordsLen * words.length;\r\n  let map = words.reduce((totalMap, cur) => {\r\n      totalMap.set(cur, (totalMap.get(cur) || 0) + 1)\r\n      return totalMap\r\n  }, new Map())\r\n  let r = 0;\r\n  while (r < s.length - resLen + 1) {\r\n      let mapT = new Map()\r\n      const curTotalStr = s.slice(r, r + resLen)\r\n      let i = 0\r\n      for (; i < resLen; i += wordsLen) {\r\n          const curStr = curTotalStr.slice(i, i + wordsLen)\r\n          if (!map.has(curStr)) break;\r\n          mapT.set(curStr, (mapT.get(curStr) || 0) + 1)\r\n          if (map.get(curStr) < mapT.get(curStr)) break;\r\n      }\r\n      if (i == resLen) {\r\n          res.push(r)\r\n      }\r\n      r += 1\r\n  }\r\n  return res\r\n};\r\n```\r\n**复杂度**\r\n\r\n令 n 为字符串 S 长度, m 为 words 数组元素个数, k 为单个 word 字串长度。\r\n\r\n时间复杂度：O(m+w×n)\r\n空间复杂度： O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326610078","body":"\n**先导知识**\n\n> -  看到连续子数组就可以考虑用前缀和进行优化。\n>    前缀和: 子数组 A[i:j] 的和就是 pres[j] - pres[i-1]，其中 pres 为 A 的前缀和。\n> -  看到被 x 整除，求余数等问题都可以尝试考虑是否可以使用数学中的同余定理\n>    同余定理: 两个模 k 余数相同的数字相减，得到的值定可以被 k 整除。\n\n**思路**：\n\n- 以先计算出总体的数组和 total 模 k 的余数，记为 target，那么我们的目标就是找到一段模 k 等于 target 的子数组。\n\n- 连续子数组相加的值又会等于两个子数组前缀和相减。于是目标转为求\n(pres[j] - pres[i-1])% K = target，根据公式可推导出 (pres[j]-target)%K =pres[i-1]%K\n\n- 可以将前缀和模 k 的余数 x 放到哈希表中，这个哈希表就充当了前缀和的角色，来记录最新的余数 x 对应的下标，随着循环遍历，最新的下标对应的前缀和数组越长，连续子数组越短，所以需要哈希记录最新下标\n\n**代码**\n\n```js\n// 注：-1 % 4 为-1，而我们期望为 3，为了解决正负数求余统一，采用 Math.floorMod，等同于先+4 再模 4\nvar floorMod = function (a, b) {\n  return ((a % b) + b) % b;\n};\n\nvar subarraysDivByK = function(nums, k) {\n  var map = new Map();\n  map.set(0, -1);\n  var res = nums.length;\n  var target = 0;\n  var currSum = 0;\n  for (let i = 0; i < nums.length; i++) {\n    target += nums[i];\n  }\n  target = target % k;\n\n  for (let i = 0; i < nums.length; i++) {\n    currSum = (nums[i] + currSum) % k;\n    map.set(currSum, i);\n    var prevSum = floorMod(currSum - target, k);\n    if (map.has(prevSum)) {\n      res = Math.min(res, i - )map.get(prevSum);\n    }\n  }\n  return res === nums.length ? -1 : res;\n};\n```\n**复杂度**\n时间：O(N)\n空间：O(min(K,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327343442","body":"### 思路\n\n快指针每次最两步，慢指针每次走一步，这样当快指针走到链表尾部的时候， 慢指针刚好到达链表中间位置。\n\n- 关于快慢节点求中点，如果以 head 为起点，则最后 slow 是在后面那个中间节点\n- **如果以 head 的前一个节点为起点，那么 slow 就会在前面的中间节点**\n\n### 代码\n\n```\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\n\nvar middleNode = function(head) {\n    let slow = head, fast = head;\n    while(fast && fast.next){\n        fast = fast.next.next\n        slow = slow.next\n    }\n    return slow\n};\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为链表长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328044893","body":"**思路**\n\n读写指针，需要注意写的时机：即读指针跟当前写指针指向的下标前一个值不相同时\n\n**代码**\n\n```js\n var removeDuplicates = function(nums) {\n  let slow=1;\n  for (let fast = 1; fast < nums.length; fast++) {\n   if(nums[slow-1]!==nums[fast]) \n    {\n      nums[slow]=nums[fast]\n      slow++;\n    }\n  }\n  nums=nums.slice(0,slow)\nreturn nums.length\n};\n```\n\n**思路**\n\n - 时间复杂度：O(N)\n - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328247157","body":"**思路**\n\n寻找最左插入位置=寻找最右满足小于 x 的位置 + 1=找到满足值时收缩右边界\n\n**代码**\n\n```js\n  var searchLeft = function (nums, target) {\n    let l = 0, r = nums.length - 1;\n    while (l <= r) {\n        mid = Math.floor((l + r) / 2)\n        if (target <= nums[mid]) r = mid - 1 //收缩右边界\n        else l = mid + 1\n    }\n    return l\n};\n```\n\n复杂度\n\n- 时间复杂度：O(logN)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329298997","body":"**思路**\n\n#### 双端队列\n\n用一个双端队列来保存`接下来的滑动窗口可能成为最大值的数`\n\n\n\n具体做法：\n\n- 入队列\n- 移除失效元素，失效元素有两种\n\n1. 一种是已经超出窗口范围了，比如我遍历到第 4 个元素，k = 3，那么 i = 0 的元素就不应该出现在双端队列中了。具体就是`索引大于 i - k + 1的元素都应该被清除`\n2. 小于当前元素都没有利用价值了，具体就是`从后往前遍历（双端队列是一个递减队列）双端队列，如果小于当前元素就出队列`\n\n经过上面的分析，不难知道双端队列其实是一个递减的一个队列，因此队首的元素一定是最大的。\n\n```js\nvar maxSlidingWindow = function (nums, k) {\n  const res = [];\n  const dequeue = new Dequeue([]);\n  // 前 k - 1 个数入队\n  for (let i = 0; i < k - 1; i++) {\n    dequeue.push(nums[i]);\n  }\n\n  // 滑动窗口\n  for (let i = k - 1; i < nums.length; i++) {\n    dequeue.push(nums[i]);\n    res.push(dequeue.max());\n    dequeue.shift(nums[i - k + 1]);\n  }\n  return res;\n};\n\nclass Dequeue {\n  constructor(nums) {\n    this.list = nums;\n  }\n\n  push(val) {\n    const nums = this.list;\n    // 保证数据从队头到队尾递减\n    while (nums[nums.length - 1] < val) {\n      nums.pop();\n    }\n    nums.push(val);\n  }\n\n  // 队头出队\n  shift(val) {\n    let nums = this.list;\n    if (nums[0] === val) {\n      // 这里的js实现shift()理论上复杂度应该是O(k), 就不去真实实现一个O(1)出队的队列了，意思到位即可\n      nums.shift();\n    }\n  }\n\n  max() {\n    return this.list[0];\n  }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330601195","body":"https://leetcode-cn.com/problems/find-the-town-judge/solution/yi-ge-shu-zu-gao-ding-tong-su-yi-dong-997-zhao-dao/\n\n### 思路\n\n有向图问题。 法官👩‍⚖️ 实际上就是出度为0，入度为 N - 1的节点。\n\n- 统计所有人的入度和出度信息(两个数组分别记录)，将满足出度为0，入度为 N - 1的节点输出。\n- 一种是直接用一个数组记录入度和出度的差值\n\n### 代码\n\n\n```js\n// 一个数组\nvar findJudge = function (n, trust) {\n    if (n === 1 && !trust.length) return 1\n    const arr = new Array(n + 1).fill(0)\n    for (const point of trust) {\n        const [i, j] = point\n        arr[i] -= 1\n        arr[j] += 1\n    }\n    for (const i in arr) {\n        if (arr[i] === n - 1)\n            return i\n    }\n    return -1\n};\n\n// 两个数组\nvar findJudge = function (n, trust) {\n  const count = new Array(n + 1).fill(0);\n  for (const edge of trust) {\n    const x = edge[0];\n    const y = edge[1];\n    count[y]++;\n    count[x]--;\n  }\n  for (let i = 1; i <= n; ++i) {\n    if (count[i] === n - 1) {\n      return i;\n    }\n  }\n  return -1\n}\n```\n\n##### \n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332218881","body":"\n\nhttps://leetcode-cn.com/problems/possible-bipartition/\n\n## 关键点\n\n- 二分图\n- 染色法\n- 图的建立和遍历\n\n\n\n**思路**\n\n- 用邻接矩阵表示人物的喜欢关系， 不喜欢的两人坐标点都标记为1.即(a,b)和(b,a)\n- 用数组存储分组情况，值为0代表未分组，-1和1分别代表两个组。\n- **整个判断过程其实就是递归假设**：开始分组时，先假设将a分到1组，再遍历a不喜欢的人，看其是否能分到-1组（这个判断过程也是先假设人已分到-1组，不喜欢的人能否分到1组）\n- 若有人不满足假设过程，则跳出循环，返回false.\n\n```js\n const possibleBipartition = (N, dislikes) => {\n  let graph = [...Array(N)].map(() => Array()), // 动态创建二维数组\n    colors = Array(N + 1).fill(0);\n\n  // build the undirected graph\n  for (const [a, b] of dislikes) {\n    graph[a - 1][b - 1] = 1\n    graph[b - 1][a - 1] = 1\n  }\n\n  const dfs = (cur, color = 0) => {\n    colors[cur] = color;\n  for (let i = 0; i < N; i++) {\n    if(graph[cur][i]==1){\n      // 不喜欢的人在同个组，不符合题意，返回false\n       if(colors[i]==color) return false;\n      //不喜欢的人还未分组，但不能分到相反组，返回false\n       if(colors[i]===0 && !dfs(i, color*-1) ) return false\n  } \n}\n    return true;\n  };\n\n\n  for (let i = 0; i < N; ++i) if (colors[i] === 0 && !dfs(i, 1)) return false;\n\n  return true;\n};\n```\n\n- 时间复杂度：O(N2)\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334814018","body":"**思路**\nso easy\n**代码**\n```js\nvar judgeCircle = function (moves) {\n  let p = [0, 0];\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i] === \"U\") p[0] += 1;\n    if (moves[i] === \"D\") p[0] -= 1;\n    if (moves[i] === \"L\") p[1] -= 1;\n    if (moves[i] === \"R\") p[1] += 1;\n  }\n  return p[0] === 0 && p[1] === 0;\n};\n```\n**复杂度**\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336186758","body":"先打个卡\n```js\nclass MyMaxPriorityQueue {\n  constructor(a) {\n      this.q = []\n      a && this._build(a)\n  }\n  add(v, second) { // 添加\n      this.q.push({v, second}) // 添加 值（比较用） 和 第二参数（索引）\n      this._up(this.q.length - 1) // 放入 二叉树的尾部，然后 上浮\n  }\n  shift() { // 弹出\n      var n = this.q.shift() // 弹出 根节点\n      if (this.q.length) { // 如果还有节点\n          this.q.unshift(this.q.pop()) // 将 最尾部的节点 放到根节点位置\n          this._down(0) // 下沉 根节点\n      }\n      return n\n  }\n  first() { // 根节点\n      return this.q[0]\n  }\n  length() { // 优先队列长度\n      return this.q.length\n  }\n  _build(a) { // 初始化\n      this.q.push({v:a[0]}) // 先给空队列放入第0个元素\n      for (var i = 1; i < a.length; i++) this.q.unshift({v:a[i]}), this._down(0)\n      // 从第1个元素起，把新元素放在根节点，然后下沉 根节点\n  }\n  _swap(l, r, t) { // 交换\n      t = this.q[l], this.q[l] = this.q[r], this.q[r] = t // 交换两个节点\n  }\n  _down(i){ // 下沉\n      var t = this.q.length - 2 >> 1, max, maxI // 叶子节点的根节点索引，下沉到 叶子节点的根节点停止\n      while(i <= t){\n          var l = i * 2 + 1, r = l + 1 // 左子节点的索引 = 当前节点索引 * 2 + 1，右子节点的索引 = 左子节点的索引 + 1\n          if ((this.q[l] ? this.q[l].v : -Infinity) >= (this.q[r] ? this.q[r].v : -Infinity))\n               max = this.q[l].v, maxI = l\n          else max = this.q[r].v, maxI = r // 找到 左子节点 和 右子节点的 较大者\n          if (this.q[i].v < max) this._swap(i, maxI), i = maxI // 当前节点的 左子节点 或 右子节点 比 它大，交换 \n          else break\n      }\n  }\n  _up(i) { // 上浮\n      while(i > 0){ // 不能超过根节点\n          var t = i - 1 >> 1 // 当前节点的 根节点索引 = 当前节点索引 - 1 的一半\n          if (this.q[i].v >= this.q[t].v) this._swap(i, t), i = t // 当前节点值 比 它的根节点 大，交换\n          else break\n      }\n  }\n}\n\n/**\n * @param {number[][]} tasks\n * @return {number[]}\n */\nvar getOrder = function(tasks) {\n  let time=0,cpuNextTime=1,index=0;\n  const quene=new MyMaxPriorityQueue(),res=[]\n   while(tasks.length>0){\n    time++;\n    console.log(tasks[0],'tasks');\n    while(tasks.length>0 && tasks[0][0]===time){\n    const [t,second] =  tasks.shift()||[]\n      quene.add(second,index++)\n    }\n    if(time===cpuNextTime){\n     const {v, second}= quene.shift()\n      cpuNextTime+=v;\n      res.push(second)\n    }\n   }\n   return res;\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336322679","body":"**思路**\r\n\r\n- 时间数值字符串该怎么对比呢？比对总的分钟数=60*h+m\r\n- 去头去尾：分别将开始时间和结束时间规范到标准时间：开始时间取下一个标准时间，结束时间取前一个。可以借助整除处理\r\n- 参加多少对局：只需要计算结束和开始时间之间的分钟差 span，计算 span 拥有多少完成的 15 min 即可，也就是说可以用 span 整除 15 即可。\r\n\r\n**代码**\r\n\r\n```js\r\nvar numberOfRounds = function(loginTime, logoutTime) {\r\n\r\n  const [login_hour, login_minute] = loginTime.split(':')\r\n  const start = parseInt(login_hour) * 60 + parseInt(login_minute)\r\n  const [logout_hour, logout_minute] = logoutTime.split(':')\r\n  let end = parseInt(logout_hour) * 60 + parseInt(logout_minute)\r\n   if(start > end) end += 1440\r\n      return calc(start, end)\r\n  \r\n  function calc(start, end){\r\n    //取开始时间后的开局时间\r\n    if (start % 15 != 0)\r\n        start = parseInt(start / 15)  * 15 + 15\r\n    end = parseInt(end / 15) * 15\r\n    return Math.max(0, (end - start) / 15)\r\n  }\r\n};\r\n```\r\n\r\n**复杂度**\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337612794","body":"**思路**\n\n- 求相同只需要an+bn-da[i]-db[i]\n- `A 中的 每个字母 在字母表中 严格小于 B 中的 每个字母` 为例。我们要做的就是枚举所有可能的 A 的最大字母 和 B 的最小字母（其中 A 的最大字母保证严格小于 B 的最大字母），并计算操作数，最后取最小值即可\n\n**代码**\n\n```js\n var minCharacters = function(a, b) {\n  let da = new Array(26).fill(0);\n  let db = new Array(26).fill(0);\n  for(let i in a) {\n      da[a.charCodeAt(i) - 97] ++;\n  }\n  for(let i in b) {\n      db[b.charCodeAt(i) - 97] ++;\n  }\n  let an = a.length, bn = b.length, res = Number.MAX_SAFE_INTEGER;\n  //求相同数\n  for(let i = 0 ; i < 25 ; i ++) {\n      // 找最小值\n      res = Math.min(res, an+bn-da[i]-db[i]);\n  }\n  for(let i = 1 ; i < 26 ; i ++) {\n   let t = 0\n   for(let j = i ; j < 26 ; j ++) {\n        t+=da[j]\n   }\n   for(let d = 0 ; d < i ; d ++) {\n        t+=db[d]\n   }\n   res = Math.min(res, t)\n  }\n  for(let i = 1 ; i < 26 ; i ++) {\n    let t = 0\n    for(let j = i ; j < 26 ; j ++) {\n         t+=db[j]\n    }\n    for(let d = 0 ; d < i ; d ++) {\n         t+=da[d]\n    }\n    res = Math.min(res, t)\n   }\n  return res;\n};\n```\n\n**复杂度**\n\n时间：O(m+n)\n\n空间：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339399937","body":"计数排序：\n\n```js\nvar sortArray = function (nums) {\n  const counts = Array(50000 * 2 + 1).fill(0);\n  const res = [];\n  //num的取值范围是： -50000 <= nums[i] <= 50000\n  for (const num of nums) counts[50000 + num] += 1;\n  for (let i in counts) {\n    while (counts[i]--) {\n      res.push(i - 50000);\n    }\n  }\n  return res;\n};\n```\n\n**复杂度**\n\n时间复杂度 O(n)\n\n空间复杂度 O(m)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341085149","body":"https://leetcode.cn/problems/sqrtx/\n\n**思路**\n\n**找最右边的满足条件的值**\n\n**代码**\n\n```js   \nvar mySqrt = function(x) {\n  let l=0,r=x;\n   while(l<=r){\n    const mid=l+parseInt((r-l)/2)\n    const res=mid*mid\n    if(res===x) return mid\n    else if(res<x) l=mid+1\n    else  r=mid-1\n   }\n   return l-1\n};\n```\n\n\n\n**复杂度**\n\n- 时间复杂度：O(logx)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342924283","body":"**思路**\n\n最左二分直接套模板\n\n**代码**\n\n```js\nvar solution = function (isBadVersion) {\n    /**\n     * @param {integer} n Total versions\n     * @return {integer} The first bad version\n     */\n    return function (n) {\n        let left = 0;\n        let right = n;\n        while (left <= right) {\n            const mid = Math.floor(left + (right - left) / 2);\n            if (isBadVersion(mid))\n                // 收缩右边界\n                right = mid - 1;\n            // 收缩左边界\n            else left = mid + 1;\n        }\n        return left;\n    };\n};\n```\n\n**复杂度**\n\n- 时间复杂度：O(log N)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344455953","body":"**思路**\n\n归并排序\n\n**代码**\n\n```js\nvar reversePairs = function (nums) {\n    if (nums.length == 0) {\n        return 0;\n    }\n    let count = 0;\n\n    function mergeSort(nums, start, end) {\n        if (start == end) {\n            return 0;\n        }\n        const mid = start + ((end - start) >> 1);\n        mergeSort(nums, start, mid);\n        mergeSort(nums, mid + 1, end);\n\n        let i = start;\n        let j = mid + 1;\n        while (i <= mid && j <= end) {\n            if (nums[i] > 2 * nums[j]) {\n                count += mid - i + 1;\n                j++;\n            } else {\n                i++;\n            }\n        }\n        i = start;\n        j = mid + 1;\n        const temp = new Array(end - start + 1);\n        let index = 0;\n        while (i <= mid && j <= end) {\n            if (nums[i] < nums[j]) {\n                temp[index] = nums[i];\n                index++;\n                i++;\n            } else {\n                temp[index] = nums[j];\n                index++;\n                j++;\n            }\n        }\n        while (i <= mid) {\n            temp[index] = nums[i];\n            index++;\n            i++;\n        }\n        while (j <= end) {\n            temp[index] = nums[j];\n            index++;\n            j++;\n        }\n        for (let i = start, k = 0; i <= end; i++, k++) {\n            nums[i] = temp[k];\n        }\n    }\n    \n    mergeSort(nums, 0, nums.length - 1);\n    return count;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345568548","body":"### 第k个最小的绝对值差\n\n### 思路\n\n设绝对值差为x=>小于等于x的绝对值有K个\n\n确定解空间的上下限:[0,max(nums)-min(nums)],对解空间进行二分,求得mid,求小于等于mid的任意两个数的差的绝对值的个数p,若\np < k，则mid<x =>任何解空间中小于等于 mid 的数都不可能是答案=>l=mid+1\np > k，则同样可舍弃mid的右边区间\n\n问题1. 如何计算小于等于mid的个数p?\n  可以使用双指针一次遍历解决。具体地，首先对数组排序，然后使用右指针 j 和 左指针 i。如果 nums[j] - nums[i] 大于 diff，我们收缩 i 直到 nums[j] - nums[i] <= diff。这个时候，我们就可计算出以索引 j 结尾的绝对值差小于等于 diff 的个数，个数就是 j - i。我们可以使用滑动窗口技巧分别计算所有的 j 的个数，并将其累加起来就是答案。\n\n### 代码\n\n```js\nvar smallestDistancePair = function(prevNums, k) {\n   \n  const nums=prevNums.sort((a,b)=>a-b)\n  let l=0,r=nums[nums.length-1]-nums[0]\n  while(l<=r){\n    const mid= parseInt((r-l)/2)+l \n    const x= getNums(mid)\n    if(x<k) l=mid+1\n    else r=mid-1\n  }\n  return l\n  function  getNums(dis) {\n     let l=0,res=0;\n     for (let r = 1; r < nums.length; r++) {\n      while(nums[r]-nums[l]>dis)\n       { l++;  }    \n       res+=r-l;\n     }\n     return res\n  }\n};\n```\n\n### 复杂度\n\n令 n 为数组长度。\n\n时间复杂度：由于进行了排序， 因此时间复杂度大约是 O(nlogn)\n\n空间复杂度：取决于排序的空间消耗","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348388028","body":"**思路**\n新窗口元素和 = 旧窗口元素和 - 左边移除的元素 + 右边进来的元素\n**代码**\n```js\nvar maxVowels = function(s, k) {\n  if (s == null || s.length < k)\n  return 0;\n  const vowels=['a', 'e', 'i', 'o', 'u']\n  let res=0;\n  for (let l = 0; l < k; l++) {\n    res+=vowels.includes(s[l])?1:0 ;\n  }\n  let max=res;\n     for (let l = 0; l < s.length-k; l++) {\n      const r=k+l\n      vowels.includes(s[l])&&res--; \n      vowels.includes(s[r])&&res++; \n      max=Math.max(max,res )\n     }\n     return max\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351605918","body":"**思路**\n\n类似爬楼梯\n\n状态方程:dp[x]=1/w * dp[x+1]+ 1/w * dp[x+2] + 1/w * dp[x+3]...+ 1/w * dp[x+w]\n\n先求出K-W之间的概率，再反推出dp[0]\n\n**代码**\n\n```JS\nconst new21Game = (N, K, W) => {\n  const dp = new Array(K+W).fill(0);\n  let s=0;\n  for (let i = 0; i < W; i++) {\n    const index=K+i\n    dp[index]=index<=N?1 :0\n    s+=dp[index]\n  }\n  for (let i = K-1; i >=0; i--) {\n    dp[i]=s/W\n   s=s-dp[i+W]+dp[i]\n  }\n  return dp[0]\n};\n```\n\n**复杂度**\n\n- 时间复杂度：O(K+W)\n- 空间复杂度：O(K+W)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353283757","body":"**思路**\n\n- 字母异位词：不关心 p 这个串的顺序，只关心字母是否出现以及出现的次数，因此符合要求的子串长度都是 p，因而可以确定滑动窗口为固定长度p.length\n- 滑动窗口：核心思想还是新窗口元素和 = 旧窗口元素和 - 左边移除的元素 + 右边进来的元素；\n  - 如何存储 p 串及更新窗口信息：桶或哈希（数组ch），左出右进=桶中字符个数的增减\n  - 用左右指针start,end 表示窗口的指向\n  -  用rest来表示剩余待匹配字符的个数，并在循环过程维护，后续就不需要再去遍历ch判断是否字符个数都为0\n\n\n\n```js\nlet findAnagrams = function (s, p) {\n   const res=[],aNum='a'.charCodeAt(0)\n    if (s == null || p == null || s.length < p.length)\n        return res;\n\n    let ch = new Array(26).fill(0);\n    //统计p串字符个数\n    for (const c of p){\n      ch[c.charCodeAt(0) - aNum]++;\n    }\n   \n    //把窗口扩成p串的长度\n    let  start = 0, end = 0, rest = p.length;\n    for (; end < p.length; end++) {\n      // 说明之前这个字母有在p中\n      if (ch[s.charCodeAt(end)-aNum] >= 1)\n          rest--;\n        ch[s.charCodeAt(end)-aNum]--;\n    }\n\n    if (rest == 0)\n        res.push(0);\n    //开始一步一步向右移动窗口。\n    while (end < s.length) {\n        const l=s.charCodeAt(start)-aNum\n        //左边的拿出来一个并更新状态\n        ch[l]++;\n        start++;\n        //如果是不需要的字符，此时应该为0，毕竟在前面减过一次ch[l]\n        if (ch[l] >= 1)  rest++;\n        //右边的拿进来一个并更新状态\n        const r=s.charCodeAt(end)-aNum\n        if (ch[r] >= 1)  rest--;\n        ch[r]--;\n        end++;\n        // 状态合法就存到结果集合\n        if (rest == 0)\n            res.push(start);\n    }\n\n    return res;\n};\n\n```\n\n**复杂度**\n\n时间复杂度：O(n)\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354128442","body":"```js\nconst minWindow = (s, t) => {\n  let minLen = s.length + 1;\n  let start = s.length;     // 结果子串的起始位置\n  let map = {};             // 存储目标字符和对应的缺失个数\n  let missingType = 0;      // 当前缺失的字符种类数\n  for (const c of t) {      // t为baac的话，map为{a:2,b:1,c:1}\n    if (!map[c]) {\n      missingType++;        // 需要找齐的种类数 +1\n      map[c] = 1;\n    } else {\n      map[c]++;\n    }\n  }\n  let l = 0, r = 0;                // 左右指针\n  for (; r < s.length; r++) {      // 主旋律扩张窗口，超出s串就结束\n    let rightChar = s[r];          // 获取right指向的新字符\n    if (map[rightChar] !== undefined) map[rightChar]--; // 是目标字符，它的缺失个数-1\n    if (map[rightChar] == 0) missingType--;   // 它的缺失个数新变为0，缺失的种类数就-1\n    while (missingType == 0) {                // 当前窗口包含所有字符的前提下，尽量收缩窗口\n      if (r - l + 1 < minLen) {    // 窗口宽度如果比minLen小，就更新minLen\n        minLen = r - l + 1;\n        start = l;                 // 更新最小窗口的起点\n      }\n      let leftChar = s[l];          // 左指针要右移，左指针指向的字符要被丢弃\n      if (map[leftChar] !== undefined) map[leftChar]++; // 被舍弃的是目标字符，缺失个数+1\n      if (map[leftChar] > 0) missingType++;      // 如果缺失个数新变为>0，缺失的种类+1\n      l++;                          // 左指针要右移 收缩窗口\n    }\n  }\n  if (start == s.length) return \"\";\n  return s.substring(start, start + minLen); // 根据起点和minLen截取子串\n};\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356772425","body":"var readBinaryWatch = function (num) {\n  const res=[]\n\n    //直接遍历  0:00 -> 12:00   每个时间有多少1\n    for (let i = 0; i < 12; i++) {\n        for (let j = 0; j < 60; j++) {\n            if (count1(i) + count1(j) == num) {\n                res.push(i.toString()+\":\"+\n                              (j < 10 ? \"0\"+j.toString() : j.toString()));\n            }\n        }\n    }\n    return res;\n}\n//计算二进制中1的个数\nfunction count1(n) {\n    let res = 0;\n    while (n != 0) {\n        n = n & (n - 1);\n        res++;\n    }\n    return res;\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363969573","body":"#### DFS\n\n**思路**\n  先存着，再根据y,x，val做排序\n**代码**\n\n```js\n var verticalTraversal = function (root) {\n  const res = new Map([[0, [[root.val]]]])\n  proder(root.left, 1, -1)\n  proder(root.right, 1, 1)\n\n  function proder(node, row, col) {\n    if(!node) return;\n      const arr = res.get(col) || []\n      arr[row] = [...(arr[row] || []), node.val]\n      res.set(col, arr)\n      node.left && proder(node.left, row + 1, col - 1)\n      node.right && proder(node.right, row + 1, col + 1)\n  }\n  const newLocal = [...res].sort(([a], [b]) => (a - b));\n  const result = newLocal.reduce(function (total, [cur, arr]) {\n      const items = arr.map(item => item.sort((a, b) => a - b)).flat()\n      total.push(items)\n      return total;\n  }, [])\n  return result;\n};\n```\n\n**复杂度**\n\n- 时间复杂度：O(NlogN)，其中 N 为树的节点总数。\n- 空间复杂度：O(N)，其中 N 为树的节点总数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364538661","body":"**思路**\n\n爬楼梯变形题，\n\n- 状态转移方程：用f(n)表示最小花费，f(n)=Min(f(n-1)+cost[n-1],f(n-2)+cost[n-2])\n- 如何枚举：循环，枚举到n;这里还用了滚动数组\n- 临界条件：f(0)=f(1)=0\n\n```js\nvar minCostClimbingStairs = function(cost) {\n  const n=cost.length\n  if ([0,1].includes(n)) return 0;\n  \n  let a = 0;\n  let b = 0;\n  let temp;\n  \n  for (let i = 2; i <= n; i++) {\n    temp = Math.min(a+cost[i-2],b+cost[i-1] )  ;\n    a = b;\n    b = temp;\n  }\n  \n  return temp;\n};\n```\n\n**复杂度**\n\n时间：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364697503","body":"https://leetcode.cn/problems/house-robber/\n\n**思路**\n\n爬楼梯变形题\n\n- 状态转移方程：用dp表示第i个房子能获取到的最高金额，dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1])\n- 临界条件：dp(0)=nums[0]\n\n```js\nlet a = 0;\nlet b = 0;\n\nfor (let i = 0; i < nums.length; i++) {\n  const temp = b;\n  b = Math.max(a + nums[i], b);\n  a = temp;\n}\n\nreturn b;\n\n\nvar rob = function (nums) {\n  // Tag: DP\n  const dp = [];\n  dp[0] = 0;\n  dp[1] = 0;\n\n  for (let i = 2; i < nums.length + 2; i++) {\n    dp[i] = Math.max(dp[i - 2] + nums[i - 2], dp[i - 1]);\n  }\n\n  return dp[nums.length + 1];\n};\n```\n\n**复杂度**\n\n- 时间：O(N)\n\n- 空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298583857","body":"## 思路\r\n大模拟，注意进位和数比数组大的情况，处理边界\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n         int t = k % 10;\r\n         int f=0;\r\n         for(int i = num.size(); i > 0 && (k||f); i--){\r\n             t = k % 10;\r\n             k /= 10;\r\n             if(t+num[i-1]+f>=10){\r\n                 num[i-1]=(t+num[i-1]+f)%10;\r\n                 f=1;\r\n                 }\r\n                 else{\r\n                     num[i-1]=t+num[i-1]+f;\r\n                     f=0;\r\n                     }\r\n            }\r\n            // 对数字较长情况\r\n            if(k){               \r\n                while(k){\r\n                    num.emplace(num.begin(), (k%10+f)%10);\r\n                    if((k%10+f)>=10)f=1;\r\n                    else f=0;\r\n                    k/=10;\r\n                }\r\n            }\r\n            // 对首位进位情况\r\n            if(f){\r\n                 num.emplace(num.begin(), f);\r\n            }       \r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 时间为O(n）\r\n+ 空间为O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299885137","body":"### 思路\n\n记录出现的下标，对字符串的字符进行处理，相同为0，不同跟两头比，注意左右边界。\n\n### 代码\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        for(int i=0;i<s.length();i++){\n            if(c==s[i]){\n                ans.push_back(i);\n            }\n        }\n        vector<int> ansl;\n        int p=0,l=-1;\n        for(int i=0;i<s.length();i++){\n            if(p<ans.size() && i==ans[p]){\n                ansl.push_back(0);\n                l=p;\n                p++;                \n            }else if(p<ans.size() && l!=-1){                     \n                ansl.push_back(min(abs(i-ans[p]),abs(i-ans[l])));\n            }else if(p<ans.size() && l==-1){            \n                ansl.push_back(ans[p]-i);\n            }else if(p>=ans.size()){               \n                ansl.push_back(i-ans[l]);\n            }\n        }\n        return ansl;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301646705","body":"### 思路1\n模拟，应该用数组维护top，偷懒用的了vector\n\n### 代码1\n```c++\nclass CustomStack {\npublic:\n    vector <int> a;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);}\n\n    }\n    \n    int pop() {       \n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        return t;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<a.size();i++){\n            a[i]+=val;\n        }\n    }\n};\n```\n\n### 复杂度\n+ Time O(N)\n+ Space O(N)\n\n### 思路2\n维护一个add数组，因为只有pop的时候需要最终值，inc的时候记录增加值的位置，+=val，注意pop时这个值会影响到后面记得传递一位。\n使用top效率会更高，偷懒用了back()。\n\n### 代码2\n```c++\nclass CustomStack {\npublic:\n    vector <int> a, add;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n        //add.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);\n        add.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        t+=add.back();\n        int acc=add.back(); \n        add.pop_back();       \n        if(add.empty()){}\n        else{\n            add.back()+=acc;\n        }        \n        return t;\n    }\n    \n    void increment(int k, int val) {\n        int lim=k<a.size()?k:a.size();\n        if(lim>0){\n            if(k<a.size()){\n                add[k-1]+=val;\n            }else{\n                add.back()+=val;\n            }\n        } \n    }\n};\n```\n### 复杂度\n+ Time O(1)\n+ Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303772828","body":"### 思路\r\n模拟，第一次想错了，用一个栈装数一个栈装字母，结果处理不了嵌套后两个右半括号之间有字母的情况，一直企图缝缝补补，发现得记录数字和字母是否在同一级，企图每个栈里面加pair 的 int 修补。\r\n后看了题解，其实将数字和字母装进同一格即可，理论上pair修补也行，但不是正道。\r\n递归也可以做（编译原理）题解版本。\r\n### 代码 (误）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string ans;\r\n        int l=0,r=0;\r\n        int ls=0,rs=0;\r\n        vector<pair<int,int>> num;\r\n        vector<pair<int,string>> str;\r\n        int endnum=-1;\r\n        int cnt=0;\r\n        int flag=-1; // -1初始，1 num，2 alpha,[ 3,] 4\r\n        for(int i=0;i<s.length();i++){\r\n            if(num.empty()&&isalpha(s[i])){\r\n                ans+=s[i];\r\n            }\r\n            if(isdigit(s[i])){\r\n                if(flag!=1){\r\n                    if(flag==2){                        \r\n                        rs=i;\r\n                        pair <int,string> pi;\r\n                        pi.first=cnt;\r\n                        pi.second=s.substr(ls,rs-ls);                        \r\n                        str.push_back(pi);\r\n                    }\r\n                    l=i;\r\n                    // cout<<l<<endl;\r\n                    flag=1;\r\n                }      \r\n            }else if(isalpha(s[i])){\r\n                if(flag!=2){                    \r\n                    ls=i;\r\n                    flag=2;\r\n                }\r\n            }else if(s[i]=='['){\r\n                r=i;\r\n                int ss=stoi(s.substr(l,r-l)); \r\n                pair<int,int> pp;\r\n                pp.first=cnt;\r\n                pp.second=ss;               \r\n                num.push_back(pp);\r\n                cnt++;                \r\n                ls=i+1;\r\n                flag=3;\r\n            }else if(s[i]==']'){ \r\n                cnt--;               \r\n                endnum=i;      \r\n                rs=i;\r\n                pair <int,int> ti;                \r\n                ti=num.back(); \r\n                int time=ti.second;              \r\n                num.pop_back();                    \r\n                if(!num.empty()){\r\n                    if(flag==4){                        \r\n                        string aa;\r\n                        string sstr=str.back().second;\r\n                        // str.pop_back();\r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=sstr;\r\n                        }\r\n                        string te=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        cout<<te+aa<<endl;\r\n                        \r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                        ls=i+1;\r\n                    }else{\r\n                         \r\n                        string ss=s.substr(ls,rs-ls);                        \r\n                        string aa;\r\n                        // str.pop_back();\r\n                        \r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=ss;\r\n                        }\r\n                        // cout<<aa<<endl;\r\n                        string te=str.back().second;\r\n                        int ttt=str.back().first;\r\n                        str.pop_back();\r\n                        pair <int,string> ppp;\r\n                        ppp.first=ttt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                    }\r\n                }\r\n                else{\r\n                    cout<<\"!!!!\"<<i<<endl;                   \r\n                    if(flag==4){\r\n                        string acc=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=acc;\r\n                        }\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                    }else{                                                                \r\n                        string ss=s.substr(ls,rs-ls);\r\n                        cout<<ss<<endl;\r\n                        cout<<cnt<<endl;\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=ss;\r\n                        }\r\n                        \r\n                        string str2;\r\n                        if(!str.empty()){\r\n                            str2=str.back().second;\r\n                            int ttt=str.back().first;\r\n                            str.pop_back();\r\n                        }               \r\n                            // str.push_back(str2+ss);\r\n                        str1=str2+str1;\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                        cout<<str1<<endl;                                            \r\n                    }                   \r\n                }\r\n                flag=4;       \r\n            }\r\n        }\r\n        // for(int i=0;i<num.size();i++){\r\n        //     cout<<num[i]<<endl;\r\n        // }\r\n        // for(int i=0;i<str.size();i++){\r\n        //     cout<<str[i]<<endl;\r\n        // }\r\n        ans=str.back().second;\r\n        if(endnum+1 < s.length()){\r\n            string endstr=s.substr(endnum+1,s.length()-endnum);\r\n            // cout<<endstr<<endl;\r\n            ans+=endstr;\r\n        }        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 代码\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        int ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                int i;\r\n                for(i=ptr;i<s.size()&&isdigit(s[i]);i++){}\r\n                string digits = s.substr(ptr,i);\r\n                ptr=i;\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 代码（递归）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string src; \r\n    size_t ptr;\r\n\r\n    int getDigits() {\r\n        int ret = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            ret = ret * 10 + src[ptr++] - '0';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString() {\r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            // String -> EPS\r\n            return \"\";\r\n        }\r\n\r\n        char cur = src[ptr]; int repTime = 1;\r\n        string ret;\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits [ String ] String\r\n            // 解析 Digits\r\n            repTime = getDigits(); \r\n            // 过滤左括号\r\n            ++ptr;\r\n            // 解析 String\r\n            string str = getString(); \r\n            // 过滤右括号\r\n            ++ptr;\r\n            // 构造字符串\r\n            while (repTime--) ret += str; \r\n        } else if (isalpha(cur)) {\r\n            // String -> Char String\r\n            // 解析 Char\r\n            ret = string(1, src[ptr++]);\r\n        }\r\n        \r\n        return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n};\r\n```\r\n### 复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466309","body":"### 代码\n``` c++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    vector<int> ans,vc;\n    int f;\n    MyQueue() {\n        f=-1;\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        if(vc.empty())f=x;\n        vc.push_back(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int t;  \n        if(ans.empty()){\n            while(!vc.empty()){\n                t=vc.back();\n                ans.push_back(t);\n                vc.pop_back();\n                printf(\"%d\\n\",t);\n            }\n        }      \n        \n        t=ans.back();               \n        ans.pop_back();//printf(\"!!!\\n\"); \n        if(!ans.empty())f=ans.back();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        return f;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return vc.empty()&&ans.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751977","body":"### 思路 1\n计数，本来想开数组桶排序，有点大，就map，只要这一节和排好序的一节拥有同样元素的同样个数，既可作为一块。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int ans=0;\n        vector<int> s(arr);\n        map<int,int> m;\n        sort(s.begin(),s.end());\n\n        for(int i=0;i<arr.size();i++){\n            m[arr[i]]++;\n            m[s[i]]--;\n            if(m[arr[i]]==0){\n                m.erase(arr[i]);\n            }\n            if(m[s[i]]==0){\n                m.erase(s[i]);\n            }\n            if(m.size()==0){\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度\n+ 时间 O(nlogn)\n+ 空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305578695","body":"### 思路\n取余，双指针\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==NULL||k==0)return head;\n        int cnt=1;\n        ListNode* p=head;\n        while(p->next){\n            p=p->next;\n            cnt++;\n        }        \n        k%=cnt;        \n        k=cnt-k;\n        // cout<<cnt<<\" \"<<k<<endl;\n        if(cnt==k)return head;\n        ListNode* p1=head;\n        ListNode* p2;\n        for(int i=1;i<k;i++){\n            p1=p1->next;\n        }\n        p2=p1->next;\n        p->next=head;\n        p1->next=NULL; \n        return p2;\n    }\n};\n```\n\n### 复杂度\n+ 时间 O(n)\n+ 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306776159","body":"### 思路\n仨指针循环倒腾，俩用来变节点，另一个用来连原来的，注意(p!=nullptr && p->next）前后顺序\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* p=head;\n        if(head==NULL||head->next==nullptr)return head;\n        ListNode*ans=head->next;\n        ListNode* p2=head;\n        while(p!=nullptr && p->next){            \n            ListNode* p1=p->next;\n            p2->next=p1;\n            cout<<p2->val<<endl;\n            p->next=p1->next;\n\n            p1->next=p;\n            p2=p;                        \n            p=p->next;\n        }\n        return ans;\n    }\n\n};\n```\n### 复杂度\n+ time o(n)\n+ space o(1)\n\n### 思路\n看题解还可以递归，出口是为null，否则递归返回值赋给head->next。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* p=head;\n        if(head==NULL||head->next==nullptr)return head;\n        ListNode* newHead = head->next;\n        head->next = swapPairs(newHead->next);\n        newHead->next = head;\n        return newHead;\n    }\n};\n```\n### 复杂度\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307530656","body":"### 思路\n递归分治，出口是头和尾指向一个，快慢指针找中间。 也可以全捋成数组，每次查找方便一点。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head,ListNode* tail=nullptr) {\n        if(head==tail)return nullptr;\n        ListNode* fast=head,*slow=head;\n        while(fast != tail && fast->next != tail){\n            fast=fast->next->next;\n            slow=slow->next;\n        }\n        TreeNode* node=new TreeNode(slow->val);\n        node->left=sortedListToBST(head,slow);\n        node->right=sortedListToBST(slow->next,tail);\n        return node;\n    }\n};\n```\n\n### 复杂度\n+ time O(nlogn)\n+ space O(logn)\n\n### 思路\n看了题解，中序加分治，比一般二分还要效率高一点。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int getLength(ListNode* head) {\n        int ret = 0;\n        for (; head != nullptr; ++ret, head = head->next);\n        return ret;\n    }\n\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode(head->val);\n        root->left = buildTree(head, left, mid - 1);\n        root->val = head->val;\n        head = head->next;\n        root->right = buildTree(head, mid + 1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        int length = getLength(head);\n        return buildTree(head, 0, length - 1);\n    }\n};\n```\n\n### 复杂度\n+ time O(n) 因为子任务不是计数了，光比较\n+ space O(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309892875","body":"### 思路\n双指针，第一趟做差，第二趟换位保持差，换个开头，继续往后数，因为保持差值，会在交汇点相遇。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *p1=headA,*p2=headB;\n        while(p1!=nullptr&&p2!=nullptr){\n            if(p1==p2)return p1;\n            p1=p1->next;\n            p2=p2->next;            \n        }\n\n        if(p1==nullptr){\n            p1=headB;\n            while(p2!=nullptr){\n                p1=p1->next;\n                p2=p2->next;\n            }\n            p2=headA;\n            while(p1!=nullptr&&p2!=nullptr){\n                if(p1==p2)return p1;\n                p1=p1->next;\n                p2=p2->next;\n                \n            }\n        }else if(p2==nullptr){\n            p2=headA;\n            while(p1!=nullptr){\n                p1=p1->next;\n                p2=p2->next;\n            }\n            p1=headB;\n            while(p1!=nullptr&&p2!=nullptr){\n                if(p1==p2)return p1;\n                p1=p1->next;\n                p2=p2->next;\n                \n            }\n        }\n        return nullptr;\n    }\n};\n```\n简化后\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *f=headA;\n        ListNode *s=headB;\n        while(f!=s){\n            if(f==nullptr)f=headB;\n            else f=f->next;\n            if(s==nullptr)s=headA;\n            else s=s->next;\n        }\n        return f;\n    }\n};\n```\n\n### 复杂度\n+ time O(n)\n+ space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311483336","body":"### 思路\n快慢指针，第一次相遇时，快指针多跑n-1圈多，半个弧D，此时fast重置到head，步长为1，再次相遇时，自己走了直线部分L，由上次经验(L+C)*2=L+n(D+C)+c可推L=(n-1)*(C+D)+D,slow正好走的就是公式右半部分，二者在交汇处相遇。\n\n### 代码\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow=head;\n        ListNode *fast=head;\n        int i=0;\n        if(fast!=nullptr&&fast->next!=nullptr && fast->next->next!=nullptr){\n            slow=slow->next;\n            fast=fast->next->next; \n        }else{\n            return NULL;\n        }\n        while(fast!=slow && fast!=nullptr && slow!=nullptr){\n            slow=slow->next;\n            if (fast != nullptr && fast->next != nullptr) {\n            fast=fast->next->next;       }\n            else{fast=nullptr;}     \n        }\n\n        if(fast==slow){\n            fast=head;\n            while(fast!=slow){\n                slow=slow->next;\n                fast=fast->next;  \n            }\n        }\n        return fast;\n    }\n};\n```\n简化\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *f=head,*s=head;\n        while(f!=nullptr&&f->next!=nullptr){\n            f=f->next->next;\n            s=s->next;\n            if(f==s){\n                f=head;\n            \n            while(f!=s){\n                f=f->next;\n                s=s->next;\n            }            \n            return f;}\n        }\n        return NULL;\n    }\n};\n```\n\n### 复杂度\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1311977214","body":"### 思路\r\n哈希表加链表，用list写了链表，哈希表里放key和索引指针，list里用pair放key和value，每次get和put时都需要对该节点更新，先在链表里erase，再尾巴上插入，哈希表中更新索引。\r\n使用begin()，更方便。\r\n\r\n### 代码\r\n```c++\r\nclass LRUCache {\r\npublic:\r\n    map<int, list<pair<int, int>>::iterator> m;\r\n    list<pair<int,int>> l;\r\n    int n;\r\n    int i=0;\r\n    LRUCache(int capacity) {\r\n        n=capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        int ans=-1;\r\n        if(m.count(key)){\r\n            ans=(*m[key]).second;\r\n            l.erase(m[key]);\r\n            l.push_back(make_pair(key,ans));\r\n            list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n            m[key]=ll;            \r\n        }return ans;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(m.count(key)){            \r\n            l.erase(m[key]);\r\n            l.push_back(make_pair(key,value));\r\n            list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n            m[key]=ll;\r\n        }else{\r\n          \r\n            if(i<n){\r\n                i++;\r\n                l.push_back(make_pair(key,value));\r\n                list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n                m[key]=ll;                \r\n            }else{\r\n                // cout<<l.size()<<endl;  \r\n                m.erase(l.front().first);            \r\n                l.pop_front();\r\n                // l.erase(l.begin());\r\n                l.push_back(make_pair(key,value));\r\n                list<pair<int, int>>::iterator ll=l.end();\r\n                ll--;\r\n                m[key]=ll;\r\n            }            \r\n        }\r\n\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n简化\r\n```c++\r\nclass LRUCache {\r\npublic:\r\n    pair<int,int> pa;\r\n    list<pair<int,int>> l;\r\n    unordered_map<int, list<pair<int, int>>::iterator> mp;\r\n    int M=0;\r\n\r\n    LRUCache(int capacity) {\r\n        M=capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        pa=make_pair(key,-1);   \r\n        if(mp.count(key)){\r\n            pa.second=(*mp[key]).second;\r\n            l.erase(mp[key]);\r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n\r\n        }\r\n        return pa.second;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        pa=make_pair(key,value);\r\n        if(mp.count(key)){            \r\n            l.erase(mp[key]);\r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n        }\r\n\r\n\r\n        else{            \r\n            if(l.size()==M){\r\n                mp.erase(l.back().first);\r\n                l.pop_back();\r\n            }          \r\n            l.push_front(pa);\r\n            mp[key]=l.begin();\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\nO(1)\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312641783","body":"### 思路\n递归dfs\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr)return 0;\n        else{\n            int l=maxDepth(root->left);\n            int r=maxDepth(root->right);\n            return l<r?r+1:l+1;\n        }        \n    }\n};\n```\n\n### 复杂度\nO(n)\nO(hight)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312782443","body":"### 思路\ndfs 挨个比，出口俩空true，只有一个空false，值不同false，否则递归左右子树。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {       \n        if(p==nullptr && q==nullptr){\n            return true;\n        }else if(p==nullptr || q==nullptr){\n            return false;\n        }else if(p->val==q->val){\n            bool a=isSameTree(p->left,q->left);\n            bool b=isSameTree(p->right,q->right);\n            return a&&b;\n        }else{\n            return false;\n        }         \n    }\n};\n```\nor\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(!p && !q) return true;\n        if(!p || !q) return false;\n        if((p->val == q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right))\n        return true;\n        else{\n            return false;\n        }       \n    }\n};\n```\n###\nO(n)\n\n### 思路\n看了官方题解 bfs\n其中可以使用异或，表示两者不同的情况，也就是一个null一个有值，也可以考虑使用非指针的与和或来表示只有一个不为空的情况。\n        if (!leftNode && !rightNode) {  //\n                continue;\n            }    \n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n\n```c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == nullptr && q == nullptr) {\n            return true;\n        } else if (p == nullptr || q == nullptr) {\n            return false;\n        }\n        queue <TreeNode*> queue1, queue2;\n        queue1.push(p);\n        queue2.push(q);\n        while (!queue1.empty() && !queue2.empty()) {\n            auto node1 = queue1.front();\n            queue1.pop();\n            auto node2 = queue2.front();\n            queue2.pop();\n            if (node1->val != node2->val) {\n                return false;\n            }\n            auto left1 = node1->left, right1 = node1->right, left2 = node2->left, right2 = node2->right;\n            if ((left1 == nullptr) ^ (left2 == nullptr)) {\n                return false;\n            }\n            if ((right1 == nullptr) ^ (right2 == nullptr)) {\n                return false;\n            }\n            if (left1 != nullptr) {\n                queue1.push(left1);\n            }\n            if (right1 != nullptr) {\n                queue1.push(right1);\n            }\n            if (left2 != nullptr) {\n                queue2.push(left2);\n            }\n            if (right2 != nullptr) {\n                queue2.push(right2);\n            }\n        }\n        return queue1.empty() && queue2.empty();\n    }\n};\n```\nor\n```c++\nclass Solution {\npublic:\n\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (p == NULL && q == NULL) return true;\n        if (p == NULL || q == NULL) return false;\n        queue<TreeNode*> que;\n        que.push(p);   //\n        que.push(q);  //\n        while (!que.empty()) {  //\n            TreeNode* leftNode = que.front(); que.pop();\n            TreeNode* rightNode = que.front(); que.pop();\n            if (!leftNode && !rightNode) {  //\n                continue;\n            }\n            //\n            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {\n                return false;\n            }\n            que.push(leftNode->left);   //\n            que.push(rightNode->left); //\n            que.push(leftNode->right);  //\n            que.push(rightNode->right);  //\n        }\n        return true;\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315116320","body":"### 思路\n递归dfs，出口一个0一个叶子节点，其余相加。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root, int sum=0) {\n        if(root==nullptr)return 0;\n        else if(root->left==nullptr && root->right==nullptr)return sum*10+root->val;\n        else{\n            int a=sum*10+root->val; \n            return sumNumbers(root->left,a)+sumNumbers(root->right,a);\n        }\n    }\n};\n``` \n### \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316958916","body":"### 思路\ndfs\n维护一个最大深度的变量，记录每个节点的深度，如果当前节点深度比最大深度要大，则更新最大深度和结果项。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int curhi=-1;\n    void dfs(TreeNode* root, int hi, int& cur){\n        if(root==nullptr){\n            return;\n        }\n        hi++;\n        if(hi>curhi){\n            curhi=hi;\n            cur=root->val;               \n        }\n        dfs(root->left,hi,cur);\n        dfs(root->right,hi,cur);\n\n    }\n    int findBottomLeftValue(TreeNode* root) {\n        int cur=root->val;\n        dfs(root, 0, cur);\n        return cur;\n    }\n};\n```\n\n### \nO(n)\n\n### 思路\n层序\n\n### 代码\n``` c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        int ans=root->val;\n        list<TreeNode*> l;\n        l.push_back(root);\n        int deep=0;\n        while(!l.empty()){\n            deep++;\n            if(l.front()!=nullptr)ans=(l.front())->val;\n            int cnt=l.size();\n            while(cnt--){\n                TreeNode* p=l.front();\n                l.pop_front();\n                if(p->left)l.push_back(p->left);\n                if(p->right)l.push_back(p->right);\n            }\n            \n        }\n        return ans;\n    }\n};\n```\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1321195226","body":"### 思路\r\n第一次写的时候，序列化用的bfs，反序列化用的完全二叉树下标dfs，导致有的样例过不了，因为左子树早就没有了少null给右子树，就改了都bfs，但vector超时样例50，改用list。\r\n\r\n```c++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Codec {\r\npublic:\r\n\r\n    // Encodes a tree to a single string.\r\n    string serialize(TreeNode* root) {\r\n        string ans;\r\n        if(root==nullptr)return \"\";\r\n        list<TreeNode*> q;\r\n        q.push_back(root);\r\n        while(!q.empty()){ \r\n            TreeNode* temp=q.front();\r\n            q.pop_front();\r\n            if(temp!= NULL){\r\n                ans+=to_string(temp->val)+\",\";\r\n                q.push_back(temp->left);\r\n                q.push_back(temp->right);\r\n            }\r\n            else{\r\n                ans+=\"null,\";\r\n            }\r\n        }\r\n        // cout<<ans<<endl;\r\n        return ans;\r\n    }\r\n\r\n\r\n    // Decodes your encoded data to tree.\r\n    TreeNode* deserialize(string data) {\r\n        if(data.empty())return NULL;\r\n        // vector<string> res;\r\n        list<string> res;\r\n        char * strs = new char[data.length() + 1] ; \r\n\t    strcpy(strs, data.c_str()); \r\n        // char * strs=data;\r\n        char * d = new char[2];\r\n        string ss=\",\";\r\n\t    strcpy(d, ss.c_str());\r\n\r\n        // char * d=\",\";       \r\n\r\n        char *p = strtok(strs, d);\r\n\t    while(p) {\r\n\t\t    string s = p; //分割得到的字符串转换为string类型\r\n\t\t    res.push_back(s); //存入结果数组\r\n\t\t    p = strtok(NULL, d);\r\n\t    }\r\n        queue<TreeNode*> que;\r\n        if (res.front() == \"null\") return NULL;\r\n        TreeNode* root = new TreeNode(stoi(res.front()));\r\n        que.emplace(root);\r\n        res.pop_front();\r\n        while (!que.empty() && !res.empty()) {\r\n            TreeNode* cur = que.front();\r\n            que.pop();\r\n            if(res.front()!=\"null\"){\r\n                TreeNode* node1 = new TreeNode(stoi(res.front()));\r\n                cur->left=node1;\r\n                que.push(node1);\r\n            }\r\n            res.pop_front();\r\n            if(res.front()!=\"null\"){\r\n                TreeNode* node2 = new TreeNode(stoi(res.front()));\r\n                cur->right=node2;\r\n                que.push(node2);\r\n            }\r\n            res.pop_front();\r\n        }\r\n\r\n        // int ann=atoi(res[0].c_str());\r\n        // // cout<<res[3]<<endl;\r\n        // TreeNode* root=new TreeNode();\r\n        // root->val=ann;\r\n        // dfs(root,res,0);\r\n        return root;\r\n    }\r\n    // void dfs(TreeNode* root, vector<string> a,int ind){\r\n    //     // cout<<\":\"<<ind<<\" \"<<a[ind]<<endl;\r\n    //     if(a[ind]==\"null\"){return;}\r\n    //     else{\r\n    //         int size=a.size();\r\n    //         if(size>2*ind+1){\r\n    //             if(a[2*ind+1]!=\"null\"){\r\n    //                 int aaa=atoi(a[2*ind+1].c_str());\r\n    //             TreeNode* tl=new TreeNode();\r\n    //             tl->val=aaa;\r\n    //             root->left=tl;dfs(root->left,a,2*ind+1);\r\n    //             }\r\n                \r\n    //         }if(size>2*ind+2){\r\n    //             if(a[2*ind+2]!=\"null\"){\r\n    //                 int aal=atoi(a[2*ind+2].c_str());\r\n    //             TreeNode* tr=new TreeNode();\r\n    //             tr->val=aal;\r\n    //             root->right=tr;dfs(root->right,a,2*ind+2);\r\n    //             }                \r\n    //         }\r\n    //         // cout<<aaa<<\" \"<<aal<<endl;\r\n    //     }\r\n    // }\r\n    \r\n};\r\n\r\n### \r\nO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319818224","body":"### 思路\n遍历时记录row，col，将其排序，优先级分别是l，r，val。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    typedef struct{\n        int val;\n        int r;\n        int l;\n    }treeno;\n    \n    static bool cmp(treeno a,treeno b)\n    {\n        if(a.l<b.l)return true;\n        else if(a.l==b.l){\n            if(a.r<b.r)return true;\n            else if(a.r==b.r){\n                return a.val<b.val;\n            }\n            else{\n                return false;\n            }\n        }\n        else{\n            return false;\n        }     \n    }\n    vector<treeno> temp;\n    int dfs(TreeNode* root,int r,int l){\n        if(root==nullptr)return 0;        \n        else{\n            treeno st;\n            st.val=root->val;\n            st.r=r;\n            st.l=l;\n            temp.push_back(st);\n            dfs(root->left,r+1,l-1);\n            dfs(root->right,r+1,l+1);\n            return 1;\n        }\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ans;\n        vector<int> t;       \n        dfs(root,0,0);\n        sort(temp.begin(),temp.end(),cmp);\n        int index=temp.front().l;\n        for(int i=0;i<temp.size();i++){\n            if(index==temp[i].l){\n                t.push_back(temp[i].val);\n            }\n            else{\n                index=temp[i].l;\n                ans.push_back(t);\n                t.clear();\n                i--;\n            }\n            // cout<<temp[i].val<<\" \";\n        }\n        ans.push_back(t);\n        return ans;\n    }  \n};\n```\n\n###\nO(nlogn）\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320880971","body":"### 思路\n哈希\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> ans;\n        unordered_map<int,int> map;\n        int n=nums.size();\n        for(int i=0;i<n;i++){\n            if(map.count(target-nums[i])){\n                return {i,map[target-nums[i]]};\n            }\n            else{\n                map[nums[i]]=i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321055990","body":"### 思路\nmap+优先队列\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        vector<int> ans;\n        map<int,int> m;\n        for(int i=0;i<nums.size();i++){\n            if(m.count(nums[i])){\n                m[nums[i]]++;\n            }else{m[nums[i]]=1;}\n        }\n        map<int, int>::iterator iter;\n        iter = m.begin();\n        priority_queue<pair<int, int>> a;\n        pair<int, int> b;\n        while(iter != m.end()) {\n            b.first=iter->second;\n            b.second=iter->first;\n            a.push(b);\n            iter++;\n        }\n        while (!a.empty()&&k) \n        {\n            ans.push_back(a.top().second);\n            // cout << a.top().first << ' ' << a.top().second << '\\n';\n            a.pop();k--;\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度\nO(N  logK)\nO(N)\n\n快排选前k也行","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322173931","body":"### 思路\n遍历 hash\n第一回的时候考虑自身重复少算了一半，从i=j开始的，wa了，计算是（m-1+1）*（m-1）/2 * 2。\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int ans;\n        int size=points.size();\n        unordered_map<int,int> m;\n        for(int i=0;i<size;i++){\n\t\t\tfor(int j=0;j<size;j++){\n\t\t\t\tint dis=(points[i][0]-points[j][0])*(points[i][0]-points[j][0])+(points[i][1]-points[j][1])*(points[i][1]-points[j][1]);\n                m[dis]++;\n\t\t\t}\n            for(auto it:m){\n\t\t\t\tans+=(it.second*(it.second-1));\n             //   cout<<it.first<<' '<<it.second<<endl;\n\t\t\t}\n            m.clear();\n            \n\t\t}\n        return ans;\n     }\n};\n```\n### \nO(n^2)\nO(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323660866","body":"### 思路\n双指针滑动窗口+hash\n注意边界处理\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        if(s.size()==0)return 0;\n        int l=0,r=0;\n        map<char,int> m;\n        int mx=1;\n        while(l!=s.size() && r!=s.size()){            \n            if(m.count(s[r])){\n                cout<<m[s[r]]<<endl;\n                int t=m[s[r]]+1;                \n                for(int i=l;i<m[s[r]];i++){\n                    m.erase(s[i]);\n                }                \n                l=t;\n            }            \n            m[s[r]]=r;\n            mx=max(mx,r-l+1);                      \n            r++;            \n        }\n        return mx;\n    }\n};\n```\n\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324884010","body":"### 思路\n暴力，俩hash，第一回超时了，修改了循环的终值。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> ans;\n        int n=s.length();\n        int wordn=words[0].size();\n        int m=words.size();\n        map<string, int> mp;\n        for(int i =0;i<m;i++){\n            mp[words[i]]++;\n        }\n        for(int i=0;i<=n-m*wordn;i++){\n            string temp=s.substr(i,m*wordn);\n            int k=0;\n            int cnt=0;\n            map<string, int> tmp;\n            for(k=0;k<m*wordn;k+=wordn){    \n                // cout<<temp.substr(k,wordn)<<endl;\n                if(!mp.count(temp.substr(k,wordn))){\n                    break;\n                }else{\n                    tmp[temp.substr(k,wordn)]++;\n                    if(tmp[temp.substr(k,wordn)]>mp[temp.substr(k,wordn)]){\n                        break;\n                    }                    \n                    cnt++;\n                }\n            }\n            if(k<m*wordn){\n            }else{\n                if(cnt==m){\n                    ans.push_back(i);\n                }\n                \n            }\n        }\n        return ans;\n    }\n};\n``` \n\n###\nO(n∗m∗k)\nO(m+n)空间复杂度是哈希表的长度，不知道需不需要乘以哈希表的每个单位长度。\n\n### 思路\n滑动窗口，不枚举了，右边扩张左边收缩，利用上回的信息。\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        if (words.size() == 0) return {};\n        unordered_map<string, int> need, window;\n        \n        for (string w : words) need[w]++;\n        int len=words[0].length();\n        \n        int left = 0, right = 0;\n        int valid = 0;\n        vector<int> res; // 记录结果\n        int i=0;\n        while(i<len){\n            left=i++;\n            right=left;\n            window.clear();valid = 0;\n            while (right < s.size()) {\n            string c = s.substr(right,len);\n            // cout<<c<<endl;\n            right+=len;\n            // 进行窗口内数据的一系列更新\n            if (need.count(c)) {\n                window[c]++;\n                // right+=len;\n                if (window[c] == need[c]) \n                    valid++;\n            }\n            // 判断左侧窗口是否要收缩\n            while ((right - left) >= (words.size()*len)) {\n                // 当窗口符合条件时，把起始索引加入 res\n                if (valid == need.size())\n                    res.push_back(left);\n                string d = s.substr(left,len);\n                // cout<<d<<endl;\n                left+=len;\n                // 进行窗口内数据的一系列更新\n                if (need.count(d)) {\n                    if (window[d] == need[d])\n                        valid--;\n                    window[d]--;\n            }\n        }\n    }\n        }\n    return res;   \n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326235782","body":"### 思路\n暴力n3超时，前缀和加hash\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> mp;\n        mp[0]=1;\n        int sum = 0, ans = 0;\n        for (auto num: nums) {\n            sum += num;\n            int modulus = (sum % k + k) % k;\n            if (mp.count(modulus)) {\n                ans += mp[modulus];\n            }\n            ++mp[modulus];\n        }\n        return ans;\n    }\n};\n```\n###\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327510796","body":"### 思路\n快慢指针，快的到了，慢的刚好一半。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* l=head,*r=head;\n        while(r!=nullptr){            \n            if(r->next!=nullptr){\n                l=l->next;r=r->next->next;\n            }\n            else{                \n                break;\n            }\n        }\n        return l;\n    }\n};\n```\n###\nO(N)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328018390","body":"### 思路\n就地往前复制\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int p=0;\n        for(int i=1;i<nums.size();i++){\n            if(nums[i]!=nums[p]){\n                nums[++p]=nums[i];\n            }\n        }\n        return p+1;\n    }\n};\n```\n\n### \nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328231358","body":"### 思路\n遍历\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int ans=nums.size();\n        for(int i=0;i<nums.size();i++){\n            if(nums[i]>=target){\n                return i;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n###\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328979240","body":"### 思路\n一开始觉得是优先队列，看了题解发现单调队列更快，将索引存队列，注意出的时候，由于后续有更大的需要把前面比他小的清除，应该popback的，第一次写成了popfront，导致中间小数没被删掉，有些不专心。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int mx=-1;\n        vector<int> ans;\n        list<int> l;\n        l.push_back(0);\n        for(int i=1;i<k;i++){        \n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            l.push_back(i);\n            // mx=max(mx,nums[i]);\n        }\n        ans.push_back(nums[l.front()]);\n        for(int i=k;i<nums.size();i++){\n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            l.push_back(i);            \n            // cout<<nums[i]<<\" \"<<nums[l.front()]<<endl; \n            while(l.front()<=i-k){\n                l.pop_front();\n            }\n            ans.push_back(nums[l.front()]);\n\n        }        \n        // for(auto a:l){\n        //     cout<<a<<endl;\n        // }\n        return ans;\n\n    }\n};\n```\n合并\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int mx=-1;\n        vector<int> ans;\n        list<int> l;\n        for(int i=0;i<nums.size();i++){\n            while(!l.empty()&&nums[l.back()]<nums[i]){\n                l.pop_back();\n            }\n            l.push_back(i);      \n            while(l.front()<=i-k){\n                l.pop_front();\n            }\n            if(i>=k-1)ans.push_back(nums[l.front()]);\n        }      \n        return ans;\n    }\n};\n```\n\n### \nO(n)\nO(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330193544","body":"### 思路\n因为互不相同，统计所有被信任的，计数，将所有符合n-1条件的进行判别，确定是不是唯一。\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int a[1010]={};\n        vector<int> ans;\n        map<int,int> m;\n        if(n==1)return 1;\n        for(int i=0;i<trust.size();i++){\n            m[trust[i][0]]=trust[i][1];\n            if(n-1==(++a[trust[i][1]])){\n                ans.push_back(trust[i][1]);\n            };\n        }\n        int an=-1;\n        for(int i=0;i<ans.size();i++){\n            if(m.count(ans[i])){\n            }else{\n                if(an==-1){\n                    an=ans[i];\n                }else{\n                    return -1;\n                }\n            }   \n        }\n        return an;\n    }\n};\n```\n\n### \nO(n)\n\n看题解是统计出度入度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332371201","body":"### 思路\n第一次当简单题做wa了，应该二分图并查集，最后看题解发现是图dfs\n\n### 代码\n```c++\nclass Solution {\n    vector<vector<int>> g;\n    vector<int> _colors;\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        g=vector<vector<int>>(n);\n        for(int i=0;i<dislikes.size();i++){\n            g[dislikes[i][0]-1].push_back(dislikes[i][1]-1);\n            g[dislikes[i][1]-1].push_back(dislikes[i][0]-1);\n        }\n        for(int i=0;i<n;i++){\n            for(auto a:g[i]){\n                cout<<i<<\":\"<<a<<\" \";\n            }\n            cout<<endl;\n        }\n        _colors = vector<int>(n, 0);\n        for (int i = 0; i < n; i++)\n            if (_colors[i] == 0 && !dfs(i, 1))\n                return false;\n        return true;\n    }\n    bool dfs(int cur,int color){\n        _colors[cur] = color;\n        for(int next:g[cur]){\n            if(_colors[next]==color)return false;\n            if(_colors[next]==0&&!dfs(next,-color))return false;\n        }\n        return true;\n    }\n};\n```\n并查集\n```c++\nclass Solution {\npublic:\n    int findFa(int x, vector<int>& fa) {\n        return fa[x] < 0 ? x : fa[x] = findFa(fa[x], fa);\n    }\n\n    void unit(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        if (x == y) {\n            return ;\n        }\n        if (fa[x] < fa[y]) {\n            swap(x, y);\n        }\n        cout<<fa[x]<<\" \"<<fa[y]<<endl;\n        fa[x] = fa[y];\n        fa[y] = x;\n        cout<<fa[x]<<\" \"<<fa[y]<<endl;\n    }\n\n    bool isconnect(int x, int y, vector<int>& fa) {\n        x = findFa(x, fa);\n        y = findFa(y, fa);\n        return x == y;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> fa(n + 1, -1);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j < g[i].size(); ++j) {\n                unit(g[i][0], g[i][j], fa);\n                if (isconnect(i, g[i][j], fa)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n###\nO(V+E)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333970120","body":"### 思路\n拓扑排序，看了题解，要对两个key排序，bfs\n\n### 代码\n```c++\nclass Solution {\npublic:\n\n    vector<int> topS(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> q;\n        for(auto item:items){\n            if(deg[item]==0)q.push(item);\n        }\n        vector<int> res;\n        while(!q.empty()){\n            int temp=q.front();\n            q.pop();\n            res.push_back(temp);\n            for(auto v:graph[temp]){\n                if(--deg[v]==0)q.push(v);\n            }\n        }\n        return res.size()==items.size() ? res:vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        vector<vector<int>> groupGra(n + m);\n        vector<vector<int>> itemGra(n);\n\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.push_back(i);\n        }\n        int leftId = m;\n        for (int i = 0; i < n; ++i) {\n            if(group[i]==-1){\n                group[i]=leftId++;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i]++;\n                    itemGra[item].push_back(i);\n                }else{\n                    groupDegree[curGroupId]++;\n                    groupGra[beforeGroupId].push_back(curGroupId);\n                }\n            }\n        }\n\n        vector<int> groupTopS=topS(groupDegree,groupGra,id);\n        if(groupTopS.size()==0){\n            return vector<int>{};\n        }\n        vector<int> ans;\n        for(auto& curGroupId:groupTopS){\n            int size=groupItem[curGroupId].size();\n            if(size==0)continue;\n            vector<int> res=topS(itemDegree,itemGra,groupItem[curGroupId]);\n            if(res.size()==0)return vector<int>{};\n            for(auto& item:res)ans.push_back(item);\n        }\n        return ans;\n    }\n};\n```\n\n### \nO(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334964140","body":"### 思路\n模拟\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x=0,y=0;\n        for(auto a:moves){\n            if(a=='U')y++;\n            else if(a=='D')y--;\n            else if(a=='L')x--;\n            else x++;\n        }\n        return x==0&&y==0;\n    }\n};\n```\n\n###\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336099839","body":"### 思路\n模拟，第一回想的是直接优先队列，把下标也结构体并进去，重写排序函数，但其实只有在等待队列的进程才需要进入优先队列，应该拆分，一个数组第一回排序，记录下标和到达时间，另一个时间戳到了去优先队列，小顶堆需要修改声明。\n另：emplace比push多了构造函数。\n\n```c++\nclass Solution {\npublic:\n\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        int n=tasks.size();\n        vector<int> ans;        \n        vector<pair<int,int>> v;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;       \n        \n        for(int i=0;i<tasks.size();i++){\n            pair<int,int> a;\n            a.first=tasks[i][0];\n            a.second=i;\n            v.push_back(a);\n        }\n        sort(v.begin(),v.end());\n        // for(auto vv:v){\n        //     cout<<vv.first<<\" \"<<vv.second<<endl;\n        // }\n        long long int time=0;\n        int pp=0;\n        for(int i=0;i<n;i++){\n            if(q.empty()){\n                time=max(time,(long long int)tasks[v[pp].second][0]);\n            }\n            while(pp<n&&tasks[v[pp].second][0]<=time){\n                q.emplace(tasks[v[pp].second][1],v[pp].second);\n                ++pp;\n            }\n            auto && [pro,ind]=q.top();\n            time+=pro;\n            ans.push_back(ind);\n            q.pop();\n        }\n\n        // int time=v[0].first;\n        // ans.push_back(v[0].second);\n        // time+=tasks[v[0].second][1];\n\n        // cout<<\"!!\"<<endl;\n        // int time=0;\n        // while(!q.empty()){\n        //     pair<int,int>a;\n        //     a=q.top();\n        //     time=a.first;\n        //     cout<<q.top().first<<\" \"<<q.top().second<<endl;\n        //     q.pop();\n        // }\n        return ans;\n    }\n};\n```\n\n### \nO(nlogn)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336205869","body":"### 思路\n模拟，中间整块的小时*4，非整块单独处理，借由flag表示是否借位。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int ans=0;\n        string inhs=loginTime.substr(0,2);\n        string inms=loginTime.substr(3,2);\n        int inh=atoi(inhs.c_str());\n        int inm=atoi(inms.c_str());\n        // cout<<inh<<\" \"<<inm<<endl;\n        string ouths=logoutTime.substr(0,2);\n        string outms=logoutTime.substr(3,2);\n        int outh=atoi(ouths.c_str());\n        int outm=atoi(outms.c_str());\n        // cout<<ouths<<\" \"<<outms<<endl;\n        int h=0;\n        int flag=0;\n        if(outh<inh){\n            h+=24-inh;\n            h+=outh;\n        }else if(outh==inh&&outm<inm){\n            h+=24-inh;\n            h+=outh;\n        }\n        else{\n            h=outh-inh;\n        }\n        if(outh==inh&&outm>=inm)h=0;\n        else if(outm<inm||inm>0){\n           h--;\n           flag=1;\n        }        \n        ans+=h*4;\n        // cout<<h<<\":\"<<flag<<endl;\n        // cout<<inm<<\" \"<<outm<<endl;\n\n        if(0<inm&&inm<15||inm==15){\n            inm=15;\n        }else if(inm<30&&inm>15||inm==30){\n            inm=30;\n        }else if(inm<45&&inm>30||inm==45){\n            inm=45;\n        }else if(inm==0){\n            inm=0;\n        }else{\n            inm=60;\n        }\n        \n        if(0<outm&&outm<15||outm==0){\n            outm=0;\n        }else if(outm<30||outm==15){\n            outm=15;\n        }else if(outm<45||outm==30){\n            outm=30;\n        }else{\n            outm=45;\n        }\n        \n        if(outm<inm && flag==0) return ans;\n        else if(flag==1){outm+=60;}\n        // cout<<inm<<\" \"<<outm<<endl;\n        int m=outm-inm;\n        ans+=m/15;\n        return ans;\n    }\n};\n```\n看了题解转化成分钟，简直背过气。。。\n```c++\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int ans=0;\n        string inhs=loginTime.substr(0,2);\n        string inms=loginTime.substr(3,2);\n        int inh=atoi(inhs.c_str());\n        int inm=atoi(inms.c_str());\n        int t0=inh*60+inm;\n        cout<<t0<<endl;\n        string ouths=logoutTime.substr(0,2);\n        string outms=logoutTime.substr(3,2);\n        int outh=atoi(ouths.c_str());\n        int outm=atoi(outms.c_str());\n        int t1=outh*60+outm;\n        cout<<t1<<endl;\n        if(t0>t1){\n            t1+=1440;\n        }\n        if(t0%15){\n            t0=(t0+15)/15*15;\n        }\n        t1=t1/15*15;\n        return max(0,(t1-t0))/15;\n        // cout<<ouths<<\" \"<<outms<<endl;\n\n    }\n};\n```\n化简后\n```c++\nclass Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if(t0>t1){\n            t1+=1440;\n        }       \n        t1=t1/15*15;\n        return max(0,(t1-t0))/15;\n    }\n};\n```\n\n###\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337081627","body":"### 思路\n枚举26个字母，表示在当前这个字母为分割时三种条件变化情况，a表示A全为大于a的，B全为a和小于a的；或反之；或全是a。故z时没有大于z的了，只有条件三。\n\n```c++\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        int ans=INT_MAX;\n        int ac[26]={0};\n        int bc[26]={0};\n        for(auto &aa:a){\n            ac[aa-'a']++;\n        }\n        for(auto &bb:b){\n            bc[bb-'a']++;\n        }\n        int asum=0,bsum=0;\n        for (int i = 0; i < 25; i++) {\n            asum+=ac[i];\n            bsum+=bc[i];\n            // 相同的话 变化次数是两次总和差值之和      \n            ans=min(min(ans,(int)a.size()-ac[i]+(int)b.size()-bc[i]), min((int)a.size()-asum+bsum, (int)b.size()-bsum+asum));\n        }\n        ans=min(ans,(int)a.size()-ac[25]+(int)b.size()-bc[25]);\n        return ans;\n    }\n};\n```\n\n### \nO(m+n)\nO(26)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339214281","body":"```c++\nclass Solution {\n    int partition(vector<int>& q, int l, int r) {\n        if (l >= r) return -1;\n\n        int i = l - 1, j = r + 1, x = q[(l+r) >> 1];\n        while (i < j) {\n            do i++; while(q[i] < x);\n            do j--; while(q[j] > x);\n            if (i < j) swap(q[i], q[j]);\n        }\n        return j;\n\n        \n        // int pivot = nums[r];\n        // int i = l - 1;\n        // for (int j = l; j <= r - 1; ++j) {\n        //     if (nums[j] <= pivot) {\n        //         i = i + 1;\n        //         swap(nums[i], nums[j]);\n        //     }            \n        // }\n        // swap(nums[i + 1], nums[r]);\n        // return i + 1;\n    }\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\n        if (l < r) {\n            int pos = partition(nums, l, r);\n            randomized_quicksort(nums, l, pos);\n            randomized_quicksort(nums, pos + 1, r);\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {;\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n```\n处理重复多的位置","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340988107","body":"### 思路\n牛顿迭代\n```c++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if(x==0)return 0;\n        double c=x,x0=x;\n        while(1){\n            double xi=0.5*(x0+c/x0);\n            if(fabs(x0-xi)<1e-6){\n                break;\n            }\n            x0=xi;\n        }\n        return (int) x0;\n    }\n};\n```\n二分\n```c++\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        long long int l = 1, r = x, mid;\n        while(l <= r){\n            mid = (r+l)/2;\n            if(x/mid > mid) l = mid + 1;\n            else if (x/mid < mid) r = mid - 1;\n            else return mid;\n        }\n        return r;\n    }\n};\n```\n\n###\nO(logx)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341341590","body":"### 思路\n二分\n\n```c++\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int l=1,r=n;\n        while(l<r){\n            int mid=l+(r-l)/2;\n            if(isBadVersion(mid))r=mid;\n            else{l=mid+1;}\n        }\n        return l;\n    }\n};\n```\n\n### \nO(logn)\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344438624","body":"### 思路\n看了题解归并，一会补树状数组\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int mergeSort(vector<int>& nums, int l,int r){\n        if(l==r)return 0;\n        else{\n            int mid=(l+r)/2;\n            int n1=mergeSort(nums,l,mid);\n            int n2=mergeSort(nums,mid+1,r);\n            int res=n1+n2;\n\n            int i=l;\n            int j=mid+1;\n            // for(int i=l;i<=mid;i++){\n            //     for(int j=mid+1;j<=r;){\n            //         if((long long)nums[i] > 2 * (long long)nums[j])j++;\n            //         res+=(j-mid-1);\n            //     }\n            // }\n            while (i <= mid) {\n                while (j <= r && (long long)nums[i] > 2 * (long long)nums[j]) j++;\n                res += (j - mid - 1);\n                i++;\n            }\n\n            // vector<int> sorted(r-l+1);\n            // int p1=l,p2=mid+1;\n            // int p=0;\n            // while(p1<=mid||p2<=r){\n            //     if(p1>mid){\n            //         sorted[p++]=nums[p2++];\n            //     }else if(p2>r){\n            //         sorted[p++]=nums[p1++];\n            //     }else{\n            //         if(nums[p1]<nums[p2]){\n            //             sorted[p++]=nums[p1++];\n            //         }else{\n            //             sorted[p++]=nums[p1++];\n            //         }\n            //     }\n            // }\n\n            vector<int> sorted(r - l + 1);\n            int p1 = l, p2 = mid + 1;\n            int p = 0;\n            while (p1 <= mid || p2 <= r) {\n                if (p1 > mid) {\n                    sorted[p++] = nums[p2++];\n                } else if (p2 > r) {\n                    sorted[p++] = nums[p1++];\n                } else {\n                    if (nums[p1] < nums[p2]) {\n                        sorted[p++] = nums[p1++];\n                    } else {\n                        sorted[p++] = nums[p2++];\n                    }\n                }\n            }\n            \n            for (int i = 0; i < sorted.size(); i++) {\n                nums[l + i] = sorted[i];\n            }\n            return res;\n        }\n    }\n\n\n    int reversePairs(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        return mergeSort(nums, 0, nums.size() - 1);\n    }\n};\n```\n\n###\nO(Nlog⁡N)\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345285743","body":"### 思路\n475\n二分查找到最近的加热器，看一前一后哪个近，取最远的最近距离。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int find(vector<int>&heaters,int house){\n        int l=0,r=heaters.size()-1;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(heaters[mid]==house)return mid;\n            else if(heaters[mid]<house){\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return l;\n    }\n    int findRadius(vector<int>& houses, vector<int>& heaters) {\n        int ans=0;\n        sort(heaters.begin(),heaters.end());\n        for(auto& h:houses){\n            // int j=upper_bound(heaters.begin(),heaters.end(),h)-heaters.begin();\n            int j=find(heaters,h);\n            cout<<j<<endl;\n            int r=j>=heaters.size()?INT_MAX:heaters[j]-h;\n            cout<<r<<endl;\n            int l=j<1?INT_MAX:h-heaters[j-1];\n            cout<<l<<endl;\n            int cur=l<r?l:r;\n            cout<<\"cur:\"<<cur<<endl;\n            ans=ans<cur?cur:ans;\n        }\n        return ans;\n    }\n};\n```\n\n###\nO((n+m)logn)\nO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345513379","body":"### 思路\n排序+二分，看题解，还可以双指针。\n二分两次，一次对k次，一次对距离，对距离算次数。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int find(vector<int>&heaters,int j,int house){\n        int l=0,r=j-1;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(heaters[mid]==house)r=mid-1;\n            else if(heaters[mid]<house){\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return l;\n    }\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(),nums.end());\n        int n=nums.size(),l=0,r=nums[n-1]-nums[0];\n        while(l<=r){\n            int mid=(l+r)/2;\n            int cnt=0;\n            for(int i=0;i<n;i++){\n                // int j=lower_bound(nums.begin(),nums.begin()+i,nums[i]-mid)-nums.begin();\n                int j=find(nums,i,nums[i]-mid);\n                cnt+=i-j;\n            }\n            if(cnt>=k){\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n###\nO(nlogn×logD)\nO(log⁡n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346039921","body":"### 思路\n第一反应并查集，想起来二分专题，那应该就是二分值，dfs看到没到。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool dfs(int value, int x,int y,vector<vector<int>>& visited, vector<vector<int>>& grid){\n        if(x > grid.size() - 1 || x < 0 || y > grid[0].size() - 1 || y < 0) return false;\n        if(grid[x][y]>value)return false;\n        if (x == grid.size() - 1 && y == grid[0].size() - 1) return true;\n        if(visited[x][y]==1)return false;\n        visited[x][y]=1;\n        if(dfs(value,x+1,y,visited,grid)||dfs(value,x-1,y,visited,grid)||dfs(value,x,y+1,visited,grid)||dfs(value,x,y-1,visited,grid))return true;\n        else return false;\n\n    }\n    int swimInWater(vector<vector<int>>& grid) {\n        int l=0,r=-1;\n        int row=grid.size();\n        int col=grid[0].size();\n        for (int i = 0; i < row; i++) {\n            for (int j = 0; j < grid[i].size(); j++) r = max(r, grid[i][j]);\n        }\n        \n        while(l<=r){\n            vector<vector<int>> visited(row,vector<int>(col, 0));\n            int mid=(l+r)/2;\n            if(dfs(mid,0,0,visited,grid)){\n                r=mid-1;\n            }else{\n                l=mid+1;\n            }\n        }\n        return l;\n    }\n};\n```\n\n### \nO(n^2log⁡n)\nO(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348060739","body":"### 思路\n滑动窗口，双指针维护k区间，记录有几个元音，维护一个最大值\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxVowels(string s, int k) {\n        int n=s.length();\n        int l=0,r=0;\n        int cnt=0;\n        int ans=0;\n        while(r<=n){\n            if(r-l<k){\n                if(s[r]=='a'||s[r]=='e'||s[r]=='i'||s[r]=='o'||s[r]=='u'){\n                    cnt++;\n                }\n                r++;\n            }else if((r-l)==k){\n                ans=max(ans,cnt);\n                if(s[l]=='a'||s[l]=='e'||s[l]=='i'||s[l]=='o'||s[l]=='u'){\n                    cnt--;\n                }l++;\n            }\n        }        \n        return ans;\n    }\n};\n```\n\n###\nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351000830","body":"### 思路\n看了题解dp+滑动窗口，维护中间滚动数组，从后往前填字，注意边界情况，n与k与maxpts的关系范围。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        if(k==0)return 1;\n        vector<double> dp(k+maxPts);\n        for(int i=min(n,k+maxPts-1);i>=k&&i<maxPts+k;i--){\n            dp[i]=1.0;\n        }\n        double cnt=min(n-k+1, maxPts);\n        // cout<<cnt<<endl;\n        for(int i=k-1;i>=0;i--){\n            dp[i]=cnt*1/maxPts;\n            // cout<<i<<\":\"<<dp[i+maxPts]<<\" \"<<dp[i]<<endl;\n            cnt=cnt-dp[i+maxPts]+dp[i];   \n            // cout<<cnt<<endl;      \n        }\n        return dp[0];\n    }\n};\n```\n\n### \nO(min⁡(n,k+maxPts))\nO(k+maxPts)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352849007","body":"### 思路\n开始没想明白怎么计算相同，以为得排序，其实可以用cnt和全0的比。\n滑动窗口\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> findAnagrams(string s, string p) {\n        vector<int> ans;\n        vector<int> cnt(26);\n        vector<int> zero(26);\n        for(auto &c:p){\n            cnt[c-'a']++;\n        }\n        int l=0,r=0;\n        int len=p.length();\n        while(r<s.length()){\n            if(r-l<len){\n                cnt[s[r++]-'a']--;\n            }else if(r-l==len){\n                if(cnt==zero){\n                    ans.push_back(l);\n                }\n                cnt[s[l++]-'a']++;\n            }else{\n                \n            }\n        }\n        // cout<<cnt[s[s.length()-1]-'a']<<endl;\n        if(cnt==zero){\n                    ans.push_back(l);\n                }\n        return ans;\n    }\n};\n```\n\n### \nO(n)\nO(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354336441","body":"### 思路\n滑动窗口\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        if(s.length()<t.length())return \"\";\n        string ans;\n        int n=INT_MAX;\n        unordered_map<char, int> need, window;\n        for (char c : t) need[c]++;\n        // cout<<need.size()<<endl;\n        \n        int left = 0, right = 0;\n        int valid = 0; \n        int cnt=t.size();\n        while (right < s.size()) {\n            // c 是将移入窗口的字符\n            char c = s[right];\n            // 右移窗口\n            right++;\n            // 进行窗口内数据的一系列更新\n            if(need.count(c)){\n                window[c]++;\n                if(window[c]==need[c]){\n                    valid++;\n                }\n            }\n\n            /*** debug 输出的位置 ***/\n            printf(\"window: [%d, %d) %d \\n\", left, right,valid);\n            /********************/\n\n            // 判断左侧窗口是否要收缩\n            while (valid == need.size()) {\n                // cout<<(right-left)<<endl;\n                    if(n>(right-left)){                        \n                        ans=s.substr(left,right-left);\n                        n=right-left;\n                    }\n                         \n                // d 是将移出窗口的字符\n                char d = s[left];\n                // 左移窗口\n                left++;\n                // 进行窗口内数据的一系列更新\n                if(need.count(d)){                    \n                    if(window[d]==need[d]){\n                        valid--;\n                    }\n                    window[d]--;\n                }\n            }\n            \n        }\n        return ans;\n    }\n};\n```\n\n###\nO(N+K)\nO(C)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356125159","body":"### 思路\nleetcode 1423\n滑动窗口，先统计正着k个，然后开始滚倒数，维护一个最大值。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxScore(vector<int>& cardPoints, int k) {\n        int ans=0,index=0;\n        for(int i=0;i<k;i++){\n            index+=cardPoints[i];\n        }\n        ans=max(ans,index);\n        int n=cardPoints.size();\n        for(int j=0;j<k;j++){\n            index=index-cardPoints[k-j-1]+cardPoints[n-1-j];\n            ans=max(ans,index);\n        }\n        return ans;\n    }\n};\n```\n\n### \nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1359571743","body":"### 思路\r\n枚举，看了题解 __builtin_popcount( )计算有几个二进制1很好用。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<string> readBinaryWatch(int turnedOn) {\r\n        vector<string> ans;\r\n        if(turnedOn>=9)return {};\r\n        for(int i=0;i<1024;i++){\r\n            int h=i>>6,m=i&63;\r\n            if(h<12&&m<60&&__builtin_popcount(i)==turnedOn){\r\n                ans.push_back(to_string(h)+\":\"+(m<10?\"0\"+to_string(m):to_string(m)));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n###\r\nO(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1362540261","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int res=0;\r\n    // x & -x ：得到最低位的 1 代表除最后一位 1 保留，其他位全部为 0\r\n\r\n//  x & (x-1)：清零最低位的 1 代表将最后一位 1 变成 0\r\n\r\n// x & ((1 << n) - 1)：将 x 最高位至第 n 位(含)清零\r\n    void dfs(int n,int row,int col,int pie,int na){\r\n        if(row>=n){\r\n            res++;\r\n            return;\r\n        }\r\n        int bits= ~(col | pie | na) & ((1 << n) - 1);\r\n        while(bits){\r\n            int p=bits&-bits;\r\n            bits=bits&(bits-1);\r\n            dfs(n,row+1,col|p,(pie|p)<<1,(na|p)>>1);\r\n        }\r\n    }\r\n    int totalNQueens(int n) {\r\n        dfs(n,0,0,0,0);\r\n        return res;\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359607543","body":"### 思路\n并查集，维护秩，用了并查集模板\n\n### 代码\n```c++\nclass UnionFind\n{\n    private:\n        vector<int> father;\n        vector<int> rank;//按秩合并\n        vector<int> area;\n        int ans;\n    public:\n        UnionFind(vector<vector<int> >& grid)\n        {\n            ans=0;\n            int row=grid.size(),col=grid.front().size();\n            father.assign(row*col,0);\n            rank.assign(row*col,0);\n            area.assign(row*col,1);\n            for(int i=0;i<row;++i)\n            for(int j=0;j<col;++j)\n            {\n                if(grid[i][j]==1)\n                ans=1;\n                father[i*col+j]=i*col+j;\n            }\n        }\n        int find(int x)\n        {\n            return x==father[x]?x:(father[x]=find(father[x]));//路径压缩\n        }\n        void Union(int x,int y)//按秩合并\n        {\n            int fx=find(x),fy=find(y);\n            if(fx==fy)\n            return;\n            if(rank[fx]>rank[fy])\n            {\n                father[fy]=fx;\n                area[fx]+=area[fy];\n            }\n            else if(rank[fy]>rank[fx])\n            {\n                father[fx]=fy;\n                area[fy]+=area[fx];\n            }\n            else\n            {\n                area[fx]+=area[fy];\n                father[fy]=fx;\n                ++rank[fx];\n            }\n            ans=max(ans,max(area[fy],area[fx]));\n        }\n        int solve()\n        {\n            return ans;\n        }\n};\n\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        if(grid.empty()||grid.front().empty())return 0;\n        UnionFind uf(grid);\n        int r=grid.size(),c=grid[0].size();\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]==1){\n                    grid[i][j]==0;\n                    if(i>0&&grid[i-1][j]==1)uf.Union(i*c+j,(i-1)*c+j);\n                    if(i<r-1&&grid[i+1][j]==1)uf.Union(i*c+j,(i+1)*c+j);\n                    if(j>0&&grid[i][j-1]==1)uf.Union(i*c+j,i*c+j-1);\n                    if(j<c-1&&grid[i][j+1]==1)uf.Union(i*c+j,i*c+j+1);\n                }\n            }\n        }\n        return uf.solve();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361472792","body":"### 思路\nbfs\n把陆地放入队列开始拓展，没有就是-1，倒着找就是最短路。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxDistance(vector<vector<int>>& grid) {\n        int dx[4]={0,1,0,-1};\n        int dy[4]={1,0,-1,0};\n        int n=grid.size();\n        queue<pair<int,int>> q;\n        vector<vector<int>> d(n,vector(n,INT_MAX));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==1){\n                    q.push({i,j});\n                    d[i][j]=0;\n                }\n            }\n        }\n\n        while(!q.empty()){\n            auto k=q.front();\n            q.pop();\n            for(int i=0;i<4;i++){\n                int newx=k.first+dx[i];\n                int newy=k.second+dy[i];                \n                if(newx>-1&&newx<n&&newy>-1&&newy<n){                    \n                    if(d[newx][newy]>d[k.first][k.second]+1){\n                        d[newx][newy]=d[k.first][k.second]+1;\n                        q.push({newx,newy});\n                    }\n                }\n            }\n        }\n            int res=-1;\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(grid[i][j]==0&&d[i][j]<1000)res=max(res,d[i][j]);\n                }\n            }\n            return res;        \n    }\n};\n```\n\n### \nO(N^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362649410","body":"```python3\nclass Solution:\n    def solve(self, graph, target):\n        q = collections.deque([target])\n        visited = set()\n        steps = 0\n        while q:\n            for i in range(len(q)):\n                cur = q.popleft()\n                visited.add(cur)\n                for neighbor in graph[cur]:\n                    if neighbor not in visited:\n                        q.append(neighbor)\n                    elif neighbor == target:\n                        return steps + 1\n            steps += 1\n        return -1\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363801189","body":"### 思路\ndfs+排序\n\n### 代码\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    typedef struct{\n        int val;\n        int r;\n        int l;\n    }treeno;\n    \n    static bool cmp(treeno a,treeno b)\n    {\n        if(a.l<b.l)return true;\n        else if(a.l==b.l){\n            if(a.r<b.r)return true;\n            else if(a.r==b.r){\n                return a.val<b.val;\n            }\n            else{\n                return false;\n            }\n        }\n        else{\n            return false;\n        }     \n    }\n    vector<treeno> temp;\n    int dfs(TreeNode* root,int r,int l){\n        if(root==nullptr)return 0;        \n        else{\n            treeno st;\n            st.val=root->val;\n            st.r=r;\n            st.l=l;\n            temp.push_back(st);\n            dfs(root->left,r+1,l-1);\n            dfs(root->right,r+1,l+1);\n            return 1;\n        }\n    }\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        vector<vector<int>> ans;\n        vector<int> t;       \n        dfs(root,0,0);\n        sort(temp.begin(),temp.end(),cmp);\n        int index=temp.front().l;\n        for(int i=0;i<temp.size();i++){\n            if(index==temp[i].l){\n                t.push_back(temp[i].val);\n            }\n            else{\n                index=temp[i].l;\n                ans.push_back(t);\n                t.clear();\n                i--;\n            }\n            // cout<<temp[i].val<<\" \";\n        }\n        ans.push_back(t);\n        return ans;\n    }  \n};\n```\n\n### \nO(nlogn)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364495600","body":"### 思路\ndp\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        vector<int> ans;\n        ans.push_back(cost[0]);\n        ans.push_back(cost[1]);\n        for(int i=2;i<cost.size();i++){\n            int t=min(ans[i-1],ans[i-2])+cost[i];ans.push_back(t);\n        }\n        return min(ans[cost.size()-1],ans[cost.size()-2]);\n    }\n};\n```\n\n###\nO(N)\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364666612","body":"```c++\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int f1=0,f2=0;\n        for(int i=0;i<nums.size();i++){\n            int f0=max(f1+nums[i],f2);f1=f2; \n            f2=f0;                       \n        }\n        return f2;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365252414","body":"### 思路\n dp[i][0] 表示 以 nums[i] 结尾的最长上升子序列的长度，dp[i][1] 表示 以 nums[i] 结尾的长度为 dp[i][0] 的子序列的个数\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> dp1(n+1,1);\n        vector<int> dp2(n+1,1);\n        int longmax=1;\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(nums[j]>nums[i]){\n                    if(dp1[i]+1>dp1[j]){\n                        \n                        dp1[j]=dp1[i]+1;\n                        dp2[j]=dp2[i];\n                        longmax=max(longmax,dp1[j]);\n                    }else if(dp1[i]+1==dp1[j]){\n                        dp2[j]+=dp2[i];\n                    }\n                }\n            }\n        }\n        int ans=0;\n        // cout<<longmax<<endl;\n        for(int i=0;i<n;i++){\n            // cout<<dp1[i]<<endl;\n            if(dp1[i]==longmax){\n                ans+=dp2[i];\n                \n            }\n        }\n        return ans;\n    }\n};\n```\n\n###\nO(n^2)\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365749865","body":"```c++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int n1=text1.size(),n2=text2.size();\n        vector<vector<int>> dp(n1+1,vector<int>(n2+1));\n        for(int i=0;i<n1;i++){\n            for(int j=0;j<n2;j++){\n                if(text1[i]==text2[j]){\n                    dp[i+1][j+1]=dp[i][j]+1;\n                }else{\n                    dp[i+1][j+1]=max(dp[i][j+1],dp[i+1][j]);\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366557487","body":"### 思路\ndp[i][j]=dp[i-1][j]+dp[i][j-1];\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> dp(m,vector<int>(n,1));\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n    }\n};\n```\n\n###\nO(M∗N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367158834","body":"### 思路\n看了题解，每个格子放概率，累加。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<vector<int>> dirs={{-2,-1},{-2,1},{2,-1},{2,1},{-1,-2},{-1,2},{1,2},{1,-2}};\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(k+1,vector<vector<double>>(n,vector<double>(n)));\n        // cout<<dp[0][1][1]<<endl;\n        for(int s=0;s<=k;s++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    if(s==0)dp[s][i][j]=1;else{\n                        for(auto&dir:dirs){\n                        int ni=i+dir[0],nj=j+dir[1];\n                        if(ni>=0&&ni<n&&nj>=0&&nj<n){\n                            dp[s][i][j]+=dp[s-1][ni][nj]/8;\n                        }\n                    }\n                    }\n                    \n                }\n            }\n        }\n        return dp[k][row][column];\n    }\n};\n```\n###\nO(k×n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367867656","body":"### 思路\n状态压缩dp每一位表示第i个位置是否被选\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChoosableInt; \n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        maxChoosableInt=maxChoosableInteger;\n        int sum=(1+maxChoosableInteger)*maxChoosableInteger/2;\n        // cout<<sum<<endl;\n        if(sum<desiredTotal)return false;\n        if(maxChoosableInteger>=desiredTotal)return true;\n        unordered_map<int,int> d;\n        return dfs(0,desiredTotal,0,d);\n    }\n    bool dfs(int s,int t,int S,unordered_map<int,int>& d){\n        if(d[S])return d[S];\n        int& ans=d[S];\n        if(s>=t)return ans=true;\n        // if(S==(((1<<maxChoosableInt)-1)<<1))return ans=false;//11111110\n        if(S == (1 << (maxChoosableInt + 1)) - 1)return false;\n\n        for(int m=1;m<=maxChoosableInt;++m){\n            if(S&(1<<m))continue;//第m位是否为1，in 操作符\n            int nextS=S|(1<<m);//add 操作\n            if(s+m>=t)return ans=true;\n            bool r1=dfs(s+m,t,nextS,d);\n            if(!r1)return ans=true;\n        }\n        return ans=false;\n    }\n};\n```\n\n###\n O(2^n×n)\n O(2^n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368019912","body":"### 思路\n一开始以为是dfs，看了题解dp，dp[i][j]表示第i个nums下能否构成j值，dp[i][target]=dp[i-1][target-nums[i]]||dp[i-1][target],\n记 F[i, target] 为 nums 数组内前 i 个数能否构成和为 target 的子序列的可能，则状态转移方程为\nF[i, target] = F[i - 1, target] || F[i - 1, target - nums[i]]\n\n### 代码\n```c++\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        // sort(nums.begin(),nums.end());\n        int sum=0;\n        for(auto num:nums){\n            sum+=num;\n        }\n        if(sum%2)return false;\n        sum/=2;\n        int n=nums.size();\n        vector<vector<bool>> dp(n,vector<bool>(sum+1));\n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        \n        for(int i=0;i<n-1;i++){            \n            for(int j=0;j<sum+1;j++){\n                // cout<<nums[i]<<endl;\n                if(j<nums[i]){\n                    dp[i+1][j]=dp[i][j];\n                }else{\n                    dp[i+1][j]=dp[i][j-nums[i]]||dp[i][j];\n                }\n            }\n        }\n        return dp[nums.size()-1][sum];\n    }\n};\n```\n\n###\nO(n×target)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368445443","body":"### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findTargetSumWays(vector<int>& nums, int target) {\r\n        int sum=0;\r\n        for(auto num:nums){\r\n            sum+=num;\r\n        }\r\n         if((sum+target)%2||abs(target)>abs(sum))return 0;\r\n        int p=(sum+target)/2;\r\n        int n=nums.size();\r\n        // vector<vector<int>> dp(p+1,vector<int>(n+1));\r\n        vector<int> dp(sum+1);\r\n        dp[0]=1;\r\n        for(int i=0;i<n;i++){\r\n            for(int j=p;j>=nums[i];j--){\r\n                dp[j]+=dp[j-nums[i]];\r\n            }\r\n        }\r\n        // for(int i=0;i<n;i++){\r\n        //     dp[i][0]=1;\r\n        // }\r\n        \r\n        // for(int i=0;i<=p;i++){   \r\n        //     // cout<<\"!!!\"<<i<<endl;         \r\n        //     for(int j=1;j<n+1;j++){               \r\n        //         dp[i][j]=dp[i][j-1];\r\n        //         if(i>=nums[j-1]){\r\n        //             dp[i][j]+=dp[i-nums[j-1]][j-1];\r\n        //         }\r\n        //     }\r\n        // }\r\n        return dp[p];\r\n    }\r\n};\r\n```\r\n还可以递归\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int dfs(vector<int>& nums, uint t,int x){\r\n        if(t==0&&x==nums.size()){\r\n            return 1;\r\n        }\r\n        if(x>=nums.size())return 0;\r\n        int ans=0;\r\n        ans+=dfs(nums,t-nums[x],x+1);\r\n        ans+=dfs(nums,t+nums[x],x+1);\r\n        return ans;\r\n    }\r\n    int findTargetSumWays(vector<int>& nums, int S) {\r\n        return dfs(nums,S,0);\r\n    }\r\n};\r\n```\r\n\r\n时间复杂度：O((negative∗(total+target))/2)\r\n\r\n空间复杂度：O((total+target)/2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368970170","body":"### 思路\ndp或dfs\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        // dp[i]表示组成金额 i 所需要最少的硬币数量\n        vector<int> dp(amount+1,amount+1); // 大小，初值\n        dp[0]=0;\n        for(int i=1;i<=amount;i++){\n            for(int j=0;j<coins.size();j++){\n                if(coins[j]<=i)\n                    dp[i]=min(dp[i],dp[i-coins[j]]+1);\n            }\n        }\n        return dp[amount]>amount?-1:dp[amount];\n    }\n};\n```\n\n```c++\nclass Solution {\npublic:\n    vector<int>count;\n    int dp(vector<int>& coins, int rem){\n        if(rem<0)return -1;\n        if(rem==0)return 0;\n        if(count[rem-1]!=0)return count[rem-1];\n        int minCost = INT_MAX;\n        for(int coin:coins){\n            int res = dp(coins, rem - coin);                    \n            if(res >= 0 && res<minCost){\n                minCost=res+1;\n            }\n        }\n        count[rem-1] = minCost == INT_MAX ? -1:minCost;\n        return count[rem-1];\n    }\n    int dfs(vector<int>& coins, int amount,int ind){\n        if(amount == 0)return 0;\n        if(ind < coins.size() && amount > 0){\n            int maxVal = amount / coins[ind];\n            int minCost = INT_MAX;\n            for(int x = 0;x <= maxVal; x++){\n                if(amount >= x * coins[ind]){\n                    int res = dfs(coins, amount - x * coins[ind], ind+1);                    \n                    if(res != -1){\n                        minCost = min(minCost,res + x);cout<<res<<endl;\n                    }\n                }\n            }\n            return minCost == INT_MAX ? -1:minCost;\n        }\n        return -1;\n    }\n    int coinChange(vector<int>& coins, int amount) {\n        count.resize(amount);\n        return dp(coins,amount);\n    }\n};\n```\n\n###\nO(N∗amount)\nO(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369594636","body":"### 思路\ndp，二维的话定义状态 dp[i][j] 为使用前 i 个硬币组成金额 j 的组合数。\n\n则有状态转移方程为：\n\ndp[i][j] = dp[i-1][j] + dp[i][j - coins[i]]\n\n其中 dp[i-1][j] 为不选择 coins[i] 的组合数， dp[i]j - coins[i]] 为选择 coins[i] 的组合数。\n\n由于 dp[i][j] 仅仅依赖 dp[i-1][...] 因此使用滚动数组可以进行空间优化。优化后的转移方程为：\n\ndp[i] = dp[i] + dp[i - coins[j]]\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        // vector<int> dp(amount+1);\n        int n=coins.size();\n        vector<vector<int>> dp(n+1, vector<int> (amount+1));\n        // for(int i=0;i<=amount;i++){\n        //     dp[0][i]=1;dp[i][0]=1;\n        // }\n        dp[0][0]=1;        \n        for (int i = 1; i <= n; i++) {\n            int val = coins[i - 1];\n            for (int j = 0; j <= amount; j++) {\n                dp[i][j] = dp[i - 1][j];\n                for (int k = 1; k * val <= j; k++) {\n                    dp[i][j] += dp[i - 1][j - k * val];  \n                }\n            }\n        }\n   \n        return dp[n][amount];\n    }\n};\n```\n一维\n```c++\nclass Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount+1);\n        dp[0]=1;\n        int n=coins.size();\n        for(int i=0;i<n;i++){\n            for(int j=coins[i];j<=amount;j++){\n                dp[j]+=dp[j-coins[i]];\n            }\n        }\n        return dp[amount];\n    }\n};\n```\n\n###\nO(m*n)\nO(m)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370900779","body":"```c++\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        sort(g.begin(),g.end());\n        sort(s.begin(),s.end());\n        int ans=0;\n        int l=0,r=0;\n        while(r<s.size()&&l<g.size()){\n            if(s[r]>=g[l]){\n                ans++;\n                r++;\n                l++;\n            }\n            else{\n                r++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n###\nO(nlogn)\nO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372002314","body":"### 思路\n贪心\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\n        if(intervals.empty()){\n            return 0;\n        }\n\n        sort(intervals.begin(),intervals.end(),[](const auto& u,const auto& v){return u[1]<v[1];});\n        int n=intervals.size();\n        int right=intervals[0][1];\n        int ans=1;\n        for(int i=1;i<n;i++){\n            if(intervals[i][0]>=right){\n                ans++;\n                right=intervals[i][1];\n            }\n        }\n        return n-ans;\n    }\n};\n```\n\n###\nO(nlog⁡n)\nO(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373342281","body":"### 思路\n双指针\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int numRescueBoats(vector<int>& people, int limit) {\n        sort(people.begin(),people.end());\n        int n=people.size();\n        int l=0;\n        int r=n-1;\n        int ans=0;\n        while(l<=r){\n            if(l!=r && people[r]+people[l]<=limit){\n                r--;\n                l++;\n                ans++;\n            }else{\n                r--;\n                ans++;\n            }\n        }\n        // int temp=limit;\n        // vector<bool> vis(n,false);\n        // for(int i=n-1;i>=0;i--){\n        //     if(vis[i]==false){\n        //       if(limit>=people[i]){\n        //         temp=limit-people[i];\n        //         vis[i]=true;                \n        //     }                        \n        //     int ind=-1;\n        //     for(int j=i-1;j>=0;j--){\n        //         if(vis[j]==false){\n        //             // cout<<j<<endl;\n        //             if(temp>=people[j]){\n        //                 ind=j;\n        //                 break;\n        //             }\n        //         }\n        //     }\n        //     // cout<<ind<<endl;\n        //     if(ind<0){\n        //         ans++;\n        //     }else{\n        //         vis[ind]=true;\n        //         ans++;\n        //     }\n              \n        //     }\n            \n        // }\n        return ans;\n    }\n};\n```\n\n###\nO(nlogn)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374505413","body":"### 思路\n排列组合\n左边子树比顶点 i 小，右边大\n计算累加和  i*（n-i-1）\n\n```c++\nclass Solution {\n    vector<int> vis;\n    int dp(int n){\n        if(vis[n])return vis[n];\n        int ans=0;\n        for(int i=0;i<n;++i)ans+=dp(i)*dp(n-i-1);\n        return vis[n]=ans;\n    }\npublic:\n    int numTrees(int n) {\n        vis.assign(n+1,0);\n        vis[0]=1;\n        return dp(n);\n    }\n};\n```\n```c++\nclass Solution {\npublic:\n    int numTrees(int n) {\n        // G(n): 长度为 nn 的序列能构成的不同二叉搜索树的个数。\n        // F(i, n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数(1≤i≤n)。\n        // G(n)= i=1∑n F(i,n)\n        // F(i,n)=G(i−1)⋅G(n−i)\n        // G(n)= i=1∑n G(i−1)⋅G(n−i)\n        vector<int> G(n+1,0);\n        G[0]=1;\n        G[1]=1;\n\n        for(int i=2;i<=n;i++){\n            for(int j=1;j<=i;j++){\n                G[i]+=G[j-1]*G[i-j];\n            }\n        }\n        return G[n];\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374816066","body":"```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        ListNode *ans = nullptr;\n        for (size_t i = 0; i < lists.size(); ++i) {\n            ans = mergeTwoLists(ans, lists[i]);\n        }\n        return ans;\n    }\n    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n        if((!a) || (!b)) return a?a:b;\n        ListNode head,*tail=&head,*aPtr=a,*bPtr=b;\n        while(aPtr&&bPtr){\n            if(aPtr->val<bPtr->val){\n                tail->next=aPtr;aPtr=aPtr->next;\n            }\n            else{\n                tail->next=bPtr;bPtr=bPtr->next;\n            }\n            tail=tail->next;\n        }\n        tail->next=(aPtr?aPtr:bPtr);\n        return head.next;\n    }\n};\n```\nO(kn*logk)\nO(logk)\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    struct Status {\n        int val;\n        ListNode *ptr;\n        bool operator < (const Status &rhs) const {\n            return val > rhs.val;\n        }\n    };\n\n    priority_queue <Status> q;\n\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        for(auto node:lists)\n        if(node)q.push({node->val,node});\n        ListNode head,*tail=&head;\n        while(!q.empty()){\n            auto f=q.top();q.pop();\n            tail->next=f.ptr;\n            tail=tail->next;\n            if(f.ptr->next)q.push({f.ptr->next->val,f.ptr->next});\n        }\n        return head.next;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375679235","body":"### 思路\n看了题解，分治，一半奇数一半偶数，难点在于想明白性质。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        if(n==1)return {1};\n        vector<int> res;\n        auto left=beautifulArray(n-n/2);\n        auto right=beautifulArray(n/2);\n        for(auto& x:left){\n            res.push_back(2*x-1);\n        }\n        for(auto& x:right){\n            res.push_back(2*x);\n        }\n        return res;\n    }\n};\n```\n### \nO(nlogn)\nO(n + logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376835277","body":"### 思路\n异或，第一遍异或得到两个出现一次的值的异或结果。\n然后找从后往前第一个1作为过滤，说明这位两个值不同。\n第二遍将这位1和0分成两组，分别异或，得到这两组里各自只出现一遍的。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        int res=0;\n        for(int n:nums){\n            res^=n;\n        }\n        int div=1;\n        while((div&res)==0){\n            div<<=1;\n        }\n        int a=0,b=0;\n        for(auto& n:nums){\n            if(div & n){\n                a^=n;\n            }\n            else{\n                b^=n;\n            }\n        }\n        return vector<int>{a,b};\n    }\n};\n```\n### \nO(n)\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1380766574","body":"### 思路\r\n本来觉得是dfs，看了题解发现位运算。\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> subsets(vector<int>& nums) {\r\n        int s=nums.size();\r\n        int n=1<<s;\r\n        vector<vector<int>> ans;\r\n        for(int i=0;i<n;i++){\r\n            vector<int> v;\r\n            for(int j=0;j<s;j++){\r\n                if(i&(1<<j))v.push_back(nums[j]);\r\n            }\r\n            ans.push_back(v);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n### \r\nO(N∗2 ^N)\r\nO(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380588809","body":"```c++\nclass Trie {\nprivate:\n    bool isEnd;\n    Trie* next[26];\npublic:\n    /** Initialize your data structure here. */\n    Trie() {\n        isEnd = false;\n        memset(next, 0, sizeof(next));\n    }\n    \n    /** Inserts a word into the trie. */\n    void insert(string word) {\n        Trie* node = this;\n        for(char ch : word){\n            if(node->next[ch-'a'] == NULL){\n                node->next[ch-'a'] = new Trie();\n            }\n            node = node->next[ch-'a'];\n        }\n        node->isEnd = true;\n\n    }\n    \n    /** Returns if the word is in the trie. */\n    bool search(string word) {\n        Trie* node = this;\n         for(char ch : word){           \n            node = node->next[ch-'a'];\n            if(node==NULL){\n                return false;\n            }\n        }\n        return node->isEnd;\n    }\n    \n    /** Returns if there is any word in the trie that starts with the given prefix. */\n    bool startsWith(string prefix) {\n        Trie* node = this;\n        for(char ch : prefix){\n            node = node->next[ch-'a'];\n            if(node == NULL){\n                return false;\n            }\n        }\n        return true;\n    }\n};\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie* obj = new Trie();\n * obj->insert(word);\n * bool param_2 = obj->search(word);\n * bool param_3 = obj->startsWith(prefix);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1382040081","body":"```c++\nclass MapSum {\nprivate:\n    bool isEnd;\n    MapSum* next[26];\n    int value;\n    \n    int dfs(MapSum* root){\n        if(!root) return 0;\n        int res=0;\n        if(root->isEnd)res+=root->value;\n        for(MapSum* cur : root->next){\n            res+=dfs(cur);\n        }\n        return res;\n    }\n\npublic:\n    /** Initialize your data structure here. */\n    MapSum() {\n        isEnd=false;\n        memset(next,0,sizeof(next));\n        value=0;\n    }\n    \n    void insert(string key, int val) {\n        MapSum* m=this;\n        for(char ch : key){\n            if(m->next[ch-'a']==NULL){\n                m->next[ch-'a']=new MapSum();\n            }\n            m=m->next[ch-'a'];\n        }\n        m->isEnd=true;\n        m->value=val;\n    }\n    \n    int sum(string prefix) {\n        MapSum* m=this;\n        for(char ch : prefix){\n            if(m->next[ch-'a']==NULL){\n                return 0;           \n            }\n            m=m->next[ch-'a'];\n        }\n        return dfs(m);\n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as such:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382146034","body":"### 思路\n改了前面的代码，今天回来有时间补一下kmp。\n\n### 代码\n```c++\nclass Solution {\nclass Node{\npublic:\n    Node* child[26];\n    bool isEnd;\n    int value;\n\n    Node() {\n        isEnd=false;\n        memset(child,0,sizeof(child));\n        value=0;\n    }\n};\n\npublic:\n    Node* root=new Node();\n    void insert(string key, int val) {\n        Node* m=root;\n        for(char ch : key){\n            if(m->child[ch-'a']==NULL){\n                m->child[ch-'a']=new Node();\n            }\n            m=m->child[ch-'a'];\n        }\n        m->isEnd=true;\n        m->value=val;\n    }\n    vector<vector<int>> multiSearch(string big, vector<string>& smalls) {\n        int n = smalls.size();\n        vector<vector<int>> res;\n        vector<int> ind;\n        for(int i=0;i<n;i++){\n            res.push_back(ind);\n        }\n        for(int i=0;i<n;i++){\n            insert(smalls[i],i);\n        }\n        for(int i=0;i<big.length();i++){\n            Node* tmp= root;\n            for(int j=i;j<big.length();j++){\n                if(tmp->child[big[j]-'a']==NULL){\n                    break;\n                }\n                tmp=tmp->child[big[j]-'a'];\n                if(tmp->isEnd)res[tmp->value].push_back(i);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### \nO(N∗K)，其中 K 是敏感词中最长单词长度，N 是长句的长度。\nO(S)O(S), S 为所有匹配成功的位置的个数。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383150578","body":"### 思路\n并查集\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int find(vector<int>& parent,int i){\n        if(parent[i]==-1)return i;\n        return find(parent,parent[i]);\n    }\n    void unio(vector<int>& parent,int x,int y){\n        int xset=find(parent,x);\n        int yset=find(parent,y);\n        if(xset!=yset)parent[xset]=yset;\n    }\n    int findCircleNum(vector<vector<int>>& M) {\n        int n=M.size();\n        vector<int> parent(n,-1);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(M[i][j]==1&&i!=j){\n                    unio(parent,i,j);\n                }\n            }\n        }\n        int count=0;\n        for(int i=0;i<n;i++){\n            if(parent[i]==-1){\n                count++;\n            }\n        }\n        return count;\n    }\n};\n```\n### \n时间复杂度 O(n^2logn)，其中 n 是城市的数量。需要遍历矩阵 isConnected 中的所有元素，时间复杂度是 O(n^2)，如果遇到相连关系，则需要进行 2 次查找和最多 1 次合并，一共需要进行 2n^2次查找和最多 n^2次合并，因此总时间复杂度是 O(n^2 log n)。这里的并查集使用了路径压缩，但是没有使用按秩合并，最坏情况下的时间复杂度是 O(n^2log n)，平均情况下的时间复杂度依然是 O(n^2 α(n))，其中 α 为阿克曼函数的反函数，α(n) 可以认为是一个很小的常数。\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298592412","body":"### 思路\r\n\r\n先判断结果数组的长度，之后将k与num逆序按位相加取余后放到结果数组。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        if (k == 0)\r\n            return num;\r\n\r\n        string kstr = to_string(k);\r\n        int len = max(num.size(), kstr.size());\r\n        vector<int> result(len+1,0);\r\n\r\n        int a, b;\r\n\r\n        for(int i = num.size() - 1; i >= 0; i--)\r\n        {\r\n            a = num[i];\r\n            k += a;\r\n            b = k % 10;\r\n            result[len--] = b;\r\n            k /= 10;\r\n        }\r\n        if (k)\r\n        {\r\n            while (k > 9)\r\n            {\r\n                b = k % 10;\r\n                result[len--] = b;\r\n                k /= 10;\r\n            }\r\n            result[len--] = k;\r\n        }\r\n        if(!result[0]) result.erase(result.begin());\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300551765","body":"### 思路\r\n\r\n先遍历一次字符串，将所有字符出现位置的下标放到一个新数组；之后再便利一次数组，找到每个字符与数组所有出现位置的距离的最小值。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> c_position;\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n                c_position.push_back(i);\r\n        } \r\n        int dist;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n            for (int j = 0; j < c_position.size(); j++)\r\n            {\r\n                dist = abs(i - c_position[j]);\r\n                if (dist > res[i]) break;\r\n                else res[i] = dist;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*K)，其中 K 为字符出现的次数。\r\n- 空间复杂度：O(K)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302216723","body":"### 思路\r\n\r\n使用数组存放栈中的元素。\r\n\r\n### 代码\r\n\r\n\r\n```\r\ntypedef struct SNode CustomStack;\r\nstruct SNode {\r\n    int *data;\r\n    int top;\r\n    int maxsize;\r\n};\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    CustomStack *Stack = (CustomStack *)malloc(sizeof(CustomStack));\r\n    Stack->data = (int *)malloc(maxSize * sizeof(int));\r\n    Stack->maxsize = maxSize;\r\n    Stack->top = -1;\r\n    return Stack;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if(obj->top < obj->maxsize - 1)\r\n        obj->data[++obj->top] = x;\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if(obj->top > -1)\r\n        return obj->data[obj->top--];\r\n    else\r\n        return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    if (obj->top <= k - 1)\r\n    {\r\n        for(int i = 0; i <= obj->top; i++)\r\n            obj->data[i] += val;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 0; i < k; i++)\r\n            obj->data[i] += val;;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->data);\r\n    free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push 和 pop 的时间复杂度为 O(1)， increment 的时间复杂度为 O(min(k, cnt))。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303645062","body":"### 思路\r\n\r\n通过栈实现。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack <int> nums;\r\n        stack <string> strs;\r\n        int num = 0;\r\n        int len = s.size();\r\n        for(int i = 0; i < len; ++ i)\r\n        {\r\n            if(s[i] >= '0' && s[i] <= '9')\r\n            {\r\n                num = num * 10 + s[i] - '0';\r\n            }\r\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                nums.push(num);\r\n                num = 0;\r\n                strs.push(res); \r\n                res = \"\";\r\n            }\r\n            else\r\n            {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j)\r\n                    strs.top() += res;\r\n                res = strs.top(); \r\n                strs.pop();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1320891735","body":"### 思路\r\n双栈\r\n### 代码\r\n``` \r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(1)\r\n空间:o(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766593","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> nums;\r\n        int maxNum = 0;\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            if (nums.empty() || nums.top() <= arr[i]) {\r\n                nums.push(arr[i]);\r\n            } else {\r\n                maxNum = nums.top();\r\n                nums.pop();\r\n                while (!nums.empty() && nums.top() > arr[i]) {\r\n                    nums.pop();\r\n                }\r\n                nums.push(maxNum);\r\n            }\r\n        }\r\n        return nums.size();\r\n    }\r\n};\r\n\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305581440","body":"### 思路\r\n\r\n闭合为环\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode* iter = head;\r\n        while (iter->next != nullptr) {\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while (add--) {\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307187066","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummyHead = new ListNode(0); \r\n        dummyHead->next = head; \r\n        ListNode* cur = dummyHead;\r\n        while(cur->next != nullptr && cur->next->next != nullptr) {\r\n            ListNode* tmp = cur->next; \r\n            ListNode* tmp1 = cur->next->next->next; \r\n\r\n            cur->next = cur->next->next;    \r\n            cur->next->next = tmp;          \r\n            cur->next->next->next = tmp1;  \r\n\r\n            cur = cur->next->next; // cur移动两位，准备下一轮交换\r\n        }\r\n        return dummyHead->next;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308692238","body":"### 思路\r\n分治\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int getLength(ListNode* head) {\r\n        int ret = 0;\r\n        for (; head != nullptr; ++ret, head = head->next);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode*& head, int left, int right) {\r\n        if (left > right) {\r\n            return nullptr;\r\n        }\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode* root = new TreeNode();\r\n        root->left = buildTree(head, left, mid - 1);\r\n        root->val = head->val;\r\n        head = head->next;\r\n        root->right = buildTree(head, mid + 1, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int length = getLength(head);\r\n        return buildTree(head, 0, length - 1);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间 o(n)\r\n空间 o(logn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1320890007","body":"### 思路\r\n哈希\r\n\r\n### 代码\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        unordered_set<ListNode *> visited;\r\n        ListNode *temp = headA;\r\n        while (temp != nullptr) {\r\n            visited.insert(temp);\r\n            temp = temp->next;\r\n        }\r\n        temp = headB;\r\n        while (temp != nullptr) {\r\n            if (visited.count(temp)) {\r\n                return temp;\r\n            }\r\n            temp = temp->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n### 复杂度\r\n时间:o(m+n)\r\n空间:o(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311734467","body":"### 思路\r\n遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        unordered_set<ListNode *> visited;\r\n        while (head != nullptr) {\r\n            if (visited.count(head)) {\r\n                return head;\r\n            }\r\n            visited.insert(head);\r\n            head = head->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```\r\n###复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312496756","body":"###思路\r\n哈希表加双向链表\r\n\r\n### 代码\r\n```\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode* removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：o(1)\r\n空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312743482","body":"### 代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) return 0;\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313562299","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == nullptr && q == nullptr) {\r\n            return true;\r\n        } else if (p == nullptr || q == nullptr) {\r\n            return false;\r\n        } else if (p->val != q->val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315340290","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int prevSum) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root->val;\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root->left, sum) + dfs(root->right, sum);\r\n        }\r\n    }\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n时间复杂度:o(n)\r\n空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317118352","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    void dfs(TreeNode *root, int height, int &curVal, int &curHeight) {\r\n        if (root == nullptr) {\r\n            return;\r\n        }\r\n        height++;\r\n        dfs(root->left, height, curVal, curHeight);\r\n        dfs(root->right, height, curVal, curHeight);\r\n        if (height > curHeight) {\r\n            curHeight = height;\r\n            curVal = root->val;\r\n        }\r\n    }\r\n\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        int curVal, curHeight = 0;\r\n        dfs(root, 0, curVal, curHeight);\r\n        return curVal;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:o(n)\r\n空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318680407","body":"### 代码\r\n``` \r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320078266","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<tuple<int, int, int>> nodes;\r\n\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            nodes.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n        vector<vector<int>> ans;\r\n        int lastcol = INT_MIN;\r\n        for (const auto& [col, row, value]: nodes) {\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().push_back(value);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(nlogn)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320889105","body":"### 思路\r\n哈希表\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> hashtable;\r\n        for (int i = 0; i < nums.size(); ++i) {\r\n            auto it = hashtable.find(target - nums[i]);\r\n            if (it != hashtable.end()) {\r\n                return {it->second, i};\r\n            }\r\n            hashtable[nums[i]] = i;\r\n        }\r\n        return {};\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321160093","body":"### 思路\r\n堆\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\r\n        return m.second > n.second;\r\n    }\r\n\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for (auto& v : nums) {\r\n            occurrences[v]++;\r\n        }\r\n\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for (auto& [num, count] : occurrences) {\r\n            if (q.size() == k) {\r\n                if (q.top().second < count) {\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            } else {\r\n                q.emplace(num, count);\r\n            }\r\n        }\r\n        vector<int> ret;\r\n        while (!q.empty()) {\r\n            ret.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n\r\n## 复杂度\r\n时间:o(nlogk)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322110754","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>> &points) {\r\n        int ans = 0;\r\n        for (auto &p : points) {\r\n            unordered_map<int, int> cnt;\r\n            for (auto &q : points) {\r\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\r\n                ++cnt[dis];\r\n            }\r\n            for (auto &[_, m] : cnt) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n### 复杂度\r\n时间:  O(n^2) \r\n空间:  O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323875361","body":"``` \r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int n = s.size();\r\n        int rk = -1, ans = 0;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (i != 0) {\r\n                occ.erase(s[i - 1]);\r\n            }\r\n            while (rk + 1 < n && !occ.count(s[rk + 1])) {\r\n                occ.insert(s[rk + 1]);\r\n                ++rk;\r\n            }\r\n            ans = max(ans, rk - i + 1);\r\n        }\r\n        return ans;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325121494","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> findSubstring(string &s, vector<string> &words) {\r\n        vector<int> res;\r\n        int m = words.size(), n = words[0].size(), ls = s.size();\r\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\r\n            unordered_map<string, int> differ;\r\n            for (int j = 0; j < m; ++j) {\r\n                ++differ[s.substr(i + j * n, n)];\r\n            }\r\n            for (string &word: words) {\r\n                if (--differ[word] == 0) {\r\n                    differ.erase(word);\r\n                }\r\n            }\r\n            for (int start = i; start < ls - m * n + 1; start += n) {\r\n                if (start != i) {\r\n                    string word = s.substr(start + (m - 1) * n, n);\r\n                    if (++differ[word] == 0) {\r\n                        differ.erase(word);\r\n                    }\r\n                    word = s.substr(start - n, n);\r\n                    if (--differ[word] == 0) {\r\n                        differ.erase(word);\r\n                    }\r\n                }\r\n                if (differ.empty()) {\r\n                    res.emplace_back(start);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326367427","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int subarraysDivByK(vector<int>& nums, int k) {\r\n        unordered_map<int, int> record = {{0, 1}};\r\n        int sum = 0, ans = 0;\r\n        for (int elem: nums) {\r\n            sum += elem;\r\n            int modulus = (sum % k + k) % k;\r\n            if (record.count(modulus)) {\r\n                ans += record[modulus];\r\n            }\r\n            ++record[modulus];\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(min(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327551056","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n        while (fast != NULL && fast->next != NULL) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328045137","body":"### 思路\r\n双指针\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if (n == 0) {\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while (fast < n) {\r\n            if (nums[fast] != nums[fast - 1]) {\r\n                nums[slow] = nums[fast];\r\n                ++slow;\r\n            }\r\n            ++fast;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328255415","body":"### 思路\r\n二分查找\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int n = nums.size();\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left <= right) {\r\n            int mid = ((right - left) >> 1) + left;\r\n            if (target <= nums[mid]) {\r\n                ans = mid;\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(logn)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329214242","body":"### 思路\r\n优先队列\r\n\r\n### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\r\n        int n = nums.size();\r\n        priority_queue<pair<int, int>> q;\r\n        for (int i = 0; i < k; ++i) {\r\n            q.emplace(nums[i], i);\r\n        }\r\n        vector<int> ans = {q.top().first};\r\n        for (int i = k; i < n; ++i) {\r\n            q.emplace(nums[i], i);\r\n            while (q.top().second <= i - k) {\r\n                q.pop();\r\n            }\r\n            ans.push_back(q.top().first);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(nlogn)\r\n空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330703679","body":"### 代码\r\n``` \r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegrees(n + 1);\r\n        vector<int> outDegrees(n + 1);\r\n        for (auto& edge : trust) {\r\n            int x = edge[0], y = edge[1];\r\n            ++inDegrees[y];\r\n            ++outDegrees[x];\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332210614","body":"### 思路\r\n深度优先搜索\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\r\n        color[curnode] = nowcolor;\r\n        for (auto& nextnode : g[curnode]) {\r\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        vector<int> color(n + 1, 0);\r\n        vector<vector<int>> g(n + 1);\r\n        for (auto& p : dislikes) {\r\n            g[p[0]].push_back(p[1]);\r\n            g[p[1]].push_back(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：O(n+m)\r\n空间：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333801158","body":"### 思路\r\n拓扑排序\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:O(m+n)\r\n空间:O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335292726","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    bool judgeCircle(string moves) {\r\n        int x = 0, y = 0;\r\n        for (const auto& move: moves) {\r\n            if (move == 'U') {\r\n                y--;\r\n            }\r\n            else if (move == 'D') {\r\n                y++;\r\n            }\r\n            else if (move == 'L') {\r\n                x--;\r\n            }\r\n            else if (move == 'R') {\r\n                x++;\r\n            }\r\n        }\r\n        return x == 0 && y == 0;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336167984","body":"### 代码\r\n```\r\nclass Solution {\r\nprivate:\r\n    using PII = pair<int, int>;\r\n    using LL = long long;\r\n\r\npublic:\r\n    vector<int> getOrder(vector<vector<int>>& tasks) {\r\n        int n = tasks.size();\r\n        vector<int> indices(n);\r\n        iota(indices.begin(), indices.end(), 0);\r\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\r\n            return tasks[i][0] < tasks[j][0];\r\n        });\r\n\r\n        vector<int> ans;\r\n        priority_queue<PII, vector<PII>, greater<PII>> q;\r\n        LL timestamp = 0;\r\n        int ptr = 0;\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            if (q.empty()) {\r\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\r\n            }\r\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\r\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\r\n                ++ptr;\r\n            }\r\n            auto&& [process, index] = q.top();\r\n            timestamp += process;\r\n            ans.push_back(index);\r\n            q.pop();\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(nlogn)\r\n空间:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336427670","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int numberOfRounds(string startTime, string finishTime) {\r\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\r\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\r\n        if (t1 < t0){\r\n            t1 += 1440;\r\n        }\r\n        t1 = t1 / 15 * 15;\r\n        return max(0, (t1 - t0)) / 15;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间 o(1)\r\n空间 o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337529955","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int minCharacters(string a, string b) {\r\n        vector<int> acnt(26, 0);\r\n        vector<int> bcnt(26, 0);\r\n        int an = a.size(), bn = b.size();\r\n        \r\n        for (char c : a) acnt[c-'a']++;\r\n        for (char c : b) bcnt[c-'a']++;\r\n        \r\n        int ans = INT_MAX, asum = 0, bsum = 0;\r\n        for (int i = 0; i < 25; i++) {\r\n            asum += acnt[i];\r\n            bsum += bcnt[i];\r\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\r\n        }\r\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\r\n        \r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339410114","body":"### 代码\r\n```\r\nclass Solution {\r\n    int partition(vector<int>& nums, int l, int r) {\r\n        int pivot = nums[r];\r\n        int i = l - 1;\r\n        for (int j = l; j <= r - 1; ++j) {\r\n            if (nums[j] <= pivot) {\r\n                i = i + 1;\r\n                swap(nums[i], nums[j]);\r\n            }\r\n        }\r\n        swap(nums[i + 1], nums[r]);\r\n        return i + 1;\r\n    }\r\n    int randomized_partition(vector<int>& nums, int l, int r) {\r\n        int i = rand() % (r - l + 1) + l; \r\n        swap(nums[r], nums[i]);\r\n        return partition(nums, l, r);\r\n    }\r\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\r\n        if (l < r) {\r\n            int pos = randomized_partition(nums, l, r);\r\n            randomized_quicksort(nums, l, pos - 1);\r\n            randomized_quicksort(nums, pos + 1, r);\r\n        }\r\n    }\r\npublic:\r\n    vector<int> sortArray(vector<int>& nums) {\r\n        srand((unsigned)time(NULL));\r\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\r\n        return nums;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间o(nlogn)\r\n空间o(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341017734","body":"### 思路\r\n二分法\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int mySqrt(int x) {\r\n        int l = 0, r = x, ans = -1;\r\n        while (l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            if ((long long)mid * mid <= x) {\r\n                ans = mid;\r\n                l = mid + 1;\r\n            } else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n空间：o(logx)\r\n时间：o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342701202","body":"### 思路\r\n二分查找\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int left = 1, right = n;\r\n        while (left < right) { \r\n            int mid = left + (right - left) / 2; \r\n            if (isBadVersion(mid)) {\r\n                right = mid; \r\n            } else {\r\n                left = mid + 1; \r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间:o(logn)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344235138","body":"### 思路\r\n归并排序\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int reversePairsRecursive(vector<int>& nums, int left, int right) {\r\n        if (left == right) {\r\n            return 0;\r\n        } else {\r\n            int mid = (left + right) / 2;\r\n            int n1 = reversePairsRecursive(nums, left, mid);\r\n            int n2 = reversePairsRecursive(nums, mid + 1, right);\r\n            int ret = n1 + n2;\r\n\r\n            int i = left;\r\n            int j = mid + 1;\r\n            while (i <= mid) {\r\n                while (j <= right && (long long)nums[i] > 2 * (long long)nums[j]) j++;\r\n                ret += (j - mid - 1);\r\n                i++;\r\n            }\r\n\r\n            vector<int> sorted(right - left + 1);\r\n            int p1 = left, p2 = mid + 1;\r\n            int p = 0;\r\n            while (p1 <= mid || p2 <= right) {\r\n                if (p1 > mid) {\r\n                    sorted[p++] = nums[p2++];\r\n                } else if (p2 > right) {\r\n                    sorted[p++] = nums[p1++];\r\n                } else {\r\n                    if (nums[p1] < nums[p2]) {\r\n                        sorted[p++] = nums[p1++];\r\n                    } else {\r\n                        sorted[p++] = nums[p2++];\r\n                    }\r\n                }\r\n            }\r\n            for (int i = 0; i < sorted.size(); i++) {\r\n                nums[left + i] = sorted[i];\r\n            }\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    int reversePairs(vector<int>& nums) {\r\n        if (nums.size() == 0) return 0;\r\n        return reversePairsRecursive(nums, 0, nums.size() - 1);\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o（nlogn）\r\n空间：o（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345242678","body":"### 代码\r\n```\r\nclass Solution {\r\n    public int findRadius(int[] houses, int[] heaters) {\r\n        Arrays.sort(houses);\r\n        Arrays.sort(heaters);\r\n        int left = 0, right = (int)(1e9);\r\n        while (left < right) {\r\n            int mid = (left + right) / 2;\r\n            if (isCheck(houses, heaters, mid)) {\r\n                right = mid;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    public boolean isCheck(int[] houses, int[] heaters, int cover) {\r\n        int n = houses.length, cnt = 0, m = heaters.length;\r\n        for (int l = 0, r = 0, i = 0; i < m; i++) {\r\n            int lo = heaters[i] - cover, hi = heaters[i] + cover;\r\n            while (l < n && houses[l] < lo) l++;\r\n            while (r < n && houses[r] <= hi) r++;\r\n            cnt += r - l;\r\n            l = r;\r\n        }\r\n        return cnt == n;\r\n    } \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345558817","body":"### 代码\r\n```\r\nclass Solution {\r\n    public int smallestDistancePair(int[] nums, int k) {\r\n        Arrays.sort(nums);\r\n        int n = nums.length, left = 0, right = nums[n - 1] - nums[0];\r\n        while (left <= right) {\r\n            int mid = (left + right) / 2;\r\n            int cnt = 0;\r\n            for (int j = 0; j < n; j++) {\r\n                int i = binarySearch(nums, j, nums[j] - mid);\r\n                cnt += j - i;\r\n            }\r\n            if (cnt >= k) {\r\n                right = mid - 1;\r\n            } else {\r\n                left = mid + 1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n\r\n    public int binarySearch(int[] nums, int end, int target) {\r\n        int left = 0, right = end;\r\n        while (left < right) {\r\n            int mid = (left + right) / 2;\r\n            if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346532033","body":"###\r\n```\r\nstruct Entry {\r\n    int i;\r\n    int j;\r\n    int val;\r\n    bool operator<(const Entry& other) const {\r\n        return this->val > other.val;\r\n    }\r\n    Entry(int ii, int jj, int val): i(ii), j(jj), val(val) {}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int n = grid.size();\r\n        priority_queue<Entry, vector<Entry>, function<bool(const Entry& x, const Entry& other)>> pq(&Entry::operator<);\r\n        vector<vector<int>> visited(n, vector<int>(n, 0));\r\n\r\n        pq.push(Entry(0, 0, grid[0][0]));\r\n        int ret = 0;\r\n        vector<pair<int, int>> directions{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\r\n        while (!pq.empty()) {\r\n            Entry x = pq.top();\r\n            pq.pop();\r\n            if (visited[x.i][x.j] == 1) {\r\n                continue;\r\n            }\r\n            \r\n            visited[x.i][x.j] = 1;\r\n            ret = max(ret, grid[x.i][x.j]);\r\n            if (x.i == n - 1 && x.j == n - 1) {\r\n                break;\r\n            }\r\n\r\n            for (const auto [di, dj]: directions) {\r\n                int ni = x.i + di, nj = x.j + dj;\r\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\r\n                    if (visited[ni][nj] == 0) {\r\n                        pq.push(Entry(ni, nj, grid[ni][nj]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348207156","body":"###\r\n```\r\nclass Solution {\r\npublic:\r\n    bool isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; \r\n    }\r\n    \r\n    int maxVowels(string s, int k) {\r\n        int n = s.size();\r\n        int vowel_count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            vowel_count += isVowel(s[i]);\r\n        }\r\n        int ans = vowel_count;\r\n        for (int i = k; i < n; ++i) {\r\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k]);\r\n            ans = max(ans, vowel_count);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351327761","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    double new21Game(int n, int k, int maxPts) {\r\n        if (k == 0) {\r\n            return 1.0;\r\n        }\r\n        vector<double> dp(k + maxPts);\r\n        for (int i = k; i <= n && i < k + maxPts; i++) {\r\n            dp[i] = 1.0;\r\n        }\r\n        for (int i = k - 1; i >= 0; i--) {\r\n            for (int j = 1; j <= maxPts; j++) {\r\n                dp[i] += dp[i + j] / maxPts;\r\n            }\r\n        }\r\n        return dp[0];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353098067","body":"### 思路\r\n滑动窗口\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        int sLen = s.size(), pLen = p.size();\r\n\r\n        if (sLen < pLen) {\r\n            return vector<int>();\r\n        }\r\n\r\n        vector<int> ans;\r\n        vector<int> sCount(26);\r\n        vector<int> pCount(26);\r\n        for (int i = 0; i < pLen; ++i) {\r\n            ++sCount[s[i] - 'a'];\r\n            ++pCount[p[i] - 'a'];\r\n        }\r\n\r\n        if (sCount == pCount) {\r\n            ans.emplace_back(0);\r\n        }\r\n\r\n        for (int i = 0; i < sLen - pLen; ++i) {\r\n            --sCount[s[i] - 'a'];\r\n            ++sCount[s[i + pLen] - 'a'];\r\n\r\n            if (sCount == pCount) {\r\n                ans.emplace_back(i + 1);\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354186674","body":"### 思路\r\n滑动窗口\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    unordered_map <char, int> ori, cnt;\r\n\r\n    bool check() {\r\n        for (const auto &p: ori) {\r\n            if (cnt[p.first] < p.second) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    string minWindow(string s, string t) {\r\n        for (const auto &c: t) {\r\n            ++ori[c];\r\n        }\r\n\r\n        int l = 0, r = -1;\r\n        int len = INT_MAX, ansL = -1, ansR = -1;\r\n\r\n        while (r < int(s.size())) {\r\n            if (ori.find(s[++r]) != ori.end()) {\r\n                ++cnt[s[r]];\r\n            }\r\n            while (check() && l <= r) {\r\n                if (r - l + 1 < len) {\r\n                    len = r - l + 1;\r\n                    ansL = l;\r\n                }\r\n                if (ori.find(s[l]) != ori.end()) {\r\n                    --cnt[s[l]];\r\n                }\r\n                ++l;\r\n            }\r\n        }\r\n\r\n        return ansL == -1 ? string() : s.substr(ansL, len);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356223397","body":"### 代码\r\n```\r\nclass Solution {\r\n    public int maxScore(int[] cardPoints, int k) {\r\n        int len = cardPoints.length;\r\n        int[] preSum = new int[len + 1];\r\n        for (int i = 1; i <= len; i++) {\r\n            preSum[i] = preSum[i - 1] + cardPoints[i - 1];\r\n        }\r\n\r\n        int max = 0;\r\n        for (int i = 0; i <= k; i++) {\r\n            int score = preSum[i] + preSum[len] - preSum[len - k + i];\r\n            max = Math.max(score, max);\r\n        }\r\n        return max;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1357481230","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<string> readBinaryWatch(int turnedOn) {\r\n        vector<string> ans;\r\n        for (int h = 0; h < 12; ++h) {\r\n            for (int m = 0; m < 60; ++m) {\r\n                if (__builtin_popcount(h) + __builtin_popcount(m) == turnedOn) {\r\n                    ans.push_back(to_string(h) + \":\" + (m < 10 ? \"0\" : \"\") + to_string(m));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357482874","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int totalNQueens(int n) {\r\n        unordered_set<int> columns, diagonals1, diagonals2;\r\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\r\n    }\r\n\r\n    int backtrack(int n, int row, unordered_set<int>& columns, unordered_set<int>& diagonals1, unordered_set<int>& diagonals2) {\r\n        if (row == n) {\r\n            return 1;\r\n        } else {\r\n            int count = 0;\r\n            for (int i = 0; i < n; i++) {\r\n                if (columns.find(i) != columns.end()) {\r\n                    continue;\r\n                }\r\n                int diagonal1 = row - i;\r\n                if (diagonals1.find(diagonal1) != diagonals1.end()) {\r\n                    continue;\r\n                }\r\n                int diagonal2 = row + i;\r\n                if (diagonals2.find(diagonal2) != diagonals2.end()) {\r\n                    continue;\r\n                }\r\n                columns.insert(i);\r\n                diagonals1.insert(diagonal1);\r\n                diagonals2.insert(diagonal2);\r\n                count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\r\n                columns.erase(i);\r\n                diagonals1.erase(diagonal1);\r\n                diagonals2.erase(diagonal2);\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n};\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359084329","body":"### 代码\r\n```\r\nclass Solution {\r\n    int dfs(vector<vector<int>>& grid, int cur_i, int cur_j) {\r\n        if (cur_i < 0 || cur_j < 0 || cur_i == grid.size() || cur_j == grid[0].size() || grid[cur_i][cur_j] != 1) {\r\n            return 0;\r\n        }\r\n        grid[cur_i][cur_j] = 0;\r\n        int di[4] = {0, 0, 1, -1};\r\n        int dj[4] = {1, -1, 0, 0};\r\n        int ans = 1;\r\n        for (int index = 0; index != 4; ++index) {\r\n            int next_i = cur_i + di[index], next_j = cur_j + dj[index];\r\n            ans += dfs(grid, next_i, next_j);\r\n        }\r\n        return ans;\r\n    }\r\npublic:\r\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int ans = 0;\r\n        for (int i = 0; i != grid.size(); ++i) {\r\n            for (int j = 0; j != grid[0].size(); ++j) {\r\n                ans = max(ans, dfs(grid, i, j));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360988080","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    static constexpr int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\r\n    static constexpr int MAX_N = 100 + 5;\r\n\r\n    struct Coordinate {\r\n        int x, y, step;\r\n    };\r\n\r\n    int n, m;\r\n    vector<vector<int>> a;\r\n\r\n    bool vis[MAX_N][MAX_N];\r\n\r\n    int findNearestLand(int x, int y) {\r\n        memset(vis, 0, sizeof vis);\r\n        queue <Coordinate> q;\r\n        q.push({x, y, 0});\r\n        vis[x][y] = 1;\r\n        while (!q.empty()) {\r\n            auto f = q.front(); q.pop();\r\n            for (int i = 0; i < 4; ++i) {\r\n                int nx = f.x + dx[i], ny = f.y + dy[i];\r\n                if (!(nx >= 0 && nx <= n - 1 && ny >= 0 && ny <= m - 1)) {\r\n                    continue;\r\n                }\r\n                if (!vis[nx][ny]) {\r\n                    q.push({nx, ny, f.step + 1});\r\n                    vis[nx][ny] = 1;\r\n                    if (a[nx][ny]) {\r\n                        return f.step + 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    int maxDistance(vector<vector<int>>& grid) {\r\n        this->n = grid.size();\r\n        this->m = grid.at(0).size();\r\n        a = grid;\r\n        int ans = -1;\r\n        for (int i = 0; i < n; ++i) {\r\n            for (int j = 0; j < m; ++j) {\r\n                if (!a[i][j]) {\r\n                    ans = max(ans, findNearestLand(i, j));\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362772810","body":"今天leetcode的每日一题\r\n### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxScore(vector<int>& nums) {\r\n        int m = nums.size();\r\n        vector<int> dp(1 << m, 0);\r\n        vector<vector<int>> gcd_tmp(m, vector<int>(m, 0));\r\n        for (int i = 0; i < m; ++i) {\r\n            for (int j = i + 1; j < m; ++j) {\r\n                gcd_tmp[i][j] = gcd(nums[i], nums[j]);\r\n            }\r\n        }\r\n        int all = 1 << m;\r\n        for (int s = 1; s < all; ++s) {\r\n            int t = __builtin_popcount(s);\r\n            if (t & 1) {\r\n                continue;\r\n            }\r\n            for (int i = 0; i < m; ++i) {\r\n                if ((s >> i) & 1) {\r\n                    for (int j = i + 1; j < m; ++j) {\r\n                        if ((s >> j) & 1) {\r\n                            dp[s] = max(dp[s], dp[s ^ (1 << i) ^ (1 << j)] + t / 2 * gcd_tmp[i][j]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[all - 1];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363927265","body":"###\r\n二叉树的垂序遍历\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n\r\n    struct node\r\n    {\r\n        int val;\r\n        int x;\r\n        int y;\r\n        node(int _val, int _x, int _y) : val(_val), x(_x), y(_y) {}\r\n    };\r\n\r\n    vector <node*> array;\r\n\r\n    void DFS(TreeNode* root, int x, int y)\r\n    {\r\n        if (root)\r\n        {\r\n            node* temp = new node(root -> val, x, y);\r\n            array.push_back(temp);\r\n            DFS(root -> left, x - 1, y + 1);\r\n            DFS(root -> right, x + 1, y + 1);\r\n        }\r\n    }\r\n\r\n    static bool cmp(node* a, node* b)\r\n    {\r\n        if (a -> x != b -> x) return a -> x < b -> x;\r\n        if (a -> y != b -> y) return a -> y < b -> y;\r\n        return a -> val < b -> val;\r\n    }\r\n\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        DFS(root, 0, 0);\r\n        sort(array.begin(), array.end(), cmp);\r\n        int localx = -1000;\r\n        vector<vector<int>> res;\r\n        for (auto& s : array)\r\n        {\r\n            if (s -> x != localx)\r\n            {\r\n                res.emplace_back();\r\n                localx = s -> x;\r\n            }\r\n            res.back().push_back(s -> val);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364518730","body":"### 思路\r\n动态规划\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int minCostClimbingStairs(vector<int>& cost) {\r\n        int n = cost.size();\r\n        int prev = 0, curr = 0;\r\n        for (int i = 2; i <= n; i++) {\r\n            int next = min(curr + cost[i - 1], prev + cost[i - 2]);\r\n            prev = curr;\r\n            curr = next;\r\n        }\r\n        return curr;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364662360","body":"### 思路\r\n动态规划\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int rob(vector<int>& nums) {\r\n        if (nums.empty()) {\r\n            return 0;\r\n        }\r\n        int size = nums.size();\r\n        if (size == 1) {\r\n            return nums[0];\r\n        }\r\n        int first = nums[0], second = max(nums[0], nums[1]);\r\n        for (int i = 2; i < size; i++) {\r\n            int temp = second;\r\n            second = max(first + nums[i], second);\r\n            first = temp;\r\n        }\r\n        return second;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365158596","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int findNumberOfLIS(vector<int> &nums) {\r\n        int n = nums.size(), maxLen = 0, ans = 0;\r\n        vector<int> dp(n), cnt(n);\r\n        for (int i = 0; i < n; ++i) {\r\n            dp[i] = 1;\r\n            cnt[i] = 1;\r\n            for (int j = 0; j < i; ++j) {\r\n                if (nums[i] > nums[j]) {\r\n                    if (dp[j] + 1 > dp[i]) {\r\n                        dp[i] = dp[j] + 1;\r\n                        cnt[i] = cnt[j]; \r\n                    } else if (dp[j] + 1 == dp[i]) {\r\n                        cnt[i] += cnt[j];\r\n                    }\r\n                }\r\n            }\r\n            if (dp[i] > maxLen) {\r\n                maxLen = dp[i];\r\n                ans = cnt[i]; \r\n            } else if (dp[i] == maxLen) {\r\n                ans += cnt[i];\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365887533","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int longestCommonSubsequence(string text1, string text2) {\r\n        int m = text1.length(), n = text2.length();\r\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\r\n        for (int i = 1; i <= m; i++) {\r\n            char c1 = text1.at(i - 1);\r\n            for (int j = 1; j <= n; j++) {\r\n                char c2 = text2.at(j - 1);\r\n                if (c1 == c2) {\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\r\n                } else {\r\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n        return dp[m][n];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366552238","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int uniquePaths(int m, int n) {\r\n        vector<vector<int>> f(m, vector<int>(n));\r\n        for (int i = 0; i < m; ++i) {\r\n            f[i][0] = 1;\r\n        }\r\n        for (int j = 0; j < n; ++j) {\r\n            f[0][j] = 1;\r\n        }\r\n        for (int i = 1; i < m; ++i) {\r\n            for (int j = 1; j < n; ++j) {\r\n                f[i][j] = f[i - 1][j] + f[i][j - 1];\r\n            }\r\n        }\r\n        return f[m - 1][n - 1];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367242067","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<vector<int>> dirs = {{-2, -1}, {-2, 1}, {2, -1}, {2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}};\r\n\r\n    double knightProbability(int n, int k, int row, int column) {\r\n        vector<vector<vector<double>>> dp(k + 1, vector<vector<double>>(n, vector<double>(n)));\r\n        for (int step = 0; step <= k; step++) {\r\n            for (int i = 0; i < n; i++) {\r\n                for (int j = 0; j < n; j++) {\r\n                    if (step == 0) {\r\n                        dp[step][i][j] = 1;\r\n                    } else {\r\n                        for (auto & dir : dirs) {\r\n                            int ni = i + dir[0], nj = j + dir[1];\r\n                            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\r\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return dp[k][row][column];\r\n    }\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367915302","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    unordered_map<int, bool> memo;\r\n\r\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\r\n        if ((1 + maxChoosableInteger) * (maxChoosableInteger) / 2 < desiredTotal) {\r\n            return false;\r\n        }\r\n        return dfs(maxChoosableInteger, 0, desiredTotal, 0);\r\n    }\r\n\r\n    bool dfs(int maxChoosableInteger, int usedNumbers, int desiredTotal, int currentTotal) {\r\n        if (!memo.count(usedNumbers)) {\r\n            bool res = false;\r\n            for (int i = 0; i < maxChoosableInteger; i++) {\r\n                if (((usedNumbers >> i) & 1) == 0) {\r\n                    if (i + 1 + currentTotal >= desiredTotal) {\r\n                        res = true;\r\n                        break;\r\n                    }\r\n                    if (!dfs(maxChoosableInteger, usedNumbers | (1 << i), desiredTotal, currentTotal + i + 1)) {\r\n                        res = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            memo[usedNumbers] = res;\r\n        }\r\n        return memo[usedNumbers];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368197547","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    bool canPartition(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if (n < 2) {\r\n            return false;\r\n        }\r\n        int sum = accumulate(nums.begin(), nums.end(), 0);\r\n        int maxNum = *max_element(nums.begin(), nums.end());\r\n        if (sum & 1) {\r\n            return false;\r\n        }\r\n        int target = sum / 2;\r\n        if (maxNum > target) {\r\n            return false;\r\n        }\r\n        vector<vector<int>> dp(n, vector<int>(target + 1, 0));\r\n        for (int i = 0; i < n; i++) {\r\n            dp[i][0] = true;\r\n        }\r\n        dp[0][nums[0]] = true;\r\n        for (int i = 1; i < n; i++) {\r\n            int num = nums[i];\r\n            for (int j = 1; j <= target; j++) {\r\n                if (j >= num) {\r\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\r\n                } else {\r\n                    dp[i][j] = dp[i - 1][j];\r\n                }\r\n            }\r\n        }\r\n        return dp[n - 1][target];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368426219","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int count = 0;\r\n\r\n    int findTargetSumWays(vector<int>& nums, int target) {\r\n        backtrack(nums, target, 0, 0);\r\n        return count;\r\n    }\r\n\r\n    void backtrack(vector<int>& nums, int target, int index, int sum) {\r\n        if (index == nums.size()) {\r\n            if (sum == target) {\r\n                count++;\r\n            }\r\n        } else {\r\n            backtrack(nums, target, index + 1, sum + nums[index]);\r\n            backtrack(nums, target, index + 1, sum - nums[index]);\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368966655","body":"### code\r\n```\r\nclass Solution {\r\n    vector<int>count;\r\n    int dp(vector<int>& coins, int rem) {\r\n        if (rem < 0) return -1;\r\n        if (rem == 0) return 0;\r\n        if (count[rem - 1] != 0) return count[rem - 1];\r\n        int Min = INT_MAX;\r\n        for (int coin:coins) {\r\n            int res = dp(coins, rem - coin);\r\n            if (res >= 0 && res < Min) {\r\n                Min = res + 1;\r\n            }\r\n        }\r\n        count[rem - 1] = Min == INT_MAX ? -1 : Min;\r\n        return count[rem - 1];\r\n    }\r\npublic:\r\n    int coinChange(vector<int>& coins, int amount) {\r\n        if (amount < 1) return 0;\r\n        count.resize(amount);\r\n        return dp(coins, amount);\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369725400","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int change(int amount, vector<int>& coins) {\r\n        vector<int> dp(amount + 1);\r\n        dp[0] = 1;\r\n        for(auto x : coins){\r\n            for(int i = x; i<=amount ;i++){\r\n                dp[i]=dp[i - x] + dp[i];\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370995496","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int findContentChildren(vector<int>& g, vector<int>& s) {\r\n        sort(g.begin(), g.end());\r\n        sort(s.begin(), s.end());\r\n        int m = g.size(), n = s.size();\r\n        int count = 0;\r\n        for (int i = 0, j = 0; i < m && j < n; i++, j++) {\r\n            while (j < n && g[i] > s[j]) {\r\n                j++;\r\n            }\r\n            if (j < n) {\r\n                count++;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372170037","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int eraseOverlapIntervals(vector<vector<int>>& intervals) {\r\n        if (intervals.empty()) {\r\n            return 0;\r\n        }\r\n        \r\n        sort(intervals.begin(), intervals.end(), [](const auto& u, const auto& v) {\r\n            return u[0] < v[0];\r\n        });\r\n\r\n        int n = intervals.size();\r\n        vector<int> f(n, 1);\r\n        for (int i = 1; i < n; ++i) {\r\n            for (int j = 0; j < i; ++j) {\r\n                if (intervals[j][1] <= intervals[i][0]) {\r\n                    f[i] = max(f[i], f[j] + 1);\r\n                }\r\n            }\r\n        }\r\n        return n - *max_element(f.begin(), f.end());\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373516679","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int numRescueBoats(vector<int> &people, int limit) {\r\n        int ans = 0;\r\n        sort(people.begin(), people.end());\r\n        int light = 0, heavy = people.size() - 1;\r\n        while (light <= heavy) {\r\n            if (people[light] + people[heavy] > limit) {\r\n                --heavy;\r\n            } else {\r\n                ++light;\r\n                --heavy;\r\n            }\r\n            ++ans;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374677500","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    int numTrees(int n) {\r\n        vector<int> G(n + 1, 0);\r\n        G[0] = 1;\r\n        G[1] = 1;\r\n\r\n        for (int i = 2; i <= n; ++i) {\r\n            for (int j = 1; j <= i; ++j) {\r\n                G[i] += G[j - 1] * G[i - j];\r\n            }\r\n        }\r\n        return G[n];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374819290","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\r\n        if ((!a) || (!b)) return a ? a : b;\r\n        ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\r\n        while (aPtr && bPtr) {\r\n            if (aPtr->val < bPtr->val) {\r\n                tail->next = aPtr; aPtr = aPtr->next;\r\n            } else {\r\n                tail->next = bPtr; bPtr = bPtr->next;\r\n            }\r\n            tail = tail->next;\r\n        }\r\n        tail->next = (aPtr ? aPtr : bPtr);\r\n        return head.next;\r\n    }\r\n\r\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\r\n        ListNode *ans = nullptr;\r\n        for (size_t i = 0; i < lists.size(); ++i) {\r\n            ans = mergeTwoLists(ans, lists[i]);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375615293","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    unordered_map<int,vector<int> > mp;\r\n    vector<int> beautifulArray(int N) {\r\n        return f(N);\r\n    }\r\n    vector<int> f(int N) {\r\n        vector<int> ans(N, 0);\r\n        int t = 0;\r\n        if (mp.find(N) != mp.end()) {\r\n            return mp[N];\r\n        }\r\n        if (N != 1) {\r\n            for (auto x : f((N+1)/2)){\r\n                ans[t++]= 2 * x - 1;\r\n            } \r\n            for (auto x : f(N/2)){\r\n                ans[t++] =  2 * x;\r\n            }\r\n        }else {\r\n            ans[0] = 1;\r\n        }\r\n        mp[N] = ans;\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377265336","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> singleNumber(vector<int>& nums) {\r\n        unordered_map<int, int> freq;\r\n        for (int num: nums) {\r\n            ++freq[num];\r\n        }\r\n        vector<int> ans;\r\n        for (const auto& [num, occ]: freq) {\r\n            if (occ == 1) {\r\n                ans.push_back(num);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378276206","body":"### code\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> t;\r\n    vector<vector<int>> ans;\r\n\r\n    vector<vector<int>> subsets(vector<int>& nums) {\r\n        int n = nums.size();\r\n        for (int mask = 0; mask < (1 << n); ++mask) {\r\n            t.clear();\r\n            for (int i = 0; i < n; ++i) {\r\n                if (mask & (1 << i)) {\r\n                    t.push_back(nums[i]);\r\n                }\r\n            }\r\n            ans.push_back(t);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380415575","body":"### code\r\n```\r\nclass Trie {\r\nprivate:\r\n    vector<Trie*> children;\r\n    bool isEnd;\r\n\r\n    Trie* searchPrefix(string prefix) {\r\n        Trie* node = this;\r\n        for (char ch : prefix) {\r\n            ch -= 'a';\r\n            if (node->children[ch] == nullptr) {\r\n                return nullptr;\r\n            }\r\n            node = node->children[ch];\r\n        }\r\n        return node;\r\n    }\r\n\r\npublic:\r\n    Trie() : children(26), isEnd(false) {}\r\n\r\n    void insert(string word) {\r\n        Trie* node = this;\r\n        for (char ch : word) {\r\n            ch -= 'a';\r\n            if (node->children[ch] == nullptr) {\r\n                node->children[ch] = new Trie();\r\n            }\r\n            node = node->children[ch];\r\n        }\r\n        node->isEnd = true;\r\n    }\r\n\r\n    bool search(string word) {\r\n        Trie* node = this->searchPrefix(word);\r\n        return node != nullptr && node->isEnd;\r\n    }\r\n\r\n    bool startsWith(string prefix) {\r\n        return this->searchPrefix(prefix) != nullptr;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298597962","body":"## Intuition\nsimilar to add two numbers\n\n## Code\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        for (int i = num.size() - 1; i >= 0 && k > 0; i--) {\n                    num[i] += k;\n                    k = num[i] / 10;\n                    num[i] %= 10;\n                }\n        while (k) {\n            num.insert(num.begin(), k % 10);\n            k /= 10;\n        }\n\n        return num; \n    }\n};\n```\n\n## Complexity\n- Time: O(N) N = max(len(k), len(num))\n- Space: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303730976","body":"### Idea\nStack\n\n### Code\n\n\n```\n\nclass Solution(object):\n    def decodeString(self, s):\n        stack = []; curNum = 0; curString = ''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1305876329","body":"### Thought\n\nuse a dummy node\n\n### Code\n\n\n```python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next: \n            return head\n\n        dummy = ListNode(-1)\n        dummy.next = head \n\n        prev, cur = dummy, head \n\n\n        while cur and cur.next:\n            second = cur.next \n            prev.next = second \n            cur.next = second.next \n            second.next = cur \n\n            prev = cur\n            cur = cur.next \n        \n        return dummy.next\n\n```\n\n**Complexity**\n- Time：O(N\n- Space：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307627643","body":"### 思路\n\nDivide and Conquer \n\n### 代码\n\n\n```python\nlass Solution:\n\n    def findMiddle(self, head):\n        if not head or not head.next: \n            return head \n\n        fast = slow = head\n        prev = None\n        while fast and fast.next: \n            prev = slow \n            slow = slow.next \n            fast = fast.next.next\n\n        prev.next = None \n        return slow \n\n\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return None\n\n        mid = self.findMiddle(head)\n        node = TreeNode(mid.val)\n\n        # base case \n        if head == mid:\n            return node\n\n        # Recursively\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(mid.next)\n        \n        return node\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N logN)\n- 空间复杂度：O(logN)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309262008","body":"\n### 代码\n\n\n```python \n\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        l1, l2 = headA, headB\n\n        while l1 != l2: \n            l1 = l1.next if l1 else headB\n            l2 = l2.next if l2 else headA\n        \n        return l1\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600475","body":"python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return str(int(''.join(map(str,A)))+K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1301983242","body":"### 题目\r\n[LC821 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n### 思路一\r\n    1. 遍历一次把所有c的index找出来存成一个list\r\n    2. s中的每一个与c_list 求绝对值，取最小\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        c_ls = []\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                c_ls.append(i)\r\n\r\n        ans = []\r\n        for i, val in enumerate(s):\r\n            tmp = []\r\n            for j in c_ls:\r\n                tmp.append(abs(j-i))\r\n            ans.append(min(tmp))\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(N2)\r\n    空间复杂度 O(n)\r\n    \r\n### 思路二\r\n    1. 绝对值 --> 双指针，左右遍历\r\n    2. 大小比较时先设定inf\r\n    3. 左右遍历时记得顺序\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = []\r\n        tar = float('-inf')\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                tar = i\r\n            left.append(i - tar)\r\n        \r\n        right = []\r\n        tar = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                tar = i\r\n            right.append(min(tar - i, left[i]))\r\n\r\n        return right[::-1]\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301982795","body":"### 题目\r\n[LC1381设计栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n### 思路\r\n按要求操作\r\n\r\n### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.stack[-1]\r\n            del self.stack[-1]\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > len(self.stack):\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]+=val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 push O(1), pop O(1), increment O(min(maxSize,k))\r\n    空间复杂度 O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304398312","body":"### 题目\r\n[LC394 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### 思路一\r\n    括号匹配\r\n    入栈，遇到右括号出栈，记录str，左侧加value，直到遇到左括号\r\n    重复数字n次，入栈\r\n    所有数据出栈合并\r\n    ------------\r\n    错误点，数字不仅是10以内的数\r\n    \r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    tmp = stack[-1] + tmp\r\n                    stack.pop()\r\n\r\n                stack.pop() # 去掉 [\r\n                # 获取数字\r\n                repeat,e = 0,0\r\n                while len(stack)>0 and stack[-1].isdigit():\r\n                    repeat += int(stack[-1]) * (10**e)\r\n                    e += 1\r\n                    stack.pop() # 去掉数字\r\n                stack.append(repeat*tmp)\r\n            else:\r\n                stack.append(s[i])\r\n\r\n        ans = ''\r\n        for v in stack:\r\n            ans += v\r\n        \r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)\r\n\r\n\r\n### 思路二\r\n    逆波兰式，字母一个栈，数字一个栈\r\n    巧妙点：上一个str和下一个要重复次数的数字，存成一个数组\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        num = 0\r\n        string = ''\r\n        stack = []\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num*10 + int(i)                                \r\n            elif i == '[':\r\n                stack.append((string, num))\r\n                string = ''\r\n                num = 0\r\n            elif i == ']':\r\n                pre, k = stack.pop()\r\n                string = pre + k * string\r\n            elif i.isalpha():\r\n                string += i\r\n        return string\r\n\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304398515","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304809014","body":"### 题目\r\n[LC768 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n### 思路\r\n    当前数值比后面的都大就不能分块\r\n    栈中留下排序块的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if stack and arr[i]<stack[-1]:\r\n                head = stack.pop() # 最后一位是最大值\r\n                while stack and arr[i]<stack[-1]: # 为了跟前面的值对比，排序\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305659115","body":"### 题目\r\n[LC61 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n### 思路\r\n    链表拼接问题闭环再切断。首先遍历一遍计算出链表长度，为不影响原始链表，需要新声明一个链表。而后找出要切断的位置（相对于原始链表来说），cut=n-k%n。首尾闭环。循环找到切的点，cut.\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n\r\n        def rotateRight(self, head, k):\r\n            \"\"\"\r\n            :type head: ListNode\r\n            :type k: int\r\n            :rtype: ListNode\r\n            \"\"\"\r\n            #首先考虑边界，特殊情况\r\n            if k == 0 or not head or not head.next:\r\n                return head\r\n            \r\n            n = 1\r\n            cur = head\r\n\r\n            while cur.next:\r\n                cur = cur.next # 这里cur更新后，head不会更新，因为cur被重新赋值了，如果cur.next=xxx，那么head.next也会变化\r\n                n += 1\r\n            \r\n            add = n - k % n # 断开的位置\r\n            if add == n:\r\n                return head\r\n            \r\n            cur.next = head # 连接闭环\r\n            while add:\r\n                print(add)\r\n                cur = cur.next\r\n                add -= 1\r\n            \r\n            ret = cur.next\r\n            cur.next = None\r\n            return ret\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n) 最多遍历两次链表\r\n    空间复杂度 O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307266589","body":"### 题目\r\n[LC24 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n### 思路\r\n    虚拟头节点，减少边界的考虑。模拟+递归\r\n    这道题说明了对链表定义理解不透彻。节点（listNode）是一个数值+一个指针，不是像数组那样的好几个数值。力扣打印出来了，其实是循环打印了每一个节点，使得看起来像一个list。\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        if head is None or head.next is None:\r\n            return head \r\n\r\n        # head = ListNode(-1,head) # 添加虚拟节点 也work，但是尽量不要更改原始链表\r\n        # tmp = head\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        tmp = dummyHead\r\n        \r\n        while tmp.next and tmp.next.next:\r\n            node1 = tmp.next\r\n            node2 = tmp.next.next\r\n            tmp.next = node2\r\n            node1.next = node2.next\r\n        return dummyHead.next\r\n\r\n    # 递归\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 迭代O(1) 递归O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308810683","body":"### 题目\r\n[LC109 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n### 思路\r\n    首先通过快两步慢一步针的方式找到中点\r\n    递归的方式，根节点等于中点，左节点等于左子树中点，右节点等于右子树中点\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: Optional[ListNode]\r\n        :rtype: Optional[TreeNode]\r\n        \"\"\"\r\n        \r\n        def getMid(left, right):\r\n            fast = slow = left # initial 先都从左侧第一个开始\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next # 错误点，指针移动需用用自身，left.next一直是同一个，没有动\r\n                slow = slow.next\r\n            return slow\r\n\r\n        def buildTree(left, right):\r\n            if left == right:\r\n                return None\r\n            mid = getMid(left,right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n\r\n        return buildTree(head, None)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(nlogn)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600531","body":"### 思路\r\n先使用`join`方法把数组拍平成字符串，接着转成BigInt进行计算，再转成字符串，使用`split`方法转成数组\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const string = num.join('')\r\n    const sum = String(BigInt(string) + BigInt(k))\r\n    return sum.split('')\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665137","body":"### 思路\r\n借鉴的官方的答案，自己确实没有思考出来。核心的思路是正反两个方向遍历，将目标点c的位置设置为0；由于在遇到c之前，idx是不存在的。因此官方使用-n（正向遍历）和2n（反向遍历）的初始值。其目的是保证在遇到第一个c之前result[i]足够大，这样在逆向操作时（逆向操作时的result[i]肯定会经过c，因此此时的result[i]是真正的值，所以会通过Math.min筛选出来）。如果还不理解的话，debug一下就清楚了\r\n\r\n### 代码\r\n\r\n```javascript\r\nconst shortestToChar = (strs, c) => {\r\n  let len = strs.length\r\n  const result = new Array(len).fill(0)\r\n  for(let i = 0, idx = -len; i < strs.length; i++) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n    result[i] = i - idx\r\n  }\r\n\r\n  for (let i = len - 1, idx = 2 * len; i >= 0; i--) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n\r\n    result[i] = Math.min(result[i], idx - i)\r\n  }\r\n\r\n\r\n  return result\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302303781","body":"### 思路\r\njs写很容易，没啥可说的\r\n\r\n### 代码\r\n```javascript\r\nvar CustomStack = function(maxSize) {\r\n    this.len = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.len) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) return this.stack.pop()\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (this.stack.length < k) {\r\n        sum(this.stack, val)\r\n    } else {\r\n        let len = this.stack.length\r\n        let start = this.stack.slice(0, k)\r\n        let end = this.stack.slice(k, len)\r\n        sum(start, val)\r\n        this.stack = [...start, ...end]\r\n    }\r\n};\r\n\r\nconst sum = (list, val) => {\r\n    for(let i = 0; i < list.length; i++) {\r\n        list[i] = list[i] + val\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间：O(N)\r\n空间：O(N)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305780870","body":"### 思路\r\n\r\n将链表组成环，然后计算分割点`len - k%len`，再将两个分开的链表拼起来\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) return head\r\n    if (k === 0) return head\r\n    let dummy = new ListNode()\r\n    dummy.next = head\r\n    let len = 1\r\n    let cur = dummy.next\r\n    let last = dummy.next\r\n    while (last.next) {\r\n      last = last.next\r\n      len++\r\n    }\r\n  \r\n    // 建立环\r\n    last.next = head\r\n    let i = 1\r\n    while(i < len - k%len) {\r\n      cur = cur.next\r\n      i++\r\n    }\r\n  \r\n  \r\n    let temp = cur.next\r\n  \r\n    dummy.next = temp\r\n    cur.next = null\r\n  \r\n    return dummy.next\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307384091","body":"### 思路\r\n\r\n双指针，利用虚拟节点dummy，每次传入前置节点`prev`，当前节点cur，以及后一个节点完整节点的更换next，然后将节点移至下一次要交换的节点处；\r\n\r\n### 代码\r\n\r\n```javascript\r\n\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next)  return head\r\n  let cur = head, next = cur\r\n  const dummy = new ListNode()\r\n  dummy.next = head\r\n  let prev = dummy\r\n  while(cur && cur.next) {\r\n    next = cur.next\r\n    swapTwoNode(prev, cur, next)\r\n    prev = cur\r\n    cur = cur.next\r\n    next = cur\r\n  }\r\n\r\n  return dummy.next\r\n};\r\n\r\n\r\nconst swapTwoNode = (prev, cur, next) => {\r\n  let temp = next.next\r\n  prev.next = next\r\n  next.next = cur\r\n  cur.next = temp\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310385710","body":"### 思路\r\n求链表相交的固定思路是双指针，分别在自己的链表上每次移动一个节点，跑完后去另一个链表头开始移动，如果两个节点存在相同的场景，就相交了；反之没有\r\n\r\n### 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (headA === null || headB === null) {\r\n        return null;\r\n    }\r\n    let cur1 = headA, cur2 = headB\r\n    while(cur1 !== cur2) {\r\n        if (!cur1) {\r\n            cur1 = headB\r\n        } else {\r\n            cur1 = cur1.next\r\n        }\r\n        if (!cur2) {\r\n            cur2 = headA\r\n        } else {\r\n            cur2 = cur2.next\r\n        }\r\n    }\r\n\r\n    return cur1\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313977560","body":"### 思路\r\n广度遍历，依次比较，注意边界即可\r\n\r\n###代码\r\n```javascript\r\n    if (p == null && q == null) return true\r\n    if (!p || !q) return false\r\n    const queueP = [p]\r\n    const queueQ = [q]\r\n    let result = true\r\n    while(queueP.length > 0 && queueQ.length > 0) {\r\n        const nodeP = queueP.shift()\r\n        const nodeQ = queueQ.shift()\r\n\r\n        if (nodeP.val !== nodeQ.val) {\r\n            return false\r\n        }\r\n\r\n        if ((!nodeP.left && nodeQ.left) || (nodeP.left && !nodeQ.left)) return false\r\n        if ((!nodeP.right && nodeQ.right) || (nodeP.right && !nodeQ.right)) return false \r\n\r\n        if (nodeP.left) {\r\n            queueP.push(nodeP.left)\r\n        }\r\n        if (nodeP.right) {\r\n            queueP.push(nodeP.right)\r\n        }\r\n        if (nodeQ.left) {\r\n            queueQ.push(nodeQ.left)\r\n        }\r\n        if (nodeQ.right) {\r\n            queueQ.push(nodeQ.right)\r\n        }\r\n\r\n    }\r\n    if (queueP.length === 0 && queueQ.length === 0) return true\r\n    return false\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315382774","body":"### 思路\r\n遍历使用DFS，路径借用了字符串来存储，注意遍历到叶子节点时要回溯；获得路径集后使用`reduce`累加即可\r\n\r\n### 代码\r\n```javascript\r\n\r\nvar sumNumbers = function(root) {\r\n    if (!root) return 0\r\n    const result = []\r\n    const traverse = (root, str ) => {\r\n        if (!root) return\r\n        str = str + String(root.val)\r\n        // 叶子节点\r\n        if (root && !root.left && !root.right) {\r\n            result.push(str)\r\n            // 回溯\r\n            str = str.slice(0, -1)\r\n            return\r\n        }\r\n        traverse(root.left, str)\r\n        traverse(root.right, str)\r\n    }\r\n    traverse(root, '')\r\n\r\n    return result.reduce((sum, cur) => {\r\n        return sum += Number(cur)\r\n    }, 0)\r\n};\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317149565","body":"### 思路\r\n借助BFS，每次遍历时记录第一项，这是本行最左边的值\r\n\r\n### 代码\r\n```javascript\r\nvar findBottomLeftValue = function(root) {\r\n    if (!root) return null\r\n    let result = null\r\n    const queue = [root]\r\n    while (queue.length > 0) {\r\n        const len = queue.length\r\n        for (let i = 0; i < len; i++) {\r\n            const node = queue.shift()\r\n            if (i === 0) {\r\n                result = node\r\n            }\r\n            node.left && queue.push(node.left)\r\n            node.right && queue.push(node.right)\r\n        }\r\n    }\r\n    return result.val\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度: O(N)\r\n空间复杂度: O(N","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320799630","body":"## 思路\r\n将数组存入map中，再通过比较\r\n\r\n## 代码\r\n```javascript\r\nvar twoSum = function(nums, target) {\r\n    const map = {}\r\n    for (let i = 0; i < nums.length; i++) {\r\n        map[nums[i]] = i\r\n    }\r\n    for (let i = 0; i < nums.length; i++) {\r\n        const num = nums[i]\r\n        if (i !== map[target - num] && map[target - num] > -1) {\r\n            return [i, map[target - num]]\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321134785","body":"## 思路\r\n用的不是二叉堆，使用的是哈希+排序\r\n\r\n## 代码\r\n```javascript\r\nvar topKFrequent = function(nums, k) {\r\n    const map = new Map()\r\n    for(let i = 0; i < nums.length; i++) {\r\n        if (!map.get(nums[i])) {\r\n            map.set(nums[i], 1)\r\n        } else {\r\n           map.set(nums[i], map.get(nums[i]) + 1)\r\n        }\r\n    }\r\n    let arr = Array.from(map).sort((a,b) => b[1] - a[1])\r\n    let result = arr.slice(0, k).map(num => num[0])\r\n    return result\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323892821","body":"## 思路\r\n滑动窗口，map记录字符和它对应得位置，max记录最长的字符串；两个指针start，end，每次遍历移动end；当遇到重复的字符串时，更新start的位置，同时更新这个字符串在map中的位置\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar lengthOfLongestSubstring = function(s) {\r\n    const map = new Map()\r\n    const len = s.length;\r\n    let max = 0\r\n    for (let start = 0, end = 0; end < len; end++) {\r\n        // 此时说明存在相同的字符串了，这时候需要重置start的位置\r\n        if (map.has(s.charAt(end))) {\r\n            start = Math.max(map.get(s.charAt(end)), start)\r\n        }\r\n        // 计算max的最大值\r\n        max = Math.max(max, end - start + 1)\r\n        // 在map中end向前滑动一位\r\n        map.set(s.charAt(end), end + 1)\r\n    }\r\n\r\n    return max\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327644048","body":"## 思路\r\n快慢指针，快指针一次走两步，慢指针一次走一步，快指针走完后，慢指针就为中点\r\n\r\n## 代码\r\n```javascript\r\nvar middleNode = function(head) {\r\n    if (!head) return null\r\n    let prev = cur = head\r\n    while (cur && cur.next) {\r\n        prev = prev.next\r\n        cur = cur.next.next\r\n    }\r\n\r\n    return prev\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327982616","body":"## 思路\r\n双指针，快指针遍历数组，慢数组维护不重复的数据\r\n\r\n## 代码\r\n```javascript\r\nvar removeDuplicates = function(nums) {\r\n  if (nums.length === 0) return 0\r\n  if (nums.length === 1) return 1\r\n  // 智障了，做过这道题\r\n  let len = nums.length\r\n  let cur = 1, next = 1\r\n  while (next < len) {\r\n    if (nums[next] !== nums[next - 1]) {\r\n      nums[cur] = nums[next]\r\n      cur++\r\n    }\r\n    next++\r\n  }\r\n  return cur\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328172742","body":"## 思路\r\n解决本题需要两步：1. 普通二分法查找目标节点；2. 插入到合适的位置；第一点很好处理，关于第二点，其实每次缩小搜索空间到极限时，要插入的点始终在右区间边界的下一位，所以直接返回end + 1就行了。\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let start = 0, end = nums.length - 1\r\n    let result = -1\r\n    let mid \r\n    while(start <= end) {\r\n        mid = Math.floor((start + end) / 2)\r\n        if (nums[mid] === target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            start = mid + 1\r\n        } else if (nums[mid] > target) {\r\n            end = mid - 1\r\n        }\r\n    }\r\n\r\n\r\n    return end + 1\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(logN)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330842947","body":"## 代码\r\n\r\n```javascript\r\nvar findJudge = function(N, trust) {\r\n    var stack = [];\r\n    var fake = []\r\n    if (N === 1){\r\n        return N\r\n    }\r\n    for (var i = 1; i <= N; i++){\r\n        var sum = 0;\r\n        for ( var a = 0;a < trust.length; a++){\r\n            if (i === trust[a][0]){\r\n                fake.push(i)\r\n            }\r\n            if (i === trust[a][1]){\r\n                sum++\r\n                if (sum === N - 1){\r\n                    stack.push(i)\r\n                    continue\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (stack.length === 0){\r\n        return -1\r\n    }\r\n    for (var i = 0; i < stack.length; i++){\r\n        for (var f = 0; f < fake.length; f++){\r\n            if (stack[i] === fake[f]){\r\n                stack.splice(i,1)\r\n            }\r\n        }\r\n    }\r\n    if (stack.length !== 0){\r\n        return stack[0]\r\n    }else{\r\n        return -1\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N*logN)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336350063","body":"## 思路\r\n\r\n1. 将小时转化成分钟\r\n2. 根据条件判断loginTime和logoutTime的前后，如果logoutTime早于loginTime，那么要跨夜了，所以结束时间为： Miniute(logoutTime） + 24 * 60\r\n3. 计算对局数，用logoutTime / 15 - loginTime / 15 来算出完整的对局数；其中logoutTime / 15需要向下取整，因为05:13的时间不算，05:00的时间才算；loginTime / 15则要向上取整\r\n\r\n## 代码\r\n```javascript\r\nvar numberOfRounds = function(loginTime, logoutTime) {\r\n    let start = transformTime(loginTime)\r\n    let end = transformTime(logoutTime)\r\n\r\n    if (start > end) {\r\n        // 需要跨夜了\r\n        end = end + 24 * 60\r\n    }\r\n\r\n    const result = Math.floor(end / 15) - Math.ceil(start / 15)\r\n    if (result < 0) return 0\r\n    return result\r\n};\r\n\r\nconst transformTime = (time) => {\r\n    const [hour, minutes] = time.split(':')\r\n    return Number(hour) * 60 + Number(minutes)\r\n}\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339556090","body":"## 思路\r\n快排\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar sortArray = function(nums) {\r\n    const quickSort = (nums, start, end) => {\r\n        if (start > end) return\r\n        let i = start, j = end, pivot = nums[start]\r\n        while (i !== j) {\r\n            while (nums[j] >= pivot && i < j) {\r\n                j--\r\n            }\r\n            while (nums[i] <= pivot && i < j) {\r\n                i++\r\n            }\r\n\r\n            if (i < j) {\r\n                [nums[i], nums[j]] = [nums[j], nums[i]]\r\n            }\r\n        }\r\n\r\n        nums[start] = nums[i]\r\n        nums[i] = pivot\r\n\r\n        quickSort(nums, start, i - 1)\r\n        quickSort(nums, i + 1, end)\r\n\r\n        return nums\r\n    }\r\n    return quickSort(nums, 0, nums.length - 1)\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(nlogn)，最次是O(n^2)，测试用例遇到n^2了\r\n空间复杂度：O(nlogn)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341052541","body":"## 思路\r\n使用二分法处理，不断地去找mid * mid接近入参的那个值，直到超出边界\r\n\r\n## 代码\r\n```javascript\r\n\r\nvar mySqrt = function(x) {\r\n  let i = 0, j = x\r\n  let result = -1\r\n  while (i <= j) {\r\n      const mid = i + Math.floor((j - i) / 2) \r\n      if (mid * mid <= x) {\r\n        result = mid\r\n        i = mid + 1\r\n      } else {\r\n        j = mid - 1\r\n      }\r\n  }\r\n\r\n  return result\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间复杂度：O(logN)\r\n空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345256047","body":"## 思路\r\n链接打不开看评论做的475题\r\n使用二分法来找到房子最近的暖炉，找到左边和右边的暖炉，在比较左边和右边暖炉距离的最小值，即为当前房子距暖炉的最小半径。最后，再取每个房子距暖炉的最小半径的最大值\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nconst findRadius = (houses, heaters) => {\r\n  heaters.sort((a, b) => a - b)\r\n  let result = 0\r\n  const len = heaters.length\r\n  for (let house of houses) {\r\n    // 当前房子左侧暖炉的位置\r\n    let i = headtersPosSearch(heaters, house)\r\n    // 当前房子右侧暖炉的位置\r\n    let j = i + 1\r\n\r\n    const left = i < 0 ? Infinity : house - heaters[i]\r\n    const right = j >= len ? Infinity : heaters[j] - house\r\n\r\n    result = Math.max(result, Math.min(left, right))\r\n  }\r\n\r\n  return result\r\n}\r\n\r\nconst headtersPosSearch = (nums, target) => {\r\n  let left = 0, right = nums.length - 1\r\n  if (nums[left] > target) return -1 // 说明房屋左侧没有暖炉\r\n  while (left < right) {\r\n    const mid = left + Math.floor((right - left + 1) / 2)\r\n    if (nums[mid] > target) {\r\n      right = mid - 1\r\n    } else {\r\n      left = mid\r\n    }\r\n  }\r\n\r\n  return left\r\n}\r\n\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：O(N*logN)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348839300","body":"## 思路\r\n使用滑动窗口\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar maxVowels = function(s, n) {\r\n\r\n    const letters = ['a','e','i','o','u'];\r\n    const map = new Map();\r\n\r\n    letters.forEach( val => map.set(val,true));\r\n\r\n    let  count = 0;\r\n\r\n    for(let i = 0 ;i < n ; i++){\r\n        if(map.has(s[i])){\r\n            count++;\r\n        }\r\n    }\r\n\r\n    let max = count;\r\n\r\n    for(let i = n  ; i< s.length ; i++){\r\n        if(map.has(s[i])){\r\n            count++\r\n        }\r\n        if(map.has(s[i-n])){\r\n            count--;\r\n        }\r\n        max = Math.max(max,count)\r\n    }\r\n    return max\r\n};\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353273760","body":"## 思路\r\n1. 当s < p时，一定不存在异位词\r\n2. 窗口的大小就是p的长度，比较p中每个单词的数量和窗口中单词的数量是否相等\r\n\r\n## 代码\r\n```javascript\r\n\r\nconst findAnagrams = (s, p) => {\r\n  let slen = s.length, plen = p.length\r\n  if (slen < plen) return []\r\n\r\n  let result = []\r\n  // 26个字母的个数\r\n  const countS = new Array(26).fill(0)\r\n  const countP = new Array(26).fill(0)\r\n  for (let i = 0; i < plen; i++) {\r\n    countS[s[i].charAtCode() - 'a'.charAtCode()]++\r\n    countP[p[i].charAtCode() - 'a'.charAtCode()]++\r\n  }\r\n  if (countS.toString() === countP.toString()) {\r\n    result.push(0)\r\n  }\r\n\r\n  for(let i = 0; i < slen - plen; i++) {\r\n    // --是因为已经比较过了，需要还原\r\n    countS[s[i].charAtCode() - 'a'.charAtCode()]--\r\n    countS[s[i + plen].charAtCode() - 'a'.charAtCode()]++\r\n\r\n    if(countS.toString() === countP.toString()) {\r\n      result.push(i + 1)\r\n    }\r\n  }\r\n  return result\r\n}\r\n\r\n\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356824033","body":"## 思路\r\n\r\n遍历watch的小时和分钟，将他们转换成2进制，接着获取二进制中所有的1，1的个数就是turnedOn\r\n* js转换成二进制的方法是num.toStrint(2)\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nconst transform2Binary = (num) => num.toString(2)\r\nconst getOneCount = (binary) => binary.split('0').join('').length\r\n\r\nconst readBinaryWatch = (turnedOn) => {\r\n    const result = []\r\n    for (let h = 0; h < 12; h++) {\r\n        for (let m = 0; m <= 59; m++) {\r\n            if (getOneCount(transform2Binary(h)) + getOneCount(transform2Binary(m)) === turnedOn) {\r\n                result.push(h + \":\" + (m < 10 ? \"0\" : \"\") + m)\r\n            }\r\n        }\r\n    }\r\n    return result\r\n}\r\n\r\n##  复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(1)\r\n\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359415521","body":"## 思路\r\n先找到1这个点，然后递归去找四周的点，计算总和\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nconst maxAreaOfIsland = (grid) => {\r\n  let x = grid.length, y = grid[0].length, count = 0\r\n  for (let i = 0; i < x; i++) {\r\n    for (let j = 0; j < y; j++) {\r\n      if (grid[i][j] === 1) {\r\n        count = Math.max(count, calclucateIsland(grid, x, y, i, j))\r\n      }\r\n    }\r\n  }\r\n  return count\r\n}\r\n\r\nconst calclucateIsland = (grid, x, y, i, j) => {\r\n  // 处在不可能成为岛或者不是1的情况\r\n  if (i >= x || i < 0 || j >= y || j < 0 || grid[i][j] === 0) return 0\r\n  let num = 1\r\n  // 需要把当前点标为0，不然遍历四周节点时又会计算回这个点导致无限循环\r\n  grid[i][j]=0;\r\n  num += calclucateIsland(grid, x, y, i + 1, j)\r\n  num += calclucateIsland(grid, x, y, i - 1, j)\r\n  num += calclucateIsland(grid, x, y, i, j + 1)\r\n  num += calclucateIsland(grid, x, y, i, j - 1)\r\n\r\n  return num\r\n}\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N^2)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364690156","body":"## 思路\r\n\r\ndp[i]是下标i中偷取的最高金额\r\n递推公式：连续的房子会报警，所以递推公式是dp[i] = Math.max((dp[i - 2] + nums[i]), dp[i - 1])\r\ndp[i - 2] + nums[i]是因为如果偷i的话，那i - 1这个房子肯定不能偷；所以如果不偷i的话，就是取dp[i - 1]\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar rob = function(nums) {\r\n    const dp = []\r\n    dp[0] = nums[0]\r\n    dp[1] = Math.max(nums[0], nums[1])\r\n    const lastIdx = nums.length - 1\r\n    for (let i = 2; i < nums.length; i++) {\r\n        dp[i] = Math.max((dp[i - 2] + nums[i]), dp[i - 1])\r\n    }\r\n\r\n    return dp[lastIdx]\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(N)\r\n康健复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365796663","body":"## 思路\r\n\r\ndp[i][j]指的是字符串text1截止到i和字符串text2截止到j的最长公共子序列的长度\r\n递推：当text1[i - 1] === text2[j - 1]时有 -> dp[i][j] = dp[i - 1][j - 1] + 1，当text1[i - 1] !== text2[j - 1]时有 -> dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\r\n\r\n## 代码\r\n\r\n```javascript\r\nconst longestCommonSubsequence = (text1, text2) => {\r\n    const len1 = text1.length, len2 = text2.length\r\n    // 取len1+1,len2+1的原因是要甩出i - 1, j - 1的量\r\n    const dp = new Array(len1 + 1).fill(0).map(() => new Array(len2 + 1).fill(0))\r\n    for (let i = 1; i <= len1; i++) {\r\n        for (let j = 1; j <= len2; j++) {\r\n            if (text1[i] == text2[j]) {\r\n                dp[i][j] = dp[i - 1][j - 1] + 1\r\n            } else {\r\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\r\n            }\r\n            console.log('i ->', i, 'j ->', j, 'dp->', dp[i][j])\r\n        }\r\n    }\r\n    return dp[len1][len2]\r\n}\r\n\r\n\r\n```\r\n\r\n复杂度分析:\r\n时间复杂度：O(N^2)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366435350","body":"## 思路\r\ndp[i][j]表示在m,n的网格中，走到i，j的位置上时有dp[i][j]条不同的路径\r\n递推公式：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\r\n初始值：所有横纵坐标有0的一律为0，有1的一律为1\r\n\r\n## 代码\r\n```javascript\r\nconst dp = new Array(m+1).fill(0).map(() => new Array(n+1).fill(0))\r\n\r\n    for(let i = 1; i <= m; i++) {\r\n        for(let j = 1; j <=n; j++) {\r\n            if (i === 1 || j === 1) {\r\n                dp[i][j] = 1\r\n            } else {\r\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\r\n            }\r\n        }\r\n    }\r\n    return dp[m][n]\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N^2)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368956992","body":"## 代码\r\n\r\n```javascript\r\nconst coinChange = (coins, amount) => {\r\n    if(!amount) {\r\n        return 0;\r\n    }\r\n\r\n    let dp = Array(amount + 1).fill(Infinity);\r\n    dp[0] = 0;\r\n\r\n    for(let i =0; i < coins.length; i++) {\r\n        for(let j = coins[i]; j <= amount; j++) {\r\n            dp[j] = Math.min(dp[j - coins[i]] + 1, dp[j]);\r\n        }\r\n    }\r\n\r\n    return dp[amount] === Infinity ? -1 : dp[amount];\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370987714","body":"## 思路\r\n贪心算法\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nconst findContentChildren = (g, s) => {\r\n  g.sort((a, b) => a - b)\r\n  s.sort((a, b) => a - b)\r\n  let result = 0\r\n  let cookieIndex = s.length - 1\r\n  for (let i = g.length - 1; i >= 0; i--) {\r\n    if (cookieIndex >= 0 && s[cookieIndex] >= g[i]) {\r\n      result++\r\n      cookieIndex--\r\n    }\r\n  }\r\n\r\n  return result\r\n};\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1372268264","body":"## 思路\r\n贪心算法\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nconst eraseOverlapIntervals = (intervals) => {\r\n  intervals.sort((a, b) => a[1] - b[1])\r\n  let count = 1\r\n  let end = intervals[0][1]\r\n  for (let i = 1; i < intervals.length; i++) {\r\n    if (intervals[i][0] >= end) {\r\n      end = intervals[i][1]\r\n      count++\r\n    }\r\n  }\r\n\r\n  return intervals.length - count\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373792332","body":"## 思路\r\n\r\n贪心算法\r\n\r\n## 代码\r\n```javascript\r\nconst numRescueBoats = (people, limit) => {\r\n  people.sort((a, b) => a - b)\r\n  let ship = 0\r\n  let lightest = 0, heavy = people.length - 1\r\n  while(lightest <= heavy) {\r\n    if (people[lightest] + people[heavy] <= limit) {\r\n      lightest++\r\n    }\r\n    heavy--\r\n    ship++\r\n  }\r\n\r\n  return ship\r\n}\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377312040","body":"## 思路\r\n使用Map计算次数，最后遍历\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\nvar singleNumber = function(nums) {\r\n    const freq = new Map();\r\n    for (const num of nums) {\r\n        freq.set(num, (freq.get(num) || 0) + 1);\r\n    }\r\n    const ans = [];\r\n    for (const [num, occ] of freq.entries()) {\r\n        if (occ === 1) {\r\n            ans.push(num);\r\n        }\r\n    }\r\n    return ans;\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度： O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298606440","body":"#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        out = []\n        i = len(num)-1\n        while i >= 0 or k!=0:\n            x = num[i] if i>=0 else 0\n            y = k%10 if k!=0 else 0\n\n            _sum = x+y+carry\n            carry = _sum//10\n            out.append(_sum%10)\n\n            i -=1\n            k = k//10\n        if carry!=0: \n            out.append(1)\n        return out[::-1]\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300599069","body":"#### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        out = [0]*n\n        indx = -n\n        for i,x in enumerate(s):\n            if x==c:\n                indx = i\n            out[i] = i-indx\n        indx = 2*n\n        for j in range(n-1,-1,-1):\n            if s[j]==c:\n                indx = j\n            out[j] = min(indx-j,out[j])\n\n        return out\n```\n#### 复杂度分析\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302177151","body":"#### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize-1\n        self.cur = -1\n        self.stack = [-1]*maxSize\n\n    def push(self, x: int) -> None:\n        if  self.cur< self.maxsize:\n            self.cur +=1\n            self.stack[self.cur] = x\n\n    def pop(self) -> int:\n        if self.cur == -1:\n            return -1\n        else:\n            self.cur -= 1\n            return self.stack[self.cur+1]\n\n    def increment(self, k: int, val: int) -> None:\n        minl = min(k,self.cur+1)\n        for i in range(minl):\n            self.stack[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n#### 复杂度分析\nO(k)  \nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303605792","body":"#### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, cstr, num = [], \"\", 0\n        for i in s:\n            if \"0\" <= i <= \"9\":\n                num = num*10 + int(i)\n            elif i == \"[\":\n                stack.append((cstr,num))\n                cstr, num = \"\", 0\n            elif i == ']':\n                _cstr,_num = stack.pop()\n                cstr = _cstr + cstr * _num\n            else:\n                cstr += i \n        return cstr\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304378754","body":"#### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout =[]\n\n    def push(self, x: int) -> None:\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stackout:\n            return self.stackout.pop()\n        else:\n            for i in range(len(self.stackin)):\n                self.stackout.append(self.stackin.pop())\n            return self.stackout.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stackout.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stackin or self.stackout)\n```\n#### 复杂度分析\nO(1)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304821843","body":"#### 代码\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305481599","body":"#### 代码\n``` python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k==0:\n            return head\n        \n        n = 1\n        curt = head\n        while curt.next:\n            n += 1\n            curt = curt.next\n        \n        tk = (n-k)%n\n\n        if  tk ==0:\n            return head\n        \n        curt.next = head\n\n        while tk:\n            curt = curt.next\n            tk -= 1\n\n        newhead = curt.next\n        curt.next = None\n        return newhead    \n\n\n```\n#### 复杂度分析\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307274016","body":"#### 代码\n\n``` python\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        dummyHead = ListNode(next = head)\n        cur = dummyHead\n\n        while cur.next and cur.next.next:\n            temp1 = cur.next\n            temp2 = cur.next.next\n            \n            temp1.next = temp2.next\n            temp2.next = temp1\n            cur.next = temp2\n\n            cur = temp1\n     \n        return dummyHead.next\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308780157","body":"#### 代码\n\n``` python\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return head\n        elif not head.next:\n            return TreeNode(val=head.val)\n            \n        slow, fast = head, head\n        leftend = None\n        while fast and fast.next:\n            fast = fast.next.next\n            leftend = slow\n            slow = slow.next\n        if leftend:\n            leftend.next = None\n        \n        root = TreeNode(val=slow.val)\n        if slow == fast:\n            return root\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(slow.next)\n\n        return root\n```\n\n#### 复杂度分析\n\nO(N)  \nO(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309607420","body":"#### 代码\n\n``` python\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if not headA or not headB:\n            return None\n        cura, curb = headA, headB\n        while cura!=curb:\n            if cura:\n                cura = cura.next\n            else:\n                cura = headB\n            if curb:\n                curb = curb.next\n            else:\n                curb = headA\n        return cura\n\n```\n\n#### 复杂度分析\n\nO(m+n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311115889","body":"#### 代码\n\n``` python\nclass Solution(object):\n    def detectCycle(self, head):\n        slow,fast  = head, head\n        while True:\n            if not (fast and fast.next): \n                return None\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: \n                break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```\n\n#### 复杂度分析\n\nO(N)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312507147","body":"#### 代码\n\n``` python\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.cache = dict()\n        self.capacity = capacity\n        self.size = 0\n        self.head = Dlinknode()\n        self.tail = Dlinknode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n\n        self._movenode2head(node)\n\n        return node.value\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = Dlinknode(key, value)\n            self.cache[key] = node\n\n            node.prev = self.head\n            node.next = self.head.next\n            self.head.next.prev = node\n            self.head.next = node\n\n            self.size += 1\n\n            if self.size > self.capacity:\n                node = self.tail.prev\n                node.prev.next = node.next\n                node.next.prev = node.prev\n                self.cache.pop(node.key)\n                self.size -= 1\n\n        else:\n            node = self.cache[key]\n            node.value = value\n            self._movenode2head(node)\n\n\n\n    def _movenode2head(self,node):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n\nclass Dlinknode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n```\n\n#### 复杂度分析\n\nO(1)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312659613","body":"#### 代码\n\n``` python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        ##1\n        # if root is None:\n        #     return 0\n        # leftdep = self.maxDepth(root.left)\n        # rightdep = self.maxDepth(root.right)\n        # curdep = max(leftdep, rightdep) +1\n        # return curdep\n\n        ##2\n        if root is None:\n            return 0\n        layer = [root]\n        dep = 0\n        while layer:\n            dep += 1\n            nextlayer = []\n            for i in layer:\n                if i.left:\n                    nextlayer.append(i.left)\n                if i.right:\n                    nextlayer.append(i.right)\n            layer = nextlayer\n        return dep\n```\n\n#### 复杂度分析\n\nO(n)  \nO(height)\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313493502","body":"#### 代码\n\n``` python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        #1\n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        else:\n            if p.val ==q.val:\n                leftsame = self.isSameTree(p.left,q.left)\n                rightsame = self.isSameTree(p.right,q.right)\n                if leftsame and rightsame:\n                    return True\n                else:\n                    return False\n            else:\n                return False\n```\n\n#### 复杂度分析\n\nO(min(m,n))  \nO(min(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315417037","body":"#### 代码\n\n``` python\nclass Solution:\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\n        def dfs(root,preval):\n            if root is None: return 0\n            curval = preval*10 + root.val\n            if root.left is None and root.right is None:\n                return curval\n            else:\n                leftval = dfs(root.left,curval)\n                rightval = dfs(root.right, curval)\n                return leftval+rightval\n        return dfs(root, 0)   \n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317128249","body":"#### 代码\n\n``` python\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        layer = deque([root])\n        while layer:\n            node = layer.popleft()\n            if node.right:\n                layer.append(node.right)\n            if node.left:\n                layer.append(node.left)\n            val = node.val\n        return val\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318807579","body":"#### 代码\n\n``` python\nclass Codec:\n    def serialize(self, root):\n        def preorder(root):\n            if not root:\n                return \"null,\"\n            return str(root.val) + \",\" + preorder(root.left) + preorder(root.right)\n\n        return preorder(root)[:-1]\n\n    def deserialize(self, data: str):\n        nodes = data.split(\",\")\n\n        def preorder(i):\n            if i >= len(nodes) or nodes[i] == \"null\":\n                return i, None\n            root = TreeNode(nodes[i])\n            j, root.left = preorder(i + 1)\n            k, root.right = preorder(j + 1)\n            return k, root\n\n        return preorder(0)[1]\n```\n\n#### 复杂度分析\n\nO(n)  \nO(h)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319402477","body":"#### 代码\n\n``` python\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        nodes = []\n\n        def dfs(node: TreeNode, row: int, col: int) -> None:\n            if not node: return None\n            nodes.append((col, row, node.val))\n            dfs(node.left, row + 1, col - 1)\n            dfs(node.right, row + 1, col + 1)\n\n        dfs(root, 0, 0)\n        nodes.sort()\n        ans, lastcol = [], None\n\n        for col, row, value in nodes:\n            if col != lastcol:\n                lastcol = col\n                ans.append(list())\n            ans[-1].append(value)\n        \n        return ans\n```\n\n#### 复杂度分析\n\nO(nlogn)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320760770","body":"#### 代码\n\n``` python\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        table = {}\n        for i,x in enumerate(nums):\n            y = target - x\n            if y in table:\n                return [table[y],i]\n            else:\n                table[x] = i\n        return None\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321124065","body":"#### 代码\n\n``` python\nimport heapq\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        alldict = {}\n        for i in range(len(nums)):\n            num = nums[i]\n            alldict[num] = 1 if (num not in alldict) else alldict[num] +1\n            \n        pri_que = []\n        for key, val in alldict.items():\n            heapq.heappush(pri_que, (val,key))\n            if len(pri_que) > k:\n                heapq.heappop(pri_que)\n        \n        out = [0]*k\n        for j in range(k-1, -1, -1):\n            out[j] = heapq.heappop(pri_que)[1]\n        \n        return out\n```\n\n#### 复杂度分析\n\nO(nlogk)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321280333","body":"#### 代码\n\n``` python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0 \n        for x in points:\n            cntdict = {}\n            for y in points:\n                dis = (y[0]-x[0])**2 + (y[1]-x[1])**2\n                cntdict[dis] = 1 if dis not in cntdict else cntdict[dis]+1\n            for i in cntdict.values():\n                ans += i*(i-1)\n        return ans\n```\n\n#### 复杂度分析\n\nO(n^2)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323819263","body":"#### 代码\n\n``` python\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        for i in range(n):\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n            lookup.add(s[i])\n            max_len = len(lookup) if len(lookup) > max_len else max_len\n        return max_len\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325246282","body":"#### 代码\n\n``` python\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        from collections import Counter\n        if not s or not words:\n            return []\n        one_l = len(words[0])\n        allword = len(words)\n        strlen = len(s)\n        words = Counter(words)\n        res = []\n        for i in range(0,one_l):\n            head_count = 0\n            left = i\n            right = i\n            cur_counter = Counter()\n            while right + one_l <= strlen:\n                w = s[right:right+one_l]\n                right += one_l\n                cur_counter[w] += 1\n                head_count += 1\n                while cur_counter[w] >words[w]:\n                    l_w = s[left:left+one_l]\n                    left += one_l\n                    cur_counter[l_w] -= 1\n                    head_count -= 1\n                if head_count == allword:\n                    res.append(left)\n        return res\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326500874","body":"#### 代码\n\n``` python\nclass Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        presum = list(accumulate(nums))\n        extermod = presum[-1] % p\n        if extermod == 0: \n            return 0\n        numslen = len(nums)\n        res = len(nums)\n        moddict = {}\n        moddict[0] = -1\n        for i in range(numslen):\n            presumx = presum[i]\n            xmod = presumx % p\n            findsubmod = (xmod - extermod + p) %p\n            if findsubmod in moddict:\n                sublen = moddict[findsubmod]\n                tempres = i-sublen\n                res = tempres if res>tempres else res\n                if res == 1 and len(nums) != 1:\n                    return 1\n            moddict[xmod] = i\n        if res == numslen: \n            return -1\n        return res\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326919682","body":"#### 代码\n\n``` python\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dumynode = ListNode(next=head)\n        slow = dumynode\n        fast = dumynode\n        while fast:\n            slow = slow.next\n            if fast.next and fast.next.next:\n                fast = fast.next.next\n            else:\n                break\n        return slow\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327995647","body":"#### 代码\n\n``` python\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        n = len(nums)\n        slow = 0\n        fast = 1\n        for i in range(1,n):\n            if nums[fast] != nums[slow]:\n                slow += 1\n                if fast - slow > 0:\n                    nums[slow] = nums[fast]\n            fast += 1\n        return slow +1\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328181220","body":"#### 代码\n\n``` python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)-1\n\n        while left <= right:\n            mid = (left + right)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                right = mid - 1\n            else:\n                left = mid + 1\n\n        return left\n```\n\n#### 复杂度分析\n\nO(logn)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329305392","body":"#### 代码\n\n``` python\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n\n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i - k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])\n        \n        return ans\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329950158","body":"#### 代码\n\n``` python\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        in_degree = [0] * (n+1)\n        out_degree = [0] * (n+1)\n        for x,y in trust:\n            out_degree[x] += 1\n            in_degree[y] += 1\n        for i in range(1,n+1):\n            if out_degree[i] == 0 and in_degree[i] == n-1:\n                return i\n        return -1\n```\n\n#### 复杂度分析\n\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332274220","body":"#### 代码\n\n``` python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def dfs(i, c):\n            color[i] = c\n            for j in g[i]:\n                if color[j] == c:\n                    return False\n                if color[j] == 0 and not dfs(j, 3-c):\n                    return False\n            return True\n        \n        g = defaultdict(list)\n        color = [0]*n\n        for a,b in dislikes:\n            a, b = a-1, b-1\n            g[a].append(b)\n            g[b].append(a)\n        return all(c or dfs(i,1) for i,c in enumerate(color))\n```\n\n#### 复杂度分析\n\nO(n+m)  \nO(n+m)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333869972","body":"```\nclass Solution:\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334519929","body":"#### 代码\n\n``` python\n        if len(moves)%2 == 1:\n            return False\n        y = 0\n        x = 0 \n        for i in moves:\n            if i == \"L\":\n                x += 1\n            elif i == \"R\":\n                x -= 1\n            elif i == \"U\":\n                y += 1\n            else:\n                y -= 1\n        if x == 0 and y == 0:\n            return True\n        else:\n            return False\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336092737","body":"```\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(task[0], i, task[1]) for i,task in enumerate(tasks)]\n        tasks.sort()\n        backlog = []\n        time = 0\n        ans = []\n        pos = 0\n        for _ in tasks:\n            if not backlog:\n                time = max(time, tasks[pos][0])\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(backlog, (tasks[pos][2], tasks[pos][1]))\n                pos += 1\n            d, j = heapq.heappop(backlog)\n            time += d\n            ans.append(j)\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336413832","body":"#### 代码\n\n``` python\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        t0 = 60 * int(loginTime[:2]) + int(loginTime[3:])\n        t1 = 60 * int(logoutTime[:2]) + int(logoutTime[3:])\n        if t1 < t0:\n            t1 += 1440\n        t1 = t1 // 15 * 15\n        return max(0, t1-t0) //15\n```\n\n#### 复杂度分析\n\nO(1)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337476283","body":"```\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        s1 = [0] * 26 \n        s2 = [0] * 26\n        for c in a:\n            s1[ord(c)- ord(\"a\")] += 1\n        for c in b:\n            s2[ord(c)- ord(\"a\")] += 1\n        l1 = len(a)\n        l2 = len(b)\n        cnt1 = 0\n        cnt2 = 0\n        ans =  sys.maxsize\n        for i in range(25):\n            cnt1 += s1[i]\n            cnt2 += s2[i]\n            ans = min(ans, l1+l2-s1[i]-s2[i], l1-cnt1+cnt2, l2-cnt2+cnt1)\n        return min(ans, l1+l2-s1[25]-s2[25])\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338495350","body":"#### 代码\n\n``` python\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        self.mergesort(nums,0,len(nums)-1)\n        return nums\n    \n    def mergesort(self, nums, l, r):\n        if l == r:\n            return None\n        mid = (l+r)//2\n        self.mergesort(nums, l, mid)\n        self.mergesort(nums, mid+1,r)\n        tmp = []\n        i = l\n        j = mid +1\n        while i <= mid or j <= r:\n            if i>mid or (j<=r and nums[j]<nums[i]):\n                tmp.append(nums[j])\n                j += 1\n            else:\n                tmp.append(nums[i])\n                i += 1\n        nums[l:r+1] = tmp   \n```\n\n#### 复杂度分析\n\nO(nlogn)  \nO(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340998036","body":"#### 代码\n\n``` python\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        l = 0\n        r = x\n        ans = -1\n        while l <= r :\n            mid = (l+r) //2\n            if mid * mid <= x:\n                ans = mid\n                l = mid +1\n            else:\n                r = mid -1\n        return ans\n```\n\n#### 复杂度分析\n\nO(logn)  \nO(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341782093","body":"#### 代码\n\n``` python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l = 0\n        r = n\n        while l <= r:\n            mid = (l+r) //2\n            if isBadVersion(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l\n```\n\n#### 复杂度分析\n\nO(logx)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344335425","body":"```\nfrom sortedcontainers import SortedList\nclass Solution:\n    def reversePairs(self, A):\n        d = SortedList()\n        ans = 0\n\n        for a in A:\n            i = d.bisect_right(a * 2)\n            ans += len(d) - i\n            d.add(a)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345236033","body":"#### 代码\n\n``` python\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        ans = 0\n        heaters.sort()\n        for house in houses:\n            j = bisect_right(heaters,house)\n            i = j-1\n            if j < len(heaters):\n                rd = heaters[j] - house\n            else:\n                rd = float(\"inf\")\n            if i >= 0:\n                ld = house - heaters[i]\n            else:\n                ld = float(\"inf\")\n            cd = min(ld, rd)\n            ans = max(ans, cd)\n        return ans\n```\n\n#### 复杂度分析\n\nO((n+m)logn)  \nO(logn)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345443789","body":"```\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def count(mid):\n            cnt = 0\n            for j, num in enumerate(nums):\n                i = bisect_left(nums, num-mid, 0, j)\n                cnt += j - i\n            return cnt\n        nums.sort()\n        return bisect_left(range(nums[-1] - nums[0]), k, key=count)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345714895","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        res = 0\n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        visited = set([(0, 0)])\n\n        while heap:\n            height, x, y = heapq.heappop(heap)\n            res = max(res, height)\n            if x == n-1 and y == n-1:\n                return res\n            \n            for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\n                    visited.add((new_x, new_y))\n                    heapq.heappush(heap, (grid[new_x][new_y], new_x, new_y))  \n            \n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347607936","body":"#### 代码\n\n``` python\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        if len(s)<k: return 0\n        fl = \"aeiou\"\n        res = 0\n        for i in range(k):\n            if s[i] in fl:\n                res += 1\n        out = res\n        l = 0\n        r = l+k-1\n        while r < len(s)-1:\n            if s[l] in fl:\n                res -= 1\n            l += 1\n            r = l+k-1\n            if s[r] in fl:\n                res += 1\n            out = max(out,res)\n        return out\n\n```\n\n#### 复杂度分析\n\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350186748","body":"```\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        dp = [None] * (k+maxPts)\n        s = 0\n        for i in range(k, k+maxPts):\n            dp[i] = 1 if i<=n else 0\n            s += dp[i]\n        for j in range(k-1, -1, -1):\n            dp[j] = s/maxPts\n            s = s - dp[j+maxPts] + dp[j]\n        return dp[0]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353175641","body":"```\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        n, m, res = len(s), len(p), []\n        if n < m: return res\n        p_cnt = [0] * 26\n        s_cnt = [0] * 26\n\n        for i in range(m):\n            p_cnt[ord(p[i]) - ord('a')] += 1\n        \n        left = 0\n        for right in range(n):\n            cur_right = ord(s[right]) - ord('a')\n            s_cnt[cur_right] += 1\n            while s_cnt[cur_right] > p_cnt[cur_right]:\n                cur_left = ord(s[left]) - ord('a')\n                s_cnt[cur_left] -= 1\n                left += 1\n            if right - left + 1 == m:\n                res.append(left)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354603722","body":"```\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n            need=collections.defaultdict(int)\n            for c in t:\n                need[c]+=1\n            needCnt=len(t)\n            i=0\n            res=(0,float('inf'))\n            for j,c in enumerate(s):\n                if need[c]>0:\n                    needCnt-=1\n                need[c]-=1\n                if needCnt==0:       \n                    while True:      \n                        c=s[i] \n                        if need[c]==0:\n                            break\n                        need[c]+=1\n                        i+=1\n                    if j-i<res[1]-res[0]:   \n                        res=(i,j)\n                    need[s[i]]+=1  \n                    needCnt+=1\n                    i+=1\n            return '' if res[1]>len(s) else s[res[0]:res[1]+1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356079003","body":"```\nclass Solution:\n    def solve(self, A, target):\n        if not A and not target: return 0\n        target = sum(A) - target\n        ans = len(A) + 1\n        i = t = 0\n\n        for j in range(len(A)):\n            t += A[j]\n            while i <= j and t > target:\n                t -= A[i]\n                i += 1\n            if t == target: ans = min(ans, len(A) - (j - i + 1))\n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356698040","body":"#### 代码\n\n``` python\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ans = list()\n        for h in range(12):\n            for m in range(60):\n                if bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn:\n                    ans.append(\"{}:{:02d}\".format(h,m))\n        return ans\n```\n\n#### 复杂度分析\n\nO(1)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357702674","body":"```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def backtrack(row: int) -> int:\n            if row == n:\n                return 1\n            else:\n                count = 0\n                for i in range(n):\n                    if i in columns or row - i in diagonal1 or row + i in diagonal2:\n                        continue\n                    columns.add(i)\n                    diagonal1.add(row - i)\n                    diagonal2.add(row + i)\n                    count += backtrack(row + 1)\n                    columns.remove(i)\n                    diagonal1.remove(row - i)\n                    diagonal2.remove(row + i)\n                return count\n                    \n        columns = set()\n        diagonal1 = set()\n        diagonal2 = set()\n        return backtrack(0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359344992","body":"```\nclass Solution:\n    def dfs(self, grid, cur_i, cur_j) -> int:\n        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\n            return 0\n        grid[cur_i][cur_j] = 0\n        ans = 1\n        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\n            next_i, next_j = cur_i + di, cur_j + dj\n            ans += self.dfs(grid, next_i, next_j)\n        return ans\n\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ans = 0\n        for i, l in enumerate(grid):\n            for j, n in enumerate(l):\n                ans = max(self.dfs(grid, i, j), ans)\n        return ans\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298616728","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int size = num.size();\n\n        for(int i = size -1;  i >= 0 || k > 0; i--){\n            if(i>=0){\n                k = num[i] + k;\n            }\n            res.push_back(k % 10);\n            k = k / 10;\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300499931","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> index;\n        vector<int> answer(s.length(), s.length());\n        for(int i = 0; i < s.length(); i++){\n            if(c == s[i] ){\n                index.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.length(); i++){\n            for(int j = 0; j < index.size(); j++){\n                int r = abs(i-index[j]);\n                if (r < answer[i]){\n                    answer[i] = r;\n                }\n            }\n        }\n        return answer;\n    }\n};\n时间复杂度：O(m * k)\n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302284663","body":"class CustomStack {\npublic:\n    int size;\n    int top;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        size = maxSize;\n        stack = vector<int>(maxSize);\n        top = -1;\n    }\n\n    void push(int x) {\n        if(top < size-1){\n            top++;\n            stack[top]=x;\n        }\n        return;\n    }\n\n    int pop() {\n        if(top < 0){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n    }\n\n    void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top; i++){\n            stack[i] += val;\n        }\n        return;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303784300","body":"class Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304384000","body":"class MyQueue {\npublic:\n  vector<int> stdIn;\n  vector<int> stdOut;\n\n  MyQueue() {\n    stdIn = vector<int>();\n    stdIn = vector<int>();\n  }\n\n  void push(int x) {\n    stdIn.push_back(x);\n    if (stdOut.empty()) {\n      auto size = stdIn.size();\n      for (int i = 0; i < size; i++) {\n        stdOut.push_back(stdIn.back());\n        stdIn.pop_back();\n      }\n    }\n  }\n\n  int pop() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    auto res = stdOut.back();\n    stdOut.pop_back();\n    return res;\n  }\n\n  int peek() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    return stdOut.back();\n  }\n\n  bool empty() {\n    if (stdOut.empty() && stdIn.empty()) {\n      return true;\n    }\n    return false;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304736581","body":"原数组和有序数组从一端开始遍历，元素出现的频次相同即可分为一组\nclass Solution {\npublic:\n  int maxChunksToSorted(vector<int> &arr) {\n    unordered_map<int, int> cnt;\n    int res = 0;\n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n    for (int i = 0; i < sortedArr.size(); i++) {\n      int x = arr[i], y = sortedArr[i];\n      cnt[x]++;\n      if (cnt[x] == 0) {\n        cnt.erase(x);\n      }\n      cnt[y]--;\n      if (cnt[y] == 0) {\n        cnt.erase(y);\n      }\n      if (cnt.size() == 0) {\n        res++;\n      }\n    }\n    return res;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305795989","body":"class Solution {\npublic:\n  ListNode *rotateRight(ListNode *head, int k) {\n    if (head == nullptr || head->next == nullptr || k == 0)\n      return head;\n\n    int length = 1;\n    ListNode *fast = head;\n    ListNode *slow = head;\n    while (fast->next != nullptr) {\n      length++;\n      fast = fast->next;\n      if (length > k + 1) {\n        slow = slow->next;\n      }\n    }\n    int t = k / length;\n    if (t > 0) {\n      int y = k % length;\n      for (int i = 0; i < length - y - 1; i++) {\n        slow = slow->next;\n      }\n    }\n    fast->next = head;\n    head = slow->next;\n    slow->next = nullptr;\n    return head;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307352872","body":"class Solution {\npublic:\n  ListNode *swapPairs(ListNode *head) {\n    if (head == nullptr || head->next == nullptr) {\n      return head;\n    }\n    auto first = head;\n    auto second = head->next;\n    auto others = head->next->next;\n    // 先把前两个元素翻转\n    second->next = first;\n    // 利用递归定义，将剩下的链表节点两两翻转，接到后面\n    first->next = swapPairs(others);\n    // 现在整个链表都成功翻转了，返回新的头结点\n    return second;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308912659","body":"class Solution {\npublic:\n  TreeNode *sortedListToBST(ListNode *head) {\n    if (head == nullptr)\n      return nullptr;\n    return sortedListToBST(head, nullptr);\n  }\n  TreeNode *sortedListToBST(ListNode *head, ListNode *tail) {\n    if (head == tail)\n      return nullptr;\n\n    ListNode *slow = head;\n    ListNode *fast = head;\n\n    while (fast != tail && fast->next != tail) {\n      slow = slow->next;\n      fast = fast->next->next;\n    }\n\n    TreeNode *root = new TreeNode(slow->val);\n    root->left = sortedListToBST(head, slow);\n    root->right = sortedListToBST(slow->next, tail);\n    return root;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310481659","body":"ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n    if (headA == NULL || headB == NULL) return NULL;\n\n    ListNode* pA = headA;\n    ListNode* pB = headB;\n    while (pA != pB) {\n        pA = pA == NULL ? headB : pA->next;\n        pB = pB == NULL ? headA : pB->next;\n    }\n\n    return pA;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311872575","body":"ListNode *detectCycle(ListNode *head) {\n    set<ListNode*> seen;\n    ListNode *cur = head;\n    while (cur != NULL) {\n        if (seen.find(cur) != seen.end()) return cur;\n        seen.insert(cur);\n        cur = cur->next;\n    }\n    return NULL;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312512618","body":"class Node {\npublic:\n  int key;\n  int val;\n  Node *next;\n  Node *prev;\n\n  Node() : key(0), val(0), next(nullptr), prev(nullptr) {}\n  Node(int key, int x) : key(key), val(x), next(nullptr), prev(nullptr) {}\n};\nclass Linklist {\npublic:\n  int size;\n  Node *begin;\n  Node *end;\n  Linklist() : size(0), begin(new Node()), end(new Node()) {\n    begin->next = end;\n    end->prev = begin;\n  }\n  Node *insert_front(int key, int x) {\n    Node *node = new Node(key, x);\n    node->next = begin->next;\n    begin->next->prev = node;\n    node->prev = begin;\n    begin->next = node;\n    size++;\n    return node;\n  }\n  Node *delete_back() {\n    if (size <= 0) {\n      throw;\n    }\n    if (end->next == begin) {\n      throw;\n    };\n    auto node = end->prev;\n    end->prev = node->prev;\n    node->prev->next = end;\n    delete node;\n    size--;\n    return node;\n  }\n  Node *update(Node *node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n\n    node->next = begin->next;\n    begin->next->prev = node;\n    node->prev = begin;\n    begin->next = node;\n    return node;\n  }\n};\nclass LRUCache {\nprivate:\n  int cap;\n  int size;\n  unordered_map<int, Node *> cacheMap;\n  Linklist cacheList;\n\npublic:\n  LRUCache(int capacity) : size(0), cap(capacity), cacheMap(), cacheList() {}\n\n  int get(int key) {\n    auto it = cacheMap.find(key);\n    if (it == cacheMap.end()) {\n      return -1;\n    }\n    auto node = it->second;\n    return node->val;\n  }\n\n  void put(int key, int value) {\n    if (size >= cap) {\n      auto d_node = cacheList.delete_back();\n      auto key = d_node->key;\n      cacheMap.erase(key);\n    }\n\n    auto it = cacheMap.find(key);\n    if (it == cacheMap.end()) {\n      auto node = cacheList.insert_front(key, value);\n      cacheMap[key] = node;\n      return;\n    }\n\n    auto node = it->second;\n    node->val = value;\n    cacheList.update(node);\n    return;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312667769","body":"class Solution {\npublic:\n  int maxDepth(TreeNode *root) {\n    if (root == nullptr) {\n      return 0;\n    }\n    auto left = maxDepth(root->left);\n    auto right = maxDepth(root->right);\n\n    return (left > right ? left : right) + 1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313834224","body":"class Solution {\npublic:\n  bool isSameTree(TreeNode *p, TreeNode *q) {\n    if (p == nullptr && q == nullptr) {\n      return true;\n    }\n    if (p == nullptr || q == nullptr) {\n      return false;\n    }\n    if (p->val != q->val) {\n      return false;\n    }\n\n    auto res = isSameTree(p->left, q->left);\n    if (!res) {\n      return false;\n    }\n    res = isSameTree(p->right, q->right);\n    if (!res) {\n      return false;\n    }\n    return true;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315496365","body":"class Solution {\npublic:\n    int sum = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int num) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            sum += num * 10 + root->val;\n            return;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317153858","body":"class Solution {\npublic:\n  int val = 0;\n  int current_max_depth = 0;\n  void findBottomLeftValue_d(TreeNode *root, int depth) {\n    if (root == nullptr) {\n      return;\n    }\n\n    findBottomLeftValue_d(root->left, depth + 1);\n    if (root->left == nullptr && root->right == nullptr) {\n      if (depth > this->current_max_depth) {\n        val = root->val;\n        this->current_max_depth = depth;\n      }\n    }\n    findBottomLeftValue_d(root->right, depth + 1);\n  }\n  int findBottomLeftValue(TreeNode *root) {\n    findBottomLeftValue_d(root, 1);\n    return val;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318767860","body":"  void encode(TreeNode *root, string &s) {\n    if (root == nullptr) { // 空节点在序列化的时候只加上一个逗号\n      s += \",\";\n      return;\n    }\n    s += to_string(root->val) +\n         \",\"; // 非空节点在序列化的时候先加上节点值再加上逗号\n    encode(root->left, s); // 先序遍历序列化二叉树\n    encode(root->right, s);\n  }\n\n  // Encodes a tree to a single string.\n  string serialize(TreeNode *root) {\n    string s;\n    encode(root, s); // 序列化编码的结果记录在字符串s里\n    return s;\n  }\n\n  TreeNode *decode(\n      string &s,\n      int &\n          cur) { // 从字符串s反序列化二叉树，cur是当前解码的字符在字符串s中的下标，这里注意s和cur必须是引用\n    if (s[cur] == ',') { // 如果两个逗号之间什么也没有，说明是空节点\n      ++cur;\n      return nullptr;\n    }\n    int end = cur; // end记录下一个逗号的位置\n    while (end < s.size() && s[end] != ',') {\n      ++end;\n    }\n    TreeNode *root = new TreeNode(stoi(s.substr(\n        cur, end - cur))); // 两个逗号之间的子串的值转为int就是当前节点的值\n    cur = end + 1; // cur从下一个逗号的下一个位置开始解码\n    root->left = decode(s, cur); // 先序遍历解码字符串s\n    root->right = decode(s, cur);\n    return root;\n  }\n\n  // Decodes your encoded data to tree.\n  TreeNode *deserialize(string data) {\n    int cur = 0; // 从要解码的字符串的第0个字母开始解码\n    TreeNode *root = decode(data, cur);\n    return root;\n  }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320202811","body":"class Solution {\npublic:\n    struct node\n    {\n        int val;\n        int x;\n        int y;\n        node(int v,int X,int Y):val(v),x(X),y(Y){};\n    };\n    static bool cmp(node a,node b)\n    {\n        if(a.x^b.x)\n            return a.x<b.x;\n        if(a.y^b.y)\n            return a.y<b.y;\n        return a.val<b.val;\n    }\n    vector<node> a;\n    int minx=1000,maxx=-1000;\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root,0,0);\n        sort(a.begin(),a.end(),cmp);\n        vector<vector<int>>ans(maxx-minx+1);\n        for(auto xx:a)\n        {\n            ans[xx.x-minx].push_back(xx.val);\n        }\n        return ans;\n    }\n    void dfs(TreeNode* root,int x,int y)\n    {\n        if(root==nullptr)\n            return;\n        if(x<minx)\n            minx=x;\n        if(x>maxx)\n            maxx=x;\n        a.push_back(node(root->val,x,y));\n        dfs(root->left,x-1,y+1);\n        dfs(root->right,x+1,y+1);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320904442","body":"func twoSum(nums []int, target int) []int {\n\tfor i, num1 := range nums {\n\t\tfor j := i + 1; j < len(nums); j++ {\n\t\t\tif target == (num1 + nums[j]) {\n\t\t\t\treturn []int{i, j}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321018960","body":"class Solution {\nprivate:\n  map<int, int> frep;\n\n  // 最小堆\n  priority_queue<pair<int, int>, vector<pair<int, int>>,\n                 greater<pair<int, int>>>\n      q;\n\npublic:\n  vector<int> topKFrequent(vector<int> &nums, int k) {\n    for (auto it : nums) {\n      frep[it]++;\n    }\n    // 堆中元素为 [频次，数值] 元组，并根据频次维护小顶堆特性\n    for (auto it : frep) {\n      if (q.size() != k) {\n        q.push(make_pair(it.second, it.first));\n      } else {\n        if (it.second > q.top().first) {\n          q.pop();\n          q.push(make_pair(it.second, it.first));\n        }\n      }\n    }\n    vector<int> res;\n    while (q.size()) {\n      res.push_back(q.top().second);\n      q.pop();\n    }\n    return vector<int>(res.rbegin(), res.rend());\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322246046","body":"class Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323864841","body":"class Solution {\nprivate:\n  unordered_map<char, int> map;\n  pair<int, int> p = pair<int, int>(0, -1);\n  int maxLength = 0;\n\npublic:\n  int lengthOfLongestSubstring(string s) {\n    for (auto i = 0; i < s.length(); i++) {\n      auto c = s[i];\n      p.second = i;\n      auto it = map.find(c);\n      if (it == map.end() || it->second < p.first) {\n        map[c] = i;\n      } else {\n        p.first = it->second + 1;\n        it->second = i;\n      }\n\n      maxLength = max(maxLength, p.second - p.first + 1);\n    }\n\n    return maxLength;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325139893","body":"class Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n            unordered_map<string, int> differ;\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326451859","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327516485","body":"class Solution {\npublic:\n  ListNode *middleNode(ListNode *head) {\n    ListNode *p = head;\n    ListNode *q = head;\n\n    while (q != nullptr && q->next != nullptr) {\n      p = p->next;\n      q = q->next->next;\n    }\n\n    return p;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328055804","body":"class Solution {\npublic:\n  int removeDuplicates(vector<int> &nums) {\n    int p = 0;\n    for (int i = 0; i < nums.size(); i++) {\n      if (nums[i] == nums[p]) {\n        continue;\n      }\n      p++;\n      swap(nums[p], nums[i]);\n    }\n    return p + 1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328242128","body":"class Solution {\npublic:\n  int searchInsert(vector<int> &nums, int target) {\n    int left = 0;\n    int right = nums.size() - 1;\n    while (left <= right) {\n      auto mid = (right - left) / 2 + left;\n      if (nums[mid] == target) {\n        return mid;\n      }\n      if (nums[mid] < target)\n        left = mid + 1;\n      else\n        right = mid - 1;\n    }\n    return left;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329229081","body":"class Solution {\npublic:\n    vector<int> res;\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> q; // 双端队列，存储的是当前窗口最大值的索引，维护操作: 保持单调递减，队头是最大值\n\n        for (int i = 0; i < nums.size(); i++) {\n            // 依次地将数组元素加入到队列中\n            // 注意: 确保队列元素间的距离都在k以内\n            if (!q.empty() && i - k + 1 > q.front()) /* 倒着数第k个与队列开头数的index比较。窗口长度>k时，从队列中删掉最前面的数 */\n                q.pop_front();\n            while (!q.empty() && nums[i] >= nums[q.back()])\n                q.pop_back();  /* 不断地把左侧比自己小的数从队列中删掉, 遇到下一个比自己大的数时自己会被删掉。遇到比自己小的数得留着，最终双端队列会成为递减队列。 */\n\n            q.push_back(i);\n            if (i >= k - 1)      // 只要窗口大小 ≥ k 时, 窗口就会有最大值，将其放进res(结果vector)中\n            {\n                res.push_back(nums[q.front()]);\n            }\n        }\n\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330788372","body":"class Solution {\npublic:\n  int findJudge(int n, vector<vector<int>> &trust) {\n    if (trust.empty() && n == 1)\n      return 1;\n    unordered_map<int, int> count;\n    for (auto &relation : trust) {\n      count[relation[0]] += -1;\n      count[relation[1]] += 1;\n    }\n    for (auto &kvp : count) {\n      if (kvp.second == (n - 1))\n        return kvp.first;\n    }\n    return -1;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332268818","body":"class Solution {\npublic:\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\n        color[curnode] = nowcolor;\n        for (auto& nextnode : g[curnode]) {\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\n                return false;\n            }\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> color(n + 1, 0);\n        vector<vector<int>> g(n + 1);\n        for (auto& p : dislikes) {\n            g[p[0]].push_back(p[1]);\n            g[p[1]].push_back(p[0]);\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\n                return false;\n            }\n        }\n        return true;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333825986","body":"import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\n\npublic class Solution {\n\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\n        for (int i = 0; i < group.length; i++) {\n            if (group[i] == -1) {\n                group[i] = m;\n                m++;\n            }\n        }\n\n        // 第 2 步：实例化组和项目的邻接表\n        List<Integer>[] groupAdj = new ArrayList[m];\n        List<Integer>[] itemAdj = new ArrayList[n];\n        for (int i = 0; i < m; i++) {\n            groupAdj[i] = new ArrayList<>();\n        }\n        for (int i = 0; i < n; i++) {\n            itemAdj[i] = new ArrayList<>();\n        }\n\n        // 第 3 步：建图和统计入度数组\n        int[] groupsIndegree = new int[m];\n        int[] itemsIndegree = new int[n];\n\n        int len = group.length;\n        for (int i = 0; i < len; i++) {\n            int currentGroup = group[i];\n            for (int beforeItem : beforeItems.get(i)) {\n                int beforeGroup = group[beforeItem];\n                if (beforeGroup != currentGroup) {\n                    groupAdj[beforeGroup].add(currentGroup);\n                    groupsIndegree[currentGroup]++;\n                }\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (Integer item : beforeItems.get(i)) {\n                itemAdj[item].add(i);\n                itemsIndegree[i]++;\n            }\n        }\n\n        // 第 4 步：得到组和项目的拓扑排序结果\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\n        if (groupsList.size() == 0) {\n            return new int[0];\n        }\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\n        if (itemsList.size() == 0) {\n            return new int[0];\n        }\n\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\n        // key：组，value：在同一组的项目列表\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\n        for (Integer item : itemsList) {\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\n        }\n\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\n        List<Integer> res = new ArrayList<>();\n        for (Integer groupId : groupsList) {\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\n            res.addAll(items);\n        }\n        return res.stream().mapToInt(Integer::valueOf).toArray();\n    }\n\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\n        List<Integer> res = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            Integer front = queue.poll();\n            res.add(front);\n            for (int successor : adj[front]) {\n                inDegree[successor]--;\n                if (inDegree[successor] == 0) {\n                    queue.offer(successor);\n                }\n            }\n        }\n\n        if (res.size() == n) {\n            return res;\n        }\n        return new ArrayList<>();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335434734","body":"class Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int x = 0, y =0;\n        for (const char move : moves) {\n            if (move == 'R') {\n                x++;\n            }\n            if (move == 'L') {\n                x--;\n            }\n            if (move == 'U') {\n                y++;\n            }\n            if (move == 'D') {\n                y--;\n            }\n        }\n        return x==0 && y==0;\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336437180","body":"class Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        // 转化为分钟\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if (t1 < t0){\n            // 此时 finishTime 为第二天\n            t1 += 1440;\n        }\n        // 第一个小于等于 finishTime 的完整对局的结束时间\n        t1 = t1 / 15 * 15;\n        return max(0, (t1 - t0)) / 15;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337480855","body":"class Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> acnt(26, 0);\n        vector<int> bcnt(26, 0);\n        int an = a.size(), bn = b.size();\n        \n        for (char c : a) acnt[c-'a']++;\n        for (char c : b) bcnt[c-'a']++;\n        \n        int ans = INT_MAX, asum = 0, bsum = 0;\n        for (int i = 0; i < 25; i++) {\n            asum += acnt[i];\n            bsum += bcnt[i];\n            ans = min(min(ans, an-acnt[i]+bn-bcnt[i]), min(an-asum+bsum, bn-bsum+asum));\n        }\n        ans = min(ans, an-acnt[25]+bn-bcnt[25]);\n        \n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339437279","body":"class Solution {\n    int partition(vector<int>& nums, int l, int r) {\n        int pivot = nums[r];\n        int i = l - 1;\n        for (int j = l; j <= r - 1; ++j) {\n            if (nums[j] <= pivot) {\n                i = i + 1;\n                swap(nums[i], nums[j]);\n            }\n        }\n        swap(nums[i + 1], nums[r]);\n        return i + 1;\n    }\n    int randomized_partition(vector<int>& nums, int l, int r) {\n        int i = rand() % (r - l + 1) + l; // 随机选一个作为我们的主元\n        swap(nums[r], nums[i]);\n        return partition(nums, l, r);\n    }\n    void randomized_quicksort(vector<int>& nums, int l, int r) {\n        if (l < r) {\n            int pos = randomized_partition(nums, l, r);\n            randomized_quicksort(nums, l, pos - 1);\n            randomized_quicksort(nums, pos + 1, r);\n        }\n    }\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        srand((unsigned)time(NULL));\n        randomized_quicksort(nums, 0, (int)nums.size() - 1);\n        return nums;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298627092","body":"### 思路\nK+num（个位加个位，十位加十位）\n个位 除 1 取余10，十位 除10 取余 10，百位 除 100 取余10 \n取余数的反转结果集\n[9,9,9,9,9,9,9,9,9,9] 1,报错，超过了int最大值，要么换long，要么换个思路，取余k，而不是给数组内的值\n\n### 代码\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, long k){\n        int numSize = num.length;\n        //[1,8,9,2]  k = 34  1926\n        ArrayList<Integer> rst = new ArrayList<>();\n        for(int i = numSize - 1 ;i >= 0; --i){\n            //36, 90+36 = 126,126 + 800 = 926,926 + 1000 = 1926\n            k += num[i] * Math.pow(10,numSize - i -1);\n            // 36, 12, 9,1\n            int j = (int) (k / Math.pow(10,numSize - i -1));\n            // 6,2,9,1\n            rst.add(j % 10);\n        }\n        //如果K比数组大，还要继续取余\n//        for (int i = )\n        k /= Math.pow(10,numSize);\n        for (;k>0;k/=10){\n            rst.add((int)(k % 10));\n        }\n        Collections.reverse(rst);\n        return rst;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，N为数组的长度，思考：1. N是否可以为K的长度，2. 列表不需要反转\n- 空间复杂度：O(N)，N为集合的长度","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305578942","body":"## 61. 旋转链表\n\n### 思路\n\n 1. 链表长度n，移动k次\n 2. 当k > n又n每移动n次变为原样，链表仅移动k mod n次\n 3. 新链表的最后一个位置为原链表的(n -1) - (k mod n)\n 4. 将链表链接成环，在指定位置断开\n\n### 代码\n\n```java\npublic class Solution {\n\n    public class ListNode {\n        int val;\n        ListNode next;\n\n        ListNode() {\n        }\n\n        ListNode(int val) {\n            this.val = val;\n        }\n\n        ListNode(int val, ListNode next) {\n            this.val = val;\n            this.next = next;\n        }\n    }\n\n\n    public ListNode rotateRight(ListNode head, int k) {\n\n        // 先链接成环\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        // n代表链表的长度\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n\n        // 找到指定位置\n        int add = n - (k % n);\n        // 断开\n        if (add == n) {\n            return head;\n        }\n\n        //尾头相连\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n\n        ListNode ret = iter.next;\n        iter.next = null;\n        // 返回\n\n        return ret;\n    }\n\n\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N),最坏遍历两次\n- 空间复杂度：O(1),常熟个空间存储若干变量","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298659136","body":"```\nvar addToArrayForm = function(num, k) {\n    //使用 BigInt是确保当数组足够长的时候，防止整形的精度丢失\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299694150","body":"```javascript\nvar shortestToChar = function(s, c) {\n    let res = [], arr = []\n    // 拿到所有c的索引值\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == c) arr.push(i)\n    }\n    // 利用双循环比较绝对距离\n    for(let i = 0; i < s.length; i++){\n        let min = +Infinity\n        for(let j = 0; j < arr.length; j++){\n            min = Math.min(Math.abs(i - arr[j]), min)\n        }\n        res.push(min)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302201160","body":"```javascript\n/**\n * @param {number} maxSize\n */\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.head=null;\n    this.length=0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303743513","body":"```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let r = ''\n    var a = function(t) {\n        const firstClose = t.indexOf(']')\n        if ( firstClose == -1 ) r = t \n        if ( firstClose != -1 ) {\n        const rangeLastOpen =  t.substring(0, firstClose).lastIndexOf('[')\n        var reg = /(\\d+)$/g\n        var z = reg.exec(t.substring(0, rangeLastOpen))\n        if (z) {\n        const zNum = z[0]\n        const changeChars = t.substring(rangeLastOpen + 1, firstClose)\n        const num = parseInt(zNum)\n        let beforechange = ''\n        for(let a = 0; a < num ; a ++) {\n            beforechange += changeChars\n        }\n        const result = t.substring(0, rangeLastOpen - zNum.length) + beforechange + t.substring(firstClose + 1)\n        if (result.indexOf(']') != -1) a(result)\n        if (result.indexOf(']') === -1) r = result\n        }\n        }\n    }\n    a(s)\n    return r;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304554634","body":"```javascript\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    let tmp = this.outStack.pop()\n    this.outStack.push(tmp)\n    return tmp\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794630","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    let help = []\n    help[arr.length] = Number.MAX_SAFE_INTEGER\n    for (let i = arr.length - 1; i >= 0; i--) {\n        help[i] = Math.min(arr[i],help[i + 1])\n    }\n    let cnt = 0,mx = -1\n    arr.forEach((val,i) => {\n        mx = Math.max(mx,val)\n        if(mx <= help[i + 1]) cnt++\n    })\n    return cnt\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312478893","body":"```javascript\n/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.map = new Map()\n    this.max = capacity\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if (this.map.has(key)) {\n        const value = this.map.get(key)\n        this.map.delete(key)\n        this.map.set(key, value)\n        return value\n    }\n    return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    if (this.map.has(key)) {\n        this.map.delete(key)\n    }\n\n    if (this.map.size === this.max) {\n        const delKey = this.map.keys().next().value\n        this.map.delete(delKey)\n    }\n\n    this.map.set(key, value)\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314948080","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number}\n */\nvar sumNumbers = function(root) {\n    if(root === null) return -1;\n    const findAll = (root, path = []) => {\n        if(root === null) return;\n        path.push(root.val);\n        if(root.left === null && root.right === null) {\n            sum += parseInt(path.join(''));\n        }\n        root.left && findAll(root.left, path);\n        root.right && findAll(root.right, path);\n        path.pop();\n    };\n    let sum = 0;\n    findAll(root);\n    return sum;\n};\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319421959","body":"```javascript\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\n\nvar verticalTraversal = function(root) {\n  let ans = [], temp = []\n  const dfs = (root, row, col) => {\n    if(!root) return\n    row ++\n    temp.push([root.val, row, col])\n    dfs(root.left, row, col - 1)\n    dfs(root.right, row, col + 1)\n  }\n  dfs(root, 0, 0)\n\n  temp.sort((a,b) => a[2] - b[2] || a[1] - b[1] || a[0] - b[0])\n\n  let prev\n\n  for(let [val, , col] of temp){\n    if(col !== prev){\n      prev = col\n      ans.push([])\n    }\n    ans[ans.length -1].push(val)\n  }\n  return ans\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324596957","body":"```javascript\n/**\n * @param {string} s\n * @param {string[]} words\n * @return {number[]}\n */\nvar findSubstring = function(s, words) {\n    words = words.sort()\n    var wl = words[0].length;\n    var l = words.length * wl;\n    var res = [];\n    if (s.length < l) return res;\n    const regex = new RegExp(`.{${wl}}`, 'g')\n    for (var i = 0; i < s.length; i+=1) {\n        const ss = (s.substring(i, i+l).match(regex) || []).sort()\n        if (ss.length===words.length && ss.every((_,j) => ss[j]===words[j])) {\n            res.push(i)\n        }\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328407181","body":"```javascript\nvar maxSlidingWindow = function(nums, k) {\n const n = nums.length;\n    const q = [];\n    for (let i = 0; i < k; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n    }\n\n    const ans = [nums[q[0]]];\n    for (let i = k; i < n; i++) {\n        while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n            q.pop();\n        }\n        q.push(i);\n        while (q[0] <= i - k) {\n            q.shift();\n        }\n        ans.push(nums[q[0]]);\n    }\n    return ans;\n\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1336925671","body":"```javascript\n/**\n * @param {string} moves\n * @return {boolean}\n */\nvar judgeCircle = function (moves) {\n  let m = new Map([\n    [\"R\", 0],\n    [\"L\", 0],\n    [\"U\", 0],\n    [\"D\", 0],\n  ])\n  for (let i = 0; i < moves.length; i++) {\n    m.set(moves[i], m.get(moves[i]) + 1)\n  }\n  return m.get(\"R\") === m.get(\"L\") && m.get(\"U\") === m.get(\"D\")\n};\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336921733","body":"/**\n * @param {string} a\n * @param {string} b\n * @return {number}\n */\nvar minCharacters = function(a, b) {\n    let da = new Array(26).fill(0);\n    let db = new Array(26).fill(0);\n    for(let i in a) {\n        da[a.charCodeAt(i) - 97] ++;\n    }\n    for(let i in b) {\n        db[b.charCodeAt(i) - 97] ++;\n    }\n    let an = a.length, bn = b.length, asum = 0, bsum = 0, res = Number.MAX_SAFE_INTEGER;\n    for(let i = 0 ; i < 25 ; i ++) {\n        asum += da[i];\n        bsum += db[i];\n        res = Math.min(res, an+bn-da[i]-db[i], an-asum+bsum, bn-bsum+asum);\n    }\n    return Math.min(res, an+bn-da[25]-db[25]);\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345565147","body":"```javascript\n/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar smallestDistancePair = function(nums, k) {\n    nums.sort((a, b) => a - b)\n\n    let len = nums.length\n    let left = 0 \n    let right = nums[len - 1] - nums[0]\n\n    while (left < right) {\n      mid = left + ((right - left) >> 1)\n      let cur = 0\n      let start = 0\n\n      for (let i = 0; i < nums.length; i++) {\n        while (nums[i] - nums[start] > mid) {\n          start += 1\n        }\n        cur += i - start\n      }\n      if (cur < k) {\n        left = mid + 1\n      } else {\n        right = mid\n      }\n    }\n\n    return left\n};\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1354054743","body":"```javascript\n/**\n * @param {string} s\n * @param {string} t\n * @return {string}\n */\nvar minWindow = function(s, t) {\n    let l = 0\n    let r = 0\n    const need = new Map()\n    for(let c of t){\n        need.set( c,need.has(c) ? need.get(c) + 1 : 1)\n    }\n\n    let needType = need.size\n    let res = ''\n    while(r<s.length){\n        let c = s[r]\n        if(need.has(c)){\n            need.set( c,need.get(c) -1 )\n            if( need.get(c) === 0) needType -= 1\n        }\n        \n        while(needType === 0){\n            const newRes = s.substring(l,r+1)\n            if( !res || newRes.length < res.length ) res = newRes\n\n            const c2 = s[l]\n            if(need.has(c2)){\n                need.set(c2,need.get(c2) + 1)\n                if( need.get(c2) === 1 ) needType += 1\n            }\n            l += 1\n        }\n        r += 1\n    }\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298679459","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300415798","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n);\n        int k = -n;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) k = i;\n            ans[i] =i-k;\n            ;\n    \n        }\n    \n    \n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) k = i;\n            ans[i] = min(ans[i], abs(i - k));\n        }\n        return ans;\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303523803","body":"class Solution {\npublic:\n    string src; \n    size_t ptr;\n\n    int getDigits() {\n        int ret = 0;\n        while (ptr < src.size() && isdigit(src[ptr])) {\n            ret = ret * 10 + src[ptr++] - '0';\n        }\n        return ret;\n    }\n\n    string getString() {\n        if (ptr == src.size() || src[ptr] == ']') {\n            // String -> EPS\n            return \"\";\n        }\n\n        char cur = src[ptr]; int repTime = 1;\n        string ret;\n\n        if (isdigit(cur)) {\n            // String -> Digits [ String ] String\n            // 解析 Digits\n            repTime = getDigits(); \n            // 过滤左括号\n            ++ptr;\n            // 解析 String\n            string str = getString(); \n            // 过滤右括号\n            ++ptr;\n            // 构造字符串\n            while (repTime--) ret += str; \n        } else if (isalpha(cur)) {\n            // String -> Char String\n            // 解析 Char\n            ret = string(1, src[ptr++]);\n        }\n        \n        return ret + getString();\n    }\n\n    string decodeString(string s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304565205","body":"class MyQueue {\npublic:\n    MyQueue() {\n       \n    }\n     stack<int> A; //用来入队\n     stack<int> B; //用来出队\n    \n    void push(int x) {\n        A.push(x);\n    }\n    \n    int pop() {\n        \n        if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        //B栈不空，直接出栈，表示出队\n        int top = B.top();\n        B.pop();\n        return top;\n    }\n    \n    int peek() {\n         if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        return B.top();\n    }\n    \n    bool empty() {\n        return A.empty() && B.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801035","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i=0; i<arr.size(); i++){\n\n            if(!stack.empty()&&stack.top()>arr[i]){\n\n                int cur = stack.top();\n            \n            \n                while(!stack.empty()&&stack.top()>arr[i]){\n\n                    stack.pop();\n                }\n                stack.push(cur);\n                }\n            else{\n                stack.push(arr[i]);\n            }\n\n        }\n        return stack.size();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305749716","body":"ListNode* rotateRight(ListNode* head, int k) {\n    if (head == nullptr\n        || head->next == nullptr\n        || k == 0)\n        return head;\n\n    int len = 1;\n    ListNode* cur = head;\n    while (cur->next != nullptr) {\n        cur = cur->next;\n        len++;\n    }\n\n    k %= len;\n\n    ListNode* fast = head;\n    ListNode* slow = head;\n\n    while (fast->next != nullptr) {\n        if (k-- <= 0) {\n            slow = slow->next;\n        }\n        fast = fast->next;\n    }\n\n    fast->next = head;\n    ListNode* new_head = slow->next;\n    slow->next = nullptr;\n    return new_head;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307108353","body":"class Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if (head == nullptr || head->next == nullptr) \n        return head;\n    ListNode* weito = new ListNode(-1,head);\n    ListNode* pre = weito;\n    ListNode* node = weito->next;\n     \n    while(node && node->next)\n    {\n        ListNode* sec = node->next;//存下第二个节点\n        node->next = sec->next;//第一个节点指向第三个节点\n        sec->next = node;//第二个节点指向第一个节点\n        pre->next = sec;//  前向节点指向新的交换后的节点\n    \n        pre = node;\n        node = node->next;\n        \n\n    }\n    return weito->next;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308861929","body":"class Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        return sortedListToBST(head, nullptr);\n    }\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail){\n\n        if (head==tail) return nullptr;\n        ListNode* slow = head;\n        ListNode* fast = head;\n        while (fast!=tail && fast->next!=tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        TreeNode* root = new TreeNode(slow->val);\n        root->left = sortedListToBST(head, slow);\n        root->right = sortedListToBST(slow->next, tail);\n        return root;\n\n    }\n\n        \n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310246232","body":"class Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode* headA, ListNode* headB) {\n        if (headA == NULL || headB == NULL) return NULL;\n    \n    map<ListNode*, bool> seen;\n    while (headA){\n\n        seen.insert(pair<ListNode*, bool>(headA, true));\n        headA = headA->next;\n    }\n    while (headB){\n        if (seen.find(headB) != seen.end()) return headB;\n        headB = headB->next;\n    }\n    return  NULL;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311752099","body":"class Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *fast = head;\n        ListNode *slow = head;\n\n    while(fast && fast->next){\n        slow = slow->next;\n        fast = fast->next->next;\n        if (slow == fast){\n            fast = head;\n        \n        while (slow != fast){\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n        }\n    }\n    return NULL;\n}\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312490640","body":"void afterNodeAccess(Node<K,V> e) { // move node to last\n    // 用 last 表示插入 e 前的尾节点\n    // 插入 e 后 e 是尾节点, 所以也是表示 e 的前一个节点\n    LinkedHashMap.Entry<K,V> last;\n    //如果是访问序，且当前节点并不是尾节点\n    //将该节点置为双向链表的尾部\n    if (accessOrder && (last = tail) != e) {\n        // p: 当前节点\n        // b: 前一个节点\n        // a: 后一个节点\n        // 结构为: b <=> p <=> a\n        LinkedHashMap.Entry<K,V> p =\n            (LinkedHashMap.Entry<K,V>)e, b = p.before, a = p.after;\n        // 结构变成: b <=> p <- a\n        p.after = null;\n\n        // 如果当前节点 p 本身是头节点, 那么头结点要改成 a\n        if (b == null)\n            head = a;\n        // 如果 p 不是头尾节点, 把前后节点连接, 变成: b -> a\n        else\n            b.after = a;\n\n        // a 非空, 和 b 连接, 变成: b <- a\n        if (a != null)\n            a.before = b;\n        // 如果 a 为空, 说明 p 是尾节点, b 就是它的前一个节点, 符合 last 的定义\n      \t// 这个 else 没有意义，因为最开头if已经确保了p不是尾结点了，自然after不会是null\n        else\n            last = b;\n\n        // 如果这是空链表, p 改成头结点\n        if (last == null)\n            head = p;\n        // 否则把 p 插入到链表尾部\n        else {\n            p.before = last;\n            last.after = p;\n        }\n        tail = p;\n        ++modCount;\n    }\n}\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312741075","body":"class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        int ans = 0;\r\n        Deque<TreeNode> d = new ArrayDeque<>();\r\n        if (root != null) d.addLast(root);\r\n        while (!d.isEmpty()) {\r\n            int sz = d.size();\r\n            while (sz-- > 0) {\r\n                TreeNode node = d.pollFirst();\r\n                if (node.left != null) d.addLast(node.left);\r\n                if (node.right != null) d.addLast(node.right);\r\n            }\r\n            ans++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312991506","body":"先检查当前根节点，再检查当前节点的左右节点；\n然后递归，将左右节点作为根节点，继续检查左右\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr && q == nullptr) return true;\n        if( p == nullptr && q != nullptr) return false;\n        if(p != nullptr && q == nullptr) return false;\n    return p->val==q->val && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315331406","body":"class Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n    if (root == nullptr){\n        return 0;\n    }\n    dfs(root, root->val);\n    return sum;\n    }\n    int sum = 0;\n    void dfs(TreeNode* root, int cursum){\n        if (root->left == nullptr && root->right == nullptr){\n            sum += cursum;\n            return;\n        }\n        if (root->left != nullptr){\n            dfs(root->left, cursum * 10 + root->left->val);\n        }\n        if (root->right != nullptr){\n            dfs(root->right, cursum * 10 + root->right->val);\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317098556","body":"\npublic class Solution513 {\n \n    public int findBottomLeftValue(TreeNode root) {\n        List<TreeNode> list = new ArrayList<>();\n        list.add(root);\n        TreeNode treeNode = levelSearch(list);\n        return treeNode.val;\n    }\n \n    private TreeNode levelSearch(List<TreeNode> list) {\n        List<TreeNode> nextList = new ArrayList<>();\n        for (TreeNode node : list) {\n            if (node.left != null) {\n                nextList.add(node.left);\n            }\n            if (node.right != null) {\n                nextList.add(node.right);\n            }\n        }\n        if (nextList.size() == 0) {\n            return list.get(0);\n        }\n        return levelSearch(nextList);\n    }\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318587293","body":"public class Codec {\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if(root == null) return \"\";\n        StringBuilder res = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.add(root);\n        while(!queue.isEmpty()){\n            TreeNode cur = queue.remove();\n            if(cur == null){\n                res.append(\"null,\");\n            }else{\n                res.append(cur.val + \",\");\n                queue.add(cur.left);\n                queue.add(cur.right);\n            }\n        }\n        return res.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if(data.length() == 0) return null;\n        String[] nodes = data.split(\",\");\n        TreeNode root = getNode(nodes[0]);\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);\n        int index = 1;\n        while(!queue.isEmpty()){\n            TreeNode temp = queue.poll();\n            if(!nodes[index].equals(\"null\")) {\n                temp.left = getNode(nodes[index]);\n                queue.offer(temp.left);\n            }\n            index++;\n            if(!nodes[index].equals(\"null\")) {\n                temp.right = getNode(nodes[index]);\n                queue.offer(temp.right);\n            }\n            index++;\n        }\n        return root;\n    }\n\n    private TreeNode getNode(String val){\n        if(val.equals(\"null\")){\n            return null;\n        }\n        return new TreeNode(Integer.valueOf(val));\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320169681","body":"public List<List<Integer>> verticalTraversal(TreeNode root) {\n        List<int[]> nodes = new ArrayList<int[]>();\n        // 遍历所有节点信息\n        dfs(root, 0, 0, nodes);\n        // 自定义排序规则\n        Collections.sort(nodes, new Comparator<int[]>(){\n            public int compare(int[] a, int[] b) {\n                if (a[0] != b[0]) {\n                    // 优先按照col升序排序\n                    return a[0] - b[0];\n                }\n                else if (a[1] != b[1]) {\n                    // 其次按照row升序排序\n                    return a[1] - b[1];\n                }\n                else{\n                    // 最后按照节点值升序\n                    return a[2] - b[2];\n                }\n            }\n        });\n        List<List<Integer>> traversal = new ArrayList<List<Integer>>();\n        int col = Integer.MIN_VALUE;\n        int index = -1;\n        for (int[] node : nodes) {\n            int curCol = node[0];\n            // 若当前col已经和之前不同\n            if (col != curCol) {\n                // 更新col\n                col = curCol;\n                // 添加新列表\n                traversal.add(new ArrayList<Integer>());\n                // 更新集合下标\n                index++;\n            }\n            // 存入当前节点\n            traversal.get(index).add(node[2]);\n        }\n        return traversal;\n    }\n    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {\n        if (node == null)\n            return;\n        // 添加节点信息\n        nodes.add(new int[]{col, row, node.val});\n        // 递归遍历\n        dfs(node.left, row+1, col-1, nodes);\n        dfs(node.right, row+1, col+1, nodes);\n    }\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320894341","body":" class Solution{\n    public:\n    vector<int> twoSum(vector<int> & nums, int target){\n        int n = nums.size();\n        for(int i=0;i<n;i++){\n            for(int j=i+1;j<n;j++){\n                if(nums[i] + nums[j]==target){\n                    return{i,j};\n                }\n            }\n        }\n        return{};\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321155490","body":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n         unordered_map<int,int> mp;      //先计算每个元素的频数\n        int length=nums.size();\n        for(int i=0;i<length;i++){\n            mp[nums[i]]++;\n        }\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>> > heap;       //利用 优先队列 进行排序\n        for(auto j:mp){\n            heap.push(make_pair(j.second,j.first));\n            if(heap.size()>k){\n                heap.pop();\n            }\n        }\n        vector<int> arr;            //将符合题意的元素放入数组arr中，并返回结果\n        for(int i=0;i<k;i++){\n            arr.push_back(heap.top().second);\n            heap.pop();\n        }\n        return arr;\n\n    }\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323790025","body":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        StringBuilder stringBuilder = new StringBuilder();\n        int l = 0;\n        for (int i = 0; i < s.length(); i++) {\n            String c = String.valueOf(s.charAt(i));\n            if (stringBuilder.indexOf(c) >= 0) {\n                stringBuilder.delete(0, stringBuilder.indexOf(c) + 1);\n            }\n            stringBuilder.append(c);\n            l = Math.max(stringBuilder.length(), l);\n        }\n        return l;\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325238307","body":"class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m,w = len(words),len(words[0])\n        M = {}\n        for it in words:\n            if it not in M.keys(): M[it] = 1\n            else: M[it] += 1\n        for i in range(w):\n            S = {}\n            j,cnt = i,0\n            while j + w <= len(s):\n                if w * m <= j:\n                    t = s[j - w * m : j - w * (m - 1)]\n                    S[t] -= 1\n                    if t in M.keys() and S[t] < M[t]: cnt -= 1\n                t = s[j:j + w]\n                if t not in S.keys(): S[t] = 1\n                else: S[t] += 1\n                if t in M.keys() and S[t] <= M[t]:cnt += 1\n                if m == cnt:\n                    res.append(j - w * (m - 1))\n                j += w\n        return res\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326498818","body":"class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int count = 0;\n        unordered_map<int,int> hash;\n        hash[0] = 1;   //自身能被整除需要直接计数\n        int cursum = 0;\n        for(int i = 0;i<nums.size();i++){\n            cursum += nums[i];\n            int mod = (cursum%k+k)%k;\n            if(hash.count(mod)) count += hash[mod];\n            hash[mod]++;\n        }\n        return count;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327519648","body":"struct ListNode* middleNode(struct ListNode* head){\n    struct ListNode* cur = head;\n    int count = 0;\n\n    //统计链表结点个数\n    while(cur !=NULL)\n    {\n        count++;\n        cur = cur->next;\n    }\n\n    int n = 0;\n    cur = head;\n\t//迭代走到中间的结点！\n    while(n <count/2)\n    {\n        n++;\n        cur = cur->next;\n    }\n    return cur;\n}\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328244040","body":"\n\nfunc searchInsert(nums []int, target int) int {\n    l,r:=0,len(nums)-1\n    var mid int\n    for l<=r{\n        mid =l+(r-l)>>1\n        switch{\n            case nums[mid]<target:\n            l=mid+1\n            case nums[mid]>target:\n            r=mid-1\n            default :\n            return mid\n\n        }\n\n    } \n    return l\n\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329198768","body":"public int[] maxSlidingWindow(int[] nums, int k) {\n        if (nums == null || nums.length == 0)\n            return new int[0];\n \n        int[] arr = new int[nums.length - k + 1];\n        LinkedList<Integer> list = new LinkedList<>();\n \n        for (int index = 0, i = 0; i < nums.length; i++) {\n            while (!list.isEmpty() && nums[list.peekLast()] < nums[i]) {\n                list.pollLast();\n            }\n            list.add(i);\n            if (list.peek() == i - k) {\n                list.poll();\n            }\n            if (i >= k - 1) {\n                arr[index++] = nums[list.peek()];\n            }\n        }\n        return arr;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330679297","body":"class Solution {\npublic:\n    int findJudge(int N, vector<vector<int>>& trust) {\n        vector<unordered_set<int>> g1(N+1);     //信任别人的人 --> 出度\n        vector<unordered_set<int>> g2(N+1);     //被信任的人 --> 入度\n        for(const auto& t: trust){\n            g1[t[0]].insert(t[1]);\n            g2[t[1]].insert(t[0]);\n        }\n        int res = -1;\n        for(int i = 1; i <= N; i++){\n            if(g2[i].size() == N-1 && g1[i].size() == 0){\n                res = i;\n                // return i;\n                break;\n            }\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332250464","body":"class Solution {\npublic:\n    vector<int> colors;\n    map<int,vector<int>> mp;\n    bool dfs(int i , int color){\n        //设置当前人物的颜色\n        colors[i] = color;\n        for(int index : mp[i]){\n            if(colors[index] == color) // 和下个人物颜色相同\n                return false;\n            if(colors[index] == 0 && !dfs(index,-color))    //未被染色则进行染色\n                return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        if(dislikes.size() == 0 )\n            return true;\n        colors.resize(N+1);\n        // 记录不共存的值\n        for(vector<int> dislike : dislikes){\n            mp[dislike[0]].push_back(dislike[1]);\n            mp[dislike[1]].push_back(dislike[0]);\n        }\n        //开始染色\n        for(int i = 1; i <= N; i ++){\n            if(colors[i] == 0 && !dfs(i,1))\n                return false;\n        }\n        return true;\n    }\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298682601","body":"#思路\n对于数组A从右到左遍历，整数K也是从右到左遍历，逐位相加，注意需要两个辅助元素，1个记录进位的数，1个记录非进位数\n\n#代码\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        result = []\n        n, carry = len(num) - 1, 0\n        while n >= 0 or k != 0:\n            x = num[n] if n >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            result.append(sum % 10)\n            carry = sum // 10\n\n            n -= 1\n            k //= 10\n        if carry != 0: result.append(carry)\n        return result[::-1]\n\n#复杂度分析\n-时间复杂度 O(N)   【N是数组数组A与K的长度取最大值】\n-空间复杂度 O(N)      \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299663114","body":"#思路\n两次遍历，1）从左到右遍历，找到s中每个字符到其左侧最近的c的距离 2）从右到左遍历，找到s中每个字符到其右侧最近的c的距离\n#代码\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        answer = [0 if s[i]== c else None for i in range(n)]\n        #left\n        idx = -n\n        for i in range(n):\n            if s[i] == c:\n                idx = i \n            answer[i] = abs(i-idx)\n        #right\n        idx = 2*n\n        for i in range(n-1,-1,-1):\n            if s[i] == c:\n                idx = i\n            answer[i] = min(answer[i], idx - i)\n\n        return answer\n\n\n#复杂度分析\n-时间复杂度 O(N)  N是字符串s的长度\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301830289","body":"# 思路\n用数组模拟栈，用top变量来记录栈顶位置。\n\n# 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x):\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n    \n    def pop(self):\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stack[self.top + 1]\n    \n    def increment(self, k, val):\n        inc_num = min(k, self.top + 1)\n        for i in range(inc_num):\n            self.stack[i] += val\n```\n\n# 复杂度分析\n## 时间复杂度： \npush, pop, 初始化 都是O(1), increment是O(k)\n## 空间复杂度：\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302477429","body":"# 思路：\n利用栈 后入先出的思想\n\n# 代码：\n````python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n        for item in s:\n            if item == '[':\n                stack.append([res, multi])\n                res = \"\"\n                multi = 0\n            elif item == ']':\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <=item <= '9':\n                multi = multi * 10 + int(item)\n            else:\n                 res += item\n        return res\n```\n\n# 复杂度分析\n   -时间复杂度 O(n) n是数组s的长度\n   -空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304539420","body":"232. 用栈实现队列\n#  思路\n栈：后入先出但是队列却是 先入先出，因此要实现队列，需要用两个栈，输入栈 和输出栈。\n把元素push到输入栈之后，输入的顺序会颠倒。因此，需要从输入栈pop，然后push到输出栈，这样顺序就是输入的顺序了，也就是实现了队列。\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        return self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n\n    def empty(self) -> bool:\n        print(self.stack2)\n        print(self.stack1)\n        print(not self.stack2)\n        print(not self.stack1)\n        return not self.stack2 and not self.stack1\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n# 复杂度分析\n-时间复杂度 push和empty 是O(1)  pop and peek 是O(N)\n-空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823907","body":"# 思路\n用一个栈来储存每一个分组的最大值\n\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n```\n# 复杂度分析\n-时间复杂度 O(n) 因为是遍历，所以时间复杂度是O(n) n是数组长度\n\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305184882","body":"#  思路\n首先找到链表的倒数第k+1个节点，然后将链表的倒数第k+1个节点与倒数第k个节点分开，把后半部分拼接到链表头部\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        n_len = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            n_len += 1\n        \n        k %= n_len\n        if k == 0:\n            return head\n        fast, slow = head, head\n        for _ in range(k):\n            fast = fast.next\n        while fast.next:\n            fast, slow = fast.next, slow.next\n        \n        newHead = slow.next\n        slow.next = None\n        fast.next = head\n        return newHead \n```\n\n# 复杂度分析\n-时间复杂度 O(N) N是链表长度\n\n-空间复杂度分析 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306638105","body":"# 思路\n迭代的方法\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        dummy_head = ListNode(0)\n        dummy_head.next = head\n        temp = dummy_head\n        while temp.next and temp.next.next:\n            node1 = temp.next\n            node2 = temp.next.next\n            temp.next = node2\n            node1.next = node2.next\n            node2.next = node1\n            temp = node1\n        return dummy_head.next\n```\n# 复杂度分析\n-时间复杂度 O(N)\n\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308243117","body":"# 思路\n找到链表的中间节点作为根节点，再找到中点两边的子链的中点，递归\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        def getMedian(left: ListNode, right: ListNode)->ListNode:\n            fast = left\n            slow = left \n            while fast != right and fast.next != right:\n                fast = fast.next.next\n                slow = slow.next\n            return slow\n        \n        def buildTree(left:ListNode, right: ListNode)-> TreeNode:\n            if left == right:\n                return None\n            mid = getMedian(left, right)\n            root = TreeNode(mid.val)\n            root.left = buildTree(left, mid)\n            root.right = buildTree(mid.next, right)\n            return root\n        return buildTree(head, None)\n```\n# 复杂度分析\n-时间复杂度 O(Nlog(N))\n\n-空间复杂度 O(log(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309767084","body":"# 思路\n假设链表A的长度为a，链表B的长度为b，二者公共部分的长度为c。\n定义两个指针A，B。A从headA出发遍历到链表A结尾，再从链表B出发，走b-c步；B从headB出发遍历完链表B，再从链表A出发走a-c步。\n于是A走了 a+(b-c) 步，B也走了b+(a-c)步。二者相遇。\n如果c>0, A,B 同时指向相遇的节点；\n如果c=0，A，B同时指向None。于是返回A即可。\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        A = headA\n        B = headB\n        while A!=B:\n            A = A.next if A else headB\n            B = B.next if B else headA\n        return A\n```\n# 复杂度分析\n-时间复杂度：O(m+n) m+n 是链表A+B的长度\n\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311237062","body":"# 思路\n快慢指针。定义两个指针，快指针：一次移动两步，慢指针：一次移动一步。\n1）如果移动过程中，快指针指向null或者快指针.next指向null，则没有环，return None。\n2）如果上述情况不会发生，则有环。fast与slow第一次相遇（注意相遇不一定就相遇在环入口），则fast 走了2s步，slow走了s步，假设环前有a个节点，环内有b个节点。则2s-s=nb；于是s=nb\n如何让指针指向环入口呢？只要slow指针再走a步即可。\n3）让fast回到头部，然后fast每次移动一步，slow每次移动一步，如果fast与slow相遇，则slow一共走了a+nb步，此时指向环的入口。返回slow即可。\n\n# 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        fast, slow = head, head\n        while True:\n            if not(fast and fast.next):\n                return None\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                break\n        fast = head\n        while fast!= slow:\n            fast = fast.next\n            slow = slow.next\n        return slow \n```\n# 复杂度分析\n-时间复杂度：O(N)\n\n-空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312477485","body":"# 思路\n哈希+双链表\n\n\n# 代码\n```python \nclass DLinkedNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.head = DLinkedNode()\n        self.tail = DLinkedNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        self.size = 0\n\n\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self.moveToHead(node)\n        return node.value\n\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            node = DLinkedNode(key, value)\n            self.cache[key] = node\n            self.addToHead(node)\n            self.size += 1\n            if self.size > self.capacity:\n                tail_node = self.removeTail()\n                self.cache.pop(tail_node.key)\n                self.size -= 1\n        \n        else:\n            node = self.cache[key]\n            node.value = value\n            self.moveToHead(node)\n\n    \n    def addToHead(self, node):\n        node.next = self.head.next \n        node.prev = self.head\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def removeNode(self, node):\n        node.next.prev = node.prev\n        node.prev.next = node.next \n\n    def moveToHead(self, node):\n        self.removeNode(node)\n        self.addToHead(node)\n\n    def removeTail(self):\n        node = self.tail.prev\n        self.removeNode(node)\n        return node \n```\n# 复杂度分析\n-时间复杂度分析： put和get都是O(1)\n\n-空间复杂度分析: O(capacity)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312633115","body":"# 思路\n递归\n\n# 代码\n```python\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        else:\n            left_depth = self.maxDepth(root.left)\n            right_depth = self.maxDepth(root.right)\n            return max(left_depth, right_depth) + 1\n```\n# 复杂度分析\n-时间复杂度O(n) n是二叉树节点的个数\n\n-空间复杂度O(height)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312776850","body":"# 思路\n迭代\n\n# 代码\n```python \n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif p is None and q is not None:\n            return False\n        elif p is not None and q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n# 复杂度分析\n-时间复杂度分析： O(\\min(m,n))O(min(m,n))，其中 mm 和 nn 分别是两个二叉树的节点数\n\n-空间复杂度分析  O(\\min(m,n))O(min(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315473617","body":"# 思路 \n深度优先搜索\n\n# 代码\n```python\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n```\n# 复杂度分析\n-时间复杂度 O(n)，其中 n是二叉树的节点个数\n\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317244103","body":"# 思路 递归\n# 代码\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        def dfs(root: TreeNode, prevTotal: int) -> int:\n            if not root:\n                return 0\n            total = prevTotal * 10 + root.val\n            if not root.left and not root.right:\n                return total\n            else:\n                return dfs(root.left, total) + dfs(root.right, total)\n\n        return dfs(root, 0)\n\n# 时间复杂度分析\n-时间复杂度：O(n) 其中 n是二叉树的节点个数\n\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318834097","body":"# 思路 \nbfs\n# 代码\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"\"\n        queue = collections.deque([root])\n        res = []\n        while queue:\n            node = queue.popleft()\n            if node:\n                res.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                res.append('None')\n        return '[' + ','.join(res) + ']'\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return []\n        dataList = data[1:-1].split(',')\n        root = TreeNode(int(dataList[0]))\n        queue = collections.deque([root])\n        i = 1\n        while queue:\n            node = queue.popleft()\n            if dataList[i] != 'None':\n                node.left = TreeNode(int(dataList[i]))\n                queue.append(node.left)\n            i += 1\n            if dataList[i] != 'None':\n                node.right = TreeNode(int(dataList[i]))\n                queue.append(node.right)\n            i += 1\n        return root\n\n# 复杂度分析\n时间复杂度O(n)\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318894827","body":"#思路 \nbfs\n# 代码\nclass Solution:\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\n        queue = collections.deque([[root, 0, 0]])\n        hashmap = collections.defaultdict(list)\n        \n        while queue:\n            node, j, i = queue.popleft()\n            hashmap[(j, i)].append(node.val)\n            if node.left:\n                queue.append([node.left, j - 1, i + 1])\n            if node.right:\n                queue.append([node.right, j + 1, i + 1])\n\n      \n        res, tmp= [], []\n        j_flag = -1001\n        for j, i in sorted(hashmap.keys()):\n            if j != j_flag:\n                res.append(tmp)\n                tmp = []\n                j_flag = j\n            tmp.extend(sorted(hashmap[(j, i)]))\n        res.pop(0)\n        res.append(tmp)\n        return res\n\n# 复杂度分析\n-时间复杂度 O(nlogn)\n-空间复杂度分析 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320904098","body":"# 思路\n哈希表\n# 代码\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        n_len = len(nums)\n        hashtable = dict()\n\n        for i, elem in enumerate(nums):\n            if target - elem in hashtable:\n                return [hashtable[target-elem], i]\n            \n            else:\n                hashtable[elem] = i\n        return []\n# 复杂度分析 \n-时间复杂度 O(N) \n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320915931","body":"# 思路\n快排\n# 代码\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = collections.Counter(nums)\n        num_cnt = list(count.items())\n        topKs = self.findTopK(num_cnt, k, 0, len(num_cnt) - 1)\n        return [item[0] for item in topKs]\n    \n    def findTopK(self, num_cnt, k, low, high):\n        pivot = random.randint(low, high)\n        num_cnt[low], num_cnt[pivot] = num_cnt[pivot], num_cnt[low]\n        base = num_cnt[low][1]\n        i = low\n        for j in range(low + 1, high + 1):\n            if num_cnt[j][1] > base:\n                num_cnt[i + 1], num_cnt[j] = num_cnt[j], num_cnt[i + 1]\n                i += 1\n        num_cnt[low], num_cnt[i] = num_cnt[i], num_cnt[low]\n        if i == k - 1:\n            return num_cnt[:k]\n        elif i > k - 1:\n            return self.findTopK(num_cnt, k, low, i - 1)\n        else:\n            return self.findTopK(num_cnt, k, i + 1, high)\n\n# 复杂度分析\n-时间复杂度 平均O(n)\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322124900","body":"# 思路\n枚举+哈希表\n# 代码\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n# 复杂度分析\n-时间复杂度 O(n^2)\n-空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323911075","body":"# 思路\n滑动窗口\n\n# 代码\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        if not s:return 0\n        left = 0\n        lookup = set()\n        n = len(s)\n        max_len = 0\n        cur_len = 0\n        for i in range(n):\n            cur_len += 1\n            while s[i] in lookup:\n                lookup.remove(s[left])\n                left += 1\n                cur_len -= 1\n            if cur_len > max_len:max_len = cur_len\n            lookup.add(s[i])\n        return max_len\n\n# 复杂度分析\n-时间复杂度 O(N)\n-空间复杂度 O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1326615419","body":"# 思路\r\n滑动窗口\r\n# 代码\r\nclass Solution:\r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        res = []\r\n        m, n, ls = len(words), len(words[0]), len(s)\r\n        for i in range(n):\r\n            if i + m * n > ls:\r\n                break\r\n            differ = Counter()\r\n            for j in range(m):\r\n                word = s[i + j * n: i + (j + 1) * n]\r\n                differ[word] += 1\r\n            for word in words:\r\n                differ[word] -= 1\r\n                if differ[word] == 0:\r\n                    del differ[word]\r\n            for start in range(i, ls - m * n + 1, n):\r\n                if start != i:\r\n                    word = s[start + (m - 1) * n: start + m * n]\r\n                    differ[word] += 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                    word = s[start - n: start]\r\n                    differ[word] -= 1\r\n                    if differ[word] == 0:\r\n                        del differ[word]\r\n                if len(differ) == 0:\r\n                    res.append(start)\r\n        return res\r\n\r\n# 复杂度分析\r\n- 时间复杂度分析 O(s的长度 * words中单词的长度)\r\n- 空间复杂度分析 O（words中单词个数*words中单词的长度）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326610914","body":"# 思路\r\n哈希表\r\n# 代码\r\nclass Solution:\r\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\r\n        record = {0: 1}\r\n        total = 0\r\n        answer = 0\r\n        for item in nums:\r\n            total += item\r\n            modulus = total % k\r\n            same = record.get(modulus, 0)\r\n            answer += same\r\n            record[modulus] = same + 1\r\n        return answer\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326618133","body":"# 思路\r\n快慢指针\r\n\r\n# 代码\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327658009","body":"# 思路\r\n快慢指针\r\n\r\n# 代码\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        if not nums:\r\n            return 0\r\n        \r\n        n = len(nums)\r\n        fast = slow = 1\r\n        while fast < n:\r\n            if nums[fast] != nums[fast - 1]:\r\n                nums[slow] = nums[fast]\r\n                slow += 1\r\n            fast += 1\r\n        \r\n        return slow\r\n# 复杂度分析\r\n-时间复杂度 O(n)\r\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328287641","body":"# 思路 \r\n二分查找\r\n# 代码\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        left, right = 0, len(nums) \r\n        while left < right:\r\n            mid = left + (right - left)\r\n            if nums[mid] < target: \r\n                left = mid + 1 \r\n            else:\r\n                right = mid \r\n        return left\r\n\r\n# 复杂度分析\r\n-时间复杂度O(logn)\r\n-空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328288182","body":"# 思路\r\n优先队列\r\n# 代码\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        n = len(nums)\r\n        q = [(-nums[i], i) for i in range(k)]\r\n        heapq.heapify(q)\r\n\r\n        ans = [-q[0][0]]\r\n        for i in range(k, n):\r\n            heapq.heappush(q, (-nums[i], i))\r\n            while q[0][1] <= i - k:\r\n                heapq.heappop(q)\r\n            ans.append(-q[0][0])\r\n        \r\n        return ans\r\n\r\n# 复杂度分析\r\n-时间复杂度O(nlogn)\r\n-空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1329299144","body":"# 思路\r\n数组\r\n# 代码\r\nclass Solution:\r\n     def findJudge(self, N, trust):\r\n        in_degree = [0] * (N + 1)\r\n        out_degree = [0] * (N + 1)\r\n        for a, b in trust:\r\n            in_degree[b] += 1\r\n            out_degree[a] += 1\r\n        for i in range(1, N + 1):\r\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n\r\n# 复杂度分析\r\n-时间复杂度O(N)\r\n-空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1330925701","body":"# 思路\r\n深度优先搜索\r\n# 代码\r\nclass Solution:\r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = [[] for _ in range(n)]\r\n        for x, y in dislikes:\r\n            g[x - 1].append(y - 1)\r\n            g[y - 1].append(x - 1)\r\n        color = [0] * n  # color[x] = 0 表示未访问节点 x\r\n        def dfs(x: int, c: int) -> bool:\r\n            color[x] = c\r\n            return all(color[y] != c and (color[y] or dfs(y, -c)) for y in g[x])\r\n        return all(c or dfs(i, 1) for i, c in enumerate(color))\r\n\r\n# 复杂度分析\r\n-时间复杂度 O(m+n)\r\n-空间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333076276","body":"# 思路\r\n# 代码\r\n···python\r\nclass Solution:\r\n    def topological_sort(self,items,indegree,neighbors):\r\n        # 建立队列和访问顺序\r\n        queue = collections.deque()\r\n        res = []\r\n        \r\n        # 初始化队列\r\n        for item in items:\r\n            if not indegree[item]:\r\n                queue.append(item)\r\n                \r\n        if not queue: return []\r\n        \r\n        # BFS\r\n        while queue:\r\n            cur = queue.popleft()\r\n            res.append(cur)\r\n            \r\n            # 遍历邻居节点\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    queue.append(neighbor)\r\n                    \r\n        return res\r\n    \r\n    \r\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for task in range(n):\r\n            if group[task] == -1:\r\n                group[task] = max_group_id\r\n                max_group_id += 1\r\n                \r\n        task_indegree = [0] * n    \r\n        group_indegree = [0] * max_group_id\r\n        task_neighbors = [[] for _ in range(n)]\r\n        group_neighbors = [[] for _ in range(max_group_id)]\r\n        group_to_tasks = [[] for _ in range(max_group_id)]\r\n        \r\n        for task in range(n):\r\n            group_to_tasks[group[task]].append(task)\r\n            \r\n            for prerequisite in beforeItems[task]:\r\n                \r\n                # 判断相关联的两个项目是否属于同一组\r\n                if group[prerequisite] != group[task]:\r\n                    \r\n                    # 不是同组，给小组建图\r\n                    group_indegree[group[task]] += 1\r\n                    group_neighbors[group[prerequisite]].append(group[task])\r\n                else:\r\n                    # 同组，给组内项目建图\r\n                    task_indegree[task] += 1\r\n                    task_neighbors[prerequisite].append(task)\r\n                    \r\n\r\n        res = []\r\n        \r\n        # 得到小组的访问顺序\r\n        group_queue = self.topological_sort([i for i in range(max_group_id)],group_indegree,group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id: return []\r\n        \r\n        for group_id in group_queue:\r\n            # 得到每组项目的访问顺序\r\n            task_queue = self.topological_sort(group_to_tasks[group_id],task_indegree,task_neighbors)\r\n\r\n            if len(task_queue) != len(group_to_tasks[group_id]):\r\n                return []\r\n            res += task_queue\r\n                    \r\n        return res\r\n···\r\n# 复杂度分析\r\n-时间复杂度O(m + n)\r\n-空间复杂度O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334533676","body":"# 思路\r\n模拟\r\n# 代码\r\n`class Solution(object):\r\n    def judgeCircle(self, moves):\r\n        x = y = 0\r\n        for move in moves:\r\n            if move == 'U': y -= 1\r\n            elif move == 'D': y += 1\r\n            elif move == 'L': x -= 1\r\n            elif move == 'R': x += 1\r\n\r\n        return x == y == 0\r\n`\r\n# 复杂度分析\r\n-时间复杂度 O(N)\r\n-空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336145888","body":"class Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        tasks = sorted(enumerate(tasks), key=lambda x: (-x[1][0],-x[1][1],-x[0]))\r\n        ans = []\r\n        pq = []\r\n        time = 0\r\n        while tasks or pq:\r\n            if pq:\r\n                l, idx, t = heapq.heappop(pq)\r\n            else:\r\n                idx, v = tasks.pop()\r\n                t, l = v\r\n            ans.append(idx)\r\n            time = max(t,time) + l\r\n            while tasks and tasks[-1][1][0] <= time:\r\n                index, val = tasks.pop()\r\n                ti, le = val\r\n                heapq.heappush(pq, (le, index, ti))\r\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336434515","body":"class Solution:\r\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\r\n        t0 = 60 * int(startTime[:2]) + int(startTime[3:])\r\n        t1 = 60 * int(finishTime[:2]) + int(finishTime[3:])\r\n        if t1 < t0:      \r\n            t1 += 1440\r\n        t1 = t1 // 15 * 15\r\n        return max(0, (t1 - t0)) // 15\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336851961","body":"class Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        ca = collections.Counter(a)\r\n        cb = collections.Counter(b)\r\n        cc = ca + cb\r\n        res = len(a) + len(b) - max(cc.values())\r\n        nord = lambda x: ord(x)-97\r\n        for bd in range(nord('a'),nord('z')):\r\n            # res1代表将a改为严格小于b中字母的最少操作数\r\n            # res2代表将b改为严格小于a中字母的最少操作数\r\n            res1,res2 = 0,0 \r\n            for c in ca:\r\n                # 若c大于boundary则需要\r\n                if nord(c) > bd: \r\n                    res1 += ca[c]\r\n                else:\r\n                    res2 += ca[c] \r\n            for c in cb:\r\n                if nord(c) > bd:\r\n                    res2 += cb[c]\r\n                else:\r\n                    res1 += cb[c]\r\n            res = min(res,res1,res2)\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339241475","body":"class Solution:\r\n    def max_heapify(self, heap, root, heap_len):\r\n        p = root\r\n        while p * 2 + 1 < heap_len:\r\n            l, r = p * 2 + 1, p * 2 + 2\r\n            if heap_len <= r or heap[r] < heap[l]:\r\n                nex = l\r\n            else:\r\n                nex = r\r\n            if heap[p] < heap[nex]:\r\n                heap[p], heap[nex] = heap[nex], heap[p]\r\n                p = nex\r\n            else:\r\n                break\r\n        \r\n    def build_heap(self, heap):\r\n        for i in range(len(heap) - 1, -1, -1):\r\n            self.max_heapify(heap, i, len(heap))\r\n\r\n    def heap_sort(self, nums):\r\n        self.build_heap(nums)\r\n        for i in range(len(nums) - 1, -1, -1):\r\n            nums[i], nums[0] = nums[0], nums[i]\r\n            self.max_heapify(nums, 0, i)\r\n            \r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        self.heap_sort(nums)\r\n        return nums","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341078655","body":"class Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        l, r, ans = 0, x, -1\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if mid * mid <= x:\r\n                ans = mid\r\n                l = mid + 1\r\n            else:\r\n                r = mid - 1\r\n        return ans\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1344212815","body":"class Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        i, j = 1, n\r\n        while i <= j:\r\n            m = (i + j) // 2\r\n            if isBadVersion(m): j = m - 1\r\n            else: i = m + 1\r\n        return i","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344213772","body":"class Solution:\r\n    def find_reversed_pairs(self,nums,left,right):\r\n        res,mid = 0,(left+right)//2\r\n        \r\n        j = mid+1\r\n        for i in range(left,mid+1):\r\n            while j <= right and nums[i] > 2*nums[j]:\r\n                res += mid-i+1\r\n                j += 1\r\n        return res      \r\n        \r\n    def merge_sort(self,nums,nums_sorted,l,r):\r\n        if l >= r: return 0\r\n        mid = (l+r) // 2\r\n        res = self.merge_sort(nums,nums_sorted,l,mid) +\\\r\n              self.merge_sort(nums,nums_sorted,mid+1,r) +\\\r\n              self.find_reversed_pairs(nums,l,r)\r\n        \r\n        i,j,k = l,mid+1,l\r\n        while i <= mid and j <= r:\r\n            if nums[i] <= nums[j]:\r\n                nums_sorted[k] = nums[i]\r\n                i += 1\r\n            else:\r\n                nums_sorted[k] = nums[j]\r\n                j += 1\r\n            k += 1\r\n                \r\n        while i <= mid:\r\n            nums_sorted[k] = nums[i]\r\n            i += 1\r\n            k += 1\r\n        while j <= r:\r\n            nums_sorted[k] = nums[j]\r\n            j += 1\r\n            k += 1\r\n        \r\n        for k in range(l,r+1): nums[k] = nums_sorted[k]\r\n        \r\n        return res\r\n        \r\n    \r\n    def reversePairs(self, nums: List[int]) -> int:\r\n        if not nums: return 0\r\n        nums_sorted = [0] * len(nums)\r\n        return self.merge_sort(nums,nums_sorted,0,len(nums)-1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345268806","body":"class Solution:\r\n    def solve(self, nums):\r\n        nums.sort()\r\n        N = len(nums)\r\n        if N <= 3:\r\n            return 0\r\n        LIGHTS = 3\r\n        def possible(diameter):\r\n            start = nums[0]\r\n            end = start + diameter\r\n            for i in range(LIGHTS):\r\n                idx = bisect_right(nums, end)\r\n                if idx >= N:\r\n                    return True\r\n                start = nums[idx]\r\n                end = start + diameter\r\n            return False\r\n\r\n        l, r = 0, nums[-1] - nums[0]\r\n        while l <= r:\r\n            mid = (l + r) // 2\r\n            if possible(mid):\r\n                r = mid - 1\r\n            else:\r\n                l = mid + 1\r\n        return l / 2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345579413","body":"class Solution(object):\r\n    def smallestDistancePair(self, nums, k):\r\n        def possible(guess):\r\n            #Is there k or more pairs with distance <= guess?\r\n            return sum(prefix[min(x + guess, W)] - prefix[x] + multiplicity[i]\r\n                       for i, x in enumerate(nums)) >= k\r\n\r\n        nums.sort()\r\n        W = nums[-1]\r\n\r\n        #multiplicity[i] = number of nums[j] == nums[i] (j < i)\r\n        multiplicity = [0] * len(nums)\r\n        for i, x in enumerate(nums):\r\n            if i and x == nums[i-1]:\r\n                multiplicity[i] = 1 + multiplicity[i - 1]\r\n\r\n        #prefix[v] = number of values <= v\r\n        prefix = [0] * (W + 1)\r\n        left = 0\r\n        for i in xrange(len(prefix)):\r\n            while left < len(nums) and nums[left] == i:\r\n                left += 1\r\n            prefix[i] = left\r\n\r\n        lo = 0\r\n        hi = nums[-1] - nums[0]\r\n        while lo < hi:\r\n            mi = (lo + hi) / 2\r\n            if possible(mi):\r\n                hi = mi\r\n            else:\r\n                lo = mi + 1\r\n\r\n        return lo","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1351620877","body":"class Solution:\r\n    def swimInWater(self, grid: List[List[int]]) -> int:\r\n        res = 0\r\n        n = len(grid)\r\n        heap = [(grid[0][0],0,0)]\r\n        visited = set([(0,0)])\r\n        \r\n        while heap:\r\n            height,x,y = heapq.heappop(heap)\r\n            res = max(res,height)\r\n            if x == n-1 and y == n-1:\r\n                return res\r\n            \r\n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\r\n                new_x,new_y = x + dx,y + dy\r\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\r\n                    visited.add((new_x,new_y))\r\n                    heapq.heappush(heap,(grid[new_x][new_y],new_x,new_y))\r\n        \r\n        return -1\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1351618179","body":"class Solution:\r\n    def maxVowels(self, s: str, k: int) -> int:\r\n        def isVowel(ch):\r\n            return int(ch in \"aeiou\")\r\n        \r\n        n = len(s)\r\n        vowel_count = sum(1 for i in range(k) if isVowel(s[i]))\r\n        ans = vowel_count\r\n        for i in range(k, n):\r\n            vowel_count += isVowel(s[i]) - isVowel(s[i - k])\r\n            ans = max(ans, vowel_count)\r\n        return ans\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350901885","body":"class Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        if k == 0:\r\n            return 1.0\r\n        dp = [0.0] * (k + maxPts)\r\n        for i in range(k, min(n, k + maxPts - 1) + 1):\r\n            dp[i] = 1.0\r\n        for i in range(k - 1, -1, -1):\r\n            for j in range(1, maxPts + 1):\r\n                dp[i] += dp[i + j] / maxPts\r\n        return dp[0]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353251926","body":"class Solution:\r\n    def findAnagrams(self, s: str, p: str) -> List[int]:\r\n        s_len, p_len = len(s), len(p)\r\n        \r\n        if s_len < p_len:\r\n            return []\r\n\r\n        ans = []\r\n        s_count = [0] * 26\r\n        p_count = [0] * 26\r\n        for i in range(p_len):\r\n            s_count[ord(s[i]) - 97] += 1\r\n            p_count[ord(p[i]) - 97] += 1\r\n\r\n        if s_count == p_count:\r\n            ans.append(0)\r\n\r\n        for i in range(s_len - p_len):\r\n            s_count[ord(s[i]) - 97] -= 1\r\n            s_count[ord(s[i + p_len]) - 97] += 1\r\n            \r\n            if s_count == p_count:\r\n                ans.append(i + 1)\r\n\r\n        return ans\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1357810668","body":"class Solution:\r\n    def minWindow(self, s: 'str', t: 'str') -> 'str':\r\n        from collections import defaultdict\r\n        lookup = defaultdict(int)\r\n        for c in t:\r\n            lookup[c] += 1\r\n        start = 0\r\n        end = 0\r\n        min_len = float(\"inf\")\r\n        counter = len(t)\r\n        res = \"\"\r\n        while end < len(s):\r\n            if lookup[s[end]] > 0:\r\n                counter -= 1\r\n            lookup[s[end]] -= 1\r\n            end += 1\r\n            while counter == 0:\r\n                if min_len > end - start:\r\n                    min_len = end - start\r\n                    res = s[start:end]\r\n                if lookup[s[start]] == 0:\r\n                    counter += 1\r\n                lookup[s[start]] += 1\r\n                start += 1\r\n        return res","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1357813092","body":"class Solution(object):\r\n    def minOperations(self, nums, x):\r\n        target = sum(nums) - x\r\n        \r\n        if target == 0:\r\n            return len(nums)\r\n        \r\n        left, right = 0, 0 \r\n        curr, cnt = 0, 0 \r\n        \r\n        while right < len(nums):\r\n            curr = curr + nums[right]\r\n            \r\n            while left < right and curr > target:\r\n                curr = curr - nums[left]\r\n                left = left + 1\r\n            if curr == target:\r\n                cnt = max(cnt, right - left + 1)\r\n            right = right + 1\r\n            \r\n        if cnt == 0:\r\n            return -1 \r\n        else:\r\n            return len(nums) - cnt \r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1357814255","body":"class Solution:\r\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\r\n        ans = list()\r\n        for h in range(12):\r\n            for m in range(60):\r\n                if bin(h).count(\"1\") + bin(m).count(\"1\") == turnedOn:\r\n                    ans.append(f\"{h}:{m:02d}\")\r\n        return ans","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357807241","body":"class Solution:\r\n    def totalNQueens(self, n: int) -> int:\r\n        def backtrack(row: int) -> int:\r\n            if row == n:\r\n                return 1\r\n            else:\r\n                count = 0\r\n                for i in range(n):\r\n                    if i in columns or row - i in diagonal1 or row + i in diagonal2:\r\n                        continue\r\n                    columns.add(i)\r\n                    diagonal1.add(row - i)\r\n                    diagonal2.add(row + i)\r\n                    count += backtrack(row + 1)\r\n                    columns.remove(i)\r\n                    diagonal1.remove(row - i)\r\n                    diagonal2.remove(row + i)\r\n                return count\r\n                    \r\n        columns = set()\r\n        diagonal1 = set()\r\n        diagonal2 = set()\r\n        return backtrack(0)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359609612","body":"class Solution:\r\n    def dfs(self, grid, cur_i, cur_j) -> int:\r\n        if cur_i < 0 or cur_j < 0 or cur_i == len(grid) or cur_j == len(grid[0]) or grid[cur_i][cur_j] != 1:\r\n            return 0\r\n        grid[cur_i][cur_j] = 0\r\n        ans = 1\r\n        for di, dj in [[0, 1], [0, -1], [1, 0], [-1, 0]]:\r\n            next_i, next_j = cur_i + di, cur_j + dj\r\n            ans += self.dfs(grid, next_i, next_j)\r\n        return ans\r\n\r\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i, l in enumerate(grid):\r\n            for j, n in enumerate(l):\r\n                ans = max(self.dfs(grid, i, j), ans)\r\n        return ans\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1359610915","body":"class Solution:\r\n    def maxDistance(self, grid: List[List[int]]) -> int:\r\n        m, n = len(grid), len(grid[0])\r\n\r\n        stack = []\r\n        for i in range(m):\r\n            for j in range(n):\r\n                if grid[i][j]:\r\n                    stack.append([i, j])\r\n\r\n        if len(stack) == m*n or not stack:\r\n            return -1\r\n\r\n        step = 1\r\n        while stack:\r\n            nex = []\r\n            for i, j in stack:\r\n                for x, y in [[i+1, j], [i-1, j], [i, j+1], [i, j-1]]:\r\n                    if 0<=x<m and 0<=y<n and not grid[x][y]:\r\n                        nex.append([x, y])\r\n                        grid[x][y] = step\r\n            stack = nex\r\n            step += 1\r\n        return step-2","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364054779","body":"class Solution:\r\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\r\n        n = len(cost)\r\n        prev = curr = 0\r\n        for i in range(2, n + 1):\r\n            nxt = min(curr + cost[i - 1], prev + cost[i - 2])\r\n            prev, curr = curr, nxt\r\n        return curr\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1364548973","body":"def rob(self, nums: List[int]) -> int:\r\n    if len(nums) == 0:\r\n        return 0\r\n\r\n    # 子问题：\r\n    # f(k) = 偷 [0..k) 房间中的最大金额\r\n\r\n    # f(0) = 0\r\n    # f(1) = nums[0]\r\n    # f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\r\n\r\n    N = len(nums)\r\n    dp = [0] * (N+1)\r\n    dp[0] = 0\r\n    dp[1] = nums[0]\r\n    for k in range(2, N+1):\r\n        dp[k] = max(dp[k-1], nums[k-1] + dp[k-2])\r\n    return dp[N]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364808318","body":"class Solution:\r\n    def findNumberOfLIS(self, nums: List[int]) -> int:\r\n        n, max_len, ans = len(nums), 0, 0\r\n        dp = [0] * n\r\n        cnt = [0] * n\r\n        for i, x in enumerate(nums):\r\n            dp[i] = 1\r\n            cnt[i] = 1\r\n            for j in range(i):\r\n                if x > nums[j]:\r\n                    if dp[j] + 1 > dp[i]:\r\n                        dp[i] = dp[j] + 1\r\n                        cnt[i] = cnt[j]  # 重置计数\r\n                    elif dp[j] + 1 == dp[i]:\r\n                        cnt[i] += cnt[j]\r\n            if dp[i] > max_len:\r\n                max_len = dp[i]\r\n                ans = cnt[i]  # 重置计数\r\n            elif dp[i] == max_len:\r\n                ans += cnt[i]\r\n        return ans\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365545864","body":"class Solution:\r\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\r\n        m, n = len(text1), len(text2)\r\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\r\n        \r\n        for i in range(1, m + 1):\r\n            for j in range(1, n + 1):\r\n                if text1[i - 1] == text2[j - 1]:\r\n                    dp[i][j] = dp[i - 1][j - 1] + 1\r\n                else:\r\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\r\n        \r\n        return dp[m][n]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366425095","body":"class Solution:\r\n    def uniquePaths(self, m: int, n: int) -> int:\r\n        pre = [1] * n\r\n        cur = [1] * n\r\n        for i in range(1, m):\r\n            for j in range(1, n):\r\n                cur[j] = pre[j] + cur[j-1]\r\n            pre = cur[:]\r\n        return pre[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367028409","body":"class Solution:\r\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\r\n        dp = [[[0] * n for _ in range(n)] for _ in range(k + 1)]\r\n        for step in range(k + 1):\r\n            for i in range(n):\r\n                for j in range(n):\r\n                    if step == 0:\r\n                        dp[step][i][j] = 1\r\n                    else:\r\n                        for di, dj in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):\r\n                            ni, nj = i + di, j + dj\r\n                            if 0 <= ni < n and 0 <= nj < n:\r\n                                dp[step][i][j] += dp[step - 1][ni][nj] / 8\r\n        return dp[k][row][column]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367686980","body":"class Solution:\r\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\r\n        if maxChoosableInteger >= desiredTotal: return True\r\n        if (1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal: return False\r\n\r\n        def dfs(state, desiredTotal, dp):\r\n            if dp[state] != None:\r\n                return dp[state]\r\n            for i in range(1, maxChoosableInteger + 1):\r\n                cur = 1 << (i - 1)\r\n                if cur & state != 0:\r\n                    continue\r\n                \r\n                if i >= desiredTotal or not dfs(cur | state, desiredTotal - i, dp):\r\n                    dp[state] = True\r\n                    return True\r\n            dp[state] = False\r\n            return False\r\n        \r\n        return dfs(0, desiredTotal, [None] * (1 << maxChoosableInteger))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368376525","body":"class Solution:\r\n    def canPartition(self, nums: List[int]) -> bool:\r\n        n = len(nums)\r\n        if n < 2:\r\n            return False\r\n        \r\n        total = sum(nums)\r\n        maxNum = max(nums)\r\n        if total & 1:\r\n            return False\r\n        \r\n        target = total // 2\r\n        if maxNum > target:\r\n            return False\r\n        \r\n        dp = [[False] * (target + 1) for _ in range(n)]\r\n        for i in range(n):\r\n            dp[i][0] = True\r\n        \r\n        dp[0][nums[0]] = True\r\n        for i in range(1, n):\r\n            num = nums[i]\r\n            for j in range(1, target + 1):\r\n                if j >= num:\r\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]\r\n                else:\r\n                    dp[i][j] = dp[i - 1][j]\r\n        \r\n        return dp[n - 1][target]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368376648","body":"class Solution:\r\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\r\n        sumAll = sum(nums)\r\n        if S > sumAll or (S + sumAll) % 2:\r\n            return 0\r\n        target = (S + sumAll) // 2\r\n\r\n        dp = [0] * (target + 1)\r\n        dp[0] = 1\r\n\r\n        for num in nums:\r\n            for j in range(target, num - 1, -1):\r\n                dp[j] = dp[j] + dp[j - num]\r\n        return dp[-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368601134","body":"class Solution:\r\n    def coinChange(self, coins: List[int], amount: int) -> int:\r\n        @functools.lru_cache(amount)\r\n        def dp(rem) -> int:\r\n            if rem < 0: return -1\r\n            if rem == 0: return 0\r\n            mini = int(1e9)\r\n            for coin in self.coins:\r\n                res = dp(rem - coin)\r\n                if res >= 0 and res < mini:\r\n                    mini = res + 1\r\n            return mini if mini < int(1e9) else -1\r\n\r\n        self.coins = coins\r\n        if amount < 1: return 0\r\n        return dp(amount)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369919997","body":"class Solution:\r\n    def change(self, amount: int, coins: List[int]) -> int:\r\n        \r\n        dp = [0]*(amount+1)               \r\n        dp[0] = 1   \r\n        for coin in coins:                 \r\n            for j in range(coin, amount+1): \r\n                dp[j] += dp[j-coin]\r\n        \r\n        return dp[amount]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370746342","body":"class Solution:\r\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\r\n        g.sort()\r\n        s.sort()\r\n        m, n = len(g), len(s)\r\n        i = j = count = 0\r\n\r\n        while i < m and j < n:\r\n            while j < n and g[i] > s[j]:\r\n                j += 1\r\n            if j < n:\r\n                count += 1\r\n            i += 1\r\n            j += 1\r\n        \r\n        return count\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371788403","body":"class Solution:\r\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\r\n        if not intervals:\r\n            return 0\r\n        \r\n        intervals.sort()\r\n        n = len(intervals)\r\n        f = [1]\r\n\r\n        for i in range(1, n):\r\n            f.append(max((f[j] for j in range(i) if intervals[j][1] <= intervals[i][0]), default=0) + 1)\r\n\r\n        return n - max(f)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1374503391","body":"class Solution:\r\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\r\n        ans = 0\r\n        people.sort()\r\n        light, heavy = 0, len(people) - 1\r\n        while light <= heavy:\r\n            if people[light] + people[heavy] > limit:\r\n                heavy -= 1\r\n            else:\r\n                light += 1\r\n                heavy -= 1\r\n            ans += 1\r\n        return ans\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374503592","body":"lass Solution:\r\n    def numTrees(self, n):\r\n        \"\"\"\r\n        :type n: int\r\n        :rtype: int\r\n        \"\"\"\r\n        G = [0]*(n+1)\r\n        G[0], G[1] = 1, 1\r\n\r\n        for i in range(2, n+1):\r\n            for j in range(1, i+1):\r\n                G[i] += G[j-1] * G[i-j]\r\n\r\n        return G[n]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1375749210","body":"class Solution:\r\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\r\n        import heapq\r\n        dummy = ListNode(0)\r\n        p = dummy\r\n        head = []\r\n        for i in range(len(lists)):\r\n            if lists[i] :\r\n                heapq.heappush(head, (lists[i].val, i))\r\n                lists[i] = lists[i].next\r\n        while head:\r\n            val, idx = heapq.heappop(head)\r\n            p.next = ListNode(val)\r\n            p = p.next\r\n            if lists[idx]:\r\n                heapq.heappush(head, (lists[idx].val, idx))\r\n                lists[idx] = lists[idx].next\r\n        return dummy.next\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375753277","body":"class Solution:\r\n    def beautifulArray(self, N):\r\n        memo = {1: [1]}\r\n        def f(N):\r\n            if N not in memo:\r\n                odds = f((N+1)/2)\r\n                evens = f(N/2)\r\n                memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]\r\n            return memo[N]\r\n        return f(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377483693","body":"    def singleNumber(self, nums: List[int]) -> List[int]:\r\n        freq = Counter(nums)\r\n        return [num for num, occ in freq.items() if occ == 1]\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1377485114","body":"class Solution:\r\n    def subsets(self, nums: List[int]) -> List[List[int]]:\r\n        res = []\r\n        for i in range(len(nums)+1):\r\n            for tmp in itertools.combinations(nums, i):\r\n                res.append(tmp)\r\n        return res\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1380583997","body":"class Trie:\r\n    def __init__(self):\r\n        self.children = [None] * 26\r\n        self.isEnd = False\r\n    \r\n    def searchPrefix(self, prefix: str) -> \"Trie\":\r\n        node = self\r\n        for ch in prefix:\r\n            ch = ord(ch) - ord(\"a\")\r\n            if not node.children[ch]:\r\n                return None\r\n            node = node.children[ch]\r\n        return node\r\n\r\n    def insert(self, word: str) -> None:\r\n        node = self\r\n        for ch in word:\r\n            ch = ord(ch) - ord(\"a\")\r\n            if not node.children[ch]:\r\n                node.children[ch] = Trie()\r\n            node = node.children[ch]\r\n        node.isEnd = True\r\n\r\n    def search(self, word: str) -> bool:\r\n        node = self.searchPrefix(word)\r\n        return node is not None and node.isEnd\r\n\r\n    def startsWith(self, prefix: str) -> bool:\r\n        return self.searchPrefix(prefix) is not None","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1380584708","body":"class MapSum:\r\n    def __init__(self):\r\n        self.map = {}\r\n\r\n    def insert(self, key: str, val: int) -> None:\r\n        self.map[key] = val\r\n\r\n    def sum(self, prefix: str) -> int:\r\n        res = 0\r\n        for key,val in self.map.items():\r\n            if key.startswith(prefix):\r\n                res += val\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1383179910","body":"class Trie:\r\n    def __init__(self, words):\r\n        self.d = {}\r\n        for word in words:\r\n            t = self.d\r\n            for w in word:\r\n                if w not in t:\r\n                    t[w] = {}\r\n                t = t[w]\r\n            t['end'] = word\r\n    \r\n    def search(self, s):\r\n        t = self.d\r\n        res = []\r\n        for w in s:\r\n            if w not in t:\r\n                break\r\n            t = t[w]\r\n            if 'end' in t:\r\n                res.append(t['end'])\r\n        return res\r\n\r\nclass Solution:\r\n    def multiSearch(self, big: str, smalls: List[str]) -> List[List[int]]:\r\n        trie = Trie(smalls)\r\n        hit = collections.defaultdict(list)\r\n\r\n        for i in range(len(big)):\r\n            matchs = trie.search(big[i:])\r\n            for word in matchs:\r\n                hit[word].append(i)\r\n        \r\n        res = []\r\n        for word in smalls:\r\n            res.append(hit[word])\r\n        return res\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383180034","body":"class Solution:\r\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\r\n        def dfs(i: int):\r\n            for j in range(cities):\r\n                if isConnected[i][j] == 1 and j not in visited:\r\n                    visited.add(j)\r\n                    dfs(j)\r\n        \r\n        cities = len(isConnected)\r\n        visited = set()\r\n        provinces = 0\r\n\r\n        for i in range(cities):\r\n            if i not in visited:\r\n                dfs(i)\r\n                provinces += 1\r\n        \r\n        return provinces\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/84#issuecomment-1383180251","body":"class Solution(object):\r\n    def minMalwareSpread(self, graph, initial):\r\n       \r\n        N = len(graph)\r\n        colors = {}\r\n        c = 0\r\n\r\n        def dfs(node, color):\r\n            colors[node] = color\r\n            for nei, adj in enumerate(graph[node]):\r\n                if adj and nei not in colors:\r\n                    dfs(nei, color)\r\n\r\n        for node in xrange(N):\r\n            if node not in colors:\r\n                dfs(node, c)\r\n                c += 1\r\n\r\n        size = collections.Counter(colors.values()) \r\n        color_count = collections.Counter()\r\n        for node in initial:\r\n            color_count[colors[node]] += 1\r\n\r\n        \r\n        ans = float('inf')\r\n        for x in initial:\r\n            c = colors[x]\r\n            if color_count[c] == 1:\r\n                if ans == float('inf'):\r\n                    ans = x\r\n                elif size[c] > size[colors[ans]]:\r\n                    ans = x\r\n                elif size[c] == size[colors[ans]] and x < ans:\r\n                    ans = x\r\n\r\n        return ans if ans < float('inf') else min(initial)    \r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298687572","body":"//一开始想复杂了，想着要把array转成数字然后做加法然后再将数字转成array，直到case 9999999999 超过int 范围之后发现这么做不好\r\n\r\n代码：\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> list = new ArrayList<Integer>();\r\n        int i = n - 1,sum = 0,carry = 0,remainder = 0;\r\n        while ( (i >= 0)|| k != 0 )\r\n        {\r\n            int origin = i >= 0 ? num[i] : 0;\r\n            remainder = k != 0 ? k % 10 : 0;\r\n            \r\n            sum = origin + remainder + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n            list.add(0,sum%10);\r\n        }\r\n        if(carry!=0)\r\n            list.add(0,carry);\r\n        \r\n        return list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299972946","body":"思路：双指针\r\n代码：\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        int last = -n;\r\n        for(int i = 0; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                for(int j = i; j >= Math.max(0, (i + last - 1) / 2); j--)\r\n                    ans[j] = Math.min(ans[j], i - j);\r\n                last = i;\r\n            } else\r\n                ans[i] = Math.min(ans[i], i - last);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302253415","body":"```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303551874","body":"\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n    private String[] dfs(String s, int i) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        while(i < s.length()) {\r\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') \r\n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); \r\n            else if(s.charAt(i) == '[') {\r\n                String[] tmp = dfs(s, i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(multi > 0) {\r\n                    res.append(tmp[1]);\r\n                    multi--;\r\n                }\r\n            }\r\n            else if(s.charAt(i) == ']') \r\n                return new String[] { String.valueOf(i), res.toString() };\r\n            else \r\n                res.append(String.valueOf(s.charAt(i)));\r\n            i++;\r\n        }\r\n        return new String[] { res.toString() };\r\n    } \r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304701683","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        long res = 0, sum1 = 0, sum2 = 0;\r\n        vector<int> expect = arr;\r\n        sort(expect.begin(), expect.end());\r\n        for (int i = 0; i < arr.size(); ++i) {\r\n            sum1 += arr[i];\r\n            sum2 += expect[i];\r\n            if (sum1 == sum2) ++res;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307224517","body":"```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308959425","body":"```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = findMid(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode findMid(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310203592","body":"```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A = headA, B = headB;\r\n        while (A != B) {\r\n            A = A != null ? A.next : headB;\r\n            B = B != null ? B.next : headA;\r\n        }\r\n        return A;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311599182","body":"```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow. Next;\r\n            fast = fast.next.next;\r\n            // 第一次相遇\r\n            if(slow == fast){\r\n                fast = head;\r\n                while(true){\r\n                    // 第二次相遇\r\n                    if(slow == fast) return slow;\r\n                    slow = slow. Next;\r\n                    fast = fast. Next;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298691583","body":"采用逐位相加，大于10进1\n\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int *res = malloc(sizeof(int)* fmax(10,numSize+1));\n    *returnSize = 0;\n    for(int i = numSize -1; i>=0;--i)\n    {\n        int sum = num[i]+k%10;\n        k /= 10;\n        if(sum>=10)\n        {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for(;k>0;k /= 10)\n    {\n        res[(*returnSize)++] = k % 10;\n    }\n    for(int i =0;i<(*returnSize)/2;i++)\n    {\n        int tmp = res[i];\n        res[i] = res[(*returnSize)-1-i];\n        res[(*returnSize)-1-i] = tmp;\n    }\n    return res;\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1341148673","body":"#define MIN(a,b) ((a)>(b)) ? (a):(b)\r\n\r\nint *shortTochar(char *s, char c, int returnlength)\r\n{\r\n    int n = strlen(s);\r\n    int *ans =  (int*)malloc(sizeof(int) *n)\r\n\r\n    for(int i = 0,idx = -n;i<n;++i)\r\n    {\r\n        if(s[i] = c){\r\n            idx = i;\r\n        }\r\n        \r\n    }\r\n    for(int i = n-1,idx = 2 * n;--i)\r\n    {\r\n        if(s[i] = c){\r\n            idx = i;\r\n        }\r\n        ans[i] = MIN(ans[i],idx-i);\r\n    }\r\n    *returnlength = n;\r\n    return ans;\r\n}","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346308875","body":"class Solution {\r\npublic:\r\n    bool dfs(int mid, int x, int y, set<pair<int, int>>& visited, vector<vector<int>>& grid) {\r\n        if (x > grid.size() - 1 || x < 0 || y > grid[0].size() - 1 || y < 0) return false;\r\n        if (grid[x][y] > mid) return false;\r\n        if (x == grid.size() - 1 && y == grid[0].size() - 1) return true;\r\n        if (visited.count({x, y})) return false;\r\n        visited.insert({x, y});\r\n        bool res = dfs(mid, x + 1, y, visited, grid) || dfs(mid, x - 1, y, visited, grid) || dfs(mid, x, y + 1, visited, grid) || dfs(mid, x, y - 1, visited, grid);\r\n        return res;\r\n    }\r\n\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int l = 0;\r\n        int r = INT_MIN;\r\n        for (int i = 0; i < grid.size(); i++) {\r\n            for (int j = 0; j < grid[i].size(); j++) r = max(r, grid[i][j]);\r\n        }\r\n        set<pair<int, int>> visited;\r\n        while (l <= r) {\r\n            int mid = l + (r - l) / 2;\r\n            if (dfs(mid, 0, 0, visited, grid)) {\r\n                r = mid - 1;\r\n            } else {\r\n                l = mid + 1;\r\n            }\r\n            visited.clear();\r\n        }\r\n        return l;\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356953284","body":"struct hashTable {\r\n    int key;\r\n    UT_hash_handle hh;\r\n};\r\n\r\nstruct hashTable* find(struct hashTable** hashtable, int ikey) {\r\n    struct hashTable* tmp = NULL;\r\n    HASH_FIND_INT(*hashtable, &ikey, tmp);\r\n    return tmp;\r\n}\r\n\r\nvoid insert(struct hashTable** hashtable, int ikey) {\r\n    struct hashTable* tmp = NULL;\r\n    HASH_FIND_INT(*hashtable, &ikey, tmp);\r\n    if (tmp == NULL) {\r\n        tmp = malloc(sizeof(struct hashTable));\r\n        tmp->key = ikey;\r\n        HASH_ADD_INT(*hashtable, key, tmp);\r\n    }\r\n}\r\n\r\nvoid erase(struct hashTable** hashtable, int ikey) {\r\n    struct hashTable* tmp = NULL;\r\n    HASH_FIND_INT(*hashtable, &ikey, tmp);\r\n    if (tmp != NULL) {\r\n        HASH_DEL(*hashtable, tmp);\r\n        free(tmp);\r\n    }\r\n}\r\n\r\nstruct hashTable *columns, *diagonals1, *diagonals2;\r\n\r\nint backtrack(int n, int row) {\r\n    if (row == n) {\r\n        return 1;\r\n    } else {\r\n        int count = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (find(&columns, i) != NULL) {\r\n                continue;\r\n            }\r\n            int diagonal1 = row - i;\r\n            if (find(&diagonals1, diagonal1) != NULL) {\r\n                continue;\r\n            }\r\n            int diagonal2 = row + i;\r\n            if (find(&diagonals2, diagonal2) != NULL) {\r\n                continue;\r\n            }\r\n            insert(&columns, i);\r\n            insert(&diagonals1, diagonal1);\r\n            insert(&diagonals2, diagonal2);\r\n            count += backtrack(n, row + 1);\r\n            erase(&columns, i);\r\n            erase(&diagonals1, diagonal1);\r\n            erase(&diagonals2, diagonal2);\r\n        }\r\n        return count;\r\n    }\r\n}\r\n\r\nint totalNQueens(int n) {\r\n    columns = diagonals1 = diagonals2 = NULL;\r\n    return backtrack(n, 0);\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298710908","body":"var addToArrayForm = function (A, K) {\r\n    const res = []\r\n    let i = A.length - 1;\r\n    while (i >= 0 || K > 0) {\r\n        if (i >= 0) {\r\n            // A[i]有值时，加入\r\n            K += A[i];\r\n            i--;\r\n        }\r\n        // 使用push，然后reverse反转，比unshift稍快\r\n        res.push(K % 10);\r\n        K = parseInt(K / 10);\r\n    }\r\n    return res.reverse();\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300700229","body":"var shortestToChar = function(S, C) {\r\n let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307369946","body":"var swapPairs = function(head) {\r\n    if(!head)return null\r\n    if(!head.next)return head\r\n    let arr=[]\r\n    while(head!==null){\r\n        arr.push(head.val)\r\n        head=head.next\r\n    }\r\n    let len=arr.length\r\n    let result=new ListNode(-1)\r\n    let tmp=result\r\n    for(let i=0;i<len;i+=2){\r\n        if(arr[i+1]!==undefined){\r\n            tmp.next=new ListNode(arr[i+1])\r\n            tmp=tmp.next\r\n        }\r\n        tmp.next=new ListNode(arr[i])\r\n        tmp=tmp.next\r\n    }\r\n    return result.next\r\n};\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312757021","body":"function maxDepth(root) {\r\n    // 终止条件\r\n    if (root === null) return 0;\r\n\r\n    // 函数主功能\r\n    let leftDepth = maxDepth(root.left);\r\n    let rightDepth = maxDepth(root.right);\r\n\r\n    return Math.max(leftDepth, rightDepth) + 1;\r\n};","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321167103","body":"function topKFrequent(nums: number[], k: number): number[] {\r\n    const map = new Map<number, number>()\r\n\r\n    for (let i = 0; i < nums.length; i++) {\r\n        if (!map.has(nums[i])) {\r\n            map.set(nums[i], 1)\r\n        } else {\r\n            let count = map.get(nums[i]) as number\r\n            map.set(nums[i], count + 1)\r\n        }\r\n    }\r\n\r\n    const arr = Array.from(map)\r\n    arr.sort((a, b) => b[1] - a[1])\r\n\r\n    const result = arr.map((v) => v[0])\r\n    // console.log(result.slice(0, k))\r\n\r\n    return result.slice(0, k)\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298713019","body":"**思路** \r\n一开始想的是大数相加，最后需要按位相加，并考虑到进位情况，\r\n细节点：num长度比k长，或者k的长度比num长度长\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let res = [];\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    // 每次都取k的最低位\r\n    let sum = num[i] + (k % 10);\r\n    // 取完一位最低位之后就除10，保证下次取的最低位是倒数第2位\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      // 有进位，进位放到k中，这样不仅仅少了一个变量，后面的逻辑也更简化\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.unshift(sum);\r\n  }\r\n  // num中所有数字都加完了之后，如果k中还有剩余再把k的加上\r\n  while (k > 0) {\r\n    res.unshift(k % 10);\r\n    k = Math.floor(k / 10);\r\n  }\r\n  return res;\r\n};\r\n```\r\nO(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300430884","body":"```js\r\n// from xiaoranzi\r\n// n为S的length，m为C在S中的数量\r\n// 时间复杂度：O(nm)O(nm)\r\n// 空间复杂度：O(nm)O(nm)\r\nvar shortestToChar = function (S, C) {\r\n    const res = Array(S.length)\r\n    const indexArr = []\r\n    const maxVal = Infinity;\r\n    // 得到所有的c的坐标位置 存入indexArr\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    // 更新每个位置距离 每个indx坐标的位置\r\n    // 初始值为无穷大，不断更新res[i]元素的值\r\n    for (let i = 0; i < S.length; i++) {\r\n        res[i] = indexArr.reduce((tmp, item) => {\r\n            return Math.min(tmp, Math.abs(i - item))\r\n        }, maxVal)\r\n    }\r\n    return res\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302296378","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if( this.arr.length < this.maxSize ) this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if( this.arr.length == 0 ) return -1\r\n    return ( (this.arr).splice(this.arr.length - 1 , 1) )[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if( this.arr.length < k ){\r\n        for( let i = 0 ; i < this.arr.length ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }else{\r\n        for( let i = 0 ; i < k ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308082230","body":"```js\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { // 将链表节点的值逐个推入数组arr\r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  // 根据索引start到end的子数组构建子树\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\r\n    const mid = (start + end) >>> 1;     // 求中间索引 中间元素是根节点的值\r\n    const root = new TreeNode(arr[mid]); // 创建根节点\r\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\r\n    return root;                          // 返回当前子树\r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\r\n};\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313862308","body":"\r\n```js\r\nvar isSameTree = function(p, q) {\r\n    function bst(rootP,rootQ){\r\n        if(rootP === null && rootQ === null){\r\n            return true;\r\n        }\r\n        if(rootP === null && rootQ !== null){\r\n            return false;\r\n        }\r\n        if(rootP !== null && rootQ === null){\r\n            return false;\r\n        }\r\n        if(rootP.val !== rootQ.val){\r\n            return false;\r\n        }\r\n        \r\n        return bst(rootP.left,rootQ.left) && bst(rootP.right,rootQ.right);\r\n    }\r\n    \r\n    return bst(p, q)\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327617042","body":"```js\r\n\r\nvar middleNode = function(head) {\r\n    let slow = head, fast = head;\r\n    let len = 0;\r\n    while(fast.next){\r\n        fast = fast.next;\r\n        len++;\r\n    }\r\n    for(let i = 0;i<len/2;i++){\r\n        slow = slow.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n复杂度\r\n时间:o(n)\r\n空间:o(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1329229134","body":"\r\n\r\n```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let left = 0;\r\n    let right = nums.length - 1;\r\n    while(left <= right){\r\n        let mid =Math.floor((left + right) / 2);\r\n        if(target === nums[mid]){\r\n            return mid\r\n        }else if(target < nums[mid]){\r\n            right = mid - 1;\r\n        }else{\r\n            left = mid + 1;\r\n        }\r\n    }\r\n    return left;\r\n};\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329274162","body":"var maxSlidingWindow = function(nums, k) {\r\n    const queue = [],\r\n          result = []\r\n    for (let i = 0; i < nums.length; i++) {\r\n        // 如果队列不为空，且要入队的元素大于队尾元素, 队尾元素出队\r\n        while (queue.length > 0 && nums[i] > nums[queue[queue.length - 1]]) {\r\n            queue.pop()\r\n        }\r\n        queue.push(i)\r\n\r\n        // j 是把 i 为作为滑动窗口最后一个值时滑动窗口第一个值的索引\r\n        const j = i - k + 1\r\n        // j >= 0 说明滑动窗口已构建完毕\r\n        if (j >= 0) {\r\n            // 当队首元素不属于当前滑动窗口时出队\r\n            if (queue[0] < j) queue.shift()\r\n            // 把队首元素添加到结果数组中\r\n            result.push(nums[queue[0]])\r\n        }\r\n    }\r\n    return result\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345284297","body":"var rotateString = function(s, goal) {\r\n    const m = s.length, n = goal.length;\r\n    if (m !== n) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < n; i++) {\r\n        let flag = true;\r\n        for (let j = 0; j < n; j++) {\r\n            if (s[(i + j) % n] !== goal[j]) {\r\n                flag = false;\r\n                break;\r\n            }\r\n        }\r\n        if (flag) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298724244","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\".join(list(map(str, num)))\n        return [int(i) for i in str(int(s) + k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300621317","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strs = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                strs.append(i)\n        \n        res = []\n        for i, ch in enumerate(s):\n            mini = float('inf')\n            for j in strs:\n                mini = min(mini, abs(i-j))\n            res.append(mini)\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304562922","body":"### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 =[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            for i in range(len(self.stack1)):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stack2.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stack1 or self.stack2)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829993","body":"### 思路\n单调栈，维护每个块的最大值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                pivot = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(pivot)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305478463","body":"### 思路\n等价于是从第N个节点截断，当作链表头，将前面的链表接到后面\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head  \n\n        node_length = 0\n        yummy = head  \n        while yummy:\n            node_length += 1\n            yummy = yummy.next \n        \n        if k % node_length == 0:\n            return head  \n\n        k = node_length - k % node_length\n        slow, fast = head, head  \n\n        while k != 1:\n            k -= 1\n            fast = fast.next \n        new_start = fast.next\n        fast.next = None  \n\n        new_tail = new_start\n\n        while new_tail and new_tail.next:\n            new_tail = new_tail.next \n        new_tail.next = slow \n        return new_start\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312661078","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313538654","body":"### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True \n        if not p or not q or p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321750210","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n\n        for i, (x, y) in enumerate(points):\n            hashdict = collections.defaultdict(list)\n            for j, (x1, y1) in enumerate(points):\n                if j == i:\n                    continue \n                \n                dis = (x-x1)**2 + (y-y1)**2\n                hashdict[dis].append((x1,y1))\n            \n            for k, v in hashdict.items():\n                if len(v) > 1:\n                    res += len(v)*(len(v)-1)\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934522","body":"### 思路\n快慢指针\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head \n        while fast and fast.next:\n            slow = slow.next \n            fast = fast.next.next\n\n        return slow\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332144695","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        g = defaultdict(list)\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        p = list(range(n))\n        for i in range(n):\n            for j in g[i]:\n                if find(i) == find(j):\n                    return False\n                p[find(j)] = find(g[i][0])\n        return True\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337605249","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        cnta=[0]*26\n        cntb=[0]*26\n        for c in a:\n            cnta[ord(c)-ord('a')]+=1\n        for c in b:\n            cntb[ord(c)-ord('a')]+=1\n        lena = len(a)\n        lenb = len(b)\n        res,ca,cb = lena+lenb,0,0\n        print(cnta,cntb)\n        for i in range(25): \n            ca+=cnta[i]\n            cb+=cntb[i]\n            ta = ca+lenb-cb\n            tb = cb+lena-ca\n            res = min(res,min(ta,tb))\n        for i in range(26):\n            res = min(res,lena-cnta[i]+lenb-cntb[i])\n        return res\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298727843","body":"```JavaScript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298739620","body":"思路：k从num最后一位开始加，每次除10判断是否进位，再加上对应位置，检查是否进位。\nclass Solution:\n  def addToArrayForm(self,num:List[int],k:int)->List[int]:\n     result=[]\n    for i in range(Len(num)):\n       r=num[len(num)-1-i]+k\n       num[len(num)-1-i]=r%10\n       k=int(r/10)\n      if k==0:\n    break\n  if k!=0;\n  num.insert(0,k)\nreturn num\n时间复杂度是O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300581799","body":"思路：先找到字母的位置，求出所有可能的距离，最后找最小值。\nclass Solution:\n  def shortestToChar(self, s:str, c:str)->List[int]:\n    result=[]\n    c_position=[]\n    for i in range(len(s)):\n      if s[i]==c:\n          c_position.append(i)\n    for i in c_position:\n      for j in range(len(s)):\n        dis=abj(j-i)\n        result.append(dis)\n    result = np.array(result)\n    result = result.reshape(-1,len(s))\n    result1 = np.min(result,axis=0)\n    result = result1.tolist()\n    return result\n复杂度时间O(N)\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302307949","body":"思路：数组写栈 class CustomStack: def__init__(self, maxSize:int): self.stack=[] self.max = maxSize def push(self,x:int)->None: if len(self.stack)<self.max: self.stack.append(x) def pop(self): if len(self.stack)>0: return self.stack.pop() def increment(self,k,val): for i in range(min(k,len(self.stack)): self.stack[i]= self.stack[i]+val\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831114","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298744285","body":"````c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300709010","body":"````c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302299180","body":"````c++\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n\n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303795708","body":"````c++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828940","body":"````c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        unordered_map<int, int> cnt;\n        int res = 0;\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        for (int i = 0; i < sortedArr.size(); i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt[x]++;\n            if (cnt[x] == 0) {\n                cnt.erase(x);\n            }\n            cnt[y]--;\n            if (cnt[y] == 0) {\n                cnt.erase(y);\n            }\n            if (cnt.size() == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305793814","body":"````c++\nListNode* rotateRight(ListNode* head, int k) {\n    if (head == nullptr\n        || head->next == nullptr\n        || k == 0)\n        return head;\n\n    int len = 1;\n    ListNode* cur = head;\n    while (cur->next != nullptr) {\n        cur = cur->next;\n        len++;\n    }\n\n    k %= len;\n\n    ListNode* fast = head;\n    ListNode* slow = head;\n\n    while (fast->next != nullptr) {\n        if (k-- <= 0) {\n            slow = slow->next;\n        }\n        fast = fast->next;\n    }\n\n    fast->next = head;\n    ListNode* new_head = slow->next;\n    slow->next = nullptr;\n    return new_head;\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307438583","body":"````c++\nListNode* swapPairs(ListNode* head) {\n    if (head == nullptr || head->next == nullptr) return head;\n\n    ListNode* dummy = new ListNode(-1, head);\n    ListNode* prev = dummy;\n    ListNode* cur = prev->next;\n\n    while (cur != nullptr && cur->next != nullptr) {\n        ListNode* next = cur->next;\n        cur->next = next->next;\n        next->next = cur;\n        prev->next = next;\n\n        prev = cur;\n        cur = cur->next;\n    }\n    return dummy->next;\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308799545","body":"````c++\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        if(head==nullptr){\n            return nullptr;\n        }\n        return sortedListToBST_new(head,nullptr);\n    }\n    TreeNode* sortedListToBST_new(ListNode* head,ListNode*tail){\n        if(head==tail) return nullptr;\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast!=tail && fast->next!=tail){\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        TreeNode * root= new TreeNode(slow->val);\n        root->left= sortedListToBST_new(head,slow);\n        root->right = sortedListToBST_new(slow->next,tail); \n        return root;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309808255","body":"````c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *curA = headA;\n        ListNode *curB = headB;\n        while(curA!=curB){\n            curA = curA->next;\n            curB = curB->next;\n            if(curA==curB && curA==nullptr) return nullptr;\n            if(curA==nullptr) curA = headA;\n            if(curB==nullptr) curB =headB;\n        }\n        return curA;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311489672","body":"````c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        ListNode *slow = head;\n        ListNode *fast = head;\n\n        while(fast && fast->next){\n            slow = slow->next;\n            fast = fast->next->next;\n\n            if(slow == fast){\n                ListNode *tmp = head;\n                while(tmp!=slow){\n                    tmp = tmp->next;\n                    slow = slow->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312501652","body":"````c++\nstruct DLinkedNode {\n    int key, value;\n    DLinkedNode* prev;\n    DLinkedNode* next;\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DLinkedNode*> cache;\n    DLinkedNode* head;\n    DLinkedNode* tail;\n    int size;\n    int capacity;\n\npublic:\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head->next = tail;\n        tail->prev = head;\n    }\n    \n    int get(int key) {\n        if (!cache.count(key)) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        DLinkedNode* node = cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        if (!cache.count(key)) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode* node = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache[key] = node;\n            // 添加至双向链表的头部\n            addToHead(node);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode* removed = removeTail();\n                // 删除哈希表中对应的项\n                cache.erase(removed->key);\n                // 防止内存泄漏\n                delete removed;\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            DLinkedNode* node = cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n\n    void addToHead(DLinkedNode* node) {\n        node->prev = head;\n        node->next = head->next;\n        head->next->prev = node;\n        head->next = node;\n    }\n    \n    void removeNode(DLinkedNode* node) {\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void moveToHead(DLinkedNode* node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    DLinkedNode* removeTail() {\n        DLinkedNode* node = tail->prev;\n        removeNode(node);\n        return node;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312760393","body":"````c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root==nullptr){\n            return 0 ;\n        }\n        return max(maxDepth(root->left)+1,maxDepth(root->right)+1);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313730680","body":"````c++\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p==nullptr && q==nullptr) return true;\n        if(p==nullptr && q!=nullptr) return false;\n        if(p!=nullptr && q==nullptr) return false;\n\n        return (p->val==q->val) && isSameTree(p->left,q->left) && isSameTree(p->right,q->right);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315502412","body":"````c++\nclass Solution {\npublic:\n    int sum = 0;\n    int sumNumbers(TreeNode* root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    void dfs(TreeNode* root, int num) {\n        if (!root) return;\n        if (!root->left && !root->right) {\n            sum += num * 10 + root->val;\n            return;\n        }\n        dfs(root->left, num * 10 + root->val);\n        dfs(root->right, num * 10 + root->val);\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317046251","body":"### 思路\nBFS\n\n### 代码\n````c++\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode *> q;\n        TreeNode* ans = NULL;\n        q.push(root);\n        while(!q.empty()){\n            ans=q.front();\n            int size = q.size();\n            while(size--){\n                TreeNode *tmp = q.front();\n                q.pop();\n                if(tmp->left) q.push(tmp->left);\n                if(tmp->right) q.push(tmp->right);\n            }\n        }\n        return ans->val;\n    }\n};\n````","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320906160","body":"````Java\nclass Solution {\n\n    public int[] twoSum(int[] nums, int target) {\n        \n        Map<Integer, Integer> map = new HashMap<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            \n            if (map.containsKey(nums[i]))\n                return new int[]{map.get(nums[i]), i};\n            \n            map.put(target - nums[i], i);\n        }\n        \n        return new int[]{};\n    }\n}\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322240625","body":"````python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        n = len(points)\n        ans = 0\n        for i in range(n):\n            m = collections.defaultdict(int)\n            for j in range(n):\n                dist = abs(points[i][0] - points[j][0]) ** 2 + abs(points[i][1] - points[j][1]) ** 2\n                m[dist] += 1\n            for count in m.values():\n                ans += count * (count-1)\n        return ans\n````","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328191439","body":"````c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size();\n\n        while (l <= r) {\n            int mid = l + (r - l)/2;\n            if (nums[mid] == target) return mid;\n\n            if (nums[mid] < target) l = mid + 1;\n            else\n                r = mid - 1;\n        }\n\n        return l;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329200992","body":"````java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int[] ans = new int[nums.length - k + 1];\n        Deque<Integer> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; i++){\n            if (!deque.isEmpty() && deque.peekFirst() + k <= i) deque.pollFirst();\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]){\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            if (i - k + 1 >= 0) ans[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330640863","body":"````c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        if (trust.empty() && n == 1) return 1;\n        unordered_map<int, int> count;\n        for (auto& relation : trust)\n        {\n            count[relation[0]] += -1;\n            count[relation[1]] += 1;\n        }\n        int no_k = -1;\n        for (auto& kvp : count)\n        {\n            if (kvp.second == (n-1)) no_k = kvp.first;\n        }\n        return no_k;\n    }\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298751076","body":"思路：把k变成数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300737466","body":"```\n解题思路:双指针\n在遍历的时候记录上一次遇到c的位置，每次先更新距离为到上次遇到c的距离，直到遇到了另一个c。 \n将这个c和上一个c的中点，到这个c之间的点，更新为更近的新的c到它们的距离。\n同时上一个c变成了这个c。\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302300598","body":"```\n使用数组模拟栈，用一个变量 top 记录当前栈顶的位置。\n对于 push ，只要当前元素的个数是没达到上限，就把 top 后移一个位置并添加一个元素。\n对于 pop ，只要当前栈非空，则返回栈顶元素，并将top前移\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828655","body":"```\n单调栈\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305799809","body":"```\n快慢指针\nclass Solution:\n    def rotateRight(self, head, k):\n        if not head or not head.next: \n            return head\n        # 求链表长度\n        _len = 0\n        cur = head\n        while cur:\n            _len += 1\n            cur = cur.next\n        # 对长度取模\n        k %= _len\n        if k == 0: return head\n        # 快慢指针 让 fast 先向后走 k 步\n        fast, slow = head, head\n        while k:\n            fast = fast.next\n            k -= 1\n        # 继续往后走\n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n        # 新链表的头newHead，也就是倒数第 k 个节点\n        newHead = slow.next\n        # 将倒数第 k + 1 个节点 和 倒数第 k 个节点断开\n        slow.next = None\n        # 让最后一个节点指向原始链表的头\n        fast.next = head\n        return newHead\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311780065","body":"```\nclass Solution:\n    def detectCycle(self, head: ListNode) -> ListNode:\n\n        slow, fast = head, head\n        while fast  and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                break;\n        if not fast or not fast.next: \n            return None\n        fast = head\n        while slow != fast:\n            fast = fast.next\n            slow = slow.next\n        return slow\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312332707","body":"```\n哈希表+双向链表\n搬运工 学习一下\n\nclass ListNode:\n    def __init__(self, key=None, value=None):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.hashmap = {}\n        # 新建两个节点 head 和 tail\n        self.head = ListNode()\n        self.tail = ListNode()\n        # 初始化链表为 head <-> tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    # 因为get与put操作都可能需要将双向链表中的某个节点移到末尾，所以定义一个方法\n    def move_node_to_tail(self, key):\n            # 先将哈希表key指向的节点拎出来，为了简洁起名node\n            #      hashmap[key]                               hashmap[key]\n            #           |                                          |\n            #           V              -->                         V\n            # prev <-> node <-> next         pre <-> next   ...   node\n            node = self.hashmap[key]\n            node.prev.next = node.next\n            node.next.prev = node.prev\n            # 之后将node插入到尾节点前\n            #                 hashmap[key]                 hashmap[key]\n            #                      |                            |\n            #                      V        -->                 V\n            # prev <-> tail  ...  node                prev <-> node <-> tail\n            node.prev = self.tail.prev\n            node.next = self.tail\n            self.tail.prev.next = node\n            self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.hashmap:\n            # 如果已经在链表中了久把它移到末尾（变成最新访问的）\n            self.move_node_to_tail(key)\n        res = self.hashmap.get(key, -1)\n        if res == -1:\n            return res\n        else:\n            return res.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.hashmap:\n            # 如果key本身已经在哈希表中了就不需要在链表中加入新的节点\n            # 但是需要更新字典该值对应节点的value\n            self.hashmap[key].value = value\n            # 之后将该节点移到末尾\n            self.move_node_to_tail(key)\n        else:\n            if len(self.hashmap) == self.capacity:\n                # 去掉哈希表对应项\n                self.hashmap.pop(self.head.next.key)\n                # 去掉最久没有被访问过的节点，即头节点之后的节点\n                self.head.next = self.head.next.next\n                self.head.next.prev = self.head\n            # 如果不在的话就插入到尾节点前\n            new = ListNode(key, value)\n            self.hashmap[key] = new\n            new.prev = self.tail.prev\n            new.next = self.tail\n            self.tail.prev.next = new\n            self.tail.prev = new\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312687409","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n        # elif not root.left and not root.right:\n        #     return 1\n        else :\n            return 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313874737","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        else:\n            return p.val == q.val and self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314578622","body":"```\n#递归左子树，回溯，递归右子树\nclass Solution:\n    def sumNumbers(self, root: TreeNode) -> int:\n        res = 0\n        path = []\n        def backtrace(root):\n            nonlocal res\n            # 空节点，返回\n            if not root: return \n            path.append(root.val)\n            # 叶子节点\n            if not root.left and not root.right: \n                res += get_sum(path)\n            # 左子树不空\n            if root.left: \n                backtrace(root.left)\n                path.pop()\n            # 右子树不空\n            if root.right: \n                backtrace(root.right)\n                path.pop()\n            \n\n        def get_sum(arr):\n            s = 0\n            for i in range(len(arr)):\n                s = s * 10 + arr[i]\n            return s\n\n        backtrace(root)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317064337","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n#广度优先搜索, 分层搜索，每层记录最左边的结点，最深一层记录的即所求结点\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue, ans = Deque([root]), None\n        while queue:\n            ans = queue[0].val\n            for _ in range(len(queue)):\n                node = queue.popleft()\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320912182","body":"```\nclass Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        res = {}\n        for i,value in enumerate(nums):\n            if target - value in res.keys():\n                return [i,res[target - value]]\n            else:\n                res[value] = i\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128804","body":"```\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        # 先统计各数字数目，然后找出数目的第k大数\n        cnt = Counter(nums)\n        l = list(cnt.values())\n\n        # 小根堆\n        def findKthLargest(nums, k):\n            maxHeap = []\n            for x in nums:\n                heapq.heappush(maxHeap, -x)\n            for _ in range(k - 1):\n                heapq.heappop(maxHeap)\n            return -maxHeap[0]\n\n        ans = list()\n        n = findKthLargest(l, k)\n        for k, v in cnt.items():\n            if v >= n:\n                ans.append(k)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322174487","body":"```\n# 思路\n# 1、用哈希表记录某个点到其他点的距离，并统计每个距离相同的点个数\n# 2、遍历哈希表，从距离相同的点中选2个，作为回旋镖的后两个点\n# 3、对每个点都执行1和2\n\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        for i in range(len(points)):\n            hashmap = collections.defaultdict(int)\n            for j in range(len(points)):\n                dx = points[i][0] - points[j][0]\n                dy = points[i][1] - points[j][1]\n                dis = dx * dx + dy * dy\n                hashmap[dis] += 1\n            for val in hashmap.values():\n                    res += val * (val - 1)\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323813979","body":"```\n#滑动窗口\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        max_len, hashmap = 0, {}\n        start = 0\n        #移动窗口右边界\n        for end in range(len(s)):\n            hashmap[s[end]] = hashmap.get(s[end], 0) + 1\n            if len(hashmap) == end - start + 1:\n                max_len = max(max_len, end - start + 1)\n        #移动窗口左边界\n            while end - start + 1 > len(hashmap):\n                head = s[start]\n                hashmap[head] -= 1\n                if hashmap[head] == 0:\n                    del hashmap[head]\n                start += 1\n        return max_len\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325171486","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:return []\n        one_word_len = len(words[0])\n        all_words_len = len(words) * one_word_len\n        n = len(s)\n        words_counter = collections.Counter(words)\n        res = []\n        for i in range(0, n - all_words_len + 1):\n            tmp = s[i:i+all_words_len]\n            c_tmp = []\n            for j in range(0, all_words_len, one_word_len):\n                c_tmp.append(tmp[j:j+one_word_len])\n            if collections.Counter(c_tmp) == words_counter:\n                res.append(i)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326614429","body":"```\nclass Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        # 前缀和\n        ans, sum = [0], 0\n        for i in nums:\n            sum = sum + i\n            ans.append(sum)\n        # 字典\n        dict1 = {}\n        for i in ans:\n            if i % k not in dict1:\n                dict1[i % k] = 0\n            dict1[i % k] += 1\n        # 排列次数\n        total = 0\n        for v in dict1.values():\n            total = total + v * (v - 1) // 2\n        return total\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328068013","body":"```\n# 快慢指针\n# 初始化慢指针slow指向数组的起始位置（nums[0]），快指针fast指向指针slow的后一个位置（nums[1]）。\n# 随着指针fast不断向后移动，将指针fast指向的元素与指针slow指向的元素进行比较：\n\n# 如果nums[fast] ≠ nums[slow]，那么nums[slow + 1] = nums[fast]；\n\n# 如果nums[fast] = nums[slow]，那么指针fast继续向后查找；\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        slow, fast = 0, 1\n        while fast < len(nums):\n            if nums[fast] != nums[slow]:\n                slow = slow + 1\n                nums[slow] = nums[fast]\n            fast = fast + 1\n        return slow + 1\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1329339418","body":"```\ncopy\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        if not nums or not k:\n            return []\n        if len(nums) == 1:\n            return [nums[0]]\n\n        # 初始化队列和结果，队列存储数组的下标\n        queue = []\n        res = []\n\n        for i in range(len(nums)):\n            # 如果当前队列最左侧存储的下标等于 i-k 的值，代表目前队列已满，新元素需要进来，列表最左侧的下标出队列\n            if queue and queue[0] == i - k:\n                queue.pop(0)\n\n            # 对于新进入的元素，如果队列前面的数比它小，那么前面的都出队列\n            while queue and nums[queue[-1]] < nums[i]:\n                queue.pop()\n            # 新元素入队列\n            queue.append(i)\n\n            # 当前的大值加入到结果数组中\n            if i >= k-1:\n                res.append(nums[queue[0]])\n\n        return res\n\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336443638","body":"```\n# 转换单位为分钟\n# 开始小于结束，跨天，+24h处理\n# 转换为单位为15分钟\n# 1 整点才开始， 故向上取整\n# 2 整点完成才算完成，故向下取整\n# 返回求差值\n\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        m1,m2 = self.toMinutes(loginTime), self.toMinutes(logoutTime)\n        if m1 > m2:\n            m2 += 24 * 60\n        ans = math.floor(m2 / 15) - math.ceil(m1 / 15)\n        if ans < 0:\n            ans = 0 \n        return ans\n\n\n    def toMinutes(self,time):\n        h, m = time.split(':')\n        return int(h) * 60 + int(m)\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337550011","body":"```\n# 1、事先算好a和b里每个字母的counter \n# 2、如果要a的所有字母都变成小于“c”，b的所有字母都变成大于“c”，因为已经有counter了所以O(1)时间就能算出。 这样对26个字母过一遍选最小的就是“操作1”的解。 \n#同理可得操作2和操作3的解。\n\n\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter1,counter2=[0]*26,[0]*26\n        for c in a: counter1[ord(c)-ord('a')]+=1\n        for c in b: counter2[ord(c)-ord('a')]+=1\n        way1=min(sum(counter1[i:])+sum(counter2[:i]) for i in range(1,26))\n        way2=min(sum(counter2[i:])+sum(counter1[:i]) for i in range(1,26))\n        way3=min(len(a)+len(b)-counter1[i]-counter2[i] for i in range(26))\n        return min(way1,way2,way3)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339503191","body":"```\n#快排竟然超时~\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n\n        def maxHepify(arr, i, end):     # 大顶堆\n            j = 2*i + 1                 # j为i的左子节点【建堆时下标0表示堆顶】\n            while j <= end:             # 自上而下进行调整\n                if j+1 <= end and arr[j+1] > arr[j]:    # i的左右子节点分别为j和j+1\n                    j += 1                              # 取两者之间的较大者\n                \n                if arr[i] < arr[j]:             # 若i指示的元素小于其子节点中的较大者\n                    arr[i], arr[j] = arr[j], arr[i]     # 交换i和j的元素，并继续往下判断\n                    i = j                       # 往下走：i调整为其子节点j\n                    j = 2*i + 1                 # j调整为i的左子节点\n                else:                           # 否则，结束调整\n                    break\n        \n\n        n = len(nums)\n        \n        # 建堆【大顶堆】\n        for i in range(n//2-1, -1, -1):         # 从第一个非叶子节点n//2-1开始依次往上进行建堆的调整\n            maxHepify(nums, i, n-1)\n\n        # 排序：依次将堆顶元素（当前最大值）放置到尾部，并调整堆\n        for j in range(n-1, -1, -1):\n            nums[0], nums[j] = nums[j], nums[0]     # 堆顶元素（当前最大值）放置到尾部j\n            maxHepify(nums, 0, j-1)                 # j-1变成尾部，并从堆顶0开始调整堆\n        \n        return nums\n\n\n\n\n# class Solution:\n#     def sortArray(self, arr: List[int]) -> List[int]:\n#         if arr is None or len(arr) < 1:\n#             return arr\n\n#         def swap(arr, low, upper):\n#             arr[low], arr[upper] = arr[upper] ,arr[low]\n\n#         def QuickSort_TwoWay(arr, low, upper):\n#             if low >= upper:\n#                 return arr\n#             # 随机选取基准值, 并将基准值替换到数组第一个元素\n#             swap(arr, low, int(random.uniform(low, upper)))\n#             temp = arr[low]\n#             # 缓存边界值, 从上下边界同时排序,第一个元素是基准值,所以要跳过\n#             i, j = low+1, upper\n#             while True:\n#                 # 从下边界开始寻找大于基准值的索引\n#                 while i <= upper and arr[i] <= temp:\n#                     i += 1\n#                 # 从上边界开始寻找小于基准值的索引,因为j肯定大于i, 所以索引值肯定在小区间中\n#                 while arr[j] > temp:\n#                     j -= 1\n#                 # 如果小索引大于等于大索引, 说明排序完成, 退出排序\n#                 if i >= j:\n#                     break\n#                 swap(arr, i, j)\n#             # 将基准值的索引从下边界调换到索引分割点\n#             swap(arr, low, j)\n#             QuickSort_TwoWay(arr, low, j - 1)\n#             QuickSort_TwoWay(arr, j + 1, upper)\n#             return arr\n\n#         return QuickSort_TwoWay(arr, 0, len(arr) - 1)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341026924","body":"```\n\n# class Solution:\n#     def mySqrt(self, x: int) -> int:\n#         if x <= 1:\n#             return x\n#         ans = x // 2\n#         for i in range(1,ans+1):\n#             if i*i == x:\n#                 return i\n#             elif i*i > x:\n#                 return i-1\n#         return i\n\n\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n        if x <= 1:\n            return x\n        low, high = 1, x\n        while low <= high:\n            mid = low + (high - low) // 2\n            if mid < x / mid:\n                low = mid + 1\n            elif mid > x / mid:\n                high = mid - 1\n            else:\n                return mid\n        return high\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342915922","body":"```\n# The isBadVersion API is already defined for you.\n# def isBadVersion(version: int) -> bool:\n\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n\n        l, r = 1, n\n\n        while l < r:\n            mid = l + r >> 1\n            if isBadVersion(mid):\n                r = mid\n            else:\n                l = mid + 1\n            \n        return l\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344424251","body":"```\n#把输入数组反过来,乘以2然后插入一个有序数组中，插入的位置就是在原数组中位于它右侧且小于它的1/2的元素的个数。\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        tb, res = [], 0\n        for n in nums[::-1] :\n            res += bisect.bisect_left(tb, n)\n            n2 = 2*n\n            idx = bisect.bisect_left(tb, n2)\n            tb.insert(idx, n2)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345160698","body":"```\ncopy的别人的题解\n\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n\n        \"\"\"存放每个房屋与加热器的最短距离\"\"\"\n        res = []\n        heaters.sort()\n        for c in houses:\n            \"\"\"二分查找\"\"\"\n            left = 0\n            right = len(heaters) - 1\n            while left < right:\n                mid = (left + right) >> 1\n                if heaters[mid] < c:\n                    left = mid + 1\n                else:\n                    right = mid\n            \"\"\"得出的 left 所指的加热器并不一定是离房屋 c 最近的一个，需要判断以下情况\"\"\"\n            if heaters[left] == c:\n                \"\"\"若找到的值等于 c ，则说明 c 房屋处放有一个加热器，c 房屋到加热器的最短距离为 0\"\"\"\n                res.append(0)\n\n            elif heaters[left] < c:\n                \"\"\"若该加热器的坐标值小于 c ，说明该加热器的坐标与 c 之间没有别的加热器\"\"\"\n                res.append(c - heaters[left])\n\n            elif left == 0:\n                \"\"\"\n                若left == 0 即二分查找的结果指向第一个加热器的坐标,说明 heaters[left] 坐标的房屋之前的位置\n                未放置加热器,直接相减就是到房屋 c 最近加热器的距离\n                \"\"\"\n                res.append(heaters[left] - c)\n                \n            else:\n                \"\"\"\n                若left不等于 0 ，说明 c 介于left和left-1之间，房屋到加热器的最短距离就是left和left - 1处\n                加热器与 c 差值的最小值.\n                \"\"\"\n                res.append(min(heaters[left] - c, c - heaters[left - 1]))\n                \n        return max(res)\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346735710","body":"```\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        res = 0\n        n = len(grid)\n        heap = [(grid[0][0],0,0)]\n        visited = set([(0,0)])\n        \n        while heap:\n            height,x,y = heapq.heappop(heap)\n            res = max(res,height)\n            if x == n-1 and y == n-1:\n                return res\n            \n            for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:\n                new_x,new_y = x + dx,y + dy\n                if 0 <= new_x < n and 0 <= new_y < n and (new_x,new_y) not in visited:\n                    visited.add((new_x,new_y))\n                    heapq.heappush(heap,(grid[new_x][new_y],new_x,new_y))\n        \n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348799037","body":"```\n滑动窗口，比较滑动前后的边界\n\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = {'a', 'e', 'i', 'o', 'u'}\n        cnt = 0\n        for i in range(k):\n            if s[i] in vowels:\n                cnt += 1\n        res = cnt\n\n        for i in range(k, len(s)):\n            if s[i - k] in vowels:\n                cnt -= 1\n            if s[i] in vowels:\n                cnt += 1\n                res = max(res, cnt)\n        return res\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356825307","body":"```\n这竟然是个简单题，抄会都难\n'''\n总体思路\n在10个灯中选num个灯点亮，如果选择的灯所组成的时间已不合理（小时超过11，分钟超过59）就进行剪枝\n也就是从0到10先选一个灯亮，再选当前灯的后面的灯亮，再选后面的灯的后面的灯亮，一直到num个灯点满\n具体思路\n为了方便计算，分别设置了小时数组和分钟数组\n递归的四个参数分别代表：剩余需要点亮的灯数量，从索引index开始往后点亮灯，当前小时数，当前分钟数\n每次进入递归后，先判断当前小时数和分钟数是否符合要求，不符合直接return\nfor循环枚举点亮灯的情况，从index枚举到10，每次枚举，\n减少一个需要点亮的灯数量num - 1\n从当前已点亮的灯后面选取下一个要点亮的灯 i + 1\n在hour中增加当前点亮灯的小时数，如果i大于3，当前灯是分钟灯而不是小时灯，则加上0个小时\n在minute中增加当前点亮灯的分钟数，如果i没有大于3，当前灯是小时灯而不是分钟灯，则加上0分钟\n当剩余需要点亮的灯数量为0的时候，已枚举完一种情况，根据题目要求的格式加到res列表中\n返回res\n\n'''\nclass Solution:\n    def readBinaryWatch(self, num: int) -> List[str]:\n        hours = [1, 2, 4, 8, 0, 0, 0, 0, 0, 0]\n        minutes = [0, 0, 0, 0, 1, 2, 4, 8, 16, 32]\n        res = []\n        def backtrack(num, index, hour, minute):\n            if hour > 11 or minute > 59:\n                return\n            if num == 0:\n                res.append('%d:%02d' % (hour, minute))\n                return\n            for i in range(index, 10):\n                backtrack(num - 1, i + 1, hour + hours[i], minute + minutes[i])\n        \n        backtrack(num, 0, 0, 0)\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357852554","body":"```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def backtrack(r):\n            if r == n:\n                result.append(1)\n                return\n            for i in range(n):\n                if i in columns or r - i in diagonal1 or r + i in diagonal2:\n                    continue\n                #当前列及正反对角线都没有皇后时；再进行放置皇后\n                columns.append(i)           #将放置皇后的列添加到用来存放已放置过皇后的数组中\n                diagonal1.append(r - i)     #将放置皇后所在的反对角线坐标的值添加到用来存放相应的数组里记录\n                diagonal2.append(r + i)     #将放置皇后所在的正对角线坐标的值添加到用来存放相应的数组里记录\n                backtrack(r + 1)            #对下一行进行放置\n                columns.pop()               #回溯，将之前添加的pop出\n                diagonal1.pop()             #回溯，将之前添加的pop出\n                diagonal2.pop()             #回溯，将之前添加的pop出\n        result = []\n        columns, diagonal1, diagonal2 = [], [], []\n        row = [\".\"] * n\n        backtrack(0)\n        return len(result)\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359501739","body":"```\n# 遍历二维数组，对于每块土地，去其前后左右找相邻土地，再去前后左右的土地找其前后左右的土地，直到周围没有土地\n# 对于每一块已找过的土地，为避免重复计算，将其置为0\n# 遍历所有的岛屿，然后取这些岛屿的最大面积res = max(res, dfs(i, j))\n\n\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        def dfs(i, j):\n            if 0 <= i < m and 0 <= j < n and grid[i][j]:\n                grid[i][j] = 0\n                return 1 + dfs(i - 1, j) + dfs(i + 1, j) + dfs(i, j - 1) + dfs(i, j + 1)\n            return 0\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j]:\n                    res = max(res, dfs(i, j))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361331664","body":"```\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        steps = -1\n        q = deque([(i, j) for i in range(N) for j in range(N) if grid[i][j] == 1])\n        if len(q) == 0 or len(q) == N ** 2:\n            return steps\n        move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        while len(q) > 0:\n            for _ in range(len(q)):\n                x, y = q.popleft()\n                for dx, dy in move:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 0:\n                        q.append((nx, ny))\n                        grid[nx][ny] = -1\n            steps += 1\n\n        return steps\n\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366714380","body":"```\n# 思路\n# 1.定义状态：不同路径的数量 dp[i][j]含义：到位置(i, j)一共有几条路径 \n# 2.初始化状态：初始化第一行和第一列，均为1 \n# 3.状态转移：dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [[1] * n] + [[1] + [0] * (n - 1)] * (m - 1)\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n        return dp[-1][-1]\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367702321","body":"```\n抄袭大法好\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n        # 剪枝1：如果 所有数加起来 不足，那么谁都不可能赢\n        if (maxChoosableInteger + 1) * maxChoosableInteger / 2 < desiredTotal:\n            return False\n        # 剪枝2：先手直接选 maxChoosableInteger稳赢\n        if maxChoosableInteger >= desiredTotal:\n            return True\n        \n        @cache # 记忆搜索，算过的状态直接用结果，不用再重复算\n        def dfs(cur, state): # cur：当前和，state位运算用来表示 数字们的使用状态\n            for i in range(1, maxChoosableInteger + 1): # 遍历 1 到 maxChoosableInteger 位置，找能让我赢的 数字 i\n                if not (1 << i) & state: # 如果 state中 i 位置是0，数字 i 没有被使用，那么接下来就用数字 i\n                    if cur + i >= desiredTotal or not dfs(cur + i, state | (1 << i)): # 两种赢，要么我到目的了，要么你在后面的回合不可能赢，注意 当前和 + i，以及 数字i 被使用了\n                        return True\n            return False\n        return dfs(0,0) # 初始状态，当前和为0，所有数字都没有被使用```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368243812","body":"```\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        sumAll = sum(nums)\n        if sumAll % 2:\n            return False\n        target = sumAll // 2\n\n        dp = [False] * (target + 1)\n        dp[0] = True\n\n        for i in range(len(nums)):\n            for j in range(target, nums[i] - 1, -1):\n                dp[j] = dp[j] or dp[j - nums[i]]\n        return dp[-1]\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368366453","body":"```\n# 思路和大部分代码来自郁郁雨，增加了target小于0的判断\n# 01背包问题是选或者不选，但本题是必须选，是选+还是选-。先将本问题转换为01背包问题。 假设所有符号为+的元素和为x，符号为-的元素和的绝对值是y。 我们想要的 S = 正数和 - 负数和 = x - y 而已知x与y的和是数组总和：x + y = sum 可以求出 x = (S + sum) / 2 = target 也就是我们要从nums数组里选出几个数，令其和为target 于是就转化成了求容量为target的01背包问题 =>要装满容量为target的背包，有几种方案\n# 特例判断 如果S大于sum，不可能实现，返回0 如果x不是整数，也就是S + sum不是偶数，不可能实现，返回0; \n# target小于0，返回0\n# dp[j]代表的意义：填满容量为j的背包，有dp[j]种方法。因为填满容量为0的背包有且只有一种方法，所以dp[0] = 1\n# 状态转移：dp[j] = dp[j] + dp[j - num]， 当前填满容量为j的包的方法数 = 之前填满容量为j的包的方法数 + 之前填满容量为j - num的包的方法数 也就是当前数num的加入，可以把之前和为j - num的方法数加入进来。\n# 返回dp[-1]，也就是dp[target]\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        sumAll = sum(nums)\n        if S > sumAll or (S + sumAll) % 2:\n            return 0\n        target = (S + sumAll) // 2\n        if target < 0:\n            return 0\n\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for num in nums:\n            for j in range(target, num - 1, -1):\n                dp[j] = dp[j] + dp[j - num]\n        return dp[-1]\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373752907","body":"```\nclass Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        people.sort()\n        i, j = 0, len(people) - 1\n        res = 0\n        \n        while i <= j:\n            if people[i] + people[j] <= limit:\n                i += 1\n            j -= 1\n            res += 1\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374499352","body":"```\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [1] + [0] * n\n        for i in range(1, n + 1):\n            for j in range(i):\n                dp[i] += dp[j] * dp[i - j - 1]\n        return dp[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374866428","body":"```\n# 利用堆的数据结构\n\nclass Solution:\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\n        import heapq #调用堆\n        minHeap = []\n        for listi in lists: \n            while listi:\n                heapq.heappush(minHeap, listi.val) #把listi中的数据逐个加到堆中\n                listi = listi.next\n        head = ListNode(0) #构造虚节点\n        p = head\n        while minHeap:\n            p.next = ListNode(heapq.heappop(minHeap)) #依次弹出最小堆的数据\n            p = p.next\n        return head.next \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1379016196","body":"```\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ans=[[]]\n        for i in nums:\n            for j in range(len(ans)):\n                ans.append(ans[j]+[i])\n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753812","body":"`func addToArrayForm(num []int, k int) []int {\r\n    n := len(num)\r\n    pre,sum:=0,0\r\n    out := []int{}\r\n    for i:=n-1;i>=0||k>0||pre>0;i--{\r\n        if i >= 0{\r\n            sum = num[i]+k%10+pre\r\n        }else{\r\n            sum =k%10 + pre\r\n        }\r\n        pre = sum/10\r\n        k /= 10\r\n        out = append(out,sum%10)\r\n    }\r\n    reverse(out)\r\n    return out\r\n}\r\nfunc reverse(out []int) []int{\r\n    for i:=0;i<len(out)/2;i++{\r\n        out[i],out[len(out)-1-i] = out[len(out)-1-i] , out[i]\r\n    }\r\n    return out\r\n}`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300758564","body":"*代码\r\n\r\n```python \r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302310783","body":"## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        m = min(self.size, k)\r\n        for i in range(m):\r\n            self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303793836","body":"## 代码\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1303910219","body":"## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780087","body":"## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305798946","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308976671","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left: ListNode, right: ListNode) -> ListNode:\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        \r\n        def buildTree(left: ListNode, right: ListNode) -> TreeNode:\r\n            if left == right:\r\n                return None\r\n            mid = getMedian(left, right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left, mid)\r\n            root.right = buildTree(mid.next, right)\r\n            return root\r\n        \r\n        return buildTree(head, None)\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1313897620","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if root:\r\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n        else:\r\n            return 0\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313898860","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        return p != None and q != None and q.val == p.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317240257","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        self.h = 0\r\n        self.v = 0\r\n\r\n        def dfs(root, last_h):\r\n            if not root:\r\n                return 0\r\n            else:\r\n                h = last_h + 1\r\n\r\n                if not root.left and not root.right:\r\n                    if h > self.h:\r\n                        self.h = h\r\n                        self.v = root.val\r\n                \r\n                dfs(root.left, h)\r\n                dfs(root.right, h)\r\n        dfs(root,0)\r\n        return self.v\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318810442","body":"##代码##\r\n\r\n```python\r\nclass Codec:\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        self.open = [root]\r\n        self.res = []\r\n        self.children = []\r\n\r\n        while self.open:\r\n            node = self.open.pop(0)\r\n            if node:\r\n                self.res.append(str(node.val))\r\n                self.open.append(node.left)\r\n                self.open.append(node.right)\r\n            else:\r\n                self.res.append('None')\r\n        # return self.res\r\n        return '[' + ','.join(self.res) + ']'\r\n\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return []\r\n        dataList = data[1:-1].split(',')\r\n        root = TreeNode(int(dataList[0]))\r\n        self.open = [root]\r\n        i = 1\r\n        while self.open:\r\n            node = self.open.pop(0)\r\n            if dataList[i] != 'None':\r\n                node.left = TreeNode(int(dataList[i]))\r\n                self.open.append(node.left)\r\n            i += 1\r\n            if dataList[i] != 'None':\r\n                node.right = TreeNode(int(dataList[i]))\r\n                self.open.append(node.right)\r\n            i += 1\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320084504","body":"## 代码 ##\r\n```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1299362003","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] = divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry\r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299379101","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lr = [float('inf')] * len(s)\r\n        rl = [float('inf')] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lr[i] = 0\r\n            else:\r\n                if i-1 >= 0:\r\n                    lr[i] = lr[i-1] + 1\r\n                else:\r\n                    lr[i] = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                rl[i] = 0\r\n            else:\r\n                if i+1 < len(s):\r\n                    rl[i] = rl[i+1] + 1\r\n                else:\r\n                    rl[i] = float('inf')\r\n        for i in range(len(s)):\r\n            lr[i] = min(lr[i], rl[i])\r\n        return lr\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301125936","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.index = []\r\n        self.curSize = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.curSize < self.maxSize:\r\n            self.stack.append(x)\r\n            self.index.append(0)\r\n            self.curSize += 1\r\n        \r\n    def pop(self) -> int:\r\n        if self.curSize == 0:\r\n            return -1\r\n        else:\r\n            self.curSize -= 1\r\n            inc = self.index.pop()\r\n            if self.curSize > 0:\r\n                self.index[-1] += inc\r\n            return self.stack.pop() + inc\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(self.curSize, k)\r\n        if s != 0:\r\n            self.index[s-1] += val\r\n```\r\ntime O(1), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302775657","body":"```\r\nfrom collections import deque\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        k = \"\"\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] in \"0123456789\":\r\n                k += s[i]\r\n            else:\r\n                if k != \"\":\r\n                    n = int(k[::-1])\r\n                    temp = []\r\n                    # pop until ] or end\r\n                    while stack:\r\n                        c = stack.popleft()\r\n                        if c == \"]\":\r\n                            break\r\n                        else:\r\n                            if c != \"[\":\r\n                                temp.append(c)\r\n                    # repeate k time\r\n                    for _ in range(n):\r\n                        # push back\r\n                        for c in temp[::-1]:\r\n                            stack.appendleft(c)\r\n                    # clear k\r\n                    k = \"\"\r\n                stack.appendleft(s[i])\r\n        if k != \"\":\r\n            # repeate\r\n            n = int(k[::-1])\r\n            temp = []\r\n            # pop until ] or end\r\n            while stack:\r\n                c = stack.popleft()\r\n                if c == \"]\":\r\n                    break\r\n                else:\r\n                    if c != \"[\":\r\n                        temp.append(c) \r\n            # repeate k time\r\n            for _ in range(n):\r\n                # push back\r\n                for c in temp[::-1]:\r\n                    stack.appendleft(c)\r\n        return \"\".join(stack)\r\n```\r\ntime O(len(string)) space O(len(string)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304387929","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304744134","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for val in arr:\r\n            if stack:\r\n                max_val = stack[-1]\r\n                if val < max_val:\r\n                    while stack and val < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(max_val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                stack.append(val)\r\n        return len(stack)\r\n```\r\ntimeO(N),  space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1306238924","body":"```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        p = head\r\n        length = 0\r\n        while p:\r\n            length += 1\r\n            p = p.next\r\n        k = k % length\r\n        # \r\n        if k == 0:\r\n            return head\r\n        num = length - k\r\n        p = head\r\n        acc = 0\r\n        for _ in range(length):\r\n            if acc == num-1:\r\n                b = p\r\n            if acc == length-1:\r\n                f = p\r\n            p = p.next\r\n            acc += 1\r\n        # b.next will be None\r\n        ans = b.next\r\n        b.next = None\r\n        # cut the \r\n        f.next = head\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306731796","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        p = head\r\n        ans = head\r\n        acc = 1\r\n        while p.next:\r\n            if acc % 2 == 1:\r\n                if acc == 1:\r\n                    next_node = p.next\r\n                    p.next = next_node.next\r\n                    next_node.next = p\r\n                    ans = next_node\r\n                else:\r\n                    next_node = p.next\r\n                    p.next = next_node.next\r\n                    pre_node.next = next_node\r\n                    next_node.next = p\r\n            else:\r\n                pre_node = p\r\n                p = p.next\r\n            acc += 1\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307975865","body":"```\r\nclass Solution:\r\n    def helper(self, nums):\r\n        if not nums:\r\n            return None\r\n        h_node = len(nums) // 2\r\n        ans = TreeNode(val=nums[h_node])\r\n        ans.left = self.helper(nums[:h_node])\r\n        ans.right = self.helper(nums[h_node+1:])\r\n        return ans\r\n        \r\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\r\n        if not head:\r\n            return None\r\n        p = head\r\n        nums = []\r\n        while p:\r\n            nums.append(p.val)\r\n            p = p.next\r\n        ans = self.helper(nums)\r\n        return ans\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309881204","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pa = headA\r\n        pb = headB\r\n        while pa != pb:\r\n            pa = headB if pa is None else pa.next\r\n            pb = headA if pb is None else pb.next\r\n        return pa\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311249452","body":"```\r\nclass Solution:\r\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        p = head\r\n        pool = set()\r\n        while p:\r\n            if p in pool:\r\n                return p\r\n            else:\r\n                pool.add(p)\r\n            p = p.next\r\n        return None\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312672343","body":"```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        self.s = capacity\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n            return self[key]\r\n        else:\r\n            return -1\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.s:\r\n            self.popitem(last=False)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312652958","body":"```\r\nclass Solution:\r\n    def helper(self, branch, num):\r\n        if not branch:\r\n            return num\r\n        l = self.helper(branch.left, num+1)\r\n        r = self.helper(branch.right, num+1)\r\n        return max(l, r)\r\n        \r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        #if not root:\r\n        #    return 0\r\n        #l = self.helper(root.left, 1)\r\n        #r = self.helper(root.right, 1)\r\n        return self.helper(root, 0)\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312779350","body":"```\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        \r\n        if p and q:\r\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n        elif p and not q:\r\n            return False\r\n        elif not p and q:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314199324","body":"```\r\nclass Solution:\r\n    \r\n    def helper(self, node, num):\r\n        \r\n        if not node.left and not node.right:\r\n            return num*10 + node.val\r\n        elif not node.left and node.right:\r\n            num = num*10 + node.val\r\n            return self.helper(node.right, num)\r\n        elif node.left and not node.right:\r\n            num = num*10 + node.val\r\n            return self.helper(node.left, num)\r\n        else:\r\n            num = num*10 + node.val\r\n            return self.helper(node.left, num) + self.helper(node.right, num)\r\n        \r\n    def sumNumbers(self, root: Optional[TreeNode]) -> int:\r\n        if not root.left and not root.right:\r\n            return root.val\r\n        elif not root.left and root.right:\r\n            return self.helper(root.right, root.val)\r\n        elif root.left and not root.right:\r\n            return self.helper(root.left, root.val)\r\n        else:\r\n            return self.helper(root.left, root.val) + self.helper(root.right, root.val)\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316524727","body":"```\r\nclass Solution:\r\n    ans = 0\r\n    max_v = -float(\"inf\")\r\n    min_h = float(\"inf\")\r\n    def helper(self, node, v, h):\r\n        if v > self.max_v:\r\n            self.max_v = v\r\n            self.min_h = h\r\n            self.ans = node.val\r\n        if v == self.max_v:\r\n            if h < self.min_h:\r\n                self.min_h = h\r\n                self.ans = node.val\r\n        if node.left:\r\n            self.helper(node.left, v+1, h-1)\r\n        if node.right:\r\n            self.helper(node.right, v+1, h+1)\r\n        \r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        self.helper(root, 0, 0)\r\n        return self.ans\r\n```\r\ntime O(N) space O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318269257","body":"```\r\nfrom collections import deque\r\nclass Codec:\r\n    ans_str = \"\"\r\n    def serialize_helper(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if root:\r\n            self.ans_str += str(root.val)\r\n            self.ans_str += \" \"\r\n        else:\r\n            self.ans_str += \"None\"\r\n            self.ans_str += \" \"\r\n            return\r\n        self.serialize_helper(root.left)\r\n        self.serialize_helper(root.right)\r\n    \r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        else:\r\n            self.serialize_helper(root)\r\n        return self.ans_str\r\n        \r\n    def deserialize_helper(self, data):\r\n        if not data:\r\n            return None\r\n        val = data.popleft()\r\n        if val == \"None\":\r\n            return None\r\n        ans = TreeNode(int(val))\r\n        ans.left = self.deserialize_helper(data)\r\n        ans.right = self.deserialize_helper(data)\r\n        return ans\r\n        \r\n        \r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return None\r\n        data = deque(data.split())\r\n        ans = self.deserialize_helper(data)\r\n        return ans\r\n        \r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319686694","body":"```\r\nclass Solution:\r\n    def helper(self, node, tup, r, c):\r\n        if node:\r\n            tup.append((c, r, node.val))\r\n            self.helper(node.left, tup, r+1, c-1)\r\n            self.helper(node.right, tup, r+1, c+1)\r\n            \r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        tup = []\r\n        self.helper(root, tup, 0, 0)\r\n        tup = sorted(tup)\r\n        ans = collections.OrderedDict()\r\n        for c in tup:\r\n            if c[0] not in ans:\r\n                ans[c[0]] = []\r\n                ans[c[0]].append(c[-1])\r\n            else:\r\n                ans[c[0]].append(c[-1])\r\n        return list(ans.values())\r\n```\r\n\r\ntime O(nlogn) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320270100","body":"```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        can = {}\r\n        for i, val in enumerate(nums):\r\n            if val in can:\r\n                return [can[val], i]\r\n            else:\r\n                can[target-val] = i\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320956093","body":"```\r\nclass Solution:\r\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\r\n        nums = collections.Counter(nums)\r\n        min_key, min_val = 0, float(\"inf\")\r\n        ans = {}\r\n        for key, val in nums.items():\r\n            if len(ans) < k:\r\n                ans[key] = val\r\n                if val < min_val:\r\n                    min_key = key\r\n                    min_val = val\r\n            else:\r\n                if val > min_val:\r\n                    del ans[min_key]\r\n                    ans[key] = val\r\n                    min_val = float(\"inf\")\r\n                    for kk, vv in ans.items():\r\n                        if vv < min_val:\r\n                            min_val = vv\r\n                            min_key = kk\r\n        return ans.keys()\r\n```\r\ntime O(N) spce O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321309068","body":"```\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        ans = 0\r\n        for i, a in enumerate(points):\r\n            distance = collections.defaultdict(int)\r\n            for j, b in enumerate(points):\r\n                if i == j:\r\n                    continue\r\n                dist = (a[0] - b[0])**2 + (a[1] - b[1])**2\r\n                distance[dist] += 1\r\n            #\r\n            for k, v in distance.items():\r\n                if v >=2:\r\n                    ans += v*(v-1)\r\n        return ans\r\n```\r\ntime O(N**2) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322502631","body":"```\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        l, r = 0, 0\r\n        pool = set()\r\n        pool.add(s[0])\r\n        ans = 1\r\n        for r in range(1, len(s)):\r\n            while s[r] in pool:\r\n                pool.remove(s[l])\r\n                l += 1\r\n            \r\n            pool.add(s[r])\r\n            ans = max(ans, len(pool))\r\n        return ans\r\n```\r\ntime (N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324242509","body":"```\r\nclass Solution:\r\n    def helper(self, s, start, words, w_len, s_len, golden):\r\n        ans = []\r\n        if len(s) < s_len:\r\n            return ans\r\n        l, r = 0, 0\r\n        target = collections.defaultdict(int)\r\n        for r in range(0, s_len, w_len):\r\n            target[s[r: w_len+r]] += 1\r\n        if target == golden:\r\n            ans.append(l+start)\r\n            \r\n        if s_len > len(s) - w_len:\r\n            return ans\r\n        \r\n        for r in range(s_len, len(s), w_len):\r\n            target[s[r: r+w_len]] += 1\r\n            target[s[l: l+w_len]] -= 1\r\n            if target[s[l: l+w_len]] == 0:\r\n                del target[s[l: l+w_len]]\r\n            l += w_len\r\n            if target == golden:\r\n                ans.append(l+start)\r\n        return ans\r\n            \r\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\r\n        w_len = len(words[0])\r\n        s_len = len(words)*w_len\r\n        ans = []\r\n        target = collections.Counter(words)\r\n        if len(s) < s_len:\r\n            return ans\r\n        else:\r\n            for i in range(w_len):\r\n                ans += self.helper(s[i:], i, words, w_len, s_len, target)\r\n            return ans\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326017208","body":"```\r\nclass Solution:\r\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\r\n        pool = collections.defaultdict(list)\r\n        pre = 0\r\n        ans = 0\r\n        pool[0] = [-1]\r\n        for j in range(len(nums)):\r\n            pre += nums[j]\r\n            target = pre % k\r\n            if target in pool:\r\n                ans += len(pool[target])\r\n            pool[target].append(j)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326832407","body":"```\r\nclass Solution:\r\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327931255","body":"```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        diffs = set()\r\n        l, r, ans = 0, 0, 1\r\n        diffs.add(nums[0])\r\n        for r in range(1, len(nums)):\r\n            if nums[r] in diffs:\r\n                continue\r\n            else:\r\n                l += 1\r\n                nums[l] = nums[r]\r\n                ans += 1\r\n                diffs.add(nums[r])\r\n        return ans\r\n```\r\ntime O(N) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328120307","body":"```\r\nclass Solution:\r\n    def searchInsert(self, nums: List[int], target: int) -> int:\r\n        l, r = 0, len(nums)-1\r\n        while l <= r:\r\n            mid = (l+r) // 2\r\n            if nums[mid] == target:\r\n                return mid\r\n            elif nums[mid] > target:\r\n                r = mid-1\r\n            else:\r\n                l = mid+1\r\n        return l\r\n```\r\ntime O(logN) space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1331453649","body":"```\r\nimport heapq\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        h, ans = [], []\r\n        for i in range(k):\r\n            heapq.heappush(h, (-nums[i], i))\r\n        ans.append(-h[0][0])\r\n        for i in range(k, len(nums)):\r\n            heapq.heappush(h, (-nums[i], i))\r\n            while h[0][1] < i-k+1:\r\n                heapq.heappop(h)\r\n            ans.append(-h[0][0])\r\n        return ans\r\n```\r\ntime O(NlogK) space O(k)\r\n\r\n```\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        s = collections.deque()\r\n        ans = []\r\n        for i in range(len(nums)):\r\n            while s and nums[s[-1]] <= nums[i]:\r\n                s.pop()\r\n            while s and i-s[0] >= k:\r\n                s.popleft()\r\n            s.append(i)\r\n            if i >= k-1:\r\n                ans.append(nums[s[0]])\r\n        return ans\r\n```\r\ntime O(N) space O(K)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1331463124","body":"```\r\nclass Solution:\r\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\r\n        in_degree, out_degree = [0]*(n+1), [0]*(n+1)\r\n        for f, t in trust:\r\n            in_degree[t] += 1\r\n            out_degree[f] += 1\r\n        for i in range(1, n+1):\r\n            if in_degree[i] == n-1 and out_degree[i] == 0:\r\n                return i\r\n        return -1\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331466464","body":"```\r\nclass Solution:\r\n    def dfs(self, g, i, c, colors):\r\n        colors[i] = c\r\n        # for it's connector v, try to color -1*c\r\n        for j in g[i]:\r\n            if colors[j] == c:\r\n                return False\r\n            elif colors[j] == 0 and not self.dfs(g, j, -1*c, colors):\r\n                return False\r\n        return True\r\n    \r\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\r\n        g = collections.defaultdict(list)\r\n        for x, y in dislikes:\r\n            g[x-1].append(y-1)\r\n            g[y-1].append(x-1)\r\n        colors = [0] * n\r\n        for i in range(n):\r\n            if colors[i] == 0 and not self.dfs(g, i, 1, colors):\r\n                return False\r\n        return True\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1334823957","body":"```\r\nclass Solution:\r\n    # 拓扑排序\r\n    def tp_sort(self, items, indegree, neighbors):\r\n        q = collections.deque([])\r\n        ans = []\r\n        for item in items:\r\n            if not indegree[item]:\r\n                q.append(item)\r\n        while q:\r\n            cur = q.popleft()\r\n            ans.append(cur)\r\n\r\n            for neighbor in neighbors[cur]:\r\n                indegree[neighbor] -= 1\r\n                if not indegree[neighbor]:\r\n                    q.append(neighbor)\r\n\r\n        return ans\r\n\r\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\r\n        max_group_id = m\r\n        for project in range(n):\r\n            if group[project] == -1:\r\n                group[project] = max_group_id\r\n                max_group_id += 1\r\n\r\n        project_indegree = collections.defaultdict(int)\r\n        group_indegree = collections.defaultdict(int)\r\n        project_neighbors = collections.defaultdict(list)\r\n        group_neighbors = collections.defaultdict(list)\r\n        group_projects = collections.defaultdict(list)\r\n\r\n        for project in range(n):\r\n            group_projects[group[project]].append(project)\r\n\r\n            for pre in pres[project]:\r\n                if group[pre] != group[project]:\r\n                    # 小组关系图\r\n                    group_indegree[group[project]] += 1\r\n                    group_neighbors[group[pre]].append(group[project])\r\n                else:\r\n                    # 项目关系图\r\n                    project_indegree[project] += 1\r\n                    project_neighbors[pre].append(project)\r\n\r\n        ans = []\r\n        # 先对组进行拓扑排序\r\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\r\n\r\n        if len(group_queue) != max_group_id:\r\n            return []\r\n\r\n        for group_id in group_queue:\r\n            # 对小组中的项目进行拓扑排序\r\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\r\n\r\n            if len(project_queue) != len(group_projects[group_id]):\r\n                return []\r\n            ans += project_queue\r\n\r\n        return ans\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334822061","body":"```\r\nclass Solution:\r\n    def judgeCircle(self, moves: str) -> bool:\r\n        res = collections.Counter(moves)\r\n        return res[\"L\"]==res[\"r\"] and res[\"U\"]==res[\"D\"]\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336106906","body":"```\r\nclass Solution:\r\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\r\n        tasks = [(task[0], i, task[1]) for i, task in enumerate(tasks)]\r\n        tasks.sort()\r\n        ans = []\r\n        will_pro = []\r\n        time, pro = 0, 0 \r\n        for _ in tasks:\r\n            if not will_pro:\r\n                time = max(time, tasks[pro][0])\r\n            while pro < len(tasks) and tasks[pro][0] <= time:\r\n                heapq.heappush(will_pro, (tasks[pro][2], tasks[pro][1]))\r\n                pro += 1\r\n            en, i = heapq.heappop(will_pro)\r\n            ans.append(i)\r\n            time += en\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336335830","body":"```\r\nclass Solution:\r\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\r\n        sh, sm = map(int, loginTime.split(\":\"))\r\n        eh, em = map(int, logoutTime.split(\":\"))\r\n        d = 0\r\n        if sh*60 + sm > eh*60 + em: d += 1\r\n        if 0 < sm <= 15:\r\n            sm = 15\r\n        elif 15 < sm <= 30:\r\n            sm = 30\r\n        elif 30 < sm <= 45:\r\n            sm = 45\r\n        elif 45 < sm <= 60:\r\n            sm = 0\r\n            sh += 1\r\n        \r\n        if 0 <= em < 15:\r\n            em = 0\r\n        elif 15 <= em < 30:\r\n            em = 15\r\n        elif 30 <= em < 45:\r\n            em = 30\r\n        elif 45<= em < 60:\r\n            em = 45\r\n        \r\n        return max(0, ((eh + d*24 - sh)*60 + (em - sm))//15)\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340493481","body":"```\r\nclass Solution:\r\n    def mySqrt(self, x: int) -> int:\r\n        if x == 0 or x == 1:\r\n            return x\r\n        l, r = 0, x//2\r\n        while l<=r:\r\n            mid = l + (r-l)//2\r\n            if mid**2 == x:\r\n                return mid\r\n            if mid**2 < x:\r\n                l = mid+1\r\n            if mid**2 > x:\r\n                r = mid-1\r\n        return r\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350621345","body":"```\r\nclass Solution:\r\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\r\n        dp = [0]*(maxPts + k)\r\n        wd = 0\r\n        for i in range(k, k+maxPts):\r\n            if i <= n:\r\n                dp[i] = 1\r\n                wd += dp[i]\r\n        \r\n        for i in range(k-1, -1, -1):\r\n            dp[i] = wd/maxPts\r\n            wd = wd + dp[i] - dp[i+maxPts]\r\n        return dp[0]\r\n        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299479938","body":"## Thought: \nSweep from left side, compute the distance.\nThen sweep from right side, compute distance again.\nCompare the results from left and right, and output the min. \n\n## Code:\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # initialization \n        N = len(s)\n        left,right,res = [None] * N, [None] * N, [None] * N\n\n        ind = float('inf')\n        # sweep from left\n        for ii in range(N):\n            if s[ii] == c:\n                ind = ii\n            left[ii] = abs(ind - ii) \n        # sweep from right\n        ind = float('inf')\n        for ii in range(N-1,-1,-1):\n            if s[ii] == c:\n                ind = ii\n            right[ii] = abs(ind - ii)             \n        \n        # take the min of left and right \n        for ii in range(N):\n            res[ii] = min(left[ii],right[ii])\n        \n        return res\n\n```\n\n## Complexity: \nTime complexity: O(n)\n\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595367","body":"## Thought \n\nUse list to work for a stack.\nUse append method for push and pop method for pop.\n## Code \n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n        else:\n            print(\"Max size has been reached!\")            \n\n\n    def pop(self) -> int:\n        if len(self.stack) >=1:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val      \n```\n## Complexity: \n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305044968","body":"## Thought:\n1. Find length of linked list n\n2. Linked list will be rotated k%n times\n3. Jump to the pivot:\n           make tne next node new head\n           link the pivot to None\n           link tail to old head\n## Code \n```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        # get the length of the list\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n    \n        k = k % length\n        # no change in this case\n        if k == 0:\n            return head\n        \n        cur = head\n        for i in range(length-k-1):\n            cur = cur.next\n        \n        \n        new_head = cur.next\n        cur.next = None\n        tail.next = head\n        \n        return new_head\n```\n\n## Complexity:\n\nTO: O(n)\n\nSO: O(1)\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312806315","body":"(参考题解学习)\n## 思路： 迭代\n\n## 代码：\n```python3\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n## 复杂度：\nTC: O(n)\nSC: O(h)","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325912380","body":"(参考题解)\n```python\nclass Solution:\n    def solve(self, nums, k):\n        total = sum(nums)\n        mod = total % k\n\n        ans = len(nums)\n        total = 0\n        dic = {0: -1}\n        for j in range(len(nums)):\n            total += nums[j]\n            cur = total % k\n            target = (cur - mod + k) % k\n            if target in dic:\n                ans = min(ans, j - dic[target])\n            dic[cur] = j\n\n        if ans == len(nums):\n            return -1\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328111117","body":"```python\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l = 0\n        r = len(nums) - 1\n\n        while(l<=r):\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return l\n```\n\nO(logn), O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330013033","body":"(参考题解)\n```python\nclass Solution:\n     def findJudge(self, N, trust):\n        in_degree = [0] * (N + 1)\n        out_degree = [0] * (N + 1)\n        for a, b in trust:\n            in_degree[b] += 1\n            out_degree[a] += 1\n        for i in range(1, N + 1):\n            if in_degree[i] == N - 1 and out_degree[i] == 0:\n                return i\n        return -1\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336552915","body":"（参考题解）\n```python\nclass Solution:\n    def minCharacters(self, A: str, B: str) -> int:\n        ca = collections.Counter(A)\n        cb = collections.Counter(B)\n        # ca 中严格大于 cb 的最小操作数\n        def greater_cost(ca, cb):\n            ans = float(\"inf\")\n            # 枚举 ca 中的最小值\n            for i in range(1, 26):\n                count = 0\n                # 将 ca 中小于最小值的都进行一次操作\n                for j in range(i):\n                    count += ca[chr(97 + j)]\n                # 将 cb 中大于等于最小值的都进行一次操作（注意这里的等号）\n                for j in range(i, 26):\n                    count += cb[chr(97 + j)]\n                ans = min(ans, count)\n            return ans\n\n        def equal_cost(ca, cb):\n            ans = float(\"inf\")\n            for i in range(26):\n                ans = min(ans, len(A) + len(B) - ca[chr(97 + i)] - cb[chr(97 + i)])\n            return ans\n\n        return min(greater_cost(ca, cb), greater_cost(cb, ca), equal_cost(ca, cb))\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1344894699","body":"（参考题解）\n```python\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        # 这里使用的是直径，因此最终返回需要除以 2\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345794989","body":"(Referring to the solution)\n```python\nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        l, r = 0, max([max(vec) for vec in grid])\n        seen = set()\n\n        def test(mid, x, y):\n            if x > len(grid) - 1 or x < 0 or y > len(grid[0]) - 1 or y < 0:\n                return False\n            if grid[x][y] > mid:\n                return False\n            if (x, y) == (len(grid) - 1, len(grid[0]) - 1):\n                return True\n            if (x, y) in seen:\n                return False\n            seen.add((x, y))\n            ans = test(mid, x + 1, y) or test(mid, x - 1,\n                                              y) or test(mid, x, y + 1) or test(mid, x, y - 1)\n            return ans\n        while l <= r:\n            mid = (l + r) // 2\n            if test(mid, 0, 0):\n                r = mid - 1\n            else:\n                l = mid + 1\n            seen = set()\n        return l\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1353627124","body":"(Referring to the solution)\n```python\nclass Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        l, counter, N, ct = 0, Counter(), len(s), Counter(t)\n        k = 0\n        ret, ans = inf, \"\"\n        for r in range(N):\n            counter[s[r]] += 1\n            if s[r] in t and counter[s[r]] == ct[s[r]]:\n                k += 1\n            while k == len(ct):\n                if r - l + 1 < ret:\n                    ans = s[l:r+1]\n                ret = min(r - l + 1, ret)\n                counter[s[l]] -= 1\n                if s[l] in t and counter[s[l]] == ct[s[l]]-1:\n                    k -= 1\n                l += 1\n        return ans\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357091042","body":"(referring to solution)\n```\n/**\n * @param {number} n\n * @return {number}\n * @param row 当前层\n * @param col 列\n * @param pie 左斜线\n * @param na 右斜线\n */\nconst totalNQueens = function (n) {\n  let res = 0;\n  const dfs = (n, row, col, pie, na) => {\n    if (row >= n) {\n      res++;\n      return;\n    }\n    // 将所有能放置 Q 的位置由 0 变成 1，以便进行后续的位遍历\n    // 也就是得到当前所有的空位\n    let bits = ~(col | pie | na) & ((1 << n) - 1);\n    while (bits) {\n      // 取最低位的1\n      let p = bits & -bits;\n      // 把P位置上放入皇后\n      bits = bits & (bits - 1);\n      // row + 1 搜索下一行可能的位置\n      // col ｜ p 目前所有放置皇后的列\n      // (pie | p) << 1 和 (na | p) >> 1) 与已放置过皇后的位置 位于一条斜线上的位置\n      dfs(n, row + 1, col | p, (pie | p) << 1, (na | p) >> 1);\n    }\n  };\n  dfs(n, 0, 0, 0, 0);\n  return res;\n};\n``` ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1363181444","body":"(Referring to solution)\n```python3\nclass Solution:\n    def solve(self, root):\n        q = collections.deque([(root, 0)])\n        d = {}\n        while q:\n            cur, pos = q.popleft()\n            if pos not in d:\n                d[pos] = cur.val\n            if cur.left:\n                q.append((cur.left, pos - 1))\n            if cur.right:\n                q.append((cur.right, pos + 1))\n        return list(map(lambda x:x[1], sorted(d.items(),key=lambda x: x[0])))\n\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366375739","body":"(Referring to solution)\n```python3\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        d = [[1] * n for _ in range(m)]\n\n        for col in range(1, m):\n            for row in range(1, n):\n                d[col][row] = d[col - 1][row] + d[col][row - 1]\n\n        return d[m - 1][n - 1]\n```\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368286919","body":"(Referring to solution)\n```python3\nclass Solution:\n    def findTargetSumWays(self, nums, target) -> bool:\n        t = sum(nums) + target\n        if t % 2:\n            return 0\n        t = t // 2\n\n        dp = [0] * (t + 1)\n        dp[0] = 1\n\n        for i in range(len(nums)):\n            for j in range(t, nums[i] - 1, -1):\n                dp[j] += dp[j - nums[i]]\n        return dp[-1]\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373793583","body":"```python3\nclass Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        res = 0\n        l = 0\n        r = len(people) - 1\n        people.sort()\n\n        while l < r:\n            total = people[l] + people[r]\n            if total > limit:\n                r -= 1\n                res += 1\n            else:\n                r -= 1\n                l += 1\n                res += 1\n        if (l == r):\n            return res + 1\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1376290716","body":"```python3\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        xor = a = b = 0\n        right_bit = 1\n        length = len(nums)\n        for i in nums:\n            xor ^= i\n        while right_bit & xor == 0:\n            right_bit <<= 1\n        for i in nums:\n            if right_bit & i:\n                a ^= i\n            else:\n                b ^= i\n        return [a, b]\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382340644","body":"```cpp\nclass Solution {\n\n    private Node root = new Node();\n\n    public int[][] multiSearch(String big, String[] smalls) {\n\n        int n = smalls.length;\n        // 初始化结果集\n        List<Integer>[] res = new List[n];\n        for(int i = 0 ; i < n ; i++)\n            res[i] = new ArrayList<>();\n        // 建树\n        for(int i = 0 ; i < smalls.length; i++)\n            insert(smalls[i], i);\n\n        for(int i = 0 ; i < big.length(); i++){\n\n            Node tmp = root;\n\n            for(int j = i ; j < big.length(); j++){\n                //不存在以该串为prefix的敏感词\n                if(tmp.children[big.charAt(j) - 'a'] == null)\n                    break;\n\n                tmp = tmp.children[big.charAt(j) - 'a'];\n\n                if(tmp.isWord)\n                    res[tmp.id].add(i);\n            }\n        }\n        // 返回二维数组\n        int[][] ret = new int[n][];\n\n        for(int i = 0 ; i < n ; i++){\n\n            ret[i] = new int[res[i].size()];\n\n            for(int j = 0 ; j < ret[i].length; j++)\n                ret[i][j] = res[i].get(j);\n        }\n\n        return ret;\n    }\n\n    private void insert(String word, int id){\n\n        Node tmp = root;\n\n        for(int i = 0; i < word.length(); i++){\n\n            if(tmp.children[word.charAt(i) - 'a'] == null)\n                tmp.children[word.charAt(i) - 'a'] = new Node();\n\n            tmp = tmp.children[word.charAt(i) - 'a'];\n        }\n\n        tmp.isWord = true;\n        tmp.id = id;\n    }\n\n    class Node {\n\n        Node[] children;\n        boolean isWord;\n        int id;\n\n        public Node() {\n\n            children = new Node[26];\n            isWord = false;\n            id = 0;\n        }\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299539108","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1306150550","body":" public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || k == 0)\r\n            return head;\r\n        ListNode pointer = head;\r\n        int count = 0;\r\n        while(pointer.next != null) {\r\n            pointer = pointer.next;\r\n            count++;\r\n        }\r\n        pointer.next = head;\r\n        count++;\r\n        int times = k/count+1;\r\n        for(int i = 0; i < count - (k%count); i++) {\r\n            head = head.next;\r\n            pointer = pointer.next;\r\n        }\r\n        ListNode ans = head;\r\n        pointer.next = null;\r\n        return ans;\r\n    }","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306147261","body":"if not head or not head.next: return head\n    ans = ListNode()\n    ans.next = head.next\n    pre = ans\n    while head and head.next:\n        next = head.next\n        n_next = next.next\n\n        next.next = head\n        pre.next = next\n        head.next = n_next\n        # 更新指针\n        pre = head\n        head = n_next\n    return ans.next","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312372140","body":"class LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : _capacity(capacity) {\r\n\r\n    }\r\n    \r\n    int get(int key) {\r\n        auto it = _table.find(key);\r\n        if (it != _table.end()) {\r\n            _lru.splice(_lru.begin(), _lru, it->second);\r\n            return it->second->second;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        auto it = _table.find(key);\r\n        if (it != _table.end()) {\r\n            _lru.splice(_lru.begin(), _lru, it->second);\r\n            it->second->second = value;\r\n            return;\r\n        }\r\n        \r\n        _lru.emplace_front(key, value);\r\n        _table[key] = _lru.begin();\r\n        \r\n        if (_table.size() > _capacity) {\r\n            _table.erase(_lru.back().first);\r\n            _lru.pop_back();\r\n        }\r\n    }\r\nprivate:\r\n    unordered_map<int, std::list<std::pair<int, int>>::iterator> _table;\r\n    std::list<std::pair<int, int>> _lru;\r\n    int _capacity;\r\n};","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318968555","body":"class Solution {\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        vector<tuple<int, int, int>> nodes;\r\n\r\n        function<void(TreeNode*, int, int)> dfs = [&](TreeNode* node, int row, int col) {\r\n            if (!node) {\r\n                return;\r\n            }\r\n            nodes.emplace_back(col, row, node->val);\r\n            dfs(node->left, row + 1, col - 1);\r\n            dfs(node->right, row + 1, col + 1);\r\n        };\r\n\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n        vector<vector<int>> ans;\r\n        int lastcol = INT_MIN;\r\n        for (const auto& [col, row, value]: nodes) {\r\n            if (col != lastcol) {\r\n                lastcol = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().push_back(value);\r\n        }\r\n        return ans;\r\n    }\r\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1327479577","body":"class Solution {\r\n    public int lengthOfLongestSubstring(String s) {\r\n        // 记录字符上一次出现的位置\r\n        int[] last = new int[128];\r\n        for(int i = 0; i < 128; i++) {\r\n            last[i] = -1;\r\n        }\r\n        int n = s.length();\r\n\r\n        int res = 0;\r\n        int start = 0; // 窗口开始位置\r\n        for(int i = 0; i < n; i++) {\r\n            int index = s.charAt(i);\r\n            start = Math.max(start, last[index] + 1);\r\n            res   = Math.max(res, i - start + 1);\r\n            last[index] = i;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327469826","body":"var middleNode = function(head) {\r\n  if(!head) return head;\r\n  let newHead = head;\r\n  let quick = newHead;\r\n  let slow = newHead;\r\n  while(quick && quick.next){\r\n    quick = quick.next.next;\r\n    slow = slow.next;\r\n  }\r\n  return slow;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341562545","body":"class Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        if(isBadVersion(1)) return 1;\r\n        long long left=1,right=n,mid;\r\n        while(left<=right){\r\n            mid=(left+right)/2;\r\n            if(isBadVersion(mid)&&!isBadVersion(mid-1)) return mid;\r\n            else if(!isBadVersion(mid)) left=mid+1;\r\n            else right=mid-1;\r\n        }\r\n        return n;\r\n    }\r\n};\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345661760","body":"class Solution {\r\npublic:\r\n    int swimInWater(vector<vector<int>>& grid) {\r\n        int m=grid.size();\r\n        int n=grid[0].size();\r\n        UnionFind uf(m*n);\r\n        vector<tuple<int,int,int>>edge;\r\n        for(int i=0;i<m;i++)\r\n        for(int j=0;j<n;j++){\r\n            int id=i*n+j;\r\n            if(i>0)edge.emplace_back(max(grid[i][j],grid[i-1][j]),id,id-m);\r\n            if(j>0)edge.emplace_back(max(grid[i][j],grid[i][j-1]),id,id-1);\r\n        }\r\n        sort(edge.begin(),edge.end());\r\n        int res=0;\r\n        for(auto&[v,x,y]:edge){\r\n            uf.merge(x,y);\r\n            if(uf.connected(0,n*n-1)){\r\n                res=v;\r\n                break;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352450518","body":"class Solution {\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        int n = s.size(), m = p.size();\r\n        vector<int64_t> pre(n + 1);\r\n        vector<int> res;\r\n        int64_t sum = accumulate(p.begin(), p.end(), 0ll, [](int64_t cur, char c) {\r\n            return cur + c * c * c;\r\n        });\r\n        for (int i = 1; i <= n; i ++) {\r\n            pre[i] = pre[i - 1] + s[i - 1] * s[i - 1] * s[i - 1];\r\n        }\r\n        for (int i = m; i <= n; i ++) {\r\n            if (sum == pre[i] - pre[i - m]) {\r\n                res.push_back(i - m);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360831271","body":"class Solution {\r\npublic:\r\n    int maxDistance(vector<vector<int>>& grid) {\r\n        const int M = grid.size();\r\n        const int N = grid[0].size();\r\n\r\n        deque<pair<int, int>> deq;\r\n        for (int i = 0; i < M; ++i) {\r\n            for (int j = 0; j < N; ++j) {\r\n                if (grid[i][j] == 1) {\r\n\r\n                    deq.push_back({i, j});\r\n                }\r\n            }\r\n        }\r\n\r\n        if (deq.size() == 0 || deq.size() == M * N) {\r\n            return -1;\r\n        }\r\n\r\n        int distance = -1;\r\n\r\n        while (deq.size() != 0) {\r\n\r\n            distance ++;\r\n\r\n            int size = deq.size();\r\n            while (size --) {\r\n\r\n                auto cur = deq.front(); deq.pop_front();\r\n\r\n                for (auto& d : directions) {\r\n                    int x = cur.first + d[0];\r\n                    int y = cur.second + d[1];\r\n\r\n                    if (x < 0 || x >= M || y < 0 || y >= N ||\r\n                        grid[x][y] != 0) {\r\n                        continue;\r\n                    }\r\n\r\n\r\n                    deq.push_back({x, y});\r\n                }\r\n            }\r\n        }\r\n\r\n        return distance;\r\n    }\r\nprivate:\r\n    vector<vector<int>> directions = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\r\n};\r\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364714130","body":"class Solution {\r\npublic:\r\n    int findNumberOfLIS(vector<int>& nums) {\r\n        vector<deque<pair<int,int>>> cnts({{{-1e9, 1}}});\r\n        vector<int> sums({1});\r\n\r\n        for(int i : nums) {\r\n            auto pos = lower_bound(cnts.begin(), cnts.end(), i, [](auto& a, auto& b) {\r\n                return a.back().first < b;\r\n            }) - cnts.begin();\r\n\r\n            while(cnts[pos-1].front().first >= i) {\r\n                sums[pos-1] -= cnts[pos-1].front().second;\r\n                cnts[pos-1].pop_front();\r\n            }\r\n\r\n            if(pos == cnts.size()) {\r\n                cnts.push_back({});\r\n                sums.push_back(0);\r\n            }\r\n\r\n            cnts[pos].push_back({i, sums[pos - 1]});\r\n            sums[pos] += sums[pos - 1];\r\n        }\r\n\r\n        return sums.back();\r\n    }\r\n};\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368339959","body":"class Solution{\r\n    public int findTargetSumWays(int[] nums, int target)\r\n    {\r\n        int sum = 0;\r\n        for (int num : nums) {\r\n            sum += num;\r\n        }\r\n        int bagSize = (target + sum) / 2;\r\n        if (bagSize < 0) bagSize = -bagSize;\r\n        if ((target + sum) % 2 == 1) return 0;\r\n        int[] dp = new int[bagSize + 1];   \r\n        dp[0] = 1;  \r\n        for (int i = 0; i < nums.length; i++) {\r\n            for (int j = bagSize; j >= nums[i]; j--) {\r\n                dp[j] = dp[j] + dp[j - nums[i]];\r\n            }\r\n        }\r\n        return dp[bagSize];\r\n    }\r\n\r\n}\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1377816446","body":"class Solution {\r\n    public List<List<Integer>> subsets(int[] nums) {\r\n        List<List<Integer>> res = new ArrayList<>();\r\n        res.add(new ArrayList<>());\r\n        for (int i = 0; i < nums.length; i++) {\r\n           int all = res.size();\r\n            for (int j = 0; j < all; j++) {\r\n                List<Integer> tmp = new ArrayList<>(res.get(j));\r\n                tmp.add(nums[i]);\r\n                res.add(tmp);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299576804","body":"var shortestToChar = function(s, c) {\r\n    let num = [],res = []\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i] === c){\r\n            num.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min = Infinity\r\n        for(let j=0;j<num.length;j++){\r\n            min = Math.min(Math.abs(i-num[j]),min)\r\n        }\r\n        res.push(min)\r\n    }\r\n    return res\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301955903","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length < this.maxSize){\n        this.arr.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.arr.length?this.arr.pop():-1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length)\n    for(let i=0;i<min;i++){\n        this.arr[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304452988","body":"var MyQueue = function() {\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr.push(x)\n    return this.arr\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.arr.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.arr[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.arr.length?false:true\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304757577","body":"var maxChunksToSorted = function(arr) {\n    let arr1 = [...arr]\n    let arr2 = arr.sort((a,b)=>a-b)\n    let sum1 = sum2 = sum = 0\n    for(let i=0;i<arr1.length;i++){\n        sum1 += arr1[i]\n        sum2 += arr2[i]\n        if(sum1 === sum2){\n            ++sum\n        }\n    }\n    return sum\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305000850","body":"var rotateRight = function(head, k) {\n    if(!head)return null\n    let newhead = head,ln = 1\n    while(newhead.next){\n        newhead = newhead.next\n        ++ln\n    }\n    let move = ln - k%ln\n    newhead.next = head\n    while(move){\n        newhead = newhead.next\n        --move\n    }\n    let cur = newhead.next\n    newhead.next = null\n    return cur\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308124972","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {ListNode} head\n * @return {TreeNode}\n */\nvar sortedListToBST = function(head) {\n    let arr = [],newhead = head\n    while(newhead){\n        arr.push(newhead.val)\n        newhead = newhead.next\n    }\n    const dps = (start,end)=>{\n        if(start>end)return null\n        let mid = start + end >> 1\n        let root = new TreeNode(arr[mid])\n        root.left = dps(start,mid - 1)\n        root.right = dps(mid+1,end)\n        return root\n    }\n    return dps(0,arr.length-1)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309660428","body":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n\n/**\n * @param {ListNode} headA\n * @param {ListNode} headB\n * @return {ListNode}\n */\nvar getIntersectionNode = function(headA, headB) {\n    let map = new Map()\n    let h1 = headA\n    while(h1){\n        map.set(h1,true)\n        h1 = h1.next\n    }\n    let h2 = headB\n    while(h2){\n        if(map.get(h2)){\n            return h2\n        }else{\n            h2 = h2.next\n        }\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311140277","body":"var detectCycle = function(head) {\n    let m = new Map()\n    let cur = head\n    while(cur){\n        if(m.get(cur)){\n            return cur\n        }else{\n            m.set(cur,true)\n            cur = cur.next\n        }\n    }\n    return null\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312747309","body":"/**\n * @param {number} capacity\n */\nvar LRUCache = function(capacity) {\n    this.ln = capacity\n    this.m = new Map()\n};\n\n/** \n * @param {number} key\n * @return {number}\n */\nLRUCache.prototype.get = function(key) {\n    if(this.m.has(key)){\n        let val = this.m.get(key)\n        this.m.delete(key)\n        this.m.set(key,val)\n        return val\n    }\n    return -1\n};\n\n/** \n * @param {number} key \n * @param {number} value\n * @return {void}\n */\nLRUCache.prototype.put = function(key, value) {\n    this.m.delete(key)\n    this.m.set(key,value)\n    if(this.m.size > this.ln){\n        let k = this.m.keys().next().value\n        this.m.delete(k)\n    }\n};\n\n/**\n * Your LRUCache object will be instantiated and called as such:\n * var obj = new LRUCache(capacity)\n * var param_1 = obj.get(key)\n * obj.put(key,value)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312944016","body":"var isSameTree = function(p, q) {\n    if(!p && !q){\n        return true\n    }\n    if(p && q && p.val === q.val && isSameTree(p.left,q.left) && isSameTree(p.right,q.right)){\n        return true\n    }\n    return false\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314663924","body":"var sumNumbers = function(root) {\n    const dfs = (root,pre)=>{\n        if(!root)return 0\n        let cur = pre * 10 + root.val\n        if(!root.left && !root.right){\n            return cur\n        }else{\n            return dfs(root.left,cur) + dfs(root.right,cur)\n        }\n    }\n    return dfs(root,0)\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316402051","body":"var findBottomLeftValue = function(root) {\n    let stack = [root],res = 0\n    while(stack.length){\n        let ln = stack.length\n        for(let i=0;i<ln;i++){\n            let node = stack.shift()\n            if(i === 0){\n                res = node.val\n            }\n            node.left && stack.push(node.left)\n            node.right && stack.push(node.right) \n        }\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318140253","body":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function(root) {\n    return dfsSerialize(root,'')\n};\nvar dfsSerialize = (root,str)=>{\n   if(!root){\n       str += 'None,'\n   }else{\n       str += root.val + ','\n       str = dfsSerialize(root.left,str)\n       str = dfsSerialize(root.right,str)\n   }\n   return str\n}\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function(data) {\n    let arr = data.split(',')\n    return dfsDeserialize(arr)\n};\nvar dfsDeserialize = (dataList)=>{\n    if(dataList[0] === 'None'){\n        dataList.shift()\n        return null\n    }\n    let root = new TreeNode(parseInt(dataList[0]))\n    dataList.shift()\n    root.left = dfsDeserialize(dataList)\n    root.right = dfsDeserialize(dataList)\n    return root\n}\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321320562","body":"var topKFrequent = function(nums, k) {\n    let obj = {}\n    for(let i=0;i<nums.length;i++){\n        let key = nums[i]\n        if(typeof obj[key] === 'undefined'){\n            obj[key] = 1\n        }else{\n            obj[key] += 1\n        }\n    }\n    console.log(obj)\n    let cur = []\n    for(let k in obj){\n        let val = obj[k]\n        cur.push({number:val,key:k})\n    }\n    cur.sort((a,b)=>b.number-a.number)\n    console.log(cur)\n    let res = []\n    for(let i=0;i<k;i++){\n        res.push(cur[i].key)\n    }\n    return res\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326001198","body":"/**\n * @param {string} s\n * @return {number}\n */\nvar lengthOfLongestSubstring = function(s) {\n    let set = new Set(),rk = -1,max = 0\n    for(let i=0;i<s.length;i++){\n        if(i !== 0){\n            set.delete(s[i-1])\n        }\n        while(rk+1<s.length && !set.has(s[rk+1])){\n            set.add(s[rk+1])\n            ++rk\n        }\n        max = Math.max(max,rk+1-i)\n    }\n    return max\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299631296","body":"# 思路\r\n用空间换时间,先遍历记录index到 distance set,然后遍历一般根据distance set求最短距离\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_set = set()\r\n        res = [-1] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                char_set.add(i)\r\n        for j in range(len(s)):\r\n            lowest = float('inf')\r\n            for index in char_set:\r\n                if lowest > abs(index - j):\r\n                    lowest = abs(index - j)\r\n            res[j] = lowest\r\n        return res\r\n```\r\n\r\n\r\n# 复杂度\r\n时间复杂度: O(N) * O(M) , M取决于c出现的次数\r\n空间复杂度: O(M), M取决于c出现的次数\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304550486","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        \r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311428342","body":"```\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299691427","body":"### 思路\n先将字符串中C表示的字符的位置记录下来，然后计算字符串中每一个字符与所有字符C的距离，并求出最小距离\n\n\n\n### 代码\n\n```py\n\n\n\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        loc=[]\n        dis=[]        \n        for i in range(0,len(S)):\n            if S[i]==C:\n                loc.append(i)#记录e在列表中的位置\n        for i in range(0,len(S)):\n            t=[]\n            for j in loc:\n                t.append(abs(i-j))#计算每一个字符和所有C的距离\n            dis.append(min(t))#将最小距离添加到结果数组中\n        return dis\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303067731","body":"### 思路\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n如果当前的字符为字母或者左括号，直接进栈\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（这个次数和字符串构造出新的字符串并进栈\n\n### 代码\n\n\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n\n\n\n```\n\n**复杂度分析**\n时间复杂度 O(N)，递归会更新索引，因此实际上还是一次遍历 s；\n空间复杂度 O(N)，极端情况下递归深度将会达到线性级别。\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306396231","body":"### 思路\n\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\n\n\n\n### 代码\n\n\n```py\n\nclass Solution:\n    def swapPairs(self, head: ListNode) -> ListNode:\n        if not head or not head.next:\n            return head\n        newHead = head.next\n        head.next = self.swapPairs(newHead.next)\n        newHead.next = head\n        return newHead\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1310824821","body":"### 思路\n双指针第一次相遇，第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 ，双指针第二次相遇：\n\nslow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 11 步；双指针第二次相遇：\n\nslow指针 位置不变 ，将fast指针重新 指向链表头部节点 ；slow和fast同时每轮向前走 11 步；\n\n\n### 代码\n\n\n```py\nclass Solution(object):\n    def detectCycle(self, head):\n        fast, slow = head, head\n        while True:\n            if not (fast and fast.next): return\n            fast, slow = fast.next.next, slow.next\n            if fast == slow: break\n        fast = head\n        while fast != slow:\n            fast, slow = fast.next, slow.next\n        return fast\n\n```\n\n**复杂度分析**\n时间复杂度 O(N)O(N) ：第二次相遇中，慢指针须走步数 a < a + ba<a+b；第一次相遇中，慢指针须走步数 a + b - x < a + ba+b−x<a+b，其中 xx 为双指针重合点与环入口距离；因此总体为线性复杂度；\n空间复杂度 O(1)O(1) ：双指针使用常数大小的额外空间。\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312914024","body":"### 思路\n如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。\n\n### 代码\n\n\n```py\nclass Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(min(m,n))\n- 空间复杂度：O(min(m,n))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316108439","body":"### 思路\n深度优先搜索\n### 代码\n\n\n```py\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        curVal = curHeight = 0\n        def dfs(node: Optional[TreeNode], height: int) -> None:\n            if node is None:\n                return\n            height += 1\n            dfs(node.left, height)\n            dfs(node.right, height)\n            nonlocal curVal, curHeight\n            if height > curHeight:\n                curHeight = height\n                curVal = node.val\n        dfs(root, 0)\n        return curVal\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)O(n)，其中 nn 是二叉树的节点数目。需要遍历 nn 个节点。\n\n空间复杂度：O(n)O(n)。递归栈需要占用 O(n)O(n) 的空间\n","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321257128","body":"### 思路\n题目所描述的回旋镖可以视作一个 V\\texttt{V}V 型的折线。我们可以枚举每个 points[i]\\textit{points}[i]points[i]，将其当作 V\\texttt{V}V 型的拐点。设 points\\textit{points}points 中有 mmm 个点到 points[i]\\textit{points}[i]points[i] 的距离均相等，我们需要从这 mmm 点中选出 222 个点当作回旋镖的 222 个端点，由于题目要求考虑元组的顺序，因此方案数即为在 mmm 个元素中选出 222 个不同元素的排列数，即：\n\n### 代码\n\n\n```py\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p in points:\n            cnt = defaultdict(int)\n            for q in points:\n                dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1])\n                cnt[dis] += 1\n            for m in cnt.values():\n                ans += m * (m - 1)\n        return ans\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326000667","body":"var subarraysDivByK = function(nums, k) {\n    let count = 0, sum = 0;\n    let map = {} ;\n    map[0] = 1;\n    for (let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        const mod = (sum % k + k) % k\n        if (map[mod])\n            count += map[mod];\n        map[mod] = (map[mod]|| 0) + 1;\n    }\n    return count;\n};","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328375800","body":"class Solution:\ndef maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\nn = len(nums)\nq = [(-nums[i], i) for i in range(k)]\nheapq.heapify(q)\n\n    ans = [-q[0][0]]\n    for i in range(k, n):\n        heapq.heappush(q, (-nums[i], i))\n        while q[0][1] <= i - k:\n            heapq.heappop(q)\n        ans.append(-q[0][0])\n    \n    return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331718787","body":"class Solution {\n    public int findJudge(int N, int[][] trust) {\n        if (trust.length < N - 1) \n            return -1;\n        \n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\n        \n        for (int[] t : trust) {\n            trustScores[t[1]]++;\n            trustScores[t[0]]--;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            if (trustScores[i] == N - 1)\n                return i;\n        }\n        return -1;\n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336255657","body":"class Solution {\npublic:\n    int numberOfRounds(string startTime, string finishTime) {\n        int t0 = 60 * stoi(startTime.substr(0, 2)) + stoi(startTime.substr(3, 5));\n        int t1 = 60 * stoi(finishTime.substr(0, 2)) + stoi(finishTime.substr(3, 5));\n        if(t0>t1){\n            t1+=1440;\n        }       \n        t1=t1/15*15;\n        return max(0,(t1-t0))/15;\n    }\n};","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340283261","body":"    public int mySqrt(int x) {\n        if (x <= 1) return x;\n\n        int left = 1;\n        int right = x;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (mid > x / mid)\n                right = mid;\n            else \n                left = mid + 1;\n        }\n        \n        return left - 1;\n    }","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347595163","body":"class Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        n = len(s)\n        vowels = \"aeiou\"\n        j=ans=0\n        window = 0\n        for i, ch in enumerate(s):\n            if ch in vowels:\n                window+=1\n            \n            while j < n and (i-j+1) > k:\n                // # 长度大于k了, 需要缩小窗口\n                if s[j] in vowels:\n                    window -= 1\n                j+=1\n            \n            if (i-j+1) == k:\n                ans = max(ans, window)\n        \n        return ans","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357011543","body":"class Solution:\ndef totalNQueens(self, n: int) -> int:\nself.res = 0\nself.dfs([-1]*n, 0)\nreturn self.res\n\ndef dfs(self, nums, index):\n    if index == len(nums):\n        self.res += 1\n        return #backtracking\n    for i in range(len(nums)):\n        nums[index] = i\n        if self.valid(nums, index):\n            self.dfs(nums, index+1)\n\ndef valid(self, nums, n):\n    for i in range(n):\n        if nums[i] == nums[n] or abs(nums[n]-nums[i]) == n-i:\n            return False\n    return True\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300584266","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546499","body":"#  用栈实现队列-python \n## 思路\n添加数据用stack1 append， pop/peek数据时stack1pop到stack2, stack2再pop出来\n```bash\nclass MyQueue():\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n         \n    def push(self, x):\n        self.stack1.append(x)\n    \n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n        \n    def peek(self):\n        val = self.pop()\n        self.stack2.append(val)\n        return val\n        \n    def empty(self):\n        if not self.stack1 and not self.stack2:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304758987","body":"##768. 最多能完成排序的块 II-python\n\n解法1：排序\n```bash\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        count_a = defaultdict(int)\n        count_b = defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n解法2：递增\n```bash\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack:\n                if stack[-1] > a:\n                    cur = stack[-1]\n                    while stack and stack[-1] > a:\n                        stack.pop()\n                    stack.append(cur)   \n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305515774","body":"''' \n61. 旋转链表\n\n求单链表的倒数第 N 个节点\n\ninput:  1->2->3->4->5->6->NULL, k = 2\noutput: 5->6->1->2->3->5->NULL\n\n双指针\n\n注意：\n1. k大于指针长度时: length%k\n2. 指针2比指针1快k步,当指针2到尾部时,指针1刚好到倒数第k+1个值,\n    此时 指针1.next=Null返回 head\n    此时 指针1.next!Null返回 指针1.next\n'''\n\n```bash\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass Solution(object):\n    def rotateRightList(self , head: ListNode, k) -> ListNode:\n        if head:\n            p1 = head\n            p2 = head\n        \n            i = 0\n            length = 0\n            while i<k:\n                if p2.next:\n                    p2 = p2.next\n                    i += 1\n                    length += 1\n                else:\n                    k = length%length\n                    i = 0\n                    p2 = head\n            \n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n            \n            if p1.next:\n                temp = p1.next\n            else:\n                return head\n            \n            p1.next = None\n            p2.next = head\n            \n            return temp\n```\n                ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1328218657","body":"```bash\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution():\n    def changlist(self, head:ListNode):\n        if not head or not head.next: return head\n        \n        prehead = ListNode(-1)\n        prehead.next = head\n        \n        cur = prehead\n        \n        while cur.next and cur.next.next:\n            node1 = cur.next\n            node2 = node1.next\n            node3 = node2.next\n            \n            cur.next = node2\n            node1.next = node3\n            node2.next = node1\n            \n            cur = node1\n            node1 = node3\n            \n        return prehead.next\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1328218784","body":"```bash\n'''\n109. 有序链表转换二叉搜索树\n给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树\n(一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1)\n\n思路：\n让根节点左子树中的节点个数与右子树中的节点个数尽可能接近\n\nstep:\n1. 获取当前链表的中点\n2. 以链表中点为根\n3. 中点左边的值都小于它,可以构造左子树\n4. 同理构造右子树\n5. 循环第一步\n'''\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        \n        def getmid(left: ListNode, right: ListNode):\n            node1, node2 = left, left\n            while node2!=right and node2.next!=right:\n                node2=node2.next.next\n                node1=node1.next\n            return node1\n            \n        def bulid_tree(left: ListNode, right: ListNode):\n            if left == right:\n                return None # x\n            \n            mid = getmid(left, right)\n            node = TreeNode(mid.val)\n            node.left = bulid_tree(left, mid)\n            node.right = bulid_tree(mid.next, right)\n            return node # x\n        \n        return bulid_tree(head, None)\n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1328226687","body":"```bash\n'''160. 相交链表\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null\n'''\n\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n    \nclass Solution:\n    def IntersectList(self, headA:ListNode, headB:ListNode):\n        \n        ## 遍历headA，存在哈希表中，将headB与哈希表对比\n        # if not headA or not headB:\n        #     return None\n        \n        # hashlist = []\n        # cur1 = headA\n        # while headA:\n        #     hashlist.append(cur1)\n        #     cur1 = cur1.next\n        \n        # cur2 = headB\n        # while headB:\n        #     if cur2 in hashlist:\n        #         return cur2\n        #     cur2 = cur2.next\n        \n        # return None\n        \n        ## 双指针\n        node1, node2 = headA, headB\n        while node1!=node2:\n            if node1:\n                node1 = node1.next\n            else:\n                node1 = headB\n                \n            if node2:\n                node2 = node2.next\n            else:\n                node2 = headA\n                \n        return node1\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1328232130","body":"```bash\n'''hash 或者 快慢指针\n'''\n\nclass ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n\nclass Solution:\n    def detectCycle(self, head: ListNode):\n        ## 遍历headA，存在哈希表中，将headB与哈希表对比\n        # if not head:\n        #     return None\n        \n        # hashlist = []\n        # cur1 = head\n        # while head:\n        #     if cur1 in hashlist:\n        #         return cur1\n        #     else:\n        #         hashlist.append(cur1)\n        #         cur1 = cur1.next\n        \n        # return None\n        \n        ## 双指针\n        node1, node2 = head, head\n        flag = False\n        while node2 and node2.next:\n            node2 = node2.next.next\n            node1 = node1.next\n            if node1 == node2:\n                flag = True\n                break\n        \n        if not flag:\n            return None\n        \n        node2 = head\n        while node1!=node2:\n            node1 = node1.next\n            node2 = node2.next\n        \n        return node1\n        \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1329064758","body":"```bash \n'''146. LRU 缓存机制\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\n\n// put\nif key 存在:\n    更新节点值\n    把节点移到链表头部\n    \nelse:\n    if 缓存满了:\n        移除最后一个节点\n        删除它在哈希表中的映射\n\n    新建一个节点\n    把节点加到链表头部\n    在哈希表中增加映射\n\n// get\nif key 存在:\n    返回节点值\n    把节点移到链表头部\nelse:\n    返回 -1\n    \n'''\nfrom collections import OrderedDict\n\nclass solution():\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.dict = OrderedDict()\n    \n    def get(self, key):\n        if key not in self.dict:\n            return -1\n        self.dict.move_to_end(key) # x 把节点移到链表头部\n        return self.dict[key]\n    \n    def put(self, key, value):\n        if key in self.dict:\n            self.dict.move_to_end(key)\n        self.dict[key] = value\n        \n        if len(self.dict) > self.capacity:\n            self.dict.popitem(last=False)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1329066534","body":"```bash\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        \nclass Solution:\n    def maxDepth(self, root:TreeNode): \n        if root==None: #叶子结点返回0\n            return 0\n        else:\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n        \n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313132641","body":"```bash\nclass TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n        \n\nclass Solution:\n    def isSameTree(self , p: TreeNode, q:TreeNode):\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        return p.val==q.val and \\\n            (self.isSameTree(p.left, q.left)) and \\\n                (self.isSameTree(p.right, q.right))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1316517896","body":"# 思路\nBFS 两个队列管理node 以及node对应的数字\n```bash\nfrom collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass solution:\n    def sumtree(self, root: TreeNode):\n        if not root:\n            return 0\n        \n        nodequene = deque()\n        numquene = deque()\n        nodequene.append(root)\n        numquene.append(root.val)\n        \n        total = 0\n        \n        while nodequene:\n            length = len(nodequene)\n            \n            for i in range(length):\n                node = nodequene.popleft()\n                left, right = node.left, node.right\n                \n                num = numquene.popleft()\n                if not left and not right:\n                    total+=num\n                else:\n                    if left:            \n                        numquene.append(num*10 + left.val)\n                        nodequene.append(left)\n                    if right:\n                        numquene.append(num*10 + right.val)\n                        nodequene.append(right)\n\n        return total\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316516743","body":"# python\n思路 bfs\n```bash\nfrom collections import deque\nclass TreeNode():\n    def __init__(self, val=0, left=None, right=None) -> None:\n        self.val = val\n        self.left = left\n        self.right = right\n        \nclass Solution():\n    def find_bottom_left_value(self, root:TreeNode):\n        if not root:\n            return None\n        \n        nodequene = deque()\n        numquene = deque()\n\n        nodequene.append(root)\n        numquene.append(root.val)\n        \n        while nodequene:\n            length = len(nodequene)\n            num = nodequene[0].val\n            \n            for i in range(length):\n                node = nodequene.popleft()\n                left, right = node.left, node.right\n                \n                if left:\n                    numquene.append(left.val)\n                    nodequene.append(left)\n                if right:\n                    numquene.append(right.val)\n                    nodequene.append(right)\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318140840","body":"## bfs\n```bash\n# Definition for a binary tree node.\nfrom collections import deque\n\nclass TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        # if not root: return None\n        \n        nodequene = deque()\n        nodequene.append(root)\n        \n        ans = ''\n        while nodequene:\n            length = len(nodequene)\n            for _ in range(length):\n                node = nodequene.popleft()\n                if node:\n                    ans += str(node.val)+','\n                    left, right = node.left, node.right\n                    nodequene.append(left)\n                    nodequene.append(right)\n                else:\n                    ans+='null,'\n        return ans[:-1]\n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        nodes = data.split(',')\n        if not nodes: return None\n        root = TreeNode(nodes[0])\n        \n        nodequene = deque()\n        nodequene.append(root)\n        \n        i = 0\n        while i<len(nodes)-1:\n            node = nodequene.popleft()\n            left, right = nodes[i+1], nodes[i+2]\n            i += 2\n            if left!='null':\n                n_left = TreeNode(left)\n                node.left = n_left\n                nodequene.append(n_left)\n            if right!='null':\n                n_right = TreeNode(right)\n                node.right = n_right\n                nodequene.append(n_right)\n        return root\n        \n\n# Your Codec object will be instantiated and called as such:\n# ser = Solution()\n# deser = Solution()\n# ans = deser.deserialize(ser.serialize(root))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1328050175","body":"```bash\n''' 二叉树的垂序遍历\n'''\nclass TreeNode():\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n\nclass Solution():\n    def verticalTraversal(self, root:TreeNode):\n        record = list()\n        \n        def dfs(node, row, col ):\n            record.append((col, row, node.val))\n            dfs(node.left, row+1, col-1)\n            dfs(node.right, row+1, col+1)\n            \n        dfs(root, 0, 0)\n        \n        record.sort()\n        \n        lastcol = float(\"-inf\")\n        ans = []\n        \n        for col, _, node_val in record:\n            if col != lastcol:\n                lastcol = col\n                ans.append([])\n            ans[-1].append(node_val)\n            \n        return ans\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325161039","body":"```bash\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        res = []\n        m, n, ls = len(words), len(words[0]), len(s)\n        for i in range(n):\n            if i + m * n > ls:\n                break\n            differ = Counter()\n            for j in range(m):\n                word = s[i + j * n: i + (j + 1) * n]\n                differ[word] += 1\n            for word in words:\n                differ[word] -= 1\n                if differ[word] == 0:\n                    del differ[word]\n            for start in range(i, ls - m * n + 1, n):\n                if start != i:\n                    word = s[start + (m - 1) * n: start + m * n]\n                    differ[word] += 1\n                    if differ[word] == 0:\n                        del differ[word]\n                    word = s[start - n: start]\n                    differ[word] -= 1\n                    if differ[word] == 0:\n                        del differ[word]\n                if len(differ) == 0:\n                    res.append(start)\n        return res\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325936792","body":"同余定理\n```bash\nclass Solution:\n    def subarraysDivByK(self, nums, k):\n        record = {0: 1} # 初始化\n        total, ans = 0, 0\n        for nu in nums:\n            total += nu\n            modulus = total % k\n            same = record.get(modulus, 0)\n            record[modulus] = same + 1\n            ans += same\n        return ans\n    \n\nnums = [4,5,0,-2,-3,1]\nk=5\ns = Solution()\nans = s.subarraysDivByK(nums,k)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328038330","body":"'''快慢指针,快指针2,慢指针1\n'''\n```bash\nclass ListNode():\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n        \nclass Solution():\n    def middlelist(self, head):\n        head1 = head\n        head2 = head\n        while head1 and head1.next:\n            head1 = head1.next.next\n            head2 = head2.next\n        return head2\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328036971","body":"```bash\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(n-1,0,-1): \n            if nums[i] == nums[i-1]: \n                nums.pop(i)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328199017","body":"'''给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置\n   二分法\n'''\n```bash\nclass Solution():\n    def findvalue(self, nums, target):\n        # if not nums:\n        #     return None\n        \n        # flag = False\n        # for i, num in enumerate(nums):\n        #     if num != target:\n        #         continue\n        #     return i\n        \n        # if not flag:\n        #     for i, num in enumerate(nums[::-1]):\n        #         if target >= num:\n        #             return len(nums)-i\n        #     return 0\n        \n        ############################3\n        l = 0\n        r = len(nums)-1\n        \n        while(l<=r):\n            mid = (r+l)//2\n            if nums[mid] == target:\n                return mid\n            if nums[mid] < target:\n                l = mid + 1\n            else:\n                r = mid - 1\n        \n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328541210","body":"```bash\n'''239. 滑动窗口最大值\n给定一个数组 nums,有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n'''\n\nimport heapq\n\nclass Solution:\n    def shiftwindow(self, nums:list, k:int):\n        # # 超时了 O(nk)\n        # if not nums or not k:\n        #     return None\n        \n        # ans = []\n        # for i in range(len(nums)-k+1):\n        #     window = nums[i:i+k]\n        #     ans.append(max(window))\n            \n        # return ans\n    \n        # 堆\n        n = len(nums)\n        q = [(-nums[i], i) for i in range(k)]\n        heapq.heapify(q)\n        \n        ans = [-q[0][0]]\n        for i in range(k, n):\n            heapq.heappush(q, (-nums[i], i))\n            while q[0][1] <= i-k:\n                heapq.heappop(q)\n            ans.append(-q[0][0])    \n        \n        return ans\n        \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330039641","body":"```bash\n'''997. 找到小镇的法官\n   小镇的法官不相信任何人。\n   每个人（除了小镇法官外）都信任小镇的法官。\n   只有一个人同时满足条件 1 和条件 2\n   \n   思路：\n   找到入度为 n-1, 出度为 0 的点\n   \n   复杂度:O(n)\n'''\nclass Solution:\n     def findJudge(self, n, trust):\n        count = [0] * (n + 1)\n        for i, j in trust:\n            count[i] -= 1\n            count[j] += 1\n        for i in range(1, n + 1):\n            if count[i] == n - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331624723","body":"```bash\n'''886. 可能的二分法\n   给定一组 N 人(编号为 1,2,...,N), 我们想把每个人分进任意大小的两组。\n   每个人都可能不喜欢其他人，那么他们不应该属于同一组。\n   形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。\n   当可以用这种方法将每个人分进两组时,返回true; 否则返回false。\n   \n   # 二分图\n'''\n\nclass Solution:\n    def dfs(self, i, graph, colors, n, color=None):\n        colors[i]=color\n        for j in range(n):\n            if graph[i][j]!=1: #i不喜欢的人\n                continue\n            if colors[j]==color: #i不喜欢的人与i在同一组\n                return False\n            if colors[j]==0: #i不喜欢的人还没有分组\n                if not self.dfs(j, graph, colors, n, color=-1*color):\n                    return False\n        return True\n\n    def possibleBipartition(self, n, dislikes):\n        graph = [[0]*n for i in range(n)]\n        for (a, b) in dislikes:\n            graph[a-1][b-1]=1\n            graph[b-1][a-1]=1\n        \n        colors = [0]*n\n        for i in range(n):\n            if colors[i]!=0:\n                continue\n            if not self.dfs(i, graph, colors, n, color=1):\n                return False\n        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333339321","body":"```bash\n''' 公司共有 n 个项目和 m 个小组，每个项目要不无人接手，要不就由 m 个小组之一负责\n    拓扑排序：对于一张有向图 G,我们需要将 G 的 n 个点排列成一组序列，使得图中任意一对顶点 <u,v>,\n    如果图中存在一条 u→v 的边，那么 u 在序列中需要出现在 v 的前面\n'''\nfrom collections import defaultdict, deque\nimport numpy as np\n\nclass Solution:\n    \n    # 拓扑排序\n    def tp_sort(self, indegree, graph, items):\n        q = deque([])\n        ans = []\n        for item in items:\n            if indegree[item]==0:\n                q.append(item)\n        \n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n            \n            for neib in graph[cur]:\n                indegree[neib] -= 1\n                if indegree[neib]==0:\n                    q.append(neib)\n        return ans\n                    \n    def sortItems(self, n, m, group, beforeItems):\n        # 无人负责的项目单独为一组\n        max_group = m\n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_group\n                max_group += 1\n                \n        project_graph = defaultdict(list)\n        project_indegree = defaultdict(int)\n        \n        group_graph = defaultdict(list)\n        group_indegree = defaultdict(int)\n        \n        group_projects = defaultdict(list)  \n        \n        for i in range(n):\n            # 一组处理的项目\n            group_projects[group[i]].append(i)\n            \n            # 如果一个项目和这个项目的依赖（如果存在）需要不同的组来完成，那么这两个组就拥有依赖关系\n            before_projects_i = beforeItems[i]\n            for before_project in before_projects_i:\n                if group[before_project] != group[i]: \n                    # 小组关系图\n                    group_indegree[group[i]] += 1\n                    group_graph[group[before_project]].append(group[i])\n                else:\n                    # 项目关系图\n                    project_indegree[i] += 1\n                    project_graph[before_project].append(i)\n        \n        # 先对group排序：\n        group_items = np.arange(max_group).tolist()\n        group_quene = self.tp_sort(group_indegree, group_graph, group_items)\n        \n        if len(group_quene) != max_group:\n            return []\n        \n        ans = []\n        for group_id in group_quene:\n            # 对每个group里的project排序\n            project_items = group_projects[group_id]\n            project_quene = self.tp_sort(project_indegree, project_graph, project_items)\n            \n            if len(project_quene) != len(project_items):\n                return []\n            \n            ans += project_quene\n            \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334697009","body":"```bash\nclass Solution:\n    def judgeCircle(self, moves: str):\n        begin = [0,0]\n\n        for m in moves:\n            if m == 'R':\n                begin[0]+=1\n            if m == 'L':\n                begin[0]+=-1\n            if m == 'U':\n                begin[1]+=1\n            if m == 'D':\n                begin[1]+=-1\n                \n        return begin == [0,0]\n        \n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336871932","body":"```bash\n''' 1904. 你完成的完整对局数\n    startTime-finishTime 完成了多少完整对局\n'''\nclass Solution:\n    def numberOfRounds(self, startTime: str, finishTime: str):\n        start_hour, start_min = map(int, startTime.split(':'))\n        finish_hour, finish_min = map(int, finishTime.split(':'))\n        \n        start_time, finish_time = 0,0\n        if start_hour*60+start_min > finish_hour*60+finish_min:\n            finish_time += 24*60\n        \n        if 0 < start_min <= 15:\n            start_min = 15\n        elif 15 < start_min <= 30:\n            start_min = 30\n        elif 30 < start_min <= 45:\n            start_min = 45\n        elif 45 < start_min <= 60:\n            start_min = 0\n            start_hour += 1\n            \n        if 0 <= finish_min < 15:\n            finish_min = 0\n        elif 15 <= finish_min < 30:\n            finish_min = 15\n        elif 30 <= finish_min < 45:\n            finish_min = 30\n        elif 45 <= finish_min < 60:\n            finish_min = 45\n        \n        start_time += start_hour*60 + start_min\n        finish_time += finish_hour*60 + finish_min\n        \n        # if start_hour*60+start_min > finish_hour*60+finish_min:\n        #     finish_time += 24*60\n        \n        game_time = (finish_time - start_time)//15\n        \n        return max(0, game_time)\n    \n\nstartTime = \"00:47\"\nfinishTime = \"00:57\"\ns = Solution()\nans = s.numberOfRounds(startTime, finishTime)\nprint(ans)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336830749","body":"```bash\n''' 1737. 满足三条件之一需改变的最少字符数\n    操作的最终目标是满足下列三个条件之一\n\n    a 中的每个字母在字母表中严格小于 b 中的每个字母\n    b 中的每个字母在字母表中严格小于 a 中的每个字母\n    a 和 b 都由同一个字母组成\n    返回达成目标所需的最少操作数\n'''\n\nclass Solution:\n    def minCharacters(self, A: str, B: str):\n        counter_A = [0] * 26\n        counter_B = [0] * 26\n        for a in A:\n            counter_A[ord(a) - ord('a')] += 1\n        for b in B:\n            counter_B[ord(b) - ord('a')] += 1\n        \n        ans = len(A)+len(B)\n        \n        # AB为一样的同一个字母组成的字符串\n        for i in range(26):\n            ans = min(ans, len(A)+len(B)-counter_A[i]-counter_B[i])\n        \n        # A 的最大字母保证严格小于 B 的最大字母\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_A[j]\n            for j in range(i):\n                t += counter_B[j]\n            ans = min(ans, t)\n\n        # B 的最大字母保证严格小于 A 的最大字母\n        for i in range(1, 26):\n            t = 0\n            for j in range(i, 26):\n                t += counter_B[j]\n            for j in range(i):\n                t += counter_A[j]\n            ans = min(ans, t)\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1338739316","body":"```bash\n''' 912. 排序数组\n    给你一个整数数组nums, 请你将该数组升序排列\n'''\n\nclass Solution:\n    def sortArray(self, nums:list):\n        # 归并排序\n        def merge_sort(arr, low, high):\n            if low >= high:\n                return\n            \n            mid = (low+high)//2\n            merge_sort(arr, low, mid)\n            merge_sort(arr, mid+1, high)\n            \n            left, right = low, mid+1\n            \n            tmp = []\n            while left<=mid and right<=high:\n                if arr[left]<=arr[right]:\n                    tmp.append(arr[left])\n                    left += 1\n                if arr[left]> arr[right]:\n                    tmp.append(arr[right])\n                    right += 1\n            \n            while left<= mid:\n                tmp.append(arr[left])\n                left += 1\n            \n            while right <= high:\n                tmp.append(arr[right])\n                right += 1\n                \n            arr[low:high+1] = tmp\n        \n        merge_sort(nums, 0, len(nums)-1)\n        return nums\n\ns=Solution()\nnums=[5,1,1,2,0,0]\nans = s.sortArray(nums)\nprint(ans)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341944075","body":"```bash\n'''278. 第一个错误的版本\n'''\n\nclass Solution:\n    def firstBadVersion(self, n: int):\n        l, r = 1, n\n        while l<=r:\n            mid = (l+r)//2\n            if isBadVersion(mid):\n                r = mid-1\n            else:\n                l = mid+1\n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343868542","body":"```bash\n''' 493. 翻转对\n    给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。\n    你需要返回给定数组中的重要翻转对的数量。\n'''\n# 有bug\n\nclass Solution:\n    def reversePairs(self, nums:list):\n        self.count = 0\n        def merge_sort(arr, low=None, high=None):\n            if low >= high:\n                return\n            \n            mid = (low+high)//2\n            merge_sort(arr, low=low, high=mid)\n            merge_sort(arr, low=mid+1, high=high)\n            \n            left, right = low, mid+1 \n            temp = []\n            while left<=mid and right<=high:\n                if arr[left]<=2*arr[right]:\n                    temp.append(arr[left])\n                    left+=1\n                else:\n                    temp.append(arr[right])\n                    right+=1\n                    self.count += mid-left+1\n            \n            while left<=mid:\n                temp.append(arr[left])\n                left+=1\n            \n            while right<=high:\n                temp.append(arr[right])\n                right+=1\n                \n            for i in range(len(temp)):\n                nums[low + i] = temp[i]\n                    \n        merge_sort(nums, low=0, high=len(nums)-1)\n        return self.count\n        \ns=Solution()\nnums=[1,3,2,3,1]\narr = s.reversePairs(nums)\nprint(arr)\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345587431","body":"```bash\n''' Given a list of integers nums A and an integer k, return the k-th (0-indexed) smallest abs(x - y) for every pair of elements (x, y) in nums.\n    Note that (x, y) and (y, x) are considered the same pair.\n'''\nimport heapq\n\nclass Solution:\n    def solve(self, A, k):\n        A = sorted(A)\n        length = len(A)\n        sub = [(abs(A[i]-A[j]), i-1, i) for i in range(1, length)]\n        heapq.heapify(sub)\n        \n        while True:\n            top, i, j = heapq.heappop(sub)\n            if not k: return top\n            k -= 1\n            if j+1 < length:\n                heapq.heappush(sub, (abs(A[j+1]-A[i]), i, j+1))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346013248","body":"```bash\n''' 778. 水位上升的泳池中游泳\n    在一个 N x N 的坐标方格 grid 中,每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。\n\n    现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t。\n    你可以从一个平台游向四周相邻的任意一个平台,但是前提是此时水位必须同时淹没这两个平台。\n    假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。\n\n    从坐标方格的左上平台 (0,0) 出发。最少耗时多久你才能到达坐标方格的右下平台  (N-1, N-1)?\n    \n    # 思路\n    我们执行广度优先搜索，并只去访问那些高度不超过 threshold 的方格。如果能访问到终点，说明存在这样一种路径。\n    如果能在 threshold 时间内从起点到达终点，则一定也能在 threshold+1 的时间内从起点到达终点。\n    因此，我们可以通过二分查找的方式，寻找最小可能的 threshold\n\n'''\n\nclass Solution:\n    def test(self, mid, x, y, grid, record):\n        if x>len(grid)-1 or y>len(grid[0])-1:\n            return False\n        if x<0 or y<0:\n            return False\n        if grid[x][y] > mid:\n            return False\n        if (x, y) == (len(grid)-1, len(grid[0])-1):\n            return True\n        if (x, y) in record:\n            return False\n        \n        record.add((x, y))\n        \n        ans = self.test(mid, x+1, y, grid, record) or self.test(mid, x-1, y, grid, record) \\\n            or self.test(mid, x, y+1, grid, record) or self.test(mid, x, y-1, grid, record)\n            \n        return ans\n        \n    def swimInWater(self, grid: list[list[int]]):\n        l = 0\n        r = max([max(depth) for depth in grid]) #最大水位\n        \n        record = set()\n        while l<=r:\n            mid = (l+r)//2\n            if self.test(mid, 0, 0, grid, record):\n                r = mid-1\n            else:\n                l = mid+1\n            record = set()\n            \n        return l\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347698039","body":"```bash\n''' 给你字符串 s 和整数 k 。\n    请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。\n    英文中的元音字母 为(a, e, i, o, u)\n'''\nclass Solution:\n    def maxVowels(self, s: str, k: int):\n        \n        vowls = set(['a','e','i','o','u'])\n        temp = [v for v in s[:k] if v in vowls]\n        ans = len(temp)\n        \n        if ans == k:\n            return k\n        \n        for i in range(1, len(s)-k+1):\n            if s[i-1] in vowls:\n                temp.remove(s[i-1])\n            if s[i+k-1] in vowls:\n                temp.append(s[i+k-1])\n            ans = max(ans, len(temp))\n            \n            if ans == k:\n                return k\n        \n        return ans\n\ns = \"tryhard\"\nk = 3\nsolution = Solution()\nans = solution.maxVowels(s, k)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1350398160","body":"```bash\n''' 21点\n    爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。\n    当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？\n    # 思路: 动态规划+滑动窗口\n'''\n\nclass Solution:\n    def new21Game(self, n: int, k: int, W: int):\n        # 超时\n        # dp = [0] * (k + W)\n        \n        # # 初始化 dp[i] 依赖 dp[i + x]，其中 x 属于 [1,W]\n        # for i in range(k, k + W):\n        #     if i <= n:\n        #         dp[i] = 1\n\n        # # dp[i]表示当前分数为 i 的情况下，分数不超过 N 的概率\n        # for i in range(k-1, -1, -1):\n        #     dp[i] = sum(dp[i+j] for j in range(1, W + 1)) / W\n        # return dp[0]\n        \n        dp = [0] * (k + W)\n        window_sum = 0\n        # 初始化 dp[i] 依赖 dp[i + x]，其中 x 属于 [1,W]\n        for i in range(k, k + W):\n            if i <= n:\n                dp[i] = 1\n            window_sum += dp[i]\n\n        # dp[i]表示当前分数为 i 的情况下，分数不超过 N 的概率\n        for i in range(k-1, -1, -1):\n            dp[i] = window_sum / W\n            window_sum += dp[i] - dp[i+W]\n        return dp[0]\n    \n\nn = 21\nk = 17\nW = 10\n\nsolution = Solution()\nans = solution.new21Game(n,k,W)\nprint(ans)\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356227384","body":"```bash\n''' 给你一个数组,你只可以移除数组两端的数。求最小移除次数,使得移除的数字和为target\n    思路：\n    sum(A)-target的最长子序列\n'''\n\nclass Solution:\n    def solve(self, A: list[int], target: int):\n        target = sum(A)-target\n        ans = len(A)+1\n        \n        t = 0\n        j = 0\n        \n        for i in range(len(A)):\n            t += A[i]\n            while t > target and j < i:\n                t -= A[j]\n                j += 1\n            if t == target:\n                ans = min(ans, len(A)-(i-j+1))\n        \n        return -1 if ans == len(A) + 1 else ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1357496344","body":"```bash\nclass Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        return [str(a) + \":\" + f'{b:02d}' for a in range(12) for b in range(60) if (bin(a)+bin(b)).count('1') == turnedOn]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357443005","body":"```bash\n''' 52. N皇后 II\n    思路: 任何两个皇后都不能处于同一条横行、纵行或斜线上。\n    # diagonals1 左斜线\n    # diagonals2 右斜线\n'''\n\nclass Solution:\n    def totalNQueens(self, n: int):\n        def dfs(row, columns, diagonals1, diagonals2):\n            if row == n:\n                return 1\n            else:\n                count = 0\n                avaliable = (~(columns|diagonals1|diagonals2)) & ((1<<n)-1)\n                while avaliable:\n                    position = avaliable & (-avaliable)   # 最低位的 1 的位置\n                    avaliable = avaliable & (avaliable-1) # 最低位的 1 置成 0\n                    count += dfs(row+1, columns|position, (diagonals1|position) << 1, (diagonals2|position) >> 1)\n                return count\n            \n        return dfs(0,0,0,0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1367181131","body":"```bash\nclass Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n\n        m,n = len(grid), len(grid[0])\n        ans = 0\n        def dfs(i,j):\n            if i < 0 or i >= m or j < 0 or j >= n: return 0\n            if grid[i][j] == 0: return 0\n            grid[i][j] = 0\n            top = dfs(i+1,j)\n            bottom = dfs(i-1,j)\n            left = dfs(i,j-1)\n            right = dfs(i,j+1)\n            return 1 + sum([top, bottom,left, right])\n\n        for i in range(m):\n            for j in range(n):\n                ans = max(ans, dfs(i,j))\n\n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1371053934","body":"```bash\n''' 1162. 地图分析\n    陆地1 海洋0\n'''\nclass Solution:\n    def maxDistance(self, grid: list[list[int]]):\n\n        n = len(grid)\n        q = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        \n        if len(q) == 0 or len(q) == n ** 2: \n            return -1\n\n        steps = -1\n        while(len(q)>0):\n            for _ in range(len(q)):\n                x, y = q.pop(0)\n                for xx, yy in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xx < 0 or xx >= n or yy < 0 or yy >= n:\n                        continue\n                    if grid[xx][yy] != 0:\n                        continue\n                    q.append((xx, yy))\n                    grid[xx][yy] = -1\n            \n            steps += 1\n        return steps\n\ngrid = [[1,0,1],[0,0,0],[1,0,1]]\nsolution = Solution()\nans = solution.maxDistance(grid)\nprint(ans)       \n        \n```\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1366418131","body":"```bash\nclass Solution:\n    def minCostClimbingStairs(self, cost: list[int]):\n        cost = cost + [0]\n        dp = [0]*len(cost)\n        dp[0], dp[1] = cost[0], cost[1]\n        for i in range(2, len(cost)):\n            dp[i] = min(dp[i-1], dp[i-2]) + (cost[i])\n        return dp[-1]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1366511971","body":"```bash\nif len(nums) == 1:\n            return nums[0]\n\n        dp = [0] * len(nums)\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\n        \n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i-1], dp[i-2]+nums[i])\n        \n        return dp[-1]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364948342","body":"```bash\n''' 给定一个未排序的整数数组，找到最长递增子序列的个数。\n    dp[i][0]:长度\n    dp[i][1]:个数\n'''\nclass Solution:\n    def findNumberOfLIS(self, nums: list[int]):\n        n = len(nums)\n        dp = [[1,1] for i in range(n)]\n        longest = 1\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[j] > nums[i]:\n                    if dp[i][0]+1 > dp[j][0]:\n                        dp[j][1] = dp[i][1] # 个数\n                        dp[j][0] = dp[i][0] + 1 # 长度\n                        longest = max(longest, dp[j][0])\n                    elif dp[i][0]+1 == dp[j][0]: # 长度一样\n                        dp[j][1] += dp[i][1]\n        \n        ans = sum(dp[i][1] for i in range(n) if dp[i][0]==longest)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365608446","body":"```bash\nclass Solution:\n    def longestCommonSubsequence(self, A: str, B: str) -> int:\n        m,n = len(A), len(B)\n        ans = 0\n        dp = [[0 for _ in range(n + 1)] for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if A[i-1] == B[j-1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                    ans = max(ans, dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366356701","body":"```bash\nclass Solution:\n    def uniquePaths(self, m: int, n: int):\n        dp = [[0]*n for _ in range(m)]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] =  dp[i - 1][j] + dp[i][j - 1]\n        return dp[m-1][n-1]\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367120293","body":"```bash\n''' 688. 骑士在棋盘上的概率\n'''\n\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        step_proposed = [[2,-1], [2,1], [1,2], [-1,2], [-2,1], [-2,-1], [1,-2], [-1,-2]]\n        dp = [[[0]*n for _ in range(n)] for _ in range(k+1)]\n        for step in range(k+1):\n            for i in range(n):\n                for j in range(n):\n                    if step == 0:\n                        dp[step][i][j]=1\n                    else:\n                        for step_i, step_j in step_proposed:\n                            if 0 <= i-step_i < n and 0 <= j-step_j < n:\n                                dp[step][i][j] += (1/8)*dp[step-1][i-step_i][j-step_j]\n        \n        return dp[k][row][column]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/67#issuecomment-1367819955","body":"```bash\n''' 464. 我能赢么\n    判断先出手的玩家是否能稳赢\n'''\n\nclass Solution:\n    def canIWin(self, maxChoosableInteger: int, desiredTotal: int):\n        # def dfs(totol):\n        #     if totol>=desiredTotal: return False\n            \n        #     for i in range(1, maxChoosableInteger+1):\n        #         if not dfs(totol+i):\n        #             return True\n            \n        #     return False\n        \n        # return dfs(0)\n        \n        if desiredTotal <= maxChoosableInteger: return True\n        if sum(range(maxChoosableInteger + 1)) < desiredTotal: return False\n        \n        def dfs(picked, acc):\n            if acc >= desiredTotal: return False\n            if len(picked) == maxChoosableInteger: return False\n            \n            for n in range(1, maxChoosableInteger + 1):\n                if n not in picked:\n                    picked.add(n)\n                    if not dfs(picked, acc + n):\n                        picked.remove(n)\n                        return True\n                    picked.remove(n)\n            return False\n\n        return dfs(set(), 0)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368376962","body":"```bash\n# 416. 分割等和子集\n''' 背包\n'''\nclass Solution:\n    def canPartition(self, nums: list[int]):\n\n        if len(nums) < 2:\n            return False\n\n        total = sum(nums)\n        if total % 2 != 0:\n            return False\n        \n        target = total // 2\n\n        maxNum = max(nums)\n        if maxNum > target:\n            return False\n\n        dp = [[False] * (target+1) for _ in range(len(nums))]\n        for i in range(len(nums)):\n            dp[i][0] = True\n        \n        dp[0][nums[0]] = True\n        for i in range(1, len(nums)):\n            for j in range(1, target+1):\n                if j >= nums[i]:\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - nums[i]]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[len(nums)-1][target]\n\nnums = [1,5,11,5]\nsolution = Solution()\nans = solution.canPartition(nums)\nprint(ans)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368967473","body":"```bash\n# 494. 目标和\nclass Solution:\n    def findTargetSumWays(self, nums: list[int], target: int):\n        n = len(nums)\n        total = sum(nums)\n        if (total+target)%2 != 0 or (total+target)/2 < 0:\n            return 0\n        t = int((total+target)/2)\n        \n        dp = [[0]*(t+1) for _ in range(n+1)] \n        # for i in range(n+1):\n        #     dp[i][0] = 1\n        dp[0][0]=1\n        \n        for i in range(t+1):\n            for j in range(1, len(nums) + 1):\n                dp[j][i] = dp[j-1][i]\n                if i-nums[j-1] >= 0: \n                    dp[j][i] += dp[j-1][i - nums[j-1]]\n        \n        return dp[-1][-1]\nnums = [1,1,1,1,1]\ntarget = 3\nsolution = Solution()\nans = solution.findTargetSumWays(nums, target)\nprint(ans)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368933000","body":"```bash\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        n = len(coins)\n        dp = [[amount + 1]*(amount+1) for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 0\n        \n        for i in range(1, amount+1):\n            for j in range(1,n+1):\n                coin = coins[j-1]\n                if i >= coin:\n                    dp[j][i] = min(dp[j-1][i], dp[j][i-coin]+1)\n                else:\n                    dp[j][i] = dp[j-1][i]\n\n        if dp[n][amount] == amount+1:\n            return -1\n        return dp[n][amount]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369916889","body":"```bash\n# 518. 零钱兑换 II\n'''\n'''\nclass Solution:\n    def change(self, amount: int, coins: list[int]):\n        n = len(coins)\n        dp = [[0]*(amount+1) for _ in range(n+1)]\n        # for i in range(n+1):\n        #     dp[i][0] = 0\n        dp[0][0]=1\n        for i in range(amount+1):\n            for j in range(1, n+1):\n                coin = coins[j-1]\n                dp[j][i] = dp[j-1][i]\n                if i-coin >= 0:\n                    dp[j][i] += dp[j][i-coin]\n        return dp[-1][-1]\n\ncoins = [1,2,5]\namount = 5\nsolution = Solution()\nans = solution.change(amount, coins)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1370506612","body":"```bash\n# 455 分发饼干\n''' 从大到小排序\n    饼干>胃口 count+1\n'''\n\nclass Solution:\n    def findContentChildren(self, g: list[int], s: list[int]):\n        g = sorted(g, reverse=True)\n        s = sorted(s, reverse=True)\n        count = 0\n        gg,ss = 0,0\n        while gg<len(g) and ss<len(s):\n            if s[ss]>=g[gg]:\n                ss+=1\n                count+=1\n            gg+=1\n        return count\n\ng = [1,2,3]\ns = [1,1]\nsolution = Solution()\nans = solution.findContentChildren(g, s)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371735299","body":"```bash\n\nclass Solution:\n    def eraseOverlapIntervals(self, intervals: list[list[int]]):\n        n = len(intervals)\n        dp = [1]*n\n        intervals = sorted(intervals, key=lambda a: a[1])\n        ans = 1\n        \n        for i in range(n):\n            class_i = intervals[i]\n            for j in range(i-1, -1, -1):\n                class_j = intervals[j]\n                if class_i[0]>=class_j[1]:\n                   dp[i] = max(dp[i], dp[j]+1)\n        ans = n-max(dp)\n        return ans\n\nintervals = [[1,2],[2,3],[3,4],[1,3]]\nsolution = Solution()\nans = solution.eraseOverlapIntervals(intervals)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/74#issuecomment-1373132867","body":"```bash\n# 881. 救生艇\n''' 第 i 个人的体重为 people[i],每艘船可以承载的最大重量为 limit\n    每艘船最多可同时载两人,但条件是这些人的重量之和最多为 limit\n    返回载到每一个人所需的最小船数 (保证每个人都能被船载)\n'''\n\nclass Solution:\n    def numRescueBoats(self, people: list[int], limit: int):\n        ans = 0\n        people = sorted(people)\n        n = len(people)\n        \n        left, right = 0, n-1\n        while left <= right:\n            if people[left]+people[right]>limit:\n                right-=1\n            else:\n                left+=1\n                right-=1\n            ans+=1\n        \n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1374436543","body":"```bash\n# 96. 不同的二叉搜索树\n'''  动态规划\n    假设 n 个节点存在二叉排序树的个数是 G (n)，令 f(i) 为以 i 为根的二叉搜索树的个数，则\n    G(n)=f(1)+f(2)+f(3)+f(4)+...+f(n)\n    当 i 为根节点时，其左子树节点个数为 i-1 个，右子树节点为 n-i, 则 \n    f(i) = G(i-1)*G(n-i)\n    综合两个公式可以得到 卡特兰数 公式\n    G(n)=G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)\n'''\n\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0]*(n+1)\n        dp[0] = 1;\n        dp[1] = 1;\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        return dp[n]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374750218","body":"```bash\n# 合并 K 个排序链表\n''' 合并 k 个排序链表，返回合并后的排序链表 请分析和描述算法的复杂度\n    分治\n    时间复杂度 O(kn*logk)\n'''\n\n# Definition for singly-linked list.\nclass ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\n\nclass Solution:\n    def mergeKLists(self, lists: list[ListNode]) -> list[ListNode]:\n        n = len(lists)\n        if n == 0: return None\n        if n == 1: return lists[0]\n        if n == 2: return self.merge2Lists(lists[0], lists[1])\n        \n        mid = n//2\n        return self.merge2Lists(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\n    \n    def merge2Lists(self, list1: ListNode, list2: ListNode):\n        res = ListNode(0)\n        n1, n2, n3 = list1, list2, res\n        while n1 and n2:\n            if n1.val < n2.val:\n                n3.next = ListNode(n1.val)\n                n1 = n1.next\n            else:\n                n3.next = ListNode(n2.val)\n                n2 = n2.next\n            n3 = n3.next\n\n        while n1:\n            n3.next = ListNode(n1.val)\n            n1 = n1.next\n            n3 = n3.next\n\n        while n2:\n            n3.next = ListNode(n2.val)\n            n2 = n2.next\n            n3 = n3.next\n        \n        return res.next\n        \n\nlists = [[1,4,5],[1,3,4],[2,6]]\nsolution = Solution()\nans = solution.mergeKLists(lists)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1375392304","body":"```bash\n# 932. 漂亮数组\n''' 分治 nlogn\n'''\n\nclass Solution:\n    def beautifulArray(self, n: int) -> list[int]:\n        def dp(n):\n            if n == 1:\n                return [1]\n            ans = []\n            for a in dp((n+1)//2):\n                ans += [a * 2 - 1]\n            for b in dp(n//2):\n                ans += [b * 2]\n            return ans\n\n        return dp(n)\n\nn = 4\nsolution = Solution()\nans = solution.beautifulArray(n)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1377317948","body":"```bash\n# 260. 只出现一次的数字 III\nfrom collections import Counter\n\nclass Solution:\n    def singleNumber(self, nums: list[int]) -> list[int]:\n        # count = Counter(nums)\n        # ans = [k for k,v in count.items() if v==1]\n        # return ans\n        \n        xorsum = 0\n        for num in nums:\n            xorsum ^= num\n        \n        # lsb = xorsum & (-xorsum)\n        lsb = 1\n        while lsb & xorsum == 0:\n            lsb <<= 1\n        type1 = type2 = 0\n        for num in nums:\n            if num & lsb:\n                type1 ^= num\n            else:\n                type2 ^= num\n        \n        return [type1, type2]\n\n    \nnums = [1,2,1,3,2,5] \ns = Solution()\nans = s.singleNumber(nums)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378225837","body":"```bash\n# 78. 子集\n''' 枚举 mask∈[0,2**n-1] \n    时间复杂度: O(nx2**n)\n    空间复杂度: O(n)\n'''\nclass Solution:\n    def subsets(self, nums: list[int]):\n        n = len(nums)\n        num_mask = 2**n\n        ans = []\n        for i in range(num_mask):\n            # mask = bin(i)\n            sub = []\n            for j in range(n):\n                num = nums[j]\n                if i & (1<<j):\n                    sub.append(num)\n            ans.append(sub)\n        \n        return ans\n                    \nnums = [1,2,3]\ns = Solution()\nans = s.subsets(nums)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1379847134","body":"```bash\n\nclass TrieNode:\n    def __init__(self):\n        self.count = 0 # 表示以该处节点构成的串的个数\n        self.preCount = 0 # 表示以该处节点构成的前缀的字串的个数\n        self.children = {}\n\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str):\n        node = self.root\n        for w in word:\n            if w not in node.children:\n               node.children[w] = TrieNode()\n            node = node.children[w]\n            node.preCount += 1\n        node.count += 1\n\n    def search(self, word: str):\n        node = self.root\n        for w in word:\n            if w not in node.children:\n               return False\n            node = node.children[w]\n        if node.count > 0:\n            return True\n        else:\n            return False\n\n    def startsWith(self, prefix: str):\n        node = self.root\n        for w in prefix:\n            if w not in node.children:\n               return False\n            node = node.children[w]\n        return node.preCount > 0\n\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1381246043","body":"```bash\nclass TrieNode:\n    def __init__(self):\n        self.count = 0 # 表示以该处节点构成的串的个数\n        self.preCount = {} # 表示以该处节点构成的前缀的字串的个数\n        self.children = {}\n\nclass MapSum:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n\n    def insert(self, key: str, val: int):\n        node = self.root\n        for w in key:\n            if w not in node.children:\n                node.children[w]=TrieNode()\n            node = node.children[w]\n            node.preCount[key] = val\n\n    def sum(self, prefix: str):\n        node = self.root\n        for w in prefix:\n            if w not in node.children:\n                return 0\n            node = node.children[w]\n        return sum([v for v in node.preCount.values()])\n\n\n# Your MapSum object will be instantiated and called as such:\n# obj = MapSum()\n# obj.insert(key,val)\n# param_2 = obj.sum(prefix)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/82#issuecomment-1382680922","body":"```bash\n\n\nclass Solution:\n            \n    def multiSearch(self, big: str, smalls: list[str]):\n        postion = []\n        for small in smalls:\n            length = max(len(small), 1)\n            k = 0\n            p = []\n            while k + length <= len(big):\n                if big[k:k+length] == small:\n                    p.append(k)\n                k += 1\n            postion.append(p)\n        return postion\n        \n\nbig = \"mississippi\"\nsmalls = [\"is\",\"ppi\",\"hi\",\"sis\",\"i\",\"ssippi\"]   \ns = Solution()\nans = s.multiSearch(big, smalls)\nprint(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383102661","body":"```bash\n# 547. 省份数量\nclass Solution:\n    def findCircleNum(self, isConnected: list[list[int]]):\n        def find(index):\n            if parent[index]!=index:\n                parent[index] = find(parent[index])\n            return parent[index]\n        \n        def union(index1, index2):\n            parent[find(index1)] = find(index2)\n        \n        num_city = len(isConnected)\n        parent = list(range(num_city))\n        \n        for i in range(num_city):\n            for j in range(i+1, num_city):\n                if isConnected[i][j] == 1:\n                    union(i,j) \n        print(parent)\n        return  sum([parent[i]==i for i in range(num_city)])\n            \n\nisConnected = [[1,1,0],[1,1,0],[0,0,1]]\ns = Solution()\nans = s.findCircleNum(isConnected)\nprint(ans)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300675274","body":"## 解题思路\r\n\r\n最初思路：先找到第一个 c，并把前面的距离填充好，后面再继续找 c，最后按左右对称来填充。\r\n看了题解：前后两趟遍历（Orz）\r\n\r\n## 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n        int index;\r\n\r\n        index = -2*n; // 保证足够小，i - index 得到一个足够大的数。\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = i - index;\r\n        }\r\n\r\n        index = 2*n;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = min(ans[i], index - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复制度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302251142","body":"## 思路\n使用 vector 存放\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int top, max;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (top == max - 1) {\n            return;\n        }else{\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：pop O(0), push O(1), inc O(k)\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303618337","body":"## 思路\n用栈实现类似计算器的操作\n\n## 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466540","body":"# 思路\r\n\r\n两个栈之间移动元素\r\n\r\n# 代码\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            int x = inStack.top();\r\n            outStack.push(x);\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n    \r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304990179","body":"# 思路\r\n基本思路：\r\n找到关键的 3 个点（断开部分的两个点 p1、p2、尾部节点 p3），利用穿针引线法连接。\r\n\r\n大致步骤：\r\n- 判断边界条件：当 K 为 0，链表长度为 0、1  时不需要旋转。\r\n- 求解移动长度：k = k % len。在这确定尾部节点，设置为 p3。\r\n- 设置快慢指针：让快指针先走 k 步。在这确定断开的两个点，设置为 p1 和 p2。\r\n- 将各个点相连，返回 p2。\r\n\r\n# 算法\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k == 0 || head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode *cur = head;\r\n        while(cur->next != nullptr){\r\n            len+=1;\r\n            cur = cur->next;\r\n        }\r\n        k = k % len;\r\n        if(k == 0){\r\n            return head;\r\n        }\r\n\r\n        ListNode *p1, *p2, *p3, *slow, *fast;\r\n        p3 = cur;\r\n\r\n        slow = head;\r\n        fast = head;\r\n        while(k-- > 0){\r\n            fast = fast->next;\r\n        }\r\n\r\n        while(fast->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        p1 = slow;\r\n        p2 = slow->next;\r\n\r\n        p3->next = head;\r\n        p1->next = nullptr;\r\n\r\n        return p2;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306496624","body":"## 思路\n基本思路：\n使用四点法交换节点。\n\n大致步骤：\n1. 判断边界条件进行打表。\n2. 设置 dummy 头。\n3. 使用 cur 指针遍历链表，每次移动两步。\n4. 在遍历过程中利用四点法不断交换节点。\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        \n        ListNode dummy;\n        dummy.next = head;\n        ListNode *p1, *p2, *p3, *p4, *cur = &dummy;\n        while(cur != nullptr && cur->next != nullptr && cur->next->next != nullptr){\n            p1 = cur;\n            p2 = cur->next;\n            p3 = cur->next->next;\n            p4 = cur->next->next->next;\n\n            p1->next = p3;\n            p3->next = p2;\n            p2->next = p4;\n\n            cur = cur->next->next;\n        }\n        return dummy.next;\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308177600","body":"类似 105. 从前序与中序遍历序列构造二叉树\n\n# 思路\n\n基本思路：\n每次构建一个节点。使用中间节点构建当前节点，使用左侧的节点构建左子树，使用右侧的节点构建右子树。\n\n大致流程：\n1. 将当前子树的序列作为参数。\n2. 根据子树序列的中值作为根节点。\n3. 以中值划分左右子树，递归构建左子树和右子树。\n\n# 代码\n\n```c++\nclass Solution {\nprivate:\n    deque<int> values;\n\npublic:\n    TreeNode* buildTree(int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode(values[mid]);\n        root->left = buildTree(left, mid-1);\n        root->right = buildTree(mid+1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        while(head != nullptr){\n            values.push_back(head->val);\n            head = head->next;\n        }\n        return buildTree(0, values.size() - 1);\n    }\n};\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309724960","body":"## 基本思路\n\n- 走到尽头见不到你，于是走你来时的路，等到相遇时才发现，你也走过我来时的路。\n\n\n\n## 大致步骤\n\n1. pA 和 pB 将两个链表都遍历一遍，但 pA 从 A 链表开始，pB 从 B 链表开始。当 pA 等于 pB 时，pA/pB 要么指向 NULL，要么指向同一个节点。\n2. pA 和 pB 同时进行遍历。\n3. 如果 pA 遍历完 A 链表，那么让 pA 在继续遍历 B 链表。\n4. 如果 pB 遍历完 B 链表，那么让 pB 在继续遍历 A 链表。\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA, *pB;\n        pA = headA;\n        pB = headB;\n\n        while(pA != pB){\n            if(pA == NULL){\n                pA = headB;\n            }else{\n                pA = pA->next;\n            }\n            if(pB == NULL){\n                pB = headA;\n            }else{\n                pB = pB->next;\n            }\n        }\n        return pA;\n    }\n};\n```\n\n\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311169395","body":"## 基本思路：\n\n简化模型，最后求得快慢指针相交点和链表相交点的关系 a=c+(n-1)(b+c)\n\n\n\n## 大致步骤：\n\n1. 打表。\n1. 使用 head 指针遍历链表，并设置快指针每次走两步。\n1. 如果没有环 head 会等于 NULL，否则会一直循环。\n1. 如果快慢指针移动到相交的地方， 定义 ptr 指针从链表头开始，直到慢指针和 ptr 指针重合，退出循环。\n1. 返回 head 指针。\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == NULL){\n            return NULL;\n        }\n\n        ListNode *fast, *ptr;\n        fast = ptr = head;\n\n        while(head != NULL){\n            head = head->next;\n            if(fast->next != NULL && fast->next->next != NULL){\n                fast = fast->next->next;\n            }else{\n                head = NULL;\n                break;\n            }\n\n            if(fast == head){\n                while(ptr != head){\n                    ptr = ptr->next;\n                    head = head->next;\n                }\n                break;\n            }\n        }\n\n        return head;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312295522","body":"## 基本思路：\n\n- get：哈希字典查找 O(1)。\n- put：将节点放入链表尾部 O(1)。\n\n\n\n## 大致步骤：\n\n1. put：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面（和 get 相同）。如果没有找到该节点，那么在最前面插入一个节点。如果超过容量，那么就从尾部删除一个节点。\n2. get：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面。\n\n\n\n## 代码：\n\n```c++\nstruct DNode{\n    int key, value;\n    DNode* prev;\n    DNode* next;\n    DNode(): key(0), value(0), prev(nullptr), next(nullptr){}\n    DNode(int k, int v): key(k), value(v), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DNode*> _cache;\n    DNode *_head;\n    DNode *_tail;\n    int _size;\n    int _capacity;\n\n    DNode* removeTail(){\n        DNode *node = _tail->prev;\n        removeNode(node);\n        return node;\n    }\n\n    void removeNode(DNode *node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addNodeToHead(DNode *node){\n        _head->next->prev = node;\n        node->next = _head->next;\n        _head->next = node;\n        node->prev = _head;\n    }\n\n    void moveToHead(DNode *node){\n        removeNode(node);\n        addNodeToHead(node);\n    }\n\npublic:\n    LRUCache(int capacity): _capacity(capacity), _size(0) {\n        _head = new DNode();\n        _tail = new DNode();\n        _head->next = _tail;\n        _tail->prev = _head;\n    }\n    \n    int get(int key) {\n        if(!_cache.count(key)){\n            return -1;\n        }\n        DNode *node = _cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        DNode *node, *removed;\n        if(!_cache.count(key)){\n            node = new DNode(key, value);\n            addNodeToHead(node);\n            _cache[key] = node;\n            _size+=1;\n            if(_size > _capacity){\n                removed = removeTail();\n                _cache.erase(removed->key);\n                _size--;\n                delete removed;\n            }\n        }else{\n            node = _cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：put=O(1)、get=O(1)\n- 空间复杂度：put=O(1)、get=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312591979","body":"## 基本思路：\n\n- 直接套层序遍历模版\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr){\n            return 0;\n        }\n        queue<TreeNode *> q;\n        TreeNode *node;\n        int step, size, i;\n        \n        step = 0;\n        q.push(root);\n        \n        while(!q.empty()){\n            size = q.size();\n            for(i=0; i<size; i++){\n                node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            step+=1;\n        }\n\n        return step;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1314695030","body":"## 基本思路：\r\n\r\n- 递归判断当前节点、左子树、右子树。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表，当 p 或 q 树有空节点。\r\n2. 当前节点、左子树、右子树都相同时，左右子树相同。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr || q == nullptr){\r\n            return p == q;\r\n        }\r\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(min(m, n))\r\n- 空间复杂度：O(min(m, n))","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314744258","body":"## 基本思路：\r\n\r\n- 「自顶向下」求子树和，「自底向上」算节点值。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。分别讨论：空节点、叶子节点。\r\n2. 求解下一个子树的 base 值。\r\n3. 将左子树和右子树的值相加，作为当前节点的值。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    int dfs(TreeNode* root, int pre){\r\n        if(root == nullptr){\r\n            return 0;\r\n        }\r\n        if(root->left == nullptr && root->right == nullptr){\r\n            return pre*10 + root->val;\r\n        }\r\n        \r\n\r\n        int cur = pre*10 + root->val;\r\n        return dfs(root->left, cur) + dfs(root->right, cur);\r\n    }\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316109310","body":"## 基本思路：\r\n\r\n- BFS 找到最底层最左侧的节点。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用层序遍历模版。\r\n2. 使用 flag 来判断是不是第一个节点，根据叶子节点判断是不是最底层。如果两个条件都满足，更新 ans。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode *> q;\r\n        q.push(root);\r\n        int size, i;\r\n        TreeNode *node;\r\n        int ans;\r\n        bool flag;\r\n\r\n        while(!q.empty()){\r\n            size = q.size();\r\n            flag = true;\r\n\r\n            for(i=0; i<size; i++){\r\n                node = q.front();\r\n                q.pop();\r\n\r\n                if(flag && node->left == nullptr && node->right == nullptr){\r\n                    ans = node->val;\r\n                    flag = false;\r\n                }\r\n                if(node->left != nullptr){\r\n                    q.push(node->left);\r\n                }\r\n                if(node->right != nullptr){\r\n                    q.push(node->right);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(2^h-1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318422465","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n- 序列化：\r\n  1. 使用前序遍历，将所有节点保存起来（包括空节点）。\r\n- 反序列化\r\n  1. 从左到右遍历序列。\r\n  2. 打表。如果当前元素为 None，则当前为空树。\r\n  3. 构建当前节点。\r\n  4. 递归构建左子树，递归构建右子树。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319431161","body":"## 基本思路：\r\n\r\n- 按照（列、行、节点值）进行排序。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历二叉树，保存所有节点。\r\n2. 按照（列、行、节点值）进行排序。\r\n3. 按照 col 分割，放到 ans 数组中。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    vector<tuple<int, int, int>> nodes;\r\n    void dfs(TreeNode* root, int col, int row){\r\n        if(root == nullptr){\r\n            return;\r\n        }\r\n        nodes.emplace_back(col, row, root->val);\r\n        dfs(root->left, col-1, row+1);\r\n        dfs(root->right, col+1, row+1);\r\n    }\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n\r\n        vector<vector<int>> ans;\r\n        int cur_row = INT_MIN;\r\n\r\n        for(const auto &[col, row, val]: nodes){\r\n            if(cur_row != col){\r\n                cur_row = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().emplace_back(val);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320667596","body":"## 基本思路：\r\n\r\n- 空间换时间\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用字典将遍历过的点都记录下来。\r\n2. 如果遇到合适的点，那么就直接退出循环并返回结果。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> res;\r\n        int i;\r\n        for(i=0; i<nums.size(); i++){\r\n            if(res.count(nums[i])){\r\n                break;\r\n            }\r\n            res[target - nums[i]] = i;\r\n        }\r\n        return vector<int>{res[nums[i]], i};\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321363203","body":"## 基本思路：\r\n\r\n- 利用堆获取前 k 个。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历数组，统计出现次数。\r\n1. 将数组存入小顶堆，然后维护小顶堆的大小为 k。\r\n1. 最后将小顶堆转换为数组返回。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    static bool cmp(const pair<int, int>& n, const pair<int, int>& m){\r\n        return n.second > m.second;\r\n    }\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for(const auto& num: nums){\r\n            occurrences[num]++;\r\n        }\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for(const auto &[num, count]: occurrences){\r\n            if(q.size() < k){\r\n                q.emplace(num, count);\r\n            }else{\r\n                if(q.top().second < count){\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            }\r\n        }\r\n\r\n        vector<int> ans;\r\n        while(!q.empty()){\r\n            ans.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(Nlogk)，哈希表记录的时间复杂度是 O(N)，每次堆操作需要 O(logk)，累计需要 O(Nlogk)。\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321406992","body":"## 基本思路：\r\n\r\n- 枚举+哈希表+求排列数。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 将所有节点设置为出发点。\r\n2. 求点到点的距离，并保存距离的个数。\r\n3. 求解排列数。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        unordered_map<int, int> count;\r\n        int distants, ans;\r\n        ans = 0;\r\n\r\n        for(const auto & point: points){\r\n            count.clear();\r\n            for(const auto & p: points){\r\n                if(p != point){\r\n                    distants = (point[0] - p[0]) * (point[0] - p[0]) + (point[1] - p[1]) * (point[1] - p[1]);\r\n                    count[distants]++;\r\n                }\r\n            }\r\n            for (auto &[_, m] : count) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n*n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323128794","body":"## 基本思路：\r\n\r\n- 滑动窗口+哈希集合\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 左指针 i 从 0 到 n-1，每次移动都删掉一个哈希集合中的元素。\r\n2. 右指针 rk 从 0 向右移动，直到发现重复字符。\r\n3. 保存最长子串的长度 rk - i。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int i, rk = 0, size=s.size(), ans = 0;\r\n        for(i=0; i<size; i++){\r\n            if(i>0){\r\n                occ.erase(s[i-1]);\r\n            }\r\n            while(rk<size && occ.count(s[rk]) == 0){\r\n                occ.insert(s[rk]);\r\n                rk++;\r\n            }\r\n            if(ans < rk-i){\r\n                ans = rk-i;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(k)，k 为最长子串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324935324","body":"```c++\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int totalLen = s.length();\r\n        int len = words[0].length();\r\n        int n = words.length;\r\n        if (n*totalLen == 0){\r\n            return result;\r\n        }\r\n        HashMap<String,Integer> wordMap = new HashMap<>();\r\n        for (String word:words) {\r\n            int value = wordMap.getOrDefault(word, 0);\r\n            wordMap.put(word,value+1);\r\n        }\r\n        \r\n        for (int i = 0; i <totalLen-n*len+1; i++) {\r\n          \r\n            Map<String,Integer> hasWords = new HashMap<>();\r\n            int num = 0;\r\n            while (num < n){\r\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\r\n                if (wordMap.containsKey(currWord)){\r\n                    int value = hasWords.getOrDefault(currWord,0);\r\n                    hasWords.put(currWord,value+1);\r\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n                num++;\r\n            }\r\n            if (num == n){\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328528952","body":"## 基本思路：\r\n\r\n- 快慢指针\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode *slow=head, *fast=head;\r\n        while(fast != nullptr && fast->next != nullptr){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328526240","body":"## 基本思路：\r\n\r\n- 双指针\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。\r\n2. 快慢指针都从第一个元素开始。\r\n3. 当 fast 小于 n 时，如果找到不相同的值改变 slow 位置的值并且移动 slow，每次 fast 都 +1。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if(n == 0){\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while(fast <= n-1){\r\n            if(nums[fast] != nums[fast-1]){\r\n                nums[slow++] = nums[fast]; \r\n            }\r\n            fast++;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328167354","body":"## 基本思路：\r\n\r\n- 二分查找\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义左指针和右指针。\r\n2. 当左指针小于或等于右指针时，根据中间值移动 l 或 r。\r\n3. 返回 l（如果等于，取左）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int size = nums.size();\r\n        int l = 0, r = size-1, mid;\r\n        while(l <= r){\r\n            mid = l + (r-l)/2;\r\n            if(nums[mid] < target){\r\n                l = mid+1;\r\n            }else{\r\n                r = mid-1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(log(n))\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330371642","body":"## 基本思路：\r\n\r\n- 计算各节点的入度和出度\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历所有节点，保存入度和出度。\r\n2. 遍历所有的居民（1, n），找出符合条件的居民（入度为 n-1，出度为 0）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegree(n+1);\r\n        vector<int> outDegree(n+1);\r\n        int i, size = trust.size();\r\n        for(i=0; i<size; i++){\r\n            outDegree[trust[i][0]]++;\r\n            inDegree[trust[i][1]]++;\r\n        }\r\n        for(i=1; i<n+1; i++){\r\n            if(inDegree[i] == n-1 && outDegree[i] == 0){\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n+m), m 是 Trust 的长度，n 是居民人数。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332042657","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n- 染色法\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义 color 数组存储每个人的颜色，定义 g 数组存储不能与某个人在一组的人。\r\n2. 遍历每个人，使用深度优先搜索检验是否分配到了不同的组。如果分配到了相同的组，则返回 false。\r\n3. 如果没有找到不符合规范的人，则返回 true。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\r\n        color[curnode] = nowcolor;\r\n        for (auto& nextnode : g[curnode]) {\r\n            if (color[nextnode] && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (!color[nextnode] && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        vector<int> color(n + 1, 0);\r\n        vector<vector<int>> g(n + 1);\r\n        for (auto& p : dislikes) {\r\n            g[p[0]].push_back(p[1]);\r\n            g[p[1]].push_back(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(m+n), n 是题目中给定的人数，m 为给定的 dislike 数组的大小。\r\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333284225","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n\r\n        // 组间和组内依赖图\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        // 组间和组内入度数组\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        // 给未分配的 item 分配一个 groupId\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        // 依赖关系建图\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 组间拓扑关系排序\r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        // 组内拓扑关系排序\r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336098381","body":"## 基本思路：\r\n\r\n- 模拟\r\n- 堆\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 对 task 进行排序，并将下标存入 indices 数组。\r\n1. 遍历 indices 数组，每次处理一个任务，并更新时间戳。如果没有任务处理，就根据 ptr 来更新时间戳，并将任务放入优先队列中。\r\n1. 返回 ans 数组。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    using PII = pair<int, int>;\r\n    using LL = long long;\r\n\r\npublic:\r\n    vector<int> getOrder(vector<vector<int>>& tasks) {\r\n        int n = tasks.size();\r\n        vector<int> indices(n);\r\n        iota(indices.begin(), indices.end(), 0);\r\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\r\n            return tasks[i][0] < tasks[j][0];\r\n        });\r\n\r\n        vector<int> ans;\r\n        // 优先队列\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\r\n        // 时间戳\r\n        LL timestamp = 0;\r\n        // 数组上遍历的指针\r\n        int ptr = 0;\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            // 如果没有可以执行的任务，直接快进\r\n            if (q.empty()) {\r\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\r\n            }\r\n            // 将所有小于等于时间戳的任务放入优先队列\r\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\r\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\r\n                ++ptr;\r\n            }\r\n            // 选择处理时间最小的任务\r\n            auto&& [process, index] = q.top();\r\n            timestamp += process;\r\n            ans.push_back(index);\r\n            q.pop();\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336372084","body":"## 基本思路：\r\n\r\n- 模拟\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 将开始时间和结束时间转换为分钟。\r\n2. 分析是否通宵。\r\n3. 计算开始时间的上一次比赛的结束时间。\r\n4. 计算完成的对局数。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfRounds(string loginTime, string logoutTime) {\r\n        int t0 = 60 * stoi(loginTime.substr(0, 2))+stoi(loginTime.substr(3, 5));\r\n        int t1 = 60 * stoi(logoutTime.substr(0, 2))+stoi(logoutTime.substr(3, 5));\r\n        if(t1 < t0){\r\n            t1 = t1 + 24 * 60;\r\n        }\r\n        t1 = t1 / 15 * 15;\r\n        return (t1-t0)/15;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339085391","body":"## 基本思路：\r\n\r\n- 归并排序\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. resize 临时数组。\r\n2. 调用归并排序。\r\n   1. 打表。当 l >= r 返回。\r\n   2. 递归对左半和右半进行排序。\r\n   3. 对合并已经排序的左半和右半，合并到 tmp 数组中。\r\n   4. 然后将 tmp 中的数据移动到 nums 数组中。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\n    vector<int> tmp;\r\n    void mergeSort(vector<int>& nums, int l, int r) {\r\n        if (l >= r) return;\r\n        int mid = (l + r) >> 1;\r\n        mergeSort(nums, l, mid);\r\n        mergeSort(nums, mid + 1, r);\r\n        int i = l, j = mid + 1;\r\n        int cnt = 0;\r\n        while (i <= mid && j <= r) {\r\n            if (nums[i] <= nums[j]) {\r\n                tmp[cnt++] = nums[i++];\r\n            }\r\n            else {\r\n                tmp[cnt++] = nums[j++];\r\n            }\r\n        }\r\n        while (i <= mid) {\r\n            tmp[cnt++] = nums[i++];\r\n        }\r\n        while (j <= r) {\r\n            tmp[cnt++] = nums[j++];\r\n        }\r\n        for (int i = 0; i < r - l + 1; ++i) {\r\n            nums[i + l] = tmp[i];\r\n        }\r\n    }\r\npublic:\r\n    vector<int> sortArray(vector<int>& nums) {\r\n        tmp.resize((int)nums.size(), 0);\r\n        mergeSort(nums, 0, (int)nums.size() - 1);\r\n        return nums;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341919386","body":"## 基本思路：\r\n\r\n- 二分\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 当 left 小于等于 right。\r\n1. 如果 mid 版本是错误的，那么 right 往左移动到 mid-1，否则 left 向右移动到 mid+1；\r\n1. 返回 left。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int left = 1, right = n;\r\n        while(left <= right){\r\n            int mid = left + (right - left)/2;\r\n            if(isBadVersion(mid)){\r\n                right = mid-1;\r\n            }else{\r\n                left = mid+1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348629449","body":"## 基本思路：\r\n\r\n- 滑动窗口\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 初始化 Windows 的值。\r\n2. 从做往右移动，在移动过程中不断计算 value 并更新 ans。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; \r\n    }\r\n\r\n    int init_window_value(const string &s, int k){\r\n        int count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            count += isVowel(s[i]);\r\n        }\r\n        return count;\r\n    }\r\n\r\n    int move_windows(const string &s, int value, int left_index, int right_index){\r\n        return value - isVowel(s[left_index]) + isVowel(s[right_index]) ;   \r\n    }\r\n    \r\n    int maxVowels(string s, int k) {\r\n        int n = s.size();\r\n        int count = init_window_value(s, k);\r\n        int ans = count;\r\n        for (int i = k; i < n; ++i) {\r\n            count = move_windows(s, count, i-k, i);\r\n            ans = max(ans, count);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(s)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1356560650","body":"## 基本思路：\r\n\r\n- 滑动窗口\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表\r\n2. 初始化窗口。\r\n3. 移动窗口。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    int sLen;\r\n    int pLen;\r\n    void initCount(string &s, string &p, vector<int> &sCount, vector<int> &pCount){\r\n        for(int i=0; i<pLen; i++){\r\n            sCount[s[i] - 'a']++;\r\n            pCount[p[i] - 'a']++;\r\n        }\r\n    }\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        sLen = s.size();\r\n        pLen = p.size();\r\n        if(sLen < pLen){\r\n            return vector<int>();\r\n        }\r\n\r\n        vector<int> ans;\r\n        vector<int> sCount(26);\r\n        vector<int> pCount(26);\r\n        initCount(s, p, sCount, pCount);\r\n\r\n        if(sCount == pCount){\r\n            ans.emplace_back(0);\r\n        }\r\n        for(int i=0; i<sLen-pLen; i++){\r\n            sCount[s[i] - 'a']--;\r\n            sCount[s[i+pLen] - 'a']++;\r\n\r\n            if(sCount == pCount){\r\n                ans.emplace_back(i+1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356826131","body":"## 基本思路：\r\n\r\n- 回溯\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. \r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nenum Led{\r\n    MinLed,\r\n    HourLed\r\n};\r\n\r\nclass Solution {\r\nprivate:\r\n    vector<string> res;\r\n    vector<int> mins;\r\n\r\n    void dfs(int st, int sum, int cnt, Led led){\r\n        if(cnt == 0){\r\n            if(led == MinLed){\r\n                mins.emplace_back(sum);\r\n            }else{\r\n                if(!mins.empty()){\r\n                    for(int m: mins){\r\n                        char time[6];\r\n                        sprintf(time, \"%d:%02d\", sum, m);\r\n                        res.emplace_back(string{ time });\r\n                    }\r\n                }\r\n            }\r\n            return;\r\n        }\r\n\r\n        int ledNum = led == MinLed?6: 4;\r\n        for(int i=st; i<ledNum; i++ ){\r\n            int tmp = pow(2, i);\r\n            if(led == MinLed && sum + tmp >= 60 || led == HourLed && sum+tmp >= 12){\r\n                break;\r\n            }\r\n            dfs(i+1, sum+tmp, cnt-1, led);\r\n        }\r\n\r\n    }\r\npublic:\r\n    vector<string> readBinaryWatch(int onNum) {\r\n        for(int i=0; i<6 && onNum >= i; i++){\r\n            dfs(0, 0, i, MinLed);\r\n            dfs(0, 0, onNum-i, HourLed);\r\n\r\n            mins.clear();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：\r\n- 空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357737583","body":"```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int totalNQueens(int n) {\r\n        unordered_set<int> columns, diagonals1, diagonals2;\r\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\r\n    }\r\n\r\n    int backtrack(int n, int row, unordered_set<int>& columns, unordered_set<int>& diagonals1, unordered_set<int>& diagonals2) {\r\n        if (row == n) {\r\n            return 1;\r\n        }\r\n\r\n        int count = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (columns.find(i) != columns.end()) {\r\n                continue;\r\n            }\r\n            int diagonal1 = row - i;\r\n            if (diagonals1.find(diagonal1) != diagonals1.end()) {\r\n                continue;\r\n            }\r\n            int diagonal2 = row + i;\r\n            if (diagonals2.find(diagonal2) != diagonals2.end()) {\r\n                continue;\r\n            }\r\n            columns.insert(i);\r\n            diagonals1.insert(diagonal1);\r\n            diagonals2.insert(diagonal2);\r\n            count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\r\n            columns.erase(i);\r\n            diagonals1.erase(diagonal1);\r\n            diagonals2.erase(diagonal2);\r\n        }\r\n        return count;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359225511","body":"```c++\r\nstruct Point{\r\n    int x;\r\n    int y;\r\n    Point(int x, int y): x(x), y(y) {}\r\n};\r\nint MATRIX_X[4] = {0, 0, 1, -1};\r\nint MATRIX_Y[4] = {1, -1, 0, 0};\r\n\r\nclass Solution {\r\nprivate:\r\n    bool is_land(const vector<vector<int>> &grid, const Point &point){\r\n        return grid[point.x][point.y] == 1;\r\n    }\r\n\r\n    bool is_in_grid(const vector<vector<int>> &grid, const Point &point){\r\n        return point.x >= 0 && point.y >= 0 && point.x < grid.size() && point.y < grid[0].size();\r\n    }\r\n\r\n    void add_around_point_to_queue(const vector<vector<int>> &grid, Point &point, queue<Point> &q){\r\n        int x, y;\r\n        for (int index = 0; index != 4; ++index) {\r\n            int x = point.x + MATRIX_X[index];\r\n            int y = point.y + MATRIX_Y[index];\r\n            q.push(Point(x, y));\r\n        }\r\n    }\r\n\r\n    int bfs(vector<vector<int>> &grid, Point &startPoint){\r\n        queue<Point> q;\r\n        q.push(startPoint);\r\n\r\n        int area = 0;\r\n        while (!q.empty()) {\r\n            Point point = q.front();\r\n            q.pop();\r\n\r\n            if (is_in_grid(grid, point) && is_land(grid, point)){\r\n                grid[point.x][point.y] = 0;\r\n                add_around_point_to_queue(grid, point, q);\r\n                area++;\r\n            }\r\n        }\r\n        return area; \r\n    }\r\n    \r\npublic:\r\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int ans = 0;\r\n        int cur;\r\n        for (int x = 0; x != grid.size(); x++) {\r\n            for (int y = 0; y != grid[0].size(); y++) {\r\n                Point point = Point(x, y);\r\n                cur = bfs(grid, point);\r\n                ans = max(ans, cur);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361237557","body":"```c++\r\n\r\n// BFS：超时\r\nint MATRIX_X[] = {1, 0, -1, 0};\r\nint MATRIX_Y[] = {0, -1, 0, 1};\r\nconst int MATRIX_LEN = 4;\r\nconst int MAX_N = 100 + 5;\r\n\r\nstruct Point{\r\n    int x;\r\n    int y;\r\n    int len;\r\n    Point(int x, int y, int len): x(x), y(y), len(len) {}\r\n};\r\n\r\nbool visited[MAX_N][MAX_N];\r\n\r\n#define ADD_ACCESS_FLAG(point) visited[point.x][point.y] = true\r\n#define INIT_VISITED(value) memset(visited, value, sizeof(visited))\r\n#define HAS_VISITED(point) visited[point.x][point.y] == true\r\n\r\nclass Solution {\r\nprivate:\r\n    static bool is_in_grid(const vector<vector<int>> &grid, Point point){\r\n        return point.x >= 0 && point.y >=0 && point.x < grid.size() && point.y < grid[0].size();\r\n    }\r\n\r\n    static bool is_ocean(const vector<vector<int>> &grid, Point point){\r\n        return grid[point.x][point.y] == 0;\r\n    }\r\n\r\n    void add_around_point_to_queue(queue<Point> &q, Point point, const vector<vector<int>> &grid){\r\n        for(int i=0; i<MATRIX_LEN; i++){\r\n            Point nextPoint = Point(point.x + MATRIX_X[i], point.y + MATRIX_Y[i], point.len + 1);\r\n            if(is_in_grid(grid, nextPoint) && !HAS_VISITED(nextPoint)){\r\n                ADD_ACCESS_FLAG(nextPoint);\r\n                q.push(nextPoint);\r\n            }\r\n        }\r\n    }\r\n\r\n    int bfs(vector<vector<int>> &grid, Point startPoint){\r\n        INIT_VISITED(0);\r\n        ADD_ACCESS_FLAG(startPoint);\r\n        queue<Point> q;\r\n        q.push(startPoint);\r\n        int ans=-1;\r\n\r\n        while(!q.empty()){\r\n            Point point = q.front();\r\n            q.pop();\r\n\r\n            if(!is_in_grid(grid, point)){\r\n                continue;\r\n            }\r\n\r\n            if(is_ocean(grid, point)){\r\n                add_around_point_to_queue(q, point, grid);\r\n            }else{\r\n                ans = point.len;\r\n                break;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\npublic:\r\n    int maxDistance(vector<vector<int>>& grid) {\r\n        int size = grid.size();\r\n        int x, y;\r\n        int ans=-1;\r\n\r\n        for(x=0; x<size; x++){\r\n            for(y=0; y<size; y++){\r\n                Point point = Point(x, y, 0);\r\n                \r\n                if(is_ocean(grid, point)){\r\n                    int len = bfs(grid, point);\r\n                    if(len > ans){\r\n                        ans = len;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1365148630","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int minCostClimbingStairs(vector<int>& cost) {\r\n        int size = cost.size();\r\n        vector<int> spend(size+1, 0);\r\n        int minCost;\r\n\r\n        spend[0] = spend[1] = 0;        \r\n        for(int index=2; index < size+1; index++){\r\n            spend[index] = min(spend[index - 1] + cost[index - 1], spend[index - 2] + cost[index - 2]);\r\n        }\r\n\r\n        return spend[size];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1365179995","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int rob(vector<int>& nums) {\r\n        int size = nums.size();\r\n        if (size == 1) {\r\n            return nums[0];\r\n        }\r\n        \r\n        vector<int> count = vector<int>(size, 0);\r\n        count[0] = nums[0];\r\n        count[1] = max(nums[0], nums[1]);\r\n\r\n        for (int i = 2; i < size; i++) {\r\n            count[i] = max(count[i - 2] + nums[i], count[i - 1]);\r\n        }\r\n        return count[size - 1];\r\n    }\r\n};\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365140302","body":"# 思路\r\n\r\n用每个数和前面的数对比，如果前面的数小于当前数，那么就尝试更新数组。\r\n\r\n更新数组的条件：\r\n- 长度不变：数量+1 就行。\r\n- 长度改变：改变长度，并重置数量。\r\n\r\n# 代码\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    void updateNum(int curLen,  int curLenNum, int &len, int &num){\r\n        if (curLen == len) {\r\n            num += curLenNum;\r\n        }\r\n    }\r\n\r\n    void resetLenAndNum(int curLen, int curLenNum, int &len, int &num){\r\n        if (curLen > len) {\r\n            len = curLen;\r\n            num = curLenNum; \r\n        }\r\n    }\r\npublic:\r\n    int findNumberOfLIS(vector<int> &nums) {\r\n        int size = nums.size();\r\n        vector<int> lenArr(size, 1), numArr(size, 1);\r\n        int maxLen = 0, maxLenNum = 0;\r\n\r\n        for (int endIndex = 0; endIndex < size; ++endIndex) {\r\n            for (int index = 0; index < endIndex; ++index) {\r\n                if (nums[endIndex] > nums[index]) {\r\n                    updateNum(lenArr[index] + 1, numArr[index],  lenArr[endIndex], numArr[endIndex]);\r\n                    resetLenAndNum(lenArr[index] + 1, numArr[index],  lenArr[endIndex], numArr[endIndex]);\r\n                }\r\n            }\r\n            updateNum(lenArr[endIndex], numArr[endIndex], maxLen, maxLenNum);\r\n            resetLenAndNum(lenArr[endIndex], numArr[endIndex], maxLen, maxLenNum);\r\n        }\r\n        return maxLenNum;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1366385340","body":"# 思路：动态规划\r\n\r\n在 text1 取长度为 i 的字符串，在 text2 取长度为 j 的字符串，并记录下他们的子串长度。每次改变一个字符，可以通过前面记录过的子串长度来推导。\r\n- 如果最后一个字符相同：新的子串长度等于 lens[i-1][j-1] + 1。\r\n- 如果最后一个字符不同：新的子串长度等于 max(lens[i-1][j], lens[i][j-1])\r\n\r\n# 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int longestCommonSubsequence(string text1, string text2) {\r\n        int len1 = text1.length(), len2 = text2.length();\r\n        vector<vector<int>> lens(len1 + 1, vector<int>(len2 + 1));\r\n\r\n        for (int i = 1; i <= len1; i++) {\r\n            for (int j = 1; j <= len2; j++) {\r\n                if (text1[i - 1] == text2[j - 1]) {\r\n                    lens[i][j] = lens[i - 1][j - 1] + 1;\r\n                } else {\r\n                    lens[i][j] = max(lens[i - 1][j], lens[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return lens[len1][len2];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366389708","body":"# 思路：动态规划\r\n\r\n(i, j) 的路径数 = (i-1, j) + (i, j-1)\r\n\r\n# 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int uniquePaths(int m, int n) {\r\n        vector<vector<int>> dp(m, vector<int>(n, 1));\r\n        for(int i=1; i<m; i++){\r\n            for(int j=1; j<n; j++){\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            }\r\n        }\r\n        return dp[m-1][n-1];\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300705109","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int leng = s.length();\r\n        int[] ans = new int[leng];\r\n        for (int i=0, flag=-leng; i<leng; ++i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = i - flag;\r\n        }\r\n        for (int i=leng-1, flag=2*leng; i>=0; --i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = Math.min(ans[i], flag-i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304547233","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> sIn;\r\n    Deque<Integer> sOut;\r\n\r\n    public MyQueue() {\r\n        sIn = new ArrayDeque<Integer>();\r\n        sOut = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        sIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (sIn.isEmpty() && sOut.isEmpty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!sIn.isEmpty()) {\r\n            int x = sIn.pop();\r\n            sOut.push(x);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304705799","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> numbers = new ArrayDeque<>();\r\n        for (int i=0; i<arr.length; i++) {\r\n            if (numbers.isEmpty() || numbers.peek() <= arr[i]) {\r\n                numbers.push(arr[i]);\r\n            } else {\r\n                int val = numbers.pop();\r\n                while (!numbers.isEmpty() && numbers.peek() > arr[i]) {\r\n                    numbers.pop();\r\n                }\r\n                numbers.push(val);\r\n            }\r\n        }\r\n        return numbers.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n其中 N 为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305793408","body":"```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if (not head) or (not head.next):\r\n            return head\r\n        cnt = 0\r\n        p = head\r\n        while p:\r\n            cnt += 1\r\n            p = p.next\r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        p = head\r\n        for i in range(cnt-k-1):\r\n            p = p.next\r\n        mark_tail = p\r\n        p = p.next\r\n        mark_tail.next = None\r\n        new_head = p\r\n        while p.next != None:\r\n            p = p.next\r\n        p.next = head\r\n        return new_head\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312759784","body":"递归\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315506045","body":"```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        return dfs(root, 0);\r\n    }\r\n\r\n    public int dfs(TreeNode root, int prevSum) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int sum = prevSum * 10 + root.val;\r\n        if (root.left == null && root.right == null) {\r\n            return sum;\r\n        } else {\r\n            return dfs(root.left, sum) + dfs(root.right, sum);\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323682277","body":"```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        if not s:\r\n            return 0\r\n        l = [0]\r\n        for i in range(1, len(s)):\r\n            pres = s[l[i-1]:i]\r\n            if s[i] not in pres:\r\n                l.append(l[i-1])\r\n            else:\r\n                l.append(l[i-1] + pres.index(s[i]) + 1)\r\n        return max([i-v+1 for i, v in enumerate(l)])\r\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328263837","body":"```java\r\nclass Solution {\r\n    public int searchInsert(int[] nums, int target) {\r\n        int n = nums.length;\r\n        int left = 0, right = n - 1, ans = n;\r\n        while (left<=right) {\r\n            int mid = (left + right) >> 1;\r\n            if (nums[mid] < target) {\r\n                left = mid + 1;\r\n            } else {\r\n                right = mid - 1;\r\n                ans = mid;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332141770","body":"```java\r\nclass Solution {\r\n    public boolean possibleBipartition(int n, int[][] dislikes) {\r\n        int[] color = new int[n + 1];\r\n        List<Integer>[] g = new List[n + 1];\r\n        for (int i = 0; i <= n; ++i) {\r\n            g[i] = new ArrayList<Integer>();\r\n        }\r\n        for (int[] p : dislikes) {  // 建立依赖\r\n            g[p[0]].add(p[1]);\r\n            g[p[1]].add(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {  // 未染色，不能染上第一种颜色\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public boolean dfs(int curnode, int nowcolor, int[] color, List<Integer>[] g) {\r\n        color[curnode] = nowcolor;\r\n        for (int nextnode : g[curnode]) {\r\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {  // 已染色，色同\r\n                return false;\r\n            }\r\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {  // 未染色，不能染上另一色 3^1=2 3^2=1\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339249908","body":"```python\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        def guibing(l, r):\r\n            if l == r:\r\n                return\r\n            m = (l+r) // 2\r\n            guibing(l, m)\r\n            guibing(m+1, r)\r\n            i, j = l, m+1\r\n            ans = []\r\n            while True:\r\n                if nums[i] <= nums[j]:\r\n                    ans.append(nums[i])\r\n                    i += 1\r\n                    if i == m + 1:\r\n                        ans += nums[j:r+1]\r\n                        break\r\n                else:\r\n                    ans.append(nums[j])\r\n                    j += 1\r\n                    if j == r + 1:\r\n                        ans += nums[i:m+1]\r\n                        break\r\n            nums[l:r+1] = ans\r\n\r\n\r\n        guibing(0, len(nums)-1)\r\n        return nums\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298865077","body":"# 思路 \r\n- List 的长度和 k的长度谁大谁小\r\n- 逐位相加 (Two Number Add)\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int p1 = num.length - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n        int a = 0;\r\n        int b = 0;\r\n\r\n        while(p1 >= 0 || k != 0){\r\n            a = p1 >= 0 ? num[p1] : 0;\r\n            b = k != 0 ? (k % 10) : 0;\r\n                \r\n            sum = a + b + carry;\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            \r\n            p1--;\r\n            res.add(0, sum % 10);\r\n        }\r\n\r\n        if(carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n\r\n// Time Complexity: O(n) \r\n// Space Complexity: O(n)\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301181920","body":"class CustomStack {\r\n    \r\n    private int[] arr;\r\n    private int   curr = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (curr+1 < arr.length) {\r\n            arr[++curr] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return curr < 0 ? curr : arr[curr--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369373658","body":"int change(int amount, int[] coins) {\r\n    int n = coins.length;\r\n    int[] dp = new int[amount + 1];\r\n    dp[0] = 1; \r\n    for (int i = 0; i < n; i++)\r\n        for (int j = 1; j <= amount; j++)\r\n            if (j - coins[i] >= 0)\r\n                dp[j] = dp[j] + dp[j-coins[i]];\r\n    \r\n    return dp[amount];\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301632698","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n \n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, len(self.stack))):\n            self.stack[i] += val","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304682841","body":"/**\r\n    思路: 维护一个单调递增的stack\r\n    TC: O(N), SC: O(N)\r\n*/\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n          stack = []\r\n          for num in arr:\r\n              if not stack or num >= stack[-1]:\r\n                  stack.append(num)\r\n              else:\r\n                  pop_num = stack.pop()\r\n                  while stack and stack[-1] > num:\r\n                      stack.pop()\r\n                  stack.append(pop_num)\r\n          return len(stack)\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312142028","body":"思路:\r\n这是一个经常常考叠加design的题。主要还是根据要求的几个function进行分别设计。我是运用了ordereddict这么一个已有结构进行设计。实质上还是哈希。\r\n\r\n```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n     \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self)> self.capacity:\r\n            self.popitem(last = False)\r\n```\r\n\r\n复杂度：\r\nTC: O(1)\r\nSC: O(n)    ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327998932","body":"思路：\r\n类似于快慢指针。只有不同时才copy后一个数字给前一位，并且更新左指针。 不然就一直挪动后一位。那么结果就是左指针的index。\r\n\r\n```\r\nclass Solution:\r\n    def removeDuplicates(self, nums: List[int]) -> int:\r\n        len_ = 1\r\n        if len(nums)==0:\r\n            return 0\r\n        for i in range(1,len(nums)):\r\n            if nums[i] != nums[i-1]:\r\n                nums[len_] = nums[i]\r\n                len_ +=1\r\n        return len_\r\n```\r\n\r\nTC:  O(n)\r\nSC: O(1）不需要额外空间储存。只需要更新左指针的index","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334784324","body":"思路:  x是水平移动，y是上下移动\n```\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0\n```\nTC O(n) \nSC O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342151260","body":"典型的二分法\r\n```\r\n# The isBadVersion API is already defined for you.\r\n# def isBadVersion(version: int) -> bool:\r\n\r\nclass Solution:\r\n    def firstBadVersion(self, n: int) -> int:\r\n        left = 0\r\n        right = n\r\n        while left <= right:\r\n            mid = left + (right - left) // 2\r\n            if isBadVersion(mid):\r\n                right = mid -1\r\n            else:\r\n                left = mid + 1\r\n        return left\r\n```\r\nTC O(logn)\r\nSC O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347861501","body":"典型的滑动窗口问题。 窗口 = k。如果大于k则收缩left pointer，在收缩left pointer时注意检查是否元音，如果是，则需要扣除。最后更新result。保持最大result。\n```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        vowels = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n        result = 0\n        vowel = 0\n        left = 0\n        right = 0\n        while right < len(s):\n            if s[right] in vowels:\n                vowel += 1\n            if right - left + 1 > k:\n                if s[left] in vowels:\n                    vowel -= 1\n                left += 1\n            result = max(result, vowel)\n            right += 1\n        return result\n```\n\nTC : O(n)\nSC :O(1)\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1356892368","body":"先定义一个helper function 检查该点是否符合条件（查找左上，右上，和列），不需要查找row，因为后续会简化用row来控制搜索进程。\n最后用回溯方法检查每一个点是否符合条件，如果符合，则放入Q\n```\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        self.res = 0\n        board = [[\".\"] * n for i in range(n)]\n        def isValid(board, row, col):\n            #check column\n            for i in range(len(board)):\n                if board[i][col] == \"Q\":\n                    return False\n            \n            #check left corner\n            i = row -1\n            j = col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j -= 1\n            \n            #check right corner\n            i = row - 1\n            j = col + 1\n            while i >= 0 and j < len(board):\n                if board[i][j] == \"Q\":\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row, n):\n            if row == n:\n                self.res += 1\n            for col in range(n):\n                if not isValid(board, row, col):\n                    continue\n                board[row][col] = \"Q\"\n                backtrack(board, row+1, n)\n                board[row][col] = \".\"\n        backtrack(board, 0, n)\n        return self.res\n      ```\nTC O(N!)\nSCO(N)","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364888186","body":"```\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return len(nums)\n        dp = [1] * len(nums)\n        count = [1] * len(nums)\n        res = 0\n        max_length = 0\n        for i in range(1, len(nums)):\n            for j in range(0, i):\n                if nums[i] > nums[j]:\n                    if dp[i] < dp[j] +1:\n                        dp[i] = dp[j] + 1\n                        count[i] = count[j]\n                    elif dp[i] == dp[j] + 1:\n                        count[i] += count[j]\n            max_length = max(max_length, dp[i])\n        \n        for i in range(len(nums)):\n            if max_length == dp[i]:\n                res += count[i]\n        return res\n```   ","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368662556","body":"```\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount+1] *(amount+1)\n        dp[0] = 0\n        for i in range(len(coins)):\n            for j in range(coins[i], amount+1):\n                dp[j] = min(dp[j], dp[j-coins[i]]+1)\n        if dp[amount] < amount+1:\n            return dp[amount]\n        else:\n            return -1\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1374973418","body":"```\nclass Solution:\n    def beautifulArray(self, N):\n        memo = {1: [1]}\n        def f(N):\n            if N not in memo:\n                odds = f((N+1)/2)\n                evens = f(N/2)\n                memo[N] = [2*x-1 for x in odds] + [2*x for x in evens]\n            return memo[N]\n        return f(N)\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1382871434","body":"```\nclass Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        #bfs\n        res = 0\n        n = len(isConnected)\n        visited =[0] * n\n        que = deque()\n        for i in range(n):\n            if visited[i] == 0:\n                que.append(i)\n                visited[i] = 1\n                res += 1\n                while que:\n                    c = que.popleft()\n                    for j in range(n):\n                        if isConnected[c][j] == 1 and visited[j] == 0:\n                            visited[j] = 1\n                            que.append(j)\n        return res\n ```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302262952","body":"```java\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n学习一下","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302840545","body":"```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304548436","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<Integer>();\r\n        outStack = new ArrayDeque<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304817122","body":"```java\r\npublic class Solution {\r\n\r\n     public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0;\r\n        int nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i];\r\n            int y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) {\r\n                nonzero--;\r\n            }\r\n            if (count.get(x) == 1) {\r\n                nonzero++;\r\n            }\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) {\r\n                nonzero++;\r\n            }\r\n            if (count.get(y) == 0) {\r\n                nonzero--;\r\n            }\r\n\r\n            if (nonzero == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305148682","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315342382","body":"```java\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        int sum = 0;\r\n\r\n        while (!queue.isEmpty()) {\r\n            int size = queue.size();\r\n            for (int i = 0; i < size; i++) {\r\n                TreeNode cur = queue.poll();\r\n\r\n                if (cur.left == null && cur.right == null) {\r\n                    sum = sum + cur.val;\r\n                }\r\n\r\n                if (cur.left != null) {\r\n                    cur.left.val = cur.val * 10 + cur.left.val;\r\n                    queue.offer(cur.left);\r\n                }\r\n\r\n                if (cur.right != null) {\r\n                    cur.right.val = cur.val * 10 + cur.right.val;\r\n                    queue.offer(cur.right);\r\n                }\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302322956","body":"```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const n = num.length;\r\n    let carry = 0;\r\n    let res = 0;\r\n    let i = n-1;\r\n    let arr = [];\r\n    while(i>=0 || k!=0) {\r\n        const a = i>=0 ? num[i] : 0\r\n        const b = k!=0 ? k%10 : 0;\r\n        res = a+b+carry;\r\n        arr.push(res%10)\r\n        carry = Math.floor(res/10) \r\n\r\n        i--;\r\n        k=Math.floor(k/10);\r\n    }\r\n\r\n\r\n    if(carry) {\r\n        arr.push(carry)\r\n    }\r\n    arr.reverse()\r\n    return arr\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302326047","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let n = s.length;\r\n    let resArr = new Array(n).fill(0);\r\n    for(let i=0, cIndex=-n; i<n; i++){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = i-cIndex;\r\n    }\r\n\r\n    for(let i=n-1, cIndex=2*n; i>=0; i--){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = Math.min( resArr[i], cIndex - i);\r\n    }\r\n  \r\n    return resArr\r\n};\r\n```","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305592578","body":"### 代码\n```javasscript\nvar rotateRight = function(head, k) {\n    // 只有一位直接返回\n    if(!head || !head.next) return head; \n    // 求链表长度\n    let len = 0,now = head;\n    while(now){\n        now = now.next;\n        len++;\n    }\n    // 当k大于链表长度则取余\n    k = k % len;\n    // 快慢指针\n    let slow = (fast = head);\n    while(fast.next){\n        if(k-- <= 0){\n            slow = slow.next;\n        }\n        fast = fast.next;\n    }\n    fast.next = head;\n    let res = slow.next;\n    slow.next = null;\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307193677","body":"### 代码\n```javascript\nvar swapPairs = function(head) {\n    while(head == null || head.next === null) {\n        return head\n    }\n\n    const newHead = head.next;\n    head.next = swapPairs(newHead.next);\n    newHead.next = head\n    return newHead\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313789900","body":"### 思路\n深度遍历\n终止条件\n1. 两个都是null true\n2. 其中一个为null false\n3. 相同位置值不相等 false\n\n### 代码\n```javascript\nvar isSameTree = function(p, q) {\n    if(p===null && q===null) {\n        return true\n    }\n    if(p===null || q===null) {\n        return false\n    }\n    if(p.val !== q.val ) {\n        return false\n    }\n\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right)\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315338979","body":"### 思路\n深度优先搜索 \n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。如果当前节点不是叶子节点，对其子节点递归遍历，求其子节点对应的数据\n### 代码\n```javascript\nvar sumNumbers = function(root) {\n    return dfs(root,0)\n};\n\nconst dfs = (root, preNvm) => {\n    if (root == null){\n       return 0;\n    }\n    let sum = preNvm * 10 + root.val;\n    if (root.left == null && root.right == null) {\n        return sum\n    } else {\n        return dfs(root.left,sum) + dfs(root.right,sum)\n    } \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317124078","body":"### 思路\n深度优先搜索\n先遍历左子树，然后遍历右子树。遍历的过程中记下深度\n### 代码\n```javascript\nvar findBottomLeftValue = function(root) {\n    const dfs = (root, height) => {\n        if(root == null) {\n            return\n        }\n        height++\n        dfs(root.left,height)\n        dfs(root.right,height)\n        if(height > curHeight) {\n            curHeight = height\n            curVal = root.val\n        }\n    }\n    let curHeight = 0;\n    dfs(root, 0)\n    return curVal\n};\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321088426","body":"### 思路\n哈希表存储每个值的个数，然后对每个值的个数进行排序，取k个，并返回\n### 代码\n```javascript\nvar topKFrequent = function(nums, k) {\n  var map = new Map()\n  var len = nums.length\n  for (var i = 0; i < len; i++) {\n    map.set(nums[i], (map.get(nums[i]) || 0) + 1)\n  }\n  return [...map]\n    .sort((a, b) => b[1] - a[1])\n    .filter((v, i) => i < k)\n    .map(v => v[0])\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302485327","body":"'''\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = ''\r\n        stack = []\r\n        cur_num = 0\r\n        \r\n        for i in range(len(s)):\r\n            if s[i].isdigit():\r\n                cur_num = cur_num*10 + int(s[i])\r\n            elif s[i] == '[':\r\n                stack.append((ans,cur_num))\r\n                ans = ''\r\n                cur_num = 0\r\n                \r\n            elif s[i] == ']':\r\n                cur_str, n = stack.pop()\r\n                ans = cur_str + ans *n\r\n            else:\r\n                ans += s[i]\r\n        return ans\r\n'''\r\nO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304641977","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        #chunk in previous chunk should small than nums in following chunk\n        lowest_right = [-1 for i in range(len(arr))] #each pos store the lowest value on right side\n        maxnum = float('inf')\n        #update to each pos store the lowest value on right side\n        for i in range(len(arr)-1,-1,-1):\n            lowest_right[i] = maxnum\n            maxnum = min(arr[i],maxnum)\n        \n        ans = 0\n        i = 0\n        largest_left = -1\n        while i < len(arr):\n            largest_left = max(arr[i],largest_left)\n            if arr[i]<= lowest_right[i] and largest_left<= lowest_right[i]:\n                ans += 1\n                i += 1\n            else:\n                i+=1\n\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1307795096","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        if not head:\n            return\n        #don't miss this\n        if not head.next:\n            return TreeNode(head.val)\n        slow,fast = head, head.next.next\n        while fast and fast.next:\n            fast = fast.next.next\n            slow = slow.next\n        \n        temp = slow.next\n        slow.next = None\n        root = TreeNode(temp.val)\n        root.left = self.sortedListToBST(head)\n        root.right = self.sortedListToBST(temp.next)\n        \n        return root\n        ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312367781","body":"```\nclass LRUCache:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.dic = collections.OrderedDict()\n        \n\n    def get(self, key: int) -> int:\n        if key in self.dic:\n            v = self.dic[key]\n            \n            self.dic.pop(key)\n            self.dic[key] = v\n            \n            return v\n        else:\n            return -1\n        \n\n    def put(self, key: int, value: int) -> None:\n        if key in self.dic:\n            self.dic.pop(key)\n            self.dic[key] = value\n        else:\n            if len(self.dic)>= self.capacity:\n                self.dic.popitem(last=False) \n                self.dic[key] = value\n            else:\n                self.dic[key] = value\n```        \n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312843982","body":"class Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        elif not p or not q:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316144330","body":"class Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque()\n        queue.append(root)\n        while queue:\n            length = len(queue)\n            ans = queue[0].val\n            for i in range(length):\n                node = queue.popleft()\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318118813","body":"# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return ''\n        queue = deque()\n        queue.append(root)\n        nodes = []\n        while queue:\n            cur = queue.popleft()\n            if not cur:\n                nodes.append('n')\n                continue\n            else:\n                nodes.append(str(cur.val))\n            queue.append(cur.left)\n            queue.append(cur.right)\n        return \",\".join(nodes)\n            \n\n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        nodes= data.split(',')\n        if not nodes:\n            return None\n        print(nodes)\n        root = TreeNode(nodes[0])\n        queue = deque([root])\n        i = 1\n        while i<len(nodes)-1:\n            node = queue.popleft()\n            if nodes[i] !=  'n':\n                l = TreeNode(nodes[i])\n                queue.append(l)\n                node.left = l\n            if nodes[i+1] !=  'n':\n                r = TreeNode(nodes[i+1])\n                queue.append(r)\n                node.right = r\n\n            i += 2\n        return root\n\n        return root\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320973704","body":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic = {}\n        for i in nums:\n            if i not in dic:\n                dic[i] = 1\n            else:\n                dic[i] += 1\n        \n        dic = sorted(dic, key = dic.get, reverse = True)\n        #print(dic)\n        ans = []\n        count = 0\n        for i in dic:\n            if count == k:\n                break\n            ans.append(i)\n            count += 1\n        return ans","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322860892","body":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        #dic \n        if not s:\n            return 0\n        dic = {}\n        l,r = 0,0\n        ans = 0\n        while l<=r and r < len(s):\n            if s[r] not in dic:\n                dic[s[r]] = r\n                ans = max(ans, r-l+1)\n                r += 1\n            else:\n                temp = l\n                l = dic[s[r]] + 1\n                for i in range(temp,l):\n                    del dic[s[i]]\n                ans = max(ans, r-l+1)\n                dic[s[r]] = r\n                r += 1\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326661555","body":"class Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        l,r = head,head\n\n        while r and r.next:\n            l = l.next\n            r = r.next.next\n        return l\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327759344","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i = 1\n\n        while i<len(nums):\n            if nums[i] == nums[i-1]:\n                nums.pop(i)\n            else:\n                i += 1\n        return len(nums)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328146092","body":"class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        l,r = 0,len(nums)-1\n        while l <= r:\n            mid = (l+r)//2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                r = mid - 1\n            elif nums[mid] < target:\n                l = mid + 1\n        \n        return l    ","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332779046","body":"class Solution:\n    # 拓扑排序\n    def tp_sort(self, items, indegree, neighbors):\n        q = collections.deque([])\n        ans = []\n        for item in items:\n            if not indegree[item]:\n                q.append(item)\n        while q:\n            cur = q.popleft()\n            ans.append(cur)\n\n            for neighbor in neighbors[cur]:\n                indegree[neighbor] -= 1\n                if not indegree[neighbor]:\n                    q.append(neighbor)\n\n        return ans\n\n    def sortItems(self, n: int, m: int, group: List[int], pres: List[List[int]]) -> List[int]:\n        max_group_id = m\n        for project in range(n):\n            if group[project] == -1:\n                group[project] = max_group_id\n                max_group_id += 1\n\n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n\n        for project in range(n):\n            group_projects[group[project]].append(project)\n\n            for pre in pres[project]:\n                if group[pre] != group[project]:\n                    # 小组关系图\n                    group_indegree[group[project]] += 1\n                    group_neighbors[group[pre]].append(group[project])\n                else:\n                    # 项目关系图\n                    project_indegree[project] += 1\n                    project_neighbors[pre].append(project)\n\n        ans = []\n        # 先对组进行拓扑排序\n        group_queue = self.tp_sort([i for i in range(max_group_id)], group_indegree, group_neighbors)\n\n        if len(group_queue) != max_group_id:\n            return []\n\n        for group_id in group_queue:\n            # 对小组中的项目进行拓扑排序\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n\n            if len(project_queue) != len(group_projects[group_id]):\n                return []\n            ans += project_queue\n\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334789073","body":"class Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        dic= {\"R\": 0,\"L\":0,\"U\":0,\"D\":0}\n\n        for i in moves:\n            dic[i] += 1\n        \n        if dic['R'] == dic['L'] and dic['U'] == dic['D']:\n            return True\n        else:\n            return False\n            ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336018562","body":"class Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        tasks = [(j[0],i,j[1]) for i,j in enumerate(tasks)]\n        tasks.sort()\n        ans = []\n        queue = []\n        time = 0\n        pos = 0\n        for _ in tasks:\n            if not queue:\n                time = max(time, tasks[pos][0])\n            #add available task to queue\n            while pos < len(tasks) and tasks[pos][0] <= time:\n                heapq.heappush(queue, (tasks[pos][2],tasks[pos][1]))\n                pos += 1\n            t,index = heapq.heappop(queue)\n            time += t\n            ans.append(index)\n        return ans ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336717647","body":"class Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        counter_A = collections.Counter(a)\n        counter_B = collections.Counter(b)\n        def less(a,b):\n            # a > b\n            minstep = float('inf')\n            for i in range(1,26):\n                temp = 0\n                #assume char is the smallest number in a\n                for j in range(i):\n                    temp += counter_A[chr(j+97)]\n                for j in range(i,26):\n                    temp += counter_B[chr(j+97)]\n                minstep = min(minstep,temp)\n            return temp\n        def one_char(a,b):\n            minstep = float('inf')\n            for i in range(26):\n                minstep = min(minstep,len(a)+len(b)-counter_A[chr(i+97)]-counter_B[chr(i+97)])\n            return minstep\n        print(less(a,b),less(b,a),one_char(a,b))\n        return min(less(a,b),less(b,a),one_char(a,b))","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340334507","body":"class Solution:\n    def mySqrt(self, x: int) -> int:\n        l = 0\n        r = x\n        while l<=r:\n            mid = (l+r)//2\n            if mid**2 == x:\n                return mid\n            elif mid**2 < x and (mid+1)**2>x:\n                return mid\n            elif mid**2 > x:\n                r = mid-1\n            elif mid**2<x:\n                l = mid+1\n            \n        return l\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341521754","body":"class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        l,r = 1,n\n        while l<=r:\n            mid = (l+r)//2\n            if isBadVersion(mid):\n                if mid==1 or not isBadVersion(mid-1):\n                    return mid\n                else:\n                    r = mid -1\n            else:\n                l = mid+1\n        \n        return l\n        ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343873638","body":"class Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        self.cnt = 0\n        def merge(nums, start, mid, end):\n            i, j, temp = start, mid + 1, []\n            while i <= mid and j <= end:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    self.cnt += mid - i + 1\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= end:\n                temp.append(nums[j])\n                j += 1\n\n            for i in range(len(temp)):\n                nums[start + i] = temp[i]\n\n\n        def mergeSort(nums, start, end):\n            if start >= end: return\n            mid = (start + end) >> 1\n            mergeSort(nums, start, mid)\n            mergeSort(nums, mid + 1, end)\n            merge(nums, start, mid,  end)\n        mergeSort(nums, 0, len(nums) - 1)\n        return self.cnt","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345448517","body":"class Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        def less_than(x: int) -> int:\n            i, pairs = 0, 0\n            for j in range(len(nums)):\n                while nums[j] - nums[i] > x:\n                    i += 1\n                pairs += j - i\n            return pairs\n\n        nums.sort()\n        low, high = 0, nums[-1] - nums[0]\n        while low < high:\n            mid = low + (high - low) // 2\n            if less_than(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345632025","body":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        # search space\n        l,r = 0,max([max(i) for i in grid])\n        seen = set()\n        def dfs(mid,l,r):\n            \n            if l<0 or l>len(grid)-1 or r < 0 or  r>len(grid)-1:\n                return False\n            if grid[l][r] >mid:\n                return False\n            if (l,r) in seen:\n                return False\n            if (l,r) == (len(grid)-1,len(grid)-1):\n\n                return True\n            seen.add((l,r))\n            ans = dfs(mid,l,r+1) or dfs(mid,l,r-1) or dfs(mid,l+1,r) or dfs(mid,l-1,r) \n            return ans\n        \n        while l<=r:\n            mid = (l+r)//2\n            if dfs(mid,0,0):\n                r = mid-1\n            else:\n                l = mid+1\n            seen = set()\n        return l\n                \n            \n            \n\n        ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1355944817","body":"class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        # k = len(cardpoints) is a corner case\n        sums = sum(cardPoints)\n        print(sums)\n        l = 0\n        r = l+len(cardPoints)-k-1\n        temp_sum = sum(cardPoints[l:r+1])\n        temp_ans = sums - temp_sum\n        ans = sums - temp_sum\n        print(ans)\n        while l<=r and r < len(cardPoints)-1: #l<=r l=r is a corner case\n            r += 1\n            l += 1\n            temp_ans = temp_ans-cardPoints[r]+cardPoints[l-1]\n            print(l,r,temp_ans)\n            ans = max(ans,temp_ans)\n            \n            \n            \n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356458586","body":"class Solution:\n    def readBinaryWatch(self, turnedOn: int) -> List[str]:\n        ans = []\n        # how many on hour, how many on min\n        #if turnedOn == 0 or turnedOn >9:\n        #    return []\n        def dfs(ans,hour, num):\n            if hour>num:\n                return \n            for h in itertools.combinations([1,2,4,8],hour):\n                if sum(h) > 11:\n                    continue\n                for m in itertools.combinations([1,2,4,8,16,32],num-hour):\n                    if sum(m) > 59:\n                        continue\n                    time = \"%d:%02d\" % (sum(h),sum(m))\n                    ans.append(time)\n            dfs(ans,hour+1, num)\n        dfs(ans,0, turnedOn)\n        return ans","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360757784","body":"class Solution:\n#tle\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        ans = -1\n        n = len(grid)\n        que = collections.deque([(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1])\n        if len(que) == 0 or len(que) == n ** 2: return -1\n        def bfs(start):\n            r,c = start\n            queue = collections.deque([(r,c)])\n            count = 0\n            while queue:\n                count+=1\n                for _ in range(len(queue)):\n                    a,b = queue.popleft()\n                    for i,j in [(a+1,b),(a-1,b),(a,b+1),(a,b-1)]:\n                        if i<len(grid) and i>-1 and j<len(grid[0]) and j>-1:\n                            if grid[i][j] == 1:\n                                return count \n                            else:\n                                queue.append((i,j))\n                \n            return -1\n        \n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == 0:\n                    ans = max(ans,bfs((i,j)))\n        return ans\n        \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1363367152","body":"import collections\nclass Solution(object):\n    def verticalTraversal(self, root):\n        self.seen = defaultdict(lambda :defaultdict(list))\n        self.dfs(root,0,0)\n        ans = []\n        print(sorted(self.seen))\n        print(self.seen)\n        for x in sorted(self.seen):\n            temp = []\n            for y in sorted(self.seen[x]):\n                temp += sorted(v for v in self.seen[x][y])\n            ans.append(temp)\n        return ans\n    def dfs(self,root,row,col):\n        if not root:\n            return\n        \n        self.seen[col][row].append(root.val)\n        \n        self.dfs(root.left,row+1,col-1)\n        self.dfs(root.right,row+1,col+1)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1364275501","body":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        lists = [0] * len(cost)\n        #lists[i] means lowest cost till this step\n        lists[0] = 0\n        lists[1] = 0\n        for i in range(2,len(cost)):\n            lists[i] = min(lists[i-1]+cost[i-1],lists[i-2]+cost[i-2])\n        \n        return min(lists[-2]+cost[-2],lists[-1]+cost[-1])","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1364806288","body":"class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        #need 2 dp\n        #dp1[i]: store the lenth of longest sequence till i\n        #dp2[i]: store the number of longest sequence till i\n        dp1 = [1]*len(nums)\n        dp2 = [1]*len(nums)\n        longest = 1\n        for i in range(1,len(nums)):\n            for j in range(i):\n                # nums[j]\n                if nums[i] > nums[j]:\n                    if dp1[j] + 1 > dp1[i]:\n                        dp1[i]  = dp1[j] + 1\n                        dp2[i]  = dp2[j]\n                    elif dp1[j] + 1 == dp1[i]:\n                        dp2[i] += dp2[j]\n        \n        longest = max(dp1)\n        ans = 0\n        for i in range(len(nums)):\n            if dp1[i] == longest:\n                ans += dp2[i]\n        return ans\n ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365569484","body":"class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        #dp[i][j] means the length of common sequence till i in t1 and j in t2\n        dp = [[0 for _ in range(len(text1)+1)] for _ in range(len(text2)+1)]\n        ans= 0 \n        for i in range(1,len(text2)+1):\n            for j  in range(1,len(text1)+1):\n                if text2[i-1] == text1[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                    ans = max(ans,dp[i][j])\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return ans \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366124206","body":"\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        #dp\n        ans = [[0 for _ in range(n)] for _ in range(m)]\n        ans[0][0] = 1\n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j ==0:\n                    continue\n                elif i == 0 and j != 0:\n                    ans[i][j] = 1\n                elif i != 0 and j == 0:\n                    ans[i][j] = 1\n                else:\n                    ans[i][j] = ans[i-1][j] + ans[i][j-1]\n        return ans[-1][-1]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1367008441","body":"\n\nclass Solution:\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        ans = [[0 for _ in range(n)] for _ in range(n)]\n        ans[row][column] = 1\n        dic = [(-2,1),(-1,2),(1,2),(2,1),(-2,-1),(-1,-2),(1,-2),(2,-1)]\n        for _   in range(k):\n            ans2 = [[0  for _ in range(n)] for _ in range(n)]\n            for r in range(n):\n                for  c in range(n):\n                    for k,v in  dic:\n                        if r+k>-1 and r+k<n and  c+v>-1 and c+v<n:\n                            ans2[r+k][c+v] += 0.125*ans[r][c]\n            ans =  ans2\n        \n        return sum([sum(i) for i in ans])","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368089803","body":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums)%2!=0:\n            return False\n        target = sum(nums)/2\n        dp = [[False for _ in range(int(target+1))] for _ in range(len(nums))]\n        #dp[first n nums][target] = dp[first n-1 nums][target] or dp[first n-1 nums][target-nums[n]]\n        for i in range(len(nums)):\n            dp[i][0] = True\n        if nums[0] <= target:\n            dp[0][nums[0]] = True\n        for i in range(1,len(nums)):\n            for j in range(1,int(target+1)):\n                if nums[i] <= j:\n                    dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i]]\n                else:\n                    dp[i][j] = dp[i-1][j]  \n        return dp[-1][-1]","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368541129","body":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        # bfs shortest path, first meet ans will be the answer\n        if not amount:\n            return 0\n        visit = set()\n        queue = deque([(amount,0)])\n        while queue:\n            a,nc = queue.popleft()\n            if a == 0:\n                return nc\n\n            for c in coins:\n                if a-c <0 or a-c in visit:\n                    continue\n                queue.append((a-c,nc+1))\n                visit.add(a-c)\n        return -1\n                    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369190458","body":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [[0 for _ in range(amount+1)] for _ in range(len(coins))]\n        for i in range(len(coins)):\n            dp[i][0] = 1\n        \n        for i in range(0,len(coins)):\n            for j in range(1,amount+1):\n                if j-coins[i]>=0:\n                    dp[i][j] = dp[i-1][j]+dp[i][j-coins[i]]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return dp[-1][-1]\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371288661","body":"class Solution:\n    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:\n        n = len(intervals)\n        if n == 0: return 0\n        intervals.sort(key = lambda x:x[1])\n        print(intervals)\n        count = 0\n        r  = intervals[0][1]\n        for i in range(1,n):\n            \n            if r > intervals[i][0]:\n                count += 1\n            else:\n                r  = intervals[i][1]\n        return count\n        \n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1374615023","body":"class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if len(lists) == 0:\n            return None\n        elif len(lists) == 1:\n            return lists[0]\n        elif len(lists) == 2:\n            return self.merge2(lists[0],lists[1])\n        else:\n            mid = len(lists)//2\n            return self.merge2(self.mergeKLists(lists[:mid]),self.mergeKLists(lists[mid:]))\n    def merge2(self,l,r):\n        ans = ListNode(0)\n        head = ans\n        while l and r:\n            if l.val<r.val:\n                ans.next = l\n                l =  l.next\n                ans = ans.next\n            else:\n                ans.next = r\n                ans = ans.next\n                r = r.next\n        if l:\n            ans.next = l\n        if r:\n            ans.next = r\n        return head.next","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1374914336","body":"class Solution:\n    def beautifulArray(self, n: int) -> List[int]:\n        @lru_cache(None)\n        def dp(n):\n            if n == 1:\n                return [1]\n            ans = []\n            # [1,n] 中奇数比偶数多1或一样\n            for a in dp(n - n // 2):\n                ans += [a * 2 - 1]\n            for b in dp(n // 2):\n                ans += [b * 2]\n            return ans\n\n        return dp(n)\n        ","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1378162783","body":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ans = []\n        length =  len(nums)\n        def dfs(idx,path):\n            if  idx == length:\n                ans.append(path[:])\n                return \n            else:\n                path.append(nums[idx])\n                dfs(idx+1,path)\n                path.pop()\n                dfs(idx+1,path)\n\n            \n        dfs(0,[])  \n        return ans\n            ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1317302288","body":"## 思路 \n把num转换成整数后加上k，再转换成数组\n\n## 代码\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            temp = 0\n            for item in num:\n                temp = temp * 10 + item\n            res = []\n            sumNum = temp + k\n            while sumNum != 0:\n                last = sumNum % 10\n                sumNum //= 10\n                res.insert(0, last)\n            return res\n## 复杂度\ntime O(max(num和k的长度))<br/>\nspace O(max(num和k的长度))\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1317302811","body":"## 思路\n\n先标记有 char 的 idx 的值为 0， 再遍历一遍数组如果不为 0 的地方就左右扩散找，取最小值\n\n## 代码\n\n    class Solution:\n        def shortestToChar(self, s: str, c: str) -> List[int]:\n            n = len(s)\n            res = [n] * n\n            for i in range(n):\n                if s[i] == c:\n                    res[i] = 0\n\n            for i in range(n):\n                if res[i] == 0:\n                    idx = i\n                    idx2 = i\n                    while idx + 1 < n and res[idx + 1] != 0:\n                        res[idx + 1] = min(res[idx] + 1, res[idx + 1])\n                        idx += 1\n                    while idx2 - 1 >= 0 and res[idx2 - 1] != 0:\n                        res[idx2 - 1] = min(res[idx2] + 1, res[idx2 - 1])\n                        idx2 -= 1\n            return res\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1317303312","body":"## 思路\n\n最优解前缀和，用 increment 数组把要增加的前 k 个元素和存起来，pop 时为 stack.pop() + increment[cnt - 1]， 同时把 increment[cnt - 2] 加上 increment[cnt - 1], 把 increment[cnt - 1] = 0，防止影响后续 pop 操作，这样 increment 操作为 O(1)。\n\n## 代码\n\n    class CustomStack(object):\n\n        def __init__(self, maxSize):\n            \"\"\"\n            :type maxSize: int\n            \"\"\"\n            self.capacity = maxSize\n            self.stack = []\n            self.cnt = 0\n            self.increments = [0] * maxSize\n\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            if self.cnt < self.capacity:\n                self.stack.append(x)\n                self.cnt += 1\n\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            if self.cnt == 0:\n                return -1\n            if self.cnt >= 2:\n                self.increments[self.cnt - 2]  += self.increments[self.cnt - 1]\n            val = self.stack.pop() + self.increments[self.cnt - 1]\n\n            self.increments[self.cnt - 1] = 0\n            self.cnt -= 1\n            return val\n\n\n\n        def increment(self, k, val):\n            \"\"\"\n            :type k: int\n            :type val: int\n            :rtype: None\n            \"\"\"\n            if self.cnt > 0:\n                self.increments[min(self.cnt, k) - 1] += val\n\n## 复杂度\n\ntime O(1)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302868479","body":"## 思路\n\n如果不是']'，就把当前字符放入 stack 中，否则就把从 stack pop 出 string 和 repeat time，最后再把结果放在栈里面\n\n## 代码\n\n```py\n    class Solution:\n        def decodeString(self, s: str) -> str:\n            stack = []\n            for char in s:\n                if char != \"]\":\n                    stack.append(char)\n                else:\n                    temp = \"\"\n                    count = \"\"\n                    while len(stack) != 0 and stack[-1] != \"[\":\n                        temp = stack.pop() + temp\n                    stack.pop()\n                    while len(stack) != 0 and stack[-1].isdigit():\n                        count = stack.pop() + count\n                    stack.append(temp * int(count))\n            return  \"\".join(stack)\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1317303775","body":"## 思路\n\n队列 push 时，把元素都加入到第一个栈中；当 pop 或 peek 时，把元素倒着出栈加入到第二个栈中，此时的栈顶元素就是队列的头\n\n## 代码\n\n    class MyQueue(object):\n\n        def __init__(self):\n            self.stack1 = []\n            self.stack2 = []\n\n        def push(self, x):\n            \"\"\"\n            :type x: int\n            :rtype: None\n            \"\"\"\n            self.stack1.append(x)\n\n\n        def pop(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            popOut = self.stack2.pop()\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return popOut\n\n\n        def peek(self):\n            \"\"\"\n            :rtype: int\n            \"\"\"\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n\n            peekNum = self.stack2[-1]\n\n            while len(self.stack2) != 0:\n                self.stack1.append(self.stack2.pop())\n            return peekNum\n\n        def empty(self):\n            \"\"\"\n            :rtype: bool\n            \"\"\"\n            return len(self.stack1) == 0\n\n## 复杂度\n\npush time O(1)<br/>\npop time O(N)<br/>\npeek time O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1317305154","body":"## 思路\r\n\r\n前一个模块的 max 必须小于等于后面模块的 min，所以只要后面出现小于前面 max 的，要把前面的都踢出去，留下之前的 max\r\n最后返回栈的长度，栈存的是左边模块的分界点\r\n\"\"\"\r\n[2,1,3,4,4] => [2, 3, 4, 4]\r\n\"\"\"\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for singly-linked list.\r\n\r\n    class Solution:\r\n        def maxChunksToSorted(self, arr: List[int]) -> int:\r\n            stack = []\r\n            for num in arr:\r\n                if stack and num < stack[-1]:\r\n                    curMax = stack[-1]\r\n                    while stack and num < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(curMax)\r\n                else:\r\n                    stack.append(num)\r\n            return len(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(N)<br/>\r\nspace O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1317304435","body":"## 思路\n\n注意 corner case，head 为空，head 为 1 个节点，k 为 0 时要直接 return；k 取模后如果为 0 也要直接 return\n\n## 代码\n\n    # Definition for singly-linked list.\n    # class ListNode(object):\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    class Solution(object):\n        def rotateRight(self, head, k):\n            \"\"\"\n            :type head: ListNode\n            :type k: int\n            :rtype: ListNode\n            \"\"\"\n            if not head or k == 0 or head.next == None:\n                return head\n\n            newTail= head\n            cur = head\n            length = 0\n            while cur != None:\n                cur = cur.next\n                length += 1\n\n            k %= length\n            if k == 0:\n                return head\n\n            cur = head\n            for i in range(k):\n                cur = cur.next\n\n            while cur.next != None:\n                cur = cur.next\n                newTail = newTail.next\n\n            newHead = newTail.next\n            newTail.next = None\n            cur.next = head\n            head = newHead\n            return head\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1308119107","body":"## 思路\r\n\r\n前驱节点获得要交换的两个节点，前驱节点先指向交换节点的后节点，交换的前节点指向后节点的 next 后，才能开始交换\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1)\r\n        dummy.next = head\r\n        cur = dummy\r\n        while cur.next and cur.next.next:\r\n            p2 = cur.next\r\n            p3 = cur.next.next\r\n            cur.next = p3\r\n            p2.next = p3.next\r\n            p3.next = p2\r\n\r\n            cur = p2\r\n        return dummy.next\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(N)<br/>\r\nspace O(1)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308118669","body":"## 思路\n\n注意当只有一个节点的时候要返回这个节点。获得中间节点的值，然后分别构建左右子树。\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n    # class ListNode:\n    #     def __init__(self, val=0, next=None):\n    #         self.val = val\n    #         self.next = next\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = self.findMid(head)\n            cur = mid.next\n            mid.next = None\n            root = TreeNode(cur.val)\n            root.left = self.sortedListToBST(head)\n            root.right = self.sortedListToBST(cur.next)\n            return root\n\n\n        def findMid(self, head):\n            if not head:\n                return None\n            p1, p2 = head,head\n            pre = None\n            while p2 and p2.next:\n                pre = p1\n                p1 = p1.next\n                p2 = p2.next.next\n            return pre\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309734337","body":"## 思路\n\nheadA, headB 分别指向链表 A, B 的头结点, 两个链表都分别遍历过，如果有交点就会返回。\n\n## 代码\n\n```python\n    class Solution:\n        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n            p1, p2 = headA, headB\n            while p1 != p2:\n                p1 = p1.next if p1 != None else headB\n                p2 = p2.next if p2 != None else headA\n            return p1\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1317298258","body":"## 思路\n\n先快慢指针直到相遇，相遇后把其中一指针放回起点，然后两指针同时向前走，直到相遇。相遇点就是环的开始点。否则不存在环\n\n## 代码\n\n```java\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n\n        ListNode fast = head, slow = head;\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (slow == fast) break;\n        }\n\n        if (fast == null || fast.next == null) return null;\n\n        slow = head;\n        while (slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return slow;\n    }\n}\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(1)\n```\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1317297812","body":"## 思路\n\n用双向链表和哈希表实现，用 map 能在 O(1)时间内读取，双向链表不需要前驱节点删除，添加也是 O(1)\n\n## 代码\n\n```python\n    # Definition for singly-linked list.\n\n    class ListNode:\n        def __init__(self, key, val):\n            self.key = key\n            self.val = val\n            self.pre = None\n            self.next = None\n\n    class Linkedlist:\n        def __init__(self):\n            self.head = ListNode(0, 0)\n            self.tail = ListNode(0, 0)\n            self.head.next = self.tail\n            self.tail.pre = self.head\n\n\n        def addFirst(self, node):\n            node.pre = self.head\n            node.next = self.head.next\n    #         先写pre指向node！！\n            self.head.next.pre = node\n            self.head.next = node\n\n        def delete(self, node):\n            key = node.key\n            node.next.pre = node.pre\n            node.pre.next = node.next\n            return key\n\n        def deleteLast(self):\n            if self.head.next == self.tail:\n                return -1\n            return self.delete(self.tail.pre)\n\n\n\n\n    class LRUCache(object):\n\n        def __init__(self, capacity):\n            \"\"\"\n            :type capacity: int\n            \"\"\"\n            self.cache = Linkedlist()\n            self.map = {}\n            self.capacity = capacity\n\n        def get(self, key):\n            \"\"\"\n            :type key: int\n            :rtype: int\n            \"\"\"\n            if key not in self.map:\n                return -1\n            node = self.map[key]\n            val = node.val\n            self.cache.delete(node)\n            self.cache.addFirst(node)\n            return val\n\n\n        def put(self, key, value):\n            \"\"\"\n            :type key: int\n            :type value: int\n            :rtype: None\n            \"\"\"\n            newnode = ListNode(key, value)\n    #         如果遇到满了但是要改写key val的例子，优先改写key\n            if key in self.map:\n                node = self.map[key]\n                self.cache.delete(node)\n\n            elif len(self.map.keys()) == self.capacity:\n                k = self.cache.deleteLast()\n                self.map.pop(k)\n\n\n\n            self.map[key] = newnode\n            self.cache.addFirst(newnode)\n\n\n\n\n\n\n    # Your LRUCache object will be instantiated and called as such:\n    # obj = LRUCache(capacity)\n    # param_1 = obj.get(key)\n    # obj.put(key,value)\n```\n\n## 复杂度\n\ntime O(1)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1317296667","body":"## 思路\n\nroot 的最大深度等于 max(左子树的最大深度，右子树的最大深度) + 1\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution(object):\n        def maxDepth(self, root):\n            \"\"\"\n            :type root: TreeNode\n            :rtype: int\n            \"\"\"\n            if not root:\n                return 0\n            left = self.maxDepth(root.left)\n            right = self.maxDepth(root.right)\n            return max(left, right) + 1\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1317296283","body":"## 思路\n\n两棵树每个节点遍历判断\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n            if not p and not q:\n                return True\n            if not p or not q:\n                return False\n            if p.val != q.val:\n                return False\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1317295773","body":"## 思路\n\n注意其中一边子树为空的情况，要多加两个条件判断左子树为空或者右子树为空\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def sumNumbers(self, root: Optional[TreeNode]) -> int:\n            if not root:\n                return 0\n            return self.helper(root, 0)\n\n\n        def helper(self, root, sumNum):\n            if not root.left and not root.right:\n                return sumNum * 10 + root.val\n            if not root.left:\n                return self.helper(root.right, sumNum * 10 + root.val)\n            if not root.right:\n                return self.helper(root.left, sumNum * 10 + root.val)\n            left = self.helper(root.left, sumNum * 10 + root.val)\n            right = self.helper(root.right, sumNum * 10 + root.val)\n            return left + right\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317294311","body":"## 思路\n\nBFS，然后返回最左边 bottom 的节点\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode:\n    #     def __init__(self, val=0, left=None, right=None):\n    #         self.val = val\n    #         self.left = left\n    #         self.right = right\n    class Solution:\n        def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n            q = deque()\n            q.append(root)\n            res = []\n            while q:\n                size = len(q)\n                temp = []\n                for i in range(size):\n                    cur = q.popleft()\n                    temp.append(cur.val)\n                    if cur.left:\n                        q.append(cur.left)\n                    if cur.right:\n                        q.append(cur.right)\n                res.append(temp[:])\n            return res[-1][0]\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1317293780","body":"## 思路\n\npreorder traversal transform the root data to a string, and use queue to store the data after transform it to array.\n\n## 代码\n\n```python\n    # Definition for a binary tree node.\n    # class TreeNode(object):\n    #     def __init__(self, x):\n    #         self.val = x\n    #         self.left = None\n    #         self.right = None\n\n    class Codec:\n\n        def serialize(self, root):\n            \"\"\"Encodes a tree to a single string.\n            \n            :type root: TreeNode\n            :rtype: str\n            \"\"\"\n            if not root:\n                return \"#\"\n            return str(root.val) + \",\" + self.serialize(root.left) + \",\" + self.serialize(root.right)\n            \n\n        def deserialize(self, data):\n            \"\"\"Decodes your encoded data to tree.\n            \n            :type data: str\n            :rtype: TreeNode\n            \"\"\"\n            temp = data.split(\",\")\n            q = deque(temp)\n            return self.helper(q)\n            \n        def helper(self, q):\n            if not q:\n                return None\n            \n            cur = q.popleft()\n            if cur == \"#\":\n                return None\n            root = TreeNode(cur)\n            root.left = self.helper(q)\n            root.right = self.helper(q)\n            return root\n            \n\n    # Your Codec object will be instantiated and called as such:\n    # ser = Codec()\n    # deser = Codec()\n    # ans = deser.deserialize(ser.serialize(root))\n```\n\n## 复杂度\n\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1325955752","body":"## 思路\r\n\r\n用map记录每个坐标节点list的值，最后加进来的时候要把同坐标的list排序\r\n\r\n## 代码\r\n\r\n```python\r\n    # Definition for a binary tree node.\r\n    # class TreeNode(object):\r\n    #     def __init__(self, val=0, left=None, right=None):\r\n    #         self.val = val\r\n    #         self.left = left\r\n    #         self.right = right\r\n    class Solution(object):\r\n        def verticalTraversal(self, root):\r\n            \"\"\"\r\n            :type root: TreeNode\r\n            :rtype: List[List[int]]\r\n            \"\"\"\r\n            self.seen = collections.defaultdict(lambda: collections.defaultdict(list))\r\n            self.dfs(root, 0, 0)\r\n            \r\n            res = []\r\n            for col in sorted(self.seen):\r\n                level = []\r\n                for row in sorted(self.seen[col]):\r\n                    level += list(v for v in sorted(self.seen[col][row]))\r\n                res.append(level[:])\r\n            return res\r\n            \r\n        def dfs(self, root, row, col):\r\n            if not root:\r\n                return \r\n            self.seen[col][row].append(root.val)\r\n            self.dfs(root.left, row + 1, col - 1)\r\n            self.dfs(root.right, row + 1, col + 1)\r\n            \r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(NlogN)\r\nspace O(N)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1325957089","body":"## 思路\n\n如果另一个数字的idx不等于当前idx，就返回结果数组，然后对遍历的每项都存到map中\n\n## 代码\n\n```python\n    class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        map = {}\n        for idx, val in enumerate(nums):\n            num2 = target - val\n            if map.get(num2) != None and map.get(num2) != idx:\n                return [map.get(num2), idx]\n            map[val] = idx\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1325956836","body":"## 思路\n\n与215类似，先用map统计数字频率，用set去重后再用heapq排序，建最大堆，然后取前k个元素即可。\n\n## 代码\n\n```python\n    class Solution(object):\n        def topKFrequent(self, nums, k):\n            \"\"\"\n            :type nums: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            m = collections.defaultdict(int)\n            for num in nums:\n                m[num] += 1\n            s = set(nums)\n            \n            pq = []\n            heapq.heapify(pq)\n            while s:\n                num = s.pop()\n                heapq.heappush(pq, (-m[num], num))\n                \n            res = []\n            for i in range(k):\n                count, num = heapq.heappop(pq)\n                res.append(num)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1325956609","body":"## 思路\n\n排列组合，遍历每个点作为中间点，然后求所有到这个点距离的次数count，res += count * (count - 1)\n\n## 代码\n\n```python\n    class Solution(object):\n        def numberOfBoomerangs(self, points):\n            \"\"\"\n            :type points: List[List[int]]\n            :rtype: int\n            \"\"\"\n            res = 0\n            for i in range(len(points)):\n                m = collections.defaultdict(int)\n                for j in range(len(points)):\n                    dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                    m[dis] += 1\n                for count in m.values():\n                    res += count * (count - 1)\n            return res\n```\n\n## 复杂度\n\ntime O(N ^ 2)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1325956249","body":"## 思路\n\n只要set中有重复数字就移动左窗口，移动后求res。\n\n## 代码\n\n```python\n    class Solution:\n        def lengthOfLongestSubstring(self, s: str) -> int:\n            charSet = set()\n            left, res = 0, 0\n            for i in range(len(s)):\n                char = s[i]\n                while char in charSet:\n                    d = s[left]\n                    left += 1\n                    charSet.remove(d)\n                charSet.add(char)\n                res = max(res, i - left + 1)\n            return res\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325956115","body":"## 思路\n\n双指针\n\n## 代码\n\n```python\n    class Solution:\n        def findSubstring(self, s: str, words: List[str]) -> List[int]:\n            counter = Counter(words)\n            sLen = len(s)\n            n = len(words)\n            wordLen = len(words[0])\n            res = []\n            \n    #         iterate windows\n            for i in range(sLen - n * wordLen + 1):\n    #             当前window的可能，从i开始\n                cur = s[i:i + wordLen * n]\n                j = 0\n    #         收集当前cur的每个词的频率，如果跟counter不一样就剪枝\n                temp = collections.defaultdict(int)\n                while j < len(cur):\n                    word = cur[j: j + wordLen]\n                    # print(word)\n                    if word not in counter:\n                        break\n                        \n                    temp[word] += 1\n                    if temp[word] > counter[word]:\n                        break\n                    j += wordLen\n                if j == len(cur):\n                    res.append(i)\n            return res\n\n```\n\n## 复杂度\n\ntime O(N * M)\nspace O(1)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325955959","body":"## 思路\n\n前缀和+哈希表\n累加求得每项余数，题目求减掉多少项能被整除，就是求subarray余数之差为总数和的余数\n\n## 代码\n\n```python\n    class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        map = collections.defaultdict(int)\n        total = 0\n        res = len(nums)\n        mod = sum(nums) % p\n#         initalize\n        map[0] = -1\n        if mod == 0:\n            return 0\n        for i in range(len(nums)):\n            total += nums[i]\n            cur = total % p\n            target = ((cur - mod) % p + p) % p\n            if target in map:\n                res = min(res, i - map[target])\n            map[cur] = i\n\n        return res if res != len(nums) else -1\n\n```\n\n## 复杂度\n\ntime O(N)\nspace O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1330004869","body":"## 思路\r\n\r\n二分模版\r\n\r\n## 代码\r\n\r\n```python\r\n    class Solution(object):\r\n        def searchInsert(self, nums, target):\r\n            \"\"\"\r\n            :type nums: List[int]\r\n            :type target: int\r\n            :rtype: int\r\n            \"\"\"\r\n            lo, hi = 0, len(nums) - 1\r\n            res = 0\r\n            while lo <= hi:\r\n                mid = (lo + hi) >> 1\r\n                if nums[mid] == target:\r\n                    return mid\r\n                elif nums[mid] > target:\r\n                    # res = mid\r\n                    hi = mid - 1\r\n                else:\r\n                    # res = mid\r\n                    lo = mid + 1\r\n            return lo\r\n```\r\n\r\n## 复杂度\r\n\r\ntime O(LogN)\r\nspace O(1)\r\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303797717","body":"## 思路\n使用递归的方法，每遇到一个“[”就递归一次，“]”return\n## 代码\n```\nclass Solution(object):\n    def decodeString(self, s):\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                # 获取乘数\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                # 左括号则递归获取字符串\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                # 右括号则返回需要拼接的字符串\n                elif s[i] == ']':\n                    return i, res\n                # 字母则直接接到后面\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n```\n## 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)\nn为字符串长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304820805","body":"## 思路\n使用单调栈的方法，一边遍历，一边找出最多的块数。\n局部来看，若分成两块后合并后能排序成功，则前一块的最大值应小于或等于后一块的最小值，即`max(arr1)<=min(arr2)`;\n由此，用一个栈去记录每一块的最大值，当前值大于上一个块的最大值时，将当前值作为一个单独的块，并记入stack中；\n当前值小于上一个块最大值时，将此时stack中的最大值（最后一个值 ）pop出数组存于head中，然后回溯stack，直至stack的最大值小于等于当前值。\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack=[]\n        for num in arr:\n            if stack and stack[-1]>num:\n                head = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(head)\n            else:    \n                stack.append(num)\n        return len(stack)\n```\n## 复杂度\n时间复杂度$O(N)$\n空间复杂度$O(N)$\nN为字符串长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307424916","body":"## 思路\n使用递归的方法，调换链表的节点\n## 代码\n```\nclass Solution(object):\n    def swapPairs(self, head):\n        # 若链表有至少两个节点\n        if head and head.next:\n            # 用newhead存新的链表头\n            newhead = head.next\n            # 递归调换\n            head.next = self.swapPairs(newhead.next)\n            newhead.next = head\n            return newhead\n        else: return head\n```\n## 复杂度\n时间复杂度：$O(N)$\n\n空间复杂度：$O(N)$\n\nN为链表的节点数","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312719679","body":"## 代码\n```python\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        else:\n            return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\n```\n\n## 复杂度\n时间复杂度 $O(N)$  N为节点数量\n\n空间复杂度$O(h)$  h为二叉树高度\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321078349","body":"## 思路\n哈希表+快排\n\n## 代码\n```python\nclass Solution(object):\n    def topKFrequent(self, nums, k):\n        count = collections.Counter(nums)\n        num_cnt = list(count.items())\n        topKs = self.findTopK(num_cnt, k, 0, len(num_cnt) - 1)\n        return [item[0] for item in topKs]\n    \n    def findTopK(self, num_cnt, k, low, high):\n        pivot = random.randint(low, high)\n        num_cnt[low], num_cnt[pivot] = num_cnt[pivot], num_cnt[low]\n        base = num_cnt[low][1]\n        i = low\n        for j in range(low + 1, high + 1):\n            if num_cnt[j][1] > base:\n                num_cnt[i + 1], num_cnt[j] = num_cnt[j], num_cnt[i + 1]\n                i += 1\n        num_cnt[low], num_cnt[i] = num_cnt[i], num_cnt[low]\n        if i == k - 1:\n            return num_cnt[:k]\n        elif i > k - 1:\n            return self.findTopK(num_cnt, k, low, i - 1)\n        else:\n            return self.findTopK(num_cnt, k, i + 1, high)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328262974","body":"## 思路\n二分法\n## 代码\n```\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        left, right = 0, len(nums)\n        while left < right:\n            mid = left + (right - left)//2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        return left \n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336406822","body":"## 思路\n将时间转换为分钟，如果开始时间 > 结束时间，则在结束时间的基础上加一天；\n将开始和结束时间转换为能被15整除的分钟数；\n\n## 代码\n```python \nclass Solution(object):\n    def numberOfRounds(self, loginTime, logoutTime):\n        \"\"\"\n        :type loginTime: str\n        :type logoutTime: str\n        :rtype: int\n        \"\"\"\n        loginTime = loginTime.split(\":\")\n        logoutTime=logoutTime.split(\":\")\n        start_time=int(loginTime[0])*60+int(loginTime[1])\n        end_time=int(logoutTime[0])*60+int(logoutTime[1])\n        if start_time<end_time and start_time+15>end_time:\n            return 0\n        else:\n            start_time = (start_time//15+1)*15 if start_time%15 else (start_time//15)*15\n            end_time = (end_time//15)*15 if (end_time>=start_time) else (end_time//15)*15+60*24\n            totaltime=end_time-start_time\n            out=totaltime/15\n            return int(out)\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342351503","body":"## 思路\n用二分法寻找\n\n## 代码\n```python\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        if n==1 and isBadVersion(n): return n\n        left = 0\n        right = n\n        while (left<=right):\n            mid = (left+right)//2\n            if isBadVersion(mid):\n                right = mid-1\n            else:\n                left = mid+1\n        return left\n```\n## 复杂度\n时间复杂度 O(logn)\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1351637906","body":"根据动态转移方程\n```python\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        if k == 0:\n            return 1.0\n        dp = [0.0] * (k + maxPts)\n        for i in range(k, min(n, k + maxPts - 1) + 1):\n            dp[i] = 1.0\n        for i in range(k - 1, -1, -1):\n            for j in range(1, maxPts + 1):\n                dp[i] += dp[i + j] / maxPts\n        return dp[0]\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361533044","body":"```python\nclass Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        steps = -1\n        queue = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 1]\n        if len(queue) == 0 or len(queue) == n ** 2: return steps\n        while len(queue) > 0:\n            for _ in range(len(queue)): \n                x, y = queue.pop(0)\n                for xi, yj in [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]:\n                    if xi >= 0 and xi < n and yj >= 0 and yj < n and grid[xi][yj] == 0:\n                        queue.append((xi, yj))\n                        grid[xi][yj] = -1\n            steps += 1\n                \n        return steps\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366722179","body":"动态规划\n转移方程为 f(i,j) = f(i-1,j)+f(i,j-1)\n```python\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]\n        print(f)\n        for i in range(1, m):\n            for j in range(1, n):\n                f[i][j] = f[i - 1][j] + f[i][j - 1]\n        return f[m - 1][n - 1]\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302841924","body":"- Iterate through the num reversely, and stop the loop when k is zero. \r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = []\r\n        remainder = 0\r\n        i = len(num) - 1\r\n        while k > 0:\r\n            digit = num[i] if i >= 0 else 0\r\n            remainder = (digit + k) % 10\r\n            sum.append(remainder)\r\n            k = int((digit + k)/10)\r\n            i -= 1\r\n        return num[:i+1] + sum[::-1] if i+1 > 0 else sum[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302862574","body":"- Method 1: two pointers\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        for i in range(len(s)):\r\n            left = i\r\n            right =min((i + 1), (len(s) - 1))\r\n            while True:\r\n                if s[left] == c or s[right] == c or (left == 0 and right == len(s) - 1):\r\n                    break\r\n                left = max(left - 1, 0)\r\n                right = min((right + 1), (len(s) - 1))\r\n                \r\n            print(left, right)\r\n                \r\n            if s[left] == c:\r\n                ans[i] = i - left\r\n            elif s[right] == c:\r\n                ans[i] = right - i\r\n            else:\r\n                ans[i] = 0\r\n            \r\n        return ans\r\n```\r\n\r\n- Method 2: Go through the whole list from left2right and right2left\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        left2right = self.findShortestFromLeft(s, c)\r\n        right2left = self.findShortestFromLeft(s[::-1], c)\r\n        for l, r in zip(left2right, right2left[::-1]):\r\n            ans += [min(l, r)]\r\n        return ans\r\n    \r\n    def findShortestFromLeft(self, s, c):\r\n        shortest = [0] * len(s)\r\n        buffer = len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                buffer = 0\r\n            else:\r\n                buffer += 1\r\n            shortest[i] = buffer\r\n        return shortest\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302870473","body":"- Use python list to emulate a stack\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack += [x]\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            ans = self.stack[-1]\r\n            self.stack.pop(-1)\r\n            return ans\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        pointer = 0\r\n        while pointer < k and pointer < len(self.stack):\r\n            self.stack[pointer] += val\r\n            pointer += 1\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304662127","body":"- Stack\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = []\r\n        stack = []\r\n        for i in range(len(s)):\r\n            stack.append(s[i])\r\n            if s[i] == ']':\r\n                j = len(stack) - 1\r\n                while j > 0:\r\n                    if stack[j] == '[':\r\n                        k = j - 1\r\n                        while k >= 0 and ('0' <= stack[k] <= '9'):\r\n                            k -= 1\r\n                        temp = stack[j + 1:-1] * int(\"\".join(stack[k + 1: j]))\r\n                        stack = stack[: k + 1] + temp\r\n                        break\r\n                    j -= 1\r\n        return \"\".join(stack)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304702423","body":"- Two stacks\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        return not (bool(self.stack1) or bool(self.stack2))\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304704402","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s1, s2 = 0, 0\r\n        ans = 0\r\n        for i,j in zip(arr, sorted(arr)):\r\n            s1 += i\r\n            s2 += j\r\n            ans += s1 == s2\r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302905333","body":"### Idea:\r\nschool math, 逐位加然后进位\r\n\r\n### Complexity: \r\nTime: O(max(N, log k))\r\nSpace: O(1)\r\n\r\n### Code:\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            if k == 0 : break\r\n            k, num[i] = divmod(num[i] +k,10)\r\n        while k > 0:\r\n            k, a = divmod(k, 10)\r\n            num = [a] + num   \r\n        return num   \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302952263","body":"### Idea: \r\n顺序/逆序遍历，记下距离；在出现第一个char之前的距离计算都不作数\r\n\r\n### Complexity: \r\nTime: O(N)\r\nSpace: O(N)\r\n\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        shortest_distance = []\r\n        lens = len(s)\r\n\r\n        if lens == 1:\r\n            return [0]\r\n        \r\n        k = 10001\r\n        for i in range(0, lens):\r\n            if s[i] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            shortest_distance.append(k)\r\n\r\n        k = 10001\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            if k < shortest_distance[j]:\r\n                shortest_distance[j]=k\r\n\r\n        return shortest_distance\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1304738280","body":"### Idea:\r\nReplace Time by Space, 等pop的时候再处理单个元素，先把应该进行的操作用另一个数组存下\r\n\r\n### Complexity: \r\nTime: all-O(1) \r\nSpace: O(cnt/N), N是操作数\r\n\r\n### Code:\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = []\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.stk.append(x)\r\n            self.incrementals.append(0)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1 \r\n        self.cnt -= 1\r\n        if self.cnt >= 1: \r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stk.pop() + self.incrementals.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals: \r\n            self.incrementals[min(k, self.cnt)-1] += val\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1307215442","body":"### Complexity:\r\nTime & Space: O(S)\r\n\r\n## Solution 1: Stack\r\n### Idea: \r\n见到], 出栈字符串，出栈数字，重新入栈字符串\r\n### Code:\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n        for c in s: \r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stk and stk[-1]!='[':\r\n                    repeatStr = stk.pop() + repeatStr\r\n                stk.pop()\r\n                while stk and stk[-1].isdigit():\r\n                    repeatCount = stk.pop() + repeatCount\r\n                stk.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stk.append(c)\r\n        return \"\".join(stk)  \r\n```\r\n\r\n## Solution 2: Iterative\r\n### Idea:\r\n碰到左括号进⼊递归，碰到右括号就跳出递归返回\r\n\r\n### Code:\r\n```\r\nclass Solution: \r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(start):\r\n            repeatStr = repearCount = '' # \r\n            while start < len(s):\r\n                if s[start].isdigit():\r\n                    repearCount += s[start]\r\n                elif s[start] == '[': # 进入递归条件\r\n                    start, t_str = dfs(start+1)\r\n                    print (start, t_str)\r\n                    repeatStr = repeatStr + t_str*int(repearCount) # 之前递归的结果相加\r\n                    repearCount = ''\r\n                elif s[start] == ']': # 退出递归条件\r\n                    return start, repeatStr\r\n                else: # 最小子问题情况\r\n                    repeatStr += s[start]\r\n                start += 1\r\n            return repeatStr\r\n        return dfs(0)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568728","body":"### Complexity \r\nTime: push O(N), pop/peak/empty O(1)\r\nSpace: O(N)\r\n\r\n### Code \r\n\r\n```\r\nclass MyQueue(object):\r\n    def __init__(self):\r\n        self.in_stk = []\r\n        self.out_stk = []\r\n\r\n    def push(self, x):\r\n        self.in_stk.append(x)\r\n\r\n    def pop(self):\r\n        self.peek()\r\n        return self.out_stk.pop()\r\n\r\n    def peek(self):\r\n        if not self.out_stk:\r\n            while self.in_stk:\r\n                self.out_stk.append(self.in_stk.pop())\r\n        return self.out_stk[-1]\r\n\r\n    def empty(self):\r\n        return not self.in_stk and not self.out_stk\r\n```\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312494167","body":"\r\n### Complexity:\r\nTime: O(1)\r\nSpace: O(n)\r\n\r\n### Code:\r\n```\r\nfrom collections import OrderedDict\r\nclass LRUCache(OrderedDict):\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n     \r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self)> self.capacity:\r\n            self.popitem(last = False)\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320879963","body":"### Complexity:\r\nTime: O(n)\r\nSpace: O(n)\r\n\r\n### Code:\r\n```\r\nclass Solution:\r\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\r\n        table = {}\r\n        for i,x in enumerate(nums):\r\n            y = target - x\r\n            if y in table:\r\n                return [table[y],i]\r\n            else:\r\n                table[x] = i\r\n        return None\r\n```\r\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328052565","body":"#### Complexity:\r\nTime: O(n)\r\nSpace: O(1)\r\n\r\n#### Code: \r\n\r\n```\r\nclass Solution:  \r\n    def removeDuplicates(self, nums: List[int]) -> int:  \r\n        if not nums:  \r\n            return 0  \r\n        n = len(nums)  \r\n        p = q = 0   \r\n        while q<n:  \r\n            if nums[p] ==nums[q]:  \r\n                q +=1  \r\n            else:  \r\n                nums[p+1]=nums[q]  \r\n                p +=1  \r\n                q +=1  \r\n        return p+1  \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304643562","body":"Algorithm\r\n1. add k to the end of the array\r\n2. iterate through array elements,  update carry and add carry to the element ahead\r\n3. after the iteration, if there is still carry, add separate digit ( divmod() or list( map( int,str(carry) ) ) ) to the head of array \r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        A[-1] = A[-1] + k\r\n        \r\n        for i in range(len(A)-1,-1,-1):\r\n            carry, A[i] = divmod(A[i],10)\r\n            if i != 0:\r\n                A[i-1] = A[i-1] + carry\r\n        while carry:\r\n            carry, a = divmod(carry, 10)\r\n            A = [a] + A\r\n\r\n            ## or\r\n\r\n       # if carry:\r\n            # carry = list(map(int, str(carry)))\r\n            # A = carry + A\r\n\r\n        return A\r\n```\r\n\r\ntime: O(M+N)  M -> length of input A, N ->  length of str(carry)\r\nspace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1304656554","body":"Algorithm\r\n1. loop through string from left and record the distance to the left nearest c\r\n2. loop through string from right and update the distance to the right nearest c\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = [0]*len(s)\r\n        \r\n        for p in range(len(s)):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = p - prev\r\n        \r\n        prev = float('inf')\r\n        for p in range(len(s)-1,-1,-1):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = min(ans[p],prev - p)\r\n            \r\n        return ans\r\n```\r\ntime: O(N) N is the length of input string, scan through the string twice\r\nspace: O(N) the size of ans","onTime":false},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1311035828","body":"idea:\r\n\r\nrotate k times equals to rotate k % (length of list) times. after rotate the kth node from end will be the new head of list, and k+1th from end will the new end.\r\n\r\nthus problems becomes find the k+1th from end.\r\n\r\ncode:\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        \r\n        length = 1\r\n        oldEnd = head\r\n        \r\n#         get the length of list\r\n        while oldEnd and oldEnd.next:\r\n            length += 1\r\n            oldEnd = oldEnd.next\r\n            \r\n        k = k % length\r\n        if k == 0:\r\n            return head\r\n#         find the k+1th node, make it the new end, and k th node as the new head, new head point to the old head\r\n        else:\r\n            newEnd = self.findNodeFromEnd(head,k+1)\r\n            print(newEnd)\r\n            newHead = newEnd.next\r\n            newEnd.next = None\r\n            oldEnd.next = head\r\n        return newHead\r\n            \r\n    def findNodeFromEnd(self,head,n):\r\n        p1 = p2 = head\r\n        \r\n        for i in range(n):\r\n            p2 = p2.next\r\n        \r\n        while p2 != None:\r\n            p2 = p2.next\r\n            p1 = p1.next\r\n            \r\n        return p1\r\n```\r\ntime O(n)-> O(n) get length of list + O(N) find the k+1th node from end\r\nspace O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319365483","body":"```python\r\n        \r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        res = []\r\n        node_list = []\r\n        # traverse all node and update colMap\r\n        def traverse(node,row,col):\r\n                if not node:\r\n                    return\r\n\r\n                node_list.append([node.val,row,col])\r\n                traverse(node.left, row+1,col-1)\r\n                traverse(node.right,row+1,col+1)\r\n        \r\n        # traverse tree, and update colMap\r\n        traverse(root,0,0)\r\n        \r\n        # sort rules:\r\n        # 1. sort node by col\r\n        # 2. if col is same, sort by row\r\n        # 3. if row and col is same, sort by node.val \r\n        \r\n        \r\n        # sort cols, and append nodes which in same col into res \r\n        node_list = sorted(node_list, key = lambda x: (x[2], x[1], x[0]))\r\n        node_map = OrderedDict()\r\n        \r\n        for node_val,row,col in node_list:\r\n            if col not in node_map:\r\n                node_map[col] = []\r\n            node_map[col].append(node_val)\r\n            \r\n        return node_map.values()\r\n    \r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321284379","body":"思路\r\n\r\n排列组合： 在n个数中选k个数进行有顺序排列有 n!/(n-k)! 个解。第一步有n个选择，第二步有n-1个选择，以此类推。\r\n对于每一个point，找到和其他point的距离，并将相同距离的points放在一起，用map实现，由于题目不需要知道具体的点坐标，那么统计相同距离的点数量即可。因为已经固定一个点，使用排列组合公式求出n个与其相同距离的点中，选2个数进行有顺序排列的数量，组成一个boomerang，累加到res中。\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\r\n        res = 0 \r\n        \r\n        for x,y in points:\r\n            distance_map = {}\r\n            for a,b in points:\r\n                distance = (x-a)**2 + (y-b)**2\r\n                if distance not in distance_map:\r\n                    distance_map[distance] = 0\r\n                distance_map[distance] += 1\r\n            \r\n            for _,val in distance_map.items():\r\n                if val > 1:\r\n                    res += val*(val-1)\r\n        \r\n        return res\r\n```\r\n\r\ntime: O(n^2)\r\nspace: O(n) for distance_map ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322714307","body":"siding window\r\n\r\n```python\r\nclass Solution:\r\n    def lengthOfLongestSubstring(self, s: str) -> int:\r\n        max_len = 0\r\n        count = {}\r\n        lo = hi = 0\r\n        \r\n        while hi < len(s):\r\n            # update count map\r\n            c = s[hi]\r\n            if c not in count.keys():\r\n                count[c] = 0\r\n            count[c] += 1\r\n            \r\n            # check and remove repeating char\r\n            while count[c] > 1:\r\n                # shrink lo\r\n                remove_c = s[lo]\r\n                count[remove_c] -= 1\r\n                lo += 1\r\n                \r\n            max_len = max(max_len, hi - lo + 1)\r\n            hi += 1\r\n            \r\n        return max_len\r\n```\r\ntime: O(2n) = O(n)O(2n)=O(n). In the worst case each character will be visited twice by lo and hi.\r\nspace: O(n) for sliding window (hashmap)\r\n\r\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328363305","body":"思路\r\n单调队列\r\n\r\n```py\r\nclass Solution:\r\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\r\n        from collections import deque\r\n        q = deque() # stores *indices*\r\n        res = []\r\n        for i, cur in enumerate(nums):\r\n            while q and nums[q[-1]] <= cur:\r\n                q.pop()\r\n            q.append(i)\r\n            # remove first element if it's outside the window\r\n            if q[0] == i - k:\r\n                q.popleft()\r\n            \r\n            if i >= k - 1:\r\n                res.append(nums[q[0]])\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336561445","body":"```py\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        cn1, cn2 = [0] * 26, [0] * 26\r\n        for c in a: cn1[ord(c)-97] += 1\r\n        for c in b: cn2[ord(c)-97] += 1\r\n        \r\n        ans = len(a) + len(b) - max(x + y for x, y in zip(cn1, cn2)) # condition 3\r\n        for i in range(1, 26):  # note that letters can't be smaller than 'a' or bigger than 'z'\r\n            ans = min(ans, sum(cn1[:i]) + sum(cn2[i:]), sum(cn1[i:]) + sum(cn2[:i]))\r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304679567","body":"### Thought:\r\nTake k as carry, add k to the last digit of num array, update k and add to the higher digit of num array.\r\n\r\n### Code\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<>();\r\n        int curNum = 0;\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            curNum = (num[i] + k) % 10;\r\n            ret.add(0, curNum);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k != 0) {\r\n            ret.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return ret;\r\n    }\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(1)","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304929603","body":"```\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        int sz = 1;\n        ListNode oldTail = head;\n\n        //Calculate the size of linkedlist\n        while (oldTail.next != null) {\n            oldTail = oldTail.next;\n            sz++;\n        }\n\n        //Connect the oldtail and head\n        oldTail.next = head;\n\n        //Update k circumvent the repeat procedure\n        k %= sz;\n\n        //Find the newtail after k's operation.\n        ListNode newTail = head;\n        for (int i = 0; i < sz - k - 1; i++) {\n            newTail = newTail.next;\n        }\n\n        //The newhead is next to the newtail\n        ListNode newHead = newTail.next;\n\n        //Break the loop\n        newTail.next = null;\n\n        return newHead;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306556460","body":"Recursive approach:\n```\npublic ListNode swapPairs(ListNode head) {\n        if (head == null || head.next == null)\n            return head;\n        \n        ListNode firstNode = head;\n        ListNode secondNode = firstNode.next;\n\n        firstNode.next = swapPairs(secondNode.next);\n        secondNode.next = firstNode;\n\n        return secondNode;\n        \n    }\n```\nTime complexity: O(N)\nSpace complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308158290","body":"Thought:\nuse fast and slow pointer to find the mid element (which is the root of BST), and use prev pointer to divide left element of mid element, aka left subtree of BST, and right element of root. Find the corner case and recursively find left subtree and right subtree.\n\nCode:\n```\npublic TreeNode sortedListToBST(ListNode head) {\n        if (head == null)\n            return null;\n        \n        ListNode mid = findMid(head);\n        TreeNode n = new TreeNode(mid.val);\n\n        if (head == mid)\n            return n;\n        \n        n.left = sortedListToBST(head);\n        n.right = sortedListToBST(mid.next);\n        return n;\n    }\n\n    public ListNode findMid(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n        ListNode prev = null, slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            prev = slow;\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        if (prev != null) {\n            prev.next = null;\n        }\n        return slow;\n    }\n```\nTime complexity: O(NlogN)\nSpace complexity: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309782606","body":"Thought:\nUsing two pointer to initialize the l1 and l2. Traverse l1 and l2, condition check is when l1 != l2. if l1 and l2 are not the same length, then they would encounter at the intersection point or null. If l1 and l2 are not the same length, they would traverse worst case(l1.length + l2.length) and meet in the intersection point or null.\n```\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode l1 = headA;\n        ListNode l2 = headB;\n        while (l1 != l2) {\n            l1 = l1 == null ? headB : l1.next;\n            l2 = l2 == null ? headA : l2.next;\n        }\n        return l1;\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311352203","body":"Thought:\nUse two pointer, fast and slow pointer to check if there is a cycle in linkedlist. After they met, use another pointer to start from the beginning, traverse with slow pointer in same pace. When they met, the node would be the cycle entrance.\n\nCode:\n```\npublic ListNode cycleDetect(ListNode head) {\n        if (head == null || head.next == null)\n            return null;\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast)\n                return slow;\n        }\n        return null;\n    }\n    public ListNode detectCycle(ListNode head) {\n        if (head == null) return null;\n        ListNode newL = head;\n        ListNode cycle = cycleDetect(head);\n        if (cycle == null) return null;\n        while (newL != cycle) {\n            newL = newL.next;\n            cycle = cycle.next;\n        }\n        return newL;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312388736","body":"Thoughts:\nLearned from leetcode discussion, use hashmap + doubleLinkedList.\n\nCode:\n```\nclass LRUCache {\n    \n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n    \n    private void addNode(DLinkedNode node) {\n        // add node after head;\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n        \n    }\n    \n    private void removeNode(DLinkedNode node) {\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n        \n        prev.next = next;\n        next.prev = prev;\n    }\n    \n    private void moveToHead(DLinkedNode node) {\n        //move some node right after head\n        removeNode(node);\n        addNode(node);\n    }\n    \n    private DLinkedNode popTail() {\n        DLinkedNode ret = tail.prev;\n        removeNode(ret);\n        return ret;\n    }\n    \n    private HashMap<Integer, DLinkedNode> cache = new HashMap<>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n    \n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity  = capacity;\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null)\n            return -1;\n        moveToHead(node);\n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.value = value;\n            newNode.key = key;\n            cache.put(key,newNode);\n            addNode(newNode);\n            size++;\n            if (size > capacity) {\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                size--;\n            }\n        }\n        else {\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}\n```\nTime complexity: O(1)\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312649662","body":"Thought:\r\nRecursive solution. Conduct a boundary check and recursively find the left node and right node of root\r\n\r\nCode:\r\n```\r\npublic int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(logN)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1320813322","body":"Thought:\r\nSame idea as symmetric tree. check boundary condition if p and q are null at the same time, if so return true, else false. then conduct normal recursively check on same node in p and q.\r\n\r\nCode:\r\n```\r\npublic boolean isSameTree(TreeNode p, TreeNode q) {\r\n        TreeNode l1 = p, l2 = q;\r\n        if (l1 == null && l2 == null) return true;\r\n        if (l1 == null || l2 == null) return false;\r\n        return (l1.val == l2.val && isSameTree(l1.left,l2.left) && isSameTree(l1.right, l2.right));\r\n    }\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity:O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1320811449","body":"Thoughts:\r\ndfs, use preorder traversal to concatenate their node value, recursively add them up.\r\n\r\nCode:\r\n```\r\npublic int sumNumbers(TreeNode root) {\r\n        return preorder(root, 0);\r\n\r\n    }\r\n\r\n    int preorder(TreeNode root, int sum) {\r\n        if (root == null) return 0;\r\n        if (root.left == null && root.right == null) {\r\n            sum = sum * 10 + root.val;\r\n            return sum;\r\n        }\r\n        sum = sum * 10 + root.val;\r\n        int left = preorder(root.left, sum);\r\n        int right = preorder(root.right, sum);\r\n        return left + right;\r\n    }\r\n```\r\nTime complexity: O(n);\r\nSpace complexity: O(H)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316207588","body":"Thoughts:\nBFS. Using queue traverse the nodes for each layer from right to left, then root will be the bottom layer leftmost value.\n\nCode:\n```\nQueue<TreeNode> q = new LinkedList<>();\n        q.add(root);\n        while (!q.isEmpty()) {\n            root = q.poll();\n            if (root.right != null)\n                q.add(root.right);\n            if (root.left !=null)\n                q.add(root.left);\n        }\n        return root.val;\n```\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1319738172","body":"Thought:\r\nserialize: using a divider to separate different node, use a string N to denote null value. and dfs for the whole tree.\r\ndeserialize:  dfs the whole deque/queue with each node value till buildup the whole tree\r\n```\r\nprivate static final String divider = \",\";\r\n    private static final String N = \"X\";\r\n    \r\n    // Encodes a tree to a single string.\r\n    public String serialize(TreeNode root) {\r\n        StringBuilder sb = new StringBuilder();\r\n        buildString(root, sb);\r\n        return sb.toString();\r\n    }\r\n    \r\n    private void buildString(TreeNode root, StringBuilder sb) {\r\n        if (root == null)\r\n            sb.append(N).append(divider);\r\n        else {\r\n            sb.append(root.val).append(divider);\r\n            buildString(root.left, sb);\r\n            buildString(root.right, sb);\r\n        }\r\n    }\r\n\r\n    // Decodes your encoded data to tree.\r\n    public TreeNode deserialize(String data) {\r\n        Deque<String> nodes = new LinkedList<>();\r\n        nodes.addAll(Arrays.asList(data.split(divider)));\r\n        return buildTree(nodes);\r\n    }\r\n    \r\n    private TreeNode buildTree(Deque<String> nodes) {\r\n        String val = nodes.remove();\r\n        if (val.equals(N)) return null;\r\n        else {\r\n            TreeNode node = new TreeNode(Integer.valueOf(val));\r\n            node.left = buildTree(nodes);\r\n            node.right = buildTree(nodes);\r\n            return node;\r\n        }\r\n        \r\n    }\r\n```\r\nTime complexity:O(n)\r\nSpace complexity:O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320781302","body":"Thought:\nClassic two sum. use hashmap to store element's value and index. if two number in the map can add up to target, then return these two number's index.\n\nCode:\n```\npublic int[] twoSum(int[] nums, int target) {\n        Map<Integer,Integer> hm = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (hm.containsKey(target - nums[i]))\n                return new int[]{hm.get(target - nums[i]), i};\n            hm.put(nums[i], i);\n        }\n        return null;\n    }\n```\nTime Complexity: O(n)\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1324533650","body":"Thought:\r\nWhen it comes to \"Top K frequent\", I would consider minHeap or maxHeap to do this kind of question. Use a hashmap to store the frequency of integer, and put the frequency into the minHeap. If the heap size larger than k. pop out the first element in queue. After traverse the whole map, everything left in pq is the final answer.\r\n\r\nCode:\r\n```\r\npublic int[] topKFrequent(int[] nums, int k) {\r\n        if (k == nums.length) return nums;\r\n        HashMap<Integer, Integer> hm = new HashMap<>();\r\n        for (int i : nums)\r\n            hm.put(i, hm.getOrDefault(i, 0) + 1);\r\n        \r\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b)-> hm.get(a) - hm.get(b));\r\n\r\n        for (int i : hm.keySet()) {\r\n            pq.add(i);\r\n            if (pq.size() > k) \r\n                pq.poll();\r\n        }\r\n\r\n        int[] ret = new int[k];\r\n        while (k > 0)\r\n            ret[--k] = pq.poll();\r\n        \r\n        return ret;\r\n    }\r\n```\r\nTime Complexity: O(nlogk)\r\nSpace Complexity: O(n + k) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321409351","body":"Thought:\nUse hashmap to store the two points distance, if this distance appeared more than once, then use permutation formula: n * (n - 1) to the final result.\neach traverse for total array should clear map afterwards.\n\nCode:\n```\npublic int numberOfBoomerangs(int[][] points) {\n        int n = points.length;\n        if (n < 3) return 0;\n        int ret = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j) continue;\n                int d = distance(points[i], points[j]);\n                hm.put(d, hm.getOrDefault(d,0) + 1);\n            }\n            for (int val : hm.values())\n                ret += val * (val - 1);\n            hm.clear();\n        }\n        \n        return ret;\n    }\n\n    int distance(int[] x, int[] y) {\n        return (y[0] - x[0]) * (y[0] - x[0]) + (y[1] - x[1]) * (y[1] - x[1]);\n    }\n```\nTime Complexity: O(n^2)\nSpace Complexity: O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328810844","body":"Code:\r\n```\r\nListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n```\r\nTIme complexity: O(n);\r\nSpace complexity:O(1);","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328813216","body":"Thought: two pointer\r\nCode:\r\n```\r\nif (nums.length == 1) return 1;\r\n        int l = 1;\r\n        for (int i = 0; i < nums.length - 1; i++) {\r\n            if (nums[i] != nums[i + 1])  {\r\n                nums[l] = nums[i + 1];\r\n                l++;\r\n            }\r\n\r\n        }\r\n        \r\n        return l;\r\n```\r\ntime complexity:O(n)\r\nspace complexity:O(1)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823818","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305784520","body":"class Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304848673","body":"```py\r\nclass Solution:\r\n    def addToArrayForm(self, nums: List[int], k: int) -> List[int]:\r\n        n = len(nums)\r\n        num = 0\r\n        for i in range(n):\r\n            num = num * 10 + nums[i]\r\n            \r\n            \r\n        num += k\r\n        result = []\r\n        while num > 0:\r\n            result.append(num % 10)\r\n            num //= 10\r\n            \r\n            \r\n        return result[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1304853414","body":"two pass, one pass check from left, one pass check from right\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        result = [n] * n\r\n        \r\n        pos = n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = abs(i - pos)\r\n            \r\n        pos = 0\r\n        for i in reversed(range(n)):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = min(result[i], abs(i-pos))\r\n            \r\n            \r\n        return result\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1304868133","body":"\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)            \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            return self.stack.pop(-1)\r\n        \r\n        return -1\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304918160","body":"\r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if s.find('[') == -1:\r\n            return s\r\n        bracketStack = []\r\n        digitStack = []\r\n        n = len(s)\r\n                \r\n        leftBracket, rightBracket = -1, -1\r\n        digitPos = -1\r\n        digit = -1\r\n        for i in range(n):\r\n            if s[i].isdigit():\r\n                if digitPos == -1:\r\n                    digitPos = i\r\n                \r\n                digitStack.append(int(s[i]))\r\n               \r\n            if s[i] == '[':\r\n                if digit == -1:\r\n                    digit = self.getDigit(digitStack)\r\n                bracketStack.append(i)\r\n                if leftBracket == -1:\r\n                    leftBracket = i\r\n            if s[i] == ']':\r\n                bracketStack.pop()\r\n                if len(bracketStack) == 0:\r\n                    rightBracket = i               \r\n                    break\r\n        \r\n        a = s[:digitPos]\r\n        b = digit * self.decodeString(s[leftBracket+1: rightBracket])\r\n        c = self.decodeString(s[rightBracket+1:])\r\n        \r\n        return  a + b + c\r\n                    \r\n    def getDigit(self, stack: List[int]) -> int:\r\n        result = 0\r\n        for num in stack:\r\n            result = result * 10 + num\r\n            \r\n        return result\r\n                    \r\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304844838","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return \r\n        dummyHead = ListNode(next=head)\r\n\r\n        n = self.getLength(head)\r\n        k = k % n\r\n        \r\n        # get the right side head\r\n        cur = dummyHead\r\n        for i in range(n - k):\r\n            cur = cur.next\r\n            \r\n        newHead = cur.next\r\n        cur.next = None\r\n        \r\n        \r\n        # keep the oldHead\r\n        oldHead = head\r\n        \r\n        \r\n        # connect the oldHead to the tail of prev right side\r\n        dummyHead.next = newHead\r\n        cur = dummyHead\r\n        while cur.next:\r\n            cur = cur.next\r\n        \r\n        cur.next= oldHead\r\n        \r\n        return dummyHead.next\r\n        \r\n        \r\n    def getLength(self, head: Optional[ListNode]) -> int:\r\n        result = 0\r\n        dummyHead = ListNode(next=head)\r\n        cur = dummyHead\r\n        while cur.next:\r\n            result += 1\r\n            cur = cur.next\r\n        \r\n        return result\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309389643","body":"获取两个链表的长度， 两个长度的差值则是分别从头开始往后走的差值\n```py\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:\n        if headA == None or headB == None:\n            return None\n        \n        lenA, lenB = self.getLen(headA), self.getLen(headB)\n        longerHead, shorterHead = headA if lenA > lenB else headB,  headB if lenA > lenB else headA\n        \n        for i in range(abs(lenA - lenB)):\n            longerHead = longerHead.next\n        \n        while longerHead:\n            if longerHead == shorterHead:\n                return longerHead\n            longerHead = longerHead.next\n            shorterHead = shorterHead.next\n        \n        return None\n            \n    \n    def getLen(self, head: ListNode) -> int:\n        count = 0\n        dummy = ListNode(next=head)\n        while dummy:\n            dummy = dummy.next\n            count += 1\n        return count\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312763659","body":"```py\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        \r\n        result = self.cache[key]\r\n        self.cache.move_to_end(key, last=False)\r\n        \r\n        return result\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            self.cache[key] = value\r\n            self.cache.move_to_end(key, last=False)\r\n            if len(self.cache) > self.capacity:\r\n                self.cache.popitem()\r\n            \r\n            return\r\n        \r\n        \r\n        # key in self.cache\r\n        self.cache[key] = value\r\n        self.cache.move_to_end(key, last=False)\r\n        \r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762077","body":"```py\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        return max(self.maxDepth(root.left) + 1, self.maxDepth(root.right) + 1)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312805832","body":"```py\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if not p or not q:\n            return False\n        \n        if p.val != q.val:\n            return False\n        \n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304924255","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(k == 0 || head == null || head.next == null) return head;\n        // count the number of list\n        ListNode countNode = head; \n        int count;\n        for( count = 1; countNode.next != null; count++){\n            countNode = countNode.next;\n        }\n        // make a circle \n        countNode.next = head;\n        ListNode tail = countNode;\n        ListNode prev = head;\n        for(int i = 0; i < count - k%count; i++ ){\n            tail = tail.next;\n        }\n        prev = tail.next;\n        tail.next = null;\n        return prev;\n\n    \n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309752034","body":"# 思路 \n假设两个链表有交点，A链表交点前的长度为A，B交点前的长度为B，共同交点后面的长度为C，遍历A链表的长度为A+C\n遍历B链表的长度为B+C，遍历完两个链表分别再遍历B和A链表，在交点前的遍历的总长度分别为A+C+B 和 B + C + A,相等的，\n相等时就是交点，返回一个指针。\n当不相交的时候，因为两个指针都遍历的两个链表，所以当遍历完的时候两个指针也是相等的，等于null；\n## 代码\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        ListNode pA = headA;\n        ListNode pB = headB;\n        // if pA.next is not null, pA = pA.next\n        // if pA.next is null, pA = headB;\n        // if pB.next is null, pB = headA;\n        // if pB.next is not null, pB = pB.next\n        while(pA != pB){\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n```\n## 复杂度\ntime O(N)\nspace O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311227759","body":"# 解题思路\nspace O(N), use hashset to store the listNode, when there is exist same listnode in hashset, return this node.\n\nspace O(1), slow pointer moves 1 step, fast pointer moves 2 steps.\n## 代码\n```java \n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        // check whether head is null\n        if(head == null){\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(fast != null){\n            slow = slow.next;\n            if(fast.next != null){\n                fast = fast.next.next;\n            }\n            else{\n                return null;\n            }\n            if(fast == slow){\n                ListNode ptr = head;\n                while(ptr != slow){\n                    ptr = ptr.next;\n                    slow = slow.next;\n                }\n                return ptr;\n            }\n        }\n        return null;\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313149577","body":"# 思路\n递归\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null){\n            return true;\n        }\n        if(p == null || q == null){\n            return false;\n        }\n        if(p.val != q.val){\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1319468341","body":"# 递归\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int sumNumbers(TreeNode root) {\r\n        //DFS\r\n        return dfsNums( root, 0);\r\n    \r\n    }\r\n    \r\n    public int dfsNums( TreeNode root, int sum){\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        sum = sum * 10 + root.val;\r\n        if(root.left == null && root.right == null){\r\n            return sum;\r\n        }\r\n        return dfsNums(root.left, sum) + dfsNums(root.right, sum);\r\n    }\r\n}","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320683270","body":"# 思路\n\n哈希表，key存target-nums[i] 更高效，当nums[i] 与已知的key相等的时候，返回\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashmap = new HashMap<>();\n        for(int i = 0; i < nums.length; i++){\n            if(hashmap.containsKey(nums[i]))\n                return new int[]{ hashmap.get(nums[i]), i,};\n            hashmap.put(target - nums[i], i);\n        }\n        return new int[]{};\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327068883","body":"# 思路\r\n快慢指针，一步两步\r\n```java\r\nclass Solution {\r\n    public ListNode middleNode(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while( fast != null && fast.next != null ){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n时间复杂度O(n), 空间O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1332885766","body":"```java\r\nclass Solution {\r\n    \r\n    class MonotonicQueue {\r\n        LinkedList<Integer> q = new LinkedList<>();\r\n        public void push(int n) {\r\n\r\n            while (!q.isEmpty() && q.getLast() < n) {\r\n                q.pollLast();\r\n            }\r\n            q.addLast(n);\r\n        }\r\n\r\n        public int max() {\r\n            return q.getFirst();\r\n        }\r\n\r\n        public void pop(int n) {\r\n            if (n == q.getFirst()) {\r\n                q.pollFirst();\r\n            }\r\n        }\r\n    }\r\n\r\n   \r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        MonotonicQueue window = new MonotonicQueue();\r\n        List<Integer> res = new ArrayList<>();\r\n\r\n        for (int i = 0; i < nums.length; i++) {\r\n            if (i < k - 1) {              \r\n                window.push(nums[i]);\r\n            } else {               \r\n                window.push(nums[i]);               \r\n                res.add(window.max());            \r\n                window.pop(nums[i - k + 1]);\r\n            }\r\n        }\r\n   \r\n        int[] arr = new int[res.size()];\r\n        for (int i = 0; i < res.size(); i++) {\r\n            arr[i] = res.get(i);\r\n        }\r\n        return arr;\r\n    }\r\n}","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334790273","body":"```java\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        x = y = 0\n        for move in moves:\n            if move == 'U': y -= 1\n            elif move == 'D': y += 1\n            elif move == 'L': x -= 1\n            elif move == 'R': x += 1\n\n        return x == y == 0","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305034426","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果是空和只有一个元素链表就直接返回\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        int len = 1, index;\r\n        ListNode temp = head,newHead;\r\n        //计算链表长度\r\n        while(temp.next != null){\r\n            len++;\r\n            temp = temp.next;\r\n        }\r\n    \r\n    //将列表设为循环链表\r\n        temp.next = head;\r\n        k %= len;\r\n        index = len - k;\r\n        //找到要断开循环链表的结点 记录链表新的头节点\r\n        while (index-- > 0) {\r\n            temp = temp.next;\r\n        }\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312762888","body":"```\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) return 0;\n        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanshuiqiankun":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305289929","body":"思路：1.假设有N个元素，将链表元素向右移动k个位置。\n           2.将n-k个元素采用头插法插入链表。\n代码：\nstruct ListNode* rotateRight(struct ListNode* head, int k){\n    struct ListNode* p, *q;\n    int i,n = 1;\n    if(head==NULL)\n    {\n         return NULL;\n    }\n    for(p=head; p->next!=NULL; p=p->next)\n    {\n         n++;\n    }\n    k %= n;\n    q = p;\n    for(p=head,i=0; n-k-1!=i; p=p->next,i++);\n    q->next = head;\n    head = p->next;\n    p->next=NULL;\n    return head;\n}\n时间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1307139487","body":"思路：使用递归的方式解答该题更加简便；\n          每次做了两个结点的交换并且连接下一个头结点。\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {       \n        if(head == nullptr || head->next == nullptr)\n        return head;\n        ListNode* next = head->next;\n        head->next = swapPairs(next->next);\n        next->next = head;\n        return next;//每一次返回交换那个头结点。\n    }\n}\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"annabellhyx":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305768345","body":"```JavaScript\r\nvar rotateRight = function(head, k) {\r\n    if(!head) return head\r\n    let prev = head, cur = head, tail\r\n    let len = 1\r\n\r\n    while(cur.next) {\r\n        cur = cur.next\r\n        len++\r\n    }\r\n    k %= len\r\n    if(k == 0) return head\r\n\r\n    tail = cur\r\n    cur = head\r\n    for(let i = 0; i < len - k; i++) {\r\n        prev = cur\r\n        cur = cur.next\r\n    }\r\n\r\n    tail.next = head\r\n    prev.next = null\r\n    \r\n    return cur\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305788422","body":"``` python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k == 0 or not head or not head.next:\n            return head\n        \n        n = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next = head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        return ret\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313876227","body":"```javascript\nvar isSameTree = function(p, q) {\n    let pQ = [p], qQ = [q], res = true\n\n    while (pQ.length) {\n        pNode = pQ.shift()\n        qNode = qQ.shift()\n\n        if (pNode === null && qNode === null) {\n            res = true\n        } else if (pNode === null || qNode === null) {\n            res = false\n            break \n        } else {\n            if (pNode.val !== qNode.val) {\n                res = false\n                break \n            } else {\n                pQ.push(pNode.left)\n                pQ.push(pNode.right)\n\n                qQ.push(qNode.left)\n                qQ.push(qNode.right)\n            }\n        }\n    }\n\n    return res\n};\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321112579","body":"```python\nclass Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dict ={}\n        nums.sort()\n        length = len(nums)\n        for i in nums:\n            dict[i] = dict.get(i,0)+1\n        dict = sorted(dict.items(), key=lambda dict:dict[1], reverse=True)\n        res = []\n        for x, y in dict:\n            res.append(x)\n        return res[:k]\n\n```\n","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328093761","body":"```javascript\nvar searchInsert = function(nums, target) {\n    const n = nums.length;\n    let left = 0, right = n - 1, ans = n;\n    while (left <= right) {\n        let mid = ((right - left) >> 1) + left;\n        if (target <= nums[mid]) {\n            ans = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    return ans;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306558053","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1310432319","body":"Idea: \r\nThe key idea is to set pointers to each head and let the pointer run through each linkedlist once. If the two linkedlists do have intersection, they will definitely meet at that node during the traversal. If the two linkedlists don't, they will both reach to the null value at the tail of each linkedlist. \r\n\r\n```python\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        pA, pB = headA, headB \r\n\r\n        while pA != pB: \r\n            if not pA:\r\n                pA = headB \r\n            else: \r\n                pA = pA.next \r\n            if not pB: \r\n                pB = headA \r\n            else: \r\n                pB = pB.next \r\n\r\n        return pA \r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311925801","body":"```java \r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        fast, slow = head, head \r\n\r\n        while fast and fast.next: \r\n            fast = fast.next.next \r\n            slow = slow.next \r\n\r\n            if fast == slow: \r\n                break \r\n        if not fast or not fast.next: \r\n            return None\r\n \r\n        slow = head\r\n        while fast != slow: \r\n            fast = fast.next \r\n            slow = slow.next \r\n\r\n        return slow\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312534144","body":"```python\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.head = Node(-1, -1)\r\n        self.tail = Node(-1, -1)\r\n        self.head.next = self.tail \r\n        self.tail.prev = self.head \r\n        self.hashtable = {}\r\n        self.capacity = capacity \r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.hashtable: \r\n            return -1 \r\n        node = self.hashtable[key]\r\n        self.put_in_front(node)\r\n        return node.val \r\n\r\n    def put_in_front(self, node): \r\n        left = node.prev \r\n        right = node.next \r\n\r\n        \"break process, break left, break right, connect left and right\"\r\n        if left: \r\n            left.next  = node.next \r\n            node.prev = None \r\n        if right: \r\n            node.next = None \r\n            right.prev = left \r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node \r\n        node.prev = self.head \r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.hashtable: \r\n            node = self.hashtable[key]\r\n            node.val = value \r\n            self.put_in_front(node)\r\n        else: \r\n            node = Node(key, value)\r\n            self.hashtable[key] = node \r\n            self.put_in_front(node)\r\n            \r\n            \"evict the least used key\"\r\n            if len(self.hashtable) > self.capacity: \r\n               \r\n                to_evict = self.tail.prev \r\n                key_to_evict = to_evict.key\r\n                del self.hashtable[key_to_evict]\r\n                left = to_evict.prev \r\n                right = to_evict.next \r\n                to_evict.prev, to_evict.next = None, None \r\n                left.next, right.prev = right, left\r\n        \r\n\r\nclass Node(object): \r\n    def __init__(self, key, val): \r\n        self.val = val\r\n        self.key = key\r\n        self.prev = None \r\n        self.next = None \r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312739637","body":"```java\r\nvar maxDepth = function (root) {\r\n  if(!root) return 0;\r\n  let quene = []\r\n  quene.push(root)\r\n  let i = 0\r\n  while (quene.length) {\r\n      let curLevel = quene\r\n      quene = [];\r\n      i++;\r\n      for (let i = 0; i < curLevel.length; i++) {\r\n          if (curLevel[i].left) {\r\n              quene.push(curLevel[i].left)\r\n          }\r\n          if (curLevel[i].right) {\r\n              quene.push(curLevel[i].right)\r\n          }\r\n      }\r\n  }\r\n return i;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1312968399","body":"```python\r\nclass Solution:\r\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif p is None and q is not None:\r\n            return False\r\n        elif p is not None and q is None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1315352286","body":"```python\r\nvar sumNumbers = function(root) {\r\n   let result = []\r\n    if (root == null) {\r\n        return result\r\n    }\r\n    let dfs = (node, path) => {\r\n        path.push(node.val)\r\n        if (node.left == null && node.right == null) {\r\n            result.push([...path].join(''))\r\n            path.pop()\r\n            return\r\n        }\r\n        if (node.left != null) {\r\n            dfs(node.left, path)\r\n        }\r\n        if (node.right != null) {\r\n            dfs(node.right, path)\r\n        }\r\n        path.pop()\r\n    }\r\n    dfs(root, [], 0);\r\n\r\n    let sum = 0;\r\n    for(let i=0;i<result.length;i++) {\r\n        sum += parseInt(result[i]);\r\n    }\r\n\r\n    return sum;\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316969990","body":"```python\r\nclass Solution:\r\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\r\n        curVal = curHeight = 0\r\n        def dfs(node: Optional[TreeNode], height: int) -> None:\r\n            if node is None:\r\n                return\r\n            height += 1\r\n            dfs(node.left, height)\r\n            dfs(node.right, height)\r\n            nonlocal curVal, curHeight\r\n            if height > curHeight:\r\n                curHeight = height\r\n                curVal = node.val\r\n        dfs(root, 0)\r\n        return curVal\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1320960634","body":"```python\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        # 考虑最基本的情况，当一个节点为空节点的时候用什么字符代替\r\n        if not root:\r\n            return 'x'\r\n        # 对树进行先序遍历\r\n        return ','.join([str(root.val),self.serialize(root.left),self.serialize(root.right)])\r\n\r\n    def deserialize(self, data):\r\n        # 遇到x则置为null\r\n        self.data = data\r\n        if self.data[0] == 'x':\r\n            return None\r\n        node = TreeNode(self.data[:self.data.find(',')])\r\n        node.left = self.deserialize(self.data[self.data.find(',')+1:])\r\n        node.right = self.deserialize(self.data[self.data.find(',')+1:])\r\n        return node\r\n\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320960578","body":"```python\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        self.info = []\r\n        self.dfs(root, 0, 0)\r\n\r\n        info = sorted(self.info)\r\n        ans = [[]]\r\n        pre_col = info[0][0]\r\n        for col, row, val in info:\r\n            if col == pre_col:\r\n                ans[-1].append(val)\r\n            else:\r\n                ans.append([val])\r\n                pre_col = col\r\n        return ans\r\n\r\n    def dfs(self, root, row, col):\r\n        if not root:\r\n            return None\r\n        self.info.append((col, row, root.val))\r\n        self.dfs(root.left, row + 1, col - 1)\r\n        self.dfs(root.right, row + 1, col + 1)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320960409","body":"```java\r\nclass Solution {\r\n    public int[] twoSum(int[] nums, int target) {\r\n        int N = nums.length;\r\n        for (int i = 1; i < N; i++) {\r\n            for (int j = i; j < N; j++) {\r\n                if (nums[j] + nums[j - i] == target) {\r\n                    return new int[] {j, j - i};\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320960514","body":"```java\r\n\r\nclass Solution {\r\n    public int[] topKFrequent(int[] nums, int k) {\r\n        Map<Integer, Integer> counts = new HashMap<>();\r\n        for (int n: nums) {\r\n            counts.put(n, counts.getOrDefault(n, 0) + 1);\r\n        }\r\n        int[] res = new int[k];\r\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>(\r\n            (a, b) -> counts.get(a) - counts.get(b)\r\n        );\r\n        for (int key: counts.keySet()) {\r\n            minHeap.offer(key);\r\n            if (minHeap.size() > k) {\r\n                minHeap.poll();\r\n            }\r\n        }\r\n        for (int i = 0; i < k; i++) {\r\n            res[i] = minHeap.poll();\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325409218","body":"```java\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> res = new ArrayList();\r\n        if (s == null || s.length() == 0 || words == null || words.length == 0){\r\n             return res;\r\n        }\r\n        int n = s.length();\r\n        int m = words.length;\r\n        int w = words[0].length();\r\n\r\n        //预处理，统计 words 中每个单词的数量\r\n        Map<String, Integer> total = new HashMap();\r\n        for (String word : words) {\r\n            total.put(word, total.getOrDefault(word, 0) + 1);\r\n        }\r\n\r\n        for (int i = 0; i < w; ++i) {\r\n            HashMap<String, Integer> wd = new HashMap<>();\r\n            // 统计窗口内单词在 words 中出现的次数\r\n            int cnt = 0; \r\n            for (int j = i; j + w <= n; j += w) {\r\n                //窗口已经满，需要去掉窗口最左边的单词，才能在窗口中添加新的单词\r\n                if (j >= i + w * m) {\r\n                    //获取窗口最左边的单词\r\n                    String word = s.substring(j - m * w, w + j - m * w); \r\n                    //去除窗口最左边的单词\r\n                    wd.put(word, wd.get(word) - 1); \r\n                    if (total.get(word) != null && wd.get(word) < total.get(word))\r\n                        cnt--;\r\n                }\r\n                String word = s.substring(j, j + w); \r\n                wd.put(word, wd.getOrDefault(word, 0) + 1); //在窗口最右边添加新的单词\r\n                if (total.get(word) != null && wd.get(word) <= total.get(word)){\r\n                    cnt++;\r\n                }\r\n                if (cnt == m){\r\n                    res.add(j - (m - 1) * w);\r\n                }\r\n            }\r\n        }\r\n        return res; \r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325957520","body":"```python\r\n\r\nclass Solution:\r\n    def solve(self, nums, k):\r\n        total = sum(nums)\r\n        mod = total % k\r\n\r\n        ans = len(nums)\r\n        total = 0\r\n        dic = {0: -1}\r\n        for j in range(len(nums)):\r\n            total += nums[j]\r\n            cur = total % k\r\n            target = (cur - mod + k) % k\r\n            if target in dic:\r\n                ans = min(ans, j - dic[target])\r\n            dic[cur] = j\r\n\r\n        if ans == len(nums):\r\n            return -1\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327775989","body":"```python\r\n\r\n\r\nclass Solution:\r\n    def middleNode(self, head: ListNode) -> ListNode:\r\n        if head is None:\r\n            return None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        return slow\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328301858","body":"```java \r\nclass Solution {\r\n    public int removeDuplicates(int[] nums) {\r\n        int n = nums.length;\r\n        int j = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (nums[i] != nums[j]) {\r\n                nums[++j] = nums[i];\r\n            }\r\n        }\r\n        return j + 1;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328301759","body":"```javascript\r\nvar searchInsert = function(nums, target) {\r\n    let low = 0;\r\n    let high = nums.length - 1;\r\n     while (low <= high) {\r\n        let mid = Math.floor((low + high) / 2);\r\n        if (nums[mid] == target) {\r\n            return mid\r\n        } else if (nums[mid] < target) {\r\n            low = mid + 1\r\n        } else {\r\n            high = mid - 1\r\n        }\r\n    }\r\n    return low;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1332977397","body":"```java\r\n\r\n\r\nclass Solution {\r\n    public int[] maxSlidingWindow(int[] nums, int k) {\r\n        int n = nums.length;\r\n        PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {\r\n            public int compare(int[] pair1, int[] pair2) {\r\n                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];\r\n            }\r\n        });\r\n        for (int i = 0; i < k; ++i) {\r\n            pq.offer(new int[]{nums[i], i});\r\n        }\r\n        int[] ans = new int[n - k + 1];\r\n        ans[0] = pq.peek()[0];\r\n        for (int i = k; i < n; ++i) {\r\n            pq.offer(new int[]{nums[i], i});\r\n            while (pq.peek()[1] <= i - k) {\r\n                pq.poll();\r\n            }\r\n            ans[i - k + 1] = pq.peek()[0];\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1332976869","body":"```java  \r\n\r\n/**\r\n\tTC: O(n)\tSC: O(n)\r\n*/\r\nclass Solution {\r\n    public int findJudge(int N, int[][] trust) {\r\n        if (trust.length < N - 1) \r\n            return -1;\r\n        \r\n        int[] trustScores = new int[N + 1]; // 初始信用分都为 0, 包括法官对自己\r\n        \r\n        for (int[] t : trust) {\r\n            trustScores[t[1]]++;\r\n            trustScores[t[0]]--;\r\n        }\r\n        \r\n        for (int i = 1; i <= N; i++) {\r\n            if (trustScores[i] == N - 1)\r\n                return i;\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332976333","body":"```python\r\n\r\nimport collections\r\n\r\n\r\nclass Solution(object):\r\n    def possibleBipartition(self, n, dislikes):\r\n        Not_COLORED,BLUE,GREEN = 0,1,-1\r\n        def helper(person_id,color):\r\n            color_table[person_id] = color\r\n            for the_other in dislike_table[person_id]:\r\n                if color_table[the_other] == color:\r\n                    return False\r\n                if color_table[the_other] == Not_COLORED and not helper(the_other,-color):\r\n                    return False\r\n            return True\r\n        if n==1 or not dislikes:\r\n            return True\r\n        dislike_table = collections.defaultdict(list)\r\n        color_table = collections.defaultdict(int)\r\n        for p1,p2 in dislikes:\r\n            dislike_table[p1].append(p2)\r\n            dislike_table[p2].append(p1)\r\n        for person_id in range(1,n+1):\r\n            if color_table[person_id] == Not_COLORED and not helper(person_id,BLUE):\r\n                return False\r\n        return True\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333689044","body":"```java \r\n\r\nclass Solution {\r\n\r\n    public int[] sortItems(int n, int m, int[] group, List<List<Integer>> beforeItems) {\r\n        // 第 1 步：数据预处理，给没有归属于一个组的项目编上组号\r\n        for (int i = 0; i < group.length; i++) {\r\n            if (group[i] == -1) {\r\n                group[i] = m;\r\n                m++;\r\n            }\r\n        }\r\n\r\n        // 第 2 步：实例化组和项目的邻接表\r\n        List<Integer>[] groupAdj = new ArrayList[m];\r\n        List<Integer>[] itemAdj = new ArrayList[n];\r\n        for (int i = 0; i < m; i++) {\r\n            groupAdj[i] = new ArrayList<>();\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            itemAdj[i] = new ArrayList<>();\r\n        }\r\n\r\n        // 第 3 步：建图和统计入度数组\r\n        int[] groupsIndegree = new int[m];\r\n        int[] itemsIndegree = new int[n];\r\n\r\n        int len = group.length;\r\n        for (int i = 0; i < len; i++) {\r\n            int currentGroup = group[i];\r\n            for (int beforeItem : beforeItems.get(i)) {\r\n                int beforeGroup = group[beforeItem];\r\n                if (beforeGroup != currentGroup) {\r\n                    groupAdj[beforeGroup].add(currentGroup);\r\n                    groupsIndegree[currentGroup]++;\r\n                }\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            for (Integer item : beforeItems.get(i)) {\r\n                itemAdj[item].add(i);\r\n                itemsIndegree[i]++;\r\n            }\r\n        }\r\n\r\n        // 第 4 步：得到组和项目的拓扑排序结果\r\n        List<Integer> groupsList = topologicalSort(groupAdj, groupsIndegree, m);\r\n        if (groupsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n        List<Integer> itemsList = topologicalSort(itemAdj, itemsIndegree, n);\r\n        if (itemsList.size() == 0) {\r\n            return new int[0];\r\n        }\r\n\r\n        // 第 5 步：根据项目的拓扑排序结果，项目到组的多对一关系，建立组到项目的一对多关系\r\n        // key：组，value：在同一组的项目列表\r\n        Map<Integer, List<Integer>> groups2Items = new HashMap<>();\r\n        for (Integer item : itemsList) {\r\n            groups2Items.computeIfAbsent(group[item], key -> new ArrayList<>()).add(item);\r\n        }\r\n\r\n        // 第 6 步：把组的拓扑排序结果替换成为项目的拓扑排序结果\r\n        List<Integer> res = new ArrayList<>();\r\n        for (Integer groupId : groupsList) {\r\n            List<Integer> items = groups2Items.getOrDefault(groupId, new ArrayList<>());\r\n            res.addAll(items);\r\n        }\r\n        return res.stream().mapToInt(Integer::valueOf).toArray();\r\n    }\r\n\r\n    private List<Integer> topologicalSort(List<Integer>[] adj, int[] inDegree, int n) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Queue<Integer> queue = new LinkedList<>();\r\n        for (int i = 0; i < n; i++) {\r\n            if (inDegree[i] == 0) {\r\n                queue.offer(i);\r\n            }\r\n        }\r\n\r\n        while (!queue.isEmpty()) {\r\n            Integer front = queue.poll();\r\n            res.add(front);\r\n            for (int successor : adj[front]) {\r\n                inDegree[successor]--;\r\n                if (inDegree[successor] == 0) {\r\n                    queue.offer(successor);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (res.size() == n) {\r\n            return res;\r\n        }\r\n        return new ArrayList<>();\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334655977","body":"```java \r\n\r\nclass Solution {\r\n    public boolean judgeCircle(String moves) {\r\n        int x = 0,y=0;\r\n        char[] c = moves.toCharArray();\r\n        for(char each:c){\r\n            if(each-'U' == 0){\r\n                y--;\r\n            }else if(each - 'D' == 0){\r\n                y++;\r\n            }else if(each - 'L' == 0){\r\n                x--;\r\n            }else if(each - 'R' == 0){\r\n                x++;\r\n            }\r\n        }\r\n\r\n        if(x == 0 && y ==0){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336306498","body":"```java\r\n\r\nclass Solution {\r\n    public int[] getOrder(int[][] tasks) {\r\n        // 模拟获得顺序，或者说排序\r\n        int n = tasks.length;\r\n        // 进入的时间，耗时，编号\r\n        PriorityQueue<int[]> waitTasks = new PriorityQueue<>( (a, b) -> {\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            else if (a[1] != b[1]) return a[1] - b[1];\r\n            return a[2] - b[2];\r\n        });\r\n        // 耗时，编号\r\n        PriorityQueue<int[]> sortTasks = new PriorityQueue<>( (a, b) -> {\r\n            if (a[0] != b[0]) return a[0] - b[0];\r\n            return a[1] - b[1];\r\n        });\r\n        for (int i = 0; i < n; i++) {\r\n            waitTasks.offer(new int[]{tasks[i][0], tasks[i][1], i});\r\n        }\r\n        int[] ans = new int[n];\r\n        int cnt = 0, time = 1;\r\n        while (!waitTasks.isEmpty()) {\r\n            boolean allNotInTime = true;\r\n            while (!waitTasks.isEmpty() && waitTasks.peek()[0] <= time) {\r\n                allNotInTime = false;\r\n                int[] cur = waitTasks.poll();\r\n                sortTasks.add(new int[]{cur[1], cur[2]});\r\n            }\r\n            if (allNotInTime && sortTasks.isEmpty()) {\r\n                int[] cur = waitTasks.poll();\r\n                sortTasks.add(new int[]{cur[1], cur[2]});\r\n            }\r\n            int[] cur = sortTasks.poll();\r\n            ans[cnt++] = cur[1];\r\n            time = Math.max(time, tasks[cur[1]][0]) + cur[0];\r\n        }\r\n        while (!sortTasks.isEmpty()) {\r\n            ans[cnt++] = sortTasks.poll()[1];\r\n        }\r\n        return ans;\r\n    }\r\n} \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1341382913","body":"```python\r\n\r\nclass Solution:\r\n    def numberOfRounds(self, s, f):\r\n        sh, sm = s.split(\":\")\r\n        eh, em = f.split(\":\")\r\n        sh, sm, eh, em = int(sh), int(sm), int(eh), int(em)\r\n        if sh == eh:\r\n            if sm <= em:\r\n                d = em//15-(sm//15)-(1 if sm % 15 > 0 else 0)\r\n                return d if d > 0 else 0\r\n            else:\r\n                sm = 60-sm\r\n                val = 0\r\n                val += sm//15\r\n                val += em//15\r\n                return 23*4+val\r\n        else:\r\n            if eh < sh:\r\n                eh += 24\r\n            val = 0\r\n            sm = 60-sm\r\n            val += sm//15\r\n            val += em//15\r\n            sh += 1\r\n            return (eh-sh)*4+val\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1341383560","body":"```python\r\nclass Solution:\r\n    def minCharacters(self, a: str, b: str) -> int:\r\n        def count(s):\r\n            arr = [0 for i in range(26)]\r\n            for c in s:\r\n                arr[ord(c) - ord('a')] += 1\r\n            return arr\r\n        \r\n        c1 = count(a)\r\n        c2 = count(b)\r\n        \r\n        def helper(c1, c2):\r\n            res = float('inf')\r\n            moveC1 = sum(c1) # move all in c1 to be less or equal\r\n            moveC2 = 0 # move all in c2 to be greater\r\n            for i in range(25):\r\n                moveC1 -= c1[i]\r\n                moveC2 += c2[i]\r\n                res = min(res, moveC1 + moveC2)\r\n            return res\r\n        \r\n        def helper3(c1, c2):\r\n            res = float('inf')\r\n            sum1 = sum(c1)\r\n            sum2 = sum(c2)\r\n            for i in range(26):\r\n                res = min(res, sum1 - c1[i] + sum2 - c2[i])\r\n            return res\r\n        \r\n        res1 = helper(c1, c2)\r\n        res2 = helper(c2, c1)\r\n        res3 = helper3(c1, c2)\r\n        return min([res1, res2, res3])\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1341385325","body":"```python\r\n\r\nclass Solution:\r\n    def sortArray(self, nums: List[int]) -> List[int]:\r\n        self.mergesort(nums,0,len(nums)-1)\r\n        return nums\r\n    \r\n    def mergesort(self, nums, l, r):\r\n        if l == r:\r\n            return None\r\n        mid = (l+r)//2\r\n        self.mergesort(nums, l, mid)\r\n        self.mergesort(nums, mid+1,r)\r\n        tmp = []\r\n        i = l\r\n        j = mid +1\r\n        while i <= mid or j <= r:\r\n            if i>mid or (j<=r and nums[j]<nums[i]):\r\n                tmp.append(nums[j])\r\n                j += 1\r\n            else:\r\n                tmp.append(nums[i])\r\n                i += 1\r\n        nums[l:r+1] = tmp   \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1341385786","body":"```python\r\n\r\nclass Solution {\r\n    public int mySqrt(int x) {\r\n        int l = 0, r = x;\r\n        int mid = 0;\r\n        int ans = -1;\r\n        while (l <= r) {\r\n            mid = l + (r - l) / 2;\r\n            if ((long) mid * mid <= x) { // convert to long to avoid overflow\r\n                ans = mid;\r\n                l = mid + 1;\r\n            }\r\n            else {\r\n                r = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1343677560","body":"```java\r\npublic class Solution extends VersionControl {\r\n    public int firstBadVersion(int n) {\r\n        int left=0,right=n;\r\n        while(left<right){\r\n            int mid=(right-left)/2+left;\r\n            if(isBadVersion(mid)){\r\n                right=mid;\r\n            }else\r\n                left=mid+1;\r\n        }\r\n        return left;\r\n    }\r\n}\r\n\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huibinny":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308976668","body":"    ‘\nclass Solution:\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\n        if not head:\n            return head\n        pre, slow, fast = None, head, head\n\n        while fast and fast.next:\n            fast = fast.next.next\n            pre = slow\n            slow = slow.next\n        if pre:\n            pre.next = None\n        node = TreeNode(slow.val)\n        if slow == fast:\n            return node\n        node.left = self.sortedListToBST(head)\n        node.right = self.sortedListToBST(slow.next)\n        return nod\n     ’","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313783363","body":"递归实现\n```\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if p == None and q == None:\n            return True\n        if p == None or q == None:\n            return False\n        if p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggmybro":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312745376","body":"```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null){\n            return 0;\n        }\n        return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320731791","body":"```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        int[] ans = new int[2];\n        for (int i = 0; i < nums.length; i++){\n            if (map.containsKey(target - nums[i])){\n                ans[0] = i;\n                ans[1] = map.get(target - nums[i]);\n                break;\n            }\n            map.put(nums[i], i);\n        }\n        return ans;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326984140","body":"```java\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n        ListNode fast = dummy;\n        ListNode slow = dummy;\n        while(fast != null && fast.next != null && fast.next.next != null){\n            slow = slow.next;\n            fast = fast.next;\n            fast = fast.next;\n        }\n        return slow.next;\n    }\n}","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335057443","body":"```java\nclass Solution {\n    public boolean judgeCircle(String moves) {\n        int r = 0;\n        int u = 0;\n        for(char c : moves.toCharArray()){\n            if(c == 'R'){\n                r++;\n            }else{\n                if(c == 'L'){\n                    r--;\n                }else{\n                    if(c == 'U'){\n                        u++;\n                    }else{\n                        u--;\n                    }\n                }\n            }\n        }\n        return r == 0 && u == 0;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1342929412","body":"```java\npublic int firstBadVersion(int n) {\n        if(isBadVersion(1)){\n            return 1;\n        }\n        int left = 1;\n        int right = n;\n        while(left < right){\n            int mid = left + (right - left) / 2;\n            if(mid == left){\n                break;\n            }\n            if(isBadVersion(mid)){\n                right = mid;\n            }else{\n                left = mid;\n            }\n        }\n        return right;\n    }","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353163180","body":"```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> list = new ArrayList<>();\n        if(s.length() < p.length()){\n            return list;\n        }\n        int[] target = new int[26];\n        for(int i = 0; i < p.length(); i++){\n            target[p.charAt(i) - 'a']++;\n        }\n        int left = 0;\n        int right = 0;\n        while(right < s.length()){\n            target[s.charAt(right) - 'a']--;\n            while(target[s.charAt(right) - 'a'] < 0){\n                target[s.charAt(left) - 'a']++;\n                left++;\n            }\n            if(right - left + 1 == p.length()){\n                list.add(left);\n            }\n            right++;\n        }\n        return list;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleetcodejourney":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316444570","body":"Level order traversal\n```\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        queue = collections.deque([root])\n        \n        while(queue):\n            res = queue[0]\n            \n            for _ in range(len(queue)):\n                node = queue.popleft()\n                \n                if node.left: queue.append(node.left)\n                if node.right: queue.append(node.right)\n        \n        return res.val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318151510","body":"```\nclass Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return ''\n        \n        data = []\n        queue = collections.deque()\n        queue.append(root)\n        \n        while(queue):\n            node = queue.popleft()\n            if node:\n                data.append(str(node.val))\n                queue.append(node.left)\n                queue.append(node.right)\n            else:\n                data.append(str('#'))\n        \n        return ','.join(data)\n            \n        \n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data:\n            return None\n        \n        data = data.split(',')\n        root = TreeNode(data[0])\n        queue = collections.deque()\n        queue.append(root)\n        \n        for i in range(1,len(data),2):\n            node = queue.popleft()\n            \n            if node:\n                if data[i]=='#': \n                    node.left = None\n                else: \n                    node.left = TreeNode(data[i])\n                    queue.append(node.left)\n                \n                if i+1<len(data) and data[i+1]=='#':\n                    node.right = None\n                elif i+1<len(data): \n                    node.right = TreeNode(data[i+1])\n                    queue.append(node.right)\n        return root\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319546082","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        memo = collections.defaultdict(lambda: collections.defaultdict(list))\n        self.helper(memo, root, 0, 0)\n        res = []\n        for i in sorted(memo.keys()):\n            temp = []\n            for j in sorted(memo[i]):\n                temp += sorted(memo[i][j])\n            res.append(temp)\n        \n        return res\n    \n  \n    def helper(self, memo, root, x, y):\n        memo[x][y].append(root.val)\n        \n        if root.left:\n            self.helper(memo, root.left, x-1, y+1)\n        if root.right:\n            self.helper(memo, root.right, x+1, y+1)\n        \n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321279735","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n        n = len(points)\n        \n        for i in range(n):\n            memo = collections.defaultdict(int)\n            for j in range(n):\n                if i!=j:\n                    dis = (points[i][0] - points[j][0]) ** 2 + (points[i][1] - points[j][1]) ** 2\n                    memo[dis] += 1\n                \n            for key in memo:\n                res += memo[key] * (memo[key]-1)\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324552060","body":"```\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        memo = collections.defaultdict(int) \n        \n        m = len(words)\n        n = len(words[0])\n        \n        if m*n > len(s): return []\n        \n        for word in words:\n            memo[word] += 1\n        \n        res = []\n        for i in range(len(s)):\n            curr = s[i: i+ m*n]\n            temp = collections.defaultdict(int) \n            j = 0\n            \n            while(j<m*n):\n                sub_str = curr[j:j+n]\n                if sub_str not in memo: break\n                temp[sub_str]+=1\n                \n                if temp[sub_str] >memo[sub_str]: break\n                j+=n\n            \n            if j == m * n:\n                res.append(i)\n        \n        \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327982635","body":"```\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        k = i = 0\n        \n        while(i< len(nums)):\n            nums[k] = nums[i]\n            while(i+1 < len(nums) and nums[i] == nums[i+1]):\n                i += 1\n            \n            k+=1\n            i+=1\n        \n        return k\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330171903","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        memo = [0] * (n+1)\n        \n        for t in trust:\n            memo[t[1]]+=1\n            memo[t[0]]-=1\n        \n        for i in range(1, n+1):\n            if memo[i] == n - 1:\n                return i\n        return -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331599069","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        colors = [0] * (n+1)\n        graph = collections.defaultdict(list)\n        \n        for d in dislikes:\n            graph[d[0]].append(d[1])\n            graph[d[1]].append(d[0])\n            \n        visited = set()\n        for i in graph:\n            if i in visited: continue\n            if colors[i] == 0:\n                colors[i] = 1\n            \n                queue = collections.deque([i])\n\n                while(queue):\n                    node = queue.popleft()\n \n                    for j in graph[node]:\n                        if colors[j] == colors[node]: return False\n                        if j in visited : continue\n                        \n                        colors[j] = colors[node] * -1\n                        queue.append(j)\n                        visited.add(j)\n                        \n        return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333062879","body":"```\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_id = m \n        \n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_id\n                max_id += 1\n        \n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n        \n        \n        for i in range(n):\n            group_projects[group[i]].append(i)\n            \n            for pre in beforeItems[i]:\n                if group[pre] != group[i]:\n                    group_indegree[group[i]] += 1\n                    group_neighbors[group[pre]].append(group[i])\n                else:\n                    project_indegree[i]+=1\n                    project_neighbors[pre].append(i)\n        \n        res = []\n        \n        group_queue = self.tp_sort([i for i in range(max_id)], group_indegree, group_neighbors)\n        \n        if len(group_queue) != max_id: return []\n        \n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n            \n            if len(project_queue) != len(group_projects[group_id]): return []\n            \n            res += project_queue\n        \n        return res\n                    \n        \n    def tp_sort(self, items, indegree, neighbors):\n        res = []\n        queue = collections.deque([])\n        \n        for item in items:\n            if indegree[item] == 0:\n                queue.append(item)\n                \n        while(queue):\n            t = queue.popleft()\n            res.append(t)\n            \n            for neighbor in neighbors[t]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336011915","body":"```\nclass Solution(object):\n    def getOrder(self, tasks):\n        \"\"\"\n        :type tasks: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(tasks)):\n            tasks[i].append(i)\n        \n        tasks.sort()\n        \n        n = len(tasks)\n        res = []\n        h = []\n        pos = 0\n        time = 0\n        \n        while(len(res) < len(tasks)):\n            if not h:\n                time = max(time, tasks[pos][0])\n            \n            while(pos < n and tasks[pos][0] <= time):\n                heapq.heappush(h, [tasks[pos][1], tasks[pos][2]])\n                pos += 1\n            \n            process_t, idx = heapq.heappop(h)\n            time += process_t\n            res.append(idx)\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336795950","body":"```\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        count_a = [0] * 26\n        count_b = [0] * 26\n        \n        for c in a: count_a[ord(c) - ord('a')] += 1\n        for c in b: count_b[ord(c) - ord('a')] += 1\n        \n        m, n = len(a), len(b)\n        res = m + n\n        for i in range(26):\n            res = min(res, m + n - count_a[i] - count_b[i])\n            \n            if i > 0:\n                count_a[i] += count_a[i-1]\n                count_b[i] += count_b[i-1]\n            \n            if i < 25:\n                res = min(res, m - count_a[i] + count_b[i])\n                res = min(res, n - count_b[i] + count_a[i])\n        \n        return res\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340361264","body":"```\nclass Solution:\n    def mySqrt(self, x: int) -> int:\n\n        l, r = 0, x\n        \n        while(l<=r):\n            mid = (l+r)//2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                l = mid + 1\n            else:\n                r = mid -1\n        \n        return l-1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"want2333":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316988683","body":"#### 【Day 16】513. 找树左下角的值 \n\n解题思路\nBFS\n\n```c++\n /*\n * Definition for a binary tree node.\n * struct TreeNode {\n * int val;\n * TreeNode *left;\n * TreeNode *right;\n * TreeNode() : val(0), left(nullptr), right(nullptr) {}\n * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n   */\n   class Solution {\n   public:\n   int findBottomLeftValue(TreeNode* root) {\n       vector<int> leftnode;\n       queue<TreeNode*> qu; \n       if(!root) return 0;\n       qu.push(root);\n       while(!qu.empty()){\n           int currsize = qu.size();\n           for(int i=1;i<=currsize;i++){\n               TreeNode* node = qu.front();\n               qu.pop();\n               if(i==1) leftnode.push_back(node->val);\n               if(node->left) qu.push(node->left);\n               if(node->right) qu.push(node->right);\n           }\n       }\n       return leftnode[leftnode.size()-1];\n   }\n   };\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318458892","body":"#### 【Day 17】297. 二叉树的序列化与反序列化 \n\n解题思路：\n\n深度优先搜索（前序遍历+递归）\n\n代码\n\n```c++\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    void rserialize(TreeNode* root, string& str) {\n        // 前序遍历（中左右，遇到空节点输入null），用逗号隔开\n        if (root == NULL) str += \"null,\";\n        else {\n            str += to_string(root->val) + \",\";\n            rserialize(root->left, str);\n            rserialize(root->right, str);\n        }      \n    }\n    string serialize(TreeNode* root) {\n        string ret;\n        rserialize(root, ret);\n        return ret;\n    }\n\n    // Decodes your encoded data to tree.\n\n    TreeNode* rdeserialize(list<string>& dataArray) {\n        if(dataArray.front() == \"null\") {\n            dataArray.erase(dataArray.begin());\n            return NULL;\n        }\n        // 前序遍历（中左右）恢复树结构\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\n        dataArray.erase(dataArray.begin());\n        root->left = rdeserialize(dataArray);\n        root->right = rdeserialize(dataArray);\n        return root;\n    }\n\n    TreeNode* deserialize(string data) {\n        list<string> dataArray;\n        string str;\n        // 添加各节点val\n        // 按引用传递，按值传递会增加耗时\n        for (auto& c : data) {\n            if (c == ',') {\n                // 以逗号作为节点分割\n                dataArray.push_back(str);\n                str.clear();\n            } else {\n                str.push_back(c);\n            }\n        }\n        // 添加尾部节点val\n        if (!str.empty()) {\n            dataArray.push_back(str);\n            str.clear();\n        }\n        return rdeserialize(dataArray);\n    }\n};\n\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319915975","body":"#### 【Day 18】987. 二叉树的垂序遍历\n\n##### 思路：深度优先搜索\n\n```c++\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\n        dfs(root, 0, 0);     //通过dfs遍历，把节点都安插到mymap里\n        vector<vector<int>> ans;  //用于保存答案\n        map<int, vector<pair<int, int>>>::iterator itB = myMap.begin(), itE = myMap.end();         //用于遍历mymap\n        while(itB != itE){\n            vector<pair<int, int>> &col = itB->second;   //取出mymap里的vector<pair>\n            sort(col.begin(), col.end());           //对其排序\n            const int length = col.size();         //它的长度\n            vector<int> tmp(length);              //准备将它转换成vector<int>\n            for(int i = 0; i < length; ++i)\n                tmp[i] = col[i].second;          //取出值\n            ans.push_back(tmp);                   //放入ans\n            ++itB;\n        }\n        return ans;\n    }\nprivate:\n    map<int, vector<pair<int, int>>> myMap;  //int是列，vector里存的是该节点的行数和值\n    void dfs(TreeNode* root, int row, int col){\n        if(root == nullptr)        //空指针就不用搜索下去了\n            return;\n        myMap[col].push_back({row, root->val}); //加入该列，first是行，second是值\n        dfs(root->left, row + 1, col - 1);   //继续搜索\n        dfs(root->right, row + 1, col + 1);\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320863313","body":"#### 两数之和\n\n##### 思路：哈希表 \n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        map<int,int> hx;\n        for(int i=0;i<nums.size();i++)\n        {\n            int num = target - nums[i];\n            if(hx.find(num) != hx.end())\n            {\n                return {hx[num],i};\n            }\n            hx[nums[i]] = i;\n        }\n        return {-1,-1};\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321110367","body":"#### 347. 前 K 个高频元素 \n\n##### 构造一个大小为K的堆来降低算法复杂度\n\n```\nclass Solution {\npublic:\n    static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n        return m.second > n.second;\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> occurrences;\n        for (auto& v : nums) {\n            occurrences[v]++;\n        }\n\n        // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n        for (auto& [num, count] : occurrences) {\n            if (q.size() == k) {\n                if (q.top().second < count) {\n                    q.pop();\n                    q.emplace(num, count);\n                }\n            } else {\n                q.emplace(num, count);\n            }\n        }\n        vector<int> res;\n        while (!q.empty()) {\n            res.emplace_back(q.top().first);\n            q.pop();\n        }\n        return res;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321968129","body":"#### 【Day 21】447. 回旋镖的数量 \n\n##### 思路：枚举 + 哈希表\n\n```c++\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>> &points) {\n        int ans = 0;\n        for (auto &p : points) {\n            unordered_map<int, int> cnt;\n            for (auto &q : points) {\n                int dis = (p[0] - q[0]) * (p[0] - q[0]) + (p[1] - q[1]) * (p[1] - q[1]);\n                ++cnt[dis];\n            }\n            for (auto &[_, m] : cnt) {\n                ans += m * (m - 1);\n            }\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323594927","body":"#### 【Day 22】3. 无重复字符的最长子串 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char>u;\n        int left=0,right=0,Max=0;\n        int n=s.size();\n        while(right<n){\n            if(u.end()==u.find(s[right])){\n                u.insert(s[right++]);\n                Max=max(right-left,Max);\n            } else u.erase(s[left++]);\n        }\n        return Max;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324993012","body":"#### 【Day 23】30. 串联所有单词的子串\n\n```c++\nclass Solution {\npublic:\n    vector<int> findSubstring(string &s, vector<string> &words) {\n        vector<int> res;\n        int m = words.size(), n = words[0].size(), ls = s.size();\n        for (int i = 0; i < n && i + m * n <= ls; ++i) {\n            unordered_map<string, int> differ;\n            for (int j = 0; j < m; ++j) {\n                ++differ[s.substr(i + j * n, n)];\n            }\n            for (string &word: words) {\n                if (--differ[word] == 0) {\n                    differ.erase(word);\n                }\n            }\n            for (int start = i; start < ls - m * n + 1; start += n) {\n                if (start != i) {\n                    string word = s.substr(start + (m - 1) * n, n);\n                    if (++differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                    word = s.substr(start - n, n);\n                    if (--differ[word] == 0) {\n                        differ.erase(word);\n                    }\n                }\n                if (differ.empty()) {\n                    res.emplace_back(start);\n                }\n            }\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1326329314","body":"#### 【Day 24】删除子表使和能被K整除\n\n##### 同余定理\n\n```c++\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int>predSumModK = {{0, 1}};\n        int sum = 0;\n        int res = 0;\n        for(const auto& x: nums){\n            sum += x;\n            int modK = (sum % k + k) % k; //负数取模为负数\n            predSumModK[modK]++;\n        }\n\n        for(const auto& [modK, count]: predSumModK){\n            res += (count * (count - 1) / 2);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327439387","body":"#### 【Day 25】876. 链表的中间结点 \r\n\r\n##### 链表遍历后存成数组\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        vector<ListNode*> A = {head};\r\n        while (A.back()->next != NULL)\r\n            A.push_back(A.back()->next);\r\n        return A[A.size() / 2];\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328047301","body":"#### Day 26】26.删除排序数组中的重复项 \n\n##### 双指针\n\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int m = 0;\n        int w = 1;\n        \n        while(w<nums.size()){\n            if(nums[m] != nums[w]){\n                // nums[++m] = nums[w];\n                nums[m+1] = nums[w];\n                ++m;\n            }\n            w++;\n            \n        }\n        return 1+m;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328237310","body":"#### 【Day 27】35. 搜索插入位置 \n\n##### 双指针\n\n```c++\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0;\n        int ans = nums.size();\n        int right = ans-1;\n        while( left <= right ){\n            int i = 0.5*(left + right);\n            if(nums[i] >= target){\n                ans = i;\n                right = i -1;;\n            }\n            else{\n                left = i + 1;\n            }\n            \n        }\n        return ans; \n\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328973008","body":"#### 【Day 28】239. 滑动窗口最大值 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        priority_queue<pair<int, int>> q;\n        for (int i = 0; i < k; ++i) {\n            q.emplace(nums[i], i);\n        }\n        vector<int> ans = {q.top().first};\n        for (int i = k; i < n; ++i) {\n            q.emplace(nums[i], i);\n            while (q.top().second <= i - k) {\n                q.pop();\n            }\n            ans.push_back(q.top().first);\n        }\n        return ans;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330601883","body":"#### 【Day 29】997. 找到小镇的法官 \n\n##### 有向图中节点的入度和出度\n\n```c++\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        vector<int> inDegrees(n + 1);\n        vector<int> outDegrees(n + 1);\n        for (auto& edge : trust) {\n            int x = edge[0], y = edge[1];\n            ++inDegrees[y];\n            ++outDegrees[x];\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332196198","body":"#### 【Day 30】886. 可能的二分法 \n\n##### 染色法判断二分图\n\n```c++\nclass Solution {\npublic:\n    bool dfs(int u,const vector<vector<int>> & g, vector<int>& col)\n    {\n        for(int v:g[u]){\n            if(col[v] == -1){\n                col[v] = 1 - col[u];\n                if(!dfs(v,g,col))\n                    return false;\n            }\n            else if(col[u]== col[v]) return false;\n        }\n        return true;\n    }\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<vector<int>>  mp(n);\n        for (auto& edge : dislikes) {\n            int x = edge[0] -1, y = edge[1] - 1;\n            mp[x].push_back(y);\n            mp[y].push_back(x);\n        }\n\n        vector<int> col(n,-1);\n\n        for(int i=0;i<n;i++)\n            if(col[i] == -1)\n            {\n                col[i] = 0;\n                if(!dfs(i,mp,col)) \n                    return false;\n            }\n        return true;\n    \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333685911","body":"#### 【Day 31】1203. 项目管理 \n\n##### \n\n```c++\nclass Solution {\npublic:\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\n        queue<int> Q;\n        for (auto& item: items) {\n            if (deg[item] == 0) {\n                Q.push(item);\n            }\n        }\n        vector<int> res;\n        while (!Q.empty()) {\n            int u = Q.front(); \n            Q.pop();\n            res.emplace_back(u);\n            for (auto& v: graph[u]) {\n                if (--deg[v] == 0) {\n                    Q.push(v);\n                }\n            }\n        }\n        return res.size() == items.size() ? res : vector<int>{};\n    }\n\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> groupItem(n + m);\n\n        // 组间和组内依赖图\n        vector<vector<int>> groupGraph(n + m);\n        vector<vector<int>> itemGraph(n);\n\n        // 组间和组内入度数组\n        vector<int> groupDegree(n + m, 0);\n        vector<int> itemDegree(n, 0);\n        \n        vector<int> id;\n        for (int i = 0; i < n + m; ++i) {\n            id.emplace_back(i);\n        }\n\n        int leftId = m;\n        // 给未分配的 item 分配一个 groupId\n        for (int i = 0; i < n; ++i) {\n            if (group[i] == -1) {\n                group[i] = leftId;\n                leftId += 1;\n            }\n            groupItem[group[i]].emplace_back(i);\n        }\n        // 依赖关系建图\n        for (int i = 0; i < n; ++i) {\n            int curGroupId = group[i];\n            for (auto& item: beforeItems[i]) {\n                int beforeGroupId = group[item];\n                if (beforeGroupId == curGroupId) {\n                    itemDegree[i] += 1;\n                    itemGraph[item].emplace_back(i);   \n                } else {\n                    groupDegree[curGroupId] += 1;\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\n                }\n            }\n        }\n\n        // 组间拓扑关系排序\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \n        if (groupTopSort.size() == 0) {\n            return vector<int>{};\n        } \n        vector<int> ans;\n        // 组内拓扑关系排序\n        for (auto& curGroupId: groupTopSort) {\n            int size = groupItem[curGroupId].size();\n            if (size == 0) {\n                continue;\n            }\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\n            if (res.size() == 0) {\n                return vector<int>{};\n            }\n            for (auto& item: res) {\n                ans.emplace_back(item);\n            }\n        }\n        return ans;\n    }\n};\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1335126477","body":"#### 【Day 32】657. 机器人能否返回原点 \n\n##### 一条过\n\n```c++\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int row=0,list=0;\n        for(auto move:moves){\n            if(move == 'U') row++;\n            if(move == 'D') row--;\n            if(move == 'L') list--;\n            if(move == 'R') list++;\n\n        }\n        if(row==0&&list==0) return true;\n        else{\n          return false;  \n        }\n       \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336155104","body":"#### 【Day 33】1834. 单线程 CPU\n\n```c++\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        long now = 0; // 当前时间\n        //entry 按照进入时间排序 ready按照 执行时间排序 ready是动态的\n        //entry {enqueuetime, i}\n        //ready {processtime, i}\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> >entry, ready;\n        int size = tasks.size();\n\n        for (int i = 0; i < size; ++i){\n            entry.push(make_pair(tasks[i][0], i));\n        }\n\n        vector<int> res;\n        while(!entry.empty() or !ready.empty()){ // 任务没全部执行完,任务需要entry-》ready-》完成\n            if (ready.empty()){//没有待执行任务\n                now = entry.top().first;//时间快进到有任务放入ready\n                while (!entry.empty() && now == entry.top().first){ // ready是空，把同个时间的全部扔进来\n                    ready.push(make_pair(tasks[entry.top().second][1], entry.top().second));\n                    entry.pop();\n                }\n            }\n\n            // ready 现在不为空, 运行优先级最高的任务，之后添加新任务。\n            res.emplace_back(ready.top().second);\n            now += ready.top().first;\n            ready.pop();\n\n            while(!entry.empty() && entry.top().first <= now){ //加入所有已经到达的任务\n                ready.push(make_pair(tasks[entry.top().second][1], entry.top().second));\n                entry.pop();\n            }\n        }\n\n        return res;\n    }\n};\n\n\n```\n","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1344156953","body":"    class Solution\n    {\n    public:\n        int merge_sort(vector<int>& nums, int left, int right)\n        {\n            // 1. 递归出口\n            if (left >= right) return 0;\n            // 2. 划分区间\n            int mid = left + ((right - left) >> 1);\n            // [left, mid] [mid + 1, right]\n            // 计算左边区间的翻转对\n            int retLeft = merge_sort(nums, left, mid);\n            // 计算右边区间的翻转对\n            int retRight = merge_sort(nums, mid + 1, right);\n    \n            // 3. 归并排序 + 计算翻转对的数量\n            // 定义一个辅助数组\n            vector<int> tmp(right - left + 1, 0);\n            // 初始化遍历数组的指针\n            int cur1 = left, cur2 = mid + 1, dest = 0;\n            int ret = 0; // 统计一左一右情况下翻转对的数量\n            // 先计算出翻转对的数量\n            // 由于两个数组是有序的，因此两个指针可以不回退的向后遍历\n            // 看似是双循环，其实时间复杂度是 O(N)\n            while (cur1 <= mid)\n            {\n                // 对于当前元素 nums[cur1]\n                // 在右数组中一直往后找不符合条件的位置\n                while (cur2 <= right && nums[cur1] / 2.0 > nums[cur2])\n                    cur2++;\n                // 此时[mid + 1, cur2) 左闭右开区间上都是符合要求的\n                ret += cur2 - mid - 1;\n                // 更新 cur1 的位置\n                // 此时 cur2 无需更新:\n                //     因为 nums[cur1] 下一个位置一定是大于等于当前元素的\n                //     因此 [mid + 1, cur2) 区间内的元素一定是符合条件的\n                cur1++;\n            }\n    \n            // 处理归并排序\n            cur1 = left, cur2 = mid + 1;\n            while (cur1 <= mid && cur2 <= right)\n            {\n                if (nums[cur1] < nums[cur2])\n                {\n                    tmp[dest++] = nums[cur1++];\n                }\n                else\n                {\n                    tmp[dest++] = nums[cur2++];\n                }\n            }\n    \n            while (cur1 <= mid) tmp[dest++] = nums[cur1++];\n    \n            while (cur2 <= right) tmp[dest++] = nums[cur2++];\n    \n            // 还原数组\n            for (int i = 0; i < dest; i++)\n                nums[left + i] = tmp[i];\n    \n            // 返回 左区间翻转对 + 右区间翻转对 + 一左一右选择情况下的翻转对\n            return ret + retLeft + retRight;\n        }\n    \n        int reversePairs(vector<int>& nums)\n        {\n            // 返回归并排序中统计出来的翻转对\n            return merge_sort(nums, 0, nums.size() - 1);\n        }\n    };\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1345252165","body":"\n```c++\nclass Solution:\n    def findRadius(self, houses: List[int], heaters: List[int]) -> int:\n        ans = 0\n        heaters.sort()\n        for house in houses:\n            j = bisect_right(heaters,house)\n            i = j-1\n            if j < len(heaters):\n                rd = heaters[j] - house\n            else:\n                rd = float(\"inf\")\n            if i >= 0:\n                ld = house - heaters[i]\n            else:\n                ld = float(\"inf\")\n            cd = min(ld, rd)\n            ans = max(ans, cd)\n        return ans\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1346264194","body":"#### 【Day 42】778. 水位上升的泳池中游泳 \n\n```c++\nclass Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int m=grid.size();\n        int n=grid[0].size();\n        UnionFind uf(m*n);\n        vector<tuple<int,int,int>>edge;\n        for(int i=0;i<m;i++)\n        for(int j=0;j<n;j++){\n            int id=i*n+j;\n            if(i>0)edge.emplace_back(max(grid[i][j],grid[i-1][j]),id,id-m);\n            if(j>0)edge.emplace_back(max(grid[i][j],grid[i][j-1]),id,id-1);\n        }\n        sort(edge.begin(),edge.end());\n        int res=0;\n        for(auto&[v,x,y]:edge){\n            uf.merge(x,y);\n            if(uf.connected(0,n*n-1)){\n                res=v;\n                break;\n            }\n        }\n        return res;\n\n    }\n};\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"staringwhere":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1317020322","body":"### 思路\n\nBFS，先加右节点，就能保证最后一个退出队列的是我们要的。\n\n### 代码\n\n```cpp\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode *> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            if (q.front()->right) {\n                q.push(q.front()->right);\n            }\n            if (q.front()->left) {\n                q.push(q.front()->left);\n            }\n            if (q.size() == 1) {\n                return q.front()->val;\n            }\n            q.pop();\n        }\n        return 0;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N), 空间 O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318629741","body":"### 思路\n\nDFS或BFS。这次用的是无递归的DFS，用栈来实现。deserialize和serialize的过程是一样的，只不过一个是栈给字符串提供值，一个是栈从字符串里取值\n\n### 代码\n\n```cpp\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        cout << root;\n        stack<TreeNode*> dfs;\n        string str;\n        dfs.push(root);\n        while (!dfs.empty()) {\n            TreeNode* top = dfs.top();\n            dfs.pop();\n            if (top == nullptr) {\n                str += \"n,\";\n                continue;\n            }\n            str += to_string(top->val) + \",\";\n            dfs.push(top->right);\n            dfs.push(top->left);\n        }\n        return str;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        TreeNode* root = nullptr;\n        stack<TreeNode**> dfs;\n        dfs.push(&root);\n        int val;\n        char t;\n        stringstream stream(data);\n\n        while (!stream.eof()) {\n            if (stream >> val) {\n                TreeNode* newNode = new TreeNode(val);\n                *dfs.top() = newNode;\n                dfs.pop();\n                dfs.push(&newNode->right);\n                dfs.push(&newNode->left);\n            }\n\n            if (stream.fail()){\n                stream.clear();\n            }\n\n            if (stream >> t && t == 'n') {\n                dfs.pop();\n            }\n        }\n\n        return root;\n    }\n};\n```\n\n### 复杂度分析\n\n时间：O(N)  \n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319441200","body":"### 思路\n\n从上到下，所以用BFS可以省去对深度的排序。也可以将二维map简化为一维map。\n\n### 代码\n\n```cpp\n\nstruct XNode {\n    int x;\n    TreeNode* node;\n    XNode(int val, TreeNode* n) : x(val), node(n) {}\n};\n\nvector<vector<int>> verticalTraversal(TreeNode* root) {\n    vector<vector<int>> res;\n    map<int, vector<int>> all_map;\n    queue<XNode> bfs;\n    bfs.push(XNode(0, root));\n    while (!bfs.empty()) {\n        unordered_map<int, vector<int>> layer_map;\n        int n_layer = bfs.size();\n        while (n_layer--) {\n            XNode front = bfs.front();\n\n            if (layer_map.count(front.x)) {\n                layer_map[front.x].push_back(front.node->val);\n            }\n            else{\n                layer_map[front.x] = (vector<int>){front.node->val};\n            }\n\n            if (front.node->left != nullptr) {\n                bfs.push(XNode(front.x - 1, front.node->left));\n            }\n            if (front.node->right != nullptr) {\n                bfs.push(XNode(front.x + 1, front.node->right));\n            }\n            bfs.pop();\n        }\n\n        for (auto &it : layer_map) {\n            sort(it.second.begin(), it.second.end());\n            if (all_map.count(it.first)) {\n                all_map[it.first].insert(\n                        all_map[it.first].end(),\n                        it.second.begin(),\n                        it.second.end()\n                );\n            }\n            else {\n                all_map[it.first] = it.second;\n            }\n        }\n    }\n    for (auto it : all_map) {\n        res.push_back(it.second);\n    }\n    return res;\n}\n\n```\n\n### 复杂度分析\n时间 O(Nlog(N))  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320832022","body":"### 思路\n\n用map或数组来解决，就可以只遍历一遍数组\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> complements;\n        for (int i = 0; i < nums.size(); i++) {\n            int diff = target - nums[i];\n            if (complements.count(diff)) {\n                return {i, complements[diff]};\n            }\n            complements[nums[i]] = i;\n        }\n        return nums;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321045844","body":"### 思路\n\n一般第k个问题会用堆或者快速选择算法，但这道题需要排序的东西是有限种可能的，所以可以用map来变成线性复杂度。\n\n### 代码\n\n```cpp\nclass Solution {\n  public:\n  vector<int> topKFrequent(vector<int>& nums, int k) {\n      unordered_map<int, int> num_freq;\n      unordered_map<int, vector<int>> freq_num;\n      vector<int> res;\n      for (auto it : nums) {\n          if (num_freq.count(it)) {\n              num_freq[it]++;\n          }\n          else {\n              num_freq[it] = 1;\n          }\n      }\n      int freq_max = 0;\n      for (auto it: num_freq) {\n          if (it.second > freq_max) {\n              freq_max = it.second;\n          }\n          if (freq_num.count(it.second)) {\n              freq_num[it.second].push_back(it.first);\n          }\n          else {\n              freq_num[it.second] = vector<int> {it.first};\n          }\n      }\n      int count = 0;\n      for (int i = freq_max; count < k; i--) {\n          if (freq_num.count(i)) {\n              for (int j = 0; j < freq_num[i].size() && count < k; j++, count++) {\n                  res.push_back(freq_num[i][j]);\n              }\n          }\n      }\n      return res;\n  }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321937898","body":"### 思路\n\nMap\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int numberOfBoomerangs(vector<vector<int>>& points) {\n        int count = 0;\n        for (int i = 0; i < points.size(); i++) {\n            unordered_map<int, int> dist_count;\n            for (int j = 0; j < points.size(); j++) {\n                if (i == j) { continue;}\n                int dist = (points[j][0] - points[i][0]) * (points[j][0] - points[i][0]) +\n                        (points[j][1] - points[i][1]) * (points[j][1] - points[i][1]);\n                dist_count[dist] += 1;\n                count += (dist_count[dist] - 1) * 2;\n            }\n        }\n        return count;\n    }\n};\n```\n\n### 复杂度分析\n时间 O(N^2)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323415230","body":"### 思路\n\n双指针\n\n### 代码\n```cpp\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_map<char, unsigned> flag;\n        unsigned longest = 0;\n        unsigned start = 0;\n        for (unsigned i = 0; i < s.length(); i++) {\n            if (flag.count(s[i]) && flag[s[i]] >= start) {\n                longest = max(i - start, longest);\n                start = flag[s[i]] + 1;\n            }\n            flag[s[i]] = i;\n        }\n        longest = max((int) s.length() - start, longest);\n        return longest;\n    }\n};\n```\n\n### 复杂度分析\n\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324472562","body":"### 思路\n\n用 `word.length - 1` 个 sliding window，因为我们的步长是 `word,length`。用hash table记录下单次出现的位置，通过与start位置对比，就可以知道是否在这个substring里出现过。用queue作为hash table里的value来存储位置，解决重复的word的问题，因为是从前向后遍历，因此queue里的位置是自动排序的，每次对比只需要对比queue.front()。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> findSubstring(string s, vector<string>& words) {\n        vector<int> res;\n        unordered_map<string, unsigned> count;\n        for (auto& word : words) {\n            count[word]++;\n        }\n        unsigned length = words[0].length();\n        for (unsigned i = 0; i < length; i++) {\n            unordered_map<string, queue<unsigned>> pos;\n            int start = i;\n            for (unsigned j = i; j < s.length() - length + 1; j += length) {\n                string sub = s.substr(j, length);\n                if (count.count(sub)) {\n                    if (pos[sub].size() == count[sub] && pos[sub].front() >= start) {\n                        start = pos[sub].front() + length;\n                    }\n                    if (pos[sub].size() == count[sub]) {\n                        pos[sub].pop();\n                    }\n                    pos[sub].push(j);\n                }\n                else {\n                    start = j + length;\n                }\n                if (j + length - start == length * words.size()) {\n                    res.push_back(start);\n                    start += length;\n                }\n            }\n        };\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n时间 `O(words.size() + s.length() * word.length())`  \n空间 `O(words.size() + word.length())`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325887628","body":"### 思路\n\nThe sum of subarray `sum(m, n)` can be calculated by `sum(0, n) - sum(0, m)`. So this problem is to find all pairs of `sum(0, i)` that have a same modulo (remainder), which can be solved like [[1. Two Sum]].\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        unordered_map<int, int> modulo_count = {{0, 1}};\n        int sum = 0;\n        int count = 0;\n        for (auto& num : nums) {\n            sum += num;\n            int modulo = (sum % k + k) % k;\n            count += modulo_count[modulo];\n            modulo_count[modulo]++;\n        }\n        return count;\n    }\n};\n```\n\n\n### 复杂度分析\n时间 O(N)  \n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1327323391","body":"```cpp\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* middle = head;\n        while (head != nullptr && head->next != nullptr) {\n            head = head->next->next;\n            middle = middle->next;\n        }\n        return middle;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327948039","body":"```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int k = 0;\n        for (int p = 1; p < nums.size(); p++) {\n            if (nums[p] == nums[k]) {continue;}\n            k++;\n            nums[k] = nums[p];\n        }\n        return k + 1;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328160547","body":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int left = 0;\n        int right = nums.size();\n        while (right > left) {\n            int med = (left + right) / 2;\n            if (nums[med] == target) {\n                return med;\n            }\n            if (nums[med] > target) {\n                right = med;\n            }\n            else {\n                left = med + 1;\n            }\n        }\n        return left;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328661247","body":"### 思路\n\n滑动窗口+最大最小 = 单调队列\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> mono;\n        vector<int> res;\n        for (int i = 0; i < k; i++) {\n            while (!mono.empty() && nums[mono.back()] < nums[i]) {\n                mono.pop_back();\n            }\n            mono.push_back(i);\n        }\n        res.push_back(nums[mono.front()]);\n        for (int i = k; i < nums.size(); i++) {\n            if (mono.front() < i - k + 1) {\n                mono.pop_front();\n            }\n            while (!mono.empty() && nums[mono.back()] < nums[i]) {\n                mono.pop_back();\n            }\n            mono.push_back(i);\n            res.push_back(nums[mono.front()]);\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\nO(N) / O(K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330510965","body":"```cpp\nclass Solution {\npublic:\n    int findJudge(int n, vector<vector<int>>& trust) {\n        int judge = -1;\n        vector<int> trust_count(n);\n        vector<int> trusted_count(n);\n        for (auto& pair : trust) {\n            trust_count[pair[0] - 1]++;\n            trusted_count[pair[1] - 1]++;\n        }\n        for (int i = 0; i < n; i++){\n            if (trust_count[i] == 0 && trusted_count[i] == n - 1) {\n                if (judge != -1) {\n                    return -1;\n                }\n                else {\n                    judge = i + 1;\n                }\n            }\n        }\n        return judge;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332067667","body":"### 思路\n\nDFS或BFS，依据相连接的点不能讨论，来寻找有冲突的地方。注意虽然讨厌有方向，但对分组没影响，所以应该看作无向图\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        vector<int> flag(n);\n        vector<vector<int>> graph(n);\n        for (auto& dislike : dislikes) {\n            graph[dislike[0] - 1].push_back(dislike[1] - 1);\n            graph[dislike[1] - 1].push_back(dislike[0] - 1);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!flag[i]) {\n                flag[i] = 1;\n                if (!color(graph, flag, i)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    bool color(vector<vector<int>>& graph, vector<int>& flag, int from) {\n        for (int to : graph[from]) {\n            if (flag[to]) {\n                if (flag[to] != 3 - flag[from])\n                    return false;\n            }\n            else {\n                flag[to] = 3 - flag[from];\n                if (!color(graph, flag, to)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};\n```\n\n### 复杂度分析\nO(N + K) / O (N + K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333892100","body":"还没de完bug\n```cpp\nclass Solution {\npublic:\n    vector<unordered_set<int>> all_before;\n    vector<int> ranks;\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\n        vector<vector<int>> group_items(m);\n        vector<int> res;\n        int rank_min = 0;\n\n        all_before.resize(n);\n        ranks.resize(n);\n\n        for (int i = 0; i < n; i++) {\n            if (group[i] >= 0) {\n                group_items[group[i]].push_back(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (auto before : beforeItems[i]) {\n                int group_before = group[before];\n                int group_after = group[i];\n                if (group_before >= 0 && group_before != group_after) {\n                    for (auto after : group_items[group_after]) {\n                        all_before[after].insert(group_items[group_before].begin(), group_items[group_before].end());\n                    }\n                }\n                else {\n                    all_before[i].insert(before);\n                }\n            }\n        }\n        vector<bool> path(n);\n        for (int item = 0; item < n; item++) {\n            if (ranks[item]) {continue;}\n            int rank = dfs(item, path, rank_min - 1);\n            if (!rank) {return res;}\n            rank_min = min(rank, rank_min);\n        }\n        vector<vector<int>> rank_items(-rank_min);\n        for (int item = 0; item < n; item++) {\n            rank_items[ranks[item] - rank_min].push_back(item);\n        }\n        for (int rank = 0; rank < -rank_min; rank++) {\n            res.insert(res.end(), rank_items[rank].begin(), rank_items[rank].end());\n        }\n        return res;\n    }\n    int dfs(int p, vector<bool>& path, int rank) {\n        int rank_min = rank;\n        if (path[p]) {return 0;}\n        path[p] = true;\n        ranks[p] = min(ranks[p], rank);\n        for (auto item : all_before[p]) {\n            int rank_res = dfs(item, path, rank - 1);\n            if (!rank_res) {return 0;}\n            rank_min = min(rank_res, rank_min);\n        }\n        path[p] = false;\n        return rank_min;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334821348","body":"```cpp\nclass Solution {\npublic:\n    bool judgeCircle(string moves) {\n        int UD = 0, LR = 0;\n        for (auto c : moves) {\n            switch(c) {\n                case 'L': {\n                    LR++;\n                    break;\n                }\n                case 'R': {\n                    LR--;\n                    break;\n                }\n                case 'U': {\n                    UD++;\n                    break;\n                }\n                default: {\n                    UD--;\n                }\n            }\n        }\n        return !LR && !UD;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336147924","body":"### 思路\n排序+小顶堆。提供一个cpp空间使用小于97%的方法，queue中只存index，然后利用lambda方程来读取tasks数组\n\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> getOrder(vector<vector<int>>& tasks) {\n        vector<int> res(tasks.size());\n        vector<int> indexes(tasks.size());\n        iota(indexes.begin(), indexes.end(), 0);\n        sort(indexes.begin(), indexes.end(), [&](int lhs, int rhs){\n            return tasks[lhs][0] < tasks[rhs][0];\n        });\n        priority_queue<int, vector<int>, function<bool(int, int)>> pq([&](int lhs, int rhs){\n            if (tasks[lhs][1] != tasks[rhs][1]) return tasks[lhs][1] > tasks[rhs][1];\n            return lhs > rhs;\n        });\n        int time = 0;\n        int current = 0;\n        int current_res = 0;\n        while (current_res < tasks.size()) {\n            if (current < tasks.size()) {\n                if (pq.empty() && time < tasks[indexes[current]][0])\n                    time = tasks[indexes[current]][0];\n                while (current < tasks.size() && tasks[indexes[current]][0] <= time)\n                    pq.push(indexes[current++]);\n                time += tasks[pq.top()][1];\n            }\n            res[current_res++] = pq.top();\n            pq.pop();\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\nO(NlogN) / O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336327456","body":"```cpp\nclass Solution {\npublic:\n    int numberOfRounds(string loginTime, string logoutTime) {\n        int login = stoi(loginTime.substr(0, 2)) * 60;\n        login += stoi(loginTime.substr(3, 5));\n        int logout = stoi(logoutTime.substr(0, 2)) * 60;\n        logout += stoi(logoutTime.substr(3, 5));\n        \n        int diff = (logout - login + 1440) % 1440;\n        diff -= (15 - login % 15) % 15;\n        return diff / 15;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336761680","body":"### 思路\n\n让一个数组小于另一个数组的实质是找到一个分界线。因此我们需要对两个数组排序，这道题中需要排序的字母，是有限集，又不很稀疏，因此可以用数组作为Hash Table，来代替排序算法。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    int minCharacters(string a, string b) {\n        vector<int> count_a(26);\n        vector<int> count_b(26);\n        for (auto c : a) {\n            count_a[c - 'a']++;\n        }\n        for (auto c : b) {\n            count_b[c - 'a']++;\n        }\n        auto ops_distinct = [](vector<int>& count, string& str){\n            return str.size() - *max_element(count.begin(), count.end());\n        };\n        int ops = ops_distinct(count_a, a) + ops_distinct(count_b, b);\n        int diff_min = 200000;\n        int diff_max = -200000;\n        int diff = 0;\n        for (int i = 0; i < 25; i++) {\n            diff += count_b[i] - count_a[i];\n            diff_min = min(diff_min, diff);\n            diff_max = max(diff_max, diff);\n        }\n        ops = min(ops, (int) a.size() + diff_min);\n        ops = min(ops, (int) b.size() - diff_max);\n        return ops;\n    }\n};\n```\n\n### 复杂度分析\nO(N) / O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339495813","body":"### 思路\n\n这道题需要时间复杂度为nlogn，而快排最坏时间复杂度是$n^2$，又因为题目要求最少的空间复杂度，所以选择heap sort\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        heapSort(nums);\n        return nums;\n    }\n    void maxHeapify(vector<int>& nums, int i, int length) {\n        while (2 * i + 1 < length){\n            int min_index = i;\n            if (2 * i + 1 < length && nums[2 * i + 1] > nums[min_index]) min_index = 2 * i + 1;\n            if (2 * i + 2 < length && nums[2 * i + 2] > nums[min_index]) min_index = 2 * i + 2;\n            if (min_index == i) break;\n            swap(nums[min_index], nums[i]);\n            i = min_index;\n        }\n    }\n    void heapSort(vector<int>& nums) {\n        for (int i = (nums.size() >> 1) - 1; i >= 0; i--) \n            maxHeapify(nums, i, nums.size());\n        int end = nums.size();\n        while(--end > 0) {\n            swap(nums[0], nums[end]);\n            maxHeapify(nums, 0, end);\n        }\n    }\n};\n```\n\n### 复杂度分析\nO(nlogn) / O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/44#issuecomment-1340373654","body":"```cpp\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        if (x < 1) return x;\n        long long a = 1, b = x;\n        while (abs(b - a) > 1) {\n            a = (a + b) >> 1;\n            b = x / a;\n        }\n        return min(a, b);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341596084","body":"```cpp\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        int lo = 1, hi = n;\n        while (hi > lo) {\n            int mid = lo + ((hi - lo) >> 1);\n            if (isBadVersion(mid)) hi = mid;\n            else lo = mid + 1;\n        }\n        return hi;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng8":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318097487","body":"```\r\nclass Codec:\r\n\r\n    def serialize(self, root):\r\n        \"\"\"Encodes a tree to a single string.\r\n        \r\n        :type root: TreeNode\r\n        :rtype: str\r\n        \"\"\"\r\n        if not root:\r\n            return \"\"\r\n        queue = collections.deque([root])\r\n        res = []\r\n        while queue:\r\n            node = queue.popleft()\r\n            if node:\r\n                res.append(str(node.val))\r\n                queue.append(node.left)\r\n                queue.append(node.right)\r\n            else:\r\n                res.append('None')\r\n        return '[' + ','.join(res) + ']'\r\n\r\n    def deserialize(self, data):\r\n        \"\"\"Decodes your encoded data to tree.\r\n        \r\n        :type data: str\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not data:\r\n            return []\r\n        dataList = data[1:-1].split(',')\r\n        root = TreeNode(int(dataList[0]))\r\n        queue = collections.deque([root])\r\n        i = 1\r\n        while queue:\r\n            node = queue.popleft()\r\n            if dataList[i] != 'None':\r\n                node.left = TreeNode(int(dataList[i]))\r\n                queue.append(node.left)\r\n            i += 1\r\n            if dataList[i] != 'None':\r\n                node.right = TreeNode(int(dataList[i]))\r\n                queue.append(node.right)\r\n            i += 1\r\n        return root\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319463393","body":"```\r\nclass Solution:\r\n    def verticalTraversal(self, root: TreeNode) -> List[List[int]]:\r\n        nodes = list()\r\n\r\n        def dfs(node: TreeNode, row: int, col: int) -> None:\r\n            if not node:\r\n                return\r\n\r\n            nodes.append((col, row, node.val))\r\n            dfs(node.left, row + 1, col - 1)\r\n            dfs(node.right, row + 1, col + 1)\r\n\r\n        dfs(root, 0, 0)\r\n        nodes.sort()\r\n        ans, lastcol = list(), float(\"-inf\")\r\n\r\n        for col, row, value in nodes:\r\n            if col != lastcol:\r\n                lastcol = col\r\n                ans.append(list())\r\n            ans[-1].append(value)\r\n        \r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryanbaiyansong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1318899016","body":"# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\r\n        col2nodes = defaultdict(list)\r\n\r\n        def dfs(node,r,c):\r\n            if not node:\r\n                return \r\n            col2nodes[c].append((r, node.val))\r\n            dfs(node.left, r+1, c-1)\r\n            dfs(node.right, r+1, c+1)\r\n        \r\n        dfs(root, 0, 0)\r\n        # print(col2nodes)\r\n        minColIndex = min(col2nodes.keys())\r\n        maxColIndex = max(col2nodes.keys())\r\n        res = []\r\n        for i in range(minColIndex, maxColIndex + 1):\r\n            cur = sorted(col2nodes[i])\r\n            temp = list(x[1] for x in cur)\r\n            res.append(temp)\r\n        \r\n        # print(res)\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320434999","body":"```\nclass Solution:\n    def twoSum(self, A: List[int],t: int) -> List[int]:\n        n = len(A)\n        d = {}\n        for i, v in enumerate(A):\n            if t - v in d:\n                return [d[t- v], i]\n            \n            d[v] = i\n    ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1320957010","body":"```\nclass Solution:\n    def topKFrequent(self,a: List[int], k: int) -> List[int]:\n        n = len(a)\n        # # 经典top k 问题\n        # minHeap = []\n\n        # val2freq = Counter(a)\n\n        # for val, freq in val2freq.items():\n        #     heapq.heappush(minHeap, (freq, val))\n\n        #     while len(minHeap) > k:\n        #         heapq.heappop(minHeap)\n        \n        # # print(minHeap)\n\n        # return [v for _, v in minHeap]\n        \n        # 解法二: 快速选择算法\n        # val2freq = Counter(a)\n        # # inplace 交换vals里面的元素\n        # vals = list(val2freq.keys())\n        # t = len(vals) - k\n        # def quick_select(l, r):\n        #     if l >= r:\n        #         return \n        #     pivot_index = partition(l, r)\n\n        #     if pivot_index == t:\n        #         return \n        #     elif pivot_index < t:\n        #         quick_select(pivot_index + 1, r)\n        #     else:\n        #         quick_select(l, pivot_index - 1)\n        # def partition(l, r):\n        #     i = l - 1\n        #     pivot = val2freq[vals[r]]\n        #     for j in range(l ,r):\n        #         if val2freq[vals[j]] < pivot:\n        #             i += 1\n        #             swap(i, j)\n        #     swap(i+1, r)\n        #     return i + 1\n                    \n        # def swap(l, r):\n        #     temp = vals[l]\n        #     vals[l] = vals[r]\n        #     vals[r] = temp\n        \n\n        # quick_select(0, len(vals) - 1)\n        # return vals[t:]\n\n\n        # 解法三: 计数排序\n        val2freq = Counter(a)\n        count2vals = [[] for _ in range(n + 1)] # 最多出现n次\n        # print(count2vals)\n        for val, freq in val2freq.items():\n            count2vals[freq].append(val)\n        \n        # print(count2vals)\n        \n        res = []\n        for i in range(len(count2vals) - 1, -1, -1):\n            for val in count2vals[i]:\n                res.append(val)\n                if len(res) == k:\n                    return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322548172","body":"```\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        def get_dist(a, b):\n            x1, y1 = a[0], a[1]\n            x2, y2 = b[0], b[1]\n            return (x2 - x1) ** 2 + (y1 - y2) ** 2\n        ans = 0\n        n = len(points)\n        d = defaultdict(lambda: defaultdict(int))\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                dist = get_dist(points[i], points[j])\n                d[tuple(points[i])][dist]+= 1\n        \n        ans = 0\n        for point in points:\n            for dist, val in d[tuple(point)].items():\n                ans += val * (val - 1)\n        \n        return ans\n```\n一般需要暴力枚举的题目要不就是二分优化要不就是哈希表优化\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1322509976","body":"```\nclass Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        n = len(s)\n        window = defaultdict(int)\n\n        res = j = 0\n\n        for i, ch in enumerate(s):\n            window[ch] += 1\n\n            while j < n and window[ch] > 1:\n                window[s[j]] -= 1\n                j += 1\n\n            res = max(res, i - j + 1) \n        \n        return res\n```\n标准滑动窗口模版题, 用一个dict记录字符count, 有重复的就缩小窗口直到没有重复","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1325679995","body":"···\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        need = defaultdict(int)\n        for word in words:\n            need[word] += 1\n        n = len(s)\n        m = len(words)\n        w = len(words[0])\n        res = []\n        # 分类所有w的起始位置\n        for i in range(0, w):\n            window = defaultdict(int)\n            cnt = 0\n\n            j = i\n            # 起始下标在j, 长度为w的最后一个单词的下表是 j + w - 1 <= n - 1 => j + w <= n\n            # 遍历 0, w, 2w, 3w....\n            #     1, w + 1, 2w + 1 ....\n            #     2, w + 2, 3w + 2\n            # 遍历从i开始的所有起始点下标\n            while j + w <= n:\n                # i + m * w 是 原来的位置, 需要删左边的\n                if j >= i + m * w:\n                    word = s[j - m * w: j - m * w + w]\n                    window[word] -= 1\n                    if window[word] < need[word]:\n                        cnt -= 1\n                \n                # 现在的单词是s[j: j + w]\n                word = s[j: j + w]\n                # 当前窗口的单词数 + 1\n                window[word] += 1\n                \n                if window[word] <= need[word]: cnt += 1\n\n                if cnt == m:\n                    res.append(j - (m - 1) * w)\n                \n                j += w\n        \n        return res\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/31#issuecomment-1325675903","body":"···\r\nclass Solution:\r\n    def minSubarray(self, nums: List[int], p: int) -> int:\r\n        tot = sum(nums)\r\n        if tot % p == 0:\r\n            return 0\r\n        n = len(nums)\r\n        s = 0\r\n        # (tot - remove) % p == 0\r\n        # remove % p == C\r\n        t = tot % p\r\n        # (rightSum - leftSum) % p == target\r\n        # rightSum % p - leftSum % p == target\r\n        # leftSum % p == (rightSum % p) - target\r\n        # (s % p) - t = left % p\r\n        res = n\r\n        d = defaultdict(int)\r\n        d = {\r\n            0: -1\r\n        }\r\n        res = len(nums)\r\n        for i in range(len(nums)):\r\n            s += nums[i]\r\n            curmod = s % p\r\n           这里有可能是负数所以要这么操作\r\n            tarmod = (curmod - t + p) % p\r\n            if tarmod in d:\r\n                dis = i - d[tarmod]\r\n                res = min(res, dis)\r\n            d[curmod] = i\r\n        return res if res != n else -1\r\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326743502","body":"```\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # 1 2 3 4 返回 3\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        return slow\n        // 1 2 3 4 返回2\n        slow = head\n        fast = head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        return slow\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328165501","body":"···\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        def process(nums, k):\n            idx = 0\n            for x in nums:\n                # 如果idx不足k个数直接保存\n                # 如果 1 1 1 1 4 5 5 5 5 5 k = 3 \n                #     0 1 2 3 4 \n               #  if idx - k >= 0:\n                #     print(idx, nums[idx - k], x)\n                if idx < k or nums[idx - k] != x:\n                    if idx - k >= 0:\n                        print(nums[idx])\n                    nums[idx] = x\n                    if idx - k >= 0:\n                        print(numsa[idx])\n                    # print(nums[idx])\n                    idx += 1\n                print(nums)\n            return idx\n        return process(nums, 3)\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328165382","body":"···\nclass Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        n = len(nums)\n        l, r = 0, n\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] >= target:\n                r = m\n            else:\n                l = m + 1\n        \n        return l\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/35#issuecomment-1328501550","body":"···\nclass MQ:\n    def __init__(self):\n        self.q = deque()\n        self.maxq = deque()\n    \n    def add(self, val):\n        self.q.append(val)\n\n        while self.maxq and self.maxq[-1] < val:\n            self.maxq.pop()\n        self.maxq.append(val)\n    \n    def pop(self):\n        val = self.q.popleft()\n        if val == self.maxq[0]:\n            self.maxq.popleft()\n    \n    def max(self):\n        return self.maxq[0]\n\n    def size(self):\n        return len(self.q)\nclass Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        window = MQ()\n        res = []\n        for i, v in enumerate(nums):\n            window.add(v)\n            if window.size() == k:\n                res.append(window.max())\n                window.pop()\n        \n        # print(res)\n        return res\n\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1331106743","body":"```\nclass Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        # 1 - n n个人\n        # judge 谁都不信\n        # 每个人, 除了judge自己, 都相信judge\n        # 只有一个人满足性质1 和 性质2\n        # judge可以得到得分为 n - 1, 只存在唯一一个judge, 即数组中不存在两个得分为n-1的人\n        # judge 自己不可以相信自己 \n        points = [0] * (n + 1)\n\n        for a, b in trust:\n            points[b] += 1\n            points[a] -= 1\n        \n        #$ print(points)\n        seen = False\n        ans = -1\n        for i in range(1, n+1):\n            if not seen and points[i] == n - 1:\n                seen = True\n                ans = i\n            elif seen and points[i] == n - 1:\n                return -1\n        \n        return ans \n\n            \n\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1331126673","body":"```\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        # 二分图模拟题\n        # \n        # 染色\n        # 1 - n\n        # 每个人的颜色是WHITE和BLACK, 看看能不能分成两组\n        color = [0] * (n + 1)\n        vis = [False] * (n + 1)\n\n        g = defaultdict(list)\n        for u, v in dislikes:\n            g[u].append(v)\n            g[v].append(u)\n        \n        ans = True\n        def dfs(o):\n            nonlocal ans\n            if not ans:\n                return \n            \n            vis[o] = True\n\n            for nei in g[o]:\n                if not vis[nei]:\n                    color[nei] = not color[o]\n                    dfs(nei)\n                else:\n                    if color[o] == color[nei]:\n                        ans = False\n                        return \n        for i in range(1, n + 1):\n            dfs(i)\n        return ans\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1332674880","body":"···\nclass Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        # 数据的预处理, 将 为-1的组分到别的组里面\n        \n        for i in range(len(group)):\n            if group[i] == -1:\n                group[i] = m\n                m += 1\n        groupAdj = defaultdict(list)\n        itemAdj = defaultdict(list)\n        groupInd = [0] * m\n        itemInd = [0] * n\n        # 建立组的有向图\n        for i in range(len(group)):\n            currGroup = group[i]\n            for beforeItem in beforeItems[i]:\n                beforeGroup = group[beforeItem]\n                if currGroup != beforeGroup:\n                    groupAdj[beforeGroup].append(currGroup)\n                    groupInd[currGroup] += 1\n        # 建立item的有向图\n        for i in range(n):\n            \n            for item in beforeItems[i]:\n                itemAdj[item].append(i)\n                itemInd[i] += 1\n                \n        groupList = self.topologicalSort(groupAdj, groupInd, m)\n        if len(groupList) == 0:\n            return []\n        itemsList = self.topologicalSort(itemAdj, itemInd, n)\n        if len(itemsList) == 0:\n            return []\n        \n        group2Items = defaultdict(list)\n        for item in itemsList:\n            group2Items[group[item]].append(item)\n        res  = []\n        for groupId in groupList:\n            res.extend(group2Items[groupId])\n        \n        return res\n    \n    def topologicalSort(self, graph, ind, n):\n        q = deque()\n        for i in range(n):\n            if ind[i] == 0:\n                q.append(i)\n        res = []\n        while q:\n            curr = q.popleft()\n            res.append(curr)\n            for nei in graph[curr]:\n                ind[nei] -= 1\n                if ind[nei] == 0:\n                    q.append(nei)\n        \n        if len(res) == n:\n            return res\n        return []\n        \n        \n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334135190","body":"···\nclass Solution:\n    def judgeCircle(self, moves: str) -> bool:\n        dirs = {\n            \"R\": (0, 1),\n            \"L\":(0, -1),\n            \"D\":(1, 0),\n            \"U\":(-1, 0)\n        }\n        start = [0, 0]\n        for v in moves:\n            dx, dy = dirs[v]\n            start[0] += dx\n            start[1] += dy\n        return start == [0, 0]\n\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1335648801","body":"···\nclass Solution:\n    def getOrder(self, tasks: List[List[int]]) -> List[int]:\n        n = len(tasks)\n        a = list([enque_time, process_time, i] for i, (enque_time, process_time) in enumerate(tasks))\n        a.sort()\n        t = 0\n        # i 指针在a上挪动, 用来放可以执行的tasks\n        i = 0\n        res = []\n        minHeap = []\n        while len(res) < n:\n            # 如果没有可以执行的任务, 时间跳过\n            if not minHeap:\n                t = max(t, a[i][0])\n            # 这里错误的原因是因为, 虽然当前的时间 < a[i][0], 但是任务队列中还有可以执行的任务, 所以不要这样加时间\n            # while i < n and t < a[i][0]:\n            #     t += 1\n            # print(t)\n            while i < n and a[i][0] <= t:\n                heapq.heappush(minHeap, (a[i][1], a[i][2]))\n                i += 1\n            # 执行tasks\n            if minHeap:\n                # print(minHeap)\n                process_time, _id = heapq.heappop(minHeap)\n                res.append(_id)\n                t += process_time\n        # print(res)\n        return res\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336217441","body":"```\nclass Solution:\n    def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n        login_hour, login_min = list(map(int, loginTime.split(\":\")))\n        logout_hour, logout_min = list(map(int, logoutTime.split(\":\")))\n        # 开始的时候, 必须等待到可以开始的节点: [0, 15, 30, 45, 0]\n        d = 0\n        if logout_hour * 60 + logout_min - (login_hour * 60 + login_min) < 0:\n            d += 1\n        if 0 < login_min < 15:\n            login_min = 15\n        elif 15 < login_min < 30:\n            login_min = 30\n        elif 30 < login_min < 45:\n            login_min = 45\n        elif 45 < login_min < 60:\n            login_min = 0\n            login_hour += 1\n        \n        if 0 < logout_min < 15:\n            logout_min = 0\n        elif 15 < logout_min < 30:\n            logout_min = 15 \n        elif 30 < logout_min < 45:\n            logout_min = 30\n        elif 45 < logout_min < 60:\n            logout_min = 45 \n        \n        # logout_hour * 60 + logout_min - (login_hour * 60 + login_min)\n        if d:\n            logout_hour = logout_hour + 24\n        span = logout_hour * 60 + logout_min - (login_hour * 60 + login_min)\n        return max(0 , span // 15)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1336507462","body":"```\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n\n        A = [0] * 26    # A和B分别存储字符串a和b中每个字母（26个）出现的次数\n        B = [0] * 26\n        for ch in a:    \n            A[ord(ch)-ord('a')] += 1\n        for ch in b:    \n            B[ord(ch)-ord('a')] += 1\n\n        n1, n2 = len(a), len(b)\n        presum1 = presum2 = 0\n        ans = n1+n2  \n\n        for i in range(25):    \n            \n            presum1 += A[i]     \n            presum2 += B[i]\n\n            ans = min(ans, n1-presum1+presum2, presum1+n2-presum2, n1-A[i] + n2-B[i])\n\n        \n        ans = min(ans, n1-A[25] + n2-B[25])\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1337998100","body":"```\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/46#issuecomment-1343734162","body":"```\n'''\nnumber of reverse pairs\n1, 3, 2 , 3, 1\n\nnums[i] > nums[j] * 2\n'''\nclass Solution:\n    def reversePairs(self, nums: List[int]) -> int:\n        n = len(nums)\n        self.ans = 0\n        self.sort(nums, 0, n-1)\n        return self.ans\n    \n    def sort(self, nums, l, r):\n        # (l, r)\n        if l == r:\n            return \n        mid = (l+r) // 2\n        self.sort(nums, l, mid)\n        self.sort(nums, mid+1, r)\n        self.merge(nums, l,mid, r)\n        # print(nums)\n    \n    def merge(self, nums, l, mid, r):\n        res = []\n        \n\n\n        end = mid + 1 \n        for i in range(l, mid+1):\n            # print(end, nums,l, mid, mid+1,r)\n            while (end <= r and nums[i] > nums[end] * 2):\n                end+=1\n            self.ans += end - (mid + 1)\n        i = l\n        j = mid+1\n        while i<=mid and j<=r:\n            if nums[i]<=nums[j]:\n                res.append(nums[i])\n                i+=1\n            else:\n                res.append(nums[j])\n                j+=1\n        \n        while i <= mid:\n            res.append(nums[i])\n            i+=1\n        while j<=r:\n            res.append(nums[j])\n            j+=1\n        nums[l:r+1] = res\n        # print(res, \"res\")\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/47#issuecomment-1344989740","body":"```\nclass Solution:\n    def solve(self, nums):\n        nums.sort()\n        N = len(nums)\n        if N <= 3:\n            return 0\n        LIGHTS = 3\n        # 这里使用的是直径，因此最终返回需要除以 2\n        def possible(diameter):\n            start = nums[0]\n            end = start + diameter\n            for i in range(LIGHTS):\n                idx = bisect_right(nums, end)\n                if idx >= N:\n                    return True\n                start = nums[idx]\n                end = start + diameter\n            return False\n\n        l, r = 0, nums[-1] - nums[0]\n        while l <= r:\n            mid = (l + r) // 2\n            if possible(mid):\n                r = mid - 1\n            else:\n                l = mid + 1\n        return l / 2\n```\n参考题解\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345376850","body":"···\nclass Solution:\n    def smallestDistancePair(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        l = 0\n        r = max(nums) - min(nums)\n        nums.sort()\n        def check(x):\n            '''\n            计算数组中小于等于距离x的个数有多少个\n            '''\n            cnt = j = 0\n            for i, v in enumerate(nums):\n                while j < n and v - nums[j] > x:\n                    j += 1\n                cnt += i - j\n            return cnt >= k\n        # 二分找到一个距离x, 使得小于等于距离x的个数恰好有k个\n        while l < r:\n            # print(l, r)\n            mid = (l + r) // 2\n            if check(mid):\n                r = mid\n            else:\n                l = mid + 1\n            \n        return l\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345650094","body":"```\nclass UF:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.size = [1 for i in range(n)]\n    \n    def union(self, x, y):\n        fx = self.find(x)\n        fy = self.find(y)\n        if fx == fy:\n            return\n        if self.size[fx] < self.size[fy]:\n            fx, fy = fy, fx\n        self.size[fx] += self.size[fy]\n        self.parent[fy] = fx\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def isConnected(self, x, y):\n        return self.find(x)==self.find(y)\n        \nclass Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        /////# time = 16 的时候, 首尾连通了\n        edges = []\n        for i, row in enumerate(grid):\n            for j, x in enumerate(row):\n                edges.append((x, i, j))\n        uf = UF(m*n)\n        edges.sort(key=lambda it:it[0])\n        ////print(edges)\n        ///# 双指针\n        t = 0\n        while not uf.isConnected(0, m*n-1):\n            t+=1\n            while j < m*n and edges[j][0] <= t:\n                uf.union(0, edges[j][1]*n+edges[j][2])\n                j+=1\n        \n        return t\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1347422869","body":"```\nclass Solution:\n    def maxVowels(self, s: str, k: int) -> int:\n        n = len(s)\n        vowels = \"aeiou\"\n        j=ans=0\n        window = 0\n        for i, ch in enumerate(s):\n            if ch in vowels:\n                window+=1\n            \n            while j < n and (i-j+1) > k:\n                // # 长度大于k了, 需要缩小窗口\n                if s[j] in vowels:\n                    window -= 1\n                j+=1\n            \n            if (i-j+1) == k:\n                ans = max(ans, window)\n        \n        return ans\n\n```\n# 滑动窗口, 看数据范围","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/51#issuecomment-1349967098","body":"'''\nalice玩游戏, 根据卡牌游戏21点\n开始是0点, 随机获得分数[1, maxPts]\n得到k or more points的时候停下来\n返回的是概率\n例子一: k=1, \nrange [1, maxPoints], 即[1,10], n=10, 百分之百比n小\n例子二: k=1,\nrange[1, 10], n = 6, 可以抽出来的牌是1,2,3,4,5,6,7,8,9, 10, 小于等于n的概率是6 / 10 = 0.6\n例子三: k=17,\nrange[1, 10], n = 21\n状态: \n如果分数不到k, 游戏不会停止, 最后的ans是分数在k到n之间\n假设f[i]为 到达分数i的概率是多少, the probability of reaching at i \n距离 maxPts = 6, range = [1, 6], k=18, n=21\n所以f[14] = f[13] * P(1) + f[12] * P(2) + f[11] * P(3) + f[10] * P(4) + ... + f[8](即f[14 - maxPts]) * P(6)(即P(maxPts))\n转换成公式就是f[i] = f[i-1]*P(1) + f[i-2]*P(2)+f[i-3]*P(3) +...+f[i-maxPts]*P(maxPts)\n                 = f[i-1]* (1 / maxPts) + f[i-2] * (1 / maxPts)+f[i-3]* (1 / maxPts) +...+f[i-maxPts]* (1 / maxPts)\n                 = (f[i-1] + f[i-2] + f[i-3] + ... + f[i-maxPts]) / maxPts\n这个公式的edge cases是什么呢? \n1. 如果求f[3] = f[1] * P(2) + f[2] * P(1) =》 不适应公式\n2. 如果求f[21] = f[20], f[19], f[18] 不可能从这三个状态转移过来, 因为如果分数 >= k, 游戏便会停止\n       所以只能 = f[17] * P(4) + f[16] * P(5) + f[15] * P(6)         \n'''\n···\nclass Solution:\n    def new21Game(self, n: int, k: int, maxPts: int) -> float:\n        # 解法一: 未优化, TLE\n        # 如果游戏不能开始, 那么一开始的时候总分数就是0, 一定小于=n, 所以返回1\n        # if k == 0:\n        #     return 1.0\n        # # 最大能得到的分数是 k - 1 + maxPts\n        # maxScore = k - 1 + maxPts\n        # f = [0.0] * (maxScore + 1)\n        # # 分数为0的概率是1, 即一张牌都不拿, 那么肯定可以reach point 0\n        # f[0] = 1\n        # for i in range(1, maxScore + 1):\n        #     for j in range(1, maxPts + 1):\n        #         # handle edge cases\n        #         if i - j >= 0 and i - j < k:\n        #             f[i] += f[i-j] / maxPts\n        \n        # # print(f)\n        # return sum(f[i] for i in range(k,n+1))\n\n        # 解法二: DP + 滑动窗口\n        # 举例, 我们知道\n        # f[14] = (f[13] + f[12] + f[11] + f[10] + f[9] + f[8]) / maxPts\n        # f[13] =         (f[12] + f[11] + f[10] + f[9] + f[8] + f[7]) / maxPts\n        # \n        if k == 0 or maxPts + k <= n:\n            return 1.0\n        \n        f = [0.0] * (n + 1)\n        f[0] = 1\n        runningSum = f[0]\n        res = 0\n        for i in range(1, n+1):\n            # 假设running sum 已经准备好了\n            f[i] = runningSum / maxPts\n\n            # 处理窗口的头\n            if i < k:\n                runningSum += f[i]\n            else:\n                res += f[i]\n            \n            # 处理窗口的tail\n            if i - maxPts >= 0:\n                runningSum -= f[i-maxPts]\n        \n        return res\n···\n喜欢今天的题, 非常好","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1353648102","body":"'''\n理解题意: \n两个string s 和 p, 返回所有start index of p 的anagram in s\n维护一个长度为size p的窗口, 如果窗口内的所有字符满足了p的要求, 即count = need, 左指针j的位置就满足了答案\n'''\nclass Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        need = Counter(p)\n        window = defaultdict(int)\n        res = []\n        n = len(s)\n        unique = j = 0\n        for i, ch in enumerate(s):\n            window[ch] += 1\n            if ch in need and window[ch] == need[ch]:\n                unique += 1\n            while j < n and i-j+1 > len(p):\n                if s[j] in need and window[s[j]] == need[s[j]]:\n                    unique -= 1\n                window[s[j]]-=1\n                j += 1\n            if i - j + 1 == len(p) and unique == len(need):\n                res.append(j)\n        \n        return res\n        \n        ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/53#issuecomment-1353687928","body":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        need = Counter(t)\n        valid = j = 0\n        res = \"\"\n        minLen = inf\n        window = defaultdict(int)\n        n = len(s)\n        for i,ch in enumerate(s):\n            if ch in need:\n                window[ch] += 1\n                if window[ch] == need[ch]:\n                    valid += 1\n            \n            while j<n and valid==len(need):\n                sz = i-j+1\n                if sz < minLen:\n                    minLen = sz\n                    res = s[j:j+minLen]\n                if s[j] in need:\n                    if window[s[j]] == need[s[j]]:\n                        valid -= 1\n                    window[s[j]] -= 1\n                j += 1\n        \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356405128","body":"```\nclass Solution:\n    def maxScore(self, a: List[int], k: int) -> int:\n        n = len(a)\n        拿k张卡, 卡牌总和最大, 窗口的size 就是n - k, 窗口总和最小即可\n        res = inf\n        j = sum = 0\n        tot = 0\n        for i, x in enumerate(a):\n            tot += x\n            sum += x\n            while j < n and i - j + 1 > n - k:\n                sum -= a[j]\n                j += 1\n            if i - j + 1 == n - k:\n                res = min(res, sum)\n        return tot - res\n\n```","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1360836844","body":"···\nclass Solution:\n    def maxDistance(self, a: List[List[int]]) -> int:\n        n = len(a)\n        q = deque()\n        for i, l in enumerate(a):\n            for j, x in enumerate(l):\n                if x:\n                    q.append((i,j))\n\n        if len(q) == n * n or len(q) == 0: \n            return -1\n        \n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n        steps = 0\n        while q:\n            sz = len(q)\n            for _ in range(sz):\n                x, y = q.popleft()\n                for dx, dy in dirs:\n                    nx, ny = dx + x, dy + y\n                    if 0 <= nx < n and \\\n                       0 <= ny < n and \\\n                       a[nx][ny] == 0:\n                       a[nx][ny] = 1\n                       q.append((nx, ny))\n            steps += 1\n        \n        return steps - 1\n···","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/60#issuecomment-1365543900","body":"```\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        # 二叉树的竖直遍历, 竖直遍历: 大方向是从左到右, 小方向是从上到下\n        # 先存储大方向, 再存储小方向, 大方向是colIndex, 小方向是rowIndex\n        q = deque([(0, 0, root)])\n        pos = defaultdict(list)\n        while q:\n            r, c, node = q.popleft()\n            pos[c].append((r, node.val))\n            if node.left:\n                q.append((r+1, c-1, node.left))\n            if node.right:\n                q.append((r+1, c+1, node.right))\n        \n        res = []\n        cols = sorted(pos.keys())\n        for c in cols:\n            nodes = sorted(pos[c])\n            cur = []\n            for _, val in nodes:\n                cur.append(val)\n            res.append(cur)\n        return res\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365574796","body":"```\nclass Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        f = [1] * n \n        cnt = [1] * n \n        longest = 1\n        for i in range(1, n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    cur = f[j] + 1\n                    if cur > f[i]:\n                        f[i] = cur\n                        cnt[i] = cnt[j]\n                    elif cur == f[i]:\n                        cnt[i] += cnt[j]\n            longest = max(longest, f[i])\n        \n    #    #  print(longest)\n    #     print(cnt)\n    #     print(f)\n        ans = 0\n        for i in range(n):\n            if f[i] == longest:\n                ans += cnt[i]\n        \n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365442285","body":"···\nclass Solution:\n    def longestCommonSubsequence(self, s: str, t: str) -> int:\n        # 最长公共子序列\n        # 状态表示: f[i][j] 表示 s的前i个字符和t的前j个字符的公共子序列所有方案\n        # 属性: max\n        # 集合划分, 如果 s[i]和t[j] 相同的话\n        # f[i][j] = f[i-1][j-1] + 1\n        # 如果不同, 就是两者取max\n        m, n = len(s), len(t)\n        f = [[0] * (n+1) for _ in range(m+1)]\n\n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if s[i-1] == t[j-1]:\n                    f[i][j] = f[i-1][j-1] + 1\n                else:\n                    f[i][j] = max(f[i-1][j], f[i][j-1])\n        \n        return f[-1][-1]\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366099827","body":"```\nclass Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        f = [[0] * n for _ in range(m)]\n        for i in range(m):\n            f[i][0] = 1\n        \n        for i in range(n):\n            f[0][i] = 1\n        \n        for i in range(1, m):\n            for j in range(1,n):\n                f[i][j] = f[i-1][j] + f[i][j-1]\n        \n        return f[-1][-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1366807827","body":"···\nclass Solution:\n    def knightProbability(self, n: int, m: int, r: int, c: int) -> float:\n       // # n * n 的棋盘, 马尝试k步骤, \n        //# 有8种可能的移动\n        //# 概率: (i, j) in 即 0 <= i < n and 0 <= j < n 的概率\n        //# f[i][j][k] 代表通过k步骤 从r, c 到达i,j的概率\n        /#/ 上一步有八个方向\n        /#/ 上一步的八个方向的概率 相加 = 当前的概率\n        /#/ 初始化: f[r][c][0] = 1\n        /#/ ans: f[i][j][k] for i in range(n) for j in range(n)\n        DIRS = [(1,2), (1,-2), (-1,2), (-1,-2), (2, 1), (-2, 1), (2,-1), (-2, -1)]\n\n        f = [[[0] * (m+1) for _ in range(n)] for _ in range(n)]\n        f[r][c][0] = 1\n        //# 对于这种乱七八糟不知道在哪的, 注意枚举位置\n        for k in range(1, m + 1):\n            for i in range(n):\n                for j in range(n):\n                    for di, dj in DIRS:\n                        x, y = i - di, j - dj\n                        if 0 <= x < n and 0 <= y < n:\n                            f[i][j][k] += f[x][y][k-1]/ 8\n        \n        return sum(f[i][j][m] for i in range(n) for j in range(n))\n···","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/68#issuecomment-1368028733","body":"```\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        # 只有正数的数组, 分割成两个等和的子集\n        # 题目转化 => 相当于找到一个子序列, 子序列的和为sum // 2\n        tot = sum(nums)\n        n = len(nums)\n        if tot % 2:\n            return False\n        \n        target = tot // 2\n\n        # @cache\n        # def dfs(i:int, acc:int) -> bool:\n        #     if acc == target:\n        #         return True \n        #     if i == n:\n        #         return False\n        #     if acc > target:\n        #         return False\n            \n        #     # 选择当前的数字\n        #     choice1 = dfs(i + 1, acc + nums[i])\n        #     # 不选择当前的数字\n        #     choice2 = dfs(i + 1, acc)\n            \n        #     return choice1 or choice2 \n        \n        # return dfs(0, 0)\n\n        # 时间复杂度: 2**N\n\n        # f = [[False] * (target + 1) for _ in range(n + 1)]\n        # f[0][0] = True\n        # for i in range(1, n + 1):\n        #     for j in range(target + 1):\n        #         # 如果不选当前元素\n        #         f[i][j] = f[i-1][j]\n        #         # 如果选择当前元素\n        #         if j - nums[i-1] >= 0:\n        #             f[i][j] |= f[i-1][j - nums[i-1]]\n        # return f[-1][-1]\n\n        # 压缩到一维\n        f = [False] * (target + 1)\n        f[0] = True\n\n        for i, x in enumerate(nums):\n            for j in range(target, x - 1, -1):\n                f[j] |= f[j - x]\n        \n        return f[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368270715","body":"···\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        # 寻找和为target的 方案数\n        # + 代表 要当前的数字\n        # - 代表 不要当前的数字\n        # pos + neg = target \n        # x + -y = target\n        # x + -(s-x) = target\n        # x - s + x = target \n        # x = (target + s) // 2\n        s = sum(nums)\n        if (target + s) % 2 or (target + s) < 0:\n            return 0\n\n        \n        goal = (target + s) // 2\n        f = [0] * (goal + 1)\n        f[0] = 1\n        for x in nums:\n            for i in range(goal, x - 1, -1):\n                f[i] += f[i - x]\n        \n        return f[-1]\n···","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/70#issuecomment-1368552439","body":"```\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        f = [inf] * (amount + 1)\n        f[0] = 0\n        for i, v in enumerate(coins):\n            for j in range(v, amount + 1):\n                f[j] = min(f[j], f[j - v] + 1)\n        \n        return f[-1] if f[-1] != inf else -1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369190712","body":"```\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        f = [0] * (amount + 1)\n        # 完全背包求方案总数\n        f[0] = 1\n        for x in coins:\n            for i in range(x, amount + 1):\n                f[i] += f[i - x]\n            \n        return f[-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/72#issuecomment-1371504992","body":"```\nclass Solution:\n    def findContentChildren(self, g: List[int], s: List[int]) -> int:\n        # 每个孩子最多一个cookie\n        g.sort()\n        s.sort()\n        ans = 0\n        i = j = 0\n        m, n = len(g), len(s)\n        while i < m and j < n:\n            if g[i] <= s[j]:\n                ans += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n        \n        return ans\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/73#issuecomment-1371518225","body":"```\nclass Solution:\n    def eraseOverlapIntervals(self, a: List[List[int]]) -> int:\n        A = sorted(a, key = lambda it: it[1])\n        # # 按照终点排序\n        # i = j = 0\n        # ans = 0\n        # n = len(a)\n        # while i < n:\n        #     if j < n and A[j][0] < A[i][1]:\n        #         while j < n and A[j][0] < A[i][1]:\n        #             j += 1\n        #         ans += 1\n        #         i = j\n        #     else:\n        #         i += 1\n        \n        # return n - ans\n        n = len(a)\n        count = 1\n        x_end = A[0][1]\n        for start, end in A:\n            if start >= x_end:\n                x_end = end \n                count += 1\n        \n        return n - count\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/75#issuecomment-1382433313","body":"```\nclass Solution:\n    def numTrees(self, n: int) -> int:\n        @cache\n        def count(lo, hi):\n            if lo > hi:\n                return 1\n            res = 0\n            for root in range(lo, hi + 1):\n                left = count(lo, root - 1)\n                right = count(root + 1, hi)\n                res += left * right \n            return res\n        return count(1, n)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/76#issuecomment-1382436249","body":"```\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        # 多路归并\n        dummy = ListNode(0)\n        cur = dummy \n        minHeap = [] # pair(value, index)\n        for i, h in enumerate(lists):\n            if h:\n                heappush(minHeap, (lists[i].val, i))\n        \n        while minHeap:\n            v, idx = heappop(minHeap)\n            node = ListNode(v)\n            cur.next = node \n            cur = cur.next \n            if lists[idx].next:\n                lists[idx] = lists[idx].next\n                heappush(minHeap, (lists[idx].val, idx))\n        \n        return dummy.next\n        \n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/78#issuecomment-1382461367","body":"```\nclass Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        # 2 个 elments 出现 1次\n        # 所有的别的elements 出现2次\n        xor_res = 0\n        for x in nums:\n            xor_res ^= x \n        low_bit = xor_res & (-xor_res)\n        type1 = type2 = 0\n        for x in nums:\n            if low_bit & x:\n                type1 ^= x \n            else:\n                type2 ^= x \n        return [type1, type2]\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/79#issuecomment-1382462002","body":"```\nclass Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        n = len(nums)\n        # 不能包含重复的子集\n        res = []\n        # def backtrack(pos:int, cur: List[int]):\n        #     res.append(cur[:])\n        #     for i in range(pos, n):\n        #         # 选择当前的数字\n        #         cur.append(nums[i])\n        #         backtrack(i+1, cur)\n        #         cur.pop()\n        #     return cur\n        \n        # backtrack(0, [])\n        # return res\n\n        # 选 / 不选的模型\n        def backtrack(i: int, cur: List[int]):\n            if i >= n:\n                res.append(cur[:])\n                return \n            cur.append(nums[i])\n            backtrack(i+1, cur)\n            cur.pop()\n            backtrack(i+1, cur)\n        \n        backtrack(0, [])\n        return res\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/80#issuecomment-1382650174","body":"```\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.is_word = False\nclass Trie:\n\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            cur = cur.children[c]\n        cur.is_word = True\n    def search(self, word: str) -> bool:\n        cur = self.root\n        for c in word:\n            if cur is None or c not in cur.children:\n                return False \n            cur = cur.children[c]\n        return cur.is_word\n\n    def startsWith(self, prefix: str) -> bool:\n        cur = self.root \n        for c in prefix:\n            if cur is None or c not in cur.children:\n                return False\n            cur = cur.children[c]\n        return True\n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix)\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/81#issuecomment-1382652010","body":"```\nclass TrieNode:\n    def __init__(self):\n        self.children = defaultdict(TrieNode)\n        self.val = 0\nclass MapSum:\n\n    def __init__(self):\n        self.root = TrieNode()\n        self.d = {}\n\n\n    def insert(self, key: str, val: int) -> None:\n        delta = val\n        if key in self.d:\n            prev_val = self.d[key]\n            delta = val - prev_val\n        self.d[key] = val\n        cur = self.root \n        for ch in key:\n            cur = cur.children[ch]\n            cur.val += delta\n        \n    def sum(self, prefix: str) -> int:\n        cur = self.root\n        res = 0\n        for ch in prefix:\n            if cur is None or ch not in cur.children:\n                return 0\n            cur = cur.children[ch]\n        return cur.val\n\n# a 3\n# ap 3\n# b 2 \n# a 3\n\n# apple 3\n# ap   3\n# app 2\n# apple 2\n# ap  7\n\n# Your MapSum object will be instantiated and called as such:\n# obj = MapSum()\n# obj.insert(key,val)\n# param_2 = obj.sum(prefix)\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1382950678","body":"```\nclass UF:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1 for _ in range(n)]\n        self.count = n\n        \n    def union(self, x, y):\n        fx = self.find(x)\n        fy = self.find(y)\n        if fx == fy:\n            return \n        if self.size[fx] < self.size[fy]:\n            fx, fy = fy, fx \n        self.size[fx] += self.size[fy]\n        self.par[fy] = fx \n        self.count -= 1\n    \n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    \nclass Solution:\n    def findCircleNum(self, a: List[List[int]]) -> int:\n        # UF\n        n = len(a)\n        uf = UF(n)\n        for i, row in enumerate(a):\n            for j, v in enumerate(row):\n                if v:\n                    uf.union(i, j)\n        \n        return uf.count\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dou-yu-xuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1320839822","body":"## 解题思路：\n把数组nums转换成整数，然后加上k值，  \n然后再把求到的和值进行数值切分，添加到列表的头部，最后返回整个数组  \n\n## 代码：\n    class Solution:  \n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:  \n            item = 0  \n            new_list = []  \n            for i in num:  \n                item = item*10 + i  \n            new_total = item + k  \n            while new_total !=0:  \n                last =  new_total % 10  \n                new_total //= 10    \n                new_list.insert(0,last)  \n            return new_list  \n\n## 复杂度分析：\n时间复杂度：O(n),for循环遍历整个数组，n为数组元素个数，\nwhile循环遍历整数值，相当于for循环遍历，所以时间复杂度为O(n)  \n空间复杂度：新开辟一个列表的存储空间，列表长度为n，所以空间复杂度为O(n)  ","onTime":false},null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1320068706","body":"dfs深度优先搜索解题思路：   \n前序遍历二叉树  \n二叉树最大深度 = max（左子树最大深度，右子树最大深度）+ 1  \n只要求出两边子树的最大深度即可求出整个二叉树的最大深度  \n\n\"\"\"\n\n    class Solution:  \n        def maxDepth(self, root) -> int:  \n            if root is None:  \n                return 0  \n            else:  \n                left_deep = self.maxDepth(root.left)  \n                right_deep = self.maxDepth(root.right)  \n                return max(left_deep,right_deep) + 1  \n\n\n\"\"\"\n\n时间复杂度分析：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。  \n\n空间复杂度分析：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1320162601","body":"## 深度搜索思路：\n    if q 和 p 都为空 return True\n    if q 或 p 有一个为 空 return False\n    if q 和 p 都不空：\n        比较两个树的根节点，左子树，右子树。\n        算法使用递归调用\n## 代码\n    class Solution:  \n        def isSameTree(self, p, q) -> bool:  \n            if not p and not q :  \n                return True  \n            elif not p or not q :  \n                return False  \n            elif p.val == q.val:  \n                return (self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right))  \n            else:  \n                return False  \n\n## 复杂度分析\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1320227647","body":"## 深度搜索题解思路：\n\nif 根节点为空，return 0  \nelse: 从根节点开始遍历，if 当前为叶子节点：叶子节点 + 数字之和    \n                                           #                                                 #  ##### ##########else 继续遍历  \n\n## 代码\n\n    class Solution:  \n        def sumNumbers(self, root) -> int:  \n            def dfs(root,number):  \n                if not root:  \n                    return 0  \n                total_number = 10 * number + root.val  \n                print(\"左叶子节点\", not root.left)  \n                if not root.left and not root.right:  \n                    print(total_number)  \n                    return total_number  \n                else:  \n                    return dfs(root.left,total_number) + dfs(root.right,total_number)  \n            return dfs(root,0)  \n\n## 复杂度分析：\n时间复杂度：O(n)，其中 n是二叉树的节点个数。对每个节点访问一次。\n\n空间复杂度：O(n)，其中 n是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1320247070","body":"## 解体思路：\n遍历整个二叉树，把二叉树的节点的x,y,value放到一个列表list_0中，x表示横坐标，y表示纵坐标，value表示当前节点的值。按照y值的大小进行升序排列。要把list_0进行遍历，要取出相同y值 \n 的的value值，放到一个列表中。\n## 代码：\n\n    from operator import itemgetter  \n        class Solution:  \n            def verticalTraversal(self, root):  \n                list_0 = list()  \n                def dfs(list_1, x, y):  \n                    \"\"\"\n                    :param node: 树的节点值\n                    :param x: 横坐标\n                    :param y: 纵坐标\n                    :return: none\n                    \"\"\"\n                    if not list_1:  \n                        return  \n                    list_0.append((x, y, list_1.val))  \n                    dfs(list_1.left, x + 1, y - 1)  \n                    dfs(list_1.right, x + 1, y + 1)  \n    \n                dfs(root, 0, 0)  \n                list_0.sort()  \n                list_0 = sorted(list_0,key=itemgetter(1))  \n                print(list_0)  \n                ans, lasty = list(), float(\"-inf\")  \n                for x, y, value in list_0:  \n                    print(y)  \n                    if y != lasty:  \n                        lasty = y  \n                        ans.append(list())  \n                    ans[-1].append(value)  \n                    print(\"lasty\", ans)  \n                return ans  \n”“”\n\n## 复杂度分析：\n时间复杂度：O(nlogn)  \n空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320731061","body":"## 解题思路：\r\n暴力枚举：遍历nums数组，判断是否 y + x=target\r\n\r\n## 代码：\r\n    class Solution:\r\n        def twoSum(self, nums, target):\r\n            for i in range(len(nums)):\r\n                for j in range(i+1,len(nums)):\r\n                    if nums[j] + nums[i] == target:\r\n                        return [i,j]\r\n\r\n## 复杂度分析：\r\n时间复杂度：嵌套遍历nums两遍 O(n²)  \r\n空间复杂度：O(1)\r\n\r\n## 哈希表思路：\r\n将nums 中的值和下表放到哈希表中，哈希表组成一个字典，通过查询target-x 的值是否在字典中，返回对应的下标。  \r\n\r\n## 代码\r\n    class Solution:  \r\n        def twoSum(self, nums: List[int], target: int) -> List[int]:  \r\n            hashtable = dict()  \r\n            for i, num in enumerate(nums):  \r\n                if target - num in hashtable:  \r\n                    return [hashtable[target - num], i]  \r\n                hashtable[nums[i]] = i  \r\n            return []  \r\n    a = Solution()  \r\n    numbers = [1,2,3,4,5,6,7,8,9]  \r\n    print(a.twoSum(numbers,8))  \r\n\r\n## 复杂度分析\r\n时间复杂度：O（n)  \r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321128371","body":"class Solution:  \n    def topKFrequent(self, nums, k: int) -> int:\n\n        heap = [(-1 * v1, k1) for k1, v1 in Counter(nums).items()]  # O(N) to build the heap\n        heapq.heapify(heap)  # O((n-k) log n). Worst case O(n log n).\n        result = []\n        for i in range(k):\n            result.append(heapq.heappop(heap)[1])  # O(logN) / O((n-k) log n) for the pops\n        return result","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1322277709","body":"     class Solution:\n        def numberOfBoomerangs(self, points: List[List[int]]) -> int:  \n            an = 0  \n            for i in points:  \n                cnt = defaultdict(int)  \n                #print(cnt)  \n                for m in points:  \n                    dist = (i[0]-m[0])*(i[0]-m[0])+(i[1]-m[1])*(i[1]-m[1])  \n                    cnt[dist] += 1  \n                print(cnt)  \n                for m in cnt.values():  \n                    print(m)  \n                    an += m * (m - 1)  \n            return an  \n\n## 复杂度分析：\n\n时间复杂度为O(n^2)  \n空间复杂度为O(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328035256","body":"    class Solution:  \n        def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:  \n           p=q=head  \n           while q and q.next:  \n               p = p.next  \n               q = q.next.next  \n           return p  ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328033327","body":"# 思路：\n考虑用 2 个指针，一个在前记作 p，一个在后记作 q，算法流程如下：  \n1.比较 p 和 q 位置的元素是否相等。  \n如果相等，q 后移 1 位  \n2.如果不相等，将 q 位置的元素复制到 p+1 位置上，p 后移一位，q 后移 1 位  \n重复上述过程，直到 q 等于数组长度。返回 p + 1，即为新数组长度  \n\"\"\"  \n# 代码\n    class Solution:  \n        def removeDuplicates(self, nums: List[int]) -> int:  \n            if not nums:  \n                return 0  \n            n = len(nums)  \n            p = q = 0   \n            while q<n:  \n                if nums[p] ==nums[q]:  \n                    q +=1  \n                else:  \n                    nums[p+1]=nums[q]  \n                    p +=1  \n                    q +=1  \n            return p+1  \n    m = Solution()  \n    data = [1,1,2]  \n    m.removeDuplicates(data)  \n\n\"\"\"\n# 复杂度分析：  \n时间复杂度：O(n)  \n空间复杂度：O(1)  \n\"\"\"","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333867834","body":"class Solution:\n    def sortItems(self, n: int, m: int, group: List[int], beforeItems: List[List[int]]) -> List[int]:\n        max_id = m \n        \n        for i in range(n):\n            if group[i] == -1:\n                group[i] = max_id\n                max_id += 1\n        \n        project_indegree = collections.defaultdict(int)\n        group_indegree = collections.defaultdict(int)\n        project_neighbors = collections.defaultdict(list)\n        group_neighbors = collections.defaultdict(list)\n        group_projects = collections.defaultdict(list)\n        \n        \n        for i in range(n):\n            group_projects[group[i]].append(i)\n            \n            for pre in beforeItems[i]:\n                if group[pre] != group[i]:\n                    group_indegree[group[i]] += 1\n                    group_neighbors[group[pre]].append(group[i])\n                else:\n                    project_indegree[i]+=1\n                    project_neighbors[pre].append(i)\n        \n        res = []\n        \n        group_queue = self.tp_sort([i for i in range(max_id)], group_indegree, group_neighbors)\n        \n        if len(group_queue) != max_id: return []\n        \n        for group_id in group_queue:\n            project_queue = self.tp_sort(group_projects[group_id], project_indegree, project_neighbors)\n            \n            if len(project_queue) != len(group_projects[group_id]): return []\n            \n            res += project_queue\n        \n        return res\n                    \n        \n    def tp_sort(self, items, indegree, neighbors):\n        res = []\n        queue = collections.deque([])\n        \n        for item in items:\n            if indegree[item] == 0:\n                queue.append(item)\n                \n        while(queue):\n            t = queue.popleft()\n            res.append(t)\n            \n            for neighbor in neighbors[t]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return res","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339460515","body":"    class Solution:  \n        def sortArray(self, N):  \n            def quicksort(A, I, J):  \n                if J - I <= 1: return  \n                p = partition(A, I, J)  \n                quicksort(A, I, p), quicksort(A, p + 1, J)  \n        \n            def partition(A, I, J):  \n                A[J-1], A[(I + J - 1)//2], i = A[(I + J - 1)//2], A[J-1], I  \n                for j in range(I,J):  \n                    if A[j] < A[J-1]: A[i], A[j], i = A[j], A[i], i + 1  \n                A[J-1], A[i] = A[i], A[J-1]  \n                return i  \n        \n            quicksort(N,0,len(N))  \n            return N  ","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/48#issuecomment-1345525834","body":"    class Solution:  \r\n        def smallestDistancePair(self, nums: List[int], k: int) -> int:  \r\n            def count(mid):  \r\n                cnt = 0  \r\n                for j, num in enumerate(nums):  \r\n                    i = bisect_left(nums, num-mid, 0, j)  \r\n                    cnt += j - i  \r\n                return cnt  \r\n            nums.sort()  \r\n            return bisect_left(range(nums[-1] - nums[0]), k, key=count)  ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/54#issuecomment-1356143308","body":"    class Solution:  \n        def solve(self, A, target):  \n            if not A and not target: return 0  \n            target = sum(A) - target  \n            ans = len(A) + 1  \n            i = t = 0  \n\n            for j in range(len(A)):  \n                t += A[j]  \n                while i <= j and t > target:  \n                    t -= A[i]  \n                    i += 1  \n                if t == target: ans = min(ans, len(A) - (j - i + 1))  \n            return -1 if ans == len(A) + 1 else ans   ","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359164966","body":"# 思路： \n我们可以使用深度优先搜索来解决这个问题。  \n\n在深度优先搜索中，我们从起点开始，沿着一条路径一直搜索直到无法继续为止，然后回溯并探索另一条路径。这种方法使我们能够找到所有从起点可到达的点，也就是岛屿的所有部分。  \n\n我们可以定义一个递归函数，每次调用它的时候传入当前点的行和列作为参数。然后我们检查这个点是否是 1，如果是，我们将其设置为 0，并将这个点作为新的起点调用递归函数，探索其 \n 上下左右的点。这样我们就能够遍历整个岛屿，并将它标记为已探索过。    \n\n为了计算岛屿的面积，我们可以在递归函数中计数器加 1。最后，我们可以遍历整个网格，找到所有未被探索过的 1，并使用递归函数计算每个岛屿的面积，返回最大的面积即可。  \n\n  # 代码    \n     class Solution:\n         def dfs(self,grid,cur_i,cur_j):\n             if cur_i<0 or cur_j<0 or cur_i==len(grid) or cur_j ==len(grid[0] or grid[cur_i][cur_j]!=1):\n                return 0\n            grid[cur_i][cur_j]=0\n            ans = 1\n            for di,dj in [[0,1],[0,-1],[1,0],[-1,0]]:\n                next_i,next_j = cur_i+di,cur_j+dj\n               ans += self.dfs(grid,next_i,next_j)\n            return ans\n\n        def maxAreaOfIsland(self, grid) :\n           ans =0\n           for i,l in enumerate(grid):\n                for j,n in enumerate(l):\n                    ans = max(self.dfs(grid,i,j),ans)\n           return ans","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365069346","body":"    class Solution:  \n        def findNumberOfLIS(self, nums: List[int]) -> int:  \n            if len(nums) <= 1:  \n                return len(nums)  \n            dp = [1] * len(nums)  \n            count = [1] * len(nums)  \n            res = 0  \n            max_length = 0 \n            for i in range(1, len(nums)):  \n                for j in range(0, i):  \n                    if nums[i] > nums[j]: \n                        if dp[i] < dp[j] +1:  \n                            dp[i] = dp[j] + 1  \n                            count[i] = count[j]  \n                        elif dp[i] == dp[j] + 1: \n                            count[i] += count[j] \n                max_length = max(max_length, dp[i]) \n          \n            for i in range(len(nums)):  \n                 if max_length == dp[i]:  \n                   res += count[i]  \n            return res  ","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/69#issuecomment-1368411478","body":"    class Solution:\n        def findTargetSumWays(self, nums, target) -> bool:  \n            t = sum(nums) + target  \n            if t % 2:   \n                return 0  \n            t = t // 2  \n\n            dp = [0] * (t + 1)  \n            dp[0] = 1  \n\n            for i in range(len(nums)):  \n               for j in range(t, nums[i] - 1, -1):  \n                    dp[j] += dp[j - nums[i]]  \n            return dp[-1]  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326840784","body":"\"public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n\n        if (fast.next == null) {\n            return slow;\n        } else {\n            return slow.next;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1327999479","body":"class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        len_ = 1\n        if len(nums)==0:\n            return 0\n        for i in range(1,len(nums)):\n            if nums[i] != nums[i-1]:\n                nums[len_] = nums[i]\n                len_ +=1\n        return len_","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330062488","body":"class Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] outDegrees = new int[n + 1];\n        int[] inDegrees = new int[n + 1];\n        for (int[] ab : trust) {\n            outDegrees[ab[0]] += 1;\n            inDegrees[ab[1]] += 1;\n        }\n        for (int i = 1; i <= n; ++i) {\n            if (inDegrees[i] == n - 1 && outDegrees[i] == 0) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/39#issuecomment-1334773485","body":"class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        int length = moves.length();\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') {\n                y--;\n            } else if (move == 'D') {\n                y++;\n            } else if (move == 'L') {\n                x--;\n            } else if (move == 'R') {\n                x++;\n            }\n        }\n        return x == 0 && y == 0;\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341932757","body":"public class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int l = 1, r = n;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if (isBadVersion(mid)) r = mid - 1;\n            else l = mid + 1;\n        }\n        return l;        \n    }\n}","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/49#issuecomment-1345605659","body":"class Solution {\n    public int swimInWater(int[][] grid) {\n        int N = grid.length;\n        int lo = 0, hi = N * N - 1;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            boolean[][] visit = new boolean[N][N];\n            if (reachBottom(grid, mi, N, visit, 0, 0)) hi = mi;\n            else lo = mi + 1;\n        }\n        return lo;\n    }\n\n    private boolean reachBottom(int[][] grid, int t, int N, boolean[][] visit, int i, int j) {\n        if (i < 0 || i >= N || j < 0 || j >= N || visit[i][j] || grid[i][j] > t) return false;\n        visit[i][j] = true;\n        if (i == N - 1 && j == N - 1) return true;\n        else return reachBottom(grid, t, N, visit, i + 1, j) || reachBottom(grid, t, N, visit, i - 1, j) || reachBottom(grid, t, N, visit, i, j - 1) || reachBottom(grid, t, N, visit, i, j + 1);\n    }\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1352515003","body":"class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        int len = p.length();\n        \n        int digitsNeed = len;\n        int[] freq = new int[26];\n        for (int i = 0; i < len; i++) {\n            freq[p.charAt(i) - 'a']++;\n        }\n        \n        int left = 0;\n        for (int right = 0; right < s.length(); right++) {\n            /* ------------左侧收缩------------ */\n            while (right - left >= len) {\n                char cl = s.charAt(left);\n                if (freq[cl - 'a'] >= 0) {\n                    digitsNeed++;\n                }\n                freq[cl - 'a'] ++;\n                left++;\n            }\n            /* ------------右侧更新------------ */\n            char cr = s.charAt(right);\n            freq[cr - 'a']--;\n            if (freq[cr - 'a'] >= 0) {\n                digitsNeed--;\n            }\n            /* ------------添加结果------------ */\n            if (digitsNeed == 0) {\n                result.add(left);\n            }\n        }\n        return result;\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1358573270","body":"```    \n    public int maxAreaOfIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int maxArea = 0;\n        int area;\n        boolean[][] visited = new boolean[m][n];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    area = dfs(grid, i, j, visited);\n                    maxArea = Math.max(area, maxArea);\n                } \n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int x, int y, boolean[][] visited) {\n        int m = grid.length;\n        int n = grid[0].length;\n        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != 1 || visited[x][y]) {\n            return 0;\n        }\n\n        visited[x][y] = true;\n        int area = 1;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        for (int[] dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            area += dfs(grid, nx, ny, visited);\n        }\n\n        return area;\n    }\n```\nTime O(mn)\nSpace O(mn)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/59#issuecomment-1362480154","body":"```\nclass Solution {\n\tpublic int solve(int[][] graph, int target) {\n\t\tQueue<Integer> queue = new LinkedList<>();\n\t\tSet<Integer> visited = new HashSet<>();\n\t\tqueue.offer(target);\n\t\tint step = 0;\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint size = queue.size();\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tint cur = queue.poll();\n\t\t\t\tfor (int neighbor : graph[target]) {\n\t\t\t\t\tif (!visited.contains(neighbor)) {\n\t\t\t\t\t\tvisited.add(neighbor);\n\t\t\t\t\t}\n\t\t\t\t\tif (neighbor == target) {\n\t\t\t\t\t\treturn neighbor;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tstep++;\n\t\t}\n\n\t\treturn -1;\n\t}\n}\n```\nTime O(V+E)\nSpace O(V)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1365509184","body":"class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        //初始化dp[0][] 和dp[][0]为0，因为当一个字符串长度为0时，那么他们的LCS长度也为0\n        Arrays.fill(dp[0], 0);\n        for(int i = 0; i <= m; i++){\n            dp[i][0] = 0;\n        }\n\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(text1.charAt(i - 1) == text2.charAt(j - 1))//该字符可以加入LCS\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                else{//该位置的字符不相等，至少有一个不能加入LCS，先选择当前局部最优解，即选择前面的较大值\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n       \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366361910","body":"class Solution {\n    public int uniquePaths(int m, int n) {\n        if (m == 1 || n == 1) return 1;\n\n        int[][] dp = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == 0 || j == 0) {\n                    dp[i][j] = 1;\n                }\n                else {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n                \n            }\n        }\n\n        return dp[m - 1][n - 1];\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/66#issuecomment-1366909125","body":"# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nFrom every cell on the chessboard, there are only eight directions we can go. Therefore, we can use a DP array to store the probability to reach each cell and update the probability Array step by step.\n# Approach\n<!-- Describe your approach to solving the problem. -->\n- Initialize an $$n*n$$ array $$dp$$ ```lastStep```, to store the probability to reach each cell, where ```lastStep[row][column]``` is set to be 1 because that is starting state.\n- Update the array step by step ($$k$$ steps in total), for each step, use a new $$n*n$$ array ```currentStep``` to represent the current step probability. (Use two seperate arrays because otherwise the probability of reaching ```[row][col]``` will be greater than 1)\n- Updating rule is :\nfor each of the 8 directions:  \n    - `currentRow = previousRow + dir[0]`\n    - `currentColumn = previousColumn + dir[1]`\n    - If cuurentRow or currentColumn is out of the board, skip.\n    - Otherwise:\n    ```currentStep[currentRow][currentColumn] += lastStep[previousRow][previousColumn] ```\nTherefore, the probability in each cell of currentStep is a sum of the probabilities from all the cells that are one step before.\n- After each step, assign `lastStep` to be `currentStep`\n- Sum all the probabilities within the ```lastStep``` array\n# Complexity\n- Time complexity: $$O(kn^2)$$\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\n\n- Space complexity: $$O(n^2)$$\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\n\n# Code\n```\nclass Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        int[][] dirs = {{-2, 1}, {-1, 2}, {1, 2}, {2, 1}, {2, -1}, {-1, -2}, {1, -2}, {-2, -1}};\n        double[][] lastStep = new double[n][n];\n        lastStep[row][column] = 1;\n\n        for (; k > 0; k--) {\n            double[][] currentStep = new double[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int[] dir : dirs) {\n                        int x = i + dir[0];\n                        int y = j + dir[1];\n                        if (x < 0 || x >= n || y < 0 || y >= n) continue;\n                        currentStep[x][y] += lastStep[i][j] / 8.0;\n                    }\n                }\n            }\n            lastStep = currentStep;\n        }\n\n        double res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                res += lastStep[i][j];\n            }\n        }\n\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369454941","body":"class Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int coin : coins) {\n            for (int i = coin; i <= amount; i++) {\n                if (i - coin >= 0) {\n                    dp[i] += dp[i - coin];\n                }\n            }\n        }\n        return dp[amount];\n    }\n}","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/77#issuecomment-1374955201","body":"class Solution:\r\ndef beautifulArray(self, n: int) -> List[int]:\r\n@lru_cache(None)\r\ndef dp(n):\r\nif n == 1:\r\nreturn [1]\r\nans = []\r\nfor a in dp(n - n // 2):\r\nans += [a * 2 - 1]\r\nfor b in dp(n // 2):\r\nans += [b * 2]\r\nreturn ans\r\n\r\n   return dp(n)","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/83#issuecomment-1383068742","body":"class Solution {\n    public int findCircleNum(int[][] isConnected) {\n        //城市数量\n        int n = isConnected.length;\n        //表示哪些城市被访问过\n        boolean[] visited = new boolean[n];\n        int count = 0;\n        //遍历所有的城市\n        for(int i = 0; i < n; i++){\n        //如果当前城市没有被访问过，说明是一个新的省份，\n        //count要加1，并且和这个城市相连的都标记为已访问过，\n        //也就是同一省份的\n            if(!visited[i]){\n                dfs(isConnected, visited, i);\n                count++;\n            }\n        }\n        return count;\n    }\n\n    public void dfs(int[][] isConnected, boolean[] visited, int i){\n        for(int j = 0; j < isConnected.length; j++){\n            if(isConnected[i][j] == 1 && !visited[j]){\n                //如果第i和第j个城市相连，说明他们是同一个省份的，把它标记为已访问过\n                visited[j] = true;\n                //然后继续查找和第j个城市相连的城市\n                dfs(isConnected, visited, j);\n            }\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cs12300":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332156113","body":"class Solution {\nprivate:\n    vector<int> color;\n    vector<vector<int>> edges;\n\n    bool bitpart(int u, int c) {\n        color[u] = c;\n        for(int v : edges[u]) {\n            if(color[v] != -1 && color[v] == c) {\n                return false;\n            }\n            if(color[v] == -1 && !bitpart(v,!c))return false;\n        }\n        return true;\n    }\npublic:\n    bool possibleBipartition(int N, vector<vector<int>>& dislikes) {\n        edges.resize(N+1);\n        for(vector<int> edg:dislikes) {\n            edges[edg[0]].push_back(edg[1]);\n            edges[edg[1]].push_back(edg[0]);\n        }\n        color.resize(N+1,-1);\n        for(int i = 1;i <= N; ++i) {\n            if(color[i] == -1 && !bitpart(i,0))return false;\n        }\n        return true;\n    }\n};、","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiehw":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300675274","body":"## 解题思路\r\n\r\n最初思路：先找到第一个 c，并把前面的距离填充好，后面再继续找 c，最后按左右对称来填充。\r\n看了题解：前后两趟遍历（Orz）\r\n\r\n## 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n        int index;\r\n\r\n        index = -2*n; // 保证足够小，i - index 得到一个足够大的数。\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = i - index;\r\n        }\r\n\r\n        index = 2*n;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = min(ans[i], index - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复制度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302251142","body":"## 思路\n使用 vector 存放\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int top, max;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (top == max - 1) {\n            return;\n        }else{\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：pop O(0), push O(1), inc O(k)\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303618337","body":"## 思路\n用栈实现类似计算器的操作\n\n## 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466540","body":"# 思路\r\n\r\n两个栈之间移动元素\r\n\r\n# 代码\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            int x = inStack.top();\r\n            outStack.push(x);\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n    \r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304990179","body":"# 思路\r\n基本思路：\r\n找到关键的 3 个点（断开部分的两个点 p1、p2、尾部节点 p3），利用穿针引线法连接。\r\n\r\n大致步骤：\r\n- 判断边界条件：当 K 为 0，链表长度为 0、1  时不需要旋转。\r\n- 求解移动长度：k = k % len。在这确定尾部节点，设置为 p3。\r\n- 设置快慢指针：让快指针先走 k 步。在这确定断开的两个点，设置为 p1 和 p2。\r\n- 将各个点相连，返回 p2。\r\n\r\n# 算法\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k == 0 || head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode *cur = head;\r\n        while(cur->next != nullptr){\r\n            len+=1;\r\n            cur = cur->next;\r\n        }\r\n        k = k % len;\r\n        if(k == 0){\r\n            return head;\r\n        }\r\n\r\n        ListNode *p1, *p2, *p3, *slow, *fast;\r\n        p3 = cur;\r\n\r\n        slow = head;\r\n        fast = head;\r\n        while(k-- > 0){\r\n            fast = fast->next;\r\n        }\r\n\r\n        while(fast->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        p1 = slow;\r\n        p2 = slow->next;\r\n\r\n        p3->next = head;\r\n        p1->next = nullptr;\r\n\r\n        return p2;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/15#issuecomment-1306496624","body":"## 思路\n基本思路：\n使用四点法交换节点。\n\n大致步骤：\n1. 判断边界条件进行打表。\n2. 设置 dummy 头。\n3. 使用 cur 指针遍历链表，每次移动两步。\n4. 在遍历过程中利用四点法不断交换节点。\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        if(head == nullptr || head->next == nullptr){\n            return head;\n        }\n        \n        ListNode dummy;\n        dummy.next = head;\n        ListNode *p1, *p2, *p3, *p4, *cur = &dummy;\n        while(cur != nullptr && cur->next != nullptr && cur->next->next != nullptr){\n            p1 = cur;\n            p2 = cur->next;\n            p3 = cur->next->next;\n            p4 = cur->next->next->next;\n\n            p1->next = p3;\n            p3->next = p2;\n            p2->next = p4;\n\n            cur = cur->next->next;\n        }\n        return dummy.next;\n    }\n};\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/16#issuecomment-1308177600","body":"类似 105. 从前序与中序遍历序列构造二叉树\n\n# 思路\n\n基本思路：\n每次构建一个节点。使用中间节点构建当前节点，使用左侧的节点构建左子树，使用右侧的节点构建右子树。\n\n大致流程：\n1. 将当前子树的序列作为参数。\n2. 根据子树序列的中值作为根节点。\n3. 以中值划分左右子树，递归构建左子树和右子树。\n\n# 代码\n\n```c++\nclass Solution {\nprivate:\n    deque<int> values;\n\npublic:\n    TreeNode* buildTree(int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n        int mid = (left + right + 1) / 2;\n        TreeNode* root = new TreeNode(values[mid]);\n        root->left = buildTree(left, mid-1);\n        root->right = buildTree(mid+1, right);\n        return root;\n    }\n\n    TreeNode* sortedListToBST(ListNode* head) {\n        while(head != nullptr){\n            values.push_back(head->val);\n            head = head->next;\n        }\n        return buildTree(0, values.size() - 1);\n    }\n};\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/17#issuecomment-1309724960","body":"## 基本思路\n\n- 走到尽头见不到你，于是走你来时的路，等到相遇时才发现，你也走过我来时的路。\n\n\n\n## 大致步骤\n\n1. pA 和 pB 将两个链表都遍历一遍，但 pA 从 A 链表开始，pB 从 B 链表开始。当 pA 等于 pB 时，pA/pB 要么指向 NULL，要么指向同一个节点。\n2. pA 和 pB 同时进行遍历。\n3. 如果 pA 遍历完 A 链表，那么让 pA 在继续遍历 B 链表。\n4. 如果 pB 遍历完 B 链表，那么让 pB 在继续遍历 A 链表。\n\n\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode *pA, *pB;\n        pA = headA;\n        pB = headB;\n\n        while(pA != pB){\n            if(pA == NULL){\n                pA = headB;\n            }else{\n                pA = pA->next;\n            }\n            if(pB == NULL){\n                pB = headA;\n            }else{\n                pB = pB->next;\n            }\n        }\n        return pA;\n    }\n};\n```\n\n\n\n## 复杂度分析\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/18#issuecomment-1311169395","body":"## 基本思路：\n\n简化模型，最后求得快慢指针相交点和链表相交点的关系 a=c+(n-1)(b+c)\n\n\n\n## 大致步骤：\n\n1. 打表。\n1. 使用 head 指针遍历链表，并设置快指针每次走两步。\n1. 如果没有环 head 会等于 NULL，否则会一直循环。\n1. 如果快慢指针移动到相交的地方， 定义 ptr 指针从链表头开始，直到慢指针和 ptr 指针重合，退出循环。\n1. 返回 head 指针。\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(head == NULL){\n            return NULL;\n        }\n\n        ListNode *fast, *ptr;\n        fast = ptr = head;\n\n        while(head != NULL){\n            head = head->next;\n            if(fast->next != NULL && fast->next->next != NULL){\n                fast = fast->next->next;\n            }else{\n                head = NULL;\n                break;\n            }\n\n            if(fast == head){\n                while(ptr != head){\n                    ptr = ptr->next;\n                    head = head->next;\n                }\n                break;\n            }\n        }\n\n        return head;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/19#issuecomment-1312295522","body":"## 基本思路：\n\n- get：哈希字典查找 O(1)。\n- put：将节点放入链表尾部 O(1)。\n\n\n\n## 大致步骤：\n\n1. put：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面（和 get 相同）。如果没有找到该节点，那么在最前面插入一个节点。如果超过容量，那么就从尾部删除一个节点。\n2. get：从哈希字典中寻找 key，如果找到该节点，那么把节点放在最前面。\n\n\n\n## 代码：\n\n```c++\nstruct DNode{\n    int key, value;\n    DNode* prev;\n    DNode* next;\n    DNode(): key(0), value(0), prev(nullptr), next(nullptr){}\n    DNode(int k, int v): key(k), value(v), prev(nullptr), next(nullptr){}\n};\n\nclass LRUCache {\nprivate:\n    unordered_map<int, DNode*> _cache;\n    DNode *_head;\n    DNode *_tail;\n    int _size;\n    int _capacity;\n\n    DNode* removeTail(){\n        DNode *node = _tail->prev;\n        removeNode(node);\n        return node;\n    }\n\n    void removeNode(DNode *node){\n        node->prev->next = node->next;\n        node->next->prev = node->prev;\n    }\n\n    void addNodeToHead(DNode *node){\n        _head->next->prev = node;\n        node->next = _head->next;\n        _head->next = node;\n        node->prev = _head;\n    }\n\n    void moveToHead(DNode *node){\n        removeNode(node);\n        addNodeToHead(node);\n    }\n\npublic:\n    LRUCache(int capacity): _capacity(capacity), _size(0) {\n        _head = new DNode();\n        _tail = new DNode();\n        _head->next = _tail;\n        _tail->prev = _head;\n    }\n    \n    int get(int key) {\n        if(!_cache.count(key)){\n            return -1;\n        }\n        DNode *node = _cache[key];\n        moveToHead(node);\n        return node->value;\n    }\n    \n    void put(int key, int value) {\n        DNode *node, *removed;\n        if(!_cache.count(key)){\n            node = new DNode(key, value);\n            addNodeToHead(node);\n            _cache[key] = node;\n            _size+=1;\n            if(_size > _capacity){\n                removed = removeTail();\n                _cache.erase(removed->key);\n                _size--;\n                delete removed;\n            }\n        }else{\n            node = _cache[key];\n            node->value = value;\n            moveToHead(node);\n        }\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：put=O(1)、get=O(1)\n- 空间复杂度：put=O(1)、get=O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312591979","body":"## 基本思路：\n\n- 直接套层序遍历模版\n\n\n\n## 代码：\n\n```c++\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr){\n            return 0;\n        }\n        queue<TreeNode *> q;\n        TreeNode *node;\n        int step, size, i;\n        \n        step = 0;\n        q.push(root);\n        \n        while(!q.empty()){\n            size = q.size();\n            for(i=0; i<size; i++){\n                node = q.front();\n                q.pop();\n                if(node->left){\n                    q.push(node->left);\n                }\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            step+=1;\n        }\n\n        return step;\n    }\n};\n```\n\n\n\n## 复杂度分析：\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1314695030","body":"## 基本思路：\r\n\r\n- 递归判断当前节点、左子树、右子树。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表，当 p 或 q 树有空节点。\r\n2. 当前节点、左子树、右子树都相同时，左右子树相同。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr || q == nullptr){\r\n            return p == q;\r\n        }\r\n        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(min(m, n))\r\n- 空间复杂度：O(min(m, n))","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/22#issuecomment-1314744258","body":"## 基本思路：\r\n\r\n- 「自顶向下」求子树和，「自底向上」算节点值。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。分别讨论：空节点、叶子节点。\r\n2. 求解下一个子树的 base 值。\r\n3. 将左子树和右子树的值相加，作为当前节点的值。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    int dfs(TreeNode* root, int pre){\r\n        if(root == nullptr){\r\n            return 0;\r\n        }\r\n        if(root->left == nullptr && root->right == nullptr){\r\n            return pre*10 + root->val;\r\n        }\r\n        \r\n\r\n        int cur = pre*10 + root->val;\r\n        return dfs(root->left, cur) + dfs(root->right, cur);\r\n    }\r\npublic:\r\n    int sumNumbers(TreeNode* root) {\r\n        return dfs(root, 0);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(h)，h为树的高度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/23#issuecomment-1316109310","body":"## 基本思路：\r\n\r\n- BFS 找到最底层最左侧的节点。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用层序遍历模版。\r\n2. 使用 flag 来判断是不是第一个节点，根据叶子节点判断是不是最底层。如果两个条件都满足，更新 ans。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findBottomLeftValue(TreeNode* root) {\r\n        queue<TreeNode *> q;\r\n        q.push(root);\r\n        int size, i;\r\n        TreeNode *node;\r\n        int ans;\r\n        bool flag;\r\n\r\n        while(!q.empty()){\r\n            size = q.size();\r\n            flag = true;\r\n\r\n            for(i=0; i<size; i++){\r\n                node = q.front();\r\n                q.pop();\r\n\r\n                if(flag && node->left == nullptr && node->right == nullptr){\r\n                    ans = node->val;\r\n                    flag = false;\r\n                }\r\n                if(node->left != nullptr){\r\n                    q.push(node->left);\r\n                }\r\n                if(node->right != nullptr){\r\n                    q.push(node->right);\r\n                }\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(2^h-1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/24#issuecomment-1318422465","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n- 序列化：\r\n  1. 使用前序遍历，将所有节点保存起来（包括空节点）。\r\n- 反序列化\r\n  1. 从左到右遍历序列。\r\n  2. 打表。如果当前元素为 None，则当前为空树。\r\n  3. 构建当前节点。\r\n  4. 递归构建左子树，递归构建右子树。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Codec {\r\npublic:\r\n    void rserialize(TreeNode* root, string& str) {\r\n        if (root == nullptr) {\r\n            str += \"None,\";\r\n        } else {\r\n            str += to_string(root->val) + \",\";\r\n            rserialize(root->left, str);\r\n            rserialize(root->right, str);\r\n        }\r\n    }\r\n\r\n    string serialize(TreeNode* root) {\r\n        string ret;\r\n        rserialize(root, ret);\r\n        return ret;\r\n    }\r\n\r\n    TreeNode* rdeserialize(list<string>& dataArray) {\r\n        if (dataArray.front() == \"None\") {\r\n            dataArray.erase(dataArray.begin());\r\n            return nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(stoi(dataArray.front()));\r\n        dataArray.erase(dataArray.begin());\r\n        root->left = rdeserialize(dataArray);\r\n        root->right = rdeserialize(dataArray);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* deserialize(string data) {\r\n        list<string> dataArray;\r\n        string str;\r\n        for (auto& ch : data) {\r\n            if (ch == ',') {\r\n                dataArray.push_back(str);\r\n                str.clear();\r\n            } else {\r\n                str.push_back(ch);\r\n            }\r\n        }\r\n        if (!str.empty()) {\r\n            dataArray.push_back(str);\r\n            str.clear();\r\n        }\r\n        return rdeserialize(dataArray);\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/25#issuecomment-1319431161","body":"## 基本思路：\r\n\r\n- 按照（列、行、节点值）进行排序。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历二叉树，保存所有节点。\r\n2. 按照（列、行、节点值）进行排序。\r\n3. 按照 col 分割，放到 ans 数组中。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    vector<tuple<int, int, int>> nodes;\r\n    void dfs(TreeNode* root, int col, int row){\r\n        if(root == nullptr){\r\n            return;\r\n        }\r\n        nodes.emplace_back(col, row, root->val);\r\n        dfs(root->left, col-1, row+1);\r\n        dfs(root->right, col+1, row+1);\r\n    }\r\npublic:\r\n    vector<vector<int>> verticalTraversal(TreeNode* root) {\r\n        dfs(root, 0, 0);\r\n        sort(nodes.begin(), nodes.end());\r\n\r\n        vector<vector<int>> ans;\r\n        int cur_row = INT_MIN;\r\n\r\n        for(const auto &[col, row, val]: nodes){\r\n            if(cur_row != col){\r\n                cur_row = col;\r\n                ans.emplace_back();\r\n            }\r\n            ans.back().emplace_back(val);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/26#issuecomment-1320667596","body":"## 基本思路：\r\n\r\n- 空间换时间\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 使用字典将遍历过的点都记录下来。\r\n2. 如果遇到合适的点，那么就直接退出循环并返回结果。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> twoSum(vector<int>& nums, int target) {\r\n        unordered_map<int, int> res;\r\n        int i;\r\n        for(i=0; i<nums.size(); i++){\r\n            if(res.count(nums[i])){\r\n                break;\r\n            }\r\n            res[target - nums[i]] = i;\r\n        }\r\n        return vector<int>{res[nums[i]], i};\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/27#issuecomment-1321363203","body":"## 基本思路：\r\n\r\n- 利用堆获取前 k 个。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历数组，统计出现次数。\r\n1. 将数组存入小顶堆，然后维护小顶堆的大小为 k。\r\n1. 最后将小顶堆转换为数组返回。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    static bool cmp(const pair<int, int>& n, const pair<int, int>& m){\r\n        return n.second > m.second;\r\n    }\r\n    vector<int> topKFrequent(vector<int>& nums, int k) {\r\n        unordered_map<int, int> occurrences;\r\n        for(const auto& num: nums){\r\n            occurrences[num]++;\r\n        }\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\r\n        for(const auto &[num, count]: occurrences){\r\n            if(q.size() < k){\r\n                q.emplace(num, count);\r\n            }else{\r\n                if(q.top().second < count){\r\n                    q.pop();\r\n                    q.emplace(num, count);\r\n                }\r\n            }\r\n        }\r\n\r\n        vector<int> ans;\r\n        while(!q.empty()){\r\n            ans.emplace_back(q.top().first);\r\n            q.pop();\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(Nlogk)，哈希表记录的时间复杂度是 O(N)，每次堆操作需要 O(logk)，累计需要 O(Nlogk)。\r\n- 空间复杂度：O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321406992","body":"## 基本思路：\r\n\r\n- 枚举+哈希表+求排列数。\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 将所有节点设置为出发点。\r\n2. 求点到点的距离，并保存距离的个数。\r\n3. 求解排列数。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfBoomerangs(vector<vector<int>>& points) {\r\n        unordered_map<int, int> count;\r\n        int distants, ans;\r\n        ans = 0;\r\n\r\n        for(const auto & point: points){\r\n            count.clear();\r\n            for(const auto & p: points){\r\n                if(p != point){\r\n                    distants = (point[0] - p[0]) * (point[0] - p[0]) + (point[1] - p[1]) * (point[1] - p[1]);\r\n                    count[distants]++;\r\n                }\r\n            }\r\n            for (auto &[_, m] : count) {\r\n                ans += m * (m - 1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n*n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/29#issuecomment-1323128794","body":"## 基本思路：\r\n\r\n- 滑动窗口+哈希集合\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 左指针 i 从 0 到 n-1，每次移动都删掉一个哈希集合中的元素。\r\n2. 右指针 rk 从 0 向右移动，直到发现重复字符。\r\n3. 保存最长子串的长度 rk - i。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int lengthOfLongestSubstring(string s) {\r\n        unordered_set<char> occ;\r\n        int i, rk = 0, size=s.size(), ans = 0;\r\n        for(i=0; i<size; i++){\r\n            if(i>0){\r\n                occ.erase(s[i-1]);\r\n            }\r\n            while(rk<size && occ.count(s[rk]) == 0){\r\n                occ.insert(s[rk]);\r\n                rk++;\r\n            }\r\n            if(ans < rk-i){\r\n                ans = rk-i;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(k)，k 为最长子串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/30#issuecomment-1324935324","body":"```c++\r\nclass Solution {\r\n    public List<Integer> findSubstring(String s, String[] words) {\r\n        List<Integer> result = new ArrayList<>();\r\n        int totalLen = s.length();\r\n        int len = words[0].length();\r\n        int n = words.length;\r\n        if (n*totalLen == 0){\r\n            return result;\r\n        }\r\n        HashMap<String,Integer> wordMap = new HashMap<>();\r\n        for (String word:words) {\r\n            int value = wordMap.getOrDefault(word, 0);\r\n            wordMap.put(word,value+1);\r\n        }\r\n        \r\n        for (int i = 0; i <totalLen-n*len+1; i++) {\r\n          \r\n            Map<String,Integer> hasWords = new HashMap<>();\r\n            int num = 0;\r\n            while (num < n){\r\n                String currWord = s.substring(i+num*len,i+(num+1)*len);\r\n                if (wordMap.containsKey(currWord)){\r\n                    int value = hasWords.getOrDefault(currWord,0);\r\n                    hasWords.put(currWord,value+1);\r\n                    if (wordMap.get(currWord) < hasWords.get(currWord)){\r\n                        break;\r\n                    }\r\n                }else {\r\n                    break;\r\n                }\r\n                num++;\r\n            }\r\n            if (num == n){\r\n                result.add(i);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1328528952","body":"## 基本思路：\r\n\r\n- 快慢指针\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* middleNode(ListNode* head) {\r\n        ListNode *slow=head, *fast=head;\r\n        while(fast != nullptr && fast->next != nullptr){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/33#issuecomment-1328526240","body":"## 基本思路：\r\n\r\n- 双指针\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表。\r\n2. 快慢指针都从第一个元素开始。\r\n3. 当 fast 小于 n 时，如果找到不相同的值改变 slow 位置的值并且移动 slow，每次 fast 都 +1。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int removeDuplicates(vector<int>& nums) {\r\n        int n = nums.size();\r\n        if(n == 0){\r\n            return 0;\r\n        }\r\n        int fast = 1, slow = 1;\r\n        while(fast <= n-1){\r\n            if(nums[fast] != nums[fast-1]){\r\n                nums[slow++] = nums[fast]; \r\n            }\r\n            fast++;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/34#issuecomment-1328167354","body":"## 基本思路：\r\n\r\n- 二分查找\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义左指针和右指针。\r\n2. 当左指针小于或等于右指针时，根据中间值移动 l 或 r。\r\n3. 返回 l（如果等于，取左）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int searchInsert(vector<int>& nums, int target) {\r\n        int size = nums.size();\r\n        int l = 0, r = size-1, mid;\r\n        while(l <= r){\r\n            mid = l + (r-l)/2;\r\n            if(nums[mid] < target){\r\n                l = mid+1;\r\n            }else{\r\n                r = mid-1;\r\n            }\r\n        }\r\n        return l;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(log(n))\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/36#issuecomment-1330371642","body":"## 基本思路：\r\n\r\n- 计算各节点的入度和出度\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 遍历所有节点，保存入度和出度。\r\n2. 遍历所有的居民（1, n），找出符合条件的居民（入度为 n-1，出度为 0）。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int findJudge(int n, vector<vector<int>>& trust) {\r\n        vector<int> inDegree(n+1);\r\n        vector<int> outDegree(n+1);\r\n        int i, size = trust.size();\r\n        for(i=0; i<size; i++){\r\n            outDegree[trust[i][0]]++;\r\n            inDegree[trust[i][1]]++;\r\n        }\r\n        for(i=1; i<n+1; i++){\r\n            if(inDegree[i] == n-1 && outDegree[i] == 0){\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n+m), m 是 Trust 的长度，n 是居民人数。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332042657","body":"## 基本思路：\r\n\r\n- 深度优先搜索\r\n- 染色法\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 定义 color 数组存储每个人的颜色，定义 g 数组存储不能与某个人在一组的人。\r\n2. 遍历每个人，使用深度优先搜索检验是否分配到了不同的组。如果分配到了相同的组，则返回 false。\r\n3. 如果没有找到不符合规范的人，则返回 true。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool dfs(int curnode, int nowcolor, vector<int>& color, const vector<vector<int>>& g) {\r\n        color[curnode] = nowcolor;\r\n        for (auto& nextnode : g[curnode]) {\r\n            if (color[nextnode] != 0 && color[nextnode] == color[curnode]) {\r\n                return false;\r\n            }\r\n            if (color[nextnode] == 0 && !dfs(nextnode, 3 ^ nowcolor, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\r\n        vector<int> color(n + 1, 0);\r\n        vector<vector<int>> g(n + 1);\r\n        for (auto& p : dislikes) {\r\n            g[p[0]].push_back(p[1]);\r\n            g[p[1]].push_back(p[0]);\r\n        }\r\n        for (int i = 1; i <= n; ++i) {\r\n            if (color[i] == 0 && !dfs(i, 1, color, g)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(m+n), n 是题目中给定的人数，m 为给定的 dislike 数组的大小。\r\n- 空间复杂度：O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/38#issuecomment-1333284225","body":"```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> topSort(vector<int>& deg, vector<vector<int>>& graph, vector<int>& items) {\r\n        queue<int> Q;\r\n        for (auto& item: items) {\r\n            if (deg[item] == 0) {\r\n                Q.push(item);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        while (!Q.empty()) {\r\n            int u = Q.front(); \r\n            Q.pop();\r\n            res.emplace_back(u);\r\n            for (auto& v: graph[u]) {\r\n                if (--deg[v] == 0) {\r\n                    Q.push(v);\r\n                }\r\n            }\r\n        }\r\n        return res.size() == items.size() ? res : vector<int>{};\r\n    }\r\n\r\n    vector<int> sortItems(int n, int m, vector<int>& group, vector<vector<int>>& beforeItems) {\r\n        vector<vector<int>> groupItem(n + m);\r\n\r\n        // 组间和组内依赖图\r\n        vector<vector<int>> groupGraph(n + m);\r\n        vector<vector<int>> itemGraph(n);\r\n\r\n        // 组间和组内入度数组\r\n        vector<int> groupDegree(n + m, 0);\r\n        vector<int> itemDegree(n, 0);\r\n        \r\n        vector<int> id;\r\n        for (int i = 0; i < n + m; ++i) {\r\n            id.emplace_back(i);\r\n        }\r\n\r\n        int leftId = m;\r\n        // 给未分配的 item 分配一个 groupId\r\n        for (int i = 0; i < n; ++i) {\r\n            if (group[i] == -1) {\r\n                group[i] = leftId;\r\n                leftId += 1;\r\n            }\r\n            groupItem[group[i]].emplace_back(i);\r\n        }\r\n        // 依赖关系建图\r\n        for (int i = 0; i < n; ++i) {\r\n            int curGroupId = group[i];\r\n            for (auto& item: beforeItems[i]) {\r\n                int beforeGroupId = group[item];\r\n                if (beforeGroupId == curGroupId) {\r\n                    itemDegree[i] += 1;\r\n                    itemGraph[item].emplace_back(i);   \r\n                } else {\r\n                    groupDegree[curGroupId] += 1;\r\n                    groupGraph[beforeGroupId].emplace_back(curGroupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 组间拓扑关系排序\r\n        vector<int> groupTopSort = topSort(groupDegree, groupGraph, id); \r\n        if (groupTopSort.size() == 0) {\r\n            return vector<int>{};\r\n        } \r\n        vector<int> ans;\r\n        // 组内拓扑关系排序\r\n        for (auto& curGroupId: groupTopSort) {\r\n            int size = groupItem[curGroupId].size();\r\n            if (size == 0) {\r\n                continue;\r\n            }\r\n            vector<int> res = topSort(itemDegree, itemGraph, groupItem[curGroupId]);\r\n            if (res.size() == 0) {\r\n                return vector<int>{};\r\n            }\r\n            for (auto& item: res) {\r\n                ans.emplace_back(item);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/40#issuecomment-1336098381","body":"## 基本思路：\r\n\r\n- 模拟\r\n- 堆\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 对 task 进行排序，并将下标存入 indices 数组。\r\n1. 遍历 indices 数组，每次处理一个任务，并更新时间戳。如果没有任务处理，就根据 ptr 来更新时间戳，并将任务放入优先队列中。\r\n1. 返回 ans 数组。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    using PII = pair<int, int>;\r\n    using LL = long long;\r\n\r\npublic:\r\n    vector<int> getOrder(vector<vector<int>>& tasks) {\r\n        int n = tasks.size();\r\n        vector<int> indices(n);\r\n        iota(indices.begin(), indices.end(), 0);\r\n        sort(indices.begin(), indices.end(), [&](int i, int j) {\r\n            return tasks[i][0] < tasks[j][0];\r\n        });\r\n\r\n        vector<int> ans;\r\n        // 优先队列\r\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\r\n        // 时间戳\r\n        LL timestamp = 0;\r\n        // 数组上遍历的指针\r\n        int ptr = 0;\r\n        \r\n        for (int i = 0; i < n; ++i) {\r\n            // 如果没有可以执行的任务，直接快进\r\n            if (q.empty()) {\r\n                timestamp = max(timestamp, (LL)tasks[indices[ptr]][0]);\r\n            }\r\n            // 将所有小于等于时间戳的任务放入优先队列\r\n            while (ptr < n && tasks[indices[ptr]][0] <= timestamp) {\r\n                q.emplace(tasks[indices[ptr]][1], indices[ptr]);\r\n                ++ptr;\r\n            }\r\n            // 选择处理时间最小的任务\r\n            auto&& [process, index] = q.top();\r\n            timestamp += process;\r\n            ans.push_back(index);\r\n            q.pop();\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/41#issuecomment-1336372084","body":"## 基本思路：\r\n\r\n- 模拟\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 将开始时间和结束时间转换为分钟。\r\n2. 分析是否通宵。\r\n3. 计算开始时间的上一次比赛的结束时间。\r\n4. 计算完成的对局数。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int numberOfRounds(string loginTime, string logoutTime) {\r\n        int t0 = 60 * stoi(loginTime.substr(0, 2))+stoi(loginTime.substr(3, 5));\r\n        int t1 = 60 * stoi(logoutTime.substr(0, 2))+stoi(logoutTime.substr(3, 5));\r\n        if(t1 < t0){\r\n            t1 = t1 + 24 * 60;\r\n        }\r\n        t1 = t1 / 15 * 15;\r\n        return (t1-t0)/15;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/43#issuecomment-1339085391","body":"## 基本思路：\r\n\r\n- 归并排序\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. resize 临时数组。\r\n2. 调用归并排序。\r\n   1. 打表。当 l >= r 返回。\r\n   2. 递归对左半和右半进行排序。\r\n   3. 对合并已经排序的左半和右半，合并到 tmp 数组中。\r\n   4. 然后将 tmp 中的数据移动到 nums 数组中。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\n    vector<int> tmp;\r\n    void mergeSort(vector<int>& nums, int l, int r) {\r\n        if (l >= r) return;\r\n        int mid = (l + r) >> 1;\r\n        mergeSort(nums, l, mid);\r\n        mergeSort(nums, mid + 1, r);\r\n        int i = l, j = mid + 1;\r\n        int cnt = 0;\r\n        while (i <= mid && j <= r) {\r\n            if (nums[i] <= nums[j]) {\r\n                tmp[cnt++] = nums[i++];\r\n            }\r\n            else {\r\n                tmp[cnt++] = nums[j++];\r\n            }\r\n        }\r\n        while (i <= mid) {\r\n            tmp[cnt++] = nums[i++];\r\n        }\r\n        while (j <= r) {\r\n            tmp[cnt++] = nums[j++];\r\n        }\r\n        for (int i = 0; i < r - l + 1; ++i) {\r\n            nums[i + l] = tmp[i];\r\n        }\r\n    }\r\npublic:\r\n    vector<int> sortArray(vector<int>& nums) {\r\n        tmp.resize((int)nums.size(), 0);\r\n        mergeSort(nums, 0, (int)nums.size() - 1);\r\n        return nums;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/45#issuecomment-1341919386","body":"## 基本思路：\r\n\r\n- 二分\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 当 left 小于等于 right。\r\n1. 如果 mid 版本是错误的，那么 right 往左移动到 mid-1，否则 left 向右移动到 mid+1；\r\n1. 返回 left。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int firstBadVersion(int n) {\r\n        int left = 1, right = n;\r\n        while(left <= right){\r\n            int mid = left + (right - left)/2;\r\n            if(isBadVersion(mid)){\r\n                right = mid-1;\r\n            }else{\r\n                left = mid+1;\r\n            }\r\n        }\r\n        return left;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(logn)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/50#issuecomment-1348629449","body":"## 基本思路：\r\n\r\n- 滑动窗口\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 初始化 Windows 的值。\r\n2. 从做往右移动，在移动过程中不断计算 value 并更新 ans。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isVowel(char ch) {\r\n        return ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u'; \r\n    }\r\n\r\n    int init_window_value(const string &s, int k){\r\n        int count = 0;\r\n        for (int i = 0; i < k; ++i) {\r\n            count += isVowel(s[i]);\r\n        }\r\n        return count;\r\n    }\r\n\r\n    int move_windows(const string &s, int value, int left_index, int right_index){\r\n        return value - isVowel(s[left_index]) + isVowel(s[right_index]) ;   \r\n    }\r\n    \r\n    int maxVowels(string s, int k) {\r\n        int n = s.size();\r\n        int count = init_window_value(s, k);\r\n        int ans = count;\r\n        for (int i = k; i < n; ++i) {\r\n            count = move_windows(s, count, i-k, i);\r\n            ans = max(ans, count);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(s)\r\n- 空间复杂度：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/52#issuecomment-1356560650","body":"## 基本思路：\r\n\r\n- 滑动窗口\r\n\r\n\r\n\r\n## 大致步骤：\r\n\r\n1. 打表\r\n2. 初始化窗口。\r\n3. 移动窗口。\r\n\r\n\r\n\r\n## 代码：\r\n\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    int sLen;\r\n    int pLen;\r\n    void initCount(string &s, string &p, vector<int> &sCount, vector<int> &pCount){\r\n        for(int i=0; i<pLen; i++){\r\n            sCount[s[i] - 'a']++;\r\n            pCount[p[i] - 'a']++;\r\n        }\r\n    }\r\npublic:\r\n    vector<int> findAnagrams(string s, string p) {\r\n        sLen = s.size();\r\n        pLen = p.size();\r\n        if(sLen < pLen){\r\n            return vector<int>();\r\n        }\r\n\r\n        vector<int> ans;\r\n        vector<int> sCount(26);\r\n        vector<int> pCount(26);\r\n        initCount(s, p, sCount, pCount);\r\n\r\n        if(sCount == pCount){\r\n            ans.emplace_back(0);\r\n        }\r\n        for(int i=0; i<sLen-pLen; i++){\r\n            sCount[s[i] - 'a']--;\r\n            sCount[s[i+pLen] - 'a']++;\r\n\r\n            if(sCount == pCount){\r\n                ans.emplace_back(i+1);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/55#issuecomment-1356826131","body":"### 基本思路：回溯\r\n\r\n设亮灯数为 `num`，假设『分钟』使用了 `x` 个灯，剩下始终的数为 `num - x`，在下面代码为代表 `onLedNum - onMinLedNum`，这样就能将『分钟』的灯和『小时』的灯分开计算。\r\n\r\n假设总亮灯数为 3，当前『分钟』的亮灯数为 1，则『小时』的亮灯数为 2。每一轮 dfs 可以计算一个亮灯数的值，当『分钟』的需要计算的灯为 0 时，就将结果保存到 minuteArr 中。只亮一个灯，那么 minuteArr 可能的值为\r\n\r\n```\r\n1, 2, 4, 8, 16, 32\r\n```\r\n\r\n当计算『小时』时，『小时』所需要计算的灯为 0 时，就将其和 minuteArr 中的所有值组合（他们都来自于 for 循环的同一层）。\r\n\r\n### 代码：\r\n\r\n```c++\r\nenum Led{\r\n    MinuteLed,\r\n    HourLed\r\n};\r\nconst int MINUTE = 6;\r\nconst int HOUR = 4;\r\nconst int ledValue[6] = {1, 2, 4, 8, 16, 32};\r\n\r\nclass Solution {\r\nprivate:\r\n    vector<string> res;\r\n    vector<int> minuteArr;\r\n\r\n    void dfs(Led ledType, int needCalcLed, int start, int sum){\r\n        if(ledType == MinuteLed && needCalcLed == 0){\r\n            minuteArr.emplace_back(sum);\r\n            return;\r\n        }\r\n        if(ledType == HourLed && needCalcLed == 0){\r\n            char timeCharArr[6];\r\n            for(int minute: minuteArr){\r\n                sprintf(timeCharArr, \"%d:%02d\", sum, minute);\r\n                res.emplace_back(string{ timeCharArr });\r\n            }\r\n            return;\r\n        }\r\n\r\n        int ledTotal = ledType == MinuteLed? MINUTE: HOUR;\r\n        int curValue;\r\n        for(int i=start; i<ledTotal; i++){\r\n            curValue = sum + ledValue[i];\r\n            if(ledType == MinuteLed && curValue >= 60){\r\n                break;\r\n            }\r\n            if(ledType == HourLed && curValue >= 12){\r\n                break;\r\n            }\r\n            dfs(ledType, needCalcLed-1, i+1, curValue);\r\n        }\r\n    }\r\npublic:\r\n    vector<string> readBinaryWatch(int onLedNum) {\r\n        int onHourLedNum;\r\n        for(int onMinLedNum=0; onMinLedNum <= onLedNum && onMinLedNum < MINUTE; onMinLedNum++){\r\n            onHourLedNum = onLedNum - onMinLedNum;\r\n            dfs(MinuteLed, onMinLedNum, 0, 0);\r\n            dfs(HourLed, onHourLedNum, 0, 0);\r\n\r\n            minuteArr.clear();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/56#issuecomment-1357737583","body":"```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int totalNQueens(int n) {\r\n        unordered_set<int> columns, diagonals1, diagonals2;\r\n        return backtrack(n, 0, columns, diagonals1, diagonals2);\r\n    }\r\n\r\n    int backtrack(int n, int row, unordered_set<int>& columns, unordered_set<int>& diagonals1, unordered_set<int>& diagonals2) {\r\n        if (row == n) {\r\n            return 1;\r\n        }\r\n\r\n        int count = 0;\r\n        for (int i = 0; i < n; i++) {\r\n            if (columns.find(i) != columns.end()) {\r\n                continue;\r\n            }\r\n            int diagonal1 = row - i;\r\n            if (diagonals1.find(diagonal1) != diagonals1.end()) {\r\n                continue;\r\n            }\r\n            int diagonal2 = row + i;\r\n            if (diagonals2.find(diagonal2) != diagonals2.end()) {\r\n                continue;\r\n            }\r\n            columns.insert(i);\r\n            diagonals1.insert(diagonal1);\r\n            diagonals2.insert(diagonal2);\r\n            count += backtrack(n, row + 1, columns, diagonals1, diagonals2);\r\n            columns.erase(i);\r\n            diagonals1.erase(diagonal1);\r\n            diagonals2.erase(diagonal2);\r\n        }\r\n        return count;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/57#issuecomment-1359225511","body":"```c++\r\nstruct Point{\r\n    int x;\r\n    int y;\r\n    Point(int x, int y): x(x), y(y) {}\r\n};\r\nint MATRIX_X[4] = {0, 0, 1, -1};\r\nint MATRIX_Y[4] = {1, -1, 0, 0};\r\n\r\nclass Solution {\r\nprivate:\r\n    bool is_land(const vector<vector<int>> &grid, const Point &point){\r\n        return grid[point.x][point.y] == 1;\r\n    }\r\n\r\n    bool is_in_grid(const vector<vector<int>> &grid, const Point &point){\r\n        return point.x >= 0 && point.y >= 0 && point.x < grid.size() && point.y < grid[0].size();\r\n    }\r\n\r\n    void add_around_point_to_queue(const vector<vector<int>> &grid, Point &point, queue<Point> &q){\r\n        int x, y;\r\n        for (int index = 0; index != 4; ++index) {\r\n            int x = point.x + MATRIX_X[index];\r\n            int y = point.y + MATRIX_Y[index];\r\n            q.push(Point(x, y));\r\n        }\r\n    }\r\n\r\n    int bfs(vector<vector<int>> &grid, Point &startPoint){\r\n        queue<Point> q;\r\n        q.push(startPoint);\r\n\r\n        int area = 0;\r\n        while (!q.empty()) {\r\n            Point point = q.front();\r\n            q.pop();\r\n\r\n            if (is_in_grid(grid, point) && is_land(grid, point)){\r\n                grid[point.x][point.y] = 0;\r\n                add_around_point_to_queue(grid, point, q);\r\n                area++;\r\n            }\r\n        }\r\n        return area; \r\n    }\r\n    \r\npublic:\r\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\r\n        int ans = 0;\r\n        int cur;\r\n        for (int x = 0; x != grid.size(); x++) {\r\n            for (int y = 0; y != grid[0].size(); y++) {\r\n                Point point = Point(x, y);\r\n                cur = bfs(grid, point);\r\n                ans = max(ans, cur);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/58#issuecomment-1361237557","body":"```c++\r\n\r\n// BFS：超时\r\nint MATRIX_X[] = {1, 0, -1, 0};\r\nint MATRIX_Y[] = {0, -1, 0, 1};\r\nconst int MATRIX_LEN = 4;\r\nconst int MAX_N = 100 + 5;\r\n\r\nstruct Point{\r\n    int x;\r\n    int y;\r\n    int len;\r\n    Point(int x, int y, int len): x(x), y(y), len(len) {}\r\n};\r\n\r\nbool visited[MAX_N][MAX_N];\r\n\r\n#define ADD_ACCESS_FLAG(point) visited[point.x][point.y] = true\r\n#define INIT_VISITED(value) memset(visited, value, sizeof(visited))\r\n#define HAS_VISITED(point) visited[point.x][point.y] == true\r\n\r\nclass Solution {\r\nprivate:\r\n    static bool is_in_grid(const vector<vector<int>> &grid, Point point){\r\n        return point.x >= 0 && point.y >=0 && point.x < grid.size() && point.y < grid[0].size();\r\n    }\r\n\r\n    static bool is_ocean(const vector<vector<int>> &grid, Point point){\r\n        return grid[point.x][point.y] == 0;\r\n    }\r\n\r\n    void add_around_point_to_queue(queue<Point> &q, Point point, const vector<vector<int>> &grid){\r\n        for(int i=0; i<MATRIX_LEN; i++){\r\n            Point nextPoint = Point(point.x + MATRIX_X[i], point.y + MATRIX_Y[i], point.len + 1);\r\n            if(is_in_grid(grid, nextPoint) && !HAS_VISITED(nextPoint)){\r\n                ADD_ACCESS_FLAG(nextPoint);\r\n                q.push(nextPoint);\r\n            }\r\n        }\r\n    }\r\n\r\n    int bfs(vector<vector<int>> &grid, Point startPoint){\r\n        INIT_VISITED(0);\r\n        ADD_ACCESS_FLAG(startPoint);\r\n        queue<Point> q;\r\n        q.push(startPoint);\r\n        int ans=-1;\r\n\r\n        while(!q.empty()){\r\n            Point point = q.front();\r\n            q.pop();\r\n\r\n            if(!is_in_grid(grid, point)){\r\n                continue;\r\n            }\r\n\r\n            if(is_ocean(grid, point)){\r\n                add_around_point_to_queue(q, point, grid);\r\n            }else{\r\n                ans = point.len;\r\n                break;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\npublic:\r\n    int maxDistance(vector<vector<int>>& grid) {\r\n        int size = grid.size();\r\n        int x, y;\r\n        int ans=-1;\r\n\r\n        for(x=0; x<size; x++){\r\n            for(y=0; y<size; y++){\r\n                Point point = Point(x, y, 0);\r\n                \r\n                if(is_ocean(grid, point)){\r\n                    int len = bfs(grid, point);\r\n                    if(len > ans){\r\n                        ans = len;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/61#issuecomment-1365148630","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int minCostClimbingStairs(vector<int>& cost) {\r\n        int size = cost.size();\r\n        vector<int> spend(size+1, 0);\r\n        int minCost;\r\n\r\n        spend[0] = spend[1] = 0;        \r\n        for(int index=2; index < size+1; index++){\r\n            spend[index] = min(spend[index - 1] + cost[index - 1], spend[index - 2] + cost[index - 2]);\r\n        }\r\n\r\n        return spend[size];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/62#issuecomment-1365179995","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int rob(vector<int>& nums) {\r\n        int size = nums.size();\r\n        if (size == 1) {\r\n            return nums[0];\r\n        }\r\n        \r\n        vector<int> count = vector<int>(size, 0);\r\n        count[0] = nums[0];\r\n        count[1] = max(nums[0], nums[1]);\r\n\r\n        for (int i = 2; i < size; i++) {\r\n            count[i] = max(count[i - 2] + nums[i], count[i - 1]);\r\n        }\r\n        return count[size - 1];\r\n    }\r\n};\r\n\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/63#issuecomment-1365140302","body":"# 思路\r\n\r\n用每个数和前面的数对比，如果前面的数小于当前数，那么就尝试更新数组。\r\n\r\n更新数组的条件：\r\n- 长度不变：数量+1 就行。\r\n- 长度改变：改变长度，并重置数量。\r\n\r\n# 代码\r\n```c++\r\nclass Solution {\r\nprivate:\r\n    void updateNum(int curLen,  int curLenNum, int &len, int &num){\r\n        if (curLen == len) {\r\n            num += curLenNum;\r\n        }\r\n    }\r\n\r\n    void resetLenAndNum(int curLen, int curLenNum, int &len, int &num){\r\n        if (curLen > len) {\r\n            len = curLen;\r\n            num = curLenNum; \r\n        }\r\n    }\r\npublic:\r\n    int findNumberOfLIS(vector<int> &nums) {\r\n        int size = nums.size();\r\n        vector<int> lenArr(size, 1), numArr(size, 1);\r\n        int maxLen = 0, maxLenNum = 0;\r\n\r\n        for (int endIndex = 0; endIndex < size; ++endIndex) {\r\n            for (int index = 0; index < endIndex; ++index) {\r\n                if (nums[endIndex] > nums[index]) {\r\n                    updateNum(lenArr[index] + 1, numArr[index],  lenArr[endIndex], numArr[endIndex]);\r\n                    resetLenAndNum(lenArr[index] + 1, numArr[index],  lenArr[endIndex], numArr[endIndex]);\r\n                }\r\n            }\r\n            updateNum(lenArr[endIndex], numArr[endIndex], maxLen, maxLenNum);\r\n            resetLenAndNum(lenArr[endIndex], numArr[endIndex], maxLen, maxLenNum);\r\n        }\r\n        return maxLenNum;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/64#issuecomment-1366385340","body":"# 思路：动态规划\r\n\r\n在 text1 取长度为 i 的字符串，在 text2 取长度为 j 的字符串，并记录下他们的子串长度。每次改变一个字符，可以通过前面记录过的子串长度来推导。\r\n- 如果最后一个字符相同：新的子串长度等于 lens[i-1][j-1] + 1。\r\n- 如果最后一个字符不同：新的子串长度等于 max(lens[i-1][j], lens[i][j-1])\r\n\r\n# 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int longestCommonSubsequence(string text1, string text2) {\r\n        int len1 = text1.length(), len2 = text2.length();\r\n        vector<vector<int>> lens(len1 + 1, vector<int>(len2 + 1));\r\n\r\n        for (int i = 1; i <= len1; i++) {\r\n            for (int j = 1; j <= len2; j++) {\r\n                if (text1[i - 1] == text2[j - 1]) {\r\n                    lens[i][j] = lens[i - 1][j - 1] + 1;\r\n                } else {\r\n                    lens[i][j] = max(lens[i - 1][j], lens[i][j - 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        return lens[len1][len2];\r\n    }\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/65#issuecomment-1366389708","body":"# 思路：动态规划\r\n\r\n(i, j) 的路径数 = (i-1, j) + (i, j-1)\r\n\r\n# 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int uniquePaths(int m, int n) {\r\n        vector<vector<int>> dp(m, vector<int>(n, 1));\r\n        for(int i=1; i<m; i++){\r\n            for(int j=1; j<n; j++){\r\n                dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n            }\r\n        }\r\n        return dp[m-1][n-1];\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/71#issuecomment-1369746948","body":"```c++\r\nclass Solution {\r\npublic:\r\n    int change(int amount, vector<int>& coins) {\r\n        vector<int> dp(amount + 1);\r\n        dp[0] = 1;\r\n        for(auto x : coins){\r\n            for(int i = x; i<=amount ;i++){\r\n                dp[i]=dp[i - x] + dp[i];\r\n            }\r\n        }\r\n        return dp[amount];\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aesir-idun":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298724244","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\".join(list(map(str, num)))\n        return [int(i) for i in str(int(s) + k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300621317","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strs = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                strs.append(i)\n        \n        res = []\n        for i, ch in enumerate(s):\n            mini = float('inf')\n            for j in strs:\n                mini = min(mini, abs(i-j))\n            res.append(mini)\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304562922","body":"### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 =[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            for i in range(len(self.stack1)):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stack2.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stack1 or self.stack2)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829993","body":"### 思路\n单调栈，维护每个块的最大值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                pivot = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(pivot)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305478463","body":"### 思路\n等价于是从第N个节点截断，当作链表头，将前面的链表接到后面\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head  \n\n        node_length = 0\n        yummy = head  \n        while yummy:\n            node_length += 1\n            yummy = yummy.next \n        \n        if k % node_length == 0:\n            return head  \n\n        k = node_length - k % node_length\n        slow, fast = head, head  \n\n        while k != 1:\n            k -= 1\n            fast = fast.next \n        new_start = fast.next\n        fast.next = None  \n\n        new_tail = new_start\n\n        while new_tail and new_tail.next:\n            new_tail = new_tail.next \n        new_tail.next = slow \n        return new_start\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312661078","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313538654","body":"### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True \n        if not p or not q or p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321750210","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n\n        for i, (x, y) in enumerate(points):\n            hashdict = collections.defaultdict(list)\n            for j, (x1, y1) in enumerate(points):\n                if j == i:\n                    continue \n                \n                dis = (x-x1)**2 + (y-y1)**2\n                hashdict[dis].append((x1,y1))\n            \n            for k, v in hashdict.items():\n                if len(v) > 1:\n                    res += len(v)*(len(v)-1)\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934522","body":"### 思路\n快慢指针\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head \n        while fast and fast.next:\n            slow = slow.next \n            fast = fast.next.next\n\n        return slow\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332144695","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        g = defaultdict(list)\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        p = list(range(n))\n        for i in range(n):\n            for j in g[i]:\n                if find(i) == find(j):\n                    return False\n                p[find(j)] = find(g[i][0])\n        return True\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337605249","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        cnta=[0]*26\n        cntb=[0]*26\n        for c in a:\n            cnta[ord(c)-ord('a')]+=1\n        for c in b:\n            cntb[ord(c)-ord('a')]+=1\n        lena = len(a)\n        lenb = len(b)\n        res,ca,cb = lena+lenb,0,0\n        print(cnta,cntb)\n        for i in range(25): \n            ca+=cnta[i]\n            cb+=cntb[i]\n            ta = ca+lenb-cb\n            tb = cb+lena-ca\n            res = min(res,min(ta,tb))\n        for i in range(26):\n            res = min(res,lena-cnta[i]+lenb-cntb[i])\n        return res\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaldsk12":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298724244","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\".join(list(map(str, num)))\n        return [int(i) for i in str(int(s) + k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300621317","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strs = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                strs.append(i)\n        \n        res = []\n        for i, ch in enumerate(s):\n            mini = float('inf')\n            for j in strs:\n                mini = min(mini, abs(i-j))\n            res.append(mini)\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304562922","body":"### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 =[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            for i in range(len(self.stack1)):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stack2.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stack1 or self.stack2)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829993","body":"### 思路\n单调栈，维护每个块的最大值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                pivot = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(pivot)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305478463","body":"### 思路\n等价于是从第N个节点截断，当作链表头，将前面的链表接到后面\n### 代码\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0 or not head or not head.next:\n            return head  \n\n        node_length = 0\n        yummy = head  \n        while yummy:\n            node_length += 1\n            yummy = yummy.next \n        \n        if k % node_length == 0:\n            return head  \n\n        k = node_length - k % node_length\n        slow, fast = head, head  \n\n        while k != 1:\n            k -= 1\n            fast = fast.next \n        new_start = fast.next\n        fast.next = None  \n\n        new_tail = new_start\n\n        while new_tail and new_tail.next:\n            new_tail = new_tail.next \n        new_tail.next = slow \n        return new_start\n```","onTime":true},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/20#issuecomment-1312661078","body":"```python\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root: return 0\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/21#issuecomment-1313538654","body":"### 代码\n```python\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True \n        if not p or not q or p.val != q.val:\n            return False\n\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n```","onTime":true},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/28#issuecomment-1321750210","body":"```python\nclass Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        res = 0\n\n        for i, (x, y) in enumerate(points):\n            hashdict = collections.defaultdict(list)\n            for j, (x1, y1) in enumerate(points):\n                if j == i:\n                    continue \n                \n                dis = (x-x1)**2 + (y-y1)**2\n                hashdict[dis].append((x1,y1))\n            \n            for k, v in hashdict.items():\n                if len(v) > 1:\n                    res += len(v)*(len(v)-1)\n        return res\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/32#issuecomment-1326934522","body":"### 思路\n快慢指针\n### 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow, fast = head, head \n        while fast and fast.next:\n            slow = slow.next \n            fast = fast.next.next\n\n        return slow\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/37#issuecomment-1332144695","body":"```python\nclass Solution:\n    def possibleBipartition(self, n: int, dislikes: List[List[int]]) -> bool:\n        def find(x):\n            if p[x] != x:\n                p[x] = find(p[x])\n            return p[x]\n\n        g = defaultdict(list)\n        for a, b in dislikes:\n            a, b = a - 1, b - 1\n            g[a].append(b)\n            g[b].append(a)\n        p = list(range(n))\n        for i in range(n):\n            for j in g[i]:\n                if find(i) == find(j):\n                    return False\n                p[find(j)] = find(g[i][0])\n        return True\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/42#issuecomment-1337605249","body":"```python\nclass Solution:\n    def minCharacters(self, a: str, b: str) -> int:\n        cnta=[0]*26\n        cntb=[0]*26\n        for c in a:\n            cnta[ord(c)-ord('a')]+=1\n        for c in b:\n            cntb[ord(c)-ord('a')]+=1\n        lena = len(a)\n        lenb = len(b)\n        res,ca,cb = lena+lenb,0,0\n        print(cnta,cntb)\n        for i in range(25): \n            ca+=cnta[i]\n            cb+=cntb[i]\n            ta = ca+lenb-cb\n            tb = cb+lena-ca\n            res = min(res,min(ta,tb))\n        for i in range(26):\n            res = min(res,lena-cnta[i]+lenb-cntb[i])\n        return res\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}