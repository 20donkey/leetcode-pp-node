{"372354984":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916976831","body":"### 思路\n\n从末位相加，取余留下尾数，剩下部分与下一位相加，直至 k 和 num 都用完\n\n### 代码\n\n```js\nconst addToArrayForm = function (num, k) {\n  const res = []\n  const n = num.length\n  for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n    if (i >= 0) {\n      k += num[i]\n    }\n    res.push(k % 10)\n  }\n  res.reverse()\n  return res\n}\n\n```\n### 复杂度\n\n- 时间复杂度:O(Max(n,logk))\n- 空间复杂度:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"965682575":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838838","body":"#### 思路\r\n\r\n​\t从数组的最后一位及k的个位开始计算，carry变量表示进位，将每次计算的sum值放入新的数组中，最后将数组倒置。\r\n\r\n​\t**注意**：两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在数组中\r\n\r\n#### 代码\r\n\r\n``` c++\r\npublic:\r\n\r\n vector<int> addToArrayForm(vector<int>& A, int K) {\r\n\r\n\tvector<int> res;\r\n\tint i = A.size() - 1;\r\n\tint carry = 0;\r\n\tint sum = 0;\r\n\t\r\n\twhile (i > -1 || K != 0) {\r\n        int x = i > -1 ? A[i] : 0;\r\n        int y = K != 0 ? (K % 10) : 0;\r\n        sum = x + y + carry;\r\n\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        i--;\r\n        K /= 10;\r\n        res.push_back(sum);\r\n    }\r\n\r\n\tif (carry) {\r\n\t\tres.push_back(carry);\r\n\t}\r\n\r\n\treverse(res.begin(), res.end());\r\n\treturn res;\r\n  }\r\n\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n- 时间复杂度：O(max(N, log k))\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916226878","body":"## 思路\r\n\r\n从个位开始加，用carry表示进位\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# from typing import List\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, A, K):\r\n        if K == 0:\r\n            return A\r\n\r\n        i = len(A) - 1\r\n        carry = 0\r\n\r\n        # d = []\r\n        d = deque()\r\n\r\n        while i >= 0 and K > 0:\r\n            temp = A[i] + carry + K % 10\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n            i -= 1\r\n\r\n        while i < 0 and K > 0:\r\n            temp = K % 10 + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            K = K // 10\r\n\r\n        while i >= 0:\r\n            temp = A[i] + carry\r\n            #d.insert(0, temp % 10)\r\n            d.appendleft(temp % 10)\r\n            carry = temp // 10\r\n            i -= 1\r\n\r\n        if carry > 0:\r\n            #d.insert(0, carry)\r\n            d.appendleft(carry)\r\n\r\n        #return d\r\n        return list(d)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917105068","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  正反遍历\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        dis = 10001\r\n        res = []\r\n        for i in range(0, n):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res.append(dis)\r\n            dis += 1\r\n\r\n        dis = 10001\r\n        for i in range(n - 1, -1, -1):\r\n            if S[i] == C:\r\n                dis = 0\r\n            res[i] = min(res[i], dis)\r\n            dis += 1\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ImSingee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916251691","body":"```rust\r\nimpl Solution {\r\n    pub fn add_to_array_form(num: Vec<i32>, mut k: i32) -> Vec<i32> {\r\n        let mut result = Vec::new();\r\n        for i in (0..num.len()).rev() {\r\n            result.push({\r\n                let result = num[i] + k;\r\n                let x = result % 10;\r\n                k = result / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        while k > 0 {\r\n            result.push({\r\n                let x = k % 10;\r\n                k = k / 10;\r\n                x\r\n            })\r\n        }\r\n\r\n        result.reverse();\r\n        result\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 O(len(num)) [logk约等于1 忽略] \r\n额外空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026640","body":"```go\r\nfunc min(a, b int) int {\r\n    if a < b { return a } else { return b}\r\n}\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n    result := make([]int, len(s))\r\n\r\n    left := -20000\r\n    for i := 0; i < len(s); i++ {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            left = i\r\n        }\r\n\r\n        result[i] = i - left\r\n    }\r\n\r\n    right := 20000\r\n    for i := len(s) - 1; i >= 0; i-- {\r\n        cc := s[i]\r\n\r\n        if cc == c {\r\n            right = i\r\n        }\r\n\r\n        result[i] = min(right - i, result[i])\r\n    }\r\n\r\n\r\n    return result\r\n}\r\n```\r\n\r\n时间复杂度 O(len(s))\r\n额外空间复杂度 O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916253690","body":"### 思路\r\n按照官方题解\r\n\r\n### CPP代码\r\n```Cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0; --i){\r\n            int curSum = num[i] + k % 10;\r\n            k /= 10;\r\n            if(curSum >= 10){\r\n                k++;\r\n                curSum -=10;\r\n            }\r\n            res.push_back(curSum);\r\n        }\r\n        while(k > 0){\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310692","body":"#### 思路 \r\nIterate twice: from the left and from the right. While interating, keep track of the distance between the current char to the target char. In the response vector, update the distance if the current distance is smaller. Simiar to Dijkstra.\r\n\r\n#### 代码 CPP\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        //明天就能和城仔打游戏了哦耶(＾－＾)V\r\n        //res has to have a placeholder to use index\r\n        vector<int> res(s.size(), s.size() + 1);\r\n        int targetDistance = s.size() + 1;\r\n        //iterate through the left side\r\n        for(int i = 0; i < s.size(); i++){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n        }\r\n\r\n        targetDistance = s.size() + 1;\r\n\r\n        //iterate through the right side\r\n        for(int i = s.size() - 1; i >= 0; i--){\r\n            \r\n            if(s[i] == c){\r\n                targetDistance = 0;\r\n            }else{\r\n                targetDistance++;\r\n            }\r\n            if(res[i] > targetDistance){\r\n                res[i] = targetDistance;\r\n            }\r\n\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n) n is the length of s    \r\n空间复杂度：O(1) constants","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dana-Dai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916255452","body":"## 思路\n直接对数组操作，但要注意进位，尤其是K > A的情况，要在数组开头插入以进位\n\n## 语言\ncpp\n\n## 代码\n···\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        //把K直接加到数组num上\n        int len = num.size() - 1;\n        while (k > 0) {\n            num[len] += k;\n            k = num[len] / 10;\n            num[len] %= 10;\n            len --;\n\n            if (len < 0 && k > 0) {\n                num.insert(num.begin(), 0);\n                len = 0;\n            }\n        }\n        return num;\n    }\n};\n```\n## 复杂度分析\n时间复杂度：$O（N）$即需要遍历一遍数组，故为N\n空间复杂度：$O（1）$不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348700","body":"# 中心拓展法\n## 思路\n遍历字符串s，以字符串每个节点为中心，向两边遍历，更新距离\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        //中心拓展法，以每个节点为中心，分别相前向后遍历\n        int len = s.length();\n        vector<int> answer(len);\n\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) continue;\n            int l = i, r = i;\n            int dist = 0;\n\n            while (l >= 0 || r <= len - 1) {\n                if (s[l] == c) {\n                    dist = i - l;\n                    break;\n                }\n\n                if (s[r] == c) {\n                    dist = r - i;\n                    break;\n                }\n\n                if (l > 0) l --;\n                if (r < len - 1) r ++;\n            }\n            answer[i] = dist;\n        }\n\n        return answer;\n    }\n};\n~~~\n时间复杂度：O（N^2）遍历两遍数组\n\n# 左右搜索法\n## 思路\n从左到右更新一遍距离，遇到c即为0，从右向左更新一遍距离，遇到对每个节点的距离进行覆盖\n## 代码\n~~~\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> dist(len, len);\n        //从左向右遍历，遇到c即为0，不断更新距离\n        for (int i = 0; i < len; i ++) {\n            if (s[i] == c) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        //从右向左遍历，再次更新距离\n        for (int i = len - 1; i >= 0; i --) {\n            if (dist[i] == len || (i < len - 1 && dist[i + 1] + 1 < dist[i]))\n                dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n~~~\n时间复杂度：O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-Battle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916257585","body":"## 思路\n\n## 关键点\n\n-  从个位开始往前面推算，每计算一位就放入vector结果中，并通过carry维护进位，最后再反转\n- 注意数组下标和k的位数要保证有效，防止越界\n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int carry = 0, len = num.size() - 1;\n        int tmparr = 0, tmpk = 0, sum = 0;\n        int i = len;\n        while (i >= 0 || k != 0) {\n            tmparr = 0;\n            tmpk = 0;\n            if (k != 0) {\n                tmpk = k % 10;\n                k /= 10;\n            }\n            if (i >= 0) {\n                tmparr = num[i];\n                --i;\n            }\n\n            sum = tmparr + tmpk + carry;\n            carry = sum / 10;\n            res.emplace_back(sum % 10);    \n        }\n        \n        if (carry) {\n            res.emplace_back(carry);\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916262628","body":"## 思路\r\n简单数值解法\r\n## 代码\r\n\r\n```py3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = 0\r\n        ans=[]\r\n        if len(num)==1 and num[0]==0 and k==0: return[0]\r\n        for i in num:\r\n            x = x*10 + i\r\n        x = x + k\r\n        while x!=0:\r\n            ans.append(x%10)\r\n            x=x//10\r\n        return ans[::-1]\r\n```\r\n\r\n## 复杂度\r\n时间：O(2n)\r\n空间：O(ans)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916267006","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0 ; i--) {\n            temp = k%10;\n            k/=10;\n            if (temp+num[i]>=10){\n                k++;\n                ans.addFirst((temp+num[i])%10);\n            }else {\n                ans.addFirst(temp+num[i]);\n            }\n            if (i==0){\n                while (k>0){\n                    temp = k%10;\n                    k/=10;\n                    ans.addFirst(temp);\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917310599","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\npublic int[] shortestToChar(String s, char c) {\n        int l = Integer.MIN_VALUE + s.length() + 1;\n        int r = s.indexOf(c);\n        int[] res = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            if (i <=  r){\n                res[i] = Math.min(i - l, r - i);\n            }else {\n                l = r;\n                r = s.indexOf(c, l + 1) == -1 ? Integer.MAX_VALUE : s.indexOf(c, l + 1);\n                res[i] = Math.min(i - l, r - i);\n            }\n        }\n        return res;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916274001","body":"## 思路 \n从低位往高位顺着加\n### 代码 ： java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n\n### 复杂度分析\n - 时间复杂度：O(n)，其中 n 为数组的长度\n - 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916275711","body":"\n从低到高递归处理每一位以及前面的进位\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = num[::-1]\n        k = [int(x) for x in str(k)][::-1]\n        ret = []\n        def add1(l1, l2, carry, idx):\n            nonlocal ret\n            if carry == 0 and idx >= len(l1) and idx >= len(l2): return\n            n1 = 0 if idx >= len(l1) else l1[idx]\n            n2 = 0 if idx >= len(l2) else l2[idx]\n            ret.append((n1+n2+carry) % 10)\n            carry = (n1+n2+carry)//10\n            add1(l1, l2, carry, idx+1)\n        add1(num, k, 0, 0)\n        return ret[::-1]\n```\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917022162","body":"两次遍历 左到右然后右到左\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        ans = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = abs(lastc - i)\r\n        for i in range(len(s)-1, -1, -1):\r\n            ch = s[i]\r\n            if ch == c:\r\n                ans[i] = 0\r\n                lastc = i\r\n            else:\r\n                ans[i] = min(ans[i], abs(lastc - i))\r\n        return ans\r\n```\r\nTime: O(n)\r\nSpace: Constant with O(n) for answer","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916277083","body":"## 代码\r\nJava:\r\n\r\n```java\r\n// Space = O(n) / O(1) 数组/k长度\r\n// Time = O(Math.max(n, log(k)) / O(1): num或k长度中较大的\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用LinkedList不断从头将位数和加入index 0\r\n        List<Integer> res = new LinkedList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            //从末尾往前扫，加和取余的值\r\n            res.add(0, (num[i] + k) % 10);\r\n            //更新k存进位carry\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        \r\n        // post-possing: 处理k位数大于num的情况剩下的部分\r\n        // Time = O(log(k))\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n##  复杂度分析\r\nSpace = O(n) / O(1) ：数组/k长度\r\n\r\nTime = O(Math.max(n, log(k)) / O(1): num或k长度中较大的","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052225","body":"## 思路\r\n\r\n我们要找到左右最短距离，所以从左右两边都要分别遍历一遍，比较更新取二者较小值。\r\n\r\n## 关键点 \r\npos初始值的initialize。  \r\n由于我们要取最小值，所以要取一个较大数的初始值，  \r\n因为`res[i] = i - pos`，所以pos如果initialize为Integer MIN_VALUE, i-Integer MIN_VALUE会越界。  \r\n如果取Integer MAX_VALUE，最小值始终会是这个。  \r\n所以我们取数组长度的最大值稍大的即可，即-s.length();\r\n\r\n## 代码\r\nJava\r\n```java\r\n// Time = O(n)\r\n// Space = O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] res = new int[n];\r\n        int pos = -n;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = i - pos;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                pos = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(i - pos));\r\n        }\r\n\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nTime=O(n) 左右两个for loop \r\n\r\nSpace=O(n) 开辟String长度的数组。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916278377","body":"## 思路\nAddition from right to left\n\n## 代码\n\n```Kotlin\nfun addToArrayForm(num: IntArray, k: Int): List<Int> {\n  val res = mutableListOf<Int>()\n  var carry = 0\n  var index = num.size - 1\n  var tmp = k\n\n  while (index >= 0 || tmp > 0 || carry > 0) {\n    var sum = carry\n    if (index >= 0) sum += num[index--]\n    if (tmp > 0) sum += tmp % 10\n\n    res.add(sum % 10)\n\n    carry = sum / 10\n    tmp /= 10\n  }\n  return res.reversed()\n}\n```\n\n## 复杂度分析\n- Time：O(len(num))\n- Space：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917097521","body":"## 思路\nScan the string twice, from left and from right. Update the min.\n\n## 代码\n\n```Kotlin\nfun shortestToChar(s: String, c: Char): IntArray {\n  val res = IntArray(s.length) { s.length }\n  var last = -1\n  for ((index, ch) in s.withIndex()) {\n    if (ch == c) {\n      last = index\n      res[index] = 0\n    } else if (last != -1) {\n      res[index] = index - last\n    }\n  }\n\n  last = -1\n  for (index in res.size - 1 downTo 0) {\n    if (res[index] == 0) {\n      last = index\n    } else if (last != -1) {\n      res[index] = minOf(res[index], last - index)\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- Time: O(n)\n- Space: O(1), no extra space.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916281347","body":"#### JS\n\n```js\nvar addToArrayForm = function (num, k) {\n    const ret = [];\n    let i = num.length - 1, carry = 0;\n    while (i >= 0 || k != 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n\n        const sum = x + y + carry;\n\n        ret.push(sum % 10);\n        carry = Math.floor(sum / 10);\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if (carry) {\n        ret.push(carry);\n    }\n    return ret.reverse();\n};\n```\n#### 复杂度分析\n- 时间复杂度：O（n），再具体不会了\n- 空间复杂度：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916284826","body":"# LC989. Add to Array-Form of Integer\r\n## Main Idea\r\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\r\n\r\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\r\n\r\n## Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length, carry = 0, i = n - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int kDigit = k % 10;\r\n            k /= 10;\r\n            int sum = i >= 0 ? carry + kDigit + num[i] : carry + kDigit;\r\n            res.add(sum % 10);\r\n            carry = sum >= 10 ? 1 : 0;\r\n            --i;\r\n        }\r\n      \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity Analysis\r\nTime: `O(max(N, log(K)))`\r\n* Given a number `K`, its length will be `log_{2}(K)`, the time complexity depends on the length of `N` and `K`, whichever is longer.\r\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition. If we insert at the head of array, then it will take `O(n^2)` of time.\r\n\r\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917026412","body":"# LC821. Shortest Distance to a Character\n## Main Idea\n### One Scan with Two Pointers\nWe use `prev` array to record the previous appearance of `c` and `next` array to record the next for each character in the string. \n\nFor the first character, initialize its `prev[0]` to be infinity. Then for each character `s[i]`, if `s[i] == c`, then `prev[i] = 0`, else, `prev[i] = prev[i - 1] + 1`, notice if `prev[i - 1] == Integer.MAX_VALUE`, we don't need to add 1 so it won't cause integer overflow.\n\nSimilar logic for `next` array.\n\nThen for each character, `res[i] = min{prev[i], next[i]}`.\n\nAlso we can use two pointers to acheive our goal with one scan.\n\n## Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] next = new int[n], prev = new int[n], res = new int[n];\n        for (int i = 0; i < n; ++i) {\n            int j = n - 1 - i;\n            if (i == 0) {\n                prev[i] = s.charAt(i) == c ? 0 : Integer.MAX_VALUE;\n                next[j] = s.charAt(j) == c ? 0 : Integer.MAX_VALUE;\n            } else {\n                prev[i] = s.charAt(i) == c ? 0 : prev[i - 1] == Integer.MAX_VALUE ? prev[i - 1] : prev[i - 1] + 1;\n                next[j] = s.charAt(j) == c ? 0 : next[j + 1] == Integer.MAX_VALUE ? next[j + 1] : next[j + 1] + 1;\n\n                if (i >= j) {\n                    res[i] = Math.min(prev[i], next[i]);\n                    res[j] = Math.min(prev[j], next[j]);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity Analysis\nTime: `O(n)`\nSpace: `O(n)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293322","body":"## LC 989 Add to Array-Form of Integer\n\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n### Topics  \n\n- Array\n- Math\n\n### Similar Questions\n\nMedium\n- https://leetcode.com/problems/add-two-numbers/\n\nEasy\n- https://leetcode.com/problems/plus-one/\n- https://leetcode.com/problems/add-binary/\n- https://leetcode.com/problems/add-strings/\n\n\n### 思路 \nAdd the number K to the array from right to left.\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carrier = 0\n        num_len = len(num)\n        i = num_len -1\n        # Add all matching digit        \n        while i >= 0 and k > 0:\n            cur_k, k = k%10, k//10\n            t_carrier = (num[i] + cur_k + carrier) // 10\n            num[i] = (num[i] + cur_k + carrier) % 10\n            carrier = t_carrier\n            i -= 1\n        \n        # Check whether num or k is left\n        if i >= 0:\n            while i >= 0:\n                t_carrier = (num[i] + carrier) // 10\n                num[i] = (num[i] + carrier) % 10\n                carrier = t_carrier\n                if carrier == 0:\n                    break\n                i -= 1\n            \n        if k > 0:\n            while k > 0:\n                cur_k, k = k%10, k//10\n                t_carrier = (cur_k + carrier) // 10\n                num = [(cur_k + carrier) % 10] + num\n                carrier = t_carrier\n\n        # Deal with carrier\n        if carrier > 0:\n            return [carrier] + num\n        else:\n            return num\n            \n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917052674","body":"## LC 821 Shortest Distance to a Character\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n### Topics  \n\n- Array\n- String\n\n### Similar Questions\nHard\n- https://leetcode.com/problems/shortest-common-supersequence/\n\nMedium\n- https://leetcode.com/problems/find-k-length-substrings-with-no-repeated-characters/\n- https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/\n\nEasy\n- \n\n\n### 思路 \n1. Find all c ocurrences and save them into one list.\n2. Update the corresponding position in res to 0\n3. Update other elements in the result list\n\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # Helper function to update other elements.\n        def update_res(index):\n            # Update the lower part\n            i = index\n            while i > 0 and res[i] + 1 < res[i-1]:\n                res[i-1] = res[i] + 1\n                i -= 1\n            j = index\n            while j < len(res) - 1 and res[j] + 1 < res[j+1]:\n                res[j+1] = res[j] + 1\n                j +=1\n                \n        res = [float(\"inf\")]*len(s)\n        # Find all c ocurrences and save them into one list.\n        # Update the corresponding position in res to 0\n        c_l = []\n        for i, e in enumerate(s):\n            if e == c:\n                c_l.append(i)\n                res[i] = 0\n        \n        # Update other elements in the result list\n        for idx in c_l:\n            update_res(idx)\n    \n        return res\n\n```\n\n#### 复杂度分析\n\n时间复杂度：O(N) </br>\n空间复杂度：O(N) N is the # of occurrence of c in s.\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916293869","body":"## 思路\r\n\r\n双指针 + 进位加法逻辑\r\n\r\n双指针, 让两个数的末位对齐, 两个指针 i, j均从各自字符串的末尾开始走。\r\n\r\n定义一个数组来存放结果, 一个int值carry来记录每位的进位值, 初始值设为0。\r\n算当前位置的数时, sum = a[i] + b[j] + carry, 每趟都要记得更新carry的值。\r\n\r\n循环结束时, 由于低位的数字字符先加到了结果字符串中, 最后还需要 reverse 一次, 让位置恢复正常。\r\n\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int k) {\r\n        if (k == 0) return A;\r\n        vector<int> res;\r\n        int n = A.size();\r\n        // 对位相加\r\n        int carry = 0;\r\n        int sum = 0;      \r\n        int i = n - 1; \r\n        while (k > 0 || i >= 0)\r\n        {\r\n            sum = carry + (k % 10);\r\n            if (i >= 0) // 保证访问A[i]前不越界\r\n                sum += A[i];\r\n\r\n            carry = (sum <= 9) ? 0 : 1;\r\n            res.push_back(sum % 10);            \r\n            k = k / 10;\r\n            \r\n            i--;\r\n        }\r\n        if (carry == 1) res.push_back(1);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n代码已上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数K的长度。\r\n- 空间复杂度：O(n), 主要是结果数组用的空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917028429","body":"## 思路\r\n\r\n**题意**: 计算 `abs[i] = indexGap(i, 最近的字符c)`, 1 <= s.length <= 10^4\r\n输出 `abs[i]`的数组\r\n\r\n### 解法: 双指针 中心扩展\r\n\r\n使用一个结果数组 gaps[]\r\n\r\n将string s转为字符数组，然后从前往后遍历。\r\n循环变量记作i, 对于每一趟: \r\n如果当前字符就是要搜索的字符c, 距离记为 0，否则分别向左、向右找最近的字符c。\r\n向左找, 找到第一个字符c, 将指针i与之的index之差记作leftDistance。\r\n向右找, 找到第一个字符c, 将指针i与之的index之差记作rightDistance。\r\n取两者的较小值。\r\n\r\n依次填充 gaps[i] 的值即可。\r\n\r\n\r\n## 代码\r\n\r\n### 实现语言: C++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> gaps(s.size());\r\n        vector<char> chars(s.begin(), s.end());\r\n\r\n        for (int i = 0; i < chars.size(); i++)\r\n        {\r\n            // 如果当前字符就是要搜索的字符c, 距离为 0\r\n            if (chars[i] == c) gaps[i] = 0;\r\n            else /* 否则分别向左、向右找最近的字符c */\r\n            {\r\n                int leftDistance = INT_MAX, rightDistance = INT_MAX;\r\n                for (int left = i; left >= 0; left--)\r\n                {\r\n                    if (chars[left] == c) // 向左找, 找到第一个\r\n                    {\r\n                        leftDistance = i - left;\r\n                        break;\r\n                    }\r\n                }\r\n                for (int right = i; right < chars.size(); right++) // 向右找, 找到第一个\r\n                {\r\n                    if (chars[right] == c)\r\n                    {\r\n                        rightDistance = right - i;\r\n                        break;\r\n                    }\r\n                }\r\n                gaps[i] = min(leftDistance, rightDistance);\r\n            }\r\n        }\r\n\r\n        return gaps;\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n代码已同步上传到: [leetcode-ac/91algo - github.com](https://github.com/yanglr/leetcode-ac/tree/master/91algo)\r\n\r\n\r\n\r\n## 复杂度分析 \r\n\r\n- 时间复杂度：O(n^2)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314383","body":"- Talk about how to make an easy problem complicated:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int size = Math.max(num.length, String.valueOf(k).length());\n        int dif = size - num.length; \n        int[] ans = new int[size];\n        int carry = 0;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            int n = (i - dif) < 0 ? 0:num[i - dif];\n            int m = k % 10;\n            k = k / 10;\n            ans[i] = (n + m + carry) % 10;\n            carry = (n + m + carry) / 10;\n        }\n        \n        List<Integer> list = new ArrayList<>();\n        if (carry == 1) list.add(1);\n        for (int i: ans) list.add(i);\n        \n        return list;\n    }\n}\n```\n\n- So turns out all we need to do is adding digits from the last position and reverse the list.\n- Time and space O(max(n, m)) where n is the length of num and m is the number of digits in k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917038224","body":"- Time and space O(n).\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> index = new ArrayList<>();\n        index.add(Integer.MAX_VALUE);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) index.add(i);\n        }\n        index.add(Integer.MAX_VALUE);\n        \n        int[] ans = new int[s.length()];\n        int i = 1;\n        for (int j = 0; j < s.length(); j++) {\n            ans[j] = Math.min(Math.abs(j - index.get(i)), Math.abs(j - index.get(i - 1)));\n            if (j == index.get(i)) i++;\n        }\n        \n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916314749","body":"``` python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n        \r\n```\r\n\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917058171","body":"``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_position = [i for i in range(len(s)) if s[i] == c]\n        return [min([abs(c-i) for c in c_position]) for i in range(len(s))]\n```\ntime: O(len(s) * len(c))\nspace: O(len(c))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916315048","body":"# ***Title:989. Add to Array-Form of Integer***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/)\n\n## ***Solution***\n1. Revert the array, so that we only need to manipulate the end of the array.\n2. Extract the lowest digit of K and add into the array ascendingly. \n3. After each addition, if the item at the given index excceds 10, then only keep the lowest digit part and add 1 to the next item in the array (Watch out the array boundary and expand the array by 1 if needed..\n4. After processed K, check if there still exist delta > 0, if so keep on repeating the process similar to step 2 until delta equals 0.\n5. Revert the array back.\n\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int index = 0;\n        int delta = 0;\n        \n        std::reverse(num.begin(), num.end());\n        \n        while (k > 0) {\n            delta += k % 10 + num[index];\n            k /= 10;\n            \n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (k > 0 || delta > 0))\n                num.push_back(0);\n        }\n        \n        while (delta > 0) {\n            delta += num[index];\n            num[index++] = delta % 10;\n            delta /= 10;\n            \n            if (index == num.size() && (delta > 0))\n                num.push_back(0);\n        }\n            \n        std::reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(max(N, M)), N is the size of the array, while M is the size of the virtual array form of K, which is logarithm of base 10 -> log10(K).\n\n### ***Space Complexity and Explaination***\nO(1) since we reuse the input array and didn't need any extra space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319452","body":"# ***Title: 821. Shortest Distance to a Character***\n\n## ***Question Reference*** [LeetCode](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n## ***Solution***\nStore all the indices of c in an array called helper_array, then traverse the original array and compare the indices with helper_array, to update the distance.\nSince the indices in helper_array will be in assend order, we can use 2 pointers, one points to the orginal array (po) and the other points to the helper array(ph), keep on moving the po, but only moves the ph when po > helper_array[ph], and each time compare the po with ph -1 and ph and use the smaller value to update the output array.\n## ***Code***\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> helper_array;\n        vector<int> dis(s.length(), INT_MAX);\n        \n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] == c) {\n                helper_array.push_back(i); \n            }\n        }\n        \n        for (int i = 0, j = 0; i < s.length() && j < helper_array.size(); i++) {\n            if (i > helper_array[j] && j < helper_array.size() - 1) j++;\n            \n            if (i < helper_array[j]) {\n                // compare with j - 1.\n                dis[i] = j == 0? INT_MAX : i - helper_array[j - 1];\n                // compare with j.\n                dis[i] = min(dis[i], helper_array[j] - i);\n            } else if (i > helper_array[j]) {\n                // compare with j + 1\n                dis[i] = j == helper_array.size() - 1? INT_MAX : helper_array[j + 1] - i;\n                // compare with j\n                dis[i] = min(dis[i], i - helper_array[j]);\n            } else {\n                dis[i] = 0;\n            }\n            \n        }\n        \n        return dis;\n    }\n};\n\n```\n\n## ***Complexity***\n### ***Time Complexity and Explaination***\nO(n), we first iterated the orginal array to setup the helper_array which takes O(n) time.\nDuring comparasion, since we will visit each item in the original array for 1 once, and each vistit we would compare with most 2 items from helper_array, which take O(2n)\nTotal time complexity is O(n) + O(2n) = O(n)\n\n### ***Space Complexity and Explaination***\nO(n) for the helper_array, and in the worst case, the helper_array will have the same size as the original array.\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916317988","body":"## 思路\r\n### 模版\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n### 代码\r\n- 语言： Python3\r\n\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) -1\r\n        res = []\r\n        carry = 0\r\n\r\n        while i >=0 or k != 0:\r\n            if i >= 0:\r\n                curr_num = num[i]\r\n            else:\r\n                curr_num = 0\r\n            if k != 0:\r\n                curr_k = k % 10 \r\n            else:\r\n                curr_k = 0\r\n\r\n            total = curr_num + curr_k + carry\r\n            curr_total = total % 10\r\n            carry = total // 10\r\n            res.append(curr_total)\r\n            i -= 1\r\n            k = k // 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n\r\n        return res[::-1]\r\n```\r\n\r\n### 复杂度：\r\n- 时间复杂度：$O(n)$ 遍历\r\n- 空间复杂度：$O(n)$ 新创立了一个ans list","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917211204","body":"## 思路和复杂度\n- 暴力：遍历两遍，先遍历一遍记录下target的index -> index_list，再遍历第二遍得到最小值\n- 可以优化的地方：遍历第二遍: \n1. 可以遍历index_list记录最小值 O(n^2); \n2. 可以用一个指针标记最近的target O(N)\n\n## Python3\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 两遍遍历\n        index_list = []\n        ans = []\n        min_distance = len(s)\n        for index, char in enumerate(s):\n            if char == c:\n                index_list.append(index)\n\n        for index, char in enumerate(s):\n            for i in range(0, len(index_list)):\n                distance = abs(index-index_list[i])\n                min_distance = min(distance, min_distance)\n                if i == len(index_list) -1:\n                    ans.append(min_distance)\n                    min_distance = len(s)\n\n        return ans\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916322388","body":"### 思路\n\nDeque, Array遍历；\n\n注意题目要求，1 <= A.length <= 10000，所以直接做加法是不可能的。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int pos = 0;\n        int carry = 0;\n        Deque<Integer> res = new LinkedList<>();\n        while(pos < num.length || k >= Math.pow(10, pos) || carry > 0){\n            int fromNum = pos < num.length?num[num.length - 1 - pos]:0;\n            int fromK = (k / (int)Math.pow(10, pos)) % 10;\n            int sum = fromNum + fromK + carry;\n            res.addFirst(sum % 10);\n            carry = sum > 9?1:0;\n            pos++;\n        }\n                \n        return new ArrayList<>(res);\n    }\n}\n```\n\n### 复杂度\n\nO(MAX(num.length, Integer.valueOf(k).toString.length()))\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917160920","body":"### 思路\r\nArray遍历\r\n\r\n两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从1-m编号；直到遇到下一个c，重复编号过程。（第一个c左边为未编号状态）\r\n- 第二次从右到左，遇到c，将其左边当前编号与预计编号比较并取min；第二次编号并会将第一个c左边的编号完成。\r\n\r\nStack\r\n将s遍历一次\r\n- 如果当前为c，\r\n    - pop站内元素，并依次按距离递增编号；直到栈空或栈顶为c；当前位置编号0；将当前位置压入栈\r\n- 如果当前不为c\r\n    - 如果栈顶为c，那么当前位置编号1\r\n    - 否则当前位置编号为前一个位置编号+1；\r\n    - 将当前位置index 压入栈；\r\n\r\n\r\n### 代码\r\n```java\r\n//array遍历\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        int[] res = new int[s.length()];\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        \r\n        pre = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1;i >= 0;i--){\r\n            if(s.charAt(i) == c) pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n\r\n//stack\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int[] res = new int[s.length()];\r\n        stack.add(0);\r\n        for(int i = 0;i < s.length();i++){\r\n            if(s.charAt(i) == c){\r\n                int pos = 0;\r\n                while(!stack.isEmpty() && s.charAt(stack.peek()) != c){\r\n                    int cur = stack.pop();\r\n                    \r\n                    res[cur] = res[cur] == 0?++pos:Math.min(++pos, res[cur]);\r\n                }\r\n                res[i] = 0;\r\n                stack.add(i);\r\n            } else {\r\n                if(!stack.isEmpty() && s.charAt(stack.peek()) == c){\r\n                    res[i] = 1;\r\n                } else if(i > 0 && res[i-1] != 0) {\r\n                    res[i] = res[i-1] + 1;\r\n                }\r\n                stack.add(i);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\nArray遍历\r\nO(s.length());\r\nO(1)\r\n\r\nStack\r\nO(s.length())\r\nO(N),维护一个栈。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916330275","body":"思路：\nadd with carry\n\nPython:\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        n = len(num)\n        while(n > 0 or k > 0):\n            if n > 0:\n                k += num[n - 1]\n            k, r = divmod(k, 10)\n            res.append(r)\n            n -= 1\n        return res[::-1]\n```\nC++:\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum;\n        for (int i = n - 1; i >=0; --i){\n            \n            /*Calculation of current digit*/\n            \n            sum = num[i] + k % 10;\n            k /= 10;\n            \n            /*Add the carry to k if there is any*/\n            \n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            \n            /*Append the sum to the end*/\n            \n            res.push_back(sum);\n        }\n        \n        /* Append the rest of k to the end if k is bigger than n*/\n        \n        for (k = k; k > 0; k/= 10){\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n复杂度分析:\n\n时间复杂度：O(len(A) + len(str(k)) + len(res)) = O(max(len(A), len(str(k))))\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916334960","body":"[LC 989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路**\n- 把num list转化成数字\n- 数字和k相加\n- 相加的和转化成list\n\n**python代码**\n```class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        true_number = 0\n        result = []\n        if k == 0 and len(num) == 1:\n            return num\n        for i in range(n):\n            true_number = true_number + num[i]*10**(n-i-1)\n\n        add_up = true_number + k\n        while add_up:\n            result.append(add_up%10)\n            add_up = add_up//10\n\n        return result[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917085339","body":"[821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/)\n\n**comment**\nRuntime: 146 ms beat 5%\n\n**python代码**\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp = []\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                temp.append(i)\n        \n        for j in range(len(s)):\n            a = [abs(x-j) for x in temp]\n            res.append(min(a))\n            \n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(N^2+N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JiangyanLiNEU":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916335257","body":"### Two ideas hit me when I saw this problem.\n* convert array num to integer --> add k to the integer --> convert new integer to array --> return this array\n* Use k as carry on number, and keep adding it to the elements in num until k is 0. Note that, we might  need to insert elements into num array.\n\n### Here is my implement:\n* #### Convert idea ( Runtime = O( len(num) ), Space = O( len(num) ) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # convert array num into string version\n        num_string = ''\n        for n in num:\n            num_string += str(n)\n\n        # add num and k, and convert it to string version\n        num_add_k_string = str(int(num_string) + k)\n\n        # convert result into array of int version\n        toReturn = [ int(i) for i in num_add_k_string ]\n        return toReturn\n```\n\n* #### carry k idea ( Runtime = O( len(num) ), Space = O(1) )\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        # add k into the last digit of num, and check if there should be a carryOn number\n        num[-1] += k\n        if num[-1] < 10:\n            return num\n        # if no carryOn number, then just return num, otherwise, we keep adding carry on into previous digit and update carryOn\n        carryOn = num[-1]//10\n        num[-1] = num[-1]%10\n        index = -2\n        while carryOn != 0:\n            # when there are enough digits for us to add\n            if index >= -len(num):\n                num[index] += carryOn\n            # we need to insert new digit at the beginning of the array\n            else:\n                num.insert(0, carryOn)\n            carryOn = num[index] // 10\n            num[index] %= 10\n            index -= 1\n        return num\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917119307","body":"#### Two ideas\n##### Straightforward way (Runtime = O(n), Space = O(n))\n* I get all the index of letter c in s\n* CASE1,  any letter before the first c letter, the distance will be (c_index - letter_index) \n* CASE2, any letter in between two c letters, we need to find the middle point. The distance will be (letter_index-c_index) and then after middle point, it will be (c_index-letter_index) \n* CASE3, any letter after the last c letter, the distance will be (letter_index - last_c_index)\n\n##### forward and backward update (Runtime = O(n), Space = O(n))\n* Iterate from left to right, the distance is always the distance to the right nearest letter c\n* Iterate from right to left, update the distance to be the minimum distance of current one and distance to the left nearest letter c\n\n#### Implement straightforward idea\n``` python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        # get all the location of letter c\n        c_location = [i for i in range(len(s)) if s[i]==c\n        result = []\n        #case 1\n        for i in range(c_location[0]+1):\n            result.append(c_location[0]-i)\n        #case 2\n        while len(c_location) >= 2:\n            popStart = c_location.pop(0)\n            endAt = c_location[0]\n            index = popStart + 1\n            while index <= (endAt+popStart)//2:\n                result.append(index-popStart)\n                index += 1\n            while index <= endAt:\n                result.append(endAt-index)\n                index+=1 \n        #case 3\n        for i in range(c_location[0]+1,len(s)):\n            result.append(i-c_location[0])\n        return result\n```\n\n#### Implement smarter idea\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        result = [float('inf') for i in s]\n        last_c = -float('inf')\n        for i in range(len(s)):\n            if s[i] == c:\n                last_c = i\n                result[i] = i-last_c\n            else:\n                result[i] = i-last_c\n        last_c = float('inf')\n        for i in range(len(s)-1, -1,-1):\n            if s[i] == c:\n                last_c = i\n            result[i] = min(result[i], last_c - i)\n        return result \n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916338863","body":"思路：\n历遍数组\n\nPython:\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n\n时间复杂度：O(N+max(0,K−N) \n空间复杂度：O(1)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916352332","body":"### LC 989. Add to Array-Form of Integer\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int fromNum = i >= 0 ? num[i] : 0;\n            int fromK = k % 10;\n            int val = fromNum + fromK + carry;\n            list.add(0, val % 10);\n            carry = val > 9 ? 1 : 0;\n            k = k / 10;\n            i--;\n        }\n        return list;\n    }\n}\n\n```\n### 时空复杂度：\n时间：O(Math.max(len(num), len(k.toString()))\n\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916354433","body":"### 思路\r\n从末位开始，向vector里添加各对应位置数字与进位之和。如原数组里各位置已加完，则需处理K中剩余数字与进位之和。\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int carry = 0;\r\n        vector<int> res;\r\n        for (int i = num.size() - 1; i >= 0; i--) {\r\n            res.push_back((carry + num[i] + k % 10) % 10);\r\n            carry = (carry + num[i] + k % 10) / 10;\r\n            k /= 10;\r\n        }\r\n        carry = carry + k;\r\n        while (carry) {\r\n            res.push_back(carry % 10);\r\n            carry /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N + logN + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。 \r\n- 空间复杂度：O(Max(1, K - N))，N为数组A的长度，K为K的长度。 ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917313085","body":"### 思路\n找到C的左边界和右边界，计算边界内的字符到每个边界的值。\n\n### 代码(C++)\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n        int n = s.size() - 1;\n        int left = s[0] == c ? 0 : n;\n        int right = s.find(c, 1);\n        \n        for (int i = 0; i <= n; i++) {\n            res.push_back(min(abs(i - left), abs(i - right)));\n            if (i == right) {\n                left = right;\n                right = s.find(c, right + 1);\n            }\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，N为S的长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916360004","body":"# 思路\r\n从后往前加，直到没有为止\r\n\r\n# 代码(Python3)\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        add1 = 0\r\n        add2 = 0\r\n        stop1Flag = False\r\n        stop2Flag = False\r\n        \r\n        resultStack = []\r\n        \r\n        k_int = list(map(int,str(k)))\r\n        \r\n        index = -1\r\n        while(True):\r\n            try:\r\n                add1 = num[index]                \r\n            except:\r\n                stop1Flag = True\r\n                add1 = 0\r\n                \r\n            try:\r\n                add2 = k_int[index]\r\n            except:\r\n                stop2Flag = True\r\n                add2 = 0\r\n            \r\n            index -= 1\r\n            \r\n            if(stop1Flag and stop2Flag):\r\n                if carry != 0:\r\n                    resultStack.append(carry)\r\n                break\r\n            else:\r\n                resultStack.append((add1 + add2 + carry)%10)\r\n                carry = (add1 + add2 + carry)//10\r\n        return (list(resultStack[::-1])\r\n```\r\n# 复杂度分析\r\n时间复杂度：O(N + Max(0, K - N)^2)，N为数组A的长度，K为K的长度。\r\n空间复杂度：O(Max(1, K + N))，N为数组A的长度，K为K的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917127990","body":"# 思路\n计算出c的所有位置，让s中的每个字符的位置相减，去最小值\n\n# 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        index = 0\n        locations = []\n        for idx, letter in enumerate(s):\n            if letter == c:\n                locations.append(idx)\n                \n        indexes = range(len(s))\n        difference = [ abs(x - locations[0]) for x in indexes]\n        \n        for i in range(1,len(locations)):\n            difference = [ min(difference[x] , abs(x - locations[i])) for x in indexes]\n            \n        return difference\n```\n\n# 复杂度\nTime: O(n*k)\nSpace: O(k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RonghuanYou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916378066","body":"按照加法的运算顺序从后往前遍历，r是余数，也就是做完加法后的当前位的值\nk是除去最后一位的值\n结束循环，如果k>0，就要一直处理最后的carry，就是k%10放入output array\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sumArr = []\n        for i in range(len(num) - 1, -1, -1):\n            r = (num[i] + k) % 10\n            k = (num[i] + k) // 10\n            sumArr.append(r)\n            \n        while k > 0:\n            sumArr.append(k % 10)\n            k = k // 10\n        return sumArr[::-1]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917355278","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        shortest_dis_arr = [len(s)] * len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                shortest_dis_arr[i] = 0\n        \n        for i in range(1, len(s)):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i-1]+1)\n       \n        for i in range(len(s) - 2, -1, -1):\n            shortest_dis_arr[i] = min(shortest_dis_arr[i], shortest_dis_arr[i+1]+1)\n\n        return shortest_dis_arr\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916379125","body":"## Java代码\r\n\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        Stack<Integer> stack = new Stack<>();\r\n        int borrow = 0;\r\n        int i = num.length - 1;\r\n\r\n        while (k != 0 || i >= 0 || borrow != 0) {\r\n            int currentNumber;\r\n           if (i >= 0 && k != 0) {\r\n                currentNumber = num[i] + k % 10;\r\n           } else if (i >=0) {\r\n               currentNumber = num[i];\r\n           } else {\r\n               currentNumber = k % 10;\r\n           }\r\n            stack.add((currentNumber + borrow) % 10);\r\n            borrow = (currentNumber + borrow) / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n\r\n        while (!stack.isEmpty()) {\r\n            res.add(stack.pop());\r\n        }\r\n        return res;\r\n    } \r\n```\r\n\r\n## 时间复杂度\r\n\r\nO(n)\r\n\r\n## 空间复杂度\r\n\r\nO(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917164588","body":"### 思路\r\n\r\n- 暴力解\r\n  - 从前遍历字符串中每一个char 到 target的距离， O(N^2)\r\n- 优化解\r\n  - 首先遍历字符串 找到target在字符串中的位置 并记录在index queue中\r\n  - 设置两个指针 pre = MIN_VALUE 和 next = queue.peek()， 分别代表target在字符串中出现的前一个和后一个位置\r\n  - 再次遍历字符串 当前距离 = Math.min(i-pre,  next -i)\r\n  - 果current Index == queue.peek(), pre = currentIndex, queue.poll()\r\n\r\n### Java Code\r\n\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        Queue<Integer> indexQueue = new LinkedList();\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            if (s.charAt(i) == c) {\r\n                indexQueue.add(i);\r\n            }\r\n        }\r\n        int pre = -1;\r\n        for (int i=0; i<s.toCharArray().length;i++) {\r\n            int next = indexQueue.peek();\r\n            res[i] = pre < 0 ? Math.abs(next-i) : Math.min(Math.abs(i-pre),Math.abs(next-i));\r\n            if (i == indexQueue.peek() && indexQueue.size() > 1) {\r\n                pre = indexQueue.peek();\r\n                indexQueue.poll();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n### 时间 & 空间 复杂度\r\n\r\n- O(n)\r\n- O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916390741","body":"JAVA code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;\r\n        int index = A.length - 1;\r\n        while(K > 0 || index >= 0){\r\n            int curK = K % 10;\r\n            int curA = index >= 0 ? A[index]: 0;\r\n            int curDigitSum = curK + curA + carry;\r\n            int toBeAdded = curDigitSum % 10;\r\n            carry = curDigitSum / 10;\r\n            index --;\r\n            K /= 10;\r\n            res.addFirst(toBeAdded);\r\n        }\r\n        if(carry != 0){\r\n            res.addFirst(1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n);\r\nSpace: O(n);\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408530","body":"Python 3 code:\r\n     \r\n    class Solution:\r\n         def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n              if num[0] == 0 and k == 0:\r\n                 return [0]\r\n              inputnum = 0\r\n              for number in num:\r\n                   inputnum = inputnum * 10 + number\r\n              summ = inputnum + k \r\n              res = []\r\n              while summ > 0:\r\n                      digit = summ % 10\r\n                      res.append(digit)\r\n                      summ = summ // 10\r\n              return res[::-1]\r\n\r\nTime Complexity: O(n) because we run through the given array one time\r\nSpace Complexit: O(n) because we created a new array res to record the sum","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917213167","body":"two pointers: for each character in the string we initialize two points L and R before and after the current character. Then we decrease the left pointer and increase the right pointer until the target character is found on the left side and right side of the current character. Then we record the minimum of the two distances. \r\nPython 3 code: \r\n\r\n    class Solution:\r\n         def shortestToChar(self, s: str, c: str) -> List[int]:\r\n               ans = []\r\n               for i in range(len(s)):\r\n                    left_val = len(s)\r\n                    right_val = len(s)\r\n                    if s[i] == c:\r\n                       ans.append(0)\r\n                       continue\r\n                    l , r = i - 1, i + 1\r\n                    while r <= len(s)-1:\r\n                             if s[r] == c:\r\n                                right_val = r - i\r\n                                break\r\n                             else:\r\n                                   r += 1\r\n                    while l >= 0:\r\n                             if s[l] == c:\r\n                               left_val = i - l\r\n                               break\r\n                             else:\r\n                                   l -= 1\r\n                   ans.append(min(left_val, right_val))\r\n               return ans\r\nTime complexity O(n^2) we scan through the string twice.\r\nSpace Complexity O(n) we record the distances in an list 'ans'","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916408891","body":"## 代码\nJava:\n```\n public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int i = num.length-1;\n        int carry = k;\n        while (i >= 0 || carry > 0) {\n            int n = i >= 0 ? num[i--] : 0;\n            carry += n;\n            list.add(carry % 10);\n            carry /= 10;\n        }\n        \n        Collections.reverse(list);\n        return list;\n    }\n```\nTime：O(n)     \nSpace：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409263","body":"# Solution1\n\nUse while loop to add K to num digit by digit. Maintain the carry and end the loop when carry is 0 and all digits from K has been added. Note that inserting to the list head is not efficient.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        while k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            if idx < 0:\n                num.insert(0, 0)\n                i = 0\n            else:\n                i = idx\n            tmp = num[i] + digit + carry\n            num[i] = tmp % 10\n            carry = tmp // 10\n            idx -= 1\n        return num\n```\n\nTime complexity: O(N + max(0, K - N)^2), K is length of k and N is length of num\n\nSpace complexity: O(max(1, K - N))\n\n# Solution2\n\nCreate another result array and always append the digit sum to the result end to avoid insert to head. Reverse the result list before return. The while loop end condition will also need to check if it has traversed all the num list.\n\n# Code\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry, idx = 0, len(num) - 1\n        res = []\n        while idx >= 0 or k > 0 or carry > 0:\n            digit = k % 10\n            k = k // 10\n            n = num[idx] if idx >= 0 else 0\n            res.append((n + digit + carry) % 10)\n            carry = (n + digit + carry) // 10\n            idx -= 1\n        return reversed(res)\n```\n\nTime complexity: O(N)\n\nSpace complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917162074","body":"# Note\n\nRecord the occurrence of char c in a list c_idx. Then use two pointers i and p to iterate S and c_idx. For each i, compare the distance with p and p+1 until find the closest p.\n\nThe space complexity can be improved. Instead of saving the c positions, we can scan the S twice from **left to right and from right to left**. So that each char will be able to compare to the closest C on its left and right.\n\n# Solution1\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res, c_idx = [], []\n        for i, ch in enumerate(s):\n            if ch == c:\n                c_idx.append(i)\n        p = 0\n        for i in range(len(s)):\n            while (p < len(c_idx) - 1 and abs(c_idx[p + 1] - i) < abs(c_idx[p] - i)):\n                p += 1\n            res.append(abs(c_idx[p] - i))\n        return res\n```\n\nTime complexity: O(2N + K) where N is the length of s and K is occurrence count of c.\n\nSpace complexity: O(K) to save the char occurrence positions.\n\n# Solution2\n\n```python\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n, c_idx = len(s), float('-inf')\n        res = [n] * n\n        for i in range(n):\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        for i in range(n)[::-1]:\n            if s[i] == c: c_idx = i\n            res[i] = min(res[i], abs(i - c_idx))\n        return res\n```\n\nTime complexity: O(2N) where N = len(s)\n\nSpace complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916409706","body":"很笨的办法， 请忽略  \n时间复杂度 o(n),\n空间复杂度o(n)\n\n  `def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        n = len(num)\n        temp = 0\n        for i in range(n):\n            temp +=num[i]* (10**(n-1-i))     \n        b = temp + k\n        res = []\n        while b>9:\n            d = b%10\n            b = b//10\n            res.append(d)\n        res.append(b)\n        res.reverse()        \n        return res`\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917050689","body":"思路：维护一个滑动窗口[left, right]，不断调整窗口的位置\r\n          left=right\r\n          right = new location\r\n\r\n1. 第一遍遍历, 统计所在的位置temp\r\n2. 如果temp只有一个元素， 那就直接再遍历一次，直接返回结果res\r\n3. 如果temp 有2个及其以上元素，那就用滑动窗口\r\n时间复杂度： O(n)\r\n空间复杂度： O(n)\r\n\r\n`    Python3 :\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        temp = []\r\n        for i in range(len(s)):\r\n            if c==s[i]:\r\n                 temp.append(i)\r\n        res = [-1 for _ in range(len(s))]\r\n        # print(temp)\r\n        if len(temp)==1:\r\n            res = [abs(i-temp[0]) for i in range(len(s))]\r\n            return res\r\n        left = temp[0]\r\n        right = temp[1]\r\n        j=1\r\n        for i in range(len(s)):\r\n            if i<=temp[0]:\r\n                res[i] = temp[0]-i\r\n                continue\r\n            elif i>=temp[-1]:\r\n                res[i]=i-temp[-1]\r\n            elif i==left:\r\n                    res[i]=0\r\n            elif i==right:\r\n                res[i]=0\r\n                if j<(len(temp)-1):\r\n                    left = right\r\n                    j+=1\r\n                    right = temp[j]\r\n                    # print(\"now it's time to shift window, new left=\",left,\" right=\",right)\r\n            else:\r\n                res[i] = min(abs(i-left), abs(right-i))\r\n                # print(\"i is inside the window\")\r\n                # print(\"     i = \",i,\",res[i]=\",res[i])\r\n                # print(\"          left = \",left)\r\n                # print(\"          right = \",right)\r\n        return res`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916420802","body":"## Thinking\nassume  num length is n, k has m digits\n\nTake [1,2,3]+999 as an example\n\nFirst convert [1,2,3] into 123 which takes O(m)\n\nThen add 123 with 999 = 1122, which takes O(1)\n\nFinally convert 1122 to [1,1,2,2] which is O(max(m,n)+1)  = O(max(m,n)\n\n\n## Code\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        m = 0\n        for digit in num:\n            m = m * 10 + digit\n        sum_ = m + k\n        result = []\n        while sum_:\n            result.append(sum_ % 10)\n            sum_ //= 10\n        return result[::-1] if result else [0]\n\n```\n\n## Complexity\nTime: O(n)+O(1)+O(max(m,n) = O(m+n)\n\nSpace Complexity: O(max(m,n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917107545","body":"## Thoughts\nassume s length is n\n\ntake S = \"loveleetcode\", C = 'e' as an example\n\nfirst we compute the position of C in S, we can get T  [3,5,6,11], O(n), if S only contains chars of C then T will have same length as S.\n\nthen we can use one pointer (c_index) to indicate which position of C in S we are referring to \nwe iterate through S with index i, each time we will only compare at the position of current char in S with two positions in T, (c_index, and c_index+1), and chose the minimal difference \nWhenever s[I] is equal to next position in T, we will update c_index\n\nthe whole two pointers approach takes at most 2n which is O(n)\n\n## code \n```python\nfrom typing import List\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        positions = [i for i in range(len(s)) if s[i] == c]\n        c_index = 0\n        results = []\n        for i in range(len(s)):\n            if c_index < len(positions) - 1 and i == positions[c_index + 1]:\n                c_index += 1\n            if c_index == len(positions) - 1:\n                results.append(abs(i - positions[c_index]))\n            else:\n                results.append(\n                    min(abs(i - positions[c_index]), abs(positions[c_index + 1] - i))\n                )\n        return results\n\n```\n\n## Complexity\nTime complexity: O(n) \n\nSpace Complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916424749","body":"**思路:**\r\n1. 数组num的第1个元素num[0]表示整数的最高位数字, 第n个元素num[n - 1]代表整数的个位数字\r\n2. 新的整数的每一位数字由三个部分决定：num[i], 整数k的当前位(k % 10), 进位(carry)->sum = val + k % 10 + carry\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(max(N, lgk))，N为数组num的长度, k为给定整数k\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n        int carry = 0, val = 0, sum = 0;\r\n        while (n >= 0 || k != 0) {\r\n            val = (n >= 0) ? num[n] : 0;\r\n            sum = val + k % 10 + carry;\r\n            res.push_back(sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        if (carry)\r\n            res.push_back(carry);\r\n        \r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917118118","body":"**思路:**\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为字符串s的长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, n - 1);\r\n\r\n        int idx = n - 1;\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        idx = 0;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916425383","body":"**Explanation**\r\n\r\n- Convert k to its array-form. \r\n- Add the array-forms of num and k by digit from the end to the beginning and save it in the result array. \r\n- Reverse the array-form of the result. \r\n\r\nUse the quotient and remainder divided by 10: set the current position as the remainder and update the quotient for the next position.\r\n\r\n**Python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        newK = []\r\n        for i in str(k):\r\n            newK.append(int(i))\r\n        \r\n        result = []\r\n        i, j = len(num)-1, len(newK)-1\r\n        quotient, remainder = 0, 0\r\n        while i >= 0 or j >= 0:\r\n            currI = num[i] if i >= 0 else 0\r\n            currJ = newK[j] if j >= 0 else 0\r\n            curr = currI + currJ + quotient\r\n            result.append(curr % 10)\r\n            quotient = curr // 10\r\n            i -= 1\r\n            j -= 1\r\n            \r\n        if quotient != 0:\r\n            result.append(quotient)\r\n        return result[::-1]\r\n```\r\n\r\n**Complexity**\r\n\r\n- Time Complexity: ```O(max(N, logk))``` where N is the length of the ```num``` array.\r\n- Space Complexity: ```O(max(N, logk))``` \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916426832","body":"## Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n \r\n## Python\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\n```\r\n\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917027536","body":"## Thought\r\nTraverse the array twice, one time we traverse from left to right, the second time we traverse from the back. In the first iteration, we record a temporary variable for the index where `s[i] == c`, then we can know all the distance of a character with a `c` character behind it.  Then in the opposite direction, we determine if a `c`  on the left side or on the right side is the closest for it.\r\n\r\n## python\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        N = len(s)\r\n        ans = [100000] * N\r\n        closeLoc = -100000\r\n        for i in range(N):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(i-closeLoc, ans[i])\r\n        \r\n        closeLoc = 100000\r\n        for i in range(N-1, -1, -1):\r\n            if s[i] == c:\r\n                closeLoc = i\r\n            else:\r\n                ans[i] = min(closeLoc-i, ans[i])\r\n        \r\n        return and\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZhuMengCheng":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916429301","body":"思路:\r\n从末尾相加后截取末尾存储进位,, 测试用例: [2,1,5]  806  \r\n 比如806和5相加等于811 ,保存末尾1,\r\n继续相加为81+1=82. 保存2 类推,\r\n 8会和下一个2相加为10,  \r\n整个数组的值变成[10,2,1] 截取10的情况,可能计算次数超过数组长度.需要添加额外条件判断计算次数\r\n`/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = []\r\n    // k>0 如果遇到合为10需要多一次计算 ,查询条件不能限制为只有num数组的长度\r\n    for(let i = num.length-1 ;i>=0 || k > 0;--i){\r\n        // 大于0的位数直接相加后取余数进位\r\n        if(i >= 0){\r\n            k += num[i]\r\n        }\r\n        res.push(k % 10)\r\n        // 计算是否有等于10 或者大于0的情况,在执行下次进位\r\n        k  =   (k - k  % 10) / 10\r\n    }\r\n    return res.reverse()\r\n}`\r\n\r\n时间复杂度：O(max(n,log k))\r\n空间复杂度:  O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lllouiselao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916434574","body":"[989. Add to Array-Form of Integer](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n#### 想法：最brutal way： traverse list->str->int->list \n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        str_turple = ''\n        for i in num:\n            str_turple += str(i)\n\n        str_int = int(str_turple) + k\n        int_str = str(str_int)\n\n        output = []\n        for n in int_str:\n            output.append(int(n))\n        return output\n```\n#### complexcity O(n^2) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916452724","body":"### 思路: \n\nFirst, we should convert k to list and iterate from back of the list. If the sum of two digits at the same position plus carry is greater than 10, then we set the carry to 1. The modulo of the sum is the result at that position. \n\n### 代码：\n```\n  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n**复杂度分析**\n\nTime Complexity: O(n) n is the largest length of two numbers\n\nSpace Complexity: O(n) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917311617","body":"### 思路\r\nBefore the loop we need two variables prev(keep track the most recent index of c ) and j (everything before j in s has been calculated). We iterate from 0 to the end, if we found current index is c, we keep calculating min distance until j reach current index. We also update the prev.  \r\n\r\n### 代码\r\n```\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result=[-1]*len(s)\r\n        j=0\r\n        prev=None\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                while j<=i:\r\n                    if prev is not None:\r\n                        min_dis = abs(prev-j)\r\n                    else:\r\n                        min_dis = float('inf')\r\n                    min_dis=min(abs(j-i),min_dis)\r\n                    result[j]=min_dis\r\n                    j+=1\r\n                prev=i\r\n        while j < len(s):\r\n            result[j]=abs(prev-j)\r\n            j+=1\r\n        return result \r\n```\r\n### 复杂度\r\nTime: O(n) n is the length of s\r\nSpace: O(1) \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481597","body":"## Java\n#### 解题思路\n+ 整型数组开始与k相应的位上的数字相加（从个位开始，整型数组的个位是num[num.length-1]），并将每位上相加的结果添加到一个整型的Array数组中。\n+ 这里需要注意如果相对应位置上的数相加大于10时，我们应该有进位操作，即 让k+1，number-10（ps：这里的number代表整型数组与k的相应位置上的数相加后得到的结果）\n+ 最后如果k>0,这说明最高位上有进位，最后得到的数组少最高位，我们应该再把k的每个位置的数取出来加入到数组中。\n+ 由于低数位先加入我们最终得到的Array数组中，所以我们需要翻转一下得到的数组，在java中可以调用Collections.reverse()函数来实现。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        List<Integer> resultList = new ArrayList<>();\n        int sum =0;\n        for(int i=len-1;i>=0;i--){\n            sum = num[i]+k%10;\n            k=k/10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            resultList.add(sum);\n        }\n        while(k>0){\n            resultList.add(k%10);\n            k=k/10;\n        }\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n#### 时间复杂度\nO(n)\n#### 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916481742","body":"### 思路\r\n convert a list of integers into a number\r\n update this number by adding k \r\n convert back the result into a list of integers\r\n### 代码\r\n```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_str = \"\"\r\n        for n in num:\r\n            num_str += str(n)\r\n        output = []\r\n        for n in str(int(num_str) + k):\r\n            output.append(int(n))\r\n        return output\r\n```\r\n**复杂度分析**\r\nTime Complexity：O(n)\r\nSpace Complexity：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916499894","body":"\n\n\n## 思路\n- 把K按照位转换成vector。则求解方法和求解两个vector 数相加相同，从后往前遍历。注意carry。时间复杂度 k的位数N，A的位数位M, O(N) + O(max(N,M)) 空间复杂度为 O(N + max(N,M)) \n\n\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        vector<int> veck;  \n        while(k)\n        {\n            veck.push_back(k%10);\n            k =k /10; \n        }\n        bool next = false; \n        int left =num.size()-1; \n        int right =0; \n        vector<int> ret; \n        while(left>=0 && right < veck.size())\n        {\n            int sum = num[left] + veck[right] + (next? 1:0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--; \n            right++; \n        }\n        while(left>=0)\n        {\n            int sum = num[left] + (next? 1:0); \n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            left--;                 \n        }\n        while(right < veck.size())\n        {\n            int sum = veck[right] + (next? 1 : 0);\n            if(sum/10)\n                next = true; \n            else\n                next = false; \n            sum = sum%10; \n            ret.push_back(sum);    \n            right++;             \n        }\n        if(next)\n            ret.push_back(1);\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917122923","body":"## 思路\n- 最短距离，使用BFS。第一次遍历找到所有c的字符，放入queue。并设置初始化距离0。下面通过BFS遍历，一层一层设置其他字符的距离。复杂度O(N) + O(N)。空间复杂度O(N)。需要使用队列记录节点。\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        //  method 1 use queue and bft. \n        queue<int> que; \n        vector<int> ret(s.size(), INT_MAX); \n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i]==c)\n            {\n                ret[i]=0; \n                que.push(i);\n            }\n        }\n        while(que.size())\n        {\n            int topVal = que.front();\n            que.pop();\n            for(int i=-1; i<=1; i=i+2)\n            {\n                int newIndex = topVal +i; \n                if(newIndex<0 || newIndex>=s.size()) // skip; \n                    continue;                \n                if(ret[topVal]+1 < ret[newIndex])\n                {\n                    que.push(newIndex);\n                    ret[newIndex]=ret[topVal]+1;\n                }\n            }\n        }        \n        return ret; \n        \n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916507442","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    ans = [];\r\n    while(i >= 0 || k != 0) {\r\n      sum = carry;\r\n      if (i >= 0) {\r\n        sum += num[i];\r\n        i--;\r\n      }\r\n      if (k != 0) {\r\n        sum += k % 10;\r\n        k = Math.floor(k / 10);\r\n      }\r\n\r\n      carry = Math.floor(sum / 10);\r\n      ans.unshift(sum % 10);\r\n    }\r\n\r\n    if (carry > 0) {\r\n      ans.unshift(carry);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。 k <= 10^4 不计\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917253566","body":"### 思路\r\n正序遍历，计算每个位置到左侧指定字符的最短距离；\r\n倒序遍历，计算每个位置到右侧指定字符的最短距离；\r\n取最小值。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length);\r\n  let count = s.length;\r\n  for (let i=0; i<s.length; i++) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = count;\r\n  }\r\n\r\n  count = s.length;\r\n  for (let i=s.length-1; i>=0; i--) {\r\n    count = s[i] === c ? 0 : count + 1;\r\n    ans[i] = Math.min(ans[i], count);\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(s.length)\r\n- 空间复杂度：O(s.length)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916511474","body":"JS 占坑\r\n其实可以用力扣第二题（两数之和） 类似的解法\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for (let i = num.length - 1; i >= 0 || k > 0; i--) {\r\n\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n\r\n        res.push(k % 10); // 当时个位上的数\r\n        k = (k - k % 10) / 10;\r\n    }\r\n\r\n    return res.reverse();\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916531466","body":"思路：\n1.数组从个位开始[即从后往前计数]，用一个sum保存位和[加数+被加数+低位进位],一个pre保存进位\n重新设置一个输出数组out。\n2.数组从后往前遍历，每位与k%10相加、与低位进位相加，获得sum 。 sum%10加入数组，sum/10为进\n位值，运算完记得把k/10.\n3.若数组跑完k还有值或进位有值，则再跑一遍循环处理完剩余的数据\n4.最后对整个数组首尾交换即可\n代码：\n```Go\nfunc largestRectangleArea(heights []int) int {\n    stack := []int{}\n    N := len(heights)\n    st, result := make([]int,N+2), 0\n    for i:=0; i< N+2;i++{\n        if i == 0 || i == N+1{\n            st[i] = 0\n        }else{\n            st[i] = heights[i-1]\n        }\n    }\n    for i:=0; i < N+2;i++{\n        for len(stack) > 0 &&st[i] < st[stack[len(stack)-1]]{\n            mid := stack[len(stack)-1]\n            stack = stack[:len(stack)-1]\n            w := i - stack[len(stack)-1] - 1\n            h := st[mid]\n            result = max(result, w*h)\n        }\n            stack = append(stack, i)\n    }\n    return result\n}\n\nfunc max(x, y int) int{\n    if x > y{\n        return x\n    }else{\n        return y\n    }\n}\n```\n时间复杂度：O(n)\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318416","body":"首先生成一个N长度的数组output，并且对每个值赋值len（s）【N为字符串s的长度】,然后从数组前后分别遍历一次。\r\n从前往后时，先判断字符是否等于目标字符，若相等则数组output置0.对于不相等的字符再次判断，若字符串位于首位，则置为len（s）。接下来，每位的取值为该数组左边一位的取值加1:output[i] = output[i-1] + 1\r\n从后往前时，从倒数第二位开始判断。当该值大于等于len（s）说明该数的左边没有特定字符 或 此时的取值大于 该值右边一位的数值+1【取左右目标字符的距离最小值】，则取 该值右边一位的数值+1\r\n\r\n关键边界条件两个：\r\n1.从左往右遍历的0位，他的取值没有上一位进行参考\r\n2.有右往左的遍历n-1位，他的取值没有下一位进行参考\r\n\r\n```Go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    output := make([]int,len(s), len(s))\r\n    for i:=0; i< len(s); i++{\r\n        if(s[i] == c) {\r\n            output[i] = 0\r\n        }else{\r\n            if i==0 {\r\n                output[i] = len(s)\r\n            }else{\r\n               output[i] = output[i-1] + 1\r\n            }\r\n        }\r\n    }\r\n\r\n    for i:=len(s)-2;i >= 0;i--{\r\n        if (output[i] >= len(s) || output[i] > output[i+1] + 1){\r\n            output[i] = output[i+1] + 1\r\n        }\r\n    }\r\n    return output\r\n}\r\n```\r\n复杂度分析\r\n时间复杂度O（n）\r\n空间复杂度O（n）\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534184","body":"### 解题思路\n因为数组num的长度太大，会越界，所以每一数位单独运算。把k先用字符串方法转换为各个数位的数组。用`carry`记录进位，每一个对应数位进行加法运算，结果存到链表头部。注意循环结束后再查看一下最终进位`carry`是否为0，不为0的话存到链表中。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        String str = String.valueOf(k); // Convert k to string, can also use Integer.toString(k)\n        String[] elements = str.split(\"\"); // Get individual digits as String format\n        int klen = elements.length;\n\n        int carry = 0;\n        LinkedList<Integer> result = new LinkedList<>();\n        int nlen = num.length;\n        int length = nlen > klen ? nlen : klen;\n\n        for (int i = 0; i < length; i++) {\n            int knum = i < klen ? Integer.parseInt(elements[klen - 1 - i]) : 0;\n            int cur = nlen - 1 - i;\n            int n = i < nlen ? num[cur] : 0;\n            result.addFirst((n + knum + carry) % 10);\n            carry = (n + knum + carry) / 10;\n        }\n\n        if (carry != 0) result.addFirst(carry);       \n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(n), 创建链表储存结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917266221","body":"### 解题思路\n遍历两次字符串：第一次正向遍历，计算每个字符和前面出现的特殊字符的最近距离；第二次反向遍历，计算每个字符和后面出现的特殊字符的最近距离。两次遍历过程中，把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] res = new int[length]; // create int array with size of the length of string\n        Arrays.fill(res, length); // initialize the array and fill with the length of string (the distance between two characters is always smaller than the length of string)\n\n        int idx = 0;\n        // traverse the array, and update the distance\n        for (int i = s.indexOf(c); i < length; i++) {\n            if (s.charAt(i) == c) idx = i;\n            if (Math.abs(idx - i) < res[i]) res[i] = Math.abs(idx - i);\n        }\n        // traverse the array in reverse order, and update the distance\n        for (int j = s.lastIndexOf(c); j >= 0; j--) {\n            if (s.charAt(j) == c) idx = j;\n            if (Math.abs(idx - j) < res[j]) res[j] = Math.abs(idx - j);\n        }\n\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数\n- 空间复杂度：O(n)，建立了整数数组储存结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZJP1483469269":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916534668","body":"#### 思路\n对数组与k进行按位加 保留进位位，并与下一位的k和数组相加 最后判断k是否加完，若没有则直接加进队列\n#### 代码\n    class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int c=0;\n        int a=0;\n        LinkedList<Integer> ans = new LinkedList<>();\n        for(int i=len-1;i>=0;i--){\n            a = (num[i] + k%10 + c )%10;\n            c = (num[i] + k%10 + c)/10;\n            k = k/10;\n            ans.addFirst(a);\n        }\n        if(c!=0){\n            k=k+c;\n        }\n        if(k!=0){\n            while(k!=0){\n                ans.addFirst(k%10);\n                k/=10; \n            }\n        }\n        return ans;\n    }\n}; \n\n####复杂度分析\n时间复杂度：O(n) n为数组长度\n空间复杂度：O(n) n为数组长度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319847","body":"#### 思路\n对字符串从左到右遍历一次，对于c字符右侧的非c字符，在对应的数组中加1，然后对字符串从右到左遍历一次，对于c字符左侧的非c字符，在对应的数组中减1并与第一次遍历得到的数据进行比较取较小值填入数组。\n\n#### 代码\n    class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int p =s.indexOf(c),q=s.lastIndexOf(c);\n        for(int i=p;i<len-1;i++){\n            res[i+1]=res[i]+1;\n            if(s.charAt(i+1)==c)\n                res[i+1]=0;\n        }\n        for(int i=q;i>0;i--){\n           \n            if(res[i-1]!=0)\n                res[i-1]=res[i]+1<res[i-1] ? res[i]+1 : res[i-1];\n            else\n                res[i-1]=res[i]+1;   \n            if(s.charAt(i-1)==c){\n                res[i-1]=0;\n            } \n\n        }\n        return res;\n    }\n    }   \n#### 复杂度分析\n时间复杂度：O(N）\n空间复杂度：O(N)N为字符串长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916536901","body":"## 思路\r\n\r\n+ 当前位 = 数字A + 数字B + 进位\r\n+ 利用 k 作为进位和数字B的和\r\n\r\n## 代码\r\n\r\n~~~ cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int size = num.size(), sum = 0;\r\n        for (int i = size - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            result.push_back(k % 10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n~~~\r\n\r\n## 复杂度分析\r\n\r\n+ 空间复杂度 `O(n)`\r\n+ 时间复杂度`O(max(n, logk))`\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916539064","body":"## 989. Add to Array-Form of Integer\n\nThe **array-form** of an integer `num` is an array representing its digits in left to right order.\n\n- For example, for `num = 1321`, the array form is `[1,3,2,1]`.\n\nGiven `num`, the **array-form** of an integer, and an integer `k`, return *the **array-form** of the integer* `num + k`.\n\n**Example 1:**\n\n```\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n```\n\n## Note\n\n1. O(n), O(n), `n is max(n.length,k.digitsNum)`\n   1. **From right to left**, pick the digits from the num array and k to construct the result array; Reverse the result array when returning.\n   2. CurrentValue is comprised of value from num, k and carry;Keep running the loop **as long as there is a value in num, k or carry**;\n2. Problems:\n   1. The num array could be too big to perform normal addition which leads to a totally wrong answer. \n   2. The summation of num array could be less than k which means that we may run out of the num array first.\n   3. Never forget carry.\n   4. The division in JS won’t give you an Int, please use `Math.floor()`.\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res=[];\n    let carry=0;\n    let rightIndex=num.length-1;\n    \n    while(rightIndex>=0 || k>0 || carry>0){\n        let currentSum=rightIndex>=0?num[rightIndex]+carry+ k%10:carry+ k%10;\n        k=Math.floor(k/10);\n        carry=Math.floor(currentSum/10)\n        res.push(currentSum%10);\n        rightIndex--;\n    }\n  \n    return res.reverse();\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348991","body":"## 821. Shortest Distance to a Character\n\nGiven a string `s` and a character `c` that occurs in `s`, return *an array of integers* `answer` *where* `answer.length == s.length` *and* `answer[i]` *is the **distance**from index* `i` *to the **closest** occurrence of character* `c` *in* `s`.\n\nThe **distance** between two indices `i` and `j` is `abs(i - j)`, where `abs` is the absolute value function.\n\n**Example 2:**\n\n```\nInput: s = \"aaab\", c = \"b\"\nOutput: [3,2,1,0]\n```\n\n## Note\n\n1. O(n*m), O(m+n), n is the length of the string, m is the occurrence of c. \n   1. Iterate the string s to get all the indices of c\n   2. Iterate the string s again to fill the result array by comparing current index with all the indices in Step 1 to get a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let indicesOfC=[];\n    let res=[];\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) indicesOfC.push(i);\n    }\n    \n    for(let j=0;j<s.length;j++){\n        let currDistance=s.length;\n        for(let k of indicesOfC){\n            currDistance=Math.min(currDistance,Math.abs(j-k));\n        }\n        res.push(currDistance);\n    }\n    \n    return res;\n};\n```\n\n2. O(n), O(n), n is the length of the string.\n   1. Use a prev index to remember to previous occurring index of c.\n   2. Add the distance of prev and to res array.\n   3. Loop the string reversely, change the res array if there is a minimal.\n\n```js\nvar shortestToChar = function(s, c) {\n    let res=[];\n    let prev=Infinity;\n    \n    for(let i=0;i<s.length;i++){\n        if(s[i]===c) prev=i;\n        res[i]=Math.abs(prev-i);\n    }\n    \n    prev=Infinity;\n    for(let j=s.length-1;j>=0;j--){\n        if(s[j]===c) prev=j;\n        res[j]=Math.min(res[j],Math.abs(prev-j));\n    }\n    \n    return res;\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916540032","body":"```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    const res = [];\n    let carry = 0;\n    num.reverse();\n    const strK = String(k).split('').reverse().join('');\n    const maxLen = Math.max(num.length, strK.length)\n    for (let index = 0; index < maxLen; index++) {\n        let value = Number(strK[index] ? strK[index] : 0) + (num[index] ? num[index] : 0) + carry;\n        if (value >= 10) {\n            value %= 10;\n            carry = 1\n        } else {\n            carry = 0\n\n        }\n        res.push(value);\n    }\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917312078","body":"```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        const dis = getDis(i, s, c);\r\n        res.push(dis)\r\n    }\r\n    return res\r\n};\r\nconst getDis = (i, s, c) => {\r\n    let l = i, r = i, dis = Infinity;\r\n    if (s[i] === c) return 0;\r\n    while (l >= 0) {\r\n        if (s[l] === c) {\r\n            dis = Math.min(dis, i - l);\r\n            break;\r\n        }\r\n        l--;\r\n    }\r\n    while (r < s.length) {\r\n        if (s[r] === c) {\r\n            dis = Math.min(dis, r - i);\r\n            break;\r\n        }\r\n        r++;\r\n    }\r\n    return dis\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916541347","body":"### 代码\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        num_k = []\n        while k > 0:\n            num_k.insert(0, k%10)\n            k = k // 10\n        l, lk = len(num), len(num_k)\n        if l < lk:\n            num, num_k = num_k, num\n            l, lk = lk, l\n        carry = 0\n        for i in range(max(l, lk)):\n            s = carry\n            l_idx, lk_idx = l-i-1, lk-i-1\n            s += num[l_idx]\n            if lk_idx >= 0:\n                s += num_k[lk_idx]\n            if s >= 10:\n                carry = s // 10\n                s = s % 10\n            else:\n                carry = 0\n            num[l_idx] = s\n        if carry > 0:\n            num.insert(0, carry)\n        return num\n```\n### 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327549","body":"### 代码\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0]*n\n        carry = -1\n        for i in range(n):\n            if s[i] == c:\n                carry = i\n                res[i] = i\n            else:\n                res[i] = carry\n        carry = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                carry = i\n                res[i] = 0\n            else:\n                if res[i] == -1 and carry != -1:\n                    res[i] = abs(carry-i)\n                elif res[i] != -1 and carry == -1:\n                    res[i] = abs(res[i]-i)\n                else:\n                    res[i] = min(abs(res[i]-i), abs(carry-i))\n        return res\n                   \n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916548236","body":"##  当前的问题：\r\n\r\n### 题目 run 的时候被 accept 了，但是 submit 的时候说是答案是错的。新手不知道该怎么改进。先把卡打了再说。如果有大佬看到，可以指点迷津吗？谢谢。我会继续改进。\r\n\r\n##  思路: \r\n\r\n- 先把当前 array 中转 string 再转回 integer, numInt；\r\n- 把 numInt 和 k 加起来成和, sum；\r\n- 利用 sum 除以 10 的余数来加入到新 array 的尾部\r\n\r\n## 代码 Javascript \r\n\r\n```\r\nconst addToArrayForm = function(num, k) {\r\n    const numInt = parseInt(num.join(''));\r\n    let sum = numInt + k;\r\n    const resultArray = [];\r\n    while (sum >= 0) {\r\n           let el = sum % 10 ;\r\n           sum = Math.floor(sum / 10);\r\n           resultArray.splice(0, 0, el);\r\n           }\r\n    return resultArray;\r\n```\r\n\r\n##  复杂度分析\r\n\r\n时间与空间均为 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917193739","body":"# link: \r\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\r\n\r\n# 知识弱点：\r\n\r\n- nested for loops (eg. i & j): how it works is that 到 i 某一个 index, 遍历一遍 j 的所有 indices,然后再移到 i 的下一个 index\r\n\r\n## （抄）思路 （没有自己做出来，看的别人的答案）:\r\n\r\n- 先把 c 找出来，把 c 的 indices 存入数组；\r\n- 遍历整个数组，每一个 index 与 c 对应的 index 求绝对值到差， 来找到每一个 index 与最近一个 c 的 距离；\r\n- 把这些距离存入新的空数组\r\n\r\n## 代码 Javascript\r\n\r\n```javascript\r\nconst shortestToChar = function (s, c) {\r\n  const indices = [];\r\n  const distances = [];\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      indices.push(i);\r\n    }\r\n  }\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    let min = Number.MAX_SAFE_INTEGER;\r\n    for (let j = 0; j < indices.length; j++) {\r\n      let distance = Math.abs(indices[j] - i);\r\n      if (distance < min) {\r\n        min = distance;\r\n      }\r\n    }\r\n    distances.push(min);\r\n  }\r\n\r\n  return distances;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n时间 O(n2)\r\n\r\n空间 不会算\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916558714","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length-1;\n        while(i>=0||k>0){\n            if(i>=0){\n                k +=num[i];\n            }\n            list.addFirst(k%10);\n            k /= 10;\n            i--;\n        }\n        return list;\n    }\n}\n复杂度分析：\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559464","body":"两个思路：\n\n1.将数组元素转化为数字，然后数字相加，返回数组【但是，数字表示范围容易超限】\n\n2.按位相加\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        long long n = 0;\n        for (int i = 0; i < num.size(); ++i)\n        {\n            n = n * 10 + num[i];\n        }\n        n += k;\n        vector<int>res;\n        if(n==0) return {0};\n        while (n != 0)\n        {\n            res.push_back(n % 10);\n            n /= 10;\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n超出数字表示范围\n\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n        int i = num.size()-1;\n        vector<int>res;\n        while(i>=0)\n        {\n            int temp = num[i] + k;\n            res.push_back(temp%10);\n            k = temp/10;\n            i--;\n        }\n        while(k>0) {\n\t\t\tres.push_back(k%10);\n\t\t\tk/=10;\n\t\t}\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n\n时间复杂度O（N）\n\n空间复杂度O（N）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916559576","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n## S1: 逐位相加\r\n\r\n将数字逐位相加，从低位到高位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        int carry = 0;\r\n        while (i >= 0 || k > 0 || carry > 0) {\r\n            int a = i >= 0 ? num[i--] : 0;\r\n            int b = k > 0 ? k % 10 : 0;\r\n            k /= 10;\r\n            int sum = a + b + carry;\r\n            ans.push_back(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$，N 是 num 的长度，logk 是 k 的位数。进行逐位相加以及最后 reverse 数组的时间分别都是 $O(max(N,logk))$。\r\n- ***Space:** $O(1)$，*除返回值外，使用的是常数空间。\r\n\r\n## S2: 相加\r\n\r\n将 k 从低位到高位直接加到数组的每一位。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> ans;\r\n        int i = num.size() - 1;\r\n        while (i >= 0 || k > 0) {\r\n            k += i >= 0 ? num[i--] : 0;\r\n            ans.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- ****Time:**** $O(max(N,logk))$\r\n- ***Space:** $O(1)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916561783","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]: \r\n        # if k is 0, do an early return\r\n        if k == 0:\r\n            return num\r\n        # convert the array into an integer\r\n        temp = 0\r\n        for i in range(len(num)):\r\n            temp = temp * 10 + num[i]\r\n        # get the updated integer\r\n        temp = temp + k\r\n        # convert it back to an array by appending digits of the integer backwards to the result array\r\n        result = []\r\n        while temp > 0:\r\n            result.append(temp%10)\r\n            temp = temp // 10\r\n        return result[::-1]\r\n\r\n\r\ntime: O(n) - n is the length of num\r\nspace: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916563357","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n\r\n### 官方求解方法\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        result1=[]\r\n        for i in range(len(num)-1,-1,-1):\r\n            r1=num[i]+k%10\r\n\r\n            remain1=k//10+r1//10\r\n            if r1>=10:\r\n                r1=r1%10\r\n            result1.insert(0,r1)\r\n            k=remain1\r\n        if k>0:\r\n            while k:\r\n                result1.insert(0,k%10)\r\n                k=(k-k%10)//10\r\n        return result1\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n### 字符串求解\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        str1=''\r\n        for num1 in num:\r\n            str1+=str(num1)\r\n        result1=int(str1)+k\r\n        return [int(s1) for s1 in str(result1)]\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566326","body":"### 一位一位相加即可\n````java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int x = 0;\n        LinkedList<Integer> list = new LinkedList<>();\n        for (int i = 0; i < num.length; i++) {\n            int num1 = num[num.length - i - 1];\n            int num2 = k % 10;\n            k /= 10;\n            int sum = num1 + num2 + x;\n            if(sum >= 10) {\n                sum = sum - 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(sum);\n        }\n        while (k > 0 || x == 1) {\n            int num1 = k % 10 + x;\n            k /= 10;\n            if(num1 >= 10) {\n                num1 -= 10;\n                x = 1;\n            }else {\n                x = 0;\n            }\n            list.addFirst(num1);\n        }\n\n        return list;\n    }\n}\n````\n### 复杂度分析\n时间复杂度: O(max(n, logk))\n空间复杂度: O(max(n, logk)) 存储需要返回的结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345699","body":"### 开始没理解思路只能暴力破解\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] nums = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            int left = i;\n            int right = i;\n            while (left >= 0 || right <s.length()) {\n                if(left >= 0) {\n                    if(s.charAt(left) == c) {\n                        nums[i] = Math.abs(i - left);\n                        break;\n                    }\n                    left--;\n                }\n                if(right < s.length()) {\n                    if(s.charAt(right) == c) {\n                        nums[i] = Math.abs(i - right);\n                        break;\n                    }\n                    right++;\n                }\n            }\n        }\n        return nums;\n    }\n}\n````\n\n### 两次for循环\n````java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] nums = new int[s.length()];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE / 2;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) pre = i;\n            nums[i] = Math.min(nums[i], pre - i);\n        }\n        return nums;\n    }\n}\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916566437","body":"## 思路\r\n\r\n---\r\n\r\n从数组末尾（个位）开始，逐位相加，并计算进位，因为是从低位开始计算，每次结果都要添加到结果数组的头部\r\n\r\n## 代码：JavaScript\r\n\r\n---\r\n\r\n```JavaScript\r\nvar addToArrayForm = function(num, k) {\r\n    const ans = [];\r\n    let carry = 0;\r\n    let cur;\r\n    let Addres;\r\n    let item;\r\n    let pos = num.length - 1;\r\n    do {\r\n        cur = k % 10;\r\n        k = ~~(k / 10); // ~~ 用于下取整\r\n        item = num[pos] ?? 0;\r\n        Addres = (cur + carry + item) % 10;\r\n        carry = ~~((cur + carry + item) / 10);\r\n        ans.unshift(Addres);\r\n        --pos;\r\n    } while( (k || carry) || pos >= 0)\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n---\r\n\r\n- 时间复杂度： `O(n + logk)`  n 为输入数组长度，k为非负整数大小\r\n\r\n- 额外空间复杂度： `O(1)`  \r\n\r\n## 标签\r\n\r\n---\r\n\r\n`数组` , `模拟`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321008","body":"## 思路\n\n---\n\n好多大佬都已经写出最优解了，这里想探究其他的 （更麻烦的😂做法) ，套的通用的BFS模板..\n\n## 代码：JavaScript\n\n---\n\n```JavaScript\nvar shortestToChar = function(s, target) {\n    \n    // BFS 模板\n    const dist = new Array(s.length).fill(Infinity);\n    const q = [];\n\n    for(let i = 0 ; i < s.length ; ++i) {\n        if (s[i] === target) {\n            dist[i] = 0;\n            q.push(i);\n        }\n    }\n\n    while(q.length){\n        const sz = q.length;\n        for(let _ = 0 ; _ < sz ; ++_) {\n            const head = q.shift();\n            if (dist[head] !== target) {\n                if (head + 1 < dist.length && dist[head + 1] > dist[head] + 1) {\n                    dist[head + 1] = dist[head] + 1;\n                    q.push(head + 1);\n                }\n                if (head - 1 >= 0 && dist[head - 1] > dist[head] + 1) {\n                     dist[head - 1] = dist[head] + 1\n                     q.push(head - 1)\n                }\n            }; \n        }\n    }\n\n    return dist;\n};\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度： `O(n^2)` \n\n- 额外空间复杂度： `O(n)`  开了一个队列\n\n## 标签\n\n---\n\n`字符串` , `广度优先遍历`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568209","body":"### 思路：\n\n和链表相加一样，while后面的条件是 || 然后循环里面再去判断\n\n### 代码：\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=len(num)\n        i=n-1\n        res=[]\n        carry=0\n        while i>=0 or k!=0  or carry:\n            temp=0\n            if(i>=0):\n                temp+=num[i]\n                i-=1\n            if(k!=0):\n                temp+=k%10\n                k//=10\n                \n            res.append((temp+carry)%10)\n            carry=(temp+carry)//10\n        return res[::-1]\n```\n\n### 时间复杂度\n\nO(max（n，log(k)）) n为数组长度\n\n拓展一下链表加法\n\n```python\nclass Solution:\n    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n        p=ListNode(0)\n        head=p\n        carry=0\n        while (l1 or l2 or carry):\n            if l1:\n                carry+=l1.val\n                l1=l1.next\n            if l2:\n                carry+=l2.val\n                l2=l2.next\n            p.next=ListNode(carry%10)\n            p=p.next\n            carry=carry//10\n        return head.next\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916568816","body":"## Problem\nhttps://leetcode.com/problems/add-to-array-form-of-integer/\n\n## Notes\n- Cannot solve the problem by converting `num` to int then do the addition and convert it back to int array. Because `1 <= num.length <= 104` and Integer.MAX_VALUE is smaller than that, the conversion or addition will cause overflow.\n- When doing addition, need to consider when the sum is larger than `9`, need to do the `k++` and `sum -= 10` to carry `1`, after `k /= 10`.\n- The length of `num` may be shorter than the length of `k`, the first loop condition should use the length of `num`. Use the second loop to convert the remain of `k`.\n- The length of `num` may be longer than the length of `k`, since `k%10` and `k/10` will be always 0 after `k` becomes 0, so it's ok to use the length of `num` in the first loop.\n- The original length of ArrayList is `10`, and the solution can always add the new digit at index 0 of the List, perhaps using LinkedList as the returned List would have better performance.\n\n## Solution\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k%10;\n             k /= 10;\n            if(sum > 9){\n                k++;\n                sum -= 10;\n            }\n            result.add(0, sum);\n        }\n        while(k > 0){\n            result.add(0, k%10);\n            k /= 10;\n        }\n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: The solution processes each element of `num` and each digit of `k`. So it's O(max(n, `the number of digits of k`)). And the `the number of digits of k` is `logk` (https://brilliant.org/wiki/finding-digits-of-a-number/). So it's O(max(n, logk)) (n is the length of `num`).\n- Space: Except the returned List, the extra space used is O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334085","body":"## Problem\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Notes\n- Scan the input array from left to right, set the distance between each element and the previous seen char `c` to the result array (`pos - i`).\n- Start from index `0`, the initial value of `pos` (the index of the last seen char `c`) is `-n` (`n` is the lenght of input array), so the distance of the elements scanned before the first seen char `c` would be an int greater than `n`. Thus, when scanning from right to left, the new distance would be shorter than it and be adopted.\n- Scan the input array from right to left, the new distance between each element and the previous seen char `c` (`i - pos`) is compared to the current distance, update it with the shorter one.\n- Start from index `pos - 1`, because the distance of the elements on the right side of `pos` won't be updated.\n\n## Solution\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int pos = -n;\n        int[] result = new int[n];\n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = i - pos;\n        }\n        for(int i = pos - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            result[i] = Math.min(result[i], pos - i);\n        }\n        \n        return result;\n    }\n}\n```\n\n## Complexity\n- Time: Scan twice. O(n).\n- Space: The returned array. O(n).","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916569778","body":"### 代码\n```python \nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A_list = [str(i) for i in num ]\n        A_number = int(''.join(A_list))\n        result_number = A_number + k\n        result = [int(i) for i in str(result_number)]\n        return result\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571164","body":"## day 1\n\n简单粗暴的解法：\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for number in num:\n            n = n * 10 + number\n        return [int(ch) for ch in str(k + n)]\n```\n复杂度：`O(n)`\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916571254","body":"# 989.数组形式的整数加法\n\n## 思路：\n\n首先的思路是：\n\n1. 遍历数组整合成整数\n2. 与k值相加\n\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n思考缺点：\n\n1. 对数据不敏感\n2. 思考不完整\n3. 读题不明确就上手做\n\n## 代码段：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n无嵌套,除返回值以外，操作空间为O(1)\n\n- 时间复杂度 O(N)\n- 空间复杂度 O(1)\n\n如果解释有所错误，欢迎朋友指正，感谢！\n\n## ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917322785","body":"# 821. 字符的最短距离\n\n## 思路：\n\n两层循环，i,j表示两个指针，设置一个临时变量，在遍历数组时，找到i-j的最小值更新。\n\n## 代码段：\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList<>();\n        char[] ch = s.toCharArray();\n        int n = ch.length;\n    \n        for(int i = 0; i < n; i++){\n            int t = Integer.MAX_VALUE;\n            if(ch[i] == c){\n                list.add(0);\n                continue;\n            }\n            for(int j = 0; j < n; j++){\n                if(ch[j] == c){\n                    int temp = Math.abs(i-j);\n                    if(temp < t) t = temp;;\n                }\n            }\n            list.add(t);\n        }\n        int[] res = new int[list.size()];\n        int cnt = 0;\n        for(int i : list){\n            res[cnt++] = i;\n        }\n        return res;\n    }\n}\n```\n\n## 复杂度分析：\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916573727","body":"## 思路\r\n- k 添加到末尾\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        \r\n        return res[::-1]\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917053954","body":"## 思路\r\n- 数组正反向遍历\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [inf] * n\r\n\r\n        l = -inf\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                l = i\r\n            res[i] = i - l\r\n        \r\n        r = inf\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                r = i\r\n            res[i] = min(r - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575375","body":"# 思路\n- 把k转数组，变成两个数组相加\n- 生成res数组。长度要比num 和 kArr 最大长度 + 1\n- 个位数相加，添加到res 数组\n- 判断进位carry，返回结果\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  var l1 = num.length - 1;\n  var kArr = String(k).split('');\n  var l2 = kArr.length - 1;\n  var resLen = (l1 > l2 ? l1 : l2) + 1;\n  var res = new Array(resLen + 1).fill(0);\n  var carry = 0;\n\n  while (l1 > -1 || l2 > -1) {\n    var val1 = l1 > -1 ? num[l1] : 0;\n    var val2 = l2 > -1 ? kArr[l2] : 0;\n\n    var sum = val1 + Number(val2) + carry;\n    var carry = Math.floor(sum / 10);\n    res[resLen] = Math.floor(sum % 10);\n\n    resLen--;\n    if (l1 > -1) l1--;\n    if (l2 > -1) l2--;\n  }\n\n  if (carry) {\n    res[resLen] = carry;\n  } else {\n    res.shift();\n  }\n  return res;\n};\n```\n# 复杂度分析\nN是数组nums的长度，K是数字k的长度\n- 时间复杂度  O(max(N,K) + shift) shift 是数组删除第一个元素\n- 空间复杂度 O(max(N,K)+1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916575768","body":"### 思路\n列表转成数值，加上k，然后倒着一位一位加到列表，然后反转列表\n### 代码（Python3）\n```python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        inta = 0\n        for i in A:\n            inta = inta*10 + i\n        inta = inta+K\n        res = []\n        while inta!=0:\n            res.append(inta%10)\n            inta//=10\n        if not res:\n            res.append(0)\n        return res[::-1]\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Toms-BigData":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916577408","body":"# 思路\n将数组中的数字转化为字符拼接成字符串，将字符串转化为int类型与K相加后再次转化为字符串，通过list()和map()函数将字符串拆分成int数组\n# 代码：Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = \"\".join('%s' %id for id in num)\n        num_data = str(int(num_str) + k)\n        return list(map(int,num_data))\n# 时间复杂度\n时间复杂度为O(n)\n空间复杂度为O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330247","body":"# 821. 字符的最短距离\n## 思路：\n建立一个长度等同于s的值全为float('inf')的数组，一个记录上次出现c位置的变量，循环遍历s。\n当第一次出现c时，将所有字符到该字符的距离存入数组。\n当s中再次出现c时，比较从上一个c出现后，后一位的距离到该位置的距离哪个近（因为在上一个位置出现c之前的字符的距离一定小于后面出现c的距离）更新数组\n## Python3代码：\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        distance_list = [float('inf') for _ in range(len(s))]\n        last_char_position = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                for j in range(last_char_position+1,len(distance_list)):\n                    distance_list[j] = abs(j-i) if abs(j-i) < distance_list[j] else distance_list[j]\n        return distance_list\n## 复杂度分析\n时间复杂度：O(N^2)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916579966","body":"# **思路**\n\n从低位开始相加，大于10就进位\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public List<Integer> addToArrayForm(int[] num, int k){\n        List<Integer> res = new ArrayList<Integer>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                //进一位\n                k++;\n                //减去10才是需要的数\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n\n        /**\n         * 如果k位数比数组多\n         */\n        for(; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n\n        //链表反转\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(max(n, logk))，如果n>k，那么复杂度就是O(n)，如果k比n大，那么复杂度就是O(logk)\n\n空间复杂度：O(1)，每次使用的空间都为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333047","body":"# **思路**\n\n左右开弓，计算数组左右两边哪个值小就取哪个，先从左边开始计算得到一个数组，然后再从右边遍历，取最小值\n\n# **代码**\n\n``\n\n```\npublic class Solution {\n\n    public int[] shortestToChar(String s, char c){\n        int len = s.length();\n        int[] ans = new int[len];\n        //因为s.length <= 10 *10 *10 *10\n        int prev = - 10 *10 *10 *10;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = i - prev;\n        }\n\n        prev = 10 *10 *10 *10;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```\n\n\n\n# **复杂度分析**\n\n时间复杂度：O(n)，需要左右遍历，一共两次\n\n空间复杂度：O(n)，new了一个ans数组出来，这个数据占用的大小为n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580190","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        while (k > 0) {\r\n            list.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间复杂度: O(Max(n, k))\r\n* 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917156860","body":"* 正反向遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int k = -s.length();\r\n        \r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) \r\n                k = i;\r\n            \r\n            res[i] = i - k;\r\n        }\r\n        \r\n        for (int i = k; i >= 0; i--) {\r\n            if (s.charAt(i) == c)\r\n                k = i;\r\n            res[i] = Math.min(res[i], k-i);\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"TimmmYang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916580399","body":"## 思路\n从低到高逐位相加。如果k的位数比X多，就继续执行一遍。可以把两个循环合并，给结果单开一个list逆序返回。\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            summ = num[i] + k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num[i] = summ\n        if carry == 1 and k == 0:\n            num.insert(0, 1)\n            return num\n        while k != 0:\n            summ = k % 10 + carry\n            k //= 10\n            carry = 0\n            if summ >= 10:\n                carry = 1\n                summ -= 10\n            num.insert(0, summ)\n        if carry == 1:\n            num.insert(0, 1)\n        return num\n```\n## 复杂度\n时间：O(max(n, log(k)))，n为num长度\n\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351996","body":"# 方法一\r\n## 思路\r\n第一反应的做法，两次遍历，使用额外列表存含有c的index。这样出现了循环嵌套，虽然可以通过但是不够优秀\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        record = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                record.append(i)\r\n        for i in range(len(s)):\r\n            d = len(s)\r\n            for idx in record:\r\n                d = min(abs(i - idx), d)\r\n            res.append(d)\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n时间：O(N^2)\r\n空间：O(N)\r\nN为s长度\r\n\r\n# 方法二\r\n## 思路\r\n使用正反两次遍历，每次存该位置元素离最左（右）边目标的距离，两者取最小值即为答案。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        idx = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                idx = i\r\n            res.append(i - idx)\r\n        idx = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            res[i] = (min(res[i], idx - i))\r\n        return res\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(N)\r\nN为s长度\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnhTom2000":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916581198","body":"## 思路\r\n遍历数组并且拆分k进行诸位相加，过程中注意如果两者的和超过了个位数，需要累计进位。\r\n## Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int i = num.length - 1;\r\n        while( i >= 0 || k > 0){\r\n          if( i >= 0){\r\n          int sum = num[i] + k % 10;\r\n          k/=10;\r\n          if(sum >=10){\r\n            k++;\r\n            sum-=10;\r\n          }\r\n          list.addFirst(sum);\r\n          i--; \r\n        }else {\r\n          list.addFirst(k%10);\r\n          k/=10;\r\n        }\r\n      }\r\n        return list;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：`O(n+logk)`,n为数组长度\r\n空间复杂度：`O(max(n,k))`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326031","body":"## 思路\n\n- 正向遍历一遍，每次遇到目标字符就标记，然后计算非目标字符的距离\n\n- 反向遍历一遍，同上述做法，计算与正向遍历结果最小值更新数组\n\n## 代码\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n      int len = s.length();\n      int res[] = new int[len];\n      int now = Integer.MAX_VALUE;\n      for(int i = 0; i < len; i++){\n        char target = s.charAt(i);\n        if(target == c) now = i;\n        res[i] = Math.abs( i - now);\n      }\n\n      int lNow = Integer.MAX_VALUE;\n      for(int j = len - 1; j >=0;j--){\n        char target = s.charAt(j);\n        if(target == c) lNow = j;\n        res[j] = Math.min(res[j],Math.abs(lNow - j));\n      }\n      return res;\n    }\n}\n```\n\n## 复杂度分析\n\n时间复杂度 : `O(n)`,n为字符串长度\n\n空间复杂度 : `O(n)`\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582098","body":"day  01  989　　数组形式的整数加法\r\n\r\n- 思路：\r\n  1. 遍历数组，取出合成整数\r\n  2. 合成整数与Ｋ求和\r\n  3. 把求和后的整数再反向分解为数组\r\n\r\n- 代码段：\r\n```python\r\n  def add_to_array(arrya,k):\r\n       n = len(arrya)\r\n       x=0\r\n       y =[]\r\n      for i in range(n):\r\n          x = x+ arrya[i] * 10**(n-i-1)\r\n       x = x +k\r\n       if len(x)>n:\r\n          for i in range(len(x)):\r\n              y.append( x//(10**(len(x)-i-1)))\r\n              x = x -y[i]*(10**(len(x)-i-1))\r\n       else:\r\n          for i in range(n):\r\n              y.append( x//(10**(n-i-1)))\r\n              x = x -y[i]*(10**(n-i-1))\r\n      return y\r\n  \r\n\r\n\r\n- 复杂度分析\r\n  1. 时间复杂度 O(N)\r\n  2. 空间复杂度O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917327328","body":"思路：\n\n1.先遍历记录字符c出现的位置。\n\n2.遍历字符S，找到目标字符最近的解\n```python\n    def  distance_character(self,S:str,C:str)->list[int]:\n        x =[]\n        SY = S\n        res = [1000000 for i in range (len(S))]\n        while S.rfind(C)!=-1:\n            x.append(S.rfind(C))\n            S = S[:x[-1]]\n        # 目标字符\n        x.reverse()\n        for i in range(len(SY)):\n            if SY[i]==C:\n                res[i]= 0\n        # 非目标字符，找最近\n            for index in x:\n                dist = abs(index-i)\n                if dist>res[i]: #因为计算了与第一个字符的距离后，只要后面一个比之前的距离大那么后面的都会大\n                    break\n                res[i] = dist\n        return dist\n\n\n\n复杂度分析\n\n- 时间复杂度分析 O（n*k）n是字符串长度，k是字符C出现在字符串内的次数\n- 空间复杂度O（k） k是字符C出现在字符串内的次数\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MonkofEast":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916582275","body":"# Algo\n1. Loop the array in a reversing way.\n   1. **Add current int directly to the current loc**\n   2. **Cal quo and res. Save quo as new int to next iter; save res as current item**\n   > (Optional) Leave the loop if no int should be added\n2. Attach the rest of quo in front of the array\n   >**DO remember to split out the quo since quo might not be single-digit**\n\n# Code\n```py\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # there is a same question for linked list\n        \n        # xrange(start, stop[not included], step) is not a list but a generator\n        for i in range(len(num) - 1, -1, -1):\n            # if reach the highest digit, if still have k, save and add\n            # else, just keep adding\n            num[i] += k\n            # carry along\n            k, num[i] = divmod(num[i], 10)\n            # no carry, leave\n            if not k: break\n        \n        # use map to broadcast for corners like \"[0], 100\"\n        # map(func, iterable), return an iterator\n        if k: num = list(map(int, str(k))) + num\n        return num\n```\n\n# Comp\n> T: O(N)\n> \n>S: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917096987","body":"# 821. Shortest Distance to a Character\n> [Click Me](https://leetcode.com/problems/shortest-distance-to-a-character/)\n## Algo\n0. Greedy\n1. Loop from lft, find the dis to cloest 'c' on the lft\n   > **Should init a float('-inf') for first non 'c's**\n2. Loop from lft, fint the dis to cloest 'c' on the rgt\n   > **Should init a float('-inf') for first non 'c's**\n4. Save the min() from 1 & 2\n   >Can be integrated into stp-2\n\n## Code\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # greedy\n        # init a res list \n        res = []\n        \n        # save previous loc of 'c', use '-inf' for the first non 'c's\n        prev = float('-inf') # S: O(1)\n        \n        # start from left, cal the distance of cloest 'c' on the left, record\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n                res.append(0)\n                continue\n            res.append(i - prev)\n            \n        # reset prev for the first non 'c's\n        prev = float('inf')\n        \n        # start from right, cal the distanc of cloest 'c' on the right, record\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n                continue\n            res[i] = min(res[i], prev - i)\n        return res\n```\n\n## Comp\n### T: O(N)\n### S: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916583583","body":"## 思路\n\n通过算盘模拟大数加法\n\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n  // K 也转换为数组\n  K = K.toString().split('').map(v => +v)\n\n  // 保证A的长度 > K的长度\n  if (A.length < K.length) {\n    [A, K] = [K, A]\n  }\n\n  A.reverse()\n  K.reverse()\n\n\n  let carry = 0\n  for (let i = 0; i < A.length; i++) {\n    // A 长度大于 K, K[i] 可能越界\n    let b = K[i] === undefined ? 0 : K[i]\n    let curSum = A[i] + b + carry\n    A[i] = curSum % 10\n    carry = Math.floor(curSum / 10)\n  }\n\n  // 处理最后的进位\n  if (carry) {\n    A.push(carry)\n  }\n\n  return A.reverse()\n};\n```\n\n+ 时间复杂度: $O(max(n, m)), n 为数组A的长度, m 为数字K转字符后的长度\n+ 空间复杂度: $O(m)$, m 为数字K转字符后的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584126","body":"# 思路\n从右向左遍历数组，并依次取k的最低位进行相加，如果结果大于10，则需要进位。\n\n# Java\n\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        boolean isCarried = false;\n        List<Integer> list = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0 || isCarried){\n            if (i >= 0 && k == 0 && !isCarried){\n                list.add(num[i]);\n                i--;\n                continue;\n            }\n            int val = (i >= 0 ? num[i--] : 0) + k % 10 + (isCarried ? 1 : 0);\n            if (val >= 10) {\n                val %= 10;\n                isCarried = true;\n            }else isCarried = false;\n            list.add(val);\n            k /= 10;\n            \n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n```\n\n# 复杂度分析\n\n时间复杂度：O(max(n, log k)),  n为数组长度\n空间复杂的：O(1) 如果不考虑输出结果占用的空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916584445","body":"### 思路\n一开始看到 1 <= num.length <= 10^4 ，理解成 num 所代表的数最大为 10^4，就用了把 num 转成整数，加上 k, 再转回 arrayform 的方法，结果 num 很长的test case应该是出现overflow了\n而实际上 k 才是最大值比较小的参数，于是，从个位开始一位一位加，形成 arraylist，再反转\n\n### Java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> arrayForm = new ArrayList<>();\n        \n        int p = num.length - 1;\n        while (p >= 0 || k > 0) {\n            if (p >= 0) {\n                k += num[p];\n            }\n            \n            arrayForm.add(k % 10);\n            k = k / 10;\n            p--;\n        }\n        \n        Collections.reverse(arrayForm);\n        return arrayForm;\n   }\n}\n```\n### 复杂度\ntime: O(max(num的长度，k的位数))\nspace: O(max(num的长度，k的位数))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329843","body":"### 思路\n由左向右遍历，记录 c 在 S[i] 左边时的最小距离 \\\n由右向左遍历，记录 S[i] 与 C 的最小距离 (C可能在左，也可能在右）\n\n###代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        // calculate distance from left\n        for (int i = 0; i < n; i ++) {\n            if (s.charAt(i) == c) {\n                prev = i;\n            }\n            result[i] = i - prev;\n        }\n        \n        // calculate min distance\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n - 1; i >= 0; i --) {\n            if (s.charAt(i) == c){\n                prev = i;\n            }\n            result[i] = Math.min(result[i], prev - i);\n        }\n        \n        return result;\n    }\n}\n```\n###复杂度\n时间、空间: O(S.length())","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-SUI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916585903","body":"思路：字符串相加，大位数相加，从后往前算\r\njs\r\n\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586596","body":"## 思路如下\n数组从末尾、数字从个位开始依次累加、最好记得要注意头是否是 1\n## 代码如下\n```js\n  let len = num.length,\n    add = 0,\n    res = [];\n  while (len >= 0 || k > 0) {\n    const num1 = k % 10 || 0;\n    const num2 = num.length ? num.pop() : 0;\n    let sum = num1 + num2 + add;\n    if (sum > 9) {\n      sum %= 10;\n      add = 1;\n    } else add = 0;\n    res.unshift(sum);\n    len--;\n    k = parseInt(k / 10);\n  }\n  if (add) res.unshift(add);\n  return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhang6260":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916586641","body":"## JAVA版本\n\n## 思路：\n\n从数组的最后一位，当然数组的数+进位数，余数就是当前该位置的数，除以10的商便是进位数。（最后遍历完数组还有判断，进位数是否为0的情况，例如为:arr【9,9,9,9】，K为1的情况）\n\n## 代码\n\n> ```\n>    public static int[]fun(int[]arr,int K){\n>    LinkedList<Integer> list=new LinkedList<>();\n>     for(int i=arr.length-1;i>=0;i--){\n>         int temp=arr[i]+K;\n>         if(temp>=10){\n>\n>             list.add(0,temp%10);\n>             K=temp/10;\n>         }else {\n>             list.add(0,temp);\n>             K=0;\n>         }\n>     }\n>     while (K>0){\n>         list.add(K%10);\n>         K=K/10;\n>     }\n>     int[]res=new int[list.size()];\n>     for(int i=0;i<list.size();i++){\n>         res[i]=list.get(i);\n>     }\n>\n>     return  res;\n> }\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917323419","body":"## JAVA版本\n\n## 思路：\n\n分二次遍历数组，从头到的方式进行遍历，找距离每个位置上到该位置最近的左边C的的距离并记录到数组，同理从右到左的方式，找距离每个位置最右边的距离并记录到数组，最后再进行一次遍历，取每次取左右遍历的最小值。\n\n> ```\n> package Ti_911;\n>\n> public class ti_911_2 {\n>     public static void main(String[] args) {\n>         String S=\"loveleetcode\";\n>         char c='e';\n>         int []arr_a=new int[S.length()];\n>         int []arr_b=new int[S.length()];\n>         int count=0;\n>         int isfage=1;\n>         for(int i=0;i<arr_a.length;i++){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_a[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_a[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_a[i]=count;\n>             }\n>         }\n>         isfage=1;\n>         for(int i=arr_a.length-1;i>=0;i--){\n>             if(isfage==1&&S.charAt(i)!=c){\n>                 arr_b[i]=Integer.MAX_VALUE;\n>             }else if(S.charAt(i)==c){\n>                 isfage=0;\n>                 arr_b[i]=0;\n>                 count=0;\n>             }else {\n>                 count++;\n>                 arr_b[i]=count;\n>             }\n>         }\n>         int []res=new int[S.length()];\n>         for(int i=0;i<arr_a.length;i++){\n>             res[i]=Math.min(arr_a[i],arr_b[i]);\n>             System.out.print(res[i]+\" \");\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(N)\n\n__空间复杂度__：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JK1452470209":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916587656","body":"**思路**\r\n从个位往后相加(处理进位情况)并存进list中，最后将list反转\r\n**Java**\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--){\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            ret.add(sum);\r\n        }\r\n        //k>num.length情况\r\n        for (;k > 0;k /= 10){\r\n            ret.add(k % 10);\r\n        }\r\n        Collections.reverse(ret);\r\n        return ret;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 :O(max(num.length,k))\r\n\r\n- 空间复杂度 :O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916589529","body":"### 思路\n\n先算出总和 再转换成列表\n\n### 代码\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in num:\n            temp = temp*10+i\n        temp += k\n        res = []\n        for i in str(temp):\n            res.append(int(i))\n        return res\n```\n\n### 复杂度\n\n- 时间复杂度: O(2N)\n- 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324737","body":"### 思路\n\n前后扫描各一次, 找出最小的差距\n\n### 代码\n\n```python\ndef shortestToChar(self, s: str, c: str) -> List[int]:\n        N = len(s)\n        res = [0 for _ in range (N)]\n        index = float('-inf')\n        for i in range(N):\n            if s[i] ==c:\n                index = i\n            res[i] = abs(index-i)\n        for i in range(N-1,-1,-1):\n            if s[i] ==c:\n                index = i\n            res[i] = min(res[i],abs(index-i))\n        return res\n```\n\n### 复杂度分析\n\n- 时间复杂度: $O(2N)$\n- 空间复杂度: $O(N)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590008","body":"## 思路\n模拟竖式加法\n\n## python3\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        # 将k转化成数组\n        num2 = []\n        strK = str(k)\n        for element in strK:\n            num2.append(element)\n        \n        # 直接相加 \n        res = []\n        addCarry = 0\n        i, j = len(num) - 1, len(num2) - 1\n        while i >= 0 and j >= 0:\n            sum_ = num[i] + int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n            j -= 1\n\n        # 如果多出digit另外处理\n        while i >= 0:\n            sum_ = num[i] + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            i -= 1\n        \n        # 如果多出digit另外处理\n        while j >= 0:\n            sum_ = int(num2[j]) + addCarry\n            digit = sum_ % 10\n            addCarry = sum_ // 10\n            res.append(digit)\n            j -= 1\n\n        # 如果有进位 则加1\n        if addCarry:\n            res.append(1)\n        \n        # 因为append的原因，最后得反转\n        return res[::-1]\n\n        # print(res)\n```\n## 复杂度分析\n* time max(n, logk) n为数组长度\n* space n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917317466","body":"## 思路\n最小数组\n\n## python3\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # 思路一 最小数组\n        # 因为最近的c无非在字母的左边或者右边\n        # 两次遍历 \n        # 第一次从左往右维护prev为c的idx然后求出每个坐标到此prev的距离\n        # 第二此从右往左维护prev 与第一次的值作对比 将较小的存入\n\n        ans = []\n        # 若它左边没有c字母，则idx减去-inf等于inf，配对后面取min\n        prev = float('-inf')\n        # 从前往后 看每个单词与它左边离它最近的c的距离是多少\n        for idx, char in enumerate(s):\n            if char == c:\n                prev = idx\n            ans.append(idx - prev)\n        \n        prev = float('inf')\n        # 从后往前 看每个单词与它右边离它最近的c的距离是多少\n        for idx in range(len(s) - 1,  -1, -1):\n            if s[idx] == c:\n                prev = idx\n            ans[idx] = min(ans[idx], prev - idx)\n        return ans\n```\n## 复杂度分析\n* time n n为s长度\n* space n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590188","body":"# 1. 模拟加法逻辑\r\n\r\n把 `num` 和 `k` 都转换成array， 然后逆序从最后一位开始相加，如果大于10 就向下一位进1\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # res stores the final solution\r\n        res = []\r\n        # reverse order of num\r\n        num = num[::-1]\r\n        # convert k to an arry and reverse the order\r\n        sk = [int(i) for i in str(k)]\r\n        sk = sk[::-1]\r\n\t\t# padding 0s to the shorter array\r\n        if len(num) >= len(sk):\r\n            sk = sk + [0]*(len(num) - len(sk))\r\n        else:\r\n            num = num + [0]*(len(sk) - len(num))\r\n\t\t# t stores the result of floor division \r\n        t = 0\r\n     \r\n        for i in range(len(num)):\r\n            n = num[i]\r\n            k = sk[i]\r\n            # add residual to the final solution\r\n            res = res + [(n+k+t) % 10]\r\n            t = (n+k+t) // 10\r\n            \r\n        # if the last addition results a modulo > 0, add to the end of res\r\n        if t > 0:\r\n            res = res + [1]\r\n        return res[::-1]\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度： O(n)\r\n\r\n# 2. Why bother ¯\\\\_(ツ)_/¯\r\n\r\n使用python 内置函数，把 `num` 转换成 int\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sn = [str(i) for i in num]\r\n        sn = int(''.join(sn))\r\n        res = str(sn+k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917260187","body":"Step 1. 找到s 中所有c 在的位置\n\nStep 2. 如果两个c 中间的间隔为d 并且 d % 2 == 0， 那个它们离最近的c 的距离就是1,2,...,d//2, d//2, ..., 2, 1,如果d 是奇数那么距离就是 1,2,...,d//2, d//2+1,  d//2,  ..., 2, 1\n\nStep 3. 两端分别处理一下\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        def gen_interval(k):\n            if k%2 != 0:\n                l = k//2 + 1\n                return [i for i in range(1, l)] + [i for i in range(l, 0, -1)]\n            else:\n                l = k//2\n                return [i for i in range(1, l+1)] + [i for i in range(l, 0, -1)]\n\n        locs = []\n        for i in range(len(s)):\n            if s[i] == c:\n                locs.append(i)\n        if len(locs) == 0:\n            res = [i for i in range(locs[0],-1,-1)] + [i for i in range(len(s)-1-locs[0])]\n        else:\n            diffs = [locs[i+1] - locs[i] - 1 for i in range(len(locs)-1)]\n            res = [i for i in range(locs[0],0,-1)]\n            for d in diffs:\n                res += ([0] + gen_interval(d))\n            res += [i for i in range(len(s)-locs[-1])]\n        return res\n```\n\nTime: O(n)\n\nSpace: O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590720","body":"# 思路\n从末尾遍历num，取出值和k%10的余相加，然后把k除以10取余，这个时候就判断a的值是不是大于等于10，如果是，就处理a的值和k++，把处理的a放入数组，这里要判断k的边界，如果num循环完了，k还有值，那么就处理k，在加入数组中，最后把数组反转\n```js\nvar addToArrayForm = function (num, k) {\n    let m, res = [];\n    for (let i = num.length - 1; i >= 0; i--) {\n        m = num[i] + k % 10;//取末尾和k除以10的余相加\n        k = Math.floor(k / 10);\n        if (m >= 10) {\n            k++;//相加最大也是19 所以k+1就行\n            m = m - 10;//拿到当前位的值\n        }\n        res.push(m);\n    }\n    //k的长度大于num的长度的情况\n    while (k != 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10);\n    }\n    return res.reverse();\n};\n```\n# 复杂度分析\n- 时间复杂度:O(max(num.length,k))\n- 空间复杂度:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321998","body":"## 思路\r\n先找到c所在的位置的所有下标，然后遍历判断\r\n## 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let arr = [];\r\n    let result = [];\r\n    for(let i = 0;i < s.length; i++){  \r\n        if(s[i]===c){\r\n            arr.push(i)\r\n        }\r\n    }\r\n    for(let i = 0;i < s.length; i++){\r\n        if(s[i]===c){\r\n            result[i] = 0;\r\n            continue\r\n        }\r\n        \r\n        for(let index of arr){\r\n            let res = Math.abs(index-i);\r\n            console.log(result)\r\n            if(res>=result[i]) break;\r\n            result[i] = res;\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n## 复杂度分析\r\n- 时间复杂度:O(n^2)\r\n- 空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590825","body":"## 思路\n在原有num上操作数据，进位在num前面插入数据\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc addToArrayForm(num []int, k int) []int {\n    for i:=len(num)-1;i>=0;i--{\n        val := num[i] + k %10\n        k /= 10\n\n        num[i] = val % 10\n        if val > 9 {\n            if i - 1 >= 0 {\n                num[i-1] += 1\n            } else {\n                num =  append([]int{1}, num...)\n                i++\n            }\n        } \n    }\n\n    for k !=0 {\n        num =  append([]int{k%10}, num...)\n        k /= 10\n    }\n\n    return num\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917315087","body":"\n## 思路\n找到c数据，在回溯找到前面并修改比当前数据大的值双100%\n\n## 代码\n\n- 语言支持：Go\n\nGo Code:\n\n```go\n\nfunc shortestToChar(s string, c byte) []int {\n\tres := make([]int, len(s))\n\tres[0] = 10000\n\tfor i, value := range s {\n\t\tif i != 0 {\n\t\t\tres[i] = res[i-1]+1\n\t\t}\n\t\tif byte(value) == c {\n\t\t\tres[i] = 0\n\t\t\tfor j:= i-1;j>=0;j-- {\n\t\t\t\tif res[j] < i - j {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tres[j] = i - j\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916590955","body":"```javascript\nvar addToArrayForm = function(A, K) {\n    //start from the last Index\n    let flag = A.length - 1\n    //if k <=0 jump out the loop\n    while(K) {\n        // if flag < 0 mean we still have carry left and K is not zero yet\n        if(flag < 0) {\n            //put the carray to the front\n            A.unshift(K % 10)\n        } else {\n            // k plus the last index value\n            K += A[flag]\n            // update the last index value by K % 10,if k is bigger than 9 we only take the units digit(个位数）\n            A[flag] = K % 10\n            //flag mins one for each loop\n            flag--;\n        \n        }\n        \n        K = Math.floor(K / 10)\n        \n    }\n    return A\n}\n// time O(n);\n//space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917049882","body":"<h1>思路</h1>\n两次遍历，第一次从左到右把最近距离更新到res array\n第二次 从右到左遍历，然后把第二次得到的最短距离和第一次相比取最小值\n更新 res array\n\n```javascript\nvar shortestToChar = function(s, c) {\n    //两个循环，设prev 为 INFINITY\n    //第一个循环从左到右，每次在s找到 c 这个字符 就更新 prev = i（c 这个字符的INDEX）\n    // 然后让最近更新的 c 字符 Index 和 当前 字符 INDEX 相减 取绝对值（因为从左到右，不取绝对值会得到负数）\n    let prev = Infinity;\n    let res = [];\n    for(let i =0; i<s.length;i++){\n        if(s[i] === c){\n            prev = i;\n        }\n        res[i] = Math.abs(prev-i);\n    }\n    //第一次循环之后 res 里面的结果，当前数值还没完全正确\n// I I I 0 1 0 0 1 2 3 4  ，I = Infinity\n    \n    // reset prev to INFINITY\n    prev = Infinity;\n    // 第二次循环从右到左， 跟第一次循环步骤一样\n    for(let j = s.length-1; j>=0; j--){\n        if(s[j] === c){\n            prev = j;\n        }\n        // 不同的地方是这里 对比第一次循环和第二次循环得到的值，然后取最小值更新res\n        res[j] = Math.min(res[j],prev-j);\n    }\n    return res;\n};\n\n//time O(n)\n// space O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592720","body":"```ts\nfunction addToArrayForm(arr: number[], k: number): number[] {\n    let n = arr.length - 1\n    const list = []\n    while( n >= 0 || k){\n        k += (arr[n] || 0)\n        list.push(k%10)\n        k = Math.floor(k/10)\n        n--\n    }\n    return list.reverse()\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RocJeMaintiendrai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916592795","body":"## 题目\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/submissions/\n## 思路\n从最低位开始两两相加，如果计算结果大于10，需要进一位，在高一位的计算中加1。需要注意的是k是有可能比num的位数多，不要忽略这种情况。还有就是不能将num转为integer与k相加后再转为数组形式，因为可能会越界。\n## 代码\n``` java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n\t\tfinal int len = num.length;\n\t\tfor(int i = len - 1; i >= 0; i--) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif(sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\t\n\t\t\tres.add(0, sum);\n\t\t}\n\t\tfor(; k > 0; k /= 10) {\n\t\t\tres.add(0, k % 10);\n\t\t}\n\t\treturn res;\n    }\n}\n```\n## 复杂度分析\n#### 时间复杂度\nn为num的长度，k为k的长度，如果k比n小，则时间复杂度为O(n),如果k的长度大于n，则复杂度应为O(k),所以时间复杂度应为O(max(n, k)).\n#### 空间复杂度\n除result外没有开辟新的空间，因此复杂度应为O(1).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349744","body":"## 思路\n新建一个和s长度相同的array，全部填充上最大的长度可能即为s.length（） - 1， 然后遍历s，当遇到c时使用双指针向左右两边扫，初始一个offset变量为0，指针移动一次就加一，如果在array对应的idx的数大于当前offset，则代表该字母离当前c更近，更新为当前的offset。\n## 代码\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        final int len = s.length();\n        int[] res = new int[len];\n        Arrays.fill(res, len - 1);\n        for(int i = 0; i < len; i++) {\n            if(s.charAt(i) == c) {\n                int left = i;\n                int leftOffset = 0;\n                while(left >= 0 && res[left] > leftOffset) {\n                    res[left--] = leftOffset++;\n                }\n                int right = i + 1;\n                int rightOffset = 1;\n                while(right < len && res[right] > rightOffset) {\n                    res[right++] = rightOffset++;\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n## 复杂度分析\n### 时间复杂度\nO(N^2)\n### 空间复杂度\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593071","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int n = A.length;\n        List<Integer> res = new ArrayList<>();  // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n        int i = n - 1, sum = 0, carry = 0;\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n                        \n            sum = x + y + carry;\n            carry = sum / 10;\n            K = K / 10;\n\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321390","body":"```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int n = S.length();\r\n        int[] ans = new int[n];\r\n\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < n; i++){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] =i - prev;\r\n        } \r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            if(S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N）\r\n空间复杂度：O(S) S为字符串长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AstrKing":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916593572","body":"## 思路\n\n~~~bash\n直接从后往前加，然后最低位留对10的余数即可。\n~~~\n\n## 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916595505","body":"# 思路\n\n遍历数组整合成整数\n与k值相加\n刚开始前三个测试样例平安无事，从测4后开始疯狂溢出。\n\n把int 改成Long，短暂解决，测96后，又开始了一轮溢出.....\n\n# 解决方式：\n\n数组的最后一位与k的最后一位相加，注意进位量。\n\n# java\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int n = num.length;\n        for(int i = n-1; i >= 0; i--){\n            //数组最后一个与k的最后一位相加\n            int sum = num[i]+k%10;\n            k /= 10;\n            if(sum >= 10){\n                sum -=10;\n                //进位设置\n                k++;\n            }\n            res.add(sum);\n        }\n        //防止k的位数大于num\n        for(;k >0; k/=10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599149","body":"## 思路：\n\n* 官方题解思路\n* 数组从后往前遍历，数组最后一位与K个位数相加，以此类推\n  * 需要判断相加大于10的情况\n  * 需要判断当k大于数组num时，数组遍历完，k值还有的情况\n  * 最后push进数组，返回时需反转\n\n``` js \n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const numLength = num.length\n  let res = []\n\n  for (let i = numLength - 1; i >= 0; --i) {\n    // 每一位相加\n    let sum = num[i] + k % 10\n    // 得到除去参与相加的数\n    k = Math.floor(k / 10)\n\n    // 如果相加大于9，结果取个位数，十位数给k，参与下一次循环\n    if (sum > 9) {\n      sum -= 10\n      k++\n    }\n    res.push(sum)\n  }\n\n  /**\n   *  如果k的值大于数组num值，还要将剩余的k的每一位push到数组里\n   *  由于上面执行的操作，k会不断减少一位，如果到这里还剩余，说明大于数组num值，所以此次判断条件为k>0\n   *  for(k=k; k>0; k=Math.floor(k/10))\n   */\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10)\n  }\n\n  // 由于前面数组是push，个位数在第一个，所以数组要反转一下\n  res.reverse()\n  return res\n};\n```\n\n## 复杂度分析\n\n* 时间复杂度：O(max(n, log k))，其中n为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Laurence-try":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916599312","body":"### 思路\r\n从k的个位开始，每一位加到num里面，用carry记录进位，并在下一位计算的时候算上carry值并更新carry值。需要对于num和k的长度difference的情况，分别讨论。\r\n### 代码\r\n使用代码: Python3\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num:\r\n            return list(str(k))\r\n        if not k:\r\n            return num\r\n        c = 0\r\n        n_len = len(num)\r\n        pointer = n_len - 1\r\n        res = []\r\n        while pointer >= 0 or k > 0:\r\n            if pointer >= 0:\r\n                k_c = k % 10\r\n                k = k // 10\r\n                new_dig = (num[pointer] + k_c + c) % 10\r\n                c = (num[pointer] + k_c + c) // 10\r\n                num[pointer] = new_dig\r\n                pointer -= 1\r\n            else:\r\n                k = k + c\r\n                k_c = k % 10\r\n                k = k // 10\r\n                res.append(k_c)\r\n                c = 0\r\n        res = res[::-1]\r\n        if c > 0:\r\n            return [c] + num\r\n        else:\r\n            return res + num\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(max(num_len, k_len))， 其中num_len为num的长度， k_len为str(k)的长度\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225738","body":"### 思路\n新建一个数组长度为n (n 是input数组的长度)， 并把里面所有elements设为n。\n正向遍历一遍， 在新建的数组里面更新第一个字母出现以后的所有distance，如果再次遇见字母，distance归0。\n然后在反向遍历一遍，覆盖刚刚新建的数组，同样从第一个字母出现以后开始覆盖，覆盖的条件是此时的distance要小于上一步更新的distance， 同样如果遇见字母，distance归0。\n\n### 代码\n使用语言：Python3\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s) for x in range (len(s))]\n        p = 0\n        count = 0\n        flag = False\n        while p < len(s):\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    res[p] = count\n            p += 1\n        count = 0\n        flag = False\n        p -= 1\n        while p >= 0:\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    if res[p] > count:\n                        res[p] = count\n            p -= 1\n        return res\n```\n***复杂度分析***\n时间复杂度：O(n)\n空间复杂度：O(1), compensate O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600573","body":"### 思路\n-  1、将数组的最后一个元素和k的个位开始相加，\n-  2、大于等于10 就向前进一位（k的前一位 + 1）\n-  3、 重复以上步骤知道数组和k的位数结束\n\n### 代码\n- 语言：Java\n```java\nclass Solution {\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\n    //       2、大于10 就向前进一位（k的前一位 + 1）\n     //        3、 重复以上步骤知道数组和k的位数结束\n    public List<Integer> addToArrayForm(int[] num, int k) {\n     List<Integer> rest = new LinkedList<>();\n    int len = num.length - 1;\n    for(int i = len;i >= 0;i--) {\n        int total = num[i] + k % 10;\n        //取除过后一位的前面的值\n        k /= 10;\n        if(total >= 10) {\n            //大于10，则前面的值需要进1\n            k++;\n            total = total % 10;\n        }\n        rest.add(total);\n    }\n    while(k > 0) {\n        rest.add(k % 10);\n        k /=10;\n    }\n     Collections.reverse(rest);\n     return rest;\n    }\n}\n\n````\n### 复杂度\n- 空间复杂度：O(1)\n- 时间复杂度 O max(num.length, k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gaozizhong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916600638","body":"# 思路\r\n把K从个位数开始分解成单个值与num从个位开始（倒序）相加，存入数组。\r\n要注意K位数高于num的情况。\r\n最后把结果数组进行反转即可得到正确答案。\r\n\r\n# 代码：Go\r\n```\r\nfunc addToArrayForm(num []int, k int) (result []int) {\r\n\tfor  i := len(num) - 1 ; i >= 0 ; i--{\r\n\t\tsum := num[i] + k % 10\r\n\t\tk /= 10\r\n\t\tif sum >= 10{\r\n\t\t\tk ++\r\n\t\t\tsum -= 10\r\n\t\t}\r\n\t\tresult = append(result, sum)\r\n\t}\r\n\tfor ; k > 0; k /= 10 {\r\n\t\tresult = append(result, k % 10)\r\n\t}\r\n\treverse(result)\r\n\treturn result\r\n}\r\n\r\nfunc reverse(result []int) {\r\n\tfor i, n := 0, len(result); i < n/2; i++{\r\n\t\tresult[i], result[n-1-i] = result[n-1-i], result[i]\r\n\t}\r\n}\r\n```\r\n\r\n# 时间复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601021","body":"## <font color=#A0522D>思路</font>\r\n\r\n从数组末尾开始往前遍历，每一位先和 k 相加。\r\n相加的和 %10 就是这一位应有的数值，相加的和 整除10 就是下一位的 k 。\r\n\r\n<font color=red>**注意：**</font>如果数组遍历结束后， k 仍然不为 0 ，那么需要将剩下的 k 加入到数组开头\r\n\r\n## <font color=#A0522D>复杂度</font>\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n## <font color=#A0522D>代码(Python3)</font>\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            k_add_num = num[i] + k\r\n            num[i] = k_add_num % 10\r\n            k = k_add_num // 10\r\n            # 提前退出循环的trick\r\n            if not k:\r\n                break\r\n        \r\n        if k:\r\n            while k:\r\n                num.insert(0, k % 10)\r\n                k = k // 10\r\n        \r\n        return num\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325824","body":"## 思路\n\n先从左到右遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它左侧最近字符c的距离是<font color=red>i - prev</font>。遍历结束后，**ans记录每一个位置距离它左侧字符c的最近距离。**\n\n再从右到左遍历s字符串数组，更新ans数组。记录当前遍历到最新的字符c下标prev。对于ans的第i个位置，它与它右侧最近字符c的距离是<font color=red>**prev - i，从prev - i和已经存放的i - prev中选择小的那个存入ans[i]。**</font>遍历结束后，ans记录每一个位置距离字符c的最近距离。\n\n<font color=red>注意：</font>从左到右遍历时，prev初始化成-inf；从右到左遍历时，prev初始化成inf。\n\n## 复杂度\n\n- 时间复杂度：O(n)，遍历了2遍s字符串\n- 空间复杂度：O(n)，n为ans数组大小\n\n## 代码(Python)\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        prev = float('-inf')\n        # 从左向右遍历\n        for i, char in enumerate(s):\n            if char == c:\n                prev = i\n            ans.append(i - prev)\n        \n        # 从右向左遍历\n        prev = float('inf')\n        for i in range(len(ans)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        \n        return ans\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Francis-xsc":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916601314","body":"### 思路\n\n模拟加法，从个位开始加，如有进位，k--（用变量表示进位有点复杂）\n最后反转\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int>ans;\n        for(int i=len-1;i>=0;--i)\n        {\n            int t=num[i]+(k%10);\n            k/=10;\n            if(t>=10)\n            {\n                t%=10;\n                k++;\n            }\n            ans.push_back(t);\n        }\n        while(k)\n        {\n            ans.push_back(k%10);\n            k/=10;\n        };\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917319149","body":"### 思路\n\n从前到后扫一遍，再从后到前扫一遍，取较小值\n\n### 代码\n\n\n```cpp\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int p=-100000,len=s.length();\n        vector<int> ans(len);\n        for(int i=0;i<len;++i)\n        {\n            if(s[i]==c)\n                p=i;\n            ans[i]=i-p;\n        }\n        p=INT_MAX;\n        for(int i=len-1;i>=0;--i)\n        {\n             if(s[i]==c)\n                p=i;\n            ans[i]=ans[i]<p-i?ans[i]:p-i;\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N =s.len。\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916602214","body":"### 思路\n大数相加 每个位置相加，如果大于9，向前进一位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间： O(n)\n空间： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605114","body":"### 思路\r\n从低位到高位遍历num、k，求和，注意进位。如果 k > A，需将剩余数字转换并插到num前。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if k == 0: return num\r\n        flag = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            k, b = k//10, k%10\r\n            num[i], flag = (num[i] + b + flag)%10, (num[i] + b + flag)//10\r\n        tmp = []\r\n        k += flag\r\n        while k:\r\n            k, n = k//10, k%10\r\n            tmp.append(n)\r\n        return tmp[::-1] + num\r\n```\r\n**复杂度分析**\r\n- 时间：O(max(n, K)) K = k的位数, N = len(num)\r\n- 空间：O(max(1, K-n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605335","body":"### **思路**\r\n- 从k的个位开始，从num最后一位开始加，用carry记录进位\r\n- 在下一位计算的时候算上carry值并更新carry值, k也需要更新。\r\n- 需要处理carry > 0的情况，在高一位的计算中加carry\r\n- 反转结果\r\n\r\n### **代码**\r\n\r\n- 使用代码: Java\r\n\r\n```\r\nclass Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            List<Integer> res = new ArrayList<>();\r\n            if(num == null) return res;\r\n            int carry = 0;\r\n            int size = num.length -1;\r\n            while(k > 0 || size >= 0){\r\n                int curNum = size >= 0? num[size] : 0;\r\n                int curK = k % 10;\r\n                int curSum = curNum + curK + carry;\r\n                int curAdd = curSum % 10;\r\n                carry = curSum / 10;\r\n                size--;\r\n                k = k/10;\r\n                res.add(curAdd);\r\n            }\r\n            if(carry > 0) {\r\n                res.add(carry);\r\n            }\r\n            Collections.reverse(res);\r\n            return res;\r\n        }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n- 时间复杂度：O(max(n, log k))，其中n为数组的长度\r\n- 空间复杂度：O(max(n, log k)。使用的空间为数组和k的最大长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917220140","body":"## 思路 - Array遍历\r\n- 初始化result array.\r\n- 两次遍历\r\n- 第一次从左到右，遇到c，将其右边的依次从 i - pre。 pre不会超过Array的长度\r\n- 第二次从右到左，遇到c，将其左边 i - pre 比较并取min；\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n  public int[] shortestToChar(String S, char C) {\r\n        int n = S.length(), pre = -n, res[] = new int[n];\r\n        for (int i = 0; i < n; i++) {\r\n            if (S.charAt(i) == C) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n        for (int i = pre - 1; i >= 0; i--) {\r\n            if (S.charAt(i) == C)  pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        return res;\r\n    }\r\n }\r\n```\r\n\r\n## 思路 - DP\r\n- Array遍历\r\n- 初始化result array.\r\n- 遍历从左到右，遇到c，设为0，其余设为 size - 1;\r\n- 遍历从左1到右(i = 1)，和前一位（i - 1） + 1比较后取最小值\r\n- 遍历从右1到左（i = size - 2），和前一位（i + 1） + 1比较后取最小值\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int size = s.length();\r\n        int[] res = new int[size];\r\n        for(int i = 0; i < size; i++){\r\n            res[i] = s.charAt(i) == c? 0: size - 1;\r\n        }\r\n\r\n        for (int i = 1; i < size; i++){\r\n            res[i] = Math.min(res[i], res[i - 1] + 1);\r\n        }\r\n\r\n        for (int i = size - 2; i >= 0; i--){\r\n            res[i] = Math.min(res[i], res[i + 1] + 1);\r\n        }\r\n \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度：\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YQYCS":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916605762","body":"### 思路：\r\n        将K逐位分解，加入到A中\r\n### 代码\r\n```\r\nclass Solution:\r\n  def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n### 复杂度分析\r\n        时间复杂度：O（N），需要遍历一遍数组，故为N\r\n        空间复杂度：O（1），不需要额外开辟空间\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916608620","body":"\n#idea: two iterations to add and decompose the num\n# time and space o(N)\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nums = 0\n        length = len(num)\n        \n        for i in range(length):\n            nums += num[i] * (10**(length-1-i))\n        print(nums)\n        nums2= nums+k\n        list1 = []\n        if nums2 == 0:\n            return[0]\n        while nums2:\n            a= nums2%10\n            nums2 //= 10\n            list1.insert(0,a)\n        return list1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917218318","body":"#idea: iterate the string, use dictionary to save the distance and update\r\n```\r\nclass Solution:\r\n\tdef shortestToChar(self, s: str, c: str) -> List[int]:\r\n\t\tdic = {c:[]}\r\n\t\tlens = len(s)\r\n\t\toutput = []\r\n\t\tfor i in range(lens):\r\n\t\t\tif s[i] == c:\r\n\t\t\t\tdic[c].append(i)\r\n\t\tfor i in range(lens):\r\n\t\t\ttemp = [abs(i-k) for k in dic[c]]\r\n\t\t\toutput.append(min(temp))\r\n\t\treturn output\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916610263","body":"## 思路：\n将K先加到数组最后一位，再从后向前遍历数组，依次进位\n## 代码\n```Python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n\n        num[-1] += k\n        for i in range(len(num) - 1, -1, -1):\n            carry, num[i] = divmod(num[i], 10)\n            if i > 0:\n                num[i-1] += carry\n        while carry:\n            num = [carry%10] + num\n            carry = carry//10\n        return num\n```\n## 复杂度分析\n    时间复杂度：O（N），需要遍历一遍数组，故为N\n    空间复杂度：O（1），不需要额外开辟空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917324513","body":"## 思路\nIterate twice - from the left and from the right. We will remember the index of the last char c that we've seen and append the distance to res[]. While interating from right to left, we will calc the distance agian and compare it with the one in res. Smaller ones would be the final results.\n\n## Code\n```Python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        res = []\n        for i, x in enumerate(s):\n            if x == c:\n                prev = i\n            res.append(i - prev)\n            \n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            res[i] = min(res[i], prev - i)\n            \n        return res\n```\n## 复杂度分析\n时间复杂度O（n）\n空间复杂度O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612541","body":"````\nvar addToArrayForm = function(num, k) {\n  let arr = [];\n  while (k !== 0) {\n    arr.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  let res = num.length > arr.length ? num : arr;\n  let i = 1;\n  while (i <= res.length) {\n    let add1 = num.length - i >= 0 ? num[num.length - i] : 0;\n    let add2 = arr.length - i >= 0 ? arr[arr.length - i] : 0;\n    let sum = add1 + add2;\n    if (sum >= 10) {\n      res[res.length - i] = sum % 10;\n      if (res.length - i - 1 >= 0) res[res.length - i - 1] += 1;\n      else res.unshift(1);\n    } else {\n      res[res.length - i] = sum;\n    }\n    i++;\n  }\n  return res;  \n};\n````\n时间复杂度：O(n), n为num和k长度较长的那个\n\n空间复杂度：O(n), n为k的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SnowBallBears":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916612816","body":"## **题目**\n989. Add to Array-Form of Integer\n\n## **思路**\n\nPretty straightforward thoughts, adding up an array and a number, use carry and another array to take care of the all cases.\n\n## **代码**\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        \n        for i in range(len(num)-1,-1,-1):\n            curr = num[i] + k%10 + carry\n            k = k//10\n            carry = curr//10     \n            num[i] = curr % 10\n    \n        k = k + carry\n        prenum = []\n        \n        while(k>0):\n            prenum.insert(0, k%10)\n            k = k//10\n        \n        return prenum + num\n        \n```\n\n## **复杂度**\n\nSpace: O(max(1, K-N))\nTime: O(N + max(0,(K-N)^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917333033","body":"## **题目**\n821. Shortest Distance to a Character\n\n## **思路**\n\nUse two pointers to find the nearest target letter for each letter\n\n## **代码**\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [float('inf')] * n\n        \n        for i in range(n):\n            if s[i] == c:\n                res[i] = 0\n                continue\n            \n            left = right = i\n            while(left>=0):\n                if s[left] == c:\n                    res[i] = min(res[i], abs(left-i))      \n                    break\n                left = left-1\n            \n            while(right<n):\n                if s[right] == c:\n                    res[i] = min(res[i], abs(right-i))\n                    break\n                right = right+1\n        \n        return res\n        \n```\n\n## **复杂度**\n\nSpace: O(N)\nTime: O(N^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BlueRui":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916613826","body":"# Algorithm\nI use a more general approach to handle cases when k is longer than num, and when overflow may happen.\n1. Convert k to an array of digits\n2. Iterate from the lowest digit to highest one to add num[i] and k[i]. Get the sum of num[i], k[i] and carry. Add sum % 10 to list, and set sum / 10 to the new value of carry. End iteration when we reach the length of the shorter one of num and k\n3. Iterate over the remaining length of num or k in the same way. \n\n# Complexity\n* Time complexity: O(max(num.length, k.length)) \n* Space complexity: O(max(num.length, k.length))\n\n# Code\nLanguage: Java\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        char[] kDigits = Integer.toString(k).toCharArray();\n        int[] numK = new int[kDigits.length];\n        for (int i = 0; i < kDigits.length; i++) {\n            numK[i] = kDigits[i] - '0';\n        }        \n        \n        int carry = 0;\n        int index = 0;\n        while (index < num.length && index < numK.length) {\n            int sum = num[num.length - 1 - index] + numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < num.length) {\n            int sum = num[num.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        while (index < numK.length) {\n            int sum = numK[numK.length - 1 - index] + carry;\n            result.add(sum % 10);\n            carry = sum / 10;\n            index++;\n        }\n        \n        if (carry != 0) {\n            result.add(carry);\n        }\n        \n        Collections.reverse(result);\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917180234","body":"# Algorithm\n1. Work through the array from the left to find the closest char c to the right of each char in s.\n2. Then work through the array from the right to find the closest char c to the left of each char in s.\n3. Find the min distance of step 1 and 2.\n4. Step 2 and 3 can be combined.\n\n# Complexity\n* Time Complexity: We are going over the array exactly twice. O(N)\n* Space Complexity: We can use the same output array, so no extra space. O(1)\n\n# Code\nLanguage: Java\n```Java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] result = new int[n];\n        Arrays.fill(result, n);\n        // Find closest c on the right of each char\n        int cur = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur <= i) {\n                result[cur] = i - cur;\n                cur++;\n            }\n        }\n\n        // Update to get the closest c from both sides by comparing left side\n        cur = n - 1;\n        for (int i = n - 1; i >=0; i--) {\n            if (s.charAt(i) != c) {\n                continue;\n            }\n            while (cur >= i) {\n                result[cur] = Math.min(result[cur], cur - i);\n                cur--;\n            }\n        }\n        return result;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916614606","body":"# 思路\n* 从末尾开始遍历数组，最后一位与k最后一位相加，将K除以10取整，有进位加进位，循环\n* 数组遍历完  k还大于0，将k取余放入List, k除以10取整，循环\n* * *\n# 代码\n* 语言：Java\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       LinkedList<Integer> ret = new LinkedList();\n       int index  = 0 ;\n       for(int i = num.length - 1; i >= 0 ; i--){\n          int   sum =  num[i];\n         \n                sum +=  k % 10 + index;\n                 k = k/10;\n          \n          if(sum >= 10){\n              sum =  sum - 10;\n              k++;\n          }\n          ret.addFirst(sum);\n       }\n       while(k > 0){\n           ret.addFirst(k%10);\n           k = k/10;\n       }\n     \n       return ret;\n    }\n}\n```\n* * *\n# 复杂度\n* 时间复杂度O(n)\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328807","body":"# 思路\n1.找出字符串中出现的字符的位置，放入List\n2.遍历字符串，找到List中第一个大于当前位置的数。\n3.如果找到的数位置是List 中下标为0， 新数组的数就是 list[0] - 遍历中的字符串当前位置\n4.如果找到的数位置下比0大， 比较  List 前一个数 和 找到的数， 分别做差求绝对值，取出较小的数。\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n           int strLength =  s.length();\n           int[] res = new int[strLength]; \n           List<Integer> l =  new ArrayList<>();\n           for(int i = 0; i < strLength; i++){\n               char s2c =  s.charAt(i);\n               if(s2c == c){\n                   l.add(i);                 \n               }\n           }\n           for(int i = 0; i<strLength;i++){\n               int j = 0;\n               int num = l.get(j);\n               for(;j < l.size();j++){\n                   if(l.get(j) >= i){\n                       num = l.get(j);\n                       break;\n                   }\n               }\n               if(j == 0){\n                 res[i] = Math.abs(num - i);  \n               }else{\n                 res[i] = Math.min(Math.abs(l.get(j-1) -i),Math.abs(num - i));\n               }             \n           }        \n            return res;\n    }\n}\n```\n# 复杂度\n* 时间复杂度：O(n^2)\n* 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916615519","body":"# Understand:\n```\n1 <= num.length <= 10^4\n0 <= num[i] <= 9\nnum does not contain any leading zeros except for the zero itself.\n1 <= k <= 10^4\n\nmost significant -> least significant digit\n```\n\n# Plan: \n```\ngo backward, track carry and sum for the current digit\nuse LinkedList for result\n```\n\n# Review:\n```\nnum = [9, 9, 9], k = 1 -> 1000\n\n999\n  1\n \n1000\n\nnum = [1], k = 999\n\n  1\n999\n\n\nnum = [1], k = 9\n```\n\n# Evaluate:\n```\nm = num.length, n = number of digits in k, log(10)k\n\nTime: O(max(m, n))\n\nSpace: O(max(m, n)) for the output list\n```\n\n# Code: \n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> sum = new LinkedList<>();\n        int carry = 0, curDigit = 0;\n        \n        for (int i = num.length - 1; i >= 0; i--) {\n            curDigit = k % 10 + num[i] + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        while (k > 0) {\n            curDigit = k % 10 + carry;\n            carry = curDigit / 10;\n            curDigit = curDigit % 10;\n            k /= 10;\n            sum.addFirst(curDigit);\n        }\n        \n        if (carry == 1) {\n            sum.addFirst(carry);\n        }\n        \n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuWF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916616395","body":"- convert num to int\n- add num to k\n- iterate through total by making it a string, add to res list\n- time complexity: O(N), N is the num list length\n- space complexity: O(M), M is the num list length\n\n\n\nCode:\n\n```python\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\n    total = 0\n    index = 0\n    \n    for n in num[::-1]:\n        total += (10 ** index) * n\n        index += 1\n    \n    total += k\n    \n    res = []\n    for digit in str(total):\n        res.append(int(digit))\n    \n    return res\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335074","body":"### 📜Notes:\n\n2 pass solution:\n\n- forward iteration to mark res[i] distance closest to target character on the left\n- backward iteration to mark res[i] distance closest tot target character on the right\n- time: O(N), length of s\n- space: O(N)\n\n\n\n------\n\n\n\n### 💻Code:\n\n```python\n# 2 pass\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # len(s) is 1 bigger than max distance\n        res = [len(s)] * len(s)\n        \n        leftMost = rightMost = -1\n        \n        for i in range(len(s)):\n            if s[i] == c: leftMost = i\n            if leftMost != -1:\n                res[i] = i - leftMost\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: rightMost = i\n            if rightMost != -1:\n                res[i] = min(res[i], rightMost - i)\n        \n        return res\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JoeyChengTor":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916620734","body":"### 思路\n\n从数组最后一位到第一位进行遍历, 每次与 k % 10 和 carry 相加, carry = k // 10\n\n每次加完 i 往前退一位, k // 10\n\n所有数组里的数加完有两种情况\n\n1. k 还有剩余\n2. carry 还有剩余\n\n因为 carry 也是加在 k 的最后一位, 所以 k = k + carry 一起处理\n\n每次向数组前面添加 k % 10, 之后 k 取 k // 10\n\n### 代码\n\n```python\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        # reverse loop through num and add with each digit of k\n        for i in range(len(num) - 1, -1, -1):\n            val = carry + num[i] + k % 10\n            carry, num[i] = val // 10, val % 10\n            k = k // 10\n        \n        # if there's carry or k left need to add to front of array\n        k = carry + k\n        \n        while k > 0:\n            num = [k % 10] + num\n            k = k // 10\n\n        return num\n```\n\n\n\n### 复杂度\n\n时间复杂度: O(n) 遍历数组\n\n空间复杂度: O(1) 不使用额外空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332667","body":"## 思路\n\n先建立 output 数组所有值为最大值 n\n\n正向遍历一次, 每次遇到 c 更新 l 的值为 c 的位置, 如果左边有 c 的话就更新 output 的值为 i - l 即为跟距离最靠近的左边的 c 的距离\n\n反向遍历一次, 每次遇到 c 更新 r 的值为 c 的位置, 如果右边有 c 点话就更新 output 为 min(output, r - j)\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        n = len(s)\n        output = [n for _ in range(n)]\n\n        # forward pass the string s and calculate the distance based on the closest characater c on the left of each item\n        l = None\n        for i, w in enumerate(s):\n            if w == c:\n                output[i] = 0\n                l = i\n            else:\n                if l is not None:\n                    output[i] = i-l\n\n        # backward pass the stirng s and calculate the distance based on closest character c on the right of each item\n        r = None\n        for j in range(n-1, -1, -1):\n            w = s[j]\n            if w == c:\n                output[j] = 0\n                r = j\n            else:\n                if r is not None:\n                    output[j] = min(output[j], r-j)\n\n        return output\n```\n\n## 复杂度\n\n时间复杂度: O(n) 两次遍历都是 O(n) 时间复杂度\n\n空间复杂度: O(1) 常数级空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ForLittleBeauty":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916622948","body":"## 思路\n\n***\n\n将给定的list反转后遍历，遍历的每一位与k的最低位，进位数相加，记录进位，并把个位加入最终的结果数组。之后更新k。有两种情况：\n\n- list遍历完了k还有值，那么后面继续把k没用完的位数加入结果数组，这样总体时间复杂度由logk决定\n- k先到0，list还没遍历完，那么其实继续遍历list，并不需要做任何处理，因为k一直是0，相当于每次把list新的一位添加到最终结果数组后面\n\n最后判断一下进位数是否还有值即可。\n\n***\n\n## 代码\n\n***\n\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        result = []\n        carry = 0\n        for digit in num[::-1]:\n            temp = digit+k%10+carry\n            k=k//10 #下一轮的k值\n            carry = temp//10 #下一轮的进位\n            temp = temp%10 #当前这一位数\n            result.append(temp)\n\n        #如果k还没耗尽的话\n        while k>0:\n            temp = k%10+carry\n            k=k//10\n            carry = temp//10\n            temp = temp%10\n            result.append(temp)\n        \n        #如果进位值还没耗尽的话\n        if carry>0:\n            result.append(carry)\n        \n        return result[::-1]\n```\n\n\n\n***\n\n时间复杂度: O(max(logk,n))\n\n空间复杂度: O(1)\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623473","body":"### **思路**\n\n1. 观察到A最大为10^10000,远超出long上限，因此不可把A转成数字后与k相加再写入结果数组\n2. 模拟手算，使用carry进位\n\n### **关键点**\n\n1. 从整数k中取出倒数第i位数字: k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i)\n2. 循环次数取决于A,k中较大数的位数\n\n### **代码(Java)**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> sumList = new LinkedList<Integer>();\n    Boolean carry = false;\n    int noDigits = Math.max(num.length, Integer.toString(k).length());\n    for (int i = 0; i<noDigits; ++i){\n        int k_digit = k % (int)Math.pow(10, (i+1)) / (int)Math.pow(10, i);\n        int num_digit = i<=num.length-1? num[num.length-1-i]:0;\n\n        int res = carry? k_digit + num_digit + 1 : k_digit + num_digit;\n        if (res>9){\n            res = res - 10;\n            carry = true;\n        }else{\n            carry = false;\n        }\n        sumList.add(0, res);\n    }\n    if (carry) sumList.add(0, 1);\n    return sumList;\n\n}\n```\n\n### **复杂度分析**\n\nm,n为A,k的位数时:\n\n- 时间：O（max(m,n)）\n- 空间：O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916623658","body":"## 思路\n\n1. 当前位 = `(carry + a + b) % 10` \n2. 进位处理： 当前位 % 10\n3. 调整： `k /= 10`  \n4. 最后要判断是否还有进位  `215 + 806 = 1021`  多了一位  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        int i = num.length - 1;\n        int carry = 0, sum = 0;\n        while(i>=0 || k > 0){\n            int a = i>=0 ? num[i] : 0;\n            int b = k!=0 ? k%10: 0;\n\n            //得到和\n            sum = carry + a + b;\n\n            //得到进位\n            carry = sum / 10;\n\n            //得到当前位\n            sum %= 10;\n\n            //调整两个加数\n            k /= 10;\n            i--;\n            ans.add(sum);\n        }\n        if(carry != 0) ans.add(carry);\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(max(n,logk))\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WeilanTao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916628293","body":"### 989 Easy\n\n### 思路\n\n这道题是一个模拟计算的题目。首先想到用一个变量carry来记录进位。获得个位：n%10；获得其他：n/0\n\n用一个while loop 遍历所有--只要`carry` 或 `num[]`或 `k` 没有用完， while loop 就对 carry 进行迭代, 并将此次迭代结果的个位存入结果集合`res`。\n\n在 Java 集合中选择 LinkedList 来储存结果，因为 Java 中 `LinkedList` 提供了接口 `addFirst()`。 LinkedList 在头尾插入复杂度都是O(1)。 若采用ArrayList 则需要调用接口`add(0, nums[i])` 或`Collections.reverse()` ； 相比之下都会降低性能。\n\n### 代码 Java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        int carry = 0;\n        \n        int len = num.length;\n        int i  =len-1;\n\n        LinkedList<Integer> res = new LinkedList<>();\n        \n        while(carry != 0  || k > 0 || i >= 0 ){\n         \n            if(i>=0){\n                carry += num[i];\n                i--;\n            }\n            \n            if(k>0){\n                int a = k%10;\n                carry+=a;\n                k=(k-a)/10;\n            }\n            \n            res.addFirst(carry % 10);\n            carry = carry/10;\n\n        }\n        \n        return res;\n    }\n}\n```\n\nRuntime: 2 ms, faster than 99.68% of Java online submissions for Add to Array-Form of Integer.\n\nMemory Usage: 41.2 MB, less than 35.41% of Java online submissions for Add to Array-Form of Integer.\n\n### 复杂度分析\n\n时间复杂度：O(max(nums[], k)+1) =>O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917345912","body":"### 821. Shortest Distance to a Character Easy\n\n### Idea\n\nThe basic idea of this problem is to find closest matching character `c` at the left and the right of the characters in the string. To do so, we scan the string from the left to right to find the left match; and scan from the right to left to find the right match. We will use pointer `p` to record the latest position update of `c` ; so the distance will be |i-p|. If any right match gives a smaller distance, then the record in the result array will be overwritten by the smaller one.\n\nCorner case: Either scanning from left to right or from right to left can encounter the case that left/right side doesn't have the matching character.\n\n* left side: \n  * When scanning from left to right and when no `c` occurs, the pointer `p` is set as `-s.length()`; so it means no matching character is at the left side and the recorded distance will be big enough to be overwritten by the matching at the right side.\n  * When scanning from right to left, \n    * if there is a matching character at the end of the string, then the pointer is already there as the result of the left-to-right scan. In this case the distance will be `p -  i`;\n    * If there is no matching character at the end of the string, then  `i - p` is negative in this case, which indicates the absence of the right matching. However, the absolute value of `p - i` equals `i - p`, so if we take absolute value, then there no chance for the left match to be overwritten in this case.\n    * So when it is scanning from right to left, we measure the distance by the absolute value.\n\n### Code  Java\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int p = -len;\n        int res[] =  new int[len];\n        \n        for(int i =0; i < len; i++){\n            if(s.charAt(i)==c){\n                p = i;\n            }\n    \n            res[i] = i - p;\n        }\n        \n        \n        for(int i = len-1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                p = i;\n            }    \n            res[i] = Math.min(res[i], Math.abs(p - i));\n        }\n        \n        return res;\n    }\n}\n```\n\n\n\n### Complexity\n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916629214","body":"# 989. Add to Array-Form of Integer\r\n\r\n## Intuition\r\n\r\n1. Start from least significant digit in num and current sum as k.\r\n2. Compute digit sum at each position from right to left.\r\n3. Push least significant digit to the answer array.\r\n4. Shift current sum to right by 1 position.\r\n5. Repeat until all digits in both num and k are processed.\r\n6. Reverse the answer array for the final output.\r\n\r\n## Code\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nconst addToArrayForm = function(num, k) {\r\n  const n = num.length;\r\n  const ans = [];\r\n  let curr = k;\r\n  let i = n - 1;\r\n  while (i >= 0 || curr > 0) {\r\n    if (i >= 0) {\r\n      curr += num[i];\r\n    }\r\n    ans.push(curr % 10);\r\n    curr = ~~(curr / 10);\r\n    i -= 1;\r\n  }\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n## Complexity Analysis\r\n\r\n- Time: O(max(N, K))\r\n- Space: O(max(N, K)) for answer array\r\n- N = len(num)\r\n- K = len(k)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334975","body":"# 821. Shortest Distance to a Character\n\n## Intuition\n\nTwo Pass\n\n1. Iterate from left to right.\n    - Record the distance to the closest *c* on the left side.\n2. Iterate from right to left.\n    - Record the distance to the closest *c* on the right side.\n    - Only update the answer array if closest right is closer than closest left.\n\n## Code\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nconst shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = [];\n  let prev = -Infinity;\n  for (let i = 0; i < n; i++) { // left to right\n    if (s[i] === c) prev = i;\n    ans[i] = i - prev;\n  }\n  prev = Infinity;\n  for (let i = n - 1; i >= 0; i--) { // right to left\n    if (s[i] === c) prev = i;\n    ans[i] = Math.min(ans[i], prev - i);\n  }\n  return ans;\n};\n```\n\n## Complexity Analysis\n\n- Time: O(N)\n- Space: O(N) for answer array\n- N = len(s)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632276","body":"# Day 1 989. Add to Array-Form of Integer\n\n- Problem Link\n  - [989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/submissions/)\n  - Other useful links:\n\n\n- Ideas\n  - convert list to string, then to int, add with k, convert back to list. \n- Complexity: \n  - Time: O(num.length)\n  - Space: O(num.length)\n\n- Code\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_str = ''.join([str(i) for i in num])\n        sum = int(num_str) + k\n        return [int(i) for i in str(sum)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917325775","body":"# Day 2 821. Shortest Distance to a Character\n\n- Problem Link\n  - [821. Shortest Distance to a Character](https://leetcode.com/problems/shortest-distance-to-a-character/submissions/)\n  - Other useful links:\n\n- Ideas\n  - Start from both sides, initiate position index as -len(s), iterate each character in s, update the position index if the character matches c, take absolute diff to find the closest from both sides and choose the smaller one as result.\n\n- Complexity: \n  - Time: O(s.length)\n  - Space: O(s.length)\n\n- Code\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str):\n        result = []\n        #start from left\n        loc = - len(s)\n        for i in range(len(s)):\n            if s[i] ==c:\n                loc = i\n            result.append(i-loc)\n        #then start from right\n        for i in range(len(s))[::-1]:\n            if s[i] ==c:\n                loc = i\n            result[i] = min(result[i], abs(i - loc))\n        return result\n```\n\n- other resources:","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916632424","body":"### 思路\n从后向前（从个位开始）遍历数组num，依次和K相加。\n\n相加的结果：个位数部分（取余）保存在返回结果里；十位之上部分（取模）作为新的K。\n\n当数组全部遍历之后，K不等于0时，将K的每一位插入结果的头部。\n\n生成结果时，每次插入都是0号位，使用LinkedList而不是ArrayList是为了获得更好的插入效率。\n\n### 代码\n\n```java\nclass Solution {\n  public List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new LinkedList<>();\n    for (int i = num.length - 1; i >= 0; i--) {\n      res.add(0, (num[i] + k) % 10);\n      k = (num[i] + k) / 10;\n    }\n    while (k > 0) {\n      res.add(0, k % 10);\n      k /= 10;\n    }\n    return res;\n  }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N), 确切地说是max(N, log10(K))\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343936","body":"### 思路\n\n求解最小路径可以抽象成， MIN（与左侧c的距离，与右侧c的距离）\n\n- 第一遍从左向右遍历，生成每个元素与左侧c的距离\n  - 当没有遇到c时，表示左侧没有c，赋予一个超过最大距离length的值\n- 第二遍从右向左遍历，生成每个元素与右侧c的距离，并与第一遍生成的左侧c距离比较，取最小值。\n  - 第一遍遍历之后，pos保存数组最后一个c的位置\n  - pos之后的元素的右侧不存在c，所以这次遍历只需要从pos-1开始\n\n### 代码\n\n````java\nclass Solution {\n  public int[] shortestToChar(String s, char c) {\n    int length = s.length();\n    int[] res = new int[length];\n    int pos = -length;\n    for (int i = 0; i < length; i++) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = i - pos;\n    }\n    // e.g.\n    // before loop: [length, length, 0, 1, 2, 3(pos-1), 0(pos), 1, 2]\n    // after  loop: [     2,      1, 0, 1, 2, 1       , 0     , 1, 2]\n    for (int i = pos - 1; i >= 0; i--) {\n      if (s.charAt(i) == c) pos = i;\n      res[i] = Math.min(res[i], pos - i);\n    }\n    return res;\n  }\n}\n````\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，两次循环\n- 空间复杂度：O(1)，返回变量之外，没有额外使用空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mahalasu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916633989","body":"### 思路\r\n从后往前遍历，每一位都和k相加取个位，其他位继续与更前面的数字相加。如果遍历一边之后k仍大于0，说明所得结果位数大于num的长度，则将k中所有位的数字变成一个新的数组然后与num进行连接合并。\r\n\r\n##\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for idx in range(len(num) - 1, -1, -1):\r\n            temp = num[idx] + k\r\n            k = temp // 10\r\n            num[idx] = temp % 10\r\n        \r\n        if k:\r\n            return [int(i) for i in str(k)] + num\r\n        else:\r\n            return num\r\n```\r\n##\r\nTime: O(max(n, k))\r\nSpace: O(max(n, k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917257431","body":"## 思路\r\n\r\n### Naive Way\r\n\r\n遍历一遍找出所有的c所在的地方，然后遍历第二遍，将每一个字母与所有c所在的位置进行位置计算，取最短的一个\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        places = []\r\n        result = [float('inf') for _ in range(len(s))]\r\n        \r\n        for idx in range(len(s)):\r\n            if s[idx] == c:\r\n                places.append(idx)\r\n        \r\n        for idx in range(len(s)):\r\n            for cidx in places:\r\n                dist = abs(idx - cidx)\r\n                if abs(idx - cidx) < result[idx]:\r\n                    result[idx] = dist\r\n        \r\n        return result\r\n```\r\n\r\nT：O(MN)\r\nS：O(M)\r\nN为s长度，M为c所在的所有位置的个数\r\n##\r\n\r\n### 正序倒序遍历\r\n\r\n正序遍历得到每个位置到其左侧最近位置的距离，然后倒序遍历得到每个位置到其右侧最近位置的距离\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        length, pos = len(s), float('inf')\r\n        result = [length] * length\r\n        \r\n        for i in list(range(length)) + list(range(length)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            result[i] = min(result[i], abs(i - pos))\r\n        \r\n        return result\r\n```\r\n\r\nT: O(N)\r\nS: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZETAVI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916634607","body":"## 思路\r\n\r\n从Num数组的**右侧开始往左遍历**数组,将遍历到的数**直接与K相加**,相加的结果取**最低位**插入到List输出链表的**头部**\r\n\r\n## 语言\r\n\r\nJava\r\n\r\n## 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        int i;\r\n        for (i = num.length - 1; k > 0 || i >= 0; k /= 10, i--) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            list.add(0, k % 10);\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度:\t$O(max(num.length(),logK))$\r\n\r\n​\t\t\t\t\t\t\t时间复杂度跟输入Num的长度和K的位数有关,又因为List的插入时间复杂度为$O(1)$所以插入可以忽略不计.\r\n\r\n- 额外空间复杂度: $O(1)$\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916642169","body":"### 思路\n把k当作carry 从num的末位开始做加法（做余），不断update k（做除）做为新的carry。最后判断k是否为0，不是为0就用相同方法把k的值放到linkedlist中。\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        for (int i = num.length-1; i>=0; i--) {\n            ans.add(0, (num[i]+k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k > 0) {\n            ans.add(0, k % 10);\n            k = k / 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度\n- 空间只要生成linkedlist就行，所以是O(n)\n- 时间的话，因为一直insert在头部，所以每次是o(1), 做n次，所以也是o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643778","body":"### 思路\r\n\r\n從 Array 尾部開始相加，然後計算剩下的；最後檢查 carryOver 的數字\r\n\r\n### 語言\r\n\r\nJavaScript\r\n\r\n### Code Solution\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    let carryOver = 0;\r\n    const arrK = k.toString().split('');\r\n    let numLen = num.length;\r\n    let kLen = arrK.length;\r\n    if (kLen >= numLen) {\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n                let kNum = Number(arrK[kLen - 1]);\r\n                let sum = kNum + num[j] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n                kLen--;\r\n        }\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n            if (kNum + carryOver >= 10) {\r\n                result.push((kNum + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(kNum + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n    } else {\r\n        for (let i = kLen - 1; i >= 0; i--) {\r\n            let kNum = Number(arrK[i]);\r\n                let sum = kNum + num[numLen - 1] + carryOver;\r\n                if (sum < 10) {\r\n                    result.push(sum);\r\n                    carryOver = 0;\r\n                } else {\r\n                    result.push(sum - 10);\r\n                    carryOver = 1;\r\n                }\r\n            numLen--;\r\n        }\r\n        for (let j = numLen - 1; j >= 0; j--) {\r\n            if (num[j] + carryOver >= 10) {\r\n                result.push((num[j] + carryOver) - 10);\r\n                carryOver = 1;\r\n            } else {\r\n                result.push(num[j] + carryOver);\r\n                carryOver = 0;\r\n            }\r\n        }\r\n\r\n    }\r\n    if (carryOver > 0) {\r\n        result.push(1);\r\n    }\r\n    return result.reverse();\r\n};\r\n```\r\n\r\n### 複雜度分析\r\n\r\n- 時間複雜度 O(N): 沒有 nested for loop， 時間取決於最大的那個 Array length\r\n- 空間複雜度 O(1): 只佔用 result array","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916643891","body":"### 思路\r\n\r\n1. 看到题首先想到，变成整数然后直接加再变成数组返回，然后觉得要数组—整数—数组，要遍历两次，肯定时间复杂度高，**倒是没想到整数超范围，看了大家评论才发现**\r\n2. 然后想到直接从末尾加，满十进位就行，准备开整，看了题目给的返回值类型是list，又给提醒了，数组直接进位会出现溢出的情况\r\n3. List搞起来，跑通了，发现还要逆序，用到了Collections.reverse(list);  成了（相当于又遍历了一次）。用时超过38%的人，肯定不完美\r\n4. 去评论区找到了LinkedList ，直接调用双向链表的addFirst，一次遍历出结果，舒服了。\r\n\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        int over;\r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            // 获取进位值\r\n            over = (num[i] + k) / 10;\r\n            // 得当当前位的值\r\n            num[i] = (num[i] + k) % 10;\r\n            k = over;\r\n            list.addFirst(num[i]);\r\n        }\r\n        // 数组遍历完了，可能进位值是大于0，甚至大于十、百、千，继续进位\r\n        while (k > 0){\r\n            list.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        return list;\r\n    }\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n—  时间复杂度：O(n)，其中n为数组长度。\r\n\r\n—  空间复杂度：O(n)，新建了一个链表","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"A-PolarBear":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916649889","body":"### 思路\n逐位相加，并通过carry保存进位。需要注意K和num的长度关系。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size();\n        int carry = 0;\n        int temp = 0;\n        int i=len-1;\n        while(i>=0||k!=0){\n            int A = i>=0?num[i]:0;\n            temp = A +k%10+carry;\n            carry = temp/10;\n            res.push_back(temp%10);\n            k/=10;\n            i--;\n        }\n        if(carry > 0){\n            res.push_back(carry);\n        }\n        reverse(res.begin(),res.end());\n        return res;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916652757","body":"思路：把 k 分成单个的数位，和 nums 的各个数字从后往前依次两两相加，同时注意进位\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> listK = new LinkedList<>();\r\n        int kIdx = 3;\r\n        while (k > 0) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            listK.add(0, digit);\r\n        }\r\n        int carryOver = 0;\r\n        int i = num.length - 1;\r\n        int j = listK.size() - 1;\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        while (i >= 0 || j >= 0) {\r\n\r\n            int a = i >= 0? num[i]: 0;\r\n            int b = j >= 0? listK.get(j): 0;\r\n\r\n            int curDigit = a + b + carryOver;\r\n\r\n            if (curDigit >= 10) {\r\n                carryOver = 1;\r\n            } else {\r\n                carryOver = 0;\r\n            }\r\n\r\n            result.add(0, curDigit % 10);\r\n             i--;\r\n            j--;\r\n        }\r\n\r\n        if (carryOver == 1) {\r\n            result.add(0, 1);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}`\r\nspace complexity: O(X) X指k的位数\r\ntime complexity: O(max(n, X))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654651","body":"#  989、数组形式的整数加法\n\n## 思路\n\n本质上就是 手动模拟加法的过程\n\n这种思路同时适用于高精度加法\n\n```java\nclass Solution {\n    List<Integer> res = new ArrayList();\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> resTem = new ArrayList<>() ;\n        List<Integer> res  =new ArrayList<>();\n        int i = num.length-1;\n        int tem  = 0;//用来表示进位\n        while(i>=0 || k!=0){\n            if(i>=0){\n                tem+=num[i];\n                i--;\n            }\n            if(k!=0){\n                tem+=(k%10);\n                k= k/10;\n            }\n            resTem.add(tem%10);\n            tem = tem/10;\n        }\n        if(tem>0){\n            resTem.add(tem);\n        }\n        //最后将res 倒叙输出\n        for(int j  = resTem.size()-1;j>=0;j--){\n            res.add(resTem.get(j));\n        }\n        return  res;\n    }\n\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326625","body":"时间复杂度：O(N)\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        //最后一次 c出现的位置，因为要求的是距离最近\n        int pre = Integer.MIN_VALUE/2;\n        //从前往后进行扫描，记住 c 在s[i] 的左边距 距离最近的一次\n        for(int i  = 0;i<s.length();i++){\n           if(s.charAt(i) == c){\n               //说明这就是 c 最后一次出现的位置\n               pre = i;\n           }\n           answer[i] =  i - pre;\n        }\n        pre = Integer.MAX_VALUE/2;\n         for(int i  = s.length()-1;i>=0;i--){\n           if(s.charAt(i) == c){\n               pre = i;\n\n           }\n           answer[i] = Math.min(answer[i],pre-i);\n        }\n\n        return answer;\n\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916654773","body":"### 思路\n1. 看到这道题，想到一个类似的题目，是两个list相加。然后有点类似于merge sort中merge这一步。\n从末尾一直加到开头，如果有一个数组没有到头，就加到结果上。这种方法可以做，但是写起来比较繁琐，因为需要把int转化为数组先。\n2. 因为数据范围限制，没有办法把int 数组转换为数值相加。\n3. 其实每次我们只需要求得该位的余数即可。这样可以直接把k拿来用。使用k和数组每一位求和，取余数，然后除以10。这样就可以得到每一位的余数。\n需要注意如果最后和不为0，需要把每一位取出加入list中。\n\n### 代码\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new LinkedList<>();\n        \n        int sum = k;\n        for (int i = num.length - 1; i >= 0; i--) {\n            sum += num[i];\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        while (sum > 0) {\n            list.add(0, sum % 10);\n            sum /= 10;\n        }\n        \n        return list;\n    }\n}\n```\n\n### 复杂度分析\n时间：O(N)  \n空间：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917340961","body":"### 思路\n1. 暴力解法就是记录所有字符出现的位置。然后对于每个字符，进行距离的比较。\n2. 优化\n    * 剪枝，一旦遇到字符的位置距离当前字符的位置开始增加，就可以跳出循环\n    * 对记录字符位置进行二分，可以把时间复杂度降低到O(nlog)\n\n**最优解**:\n从左到右和从右到左遍历两遍，因为最近距离不是到左边字符最近就是到右边，或者相等。\n如果左边没有遇到所求字符，那么该字符一定是到右边的最近。就设置一个虚拟的值。取length + 1即可。\n\n### 代码\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ret = new int[n];\n        \n        int temp = n + 1;\n        for (int i = 0; i < s.length(); i++) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = temp;\n        }\n        \n        temp = n + 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (c == s.charAt(i)) {\n                temp = 0;\n            } else {\n                temp++;\n            }\n            ret[i] = Math.min(ret[i], temp);\n        }\n        return ret;\n    }\n}\n```\n\n### 复杂度分析\n1. 时间复杂度：O(n)\n2. 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655204","body":"'''\r\nGiven: array form number\r\nreturn: array form number + k \r\n\r\nsample: \r\nnum = [1,2,0,0], k = 34\r\n1200 + 34 = 1234\r\n[1, 2, 3, 4]\r\n\r\n1: \r\ngenerate a integer from array form\r\n[1, 2, 0, 0] => 1200\r\n''\r\n'1'\r\n'12'\r\n'120'\r\n'1200'\r\n\r\n2: k added\r\n1200 + 34 = 1234\r\n\r\n3.\r\nfn generateForm(1234) => return [1, 2, 3, 4]\r\n1234 % 10 = 4 \r\nappend to list res [4]\r\n\r\n1234 // 10 = 123\r\n123 % 10 = 3\r\n[4, 3]\r\n123 // 10 = 12\r\n...\r\n[4, 3, 2]\r\n[4, 3, 2, 1]\r\n\r\n4. \r\nreverse list !!!!\r\n[4, 3, 2, 1] => [1, 2, 3, 4]\r\n\r\ntime O(n)\r\nspace O(n)\r\n\r\n'''\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        if not num: return []\r\n        if k == 0: return num\r\n        \r\n        s = ''\r\n        for ele in num: \r\n            s = s + str(ele)\r\n        newNums = int(s) + k\r\n\r\n        res = self.generateForm(newNums)\r\n        return res[::-1]\r\n    \r\n    def generateForm(self, nums):\r\n        res = []\r\n        while nums:\r\n            digit = nums % 10\r\n            res.append(digit)\r\n            nums = nums // 10\r\n        \r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917352250","body":"'''\nGiven:\ns\nc\nans\nlen\nQuestion:\n0   1   2   3   4   5   6   7   8   9   10  11\nl   o   v   e   l   e   e   t   c   o   d   e\n3   2   1   0   1   0   0   1   2   2   1   0\n\n1 find index of e\n0, 1, 2, 3\n3, 5, 6, 11\n\n0: abs(0 - 3)\n1\n2\n3\n4 min(abs(4-3), abs(4-5))\n\nbisect(7 in [3, 5, 6, 11]), get the index of 3\nneed to comapre index of 2 and 3\n\n7 min(abs(7-6), abs(7 - 11))\n\n0 1 2 3\na a b a\n[2]\n[2, 1, 0, 1]\n\ntime O(nlogn)\n\n'''\n\nfrom collections import deque\nfrom typing import List\nfrom collections import OrderedDict\nfrom collections import defaultdict\nimport functools\nimport heapq\nimport bisect\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s: return []\n        if len(s) == 0: return []\n\n        indexOfTarget = []\n        ans = [0] * len(s)\n\n        for i, ele in enumerate(s): \n            if ele == c:\n                indexOfTarget.append(i)\n        \n        for i, ele in enumerate(s):\n            if ele != c:\n                # 二分法找到index\n                index = bisect.bisect(indexOfTarget, i)\n                if 0 < index < len(indexOfTarget): \n                    ans[i] = min(abs(i - indexOfTarget[index]), abs(i - indexOfTarget[index - 1]))\n                elif index == 0:\n                    ans[i] = abs(i - indexOfTarget[index])\n                    # print(\"---------------------\")\n\n                elif index == len(indexOfTarget):\n                    # print(\"---------------------\")\n                    # print(i)\n                    # print(indexOfTarget[index - 1] )\n                    print(i - indexOfTarget[index - 1])\n\n                    ans[i] = abs(i - indexOfTarget[index - 1])\n                    \n        \n        return ans\n\n\n\n\n\n\n\n\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kirito1017":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916655676","body":"## 思路 \n###### 从最后一位 一位一位往上相加 并考虑是否有carry 如果长短不一样也没关系 判断一下就行。如果while loop结束后考虑下是否要最后append一个carry \n###### 每次都insert到第一个元素\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = nums.length - 1;\n        int carry = 0;\n        while (i >= 0 || k > 0) {\n            int two = k > 0 ? k % 10 : 0;\n            int one = i >= 0 ? nums[i] : 0;\n            int total = two + one + carry;\n            \n            carry = total / 10;\n            res.add(0, total % 10);\n            \n            i--;\n            k = k / 10;\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```\n## 复杂度\n###### 时间复杂度O(n), 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917348006","body":"## 将c的index存到treeset里面 然后iterate每个元素找左右最近的\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        TreeSet<Integer> set = new TreeSet<>();\n        \n        char[] chars = s.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                set.add(i);\n            }\n        }\n        \n        int[] res = new int[s.length()];\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                res[i] = 0;\n            }\n            else {\n                Integer floor = set.floor(i);\n                Integer ceil = set.ceiling(i);\n                if (floor != null && ceil != null) {\n                    res[i] = Math.min(Math.abs(floor - i), Math.abs(ceil - i));\n                }\n                else if (floor!= null) {\n                    res[i] = Math.abs(floor - i);\n                }\n                else if (ceil != null) {\n                    res[i] = Math.abs(ceil - i);\n                }\n            }\n        }\n        \n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FullStackH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916657808","body":"# 思路\n逐位相加，carry保存进位\n\n# 代码\n\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n\n# 复杂度\n时间复杂度O(n)\n空间复杂度O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916659493","body":"```js\nvar addToArrayForm = function (num, k) {\n  let idx = num.length - 1;\n  let c = 0;\n  while (c || k) {\n    let curK = k % 10;\n    let curNum = idx >= 0 ? num[idx] : 0;\n    let sum = c + curK + curNum;\n    c = Math.floor(sum / 10);\n    sum %= 10;\n    if (idx >= 0) {\n      num[idx--] = sum;\n    } else {\n      num.unshift(sum);\n    }\n    k = Math.floor(k / 10);\n  }\n  return num;\n};\n```\n\n时间：O(N)\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916661368","body":"```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let newArr = []\r\n    let numK = String(k).split('')\r\n    let maxLen = Math.max(num.length, numK.length)\r\n    let flag = 0\r\n    let cur = 0\r\n    while (cur < maxLen) {\r\n        console.log(cur)\r\n        if (num[cur] === undefined) {\r\n            num.unshift(0)\r\n        }\r\n        if (numK[cur] === undefined) {\r\n            numK.unshift(0)\r\n        } else {\r\n            numK[cur] = Number(numK[cur])\r\n        }\r\n        cur++\r\n    }\r\n    for (let i = maxLen - 1; i >= 0; i--) {\r\n         let n = num[i] + numK[i] + flag\r\n        flag = n >= 10 ? 1 : 0\r\n        n = n >= 10 ? n - 10 : n\r\n        newArr.unshift(n)\r\n    }\r\n    if (flag === 1) {\r\n        newArr.unshift(1)\r\n    }\r\n    return newArr\r\n};\r\n```\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KennethAlgol":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916664966","body":"思路: 将整个加数 k加入数组表示的数的最低位\n\n    class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<Integer>();\n            int n = num.length;\n            for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n                if (i >= 0) {\n                    k += num[i];\n                }\n                res.add(k % 10);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Richard-LYF":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916665554","body":"def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n=0\n        for i in range(len(num)):\n            n=n*10+num[i]\n        n=str(n+k)\n        out=[]\n        for i in n:\n            out.append(int(i))\n        return out\n\n分享一个自己的思路，代码比较短，容易理解，但是好像用时和内存消耗没有很优秀\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338500","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        a=[]\n        p=[]\n        for i in range(len(s)):\n            if s[i]==c:\n                p.append(i)\n        for i in range(len(s)):\n            k=[]\n            for j in p:\n                k.append(abs(j-i))\n            a.append(min(k))\n        return a\n        \n        #time complx   O(n)\n        #space complx  O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916667562","body":"\n## 题目地址()\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n\n## 题目描述\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            list.add(k % 10);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916671424","body":"# 思路\n\n- 从末尾开始循环逐个相加，把结果存到一个数组里\n- 返回 翻转的数组\n\n# 代码 js\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  let len = num.length,\n    res = [],\n    next = 0,\n    ks = k.toString().split('').map(Number),\n    klen = ks.length,\n    maxlen = len > klen ? len : klen\n\n  for (let i = 0; i < maxlen; i++) {\n    let cur = num[len - 1 - i] || 0,\n      kcur = ks[klen - 1 - i] || 0\n\n    cur = cur + kcur + next\n    next = parseInt(cur / 10)\n    cur = cur % 10\n\n    res.push(cur)\n  }\n\n  if (next > 0) {\n    res.push(next)\n  }\n\n  return res.reverse()\n}\n```\n\n# 复杂度分析\n\n- 时间复杂度：O(n) 数组的长度\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52HzEcho":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916675882","body":"#### 思路：类型转换\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n    return String(BigInt(num.join('')) + BigInt(k)).split('')\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676513","body":"地位到高位逐位相加，最后的时候需要判断是否溢出\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n var addToArrayForm = function(num, k) {\n    let res = []\n    let n = num.length\n    for(let i=n-1;i >=0; i--){\n        let sum = num[i]+ k%10\n        k = Math.floor(k/10)\n        if(sum>=10){\n            k++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n\tfor(; k>0;k= Math.floor(k/10)){\n\t\tres.push(k%10)\n\t}\n    res.reverse()\n    return res\n};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916676823","body":"### 思路\n\n```markdown\n1.由低位到高位逐位相加\n2.进行取余和整数除法\n3.判断进位是否大于0\n```\n\n### 代码(CPP)\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> array;\n\n        for(int i = num.size()-1;i >= 0;i --){\n            int r = num[i] + k;\n            array.push_back(r % 10);\n            k = r / 10;\n        }\n        //判断进位值\n        while(k > 0){\n            array.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(array.begin(),array.end());\n        return array;\n    }\n};\n```\n\n#### 复杂度分析\n\n$$\n时间复杂度：O(n)\n$$\n\n$$\n空间复杂度：O(n)\n$$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HondryTravis":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916681677","body":"## 思路\r\n\r\n已知 k 不是 bigint 的情况下\r\n\r\n1. 通过对 k 不断累加 nums 的低位来维护 k\r\n2. 通过对 k 不断求模得到当前位，不断求商得到进位，维护 k 即可\r\n\r\n### 代码[javascirpt] Q & A\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const { floor } = Math\r\n  const n = num.length, ret = []\r\n\r\n  let i = n - 1\r\n\r\n  while (i >= 0 || k) {\r\n      // 出现 undefined 就要进位默认值 0\r\n      // num: [0], k = 23\r\n      k += (num[i] || 0)\r\n      ret.push(k % 10)\r\n      k = floor(k / 10)\r\n      i--\r\n  }\r\n\r\n  return ret.reverse()\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916682817","body":"### 思路\n\n- 列表转换为整数\n- 数字相加\n- 数字拆分成列表\n\n### 代码 （Python）\n\n~~~python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        if num == [0] and k == 0: return [0] \n        x = 0\n        out = []\n        for i in num:\n            x = x*10 + i \n        x += k\n        while x > 0:\n            out.append(x % 10)\n            x //= 10\n        return out[::-1]\n~~~\n\n### 复杂度\n\nTime: $O(n)$\n\nSpace: $O(n)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683150","body":"**思路:**\n\nNumber和String的类型转换\n\n\n**代码：JavaScript**\n\n\n```\nconst addToArrayForm = (numArr, k) => {\n    if (numArr.length < 1) return [];\n​\n    //convert numArr to string integer\n    let numArrString = numArr.join('');\n  // convert the string integer into number\n    let num = BigInt(numArrString)+BigInt(k);\n​\n  //convert the number to array of strings\n    let strArr = num.toString().split('');\n  \n  //convert it back to integer\n    return strArr.map(i=>parseInt(i));\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917347554","body":"```javascript\n\nconst shortestToChar = (S, C) => {\n    let cIndices = [];\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) cIndices.push(i);\n    }\n    //console.log('cIndices is: ', cIndices);\n​\n    let result = Array(S.length).fill(Infinity);\n​\n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === C) {\n            result[i] = 0;\n            continue;\n        }\n​\n        for (const cIndex of cIndices) {\n            const dist = Math.abs(cIndex - i);\n            //console.log(`i is ${i} and cIndex is ${cIndex} dist is ${dist}`);\n​\n            if (dist >= result[i]) break;\n​\n            result[i] = dist;\n            //console.log('result is ', result);\n        }\n    }\n    return result;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916683771","body":"# 思路\n\n数组变为整数，求和，变为数组\n变整数 int(), 'sep'.join(str)\n变数组[int()]\n遍历数组 for item in list\n\n# 代码\n\n```python\nclass Solution(object):\ndef addToArrayForm(self, num, k):\n\"\"\"\n:type num: List[int]\n:type k: int\n:rtype: List[int]\n\"\"\"\np = int(''.join(str(item) for item in num)) # num为int array，需2str\nsum = p+k\nreturn [int(i) for i in str(sum)]\n```\n\n# 复杂度\n\n\n时间复杂度：O(n)\n空间复杂度：O(n)\n空间复杂度用来估量程序运行时占用的临时空间大小，此问题中，占用内存取决于数组长度\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916689310","body":"# 思路\r\n参考题解\r\n从低位到高位计算，将数组低位与K值求和依次得到末位进行前向插入得到result。\r\n考虑k值太大，K值高位需再同一处理插入result\r\n# 代码\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        vector<int> result;\r\n        for (int i = A.size() - 1; i >= 0; i --) {\r\n            int num = A[i];\r\n            K += num; //得到末位和\r\n            int remind = K % 10;\r\n            result.insert(result.begin(), remind);  \r\n            K /= 10;\r\n        }\r\n        if (K) {\r\n            while (K > 9) { //如果K 比较大，那么此时还需要把K循环放进去\r\n                int remind = K % 10;\r\n                result.insert(result.begin(), remind);\r\n                K /= 10;\r\n            }\r\n            result.insert(result.begin(), K);\r\n        }\r\n        return result;\r\n\r\n    }\r\n}; \r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n )\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916690979","body":"### 思路\n\n逐位相加，从最低位加到最高位，若是大于10，进位\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >= 0;i--){\n            int sum  = num[i] + k%10;\n            k/=10;\n            if(sum >=10){\n                k++;\n                sum -=10;\n            }\n            res.add(sum);\n        }\n        while(k > 0){\n            res.add(k%10);\n            k/=10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(maxlength(num,k))$\n- 空间复杂度 $O(1)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917318050","body":"### 思路\n\n官方题解\n\n从左向右遍历，记录等于c的位置prev，答案就是abs（i- prev）;\n\n从右向左遍历,   记录等于c的位置prev，答案就是abs（prev- i）。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N  = s.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE/2;\n        for(int i = 0;i < N;i++){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] =Math.abs( i - prev);\n        }\n        prev = Integer.MIN_VALUE/2;\n        for(int i = N-1;i >=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],Math.abs(prev-i));\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度 $O(N)$\n- 空间复杂度 $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916691806","body":"### 思路\r\n---\r\n从低位往高位做加法，为避免最后结果需要反转，可选用LinkedList存储数字。\r\n\r\n### 代码\r\n---\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int leng = num.length - 1;\r\n\r\n        while (leng >= 0 || k != 0) {\r\n\r\n            if (leng >= 0) {\r\n                k += num[leng];\r\n                leng--;\r\n            }\r\n\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n---\r\nTime: O(max(N, K)), 由数组num长度和数字k的位数两者中的较大值决定\r\n\r\nSpace: O(1), 在原数组中操作，没有额外开销\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916699491","body":"## 题目名称\n\n**989. 数组形式的整数加法**\n\n\n### 题目思路\n\n1.将 数字型数组 -> 字符串型数组  \n2.将数组中的字符串拼接, 用eval函数取出字符串中的数字 和 k 取和, 然后转为字符串  \n3.将字符串 -> 数字型的数组\n\n### code for python\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_str = [str(i) for i in num]\n        final_str = str(eval(\"\".join(list_str)) + k)\n        return [int(j) for j in final_str]\n\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinMing-Gu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700002","body":"【思路】\r\n要注意给定的数组位数过大时，数据大小超出整型数据范围。\r\n【代码】\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k)\r\n    {\r\n        int n = num.size();\r\n        long long a;\r\n        long long b = 0;\r\n        for(int i = 1; i <= n; i++)\r\n        {\r\n            double m = pow(10, n - i);\r\n            a = num[i - 1] * m;\r\n            b = b + a;\r\n        }\r\n        cout << b << endl;\r\n        cout << k << endl;\r\n        long long c = b + k;\r\n        cout << c << endl;\r\n        num.clear();\r\n        vector<int> rnum;\r\n        while(1)\r\n        {\r\n            if(c >= 10)\r\n            {\r\n                long long d = c % 10;\r\n                rnum.push_back(d);\r\n                c = c - d;\r\n                c = c / 10;\r\n            }\r\n            if(c < 10)\r\n            {\r\n                rnum.push_back(c);\r\n                break;\r\n            }\r\n        }\r\n        vector<int>::reverse_iterator riter;\r\n        for (riter = rnum.rbegin(); riter != rnum.rend(); riter++)\r\n            num.push_back(*riter);\r\n        for(auto it = num.begin(); it != num.end(); it++)\r\n            cout << *it << endl;\r\n        return num;\r\n        // reverse(rnum.begin(), rnum.end());\r\n        // for(auto it = rnum.begin(); it != rnum.end(); it++)\r\n        //     cout << *it << endl;\r\n        // return rnum;\r\n    }\r\n};\r\n```\r\n【复杂度】\r\n\r\n【参考】\r\nhttps://www.cnblogs.com/vranger/p/3502885.html","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bingbinxu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916700923","body":"**思路**\n将整数K作为移动的部分，不断与A的最后一位叠加，从而更新数组\n注意点：边界条件存在A>=K,和A<K的情况\n**代码**\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len = num.size()-1;\n        while(len>=0)\n        {\n            k = k + num[len];\n            num[len] = k % 10;\n            k = k / 10;\n            len--;\n        }\n        while(k>0)\n        {\n            num.insert(num.begin(),0);\n            num[0] = k % 10;\n            k = k /10;\n        }\n        return num;       \n    }\n};\n```\n**复杂度**\n时间复杂度O（N+max（0，K-N））\nwhile函数遍历N遍，若K超过N，还需要遍历K-N遍\n空间复杂度O（N+max（0，K-N））","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339824","body":" **思路**\n 先找出数组s中含有c的字符下标\n 循环找出每个字符对应的c的下标距离，求出最短距离\n **代码**\n class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> cp;        \n        int len = s.size();\n        vector<int> sp; \n        for(int i = 0; i < len; i++)\n        {\n            if (s[i]== c)\n            {\n                cp.push_back(i);\n            }          \n        }\n       for(int i = 0; i < len; i++)\n        {\n            sp.push_back(abs(i -cp[0]));\n            for (int j =1; j < cp.size(); j ++)\n            {\n                int a = abs(i -cp[j]);\n                if(sp[i] > a)\n                {\n                    sp[i] = a;\n                }\n            }\n        }      \n       return sp;\n    }\n};\n **复杂度分析**\n 时间复杂度 循环遍历找出c，为O（N）；循环算距离O（N*K），K为s中含有c的个数\n 空间复杂度 O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916703356","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n**思路：**\n\n1. 尝试了转整数进行相加后再次转回数组，遇到了越界问题。\n2. 按位相加\n\n**Java代码**\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<>();\n       for(int i = num.length-1; i >= 0 || k > 0 ; i--){\n           if(i >=0 ){\n               k = k + num[i];\n           }\n           res.add(0,  k % 10);\n           k = k / 10;\n       }\n       return res;\n    }\n```\n\n时间复杂度：*O(max(n,k)*n)*\n\n空间复杂度：*O(1)*\n\n优化：\n\n1.res尾插入，在返回前进行reverse\n\n时间复杂度：O(max(*n*,*k*))\n\n2.使用LinkedList\n\n时间复杂度：O(max(*n*,*k*))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zhi22":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916705363","body":"# 题目名称：989. 数组形式的整数加法\n## 题目链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/\n## 思路\n1. 将k转成和num格式一致的数组\n2. 从后向前将两个数组按位相加，并将结果保存至一个新建的数组的末尾，并用变量保存是否进位\n3. 将新建数组逆转并返回\n## 代码\n* python3\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k_str = str(k)\n        k_arr = []\n        for ch in k_str:\n            k_arr.append(int(ch))\n        addOne = 0\n        ret = []\n        while num or k_arr or addOne:\n            ret.append(0)\n            if k_arr:\n                ret[-1] += k_arr[-1]\n                k_arr.pop()\n            if num:\n                ret[-1] += num[-1]\n                num.pop()\n            ret[-1] += addOne\n            addOne = 1 if ret[-1] > 9 else 0\n            ret[-1] %= 10\n        ret.reverse()\n        return ret\n```\n## 算法复杂度\n- 时间：O(N)\n- 空间：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916708579","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n思路主要体现在加法模板：\r\n1. 和 = A的当前位 + B的当前位 + 进位\r\n2. 当前值 = 和 % 10\r\n3. 进位 = 和 / 10\r\n4. 循环条件： A/B所有位都遍历完成\r\n5. 最后检查一次进位，若不为0，则需要单独加一位\r\n\r\n## 代码\r\n```java\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        int sum = 0;\r\n        while (i >= 0 || k > 0) {\r\n            int n = i >= 0 ? num[i] : 0;\r\n            int m = k > 0 ? k % 10 : 0;\r\n            k = k/10;\r\n            i--;\r\n\r\n            sum = n + m + carry;\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n## 复杂度分析\r\n**复杂度为O(N)**\r\nwhile循环的复杂度为  `O(n + m)`  \r\n最后反转复杂度为 `O(x/2)` \r\n综合起来算法复杂度为O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916714070","body":"### 思路\r\n两数和按位相加的思路\r\n### js代码\r\n```JavaScript\r\n    let n = num.length-1,carry=0,res=[]\r\n    while(n>=0||k!=0){\r\n        const a = n>=0?num[n]:0\r\n        const b = k!=0?k%10:0\r\n        const sum = a+b+carry\r\n        carry = Math.floor(sum / 10)\r\n        res.push(sum%10)\r\n        n--\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GReyQT":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916716466","body":"## 思路\r\n直接在数组中相加，标记进位符号，对进位处进行处理\r\n\r\n\r\n## cpp\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        bool up = false;    //进位标识符\r\n\r\n        vector<int> numk;\r\n        while (k > 0)\r\n        {\r\n            numk.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(numk.begin(), numk.end());  //逆转，尾部为个位数\r\n\r\n        vector<int> res;\r\n        num.size() >= numk.size() ? res = num: (res = numk,numk=num);\r\n\r\n        for (auto it = res.rbegin(); it != res.rend(); ++it)    //从个位开始相加\r\n        {\r\n            if (up)\r\n            {\r\n                *(it - 1) %= 10;\r\n                if ((*it += 1) >= 10)\r\n                {\r\n                    up = true;\r\n                }\r\n                else\r\n                {\r\n                    up = false;\r\n                }\r\n                \r\n            }\r\n\r\n            if (numk.size() > 0)\r\n            {\r\n                if ((*it += numk.back()) >= 10) \r\n                {\r\n                    up = true;\r\n                }\r\n\r\n                numk.pop_back();        //尾出\r\n            }\r\n\r\n        }\r\n\r\n\r\n        if (up) //表示头部需要进位\r\n        {\r\n            reverse(res.begin(), res.end());    //将头部置尾\r\n\r\n            auto it = res.end()-1;\r\n\r\n            *it %= 10;  //求余\r\n\r\n            res.push_back(1);   //尾插\r\n\r\n            reverse(res.begin(), res.end());    //恢复\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度分析\r\n-     时间复杂度：O(n + logk +reverse的长度 )，其中 n 为数组的长度；k以10为底的对数操作次数，来自于reverse的时间消耗\r\n-     空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916722801","body":"## 思路\n\n-\t从后往前加，记录进位，注意 k > n 的情况\n\n\n## 代码\n\n\n```\nvector<int> addToArrayForm_0(vector<int> &num, int k)\n{\n    vector<int> res;\n    // 从后往前加，记录进位\n    int flag = 0;\n    int i = num.size() - 1;\n    while(k || (i >= 0))\n    {\n        int tmp;\n        if (i >= 0)\n            tmp = num[i] + k % 10 + flag;\n        else\n        {\n            tmp = k % 10 + flag;\n        }\n        k = k / 10;\n        if(tmp > 9)\n        {\n            tmp = tmp % 10;\n            flag = 1;\n        }\n        else\n        {\n            flag = 0;\n        }\n        res.push_back(tmp);\n        i--;\n    }\n    if (flag)\n        res.push_back(1);\n\n    for (int i = 0; i < res.size() / 2; i++)\n    {\n        int tmp;\n        tmp = res[i];\n        res[i] = res[res.size() - i - 1];\n        res[res.size() - i - 1] = tmp;\n    }\n    return res;\n}\n\n```\n-\t时间复杂度: O(N)，空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huangxuang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916726896","body":"# 题目：[989. 数组形式的整数加法]([https://leetcode.com/problems/add-to-array-form-of-integer/](https://leetcode.com/problems/add-to-array-form-of-integer/))\r\n\r\n### 思路\r\n\r\n- 如果转换成int在相加会越界\r\n- 先转换成 array 然后再用array 相加\r\n- 今天来不及了，明天改进一下，直接用arry 和数字相加\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        \r\n        //convert K to array type\r\n        ArrayList k_array = intToArray(k);\r\n        //add two arry together and return \r\n        return arraySum (num, k_array);\r\n    }\r\n    \r\n    private ArrayList<Integer> intToArray(int k) {\r\n        ArrayList <Integer> res = new ArrayList();\r\n        if (k == 0) {\r\n            res.add(0);\r\n            return res;\r\n        }\r\n        while (k > 0) {\r\n            int reminder = k % 10;\r\n            res.add(reminder);\r\n            k /= 10;\r\n        }\r\n        //reverse \r\n        ArrayList<Integer> reversed = new ArrayList();\r\n        for (int i = res.size() - 1; i >= 0; i--) {\r\n            reversed.add(res.get(i));\r\n        }\r\n        \r\n        return reversed;\r\n    }\r\n    \r\n    private ArrayList<Integer> arraySum(int[] num, ArrayList<Integer> x) {\r\n        ArrayList<Integer> res = new ArrayList();\r\n        int N = num.length; \r\n        int L = x.size();\r\n        int carray = 0;\r\n        for (int i = 0; i < Math.min(N, L); i++) {\r\n            int sum = num[N - 1 - i] + x.get(L -1 -i)+ carray;\r\n            res.add(sum % 10);\r\n            carray = sum / 10;\r\n            //carray = sum > 9 ? 1 :0;          \r\n        }\r\n        // add all other numbers directly, count carray in \r\n        if (N > L) {\r\n            //num[N - L - 1]  += carray;\r\n            for (int i = N - L - 1; i >= 0; i--) {\r\n                int sum = num[i] + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        } \r\n        if (N < L) {\r\n            for (int i = L - N - 1; i >= 0; i--) {\r\n                int sum =  x.get(i) + carray;\r\n                res.add(sum % 10);\r\n                carray = sum / 10;\r\n            }\r\n        }      \r\n        if (carray == 1) {\r\n            res.add(1);\r\n        }\r\n    \r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n        \r\n    } \r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- \r\n\r\n### attention！\r\n\r\n**int 是2进制的32bit, 10位十进制的数，long是64位，20位10进制的数**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Wu-zonglin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916730474","body":"### 思路\n数据类型转换\n### 代码\n~~~ python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        sum = int(''.join(map(str, num)))+k\n        return list(map(int,str(sum)))\n~~~\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JAYWX":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916738912","body":"# 思路\nK与num转化为列表  \n准备一个接收列表\n\n两列表同时从末尾往前根据索引取值  \n两值相加的结果c,  \n\n如果 c大于等于10,  \n十位用sum记录，为前一位计算做记录\n\n如果 c小于10，  \nsum记得清零\n\nc的个位加入接收列表\n\n注：循环结束记得把不为0的sum加入接收列表\n\n接收列表末尾为结果首位，最后把列表reverse一次\n\n\n# 代码\n```python\nfrom typing import List\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        A = num\n        a_len = len(A)\n        B = list(int(i) for i in str(k))\n        b_len = len(B)\n        big_num = max(a_len, b_len)\n\n        sum = 0\n        index_sum = 0\n        res = []\n        for i in range(big_num):\n            index_sum -= 1\n            a = 0 if a_len < abs(index_sum) else A[index_sum]\n            b = 0 if b_len < abs(index_sum) else B[index_sum]\n            c = a + b + sum\n            if c >= 10:\n                sum = c // 10 % 10\n                c = c // 1 % 10\n            else:\n                sum = 0\n            res.append(c)\n\n        if sum:\n            res.append(sum)\n\n        res.reverse()\n        return res\n```\n## 复杂度分析\n令 n 为数组长度。\n\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351718","body":"# 思路\n找到所有c字符在s列表的索引, 放入一个列表 c_index_lst\n变量start和变量end表示在c_index_lst中的索引，\n根据s中的索引值i，与start和end做减法取绝对值，找到最小值，加入结果集res，\n当最小值为0时，start和end往前进一位，即start, end = end, end + 1，\n注意c_index_lst索引的边界值\n\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_index_lst = []\n        _x = 0\n        for i in s:\n            if i == c:\n                c_index_lst.append(_x)\n            _x += 1\n\n        start = float('-inf')\n        c_index = 0\n        end = c_index_lst[c_index]\n        index = 0\n        res = []\n        for i in s:\n            c = min(abs(start - index), abs(end - index))\n            print(c)\n            res.append(c)\n            if c == 0:\n                start = end\n                if c_index + 1 < len(c_index_lst):\n                    c_index += 1\n                end = c_index_lst[c_index]\n            index += 1\n\n        return res\n```\n## 复杂度分析\n时间复杂度：$O(n)$  \n空间复杂度：$O(n)$  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916747421","body":"```CPP\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916756192","body":"时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```java\r\n    /**\r\n     * 先前试图抖机灵将数组转换为数字然后加k再转回来\r\n     * 结果分分钟被测试用例[9,9,9,9,9,9,9,9,9,9]教做人\r\n     * 数组越界，只能乖乖按位相加了哎~~~\r\n     * 技巧：线性表从左向右增长使用Array，从右向左增长使用LinkedList::addFirst\r\n     * 这样就不必使用stack倒来倒去\r\n     */\r\n    class Solution {\r\n        public List<Integer> addToArrayForm(int[] num, int k) {\r\n            if (num.length == 0) {\r\n                return numToList(k);\r\n            }\r\n            LinkedList<Integer> result = new LinkedList<>();\r\n            int carry = 0;\r\n            int size = num.length;\r\n            LinkedList<Integer> kNum = numToList(k);\r\n            while (!kNum.isEmpty()) {\r\n                if (size > 0) {\r\n                    int x = kNum.pollLast() + num[size - 1];\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                    size--;\r\n                } else {\r\n                    int x = kNum.pollLast();\r\n                    result.addFirst((x + carry) % 10);\r\n                    carry = (x + carry) / 10;\r\n                }\r\n            }\r\n            while (size > 0) {\r\n                int x = num[size - 1];\r\n                result.addFirst((x + carry) % 10);\r\n                carry = (x + carry) / 10;\r\n                size--;\r\n            }\r\n            if (carry > 0) {\r\n                result.addFirst(1);\r\n            }\r\n            return result;\r\n        }\r\n\r\n        private LinkedList<Integer> numToList(int num) {\r\n            LinkedList<Integer> list = new LinkedList<>();\r\n            while (num / 10 > 0) {\r\n                list.addFirst(num % 10);\r\n                num = num / 10;\r\n            }\r\n            list.addFirst(num % 10);\r\n            return list;\r\n        }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HouHao1998":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916760585","body":" public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> sumList =new ArrayList<>();\n    \tif(num.length==1&&num[0]==0&&k==0){\n\t\t\tsumList.add(0);\n    \t\treturn sumList;\n\t\t}\n\t\tList<Integer> kList =new ArrayList<>();\n\t\twhile (k/10!=0){\n\t\t\tkList.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tkList.add(k%10);\n\t\tint nl =num.length;\n\t\tint[] num2 = new int[nl];\n\t\tfor (int a:num) {\n\t\t\tnum2[--nl]=a;\n\t\t}\n\t\tnl =num.length-1;\n\t\tint kl =kList.size()-1;\n\t\tint go =0;\n\t\tint sun =0;\n\t\tint[] sum;\n\t\tsum =new int[Math.max(nl,kl)+2];\n\t\tfor (int i = 0; i <= Math.max(nl,kl); i++) {\n\t\t\tif(i<=nl&&i<=kl){\n\t\t\t\tsun = kList.get(i)+num2[i]+go;\n\t\t\t}else {\n\t\t\t\tsun = nl>kl?num2[i]+go:kList.get(i)+go;\n\t\t\t}\n\t\t\tsum[i]=sun%10;\n\t\t\tgo=sun/10;\n\t\t}\n\t\tif(go!=0){\n\t\t\tsum[sum.length-1]= go;\n\t\t}\n\n\t\tboolean a= true;\n\t\tfor (int i = sum.length-1; i >=0; i--) {\n\t\t\tif(sum[i]==0&&a){\n\t\t\t\tcontinue;\n\t\t\t}else {\n\t\t\t\ta=false;\n\t\t\t}\n\t\t\tsumList.add(sum[i]);\n\t\t}\n\treturn sumList;\n    }\n## 思路\n把数字变成倒叙数组，数组也直接倒叙，进位相加，再次倒叙\n复杂度分析\n\n数字或数组最长为n\n复杂度O（N）\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AruSeito":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916761326","body":"## 思路\r\n将k拆成数组，按照竖式相加的方式进行每位相加，如果相加和大于等于10，那么当前位取10的余数，前一位进1。如果是最后一位大于10，要在前面进行补加一位。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  let kArray = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((kNum) => Number(kNum));\r\n  let flag = false;\r\n  const maxLength = Math.max(num.length, kArray.length);\r\n  while (kArray.length < maxLength) kArray.unshift(0);\r\n  while (num.length < maxLength) num.unshift(0);\r\n  for (let i = maxLength - 1; i >= 0; i--) {\r\n    let tmpSum = num[i] + kArray[i];\r\n    if (tmpSum >= 10) {\r\n      if (i - 1 < 0) {\r\n        flag = true;\r\n        kArray.unshift(0);\r\n      }\r\n      kArray[i - 1 < 0 ? i : i - 1] += 1;\r\n      tmpSum = tmpSum % 10;\r\n    }\r\n    kArray[flag ? i + 1 : i] = tmpSum;\r\n  }\r\n\r\n  return kArray;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(3m-n+Max(m,n))$ m代表k的位数，n代表num的长度，对k进行拆分的时候split是一个m，map又一个m，再两个位数补全的时候是|m-n|\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917343698","body":"## 思路\r\n暴力法：直接遍历一遍，把出现过的每个索引存起来。然后再遍历s，计算出每个字符跟每个索引的差值，将最小值放到结果里。\r\n\r\n## 代码\r\n\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    let index = [],res=[],i=0;\r\n    for(let i = 0 ; i < s.length;i++){\r\n        if(s[i] === c){\r\n            index.push(i);\r\n        }\r\n    }\r\n    for(let i = 0 ; i < s.length;i++){\r\n        let tmp = Number.MAX_SAFE_INTEGER\r\n        for(let j = 0 ; j <index.length;j++){\r\n            tmp = Math.min(tmp,Math.abs(index[j]-i))\r\n        }\r\n        res.push(tmp)\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n时间复杂度： O（N）；\r\n空间复杂度：O（N）；其实是O（2N）？？？最坏的时候index里把每个字符的索引都存了，再加上结果值，N足够大的时候常数就被省略了。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BreezePython":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916762658","body":"## 思路\r\n\r\n数学题…\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k) :\r\n        n = reduce(lambda x, y: x * 10 + y, num) + k\r\n        return [0] if n == 0 else [int(i) for i in str(n)]\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917021301","body":"## 思路\n1. 既然我们需要找到最短距离，那么首先应该获取到该字符在字符串 s 中的所有下标位置。\n2. 使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组arr中。\n3. 初始化指针p，指向arr的0位置\n4. 创建 ret 数组，长度为len(s)\n5. 再次遍历s的过程中，我们需要判断当满足以下两点条件时，指针 p 右移一位\n   1. p小于arr最大下标\n   2. 前下标i 到 p + 1的绝对距离比到 p 的绝对距离小\n6. 每次将 p - i 的绝对距离添加至 ret[i] 中\n7. 最终返回ret即可\n\n## 代码\n**Python:**\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ret, p, arr = [], 0, [i for i in range(len(s)) if s[i] == c]\n        for i, j in enumerate(s):\n            if p < len(arr) - 1 and abs(arr[p] - i) > abs(arr[p + 1] - i):\n                p += 1\n            ret.append(abs(arr[p] - i))\n        return ret\n```\n**Java:**\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n```\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HZHENGZHI":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916763651","body":"**思路** \n模拟手算加法过程。当两数之和小于10，则直接加入到list中，当遇到两数之和大于10的时候，需要将1带入进行运算\n\n**代码**\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> linkedList=new LinkedList<>();\n        int temp=0;\n        for (int i = num.length-1; i >=0; i--) {\n            temp=k%10;\n            k=k/10;\n            if(num[i]+temp>=10)\n            {\n                k++;\n                linkedList.addFirst((temp+num[i])%10);\n            }\n            else\n            {\n                linkedList.addFirst(temp+num[i]);\n            }\n            if(i==0)\n            {\n                while (k!=0)\n                {\n                    temp=k%10;\n                    k=k/10;\n                    linkedList.addFirst(temp);\n                }\n            }\n        }\n        return linkedList;\n    }\n```\n**复杂度分析**\nn为num长度，m为k的长度\n+ 空间复杂度$O(n)$\n+ 空间复杂度$O(max(n,m-n))$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917309006","body":"**思路**\n每一次都查找到距离当前字符最近的字符c的位置，进行相减处理。当减到自己为0后，查找下一个字符c所在位置\n**代码**\n```java\npublic int[] shortestToChar(String s, char c) {\n        int []ans=new int[s.length()];\n        char chars[]=s.toCharArray();\n        int j=0;\n        int temp=0;\n        for (int i = 0; i < chars.length; i++) {\n            while (j<chars.length &&chars[j]!=c  )\n            {\n                j++;\n            }\n            if(i-j!=0)\n            {\n                if(j<chars.length && chars[temp]==c &&chars[j]==c)\n                {\n                    ans[i]=Math.min(Math.abs(temp-i),Math.abs(j-i));\n\n                }\n                else if(j<chars.length && chars[j]==c)\n                {\n                    ans[i]=Math.abs(i-j);\n                }\n                else if(chars[temp]==c)\n                {\n                    ans[i]=Math.abs(temp-i);\n                }\n            }\n            if(i-j==0)\n            {\n                ans[i]=0;\n                temp=j;\n                j++;\n            }\n        }\n        return ans;\n    }\n```\n**复杂度**\n+ 空间复杂度$O(n)$\n+ 时间复杂度$O(n*m)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916766187","body":"## 思路\n\n从个位开始，向高位加\n\n## 关键点\n\n- \n\n## 代码\n\n- \n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        int carry = 0;\n        List<Integer> list = new ArrayList<>();\n        while(i>=0 || k > 0){\n            int sum = 0;\n            int num1 = i>=0? num[i] : 0;\n            int num2 = k>0? k%10 : 0;\n            sum = num1 + num2 + carry;\n            carry = sum / 10;\n            list.add(sum % 10);\n            i--; k/=10;\n        }\n        if(carry != 0) list.add(carry);\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916768752","body":"# 思路\n类型转换+数位迭代计算\n\n# 代码\n``` python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:    \n        a_ = ''\n        for i in num:\n            a_ += str(i)\n        a_ = ''.join(a_)\n        sum_result = int(a_) + k\n        \n        res_array = []\n        while(sum_result>0):\n            res_array.insert(0, sum_result%10)\n            sum_result = sum_result // 10\n        if len(res_array) == 0:\n            res_array.append(0)\n        return res_array    \n```\n\n# 复杂度分析\n* 时间复杂度O(N)\n* 空间复杂度O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BpointA":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916771959","body":"### 思路\n模拟竖式的运算。首先将两个数转化为长度相同的数组，再从末位向前计算，依次进位。\n### python3代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        add=[int(i) for i in str(k)]\n        if len(add)>len(num):\n            a=[0]+add\n            b=[0]*(len(add)-len(num)+1)+num\n        else:\n            a=[0]+num\n            b=[0]*(len(num)-len(add)+1)+add\n        res=[0]*len(a)\n        for i in range(len(a)-1,0,-1):\n            k=a[i]+b[i]+res[i]\n            res[i]=k%10\n            res[i-1]=k//10\n        if res[0]==0:\n            return res[1:]\n        return res\n```\n### 复杂度\n时间复杂度：O(n) n为较长数组的长度\n\n空间复杂度：O(n)  n为答案数组的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917035360","body":"### 思路\n分别遍历两次数组。\n第一次从右向左遍历，记录s每个字母与最近的c的距离。第二次从左向右遍历，同步将距离更新为左右中较小的距离。\n\n### python3代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res=[len(s)]*len(s)\n        temp=len(s)\n        for i in range(len(s)-1,-1,-1):\n            if s[i]!=c and temp==len(s):\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=temp-i\n        temp=-1\n        for i in range(len(s)):\n            if s[i]!=c and temp==-1:\n                continue\n            elif s[i]==c:\n                temp=i\n                res[i]=0\n            else:\n                res[i]=min(res[i],i-temp)\n        return res                              \n```\n### 复杂度分析\n时间复杂度：O(n) 其中n为数组长度，具体时间复杂度为O(2n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916776310","body":"\n\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 思路\n模仿加法计算过程，通过商和余数完成进位\n\njs里没整型数据，需要Math.floor()向下取整，要不然`/`得到的是小数\n\n## 关键点\n有几个边界条件要考虑\n\n1. 输入[0] 23 或者  [0],10000---》数组短，数据长，不能在数组结束就跳出循环\n\n```javascript\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n```\n2. 输入 [2,1,5],806   ---》最高位有进位，不能跳出循环\n\n```javascript\n if (carry) res.push(carry)\n```\n3. 循环的条件是：(i >=0 || K != 0)，K不为零用来处理数组短的情况\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(A, K) {\n    const res = []\n    let i = A.length - 1, carry = 0\n    while (i >=0 || K != 0) {\n        //处理边界条件\n        const x = i >= 0 ? A[i] : 0\n        const y = K != 0 ? K % 10 : 0\n\n        const sum = x + y + carry\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10)\n\n        i--\n        K = Math.floor(K / 10)\n    }\n    //处理最高位进位\n    if (carry) res.push(carry)\n    return res.reverse()\n};\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351193","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 思路\n\n### 自己的版本\n\n很简单的做法，三个指针\n\nindex ：定位字符\n\nfront：字符前或空\n\nend：字符后一个或空\n\n通过判断`s[index]`, 's[front]', 's[end]' 是否和 c相同即可，相同push进abs坐标\n\n\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n//  match 返回所有index 直接用+- min 计算\nvar shortestToChar = function(s, c) {\n    let index = 0;\n    let front = index +1;\n    let end = index - 1;\n    let answer = [];\n    let len  = s.length - 1;\n    while(index <= len ){\n    let head = s[front]?s[front]:'';\n    let tail = s[end]?s[end]:'';\n    if( s[index] ===c){\n        answer.push(0);\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( head === c){\n        answer.push( Math.abs(front-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else if( tail === c){\n        answer.push(Math.abs(end-index));\n        index++;\n        front = index +1;\n        end = index - 1;\n    }else{\n        front++;\n        end--;\n    }\n    }\n    return answer\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916798881","body":"# 思路\nJavaScript api解决\n\n# 代码\n```javascript\nvar addToArrayForm = function (num, k) {\n    return (BigInt(num.join(\"\")) + BigInt(k)).toString().split('')\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916799914","body":"#### 链接：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n#### 思路：\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/jian-dan-yi-dong-javacpythonjs-pei-yang-a8ofe\n\n数组从右往左遍历每一个元素（i--)；\n\n整数每次个位数用到后去掉；\n\n用carry记录进位；\n\n反转结果集；\n\n#### 题解：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int carry = 0;\n        int l1 = num.length -1 ;\n\n        while(l1 >= 0 || k != 0){\n            int x = l1 < 0 ? 0 : num[l1];\n            int y = k == 0 ? 0 : k % 10;\n\n            int sum = x + y + carry;\n            res.add(sum % 10);\n            carry = sum / 10;\n\n            l1--;\n            k = k / 10;\n        }\n        if(carry != 0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\n```\n\n\n\n\n\n\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916802793","body":"# 思路\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\n\n# 代码\njavascript\n\n```javascript\n/*\n * @lc app=leetcode.cn id=989 lang=javascript\n *\n * [989] 数组形式的整数加法\n */\n\n// @lc code=start\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const kArr = (k + '').split('')\n  let temp = 0\n  const ret = []\n  let i = num.length - 1\n  let j = kArr.length - 1\n  while(i >= 0 || j >= 0) {\n    const sum = (num[i] || 0) + parseInt(kArr[j] || 0) + temp\n    ret.unshift(sum % 10)\n    temp = parseInt(sum / 10)\n    i--\n    j--\n  }\n  if (temp) {\n    ret.unshift(temp)\n  }\n\n  return ret\n};\n// @lc code=end\n\n```\n\n# 复杂度分析\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\n空间复杂度：O(max(n, log k))。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"OASans":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916809316","body":"### 思路\n逐位相加，直接加到num里面。如果加后大于10则在k上进行调整\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k % 10\n            if num[i] >= 10:\n                k = k // 10 + num[i] // 10\n                num[i] = num[i] % 10\n            else:\n                k = k // 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n```\n### 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916817098","body":"# 思路\n\n从末位开始将数组和k的每一位相加，若大于10则在下一步运算中进一位，ArrayList添加这些数字，最后反转。\n\n# 代码\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> arr = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            arr.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            arr.add(k % 10);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916818186","body":"思路\n1. 当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n2.AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n伪代码\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n    和 = A 的当前位 + B 的当前位 + 进位carry\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n    判断还有进位吗；\n\n代码\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize) {\n    int* res = malloc(sizeof(int) * fmax(10, numSize + 1));\n    *returnSize = 0;\n    for (int i = numSize - 1; i >= 0; --i) {\n        int sum = num[i] + k % 10;\n        k /= 10;\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for (; k > 0; k /= 10) {\n        res[(*returnSize)++] = k % 10;\n    }\n    for (int i = 0; i < (*returnSize) / 2; i++) {\n        int tmp = res[i];\n        res[i] = res[(*returnSize) - 1 - i];\n        res[(*returnSize) - 1 - i] = tmp;\n    }\n    return res;\n}\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrAx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916825233","body":"# 思路\r\n\r\n将数组从低位到高位加到k上,最后反转\r\n\r\n# 代码\r\n\r\n语言支持:java\r\n\r\n```java\r\nclass Solution {`\r\n\r\n  public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n​    List<Integer> res = new ArrayList<>();\r\n\r\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\r\n\r\n​      if(i>=0){\r\n\r\n​        k+=num[i];\r\n\r\n​      }\r\n\r\n​      res.add(k%10);\r\n\r\n​    }\r\n\r\n​    Collections.reverse(res);\r\n\r\n​    return res;\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度  O(max(n,log k)) , n为数组长度\r\n\r\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"L-mx-wq":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916826948","body":"思路:逐位相加，大于10加到下一位\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\n复杂度分析\n时间复杂度：O(max⁡(n,logk))\n其中 n 为数组的长度。\n空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Okkband":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916827469","body":"### 思路\r\n面向测试用例的编程\r\n\r\n``` CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        int cnt = 0;\r\n        int pre = 0;\r\n        int tmp = 0;\r\n        while(k / 10 || k % 10 || cnt < n){\r\n            cnt += 1;\r\n            if (cnt > n){\r\n                tmp = pre + 0 + k % 10;\r\n            } else {\r\n                tmp = pre + num[n - cnt] + k % 10;\r\n            }\r\n            k /= 10;\r\n            pre = 0;\r\n            if (tmp >= 10){\r\n                pre = 1;\r\n                tmp -= 10;\r\n            }\r\n            if (cnt > n){\r\n                num.insert(num.begin(), tmp);\r\n            } else {\r\n                num[n - cnt]  = tmp;\r\n            }\r\n            \r\n        }\r\n        if (pre == 1) num.insert(num.begin(), 1);\r\n        return num;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度\r\nO(n, m), 其中n, 为num的长度，m为k的位数\r\n#### 空间复杂度\r\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916830080","body":"# 思路\r\n从后往前遍历数组，同时取出非负整数的个位数，与其相加，传入新的数组中\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> result = new LinkedList<>();\r\n        int temp = 0;\r\n        for(int i = num.length - 1; i >= 0; i--){\r\n            temp = k%10;\r\n            k = k/10;\r\n            if(num[i] + temp >= 10){\r\n                k++;\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n            else{\r\n                result.addFirst((num[i] + temp) % 10);\r\n            }\r\n\r\n            if(i == 0){\r\n                while(k != 0){\r\n                    temp = k % 10;\r\n                    k = k / 10;\r\n                    result.addFirst(temp);\r\n                     \r\n                }\r\n            }\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\nO(max(m,n))\r\n\r\n# 空间复杂度\r\nO(max(m,n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916836424","body":"## 题目\n\n989. [数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n提取数组的数字，加K，加完后转为string，将string拆分为list填充\n\n### code\n\n```python\nA = [9,9,9,9,9,9,9,9,9,9]\nK = 1\n\nA_sum=0\nfor i in range(len(A)):\n  A_part=A[i]*10**(len(A)-i-1)\n  A_sum=A_sum+A_part\n\nprint(A_sum)\n\nak=A_sum+K\nlist1=[]\nak_s=str(ak)\nfor j in range(len(ak_s)):\n  list1.append(int(ak_s[j]))\n\nprint(ak_s)\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(max(m,n))\n\n+ 空间复杂度\n\n  O(max(m,n))\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917048782","body":"## 题目\n\n[821字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 思路\n\n正则化匹配符合要求的index，对原数组的每个索引与匹配好的数组索引做差，取绝对值后的min即为该索引到目标字符的最小距离\n\n### code\n\n```python\nimport re\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        f=re.finditer(c[0],s)\n\n        s_index=[]\n        for i in f:\n            s_index.append(i.span()[0])\n        print(s_index)\n\n        index1=range(len(s))\n        index2=[]\n        dis_min=float(\"inf\")\n        for j in index1:\n            for k in s_index:\n                dis_min=min(dis_min,abs(k-j))\n            index2.append(dis_min)\n            dis_min=float(\"inf\")\n\n        return index2\n```\n\n### 复杂度\n\n+ 时间复杂度\n\n  O(m*n)\n\n+ 空间复杂度\n\n  O(m*n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916838767","body":"#### 思路\n因为是数据形式的相加，那么首先考虑因为LinkedList的add的时间复杂度是1，AyyayList的add的时间复杂度是N，所以此处选用LinkedList，\n然后以数组的下标作为循环的条件，每次给传入的int值除以10来去除最后一位数，当坐标i>=0时，加上k和10取余的值，通过LinkedList的add(int index, E element)方法插入到链表头\n最后返回即可\n#### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new LinkedList<Integer>();\n        int n = A.length;\n        for (int i = n - 1; i >= 0 || K > 0; --i, K /= 10) {\n            if (i >= 0) {\n                K += A[i];\n            }\n            res.add(0,K % 10);\n        }\n        return res;\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"EggEggLiu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916840372","body":"# 思路\n取num和k的低位，逐级相加\n\n# 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ret;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            ret.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ret.push_back(k % 10);\n        }\n        reverse(ret.begin(), ret.end());\n        return ret;\n    }\n};\n```\n\n# 复杂度分析\n时间O(max(n, logk))\n\n空间O(max(n, logk))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinSkyrim":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916845902","body":"## 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        left = int(''.join(list(map(str, num))))\n        return [int(i) for i in str(left+k)]\n\n```\n## 复杂度\n时间复杂度 O(n)   \n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916862006","body":"## 思路\nlist→string→int→list\n## 代码\nclass Solution:\n\n       def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n\n             n = len(A)\n\n             x = 0\n\n             for i in range(n):\n\n                  x = x + A[i] * (10**(n-i-1))\n\n             return str(x+k)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916863413","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int carry = 0;\n        List<Integer> ans = new ArrayList();\n        while(k !=0 || i >= 0){\n            //int n1 = (i >=0)? num[i]: 0;\n            int n = k % 10;\n            n += (i >=0)? num[i]: 0;\n            n += carry;\n            int temp = n%10;\n            carry = n / 10;\n            ans.add(temp);\n            k /= 10;\n            i--;\n        }\n        if (carry != 0){\n            ans.add(carry);\n        }\n        Collections.reverse(ans);\n        return ans;\n        \n    }\n}\n```\nO(N) O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Socrates2001":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916864816","body":"- 时间：2021年9月10日13:34:46\n- 题目：[989.数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n- 思路：逐位相加（最低位开始），将结果逐个放入动态分配的数组中。若某两位相加大于10，则只和的将个位放入数组，十位在适当的数中(k)进1。最后将得到的数组内的数倒置，即为所求。\n\n## c\n\n```c\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n   int *res = (int *)malloc(sizeof(int) * fmax(10, numSize+1));\n   *returnSize = 0;\n   int i, sum, temp;\n\n   for(i=numSize-1; i>=0; i--)\n   {\n       sum = num[i] + k%10;\n       k /= 10;\n       if(sum >= 10)\n       {\n           k++;\n           sum -= 10;\n       }\n       res[(*returnSize)++] = sum;\n   }\n\n   for(; k>0; k/=10)\n   {\n       res[(*returnSize)++] = k % 10;\n   }\n\n   for(i=0; i < (*returnSize)/2; i++)\n   {\n       temp = res[i];\n       res[i] = res[(*returnSize)-1-i];\n       res[(*returnSize)-1-i] = temp;\n   }\n\n    return res;\n}\n```\n\n\n\n- 时间复杂度：O(max(n, lgk)) 其中n为数组长度\n\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Just-focus":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865049","body":"## 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n) n为较长数组的长度\r\n空间复杂度：O(n) n为答案数组的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916865936","body":"思路\n\n平铺直叙\n\n\n\n代码（Python）\n\n    class Solution:\n        def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n            List=num[:]\n            res=[]\n            sum=0\n            Len=len(List)\n            i=Len-1\n            q=1\n            while i>=0:\n                sum=sum+List[i]*q\n                i-=1\n                q*=10\n            sum+=k\n            while sum!=0:\n                res.append(sum%10)\n                sum//=10\n            res.reverse()\n            if len(res)==0:\n                res.append(0)\n            return res\n\n\n\n复杂度\n\n时间：O(n)\n\n空间：O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916875507","body":"# 思路   \r\n输出位=x+y+carry   \r\n将A设为LinkedList双向链表   \r\n# 代码  \r\n\r\n````java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        LinkedList<Integer> res = new LinkedList<>();  // 使用双向链表 LinkeList，或者 ArrayList 最后反转\r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  // 循环条件：两个数有一个没完\r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}    \r\n````\r\n# 复杂度  \r\n时间复杂度：O(max(n, lgk))  其中n为数组长度   \r\n空间复杂度：\r\n\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PearlCoastal":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884534","body":"## 思路\n- 从末尾开始做加法\n- 注意处理进位的方式\n    ·新建一个数组b=[]来处理进位，当 [2] + 998 时， carry = 100，b = [1, 0, 0]\n- 取模运算 **%**，和取整运算 **//**的区别\n    · 86 % 10 = 6 \n    · 86 // 10 = 8\n- 数组的加法运算：把两个数组连在一起\n    · A = [1, 2, 3], B = [2, 3, 4]\n    · A + B = [1, 2, 3, 2, 3, 4]\n## 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: [int], k: int) -> [int]:\n        carry = 0\n        for i in range(len(num) - 1, -1, -1):\n            curr_sum = num[i] + k % 10 + carry\n            num[i] = curr_sum % 10\n            carry = curr_sum // 10\n            k //= 10\n        \n        carry += k\n        b = []\n        while carry:\n            b = [(carry % 10)] + b\n            carry //= 10\n\n        return b + num\n```\n\n## 复杂度分析\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884660","body":"【思路——数组模拟加法过程】\n\n类似用数组模拟大数加法，即模拟人手算的过程，从低位开始，逐位相加，逢十进一，即：\n\n 当前位 = (数A的当前位 + 数B的当前位 + 低位的进位carry) % 10。\n \n 当最后的进位不为0时，需要添加到答案数组的起始位置，可以用 `vector` 的 `insert` 函数，如 `res.insert(res.begin(), carry)`；\n \n 或者我们可以在存答案数组时，从低位到高位存，即`res[0]`表示最低位，这样在运算过程中一直向数组的尾部插入元素即可，最后再将数组翻转。\n\n【C++代码】\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    vector<int> res;\n\n    int i = n - 1, sum = 0, carry = 0;\n    while(i >= 0 || k != 0) {\n        int a = i >= 0 ? num[i] : 0;\n        int b = k != 0 ? k % 10 : 0;\n\n        sum = a + b + carry;\n        carry = sum / 10;\n        res.push_back(sum % 10);\n\n        i--;\n        k /= 10;\n    }\n\n    if(carry != 0)\n        res.push_back(carry);\n    reverse(res.begin(), res.end());\n\n    return res;\n}\n```\n\n时间复杂度： $O(N)$，记 $N= \\max(n, \\log k)$，即表示答案数组的长度， `while` 遍历是 $O(N)$ 的复杂度，翻转数组也是 $O(N)$ 的复杂度。\n\n空间复杂度： $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916884680","body":"# 思路\n\n从最低位开始相加，按逆序存储在vector中，最后把vector逆序一下就可以。\n\n# 代码\nC++\n```\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int carry = 0;\n    int i = num.size() - 1;\n    while (i >= 0 || k || carry) {\n        int tmp = i >= 0 ? num[i--] + carry + k%10 : carry + k%10;\n        carry = tmp /10;\n        k /= 10;\n        res.push_back(tmp%10);\n    }\n    reverse(res.begin(), res.end());\n    return res;\n}\n```\n\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328606","body":"# 思路\n从左边和从右边分别遍历，记录上一个指定字符位置和当前位置的距离，最后遍历一遍取最小值\n# 代码\n```\nvector<int> shortestToChar(string s, char c) {\n        vector<int> right;\n        vector<int> res;\n        int prev = INT_MAX / 2;\n        for(int i = s.size() - 1; i >= 0; i--) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            right.push_back(prev - i);\n        }\n\n        prev = INT_MIN / 2;\n        for(int i = 0; i < s.size(); i++) {\n            if(s[i] == c) {\n                prev = i;\n            }\n            res.push_back(min(i - prev, right[s.size()-i-1]));\n        }\n        return res;\n    }\n```\n# 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916889747","body":"标准加法模板\r\n时间复杂度O(n),空间复杂度O(n)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\r\n\t\treverse(num.begin(), num.end());\r\n\t\tvector<int>res;\r\n\t\tint carry = 0;\r\n\t\tfor (int i = 0; i < num.size() || k>0; i++) {\r\n\t\t\t// num的当前位\r\n\t\t\tint a = (i < num.size() ? num[i] : 0);\r\n\t\t\t// 模拟加法公式\r\n\t\t\tint sum = a + k % 10 + carry;\r\n\t\t\tres.emplace_back(sum % 10);\r\n\t\t\tk /= 10;\r\n\t\t\tcarry = sum / 10;\r\n\t\t}\r\n\t\tif (carry > 0) {\r\n\t\t\tres.emplace_back(carry);\r\n\t\t}\r\n\t\treverse(res.begin(), res.end());\r\n\t\treturn res;\r\n\t}\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314402","body":"对每个字符左右寻找最小的，遇到边界输出另一边\r\n如果该字符为c，则直接给0\r\n\r\n时间O(n)\r\n空间O(1)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n\tvector<int> shortestToChar(string s, char c) {\r\n\t\tint len = s.size();\r\n\t\tvector<int>answer;\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s[i] == c) {\r\n\t\t\t\tanswer.push_back(0);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tint j = i;\r\n\t\t\tint k = i;\r\n\t\t\twhile (s[j] != c) {\r\n\t\t\t\tj--;\r\n\t\t\t\tif (j < 0) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\twhile (s[k] != c) {\r\n\t\t\t\tk++;\r\n\t\t\t\tif (k >= len) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tint la = i - j;\r\n\t\t\tint lb = k - i;\r\n\r\n\t\t\tif (j < 0) {\r\n\t\t\t\tanswer.push_back(lb);\r\n\t\t\t}\r\n\t\t\telse if (k >= len) {\r\n\t\t\t\tanswer.push_back(la);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tanswer.push_back(min(la, lb));\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn answer;\r\n\t}\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LAGRANGIST":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916891700","body":"## 思路\r\n\r\n* 用 carry 记录上一位是否有进位， carry =  ( A[i]+B[i]+carry ) **>=** 10 ? 1 : 0  （注意这里是大于等于而不是大于）\r\n* 当前位 cur 可以表示为 ( A[i]+B[i]+carry ) % 10 \r\n* 处理完 num 的所有数字后，再处理k（如果k的位数比 num 大）\r\n\r\n\r\n\r\n------\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\n#include <bits./stdc++.h>\r\n#include <iostream>\r\nusing namespace std;\r\n\r\nvector<int> addToArrayForm(vector<int> &num, int k)\r\n{\r\n    int carry = 0;\r\n    int cur = 0;\r\n    vector<int> res;\r\n    while (!num.empty())\r\n    {\r\n\r\n        cur = (num.back() + k % 10 + carry) % 10;\r\n        carry = (num.back() + k % 10 + carry) >= 10 ? 1 : 0;//看看这一位是否要进位到下一位\r\n        k /= 10;//去除k最后一位数字\r\n        res.push_back(cur);//res先反向保存，之后调用reverse调转之后再返回\r\n        num.pop_back();//去除num最后一位数字\r\n    }\r\n\r\n    while(k!= 0)//k位数比num大\r\n    {\r\n        cur = (k % 10 + carry) % 10;\r\n        carry = (k % 10 + carry) >= 10 ? 1 : 0;\r\n        k /= 10;\r\n        res.push_back(cur);\r\n    }\r\n\r\n    if(carry)//最后一次还要进位\r\n    {\r\n        res.push_back(1);\r\n    }\r\n\r\n    reverse(res.begin(), res.end()); //反转输出才是正确的\r\n    return res;\r\n}\r\n\r\n//TestDrive\r\nint main()\r\n{\r\n    vector<int> num = {2,1,5};\r\n    int k = 806;\r\n    vector<int> ans = addToArrayForm(num,k);\r\n    for (auto it = ans.begin(); it != ans.end();it++)\r\n    {\r\n        cout << *it << \" \";\r\n    }\r\n}\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n此方法需要遍历一个 num 和 int类型数字 k 的每一位\r\n\r\n所以时间复杂度是：O( max(N , K ) ) , 其中N和K分别是 num 和 k 的位数 \r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n利用了一个辅助 `vector<int> res` 其大小为max（N , K)\r\n\r\n所以空间复杂度是O( max(N, K ) )","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353759","body":"G## 思路\r\n\r\n* res [ i ] 记录的是第 i 个元素与离他最近的字符 c 的距离，它左边的 c 和右边的 c 到他距离中比较小的那一个就是最短距离\r\n\r\n* 初始化数组 res 全部为 -1\r\n\r\n* 从左向右遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 i - pre\r\n\r\n* 将pre重新归为 -1 （非常重要，我在这个地方就犯错了）\r\n\r\n* 从右向左遍历一遍\r\n\r\n\t* 如果发现 c，用 pre 来保存 c 的下标\r\n\t* 如果不是 c 但是没有找到c（pre == -1）就啥也不做跳过\r\n\r\n\t* 如果不是 c 并且 找到了 c (pre 不是 -1) 的话，就将res [ i ] 的值更新为 min ( res [ i ] , pre - i )\r\n\t\t* 但是这里要注意如果 res [ i ] 在从左向右结束后值为 -1 的话上述min值会是-1，所以单独判断一下是不是 -1，是的话直接将其更新为pre - i\r\n\r\n***\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\n```c++\r\nclass Solution\r\n{\r\npublic:\r\n    vector<int> shortestToChar(string s, char c)\r\n    {\r\n        int pre = -1;                        //用来记录上一个找到的 c,-1表示还没有找到\r\n        vector<int> res(s.size(), -1);       // -1 表示还没有找到对应的最近距离\r\n        for (int i = 0; i < s.length(); i++) //从 0 走到最后（从左到右扫描）\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1) //已经发现了他之前的一个c\r\n            {\r\n                res[i] = i - pre;\r\n            }\r\n\r\n            //如果没发现c就保持-1不变\r\n\r\n        } //for前到后\r\n\r\n        pre = -1; //这个很关键啊，第一次写就忘记重新归位了\r\n\r\n        for (int i = s.size() - 1; i >= 0; i--)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                pre = i; //记录下c的位置\r\n            }            //if\r\n\r\n            else if (pre != -1)\r\n            {\r\n                if (res[i] == -1)//防止后面的 min 里面因为 -1 更小就保留成 -1 了\r\n                {\r\n                    res[i] = pre - i;\r\n                }\r\n                else\r\n                    res[i] = min(res[i], pre - i); //如果从后往前扫的距离短了就更新\r\n            }\r\n\r\n        } //for从后到前\r\n\r\n        return res;\r\n\r\n    } //shortesToChar\r\n};    //Solution\r\n\r\n```\r\n\r\n***\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n\r\n\r\n### 时间复杂度\r\n\r\n遍历了两次数组，复杂度是 O( n )\r\n\r\n\r\n\r\n### 空间复杂度\r\n\r\n用了一个 vector 用于保存返回的数组，复杂度是 O( n )\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mokrs":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916900111","body":"## 思路一\n\n从低位到高位，逐位相加，相加结果直接修改原数组\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(1)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int i = num.size() - 1;\n    int plus = 0;\n\n    while (i >= 0 && k > 0){\n        int t = num[i] + plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\n        k /= 10;\n        --i;\n    }\n\n    while (i >= 0){\n        int t = num[i] + plus;\n        plus = t >= 10 ? 1 : 0;\n        num[i] = t % 10;\t\t\t\n        --i;\n    }\n\n    while (k > 0){\n        int t = plus + k % 10;\n        plus = t >= 10 ? 1 : 0;\n        num.insert(num.begin(), t % 10);\n        k /= 10;\t\t\t\n    }\n\n    if (plus > 0){\n        num.insert(num.begin(), plus);\n    }\n\n    return num;\n}\n```\n\n## 思路二\n\n从低位到高位，逐位相加，相加结果以逆序方式存储，最后对数组进行翻转\n\n## 分析\n\n- 时间复杂度：$O(max(n,  logK))$\n\n- 空间复杂度：$O(n)$\n\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    vector<int> res;\n    int i = num.size() - 1;\n    int plus = 0;\n    while (i >= 0 || k > 0){\n        int sum = plus;\n        sum += i >= 0 ? num[i] : 0;\n        sum += k > 0 ? k % 10 : 0;\n        plus = sum >= 10 ? 1 : 0;\n        res.push_back(sum % 10);\n        k /= 10;\n        --i;\n    }\t\n\n    if (plus > 0){\n        res.push_back(plus);\n    }\n\n    reverse(res.begin(), res.end());\n    return res;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niyaolanggeyo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916902429","body":"# 思路\n\n总体思路仿照的是，加法计算过程。采用最低位向前依次递进的方式。最后逆序输出。\n\n# 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for (int i = n - 1; i >= 0 || k > 0; i--) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904082","body":"## 思路\n常规思路\n\n## 代码\n``` javascript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度分析\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Moin-Jer":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916904187","body":"### 思路\r\n---\r\n转化为两个数组，从后往前对应位置相加，最后再进行反转\r\n### 代码\r\n----\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        char[] ch = String.valueOf(k).toCharArray();\r\n        int i = num.length - 1, j = ch.length - 1, carry = 0;\r\n        while (i >= 0 || j >= 0 || carry > 0) {\r\n            int x = (i >= 0 ? num[i] : 0);\r\n            int y = (j >= 0 ? ch[j] - '0' : 0);\r\n            int sum = x + y + carry;\r\n            list.add(sum % 10);\r\n            carry = sum / 10;\r\n            --i;\r\n            --j;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n---\r\n+ 时间复杂度：O(max(nums.length, logk))\r\n+ 空间复杂度：O(logk)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906152","body":"### 思路\r\n\r\n先mark\r\n\r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Shinnost":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916906847","body":"### 思路\n将数字`k`作为一个整体由低位到高位进行相加，从而不断进位。因为每一次同位加法都有可能发生进位，进位数大于10对加法运算没有影响。初始化：`i = len(num) - 1`。将数字`k`与`num[i]`相加，对结果取个位数作为新的`num[i]`；将结果除以10作为新的`k`。`i -= 1`。不断执行上述过程，直至`k`第一次为0时停止。因为`k`是作为一个整体往`num`上加的，当最后的结果的位数大于转换成数字的`num`的位数时，索引`i`会超过数组`num`的索引范围，故需要进行判断并添加`num`的长度使得上述过程能够正常运行，即对`num`的前几个元素添加适当的0。\n\n### 实现(python)\n```python\n## https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/pythonc-san-chong-jie-fa-by-milomusiala-7wc5/\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n\n        while k != 0:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k != 0:\n                num.insert(0, 0)\n                i = 0\n\n        return num\n```\n\n### 复杂度分析\n1. 时间复杂度：$O(n^2)$。遍历数组嵌套python的list.insert()。\n2. 空间复杂度：$O(1)$。原地操作，使用了常数级空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916907412","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (k != 0 || index >= 0) {\r\n            int knum = k % 10;\r\n            k = k / 10;\r\n\r\n            int numTemp = index < 0 ? 0 : num[index];\r\n            int temp =  knum + numTemp + carry;\r\n\r\n            res.add(temp % 10);\r\n            carry = temp >= 10 ? 1 : 0;\r\n            index --;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Joyce94":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909438","body":"###思路\r\n从后往前，逐个相加\r\n\r\n###代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        # num比k长\r\n        # num比k短\r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            cur = num[i] + carry + k % 10\r\n            num[i], carry = cur % 10, cur // 10 \r\n            k = k // 10 \r\n        \r\n        # k += carry\r\n        while k != 0 or carry != 0:\r\n            cur = carry + k % 10\r\n            num.insert(0, cur % 10)\r\n            carry = cur // 10 \r\n            k = k // 10 \r\n        return num \r\n```\r\n\r\n###复杂度\r\n时间复杂度 o(min(n,m))\r\n空间复杂度 o(1))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asterqian":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916909443","body":"### 思路\r\n两数相加从个位开始，自然想到从后往前遍历数组并且也从k的个位开始向前加，唯一要考虑的是进位问题，包括99+1=100这样的edge case。\r\n### 题解\r\n```C++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    int sum = 0;\r\n    int carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        int x = i < 0 ? 0 : num[i];\r\n        int y = k % 10;\r\n        sum = x + y + carry;\r\n        carry = sum / 10;\r\n        sum %= 10;\r\n        res.push_back(sum);\r\n        k /= 10;\r\n        --i;\r\n    }\r\n    if (carry != 0) { res.push_back(1); }\r\n    // faster than using insert in front every time\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}   \r\n```\r\n### 复杂度分析\r\n###### 时间复杂度：O(max(N, K))，N为数组长度，K为k的长度（注：reverse的时间复杂度也为O(max(N, K))）\r\n###### 空间复杂度：O(max(N, K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917349012","body":"### 思路\n计算relative distance类型，第一反应是用dp来储存。这道题由于c可能在左右两边，因此需要遍历两边才能得到shortest path。\n### 题解\n```C++\nvector<int> shortestToChar(string s, char c) {\n    vector<int> memo(s.size(), 0);\n    int prev = INT_MIN/2;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == c) {\n            // mark the pos of c last seen\n            prev = i;\n        } else {\n            // loop from i == 0, thus if c is seen, prev must be smaller than i\n            // if is not seen, i - INT_MIN will become a large positive number\n            memo[i] = i - prev; \n        }\n    }\n    int prev = INT_MAX/2;\n    for (int i = s.size() - 1; i >= 0; --i) {\n        if (s[i] == c) {\n            prev = i;\n        } else {\n            // loop from right to left, either curr is the best solution \n            // or a closer pos of c occurred after i, then prev - i is positive\n            // if not, prev - i would be a large positive number(thats why prev is updated as INT_MAX/2)\n            memo[i] = min(memo[i], prev - i);\n        }\n    }\n    return memo;\n}   \n```\n### 复杂度分析\n###### 时间复杂度：O(2N)，N为数组长度\n###### 空间复杂度：O(N)，因为是一维的数组","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmstart":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916910988","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n​    List<Integer> res = new ArrayList<>();\n​    for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\n​      if(i>=0){\n​        k+=num[i];\n​      }\n​      res.add(k%10);\n​    }\n​    Collections.reverse(res);\n​    return res;\n  }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911109","body":"## 思路\r\n> + 将整个加数 kk 加入数组表示的数的最低位\r\n## 代码\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n## 复杂度分析\r\n> + 时间: O(max(n,logk))，其中 nn 为数组的长度。\r\n> + 空间: O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizzy-123":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916911369","body":"思路：\n     1. 将数组 reverse 以下，这样从0开始低位数\n      2. 将数字求出数组形式--这时得到数组应该是从低位数到高位数\n     3. 将上面两个数组相同索引数字相加，这个相加的就是从低位到高位，如果相加数大于10，将数据减10.\n    4. 将得到数据reverse。\n代码：\n\tvector<int> addToArrayForm(vector<int>& num, int k) {\n\t\tvector<int> result;\n\t\tint n = num.size();\n\t\treverse(num.begin(), num.end());\n\t\tfor (int i = 0; i <n; ++i) {\n\t\t\tint sum = num[i] + k % 10;\n\t\t\tk /= 10;\n\t\t\tif (sum >= 10) {\n\t\t\t\tk++;\n\t\t\t\tsum -= 10;\n\t\t\t}\n\t\t\tresult.push_back(sum);\n\t\t}\n\t\tfor (; k > 0; k /= 10) {\n\t\t\tresult.push_back(k % 10);\n\t\t}\n\t\treverse(result.begin(), result.end());\n\t\treturn result;\n\t}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Poidaze7":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916918813","body":"### 思路\n\n先将列表转换成字符串再转换成数字，与k相加，再转回列表\n\n### 代码\n\n```python\ndef to_list(num):\n        return [int(i) for i in str(num)]\n\ndef to_num(num_list):\n    return int(''.join([str(i) for i in num_list]))\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        l = to_num(num) + k\n        return to_list(l)\n```\n\n### 总结\n\n总觉得不看题解的话，自己思想有点跑偏，希望慢慢转变\n\n### 复杂度分析\n\n- 时间：=。=\n- 空间：好像挺高","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916919493","body":"**思路**\n\n1.自己的思路\n\n逆序遍历数组，每次将位置i的元素与k求和得到新的k，将新k的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n\n如果k在数组遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]；\n\n最后将元素存入列表中返回。\n\n**代码**\n\n```java\nclass Day1LC989V0 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        //逆序遍历数组，每次将位置i的元素与k求和得到新的k，将和的最低位(k % 10)替换num[i]，同时k移除最低位(k /= 10);\n        for (int i = num.length - 1; i >= 0; i--) {\n            k = num[i] + k;\n            num[i] = k % 10;\n            k = k / 10;\n            //如果遍历时k为0,则无需继续求和，直接退出遍历\n            if (k == 0) break;\n        }\n        List<Integer> list = new ArrayList<>();\n        //如果k在遍历后不为0，例如num=[0], k =100,则将100转换为列表[1,0,0]\n        while (k != 0){\n            list.add(k % 10);\n            k /= 10;\n        }\n        //将list的元素逆序存入res列表中\n        for (int i = list.size() - 1; i >= 0; i--) {\n            res.add(list.get(i));\n        }\n        //将求和后的num元素添加到res列表中\n        for (int i : num) {\n            res.add(i);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917321246","body":"**思路**\n\n1.自己的思路\n\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n`idx`记录上一个字符 C 出现的位置，从左向右遍历时初始值为 `s.length() - 1(最坏情况字符在s末尾)` ；从右向左遍历时初始值为 `0(最坏情况字符在s头部)` \n\n从左向右遍历，最短距离为`abs(i - idx)`。\n\n从右向左遍历，最短距离为`abs(i - idx)`。\n\n对比两次遍历的结果，取最小值为最短距离。\n\n**代码**\n\n```java\nclass Day2LC821vV0 {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        char[] strs = s.toCharArray();\n        int idx = s.length() - 1;\n        for (int i = 0; i < strs.length; i++) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        idx = 0;\n        for (int i = strs.length - 1; i >= 0; i--) {\n            if (strs[i] == c){\n                idx = i;\n            }\n            res[i] = Math.min(Math.abs(i - idx), res[i]);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"20donkey":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916920617","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n-1; i>=0;--i){\n            int sum = num[i] + k%10;\n            k/=10;\n            if(sum>=10){\n                k++;\n                sum-=10;\n            }\n            res.add(sum);\n        }\n        for(;k>0;k/=10){\n            res.add(k%10);\n        }\n        Collections.reverse(res);\n            return res;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kashinggo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922619","body":"# 思路\r\n模拟题，逐位遍历，一开始用carry保存进位，后面发现要考虑太多，k++更省心。\r\nps. 因为是数组，如果用 add(0, sum)，每次都需要移动N次；链表的 addFirst 或最后 reverse 更优\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        // 第一天打卡数组 模拟题 \r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum > 9) k++;\r\n            sum %= 10;\r\n            res.add(sum);\r\n        }\r\n\r\n        while (k != 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        \r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n## 时间复杂度 \r\n*O(max(N, K))*，N 为数组长度，K 为数字 k 的位数\r\n## 空间复杂度 \r\n*O(max(N, K))*，额外的 list 用于返回结果 ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916922772","body":"### Java\n\n---\n\n**思路**：\n\n按照加法思路，从个位开始进行加运算，这里直接直接和 k 进行相加，然后取余得到最低位的数值，此值为相加后的结果，如此循环。注意有可能 num 还有剩余，而k已经为0了，这是只需把 num 剩下没运算的数值加到 List 尾部即可，最后对 List 进行反转，即可得到相加后的结果。\n\n\n\n**代码**：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int index = num.length - 1;\n        while(k != 0){\n            int sum = 0;\n            if(index >= 0){\n                sum = k % 10 + num[index];\n                index--;\n            }else{\n                sum = k % 10;\n            }\n            res.add(sum % 10);\n            k = k / 10 + sum / 10;\n        }\n        for(int i = index; i >= 0; i--)\n            res.add(num[i]);\n\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n\n\n**复杂度**：\n\n* **时间复杂度**：O(N)\n* **空间复杂度**：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potatoMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916923321","body":"### 思路\n***\n先在对应位置一一相加，再进行进位操作\n### 代码\n***\nJavascript code:\n```javascript\nvar addToArrayForm = function(num, k) {\n    let temp = 0;\n    const kLen = k.toString().length;\n    for (let i = 0;i < kLen;i++) {\n        if (num.length < kLen) num.unshift(0);\n        temp = k % 10;\n        k = Math.floor(k / 10);\n        num[num.length - 1 - i] += temp;\n    }\n    const nLen = num.length;\n    for (let i = nLen - 1;i > 0;i--) {\n        if (num[i] >= 10) {\n            num[i - 1] += 1\n            num[i] = num[i] % 10;\n        }\n    }\n    if (num[0] >= 10) {\n        num[0] = num[0] % 10;\n        num.unshift(1);\n    }\n    return num;\n};\n```\n### 复杂度分析\n***\n时间复杂度O(max(N,logk))<br/>\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350423","body":"### 思路1\n\n***\n\n空间换时间：先记录每一个字符C出现的下标，再遍历一次字符串S，通过下标相减的绝对值找出每个字符距离C最近的距离\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const targetIndex = [];\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) {\n            targetIndex.push(i);\n        }\n    }\n    const res = [];\n    for (let i = 0;i < s.length;i++) {\n        let min = Infinity;\n        for (let ti of targetIndex) {\n            if (min <= Math.abs(i - ti)) {\n                break;\n            }\n            min = Math.abs(i - ti);\n        }\n        res.push(min);\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N * K)，K是字符C在字符串S中出现的次数，K <= N\n\n空间复杂度：O(K)\n\n### 思路2\n\n***\n\n贪心，先从左往右遍历S，计算每个下标离左边距离C最近的距离，再从右往左遍历计算一次，如有更小的距离则覆盖\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    let targetIndex = null;\n    const res = new Array(s.length);\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex === null) {\n            res[i] = Infinity;\n        } else {\n            res[i] = Math.abs(i - targetIndex);\n        }\n    }\n    targetIndex = null;\n    for (let i = s.length - 1;i > -1;i--) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex !== null) {\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vincentLW":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916927171","body":"代码\n```\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1;\n        while (i >= 0 || k > 0) {\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\n            k = k > 0 ? k / 10 : 0;\n            i = i >= 0 ? i - 1 : -1;\n            carry = cur / 10;\n            cur = cur % 10;\n            res.add(cur);\n        }\n        if (carry == 1) res.add(carry);\n        Collections.reverse(res);\n        return res;\n    }\n```\n时间复杂度：$O(n)$\n空间复杂度：$O(n)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916929362","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        ArrayList list=new ArrayList<Integer>();\n        int f=num.length-1;int carry=0;\n        while(f>=0&&k!=0)\n        {\n            int a=(num[f]+k%10+carry)%10;carry=(num[f]+k%10+carry)/10;\n            list.add(a);\n            f--;k/=10;\n        }\n        while(k>0)\n        {\n            int a=(k%10+carry)%10;carry=(k%10+carry)/10;list.add(a);\n            k/=10;\n        }\n        while(f>=0)\n        {\n            int a=(num[f]+carry)%10;carry=(num[f]+carry)/10;list.add(a);\n            f--;\n        }\n        if(carry>0)list.add(1);\n         Collections.reverse(list);\n         return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917326518","body":" \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int pre=Integer.MIN_VALUE/2;int dist[]=new int[s.length()];\n        for(int i=0;i<s.length();i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=i-pre;\n        }\n        pre=Integer.MAX_VALUE/2;\n        for(int i=s.length()-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c)\n            {\n                pre=i;\n            }\n            dist[i]=Math.min(dist[i],Math.abs(pre-i));\n        }\n        return dist;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916930744","body":"### **思路**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n\n4. 加法问题记得再研究下模板\n\n    [力扣](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/)\n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # 可能会有k长度大于num的情况\n        # 反转列表\n        res = []\n        n = len(num) - 1\n        for i in range(n, -1, -1):\n            cur_sum = k % 10 + num[i]\n            k = k // 10\n            if cur_sum < 10:\n                res.append(cur_sum)\n            else:\n                res.append(cur_sum % 10)\n                k += 1\n        while k:\n            res.append(k % 10)\n            k //= 10\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaysonss":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934318","body":"## 思路\n\n把k转化成数组K，然后让A和K从低位到高位进行相加操作，注意进位问题。\n\n## 关键点\n\n- 如果遍历到最高位后有进位，需要在结果里加上1\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```dart\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> kList = new ArrayList<>();\n\n        while (k != 0) {\n            kList.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(kList);\n        int i = num.length - 1;\n        int j = kList.size() - 1;\n        List<Integer> retList = new ArrayList<>();\n        int delta = 0;\n\n        while (i >= 0 || j >= 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int b = j >= 0 ? kList.get(j) : 0;\n            int v = a + b + delta;\n            \n            if (v > 9) {\n                retList.add(v % 10);\n                delta = 1;\n            } else {\n                retList.add(v);\n\t\tdelta = 0;\n            }\n            i--;\n            j--;\n        }\n\n        if (delta == 1) {\n            retList.add(1);\n        }\n        Collections.reverse(retList);\n        return retList;\n    }\n\n}\n```\n\n**复杂度分析**\n\n时间复杂度：k的取值范围是1-10000，数组K最大长度为5，主要看num的长度，因此为O(n)\n\n空间复杂度：保存结果的List长度主要由num决定，因此为O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916934555","body":"### 思路\r\n\r\n从个位开始加，如果加到最后比原数组长，则把多余的位数append到左边。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n\r\n        digits = len(A)-1\r\n        \r\n        left = K\r\n        \r\n        while left!=0 and digits != -1:\r\n            result = left+A[digits]\r\n            left, A[digits] = result//10, result%10\r\n            digits-=1\r\n            \r\n        if digits == -1 and left!=0:\r\n            while left!=0:\r\n                A = [left%10]+A\r\n                left = left//10\r\n\r\n        return A\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maxsarratt":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935148","body":"### 代码\r\n\r\n```java\r\n// Time: O(max(n, log(k))) ; Space: O(max(n, log(k)))\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if (num == null || num.length == 0) {\r\n            return new LinkedList<>();\r\n        }\r\n\r\n        List<Integer> result = new LinkedList<>();\r\n\r\n        int carry = 0;\r\n        int index = num.length - 1;\r\n        while (index >= 0 || k != 0) {\r\n            int sum = carry;\r\n\r\n            if (index >= 0) {\r\n                sum += num[index--];\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n            }\r\n\r\n            result.add(0, sum % 10);\r\n            carry = sum / 10;\r\n            k /= 10;\r\n        }\r\n\r\n        if (carry != 0) {\r\n            result.add(0, carry);\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334801","body":"### 代码\r\n\r\n```java\r\n// Time: O(n); Space: O(n)\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {        \r\n        int len = s.length();\r\n\r\n        List<Integer> list = new LinkedList<>();\r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n               list.add(i);\r\n            }\r\n        }\r\n        \r\n        int p = 0;\r\n        int[] res = new int[len];\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\r\n                p++;\r\n            }\r\n            res[i] = Math.abs(list.get(p) - i);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bxcharlie":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916935576","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& B, int k) {\n         vector<int> result;\n    for (int i = B.size() - 1; i >= 0; i --) {\n        int num = B[i];\n        k += num; \n        int remind = k % 10;\n        result.insert(result.begin(), remind);\n        k /= 10;\n    }\n    if (k) {\n        while (k > 9) { \n            int remind = k % 10;\n            result.insert(result.begin(), remind);\n            k /= 10;\n        }\n        result.insert(result.begin(), k);\n    }\n    return result;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zszs97":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916938349","body":"# 开始刷题\r\n\r\n## 题目简介\r\n\r\n \r\n【Day 1 】2021-09-10 - 989. 数组形式的整数加法 \r\n-------------------\r\n\r\n\r\n### 题目思路\r\n\r\n1、注意进位\r\n2、如果全部加完还有进位，需要特殊处理。 比如 A = [2], K = 998\r\n\r\n## 题目代码\r\n### 代码块\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> sum;\r\n        int size = num.size();\r\n        for(int i = size-1;i>=0;i--)\r\n        {\r\n            int nsum = num[i] + k % 10;\r\n            k/= 10;\r\n            if(nsum>=10)\r\n            {\r\n                k++;\r\n                nsum-=10;\r\n            }\r\n            sum.push_back(nsum);\r\n        }\r\n        //如果全部加完还有进位 如2+998\r\n        while(k>0)\r\n        {\r\n            sum.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(sum.begin(),sum.end());\r\n        return sum;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 空间复杂度 O(1)\r\n+ 时间复杂度 O(n + logk + resLength)，其中 n 为数组的长度；resLength是res这个vector的长度，来自于reverse的时间消耗\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yj9676":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916941829","body":"## LC989 数组形式的整数加法\r\n### Array\r\n\r\n---\r\n### 思路\r\n与LC2 两数相加类似，从末位开始逐位相加，最后判断carry是否为0\r\n\r\n```\r\nwhile (元素A不为null或者未结束 || 元素B不为null或者未结束)\r\n    currA\r\n    currB\r\n\r\n    sum = currA + currB + carry\r\n\r\n    curr = sum % 10;\r\n    carry = sum / 10;\r\n```\r\n#### Solution\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        int step = len - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n\r\n        while (step >= 0 || k != 0){\r\n            int x = step >= 0 ? num[step] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n\r\n            ans.add(sum % 10);\r\n            step--;\r\n        }\r\n\r\n        if (carry != 0){\r\n            ans.add(carry);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n* 时间复杂度 : *O(max(num.length, logk))*\r\n\r\n* 空间复杂度 : *O(1)* \r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carreylife":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945203","body":"### 思路\n加法运算，用 `carry` 来表示进位，反向遍历数组即可。\n\n遍历结束条件：\n\n1. 数组所有元素都遍历过了\n2. 当 K 为 0 的时候\n\n需要注意的点：\n\n如果遍历结束后 `carry` 大于 0，还需要在数组前面补一位。\n\n### JS代码\n```javascript\nvar addToArrayForm = function(A, K) {\n  const res = []\n  let i = A.length - 1, carry = 0\n  while (i >=0 || K != 0) {\n      const x = i >= 0 ? A[i] : 0\n      const y = K != 0 ? K % 10 : 0\n\n      const sum = x + y + carry\n      res.push(sum % 10)\n      carry = Math.floor(sum / 10)\n\n      i--\n      K = Math.floor(K / 10)\n  }\n  if (carry) res.push(carry)\n  return res.reverse()\n};\n```\n\n**复杂度分析**\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916945692","body":"### 思路\r\n\r\n从后往前加、再反转\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\tvar res []int\r\n\tfor i:= len(num)-1;i>=0||k>0;i-- {\r\n\t\tif i >= 0 {\r\n\t\t\tk+=num[i]\r\n\t\t}\r\n\t\tres = append(res,k%10)\r\n\t\tk/=10\r\n\t}\r\n\tfor i,n:=0,len(res);i<n/2 ;i++{\r\n\t\tres[i],res[n-i-1] = res[n-i-1],res[i]\r\n\t}\r\n\treturn res\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(n,log(k)))。\r\n- 空间复杂度：O(1)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917041009","body":"### 思路\n\n从左遍历，找到左边最近距离；\n从右边遍历，找到右边最近的距离并与之前左边最近距离相比较。\n\n### 代码\n\n\n```go\nfunc shortestToChar(s string, c byte) []int {\n\tvar ans []int\n\tcurr := -len(s)\n\tfor i := range s {\n\t\tif s[i] == c {\n\t\t\tcurr = i\n\t\t\tans = append(ans, 0)\n\t\t} else {\n\t\t\tans = append(ans, i-curr)\n\t\t}\n\t}\n\tcurr = 2*len(s)\n\tfor i := len(s) - 1; i >= 0; i-- {\n\t\tif s[i] != c {\n\t\t\tif curr-i < ans[i] {\n\t\t\t\tans[i] = curr - i\n\t\t\t}\n\t\t} else {\n\t\t\tcurr = i\n\t\t}\n\t}\n\treturn ans\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)。\n- 空间复杂度：O(1)。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Zzh-Zh3nDu1":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946095","body":"## 思路\r\n先在对应位置一一相加，再进行进位操作\r\n\r\n## 代码\r\nJavascript code:\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let temp = 0;\r\n    const kLen = k.toString().length;\r\n    for (let i = 0;i < kLen;i++) {\r\n        if (num.length < kLen) num.unshift(0);\r\n        temp = k % 10;\r\n        k = Math.floor(k / 10);\r\n        num[num.length - 1 - i] += temp;\r\n    }\r\n    const nLen = num.length;\r\n    for (let i = nLen - 1;i > 0;i--) {\r\n        if (num[i] >= 10) {\r\n            num[i - 1] += 1\r\n            num[i] = num[i] % 10;\r\n        }\r\n    }\r\n    if (num[0] >= 10) {\r\n        num[0] = num[0] % 10;\r\n        num.unshift(1);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(N,logk))\r\n空间复杂度O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Weisday":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916946830","body":"#### 思路\n\n​\t将数组倒序遍历，分别使用school method addition，逐位相加。\n\n​\t自己一开始在遍历中没有考虑 `i >= 0 || k > 0` 中的k在数组遍历后不为零的情况。后来在参考别人的解析后意识到了这一点。\n\n#### 代码\n\n~~~c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size() + 1);\n        for (int i = num.size() - 1; i >= 0 || k > 0; --i)\n        {\n            k += (i >= 0 ? num[i] : 0);\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(begin(res), end(res));\n        return res;\n    }\n};\n\n\n~~~\n\n#### 复杂度分析\n\n时间复杂度： O(max(n,k))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916948342","body":"## 思路\n\n从最低位开始相加，k = 123， X = [4,5,6]，\n[4,5,6+123] --> [4,5,129] --> 129 % 10 --> 9 --> [4,5,9] --> 129 - 9 --> 120 --> Matn.floor(120 / 10) --> 12 --> [4,5+12,9]\n......\n\n## js代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n``` \n\n## 复杂度\n\n* 时间复杂度：O(max(n,logk))，其中 n 为数组的长度\n* 空间复杂度：O(1)。除了返回值以外，使用的空间为常数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916951028","body":"class 989_数组形式的加法{\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0 || k > 0 ; i--) {\n            if(i >=0) {\n             k +=  num[i];\n            }\n            res.add(k % 10);\n            k /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ff1234-debug":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953423","body":"> #### 思路\r\n> ​将k视为整体直接与最低位相加，进行取余，进位，最后再对k进行取余，进位\r\n> \r\n> ​ 数组逆置是为了便于最后单独对k的处理\r\n> \r\n> #### 代码\r\n> c++\r\n>\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n        if(k==0) return num;\r\n        int res=0,c=0,n=num.size();\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k/=10;\r\n        }\r\n        while(k!=0)\r\n        {\r\n            num.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n> #### 复杂度分析\r\n> 时间复杂度： O(max(n,log(k))\r\n>空间复杂度： O(1)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhsaga":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916953516","body":"Code:\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n\nTc：O(max(n,logk)) \n\nSc：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917254115","body":"### Code\r\n```\r\npublic class test {\r\n    public static int[] shortestToChar(String s, char c) {\r\n        int l = s.length();\r\n        int[] ans = new int[l];\r\n        int prev = -10000;\r\n        for (int i = 0; i < l; i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = i-prev;\r\n        }\r\n        prev = 10000;\r\n        for (int i = l - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            ans[i] = Math.min(prev - i, ans[i]);\r\n        }\r\n        return ans;\r\n    }\r\n```\r\n### Complexity Analysis\r\n- TC: O(n)\r\n- SC: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heyqz":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916955471","body":"## 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        for i in range(len(num)-1, -1, -1):\r\n            remain = k % 10\r\n            k = k // 10\r\n            total = num[i] + remain + carry\r\n            carry = total // 10\r\n            res.append(total % 10)\r\n        \r\n        k = k + carry\r\n        while k:\r\n            res.append(k % 10)\r\n            k //= 10\r\n        \r\n        res.reverse()\r\n        return res\r\n```\r\n## 复杂度\r\n* time complexity: O(max(n, logk))\r\n* space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lovemyse1f":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916956842","body":"思路：题解\n\n代码（python）\nclass Solution(object):\n    def addToArrayForm(self, num, K):\n        i = len(num) - 1\n        while K:\n            num[i] += K#\n            K, num[i] = num[i] // 10, num[i] % 10#\n            i -= 1\n\n            if i < 0 and K:\n                num.insert(0,0)\n                i = 0\n        return num\n复杂度：\n时间O（N）\n空间O(|K-N|)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Clarence5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962545","body":"```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\naddToArrayForm([1,2,6,3,0,7,1,7,1,9,7,5,6,6,4,4,0,0,6,3],516);\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MissNanLan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916962803","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 前置知识\n\n- 求第一个非负整数的个位与第一位分别是求余、除以10\n\n## 公司\n\n- 暂无\n\n## 思路\n\n逐位相加法\n\n## 关键点\n\n-  两数相加超过10怎么用代码表示\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (n, k) {\n  var res = [];\n  for (var i = n.length - 1; i >= 0; --i) {\n    var sum = n[i] + (k % 10);\n    k = Math.floor(k / 10);\n    if (sum >= 10) {\n      k++;\n      sum = sum - 10;\n    }\n    res.push(sum);\n  }\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n  return res.reverse();\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JinhMa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916963481","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int len = A.length;\n        int lastNum =K;\n        LinkedList<Integer> ret= new LinkedList<>();\n\n        int i = len-1;\n        while(i >=0 || lastNum > 0){\n            if(i >= 0){\n                lastNum+=A[i];\n            }\n            ret.addFirst(lastNum%10);\n            lastNum/=10;\n            i--;\n        }\n        return ret;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aatoe":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916965868","body":"先把卡打上，后面在优化。\n      var addToArrayForm = function(num, k) {\n        // 第一步先将k 加进num里，\n        let kArr = ('' + k).split('').reverse()\n        let len = kArr.length\n        for (let i = 0; i < len; i++) {\n          if (num[num.length - 1 - i] !== undefined) num[num.length - 1 - i] += +kArr[i]\n          else num.unshift(kArr[i])\n        }\n        console.log(num, 'num')\n        // 第二步将num里把每一项进行进位\n        let i = num.length - 1\n        while (i >= 0) {\n          // 大于9 进一\n          if (num[i] > 9) {\n            debugger\n            console.log(i, 'i')\n            if (i > 0) num[i - 1] = +num[i - 1] + parseInt((num[i] % 100) / 10)\n            else {\n              console.log(num[i], 'um[i]')\n              if (num[i] > 9) {\n                num.unshift()\n                let first = parseInt(num[i] % 10)\n                let second = parseInt((num[i] % 100) / 10)\n                num[i] = first\n                num.unshift(second)\n              } else {\n                num.unshift(num[i])\n              }\n            }\n            num[i] = parseInt(num[i] % 10)\n          }\n          i--\n        }\n        return num\n      }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BadCoderChou":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966133","body":"从低位往高位顺着加\r\n\r\n代码 ： java\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        while (i >= 0 || k > 0) {\r\n            int cur = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry;\r\n            k = k > 0 ? k / 10 : 0;\r\n            i = i >= 0 ? i - 1 : -1;\r\n            carry = cur / 10;\r\n            cur = cur % 10;\r\n            res.add(cur);\r\n        }\r\n        if (carry == 1) res.add(carry);\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组的长度\r\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HWFrankFung":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916966146","body":"代码\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n复杂度\n时间复杂度：O(max(n,logk))\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969010","body":"## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int sum = 0, len = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n\n        for(int i = len - 1; i >= 0; i--){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for(; k > 0; k/= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eemsyw":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969273","body":"## 思路\n数字逐位相加，满十进一。\n## 代码\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n```\n\n## 复杂度\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916969683","body":"【思路】这题肯定要用reverse,因为add（0，x)更可怕。如果先把array转为int的话，在大数字面前就不准。所以最好还是直接在array上面操作。就是普通的进位。从右到左，依次相加。保留一个进位。每次每位上面的数字就是 k%10 + num[pos] + carry. 如果k还有但是pos没有的话，num[pos] = 0；\r\n【复杂度】O（n) ，遍历一遍，reverse也是O(n)\r\n\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> rtn = new ArrayList<>();\r\n\r\n        int[] ans = num;\r\n        int add = k;\r\n        int carry = 0;\r\n        int pos = num.length - 1;\r\n        while(add != 0 || pos >= 0){\r\n            int newDigit = add % 10;\r\n            int oldDigit = (pos>=0)? num[pos] : 0;\r\n            int newSum = newDigit + oldDigit + carry;\r\n            carry = newSum / 10 ;\r\n            rtn. add( newSum % 10);\r\n            pos--;\r\n            add = add /10;\r\n        }\r\n        if(carry!=0) rtn.add(carry);\r\n        \r\n        Collections.reverse(rtn);\r\n        return rtn;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334683","body":"【思路】从左和右各遍历一遍代码，左边起始可以是-10000，右边是10000 【题目说size<10^4】，记录发现c的位置，然后和之前发现的C的位置相减。最后取左右两边算出来最小的值\r\n【复杂度分析】O（n）\r\n\r\n```\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()];\r\n        int[] right = new int[s.length()];\r\n\r\n        int leftPos = -10000;\r\n        int rightPos = 10000;\r\n        for(int i = 0 ; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                leftPos = i;\r\n                left[i] = 0;\r\n            }else{\r\n                left[i] = -leftPos+i;\r\n            }\r\n        }\r\n\r\n        for(int i = s.length()-1 ; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                rightPos = i;\r\n                right[i] = 0;\r\n            }else{\r\n                right[i] = rightPos - i;\r\n            }\r\n             left[i] = Math.min(left[i],right[i]);\r\n        }\r\n\r\n        \r\n        return left;\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iciue":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916971835","body":"### 代码\n```js\nconst solution = (num, k) => {\n    const result = []\n    let [cleanNum, carry] = [num, k]\n\n    while(cleanNum.length || carry) {\n        const sum = cleanNum.pop() || 0 + carry % 10\n        carry = ~~(sum / 10) + ~~(carry / 10)\n        result.push(sum)\n    }\n\n    if (carry) result.push(carry)\n    \n    return result.reverse()\n}\n```\n\n### 复杂度分析\n时间复杂度: O(Math.max(num.length, k.length) + result.length)\n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiayinya":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916972497","body":"### 解题思路\r\n##### 1. 暴力解题 （将两数相加 —>转成数组）【自己最开始的想法】（测试耗时76s）\r\n好吧，补充下，提交之后发现这种写法是错误的。\r\n```javascript\r\n  var addToArrayForm = function(num, k) {\r\n    let str = ''\r\n    for (const i of num) {\r\n      str = str + i\r\n    }\r\n    const numStr = Number(str)\r\n    const sum = numStr + k\r\n    const sumStr = sum.toString()\r\n    // 将数字1234变成[1, 2, 3, 4]\r\n    const arr = []\r\n    for (let i = 0; i < sumStr.length; i++) {\r\n      arr.push(Number(sumStr[i]))\r\n    }\r\n    return arr\r\n  };\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1)\r\n\r\n##### 2. 力扣优解（测试耗时80s，迷茫了，怎么比暴力解题的时间还长），这个优解还未彻底理解，待消化\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let count = 0\r\n  const len = k.toString().length\r\n  for (let i = 0; i < len; i++) {\r\n    if (num.length < len) {\r\n      num.unshift(0)\r\n    }\r\n    count = k % 10\r\n    k = parseInt(k / 10)\r\n    num[num.length - 1 - i] += count\r\n  }\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[0] > 9) {\r\n      num.unshift(0)\r\n    }\r\n    if (num[num.length - 1 - i] > 9) {\r\n      num[num.length - 2 - i]++\r\n      num[num.length - 1 - i] = num[num.length - 1 - i] % 10\r\n    }\r\n  }\r\n  return num\r\n};\r\n```\r\n时间复杂度：\r\n空间复杂度：O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chaggle":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916974685","body":"# Day-1 ：2021-09-10 \n\n# 989.数组形式的整数加法\n\n### 题目\n\n```cpp\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 题目思路\n\n-   1、建立一个res的动态数组，以位数的形式来存储最后的结果值；\n-   2、从后往前与k相加，然后对相加得到的值对10进行求余数；\n-   3、如果k的位数大于nums数组所给的位数时候，必然导致k在循环内除以10后余留的值大于0，此时需要扩展数组，由于是动态数组，直接改写类似循环中k = sum / 10，此处为k /= 10，直到k为0为止。\n-   4、最后逆序数组即可输出。\n\n## 题目代码\n\n### 代码块\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& nums, int k) {\n        vector<int> res;\n        for(int i = nums.size() - 1; i >= 0; i--)\n        {\n            int sum = nums[i] + k;\n            res.push_back(r % 10);\n            k = sum / 10;\n        }\n\n        while(k > 0)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        \n        reverse(res.begin(), res.end());\n        //此处使用reverse函数时间复杂度会更低一些\n        /* for(int i = 0, j = res.size() - 1; i < j; i++, j--)\n        {\n            int temp = res[i];\n            res[i] = res[j];\n            res[j] = temp;\n        }  */\n        \n        return res;\n    }\n};\n```\n\n## 复杂度\n\n-   空间复杂度：申请了一个常数级数组，故空间为O(1)\n-   时间复杂度：$O(max(n, \\log k))$，其中n为数组的长度。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sqshada":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916979869","body":"### 思路\n逐位相加\n\n### 代码\n```js\n/**\n * @param {number[]} A\n * @param {number} K\n * @return {number[]}\n */\nvar addToArrayForm = function (A, K) {\n    const res = []\n    const len = A.length\n    for (let i = len - 1; i >= 0; i--) {\n        let sum = A[i] + K % 10\n        K = Math.floor(K / 10)\n        if (sum >= 10) {\n            K++\n            sum -= 10\n        }\n        res.push(sum)\n    }\n    for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10)\n    }\n    res.reverse()\n    return res\n};\n```\n\n### 复杂度分析\n时间复杂度 O(N)，N 为数组的长度。     \n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CoreJa":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980151","body":"# 思路\n思路1：把num数组合并为数字，两个数字相加再转换成数组\n思路2：把k转换成数组，两个数组相加，但要额外处理一下进位的过程\n思路1里的部分可以用python的map映射偷懒完成，先把数组用join+map转成str，再换成int，还原同理\n\n# 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int,str(int(\"\".join(map(str,num)))+k)))\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916980667","body":"``` java\nclass Solution {\npublic List addToArrayForm(int[] num, int k) {\nboolean addOne=false;//进位\nLinkedList list = new LinkedList<>();\nfor(int i=num.length-1;i>=0;i--){\nif(addOne){\nif(k%10+num[i]+1>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i]+1)%10);\n}else {\nif(k%10+num[i]>=10){\naddOne=true;\n}else {\naddOne=false;\n}\nlist.add((k%10+num[i])%10);\n}\nk/=10;\n}\nif(addOne&&k==0){\nlist.add(1);\naddOne=false;\n}else if(k!=0){\nwhile (k!=0){\nif(addOne){\nlist.add((k%10+1)%10);\nif((k%10+1)>=10){\naddOne=true;\n}else {\naddOne= false;\n}\n}else {\nlist.add(k%10);\n}\nk/=10;\n}\n}\nif(addOne)\nlist.add(1);\nCollections.reverse(list);\nreturn list;\n}\n}\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Maschinist-LZY":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981887","body":"思路：\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n语言：C\r\n\r\n\r\n\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize){\r\n    int sum, len_K, len;\r\n    int * res;\r\n    if(K == 0)\r\n    {\r\n        *returnSize = ASize;\r\n        return A;\r\n    }\r\n    len_K = log10(K) + 1;\r\n    *returnSize = (ASize > len_K) ? ASize + 1: len_K + 1;\r\n    res = (int *) malloc(*returnSize * sizeof(int));\r\n    len = *returnSize;\r\n    while(len - 1 >= 1 || K > 0)\r\n    {\r\n       if(ASize > 0) K += A[--ASize];\r\n       res[--len] = K % 10;\r\n       K /= 10;\r\n    }\r\n    *returnSize -= len;\r\n    return res + len;\r\n} \r\n\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingkong1994":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916981984","body":"#数组形式的整数加法\n## 考察点\n1、数组为空时的处理情况。  \n2、数值求和进位的问题，需要注意一些特殊情况。  \n3、数组的长度跟数值k的位数长短的比较。  \n<1> 若数组长度更长，则在按位求和完k后，需要进一步考虑进位的问题。 这里需要特别注意在数组索引为0的求和进位问题。  \n<2> 若数值k的位数更长，则根据索引依次求和完num后，也同样需要考虑进位的问题。注意k的最高位进位问题。\n##代码\n```python\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int size = num.size();\n        if (num.empty()) {\n            while(k) {\n                int val = k % 10;\n                num.push_back(val);\n                k /= 10;\n            }\n            reverse(num.begin(), num.end());\n            return num;\n        }\n        int carry = 0;\n        while (size && k) {\n            int sum = num[size - 1] + (k % 10) + carry;\n            if (sum > 9) {\n                sum -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --;\n            k /= 10;\n        }\n        while(size && carry) { \n            int sum = num[size - 1] + carry;\n            if (sum > 9) {\n                sum -= 10;                   \n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num[size - 1] = sum;\n            size --; \n        }\n        while (k) {\n            int val = k % 10 + carry;\n            if (val > 9) {\n                val -= 10;\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            num.insert(num.begin(), val);\n            k /= 10;\n        }\n        if (carry) { num.insert(num.begin(), carry); }\n        return num; \n    }\n};\n```\n##复杂度\n时间复杂度： O（n）  \n空间复杂度： O（1）  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982551","body":"### Intuition\nSince the input array is passed by reference, we are allowed to modify it in place.\n\nWe start from number k, and add the digits in the array from right to left following the standard addition rule, i.e., if the sum is greater than 10 we reset the current digit and add one to the next digit. \n\nThe modulo and division operations are used to calculate the remainder and update the carry values.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    std::vector<int> addToArrayForm(std::vector<int>& num, int k)\n    {\n        int carry = k;\n        for (int i = num.size() - 1; i >= 0; i--) {\n            int tmp = carry + num[i];\n            carry = tmp / 10;\n            num[i] = tmp % 10;\n        }\n        // Insert to the front at most 3 times\n        while (carry > 0) {\n            num.insert(num.begin(), carry % 10);\n            carry /= 10;\n        }\n        return num;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917338764","body":"### Intuition\nThe observation is that the closest char 'c' for each char in the string is either its first left neigboring 'c' or right neigboring 'c'.\n\nWe can compute the distance on the fly when find the occurances of char 'c' in the string.\n\nIn the first pass going from left to right, whenever we find a char 'c', we record its index in the string, and update its following right neighors untils it hits the next occurance.\n\nIn the second pass going from right to left, whenever we find a char 'c', we record its index in the string, and update its following left neighors untils it hits the next occurance.\n\nNotice that the initial values of result vector is initialized to INT_MAX, but a value of str.length() is enough.\n    \n\n### Implementation\n```c++\nclass Solution\n{\n  public:\n    vector<int> shortestToChar(string s, char c)\n    {\n        // The shortest distance to c is eight from its left neighboring c or right neighboring c\n        int n = s.length();\n        vector<int> res(n, INT_MAX);\n\n        // Sweep from left to right\n        // When one c occurance is found, update its right neighors until the next occurance of c\n        int cIdx = -1;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != -1) {\n                res[i] = i - cIdx;\n            }\n        }\n\n        // Sweep from right to left\n        // When one c occurance is found, update its left neighors until the next occurance of c\n        cIdx = n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) {\n                cIdx = i;\n            }\n            if (cIdx != n) {\n                res[i] = std::min(res[i], cIdx - i);\n            }\n        }\n\n        return res;\n    }\n};\n```\n### Complexity\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alwaysbest":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916982643","body":"# 思路\n#### 从低到高处理数组，刚下班，先打卡\n# 代码\npublic class add2ArrayFromInteger {\n\n    public static void main(String[]args) {\n        Scanner scan = new Scanner(System.in);\n        //数组长度\n        int len = scan.nextInt();\n        //数组\n        ArrayList<Integer> list = new ArrayList<>(len);\n        int i = 0;\n        while (scan.hasNext() && i<len) {\n            list.add(scan.nextInt());\n            i++;\n        }\n        //整数k\n        int k = scan.nextInt();\n        System.out.println(\"数组：\" + list);\n        System.out.println(\"整数：\" + k);\n        //调用方法\n        System.out.println(\"结果：\"+getSum(list, k));\n\n    }\n    \n    private static ArrayList<Integer> getSum(ArrayList<Integer> list, int k) {\n        \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pzl233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916985748","body":"# 思路\n\n把k本身当作carry\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\n\n# 代码\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >=0 ; i--) {\n            int carray = (num[i] + k) % 10;\n            k = (num[i] + k) / 10;\n            result.add(0, carray);\n        }\n        while (k > 0) {\n            result.add(0, k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n\n```\n# 复杂度分析\n时间复杂度： O(n), where n is the length of the num array.\n空间复杂度:   O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangshisong":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916987710","body":"# Day-1 ：2021-09-10\r\n# 思路\r\n从右向左\r\n进位操作在下一步执行\r\n下一步根据不同情况执行不同操作\r\n\r\n### 缺点\r\n每次需要判断不同情况用以执行不同操作，主要耗时在这个地方\r\n\r\n\r\n\r\n\r\n# 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        last = 0\r\n        for i in range(max(len(num), len(str(k)))):\r\n            \r\n            if i  < len(str(k)) and i  < len(num):\r\n            \r\n                num[-1-i] = num[-1-i] + int(str(k)[-1-i]) + last\r\n            elif i  >= len(str(k)) and i  < len(num):\r\n                if last > 0:\r\n                    num[-1-i] = num[-1-i] + last\r\n                    last = 0\r\n                else:\r\n                    break\r\n            elif i  < len(str(k)) and i  >= len(num):\r\n                num = [int(str(k)[-1-i])  + last ] + num\r\n                \r\n            if num[-1-i] >= 10:\r\n                num[-1-i] -= 10\r\n                last = 1\r\n            else:\r\n                last = 0\r\n\r\n        if last == 1:\r\n            return [1] + num\r\n                \r\n        return num\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916989796","body":"## 989. 数组形式的整数加法\n\n### 思路 逐位加法\n例如计算 123+912，我们从低位到高位依次计算 3+2、2+1 和 1+9。任何时候，若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中，所以最终结果为 1035。\n\n### 代码 JavaScript\n\n```javascript\nvar addToArrayForm = function(num, k) {\n  let n = num.length\n  let sum = 0\n  let res = []\n  for (let i = n - 1; i>=0; i--) {\n      sum = num[i] + k % 10\n      k = Math.floor(k/10)\n      if (sum>=10) {\n          k++\n          sum -= 10\n      }\n      res.push(sum)\n  }\n  for (;k>0;k=Math.floor(k/10)){\n      res.push(k%10)\n  }\n  res.reverse()\n  return res\n}\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(max⁡(n,log⁡k))，其中 n 为数组的长度。\n* 空间复杂度：O(n)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"StefanLeeee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916990366","body":"### 思路\r\n把k本身当作carry\r\n从低位到高位进行循环，把carry加到目前处理的最低位，并对carry进行更新\r\n### 代码\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n### 复杂度分析\r\n时间复杂度：O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Venchyluo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993064","body":"###### \r\n简易版，把K也变成list, 然后翻转两个list， 每个位置相加。 主要注意carry， 进位的问题就好。 这样的做法就有点像linked list 相加的那道题了.\r\n\r\nO (N) 做法其实只需要从num 尾巴开始加起，也是注意carry， 是否有进位的情况。\r\n######\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry,i = 0,len(num)-1\r\n      \r\n        while carry or k or i > -1:\r\n            carry += (num[i] if i > -1 else 0) + (k % 10 if k else 0)\r\n            res.append(carry % 10)\r\n            k //= 10\r\n            carry //= 10\r\n            i -= 1\r\n            \r\n        return res[::-1]\r\n```\r\n\r\n###### \r\n时间复杂度： O(N)\r\n\r\n空间复杂度：O(1)（ 不算res的情况下）\r\n###### ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lydia61":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993282","body":"**思路**：取整，大于10进1，否则0，然后去掉多余0.\r\n**代码：python**\r\n`class Solution():\r\n    def plusK(self, digits, k):\r\n        res = [k] #把k当作初始值去做加法，66题的启示\r\n        for digit in digits[::-1]: #遍历\r\n            current_digit = res[-1] + digit #进位后\r\n            res[-1] = current_digit % 10 #整除\r\n            res.append(current_digit // 10) #＞10进位1；否则0\r\n        if res[-1] == 0: #去0\r\n            res.pop()\r\n        return res[::-1]\r\ndemo = Solution()\r\ndemo.plusK([9, 9], 11)`\r\n**时间复杂度n\r\n空间复杂度n**","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993544","body":"## 思路\n\n不断取 `num` 和 `k` 的最后一位相加，和为 `acc`，进位为 `carry`。使用队列来保存结果，保证先入先出。\n\n## 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = collections.deque()\n        acc, carry = 0, 0\n        while num or k:\n            x = num.pop() if len(num) > 0 else 0\n            y = k % 10\n            k //= 10\n            acc = x + y + carry\n            carry = acc // 10\n            res.appendleft(acc % 10)\n        if carry > 0:\n            res.appendleft(1)\n        return list(res)\n```\n\n## 复杂度分析\n\n时间复杂度：O(max(n, log(k)))\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LOVEwitch":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916993689","body":"//javascript按位相加\nvar addToArrayForm = function(num, k) {\n  //split后每一项为字符串，相加时要注意转换为数字\n  let newNum = String(k).split('');\n  //进位的值\n  let jw = 0;\n  //保证num为长数组\n  if(num.length < newNum.length){\n      let temp = num;\n      num = newNum;\n      newNum = temp;\n  }\n  //长数组从尾到头遍历一遍\n  for(let i = num.length - 1, j = newNum.length - 1; i >= 0; i--){\n      //sum为相应位置上长短数组和进位的和\n      let sum = 0;\n      //短数组存在时，长短数组和进位相加，否则长数组和进位\n      if(j >= 0){\n          sum = Number(num[i]) + Number(newNum[j]) + jw; \n          j--;\n      } else {\n          sum = Number(num[i]) + jw; \n      }\n      //保留非进位的数字\n      num[i] = sum % 10;\n      //判断是否进位，并存储此次循环的进位\n      if( sum >= 10){\n          jw = Math.floor(sum / 10);\n      } else {\n          jw = 0;\n      } \n      \n  }\n  //循环完后还有进位，存储到数组头部\n  if(jw){\n    num.unshift(jw)\n  }\n  return num;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MusicOfWind":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916994086","body":"思路:逐位相加\r\n让我们逐位将数字加在一起。例如计算 123+912123+912，我们从低位到高位依次计算 3+23+2、2+12+1 和 1+91+9。任何时候，若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中，所以最终结果为 10351035。\r\n\r\n代码:\r\nclass Solution {\r\npublic List addToArrayForm(int[] num, int k) {\r\nLinkedList ans = new LinkedList<>();\r\nint temp=0;\r\nfor (int i = num.length-1; i >=0 ; i--) {\r\ntemp = k%10;\r\nk/=10;\r\nif (temp+num[i]>=10){\r\nk++;\r\nans.addFirst((temp+num[i])%10);\r\n}else {\r\nans.addFirst(temp+num[i]);\r\n}\r\n//处理特殊情况\r\nif (i==0){\r\nwhile (k>0){\r\ntemp = k%10;\r\nk/=10;\r\nans.addFirst(temp);\r\n}\r\n}\r\n}\r\nreturn ans;\r\n}\r\n}\r\n\r\n复杂度:\r\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\r\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingcai":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996704","body":"##  思路\n\nnum数组从后往前遍历， k值从个位开始遍历。 使用add来记录是否有进位\n\n## 代码\n```cpp\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        std::vector<int> result;\n        //int devide = 10;\n        int num_index = num.size() - 1;\n        int add = 0; // 进位标志\n        int value = 0;\n        while (num_index >= 0 or k > 0) {\n            // 三种情况下 都记着+add\n            if(num_index >= 0 && k > 0) { // num和k都有值可用\n                value = num[num_index] + k % 10 + add;\n            } else if (num_index >= 0) { // k已经用完，num还没有遍历完\n                value = num[num_index] + add;\n            } else {\n                value = k % 10 +add; // num已经遍历完， k还没有用完\n            }\n\n            int real_value = value % 10;  // %10 取个位置 放入到result\n            add = value / 10; // 是否有进位\n            result.push_back(real_value);\n            k = k / 10; // 将k去掉个位，十位变成个位\n            num_index--; // num_index往前移动\n        }\n        if (add > 0) {\n            result.push_back(add); //压入最后可能存在的进位\n        }\n        reverse(result.begin(), result.end()); // 翻转result\n        return result;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度  O(n) , 必须遍历数组且会将结果数组翻转\n空间复杂度 O(n) 用来保存结果","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JunQu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916996830","body":"## 思路分析\r\n首先考虑最常见的情况，第二种输入示例2里面的情况，对位相加。\r\n然后考虑到进位，增加一个参数`n`表示进位，则`n`的值只能是`0`或者`1`。\r\n最后一个边缘情况是数字的长度大于数组的长度，这样首位前面补`0`。\r\n\r\n## 代码实现\r\n```js\r\nconst addToArrayForm = function(num, k) {\r\n  let n = 0;\r\n  let len = k.toString().length;\r\n  while (len > num.length) {\r\n    num.unshift(0);\r\n  }\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    const digit = k % 10;\r\n    const sum = num[i] + digit + n;\r\n    n = sum > 9 ? 1 : 0;\r\n    num[i] = sum % 10;\r\n    k = ~~(k / 10);\r\n  }\r\n  if (n) {\r\n    num.unshift(n);\r\n  }\r\n  return num;\r\n};\r\n```` \r\n失误点：没有一次提交过，是因为我没有考虑数字长度大于数组长度。\r\n\r\n## 复杂度分析\r\nfor 循环的时间复杂度为 O(n)，理论上 unshift 操作的复杂度也是 O(n),但是考虑到 k 的长度是5以内，所以整体的时间复杂度还是 O(n)。\r\n\r\n空间复杂度取决于 K 的长度，根据条件 K 的长度小于5，那么最大空间复杂度就是 5.\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916997256","body":"### JS解法\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n    const ret = [];\r\n    let i = num.length - 1, carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        let x = i >= 0 ? num[i] : 0;\r\n        let y = k !== 0 ? k % 10 : 0;\r\n\r\n        const sum = x + y + carry;\r\n\r\n        ret.push(sum % 10);\r\n        carry = Math.floor(sum / 10);\r\n\r\n        i--;\r\n        k = Math.floor(k / 10);\r\n    }\r\n    if (carry) {\r\n        ret.push(carry);\r\n    }\r\n    return ret.reverse();\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998377","body":"#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n``` cpp\n// 9-10 cpp \nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int i = num.size() - 1;\n        int up = 0;\n        vector<int> ans;\n        while (i >= 0 || k != 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0 ? k%10 : 0;\n\n            int sum = x + y + up;\n            ans.push_back(sum % 10);\n            up = sum / 10;\n\n            i--;\n            k = k / 10;\n        }\n        if (up) ans.push_back(up);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crypteee":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-916998496","body":"## 思路\r\n\r\n- 原地修改数组，无需开辟额外的空间\r\n- 由于加法从右到左逐位计算，自然地倒序遍历数组\r\n- 模运算 `%` 可拿到每次计算结果的末位数，然后把该末位数原地更新到原数组\r\n- 取整的除运算 `/` 可拿到去掉末位数的剩余数字，这些数字即下一轮要继续计算的数字，直到剩余的数字归零\r\n- 如果数组已经完全计算完毕，但是还有剩余的数字要计算，则对原数组的头部补 0，然后继续运算剩余的数字，直到归零\r\n\r\n## 实现\r\n\r\n语言：TypeScript\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  let restK = k;\r\n  let i = num.length - 1;\r\n\r\n  while (i >= 0) {\r\n    const curSum = num[i] + restK;\r\n    num[i] = curSum % 10;\r\n    restK = ~~(curSum / 10);\r\n\r\n    if (i === 0 && restK !== 0) {\r\n      // 原数组用完了，但还存留未计算的数，那么就在数组首部补零\r\n      num.unshift(0);\r\n    } else {\r\n      // 原数组没用完，那就继续向左移动\r\n      i = i - 1;\r\n    }\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：每个元素只遍历一次，所以是 O(N)\r\n- 空间复杂度：由于是原地操作数组，所以是 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzcyes":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000501","body":"方法一：末尾相加\r\n\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n const sum:number[] = [];\r\n    let i = num.length - 1;\r\n    while(i >= 0 || k > 0){\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        sum.push(k % 10);   //  把k的末位push进数组\r\n        i--;\r\n        k = Math.floor(k / 10); // 把k的末位去掉\r\n    }\r\n    return sum.reverse();\r\n};\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yliboom":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000554","body":"# 思路\n根据 arr 的长度 在遍历过程中做幂等运算，得出 arr 转换后的数组\n# 代码\n```javascript\n\nconst addToArrayForm = function (arr, k) {\n\n    let number = 0;\n    // 根据 arr 的长度 在遍历过程中 做运算，得出 arr 转换后的数组\n    // 0 + 1 * 1000 + 2 * 100 + 3 * 10 + 4\n\n    for (let i = 0; i < arr.length; i++) {\n        let len = arr.length - i - 1;\n        number +=  arr[i] * Math.pow(10, len);\n    }\n    return number + k\n\n}\n\n\n\n````\n# 复杂度分析\nfor 循环的时间复杂度为 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000754","body":"## 语言 CSharp \n\n* 时间复杂度:O(max⁡(n,log⁡k))\n* 空间复杂度:O(N)\n\n> 考点：两个数相加 超过10进一位 \n\n> 操作：%10 取个位上的数  /10取十位上的数 添加到数组 数组反转\n\n> 思考：先考虑有没有加0的可能性，试着用一个自己习惯的数字来进行 比如[9,9]+5 先处理一个小的数\n```\npublic IList<int> AddToArrayForm(int[] num, int k) {\n        int i = num.Length - 1;\n        int sum = k;\n        List<int> arr = new List<int>();\n        while(i >= 0 || sum != 0){\n            if(i >= 0){\n                sum += num[i];\n            }\n            arr.Add(sum % 10);\n            sum /= 10;\n            i--;\n        }\n        int[] arr1 = arr.ToArray();\n        Array.Reverse(arr1);\n        return arr1;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenbihao":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917000877","body":"\n## 思路\n硬刚出来的，明天看看别人的解答\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 先转int[] 再去加   进位字段\n        String kStr = String.valueOf(k);\n        int[] kArray = getIntArray(kStr);\n\n        List<Integer> result;\n\n        // 计算并取进位\n        if (num.length >= kArray.length) {\n            result = calculate(num, kArray);\n        } else {\n            result = calculate(kArray, num);\n        }\n        return result;\n    }\n\nprivate List<Integer> calculate(int[] longer, int[] shorter) {\n        int carry = 0;\n        for (int i = 0; i < longer.length; i++) {\n            int longerLen = longer.length - i - 1;\n            int shorterLen = shorter.length - i - 1;\n\n            if (shorterLen >= 0) {\n                int i1 = shorter[shorterLen] + longer[longerLen] + carry;\n                longer[longerLen] = i1 % 10;\n                carry = i1 / 10;\n            } else {\n                // 当k比num位数少的时候，还得计算完进位的情况\n                if (carry != 0) {\n                    int i1 = longer[longerLen] + carry;\n                    longer[longerLen] = i1 % 10;\n                    carry = i1 / 10;\n                }\n            }\n        }\n\n        // 判断最后有没有进位，有的话补上\n        List<Integer> result = Arrays.stream(longer).boxed().collect(Collectors.toList());\n        if (carry != 0) {\n            ArrayList<Integer> integers = new ArrayList<>();\n            integers.add(carry);\n            integers.addAll(result);\n            result = integers;\n        }\n        return result;\n    }\n    \n    private int[] getIntArray(String str) {\n        int[] ints = new int[str.length()];\n        for (int i = 0; i < ints.length; i++) {\n            Character ch = str.charAt(i);\n            ints[i] = Integer.parseInt(ch.toString());\n        }\n        return ints;\n    }\n\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917001862","body":"### 思路\n\n待补\n\n### 代码\n\n\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n\nvar addToArrayForm = function(num, k) {\n  const res = []\n  let i = num.length - 1\n  let carry = 0\n  while (i >= 0 || k > 0 || carry > 0) {\n    let cur = (num[i] || 0) + k % 10 + carry\n    res.push(cur % 10)\n    carry = cur / 10 | 0\n    i--\n    k = k / 10 | 0\n  }\n  return res.reverse()\n};\n```\n\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JianXinyu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917004761","body":"```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007515","body":"## 思路\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Python3\n\nPython3 Code:\n\n```python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        tmp = 0\n        for i in range(n-1,-1,-1):\n            num_tmp = num[i] + k%10+ tmp\n            tmp =num_tmp//10\n            num[i] = num_tmp%10\n            k = k//10\n        #print(k,tmp,num)\n        k += tmp\n        while k!=0:\n            num.insert(0,k%10)\n            k = k//10\n        return num\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917007922","body":"* 语言：JavaScript\r\n```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917008176","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n    \n      LinkedList<Integer> list = new LinkedList<>();\n           \n            for(int i=num.length-1;i>=0;i--){\n                 k = k + num[i];\n                 int a=(k)%10;\n\n                  k=k/10;\n\n                  list.addFirst(a);\n\n            }\n            if(k>0){\n                while(k>0){\n                   \n                    int b = k % 10;\n                     k=k/10;\n                    list.addFirst(b);\n                }\n            }\n            return list;\n\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917329642","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n         char[] chars = s.toCharArray();\n         int[] arr=new int[s.length()];\n        for(int i=0;i<s.length();i++){\n           String s1 = new String(chars,0,i);\n           String s2 = new String(chars,i,s.length()-i);\n           int i1 = s1.lastIndexOf(c);\n           int i2 = s2.indexOf(c);\n           int min=-1;\n           if(i1==-1){\n             min=i2;\n           }\n           if(i2==-1){\n           i1 = s1.length()-i1;\n            min=i1;\n           }\n            if(i1!=-1&&i2!=-1){\n                i1 = s1.length()-i1;\n               min = i1<i2?i1:i2;\n            }\n\n               arr[i]=min;\n        }\n             return arr;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917009198","body":"```\nclass Solution:\n#list转换为int\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        B = 0\n        for i in range(len(A)):\n            B += A[i]*(10**(len(A) - i - 1))\n#做加法     \n        C = B + K    \n#加判断,程序测试的时候发现[0]和0通不过       \n        if C == 0:\n            D = [0]\n        else:\n            D = []     \n#int转化为list，注意reverse\n#while循环，除了0， 空字符串，空列表，空元组，空字典，空集合等，其它都为True\n        while C:\n            D.append(C%10)\n            C //=10\n        D.reverse()\n        return D\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917013134","body":"### 代码实现\n\n```\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(max(n,logk))，其中 nn 为数组的长度\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moxiaopao278":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917014944","body":"#include <algorithm>\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& A, int K) {\n        int carry = 0;\n        vector<int> B;\n        while(K > 0){\n            B.push_back(K%10);\n            K /= 10;\n        }\n        if(B.size()==0){\n            B.push_back(0);\n        }\n        reverse(A.begin(), A.end());\n        int i;\n        int maxl = max(A.size(), B.size());\n        vector<int> C(maxl);\n        //对齐A组和B组的数位。\n        while(A.size()<maxl)A.push_back(0);\n        while(B.size()<maxl)B.push_back(0);\n        for(i = 0; i < maxl; i++){\n            C[i] = A[i] + B[i] + carry;\n            carry = C[i] / 10;\n            C[i] %= 10;\n        }\n        if(carry){\n            C.push_back(carry);\n        }\n        reverse(C.begin(), C.end());\n        return C;\n\n    }\n};\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015435","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      List returnList= new ArrayList<Integer>();\n\n      //1. 转换成int  \n      int sum = num[0];\n\n      for(int i = 0; i< num.length - 1; i++){\n          sum *=10;\n          sum += num[i+1];\n      }\n\n      //2. 相加\n      sum = sum + k;\n\n      //2. 转成Integer[]\n      String str = Integer.toString(sum);\n      char[] chars = str.toCharArray();\n\n      for(int i = 0; i < chars.length; i++){\n          Integer integer = Integer.valueOf(String.valueOf(chars[i]));\n          returnList.add(integer);\n      }\n\n      return returnList;\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zyMacro":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015464","body":"    let arr2_ = [];\n    while(k>=0) {\n        arr2_.push(k%10);\n        k = Math.floor(k/10);\n        if(k === 0) {\n            break;\n        }\n    }\n    let arr1_ = num.reverse();\n    let len1 = num.length;\n    let len2 = arr2_.length;\n    if(len1 > len2) {\n        while(len1 - len2 > 0) {\n            arr2_.push(0);\n            len1 = len1 - 1;\n        }\n    } else if (len1 < len2){\n        while(len2 - len1 > 0) {\n            arr1_.push(0);\n            len2 = len2 - 1;\n        }\n    }\n    let res = [];\n    let bit = 0;\n    let supplement = 0;\n    arr1_.forEach((val,i) => {\n        let sum = val + arr2_[i];\n        if(sum + bit > 9) {\n            supplement = sum - 10;\n            res.push(supplement + bit);\n            bit = 1;\n        } else {\n            supplement = sum ;\n            res.push(supplement + bit);\n            bit = 0;\n        }\n    })\n    if(bit === 1) {\n        res.push(1);\n    }\n    return res.reverse();","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015491","body":"```js\r\n**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    for(let i = num.length - 1; i >= 0; i--) {\r\n        let sum = k % 10 + num[i]\r\n        k = Math.floor(k / 10)\r\n        if (sum >= 10) {\r\n            k++\r\n            res.push( sum % 10 );\r\n        } else {\r\n            res.push(sum)\r\n        }\r\n    }  \r\n    while(k > 0) {\r\n        res.push(k % 10)\r\n        k = Math.floor( k / 10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yankang233":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917015563","body":"#python\r\n\r\n    class Solution:\r\n        def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n            i = len(A) - 1\r\n            while K:\r\n                A[i] += K\r\n                K, A[i] = A[i] // 10, A[i] % 10\r\n                i -= 1\r\n\r\n              if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n           return A\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351715","body":"## Code\n### python3\n      class Solution:\n          def shortestToChar(self, s: str, c: str) -> List[int]:\n              cc = [ i  for i in range(len(s))   if s[i]==c]\n              return([min([abs(x-y)  for y in cc]) for x in range(len(s))])\n\n## 复杂度\n\n时间：O(n^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017117","body":"### 思路\n\n------\n\n先在对应位置一一相加，有进位就进位，再进行进位操作，获取每位的数出来\n\n### 语言\n\n------\n\nJava\n\n        class Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n      List<Integer> res = new ArrayList<Integer>();\n       int n = num.length;\n       for (int i = n - 1; i >= 0; --i) {\n         int sum = num[i] + k % 10;\n       k /= 10;\n      if (sum >= 10) {\n       k++;\n     sum -= 10;\n     }\n       res.add(sum);\n      }\n      for (; k > 0; k /= 10) {\n       res.add(k % 10);\n        }\n      Collections.reverse(res);\n      return res;\n          }\n         }\n复杂度分析\n\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\n\n空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zulliu":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017139","body":"**思路**\n\n倒序遍历，将数字拆分为位数相加\n\n**代码**\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        holder = 0\n        counter = 0\n        num=num[::-1]\n        while k > 0 or counter < len(num):\n            if counter >= len(num):\n                digit = k % 10 + holder\n                num.append(digit % 10)\n            else:\n                digit = num[counter] + k % 10 + holder\n                num[counter] = digit % 10\n            holder = digit // 10\n            k = k //10\n            counter += 1\n        if holder == 1:\n            num.append(1)\n        num = num[::-1]\n        return num\n```\n**复杂度分析**\n\n时间复杂度：O(N)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917017461","body":"\n\n## 思路\n\n遍历进位\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> r = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n-1;i >=0;--i){\n            int sum = num[i] + k%10;\n            k /=10;\n            if(sum >= 10){\n                k++;\n                sum -=10;\n            }\n            r.add(sum);\n        }\n        for(; k>0; k /=10){\n            r.add(k%10);\n        }\n        Collections.reverse(r);\n        return r;\n    }\n}\n\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n空间复杂度 O(1)\n时间复杂度 O(n)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Baiqr":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917022001","body":"```javascript\nfunction calculateTwoNumberSum(arr, num) {\n    const arrNumberStr = arr.join(',')\n    const res = (Number(arrNumberStr.replace(/,/g, \"\")) + num)\n    return String(res).split(\"\")\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"V-Enzo":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027391","body":"## 思路\r\n判断末尾相加的和是否大于10，如果大于10则需要，给k/=10后的k加1，然后进行下一轮操作。使用push_back更易操作\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> result;\r\n        int num_size = num.size();\r\n        for(int i=num_size -1; i>=0; i--){\r\n            int value = num[i] + k%10;\r\n            k/=10;\r\n            if (value>=10){\r\n                k += 1;\r\n                value -= 10;\r\n            }\r\n            result.push_back(value);\r\n        }\r\n        for( ; k>0; k/=10){            \r\n            result.push_back(k%10);\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344037","body":"## 思路\r\n找到指定字符，计算出所有的距离，取最小值即可。这里其实变为指针移动去判断更好，能降到时间复杂度为O(N)\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int s_len = s.length();\r\n        vector<int> pos;\r\n        for(int i=0; i<s_len;i++){\r\n            if (s[i] ==c)\r\n                pos.push_back(i);\r\n        }\r\n        vector<int> ans;\r\n        for(int i=0; i<s_len; i++){\r\n            vector<int> min_dist;\r\n            for(int j=0; j<pos.size(); j++){\r\n                min_dist.push_back(abs(i-pos[j]));            \r\n                }\r\n            int min_v = *min_element(min_dist.begin(), min_dist.end());\r\n            ans.push_back(min_v);\r\n            }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n\r\n## 复杂度\r\n空间复杂度为O(N)\r\n时间复杂度为O(N^2)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ThreeGold-yxh":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027518","body":"## 思路一\n\n把 num[ ] 和k都转化为list，然后用0补齐较短的那个list，再遍历相加，加法策略为两数相加再加上进位，遍历完了之后最后检查一下进位是否为0，不为0还要插进结果list中，最后把结果list反转即可\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //首先把k变为数组模式kList\n        int temp = k;\n        List<Integer> kList = new ArrayList<>();\n        while(temp > 0){\n            int kBit = temp % 10;\n            kList.add(kBit);\n            temp = temp / 10;\n        }\n        //KList这时候是反的，个位在第一个\n        //把数组int[] num 变为 numList，注意也是个位数在最前面\n        List<Integer> numList = new ArrayList<>();\n        for(int i = num.length - 1; i >=0; i--){\n            numList.add(num[i]);\n        }\n        //比较一下这两个list哪个长，短的在后面补0\n        if(numList.size() > kList.size()){\n            int length= numList.size() - kList.size();\n            while(length-- > 0){\n                kList.add(0);\n            }\n        }\n        else{\n            int length= kList.size() - numList.size();\n             while(length-- > 0){\n                numList.add(0);\n            }\n        }\n        // //两个list反转\n        // Collections.reverse(numList);\n        // Collections.reverse(kList);\n        List<Integer> resultList = new ArrayList<>();\n        //按位做加法\n        //进位\n        int carryBit = 0;\n        for(int i = 0; i < numList.size(); i++){\n            int currentBit = numList.get(i) + kList.get(i) + carryBit;\n            int remainBit = currentBit % 10;\n            carryBit = currentBit / 10;\n            resultList.add(remainBit);\n        }\n        //最后看一下进位\n        if(carryBit != 0){\n            resultList.add(carryBit);\n        }\n        //反转resultList\n        Collections.reverse(resultList);\n        return resultList;\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n因为用到了一个辅助List去保存结果","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917334828","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n\n\n## 思路一\n\n双指针做法，一个firstIndex快指针，优先找到c的位置，然后慢指针secondIndex再来移动，补全结果数组\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //双指针来做\n        int firstIndex = 0;\n        int secondIndex = -1;\n        int[] resultArr = new int[s.length()];\n        while(firstIndex <= s.length() - 1){\n            if(!(c==(s.charAt(firstIndex)))){\n                //如果慢指针还没有动过，那么这时候连一个c都没找到，全部赋值10001\n                if(secondIndex == -1){\n                    resultArr[firstIndex] = 10001;\n                }\n                //反之此时慢指针应该指向上一个c的位置，取位置的差值赋进去\n                else{\n                    resultArr[firstIndex] = firstIndex - secondIndex;\n                }\n                //快指针继续向后\n                firstIndex++;\n            }\n            //此时快指针到了下一个c的所在地，\n            else{\n                resultArr[firstIndex] = 0;\n                int mid = 0;\n                //修改位置差值,如果secondIndex == -1，那么全部都要修改\n                if(secondIndex == -1){\n                    mid = 0;\n                }\n                //修改位置差值,从mid到firstIndex的元素都需要修改值\n                else{\n                    mid = secondIndex + ((firstIndex - secondIndex) + 1) / 2 ;\n                }\n                while(mid < firstIndex){\n                    resultArr[mid] = firstIndex - mid;\n                    mid ++;\n                }\n                //最后把慢指针直接移动到快指针位置\n                secondIndex = firstIndex;\n                //然后快指针继续移动\n                firstIndex ++;\n            }\n        }\n        return resultArr;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/1#issuecomment-917027734","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int len = num.size() - 1;\r\n        while(len>=0)\r\n        {\r\n            int sum = k % 10 + num[len];\r\n            k /= 10;\r\n            if(sum>=10)\r\n            {\r\n                ++k;\r\n                sum -= 10;\r\n            }\r\n            --len;\r\n            res.push_back(sum);\r\n        }\r\n        while(k>0)\r\n        {\r\n            res.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917328223","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n\r\n## 思路\r\n用数组index存放c在s中的位置，之后对s进行遍历，比较当前位置与index[i]，index[i+1]的距离，取最近距离值。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        vector<int> index;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]==c)\r\n                index.push_back(i);\r\n        }\r\n        for(int i=0;i<index[0];++i)\r\n            res[i] = index[0] - i;\r\n        int idx1 = 0, idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n        for(int i=index[0]+1;i<s.size();++i)\r\n        {\r\n            if(idx2==idx1)\r\n                res[i] = i - index[idx1];\r\n            else\r\n                res[i] = (i-index[idx1])<(index[idx2]-i)?(i-index[idx1]):(index[idx2]-i);\r\n            if(res[i]==0)\r\n            {\r\n                idx1++;\r\n                idx2 = idx1+1<index.size()?idx1+1:idx1;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yufanzh":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917128012","body":"## Intuition\r\nTraverse the array from left to right, and then right to left. Both sides will iterative using the following logic:\r\ninitialize the location of c `lastc` as max_value, iterative through rray, if find char == c, then update `lastc = i`; else, update `distance = lastc - i`\r\ndo the same from end to begin\r\nthen the ans will be the minimum value comparing those two at each location.\r\n\r\n## Algorithm\r\ncode in python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = [0]*len(s)\r\n        lastc = float('inf')\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                lastc=i\r\n            else:\r\n                res[i] = abs(lastc-i)\r\n        for i in range(len(s))[::-1]:\r\n            ch = s[i]\r\n            if ch == c:\r\n                lastc = i\r\n            else:\r\n                res[i] = min(res[i], abs(lastc-i))\r\n        return res\r\n```\r\n## Complexity analysis\r\ntime complexity: O(len(s)\r\nextra space complexity: O(1) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HuijunXu":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917139121","body":"### 思路\r\n\r\n* 双指针\r\n\r\n### 代码\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n    var l = -1;\r\n    var n = -1;\r\n    var i =0;\r\n    var arr = [];\r\n    while(i<s.length){\r\n        if(n<=i){\r\n            n++;\r\n            while(s[n]!=c&&n<s.length){\r\n                n++\r\n            };\r\n        }\r\n        if(s[i]===c){\r\n            l = i;\r\n            arr[i]=0\r\n        }else{\r\n            if(l<0){\r\n                arr[i] = Math.abs(i-n)\r\n            }else if(n===s.length){\r\n                arr[i] = Math.abs(i-l)\r\n            } else{\r\n                arr[i]=Math.min(Math.abs(i-l),Math.abs(i-n))\r\n            }\r\n        }\r\n        i++\r\n    }\r\n    return arr\r\n};\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n### 结果\r\n\r\nAccepted\r\n76/76 cases passed (80 ms)\r\nYour runtime beats 79.89 % of javascript submissions\r\nYour memory usage beats 50.28 % of javascript submissions (40 MB)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917225566","body":"# java, 菜鸡解法\n```import java.util.Collections;\nimport java.util.ArrayList;\nimport java.util.*;\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       char []arr=s.toCharArray();\n        int[]ans=new int[arr.length];\n      ArrayList<Integer> a=new ArrayList<Integer>();\n\n        for(int i=0; i<arr.length; i++)\n        {\n            if(arr[i]==c)\n                a.add(i);\n        }\n        for(int i=0; i<arr.length;i++)\n        {\n        ArrayList<Integer> list = new ArrayList<Integer>(); \n            for(int j=0;j<a.size();j++)\n            {\n               list.add(Math.abs(i-a.get(j)));\n            }\n             ans[i]=Collections.min(list);\n        }\n              return ans;\n    }\n}```\n时间复杂度o(n^2)\n空间复杂度0（n）\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simonsayshi":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917243682","body":"```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        vector<int>arr;int Last_Occ=-1;\n        int l;\n        for(int j = 0 ; j < s.length() ; j++)\n        {\n            size_t k = s.find(c,j);  \n            if(j==k)//found c at index j\n            {\n                arr.push_back(0);\n                Last_Occ=k;//store the latest index of occurence of char c\n            }\n            else{\n                if(Last_Occ==-1)//not reached index 'j' yet where s[j] == c\n\t\t\t\t\tarr.push_back(k-j);\n                else\n                {\n\t\t\t\t/* use  l = min(k - j , j - Last_Occ) */\n                    if( k - j <= j - Last_Occ)\n                        l = k - j;\n                    else\n                        l = j - Last_Occ;\n                    arr.push_back(l);\n                }\n            }\n            \n        }\n        return arr;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FlorenceLLL":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917256344","body":"先写一个自己想出来的暴力解决方法\r\n#### 思路\r\n1.首先找到c的所有位置，存在indexList数组中\r\n2.遍历s每个index - indexList的值，取最小，存到answer中\r\n\r\n#### 代码\r\n``` python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ##找出所有c的位置\r\n        index = s.find(c)\r\n        indexList = []\r\n        indexList.append(index)\r\n\r\n        while (index != -1):\r\n            index = s.find(c,index + 1)\r\n            if(index != -1):\r\n                indexList.append(index)\r\n\r\n        ##计算s每个位置 - c所有的位置，取最小，存到list中\r\n        answer = []\r\n        for i in range(len(s)):\r\n            min = abs(i - indexList[0])\r\n            for j in range(len(indexList)):\r\n               if(abs(i-indexList[j]) < min):\r\n                   min = abs(i-indexList[j])\r\n            answer.append(min)\r\n        \r\n        return answer\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 $$O(n^2)$$ 因为循环两次\r\n空间复杂度 $$O(n)$$ 因为新建了一个数组存answer","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devosend":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917302280","body":"## 思路\n遍历两次字符串，找到当前字符距离左边和右边第一个目标字符的距离，存储较小的值\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = []\n        index = -len(s)\n\n        for i in range(len(s)):\n            if s[i] == c:\n                index = i\n            \n            ans.append(i - index)\n\n        # index = len(s)\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                index = i\n            \n            ans[i] = min(ans[i], abs(index - i))\n        \n        return ans\n\n```\n\n## 复杂度分析\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"comst007":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917314532","body":"[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n----\r\n\r\n### 思路\r\n\r\nmin_dist[i] = min(dist_to_left[i], dist_to_right[i])\r\n\r\n\r\n----\r\n### 代码\r\n\r\n```cpp\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size());\r\n        int pos_c = -10009;\r\n        for(int ii = 0; ii < s.size(); ++ ii){\r\n            if(s[ii] == c){\r\n                pos_c = ii;\r\n                ans[ii] = 0;\r\n                continue;\r\n            }\r\n            ans[ii] = ii - pos_c;\r\n        }\r\n        pos_c = 20009;\r\n        for(int jj = s.size() - 1; jj >= 0;  -- jj){\r\n            if(s[jj] == c){\r\n                pos_c = jj;\r\n                ans[jj] = 0;\r\n                continue;\r\n            }\r\n            ans[jj] = min(ans[jj], pos_c - jj);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n};\r\n\r\n``` \r\n\r\n----\r\n\r\n**复杂度分析**\r\n-   分别从左右两边遍历一边 `O(n)`\r\n-   `O(1)`\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917330206","body":"### 思路\r\n官方题解里的贪心算法，\r\n### 代码\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n       int n = S.length();\r\n       vector<int> ret(n,n);\r\n       for(int i = 0; i < n; ++i){\r\n           if(S[i] == C){\r\n               ret[i] = 0;\r\n           }\r\n           else if(i > 0){\r\n               ret[i] = ret[i - 1] + 1;\r\n           }\r\n       }\r\n\r\n       for(int i = n -1; i >= 0; --i){\r\n           if(ret[i] == n || (i < n-1 && ret[i+ 1] + 1 < ret[i]) ){\r\n               ret[i] = ret[i + 1] + 1;\r\n           }\r\n       }\r\n       return ret;\r\n       \r\n    }\r\n};\r\n### 复杂度\r\n时间O（n）\r\n空间O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917332543","body":"# Python 思路\n先遍历s，将位置记录下\n再遍历一遍s，计算s中的元素到每一个位置的距离，取最小值（双重循环）\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        position = []\n        distance = []\n        for i,item in enumerate(s):\n            if item == c:\n                position.append(i)\n                continue\n        print(position)\n\n        for i in range(len(s)):\n            dist = []\n            for p in range(len(position)):\n                if len(position)==1:\n                    d = abs(i-position[p])\n                else:\n                    dist.append(abs(i-position[p]))\n                    d = min(dist)\n            distance.append(d)\n\n\n        return distance\n```\n时间复杂度：O（N*K）\n空间复杂度：O（K）\nK为c在s中出现的次数\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917335984","body":"## 思路\n暴力法：\n首先记录c在字符串中出现的下标，并保存在list中\n然后遍历字符串，字符串中每一位下标和list中的下标相减取绝对值，并保存最小的一个\n## 关键点\n\n-  值得注意的是，看了题解，我的代码可以在两个地方优化\n1. 在两层循环时候，一旦遇到字符c，就不需要进入内循环\n2. 在内循环中，一旦遇到距离大于之前的距离，就可以直接退出内循环，因为是顺序的，后面的距离肯定更大。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        List<Integer> list = new ArrayList();\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i) == c){\n                list.add(i);\n            }\n        }\n        int res[] = new int[s.length()];\n        \n        for(int i=0;i<s.length();i++){\n            int min=Integer.MAX_VALUE;\n            for(int j=0;j<list.size();j++){\n                int abs = Math.abs(i-list.get(j));\n                min = Math.min(abs,min);\n            }\n            res[i] = min;\n        }\n        return res;\n\n    }\n}\n\n```\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n*m)$n是数组长度，m是字符串中出现c的个数\n- 空间复杂度：$O(n)$\n\n```java\n//从左往右和从右往左遍历\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int ans[] = new int[n];\n        int prev = Integer.MIN_VALUE/2;//注意越界，所以除以2\n\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            ans[i] = i-prev;\n        }\n       prev = Integer.MAX_VALUE/2;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i) == c){\n                prev = i;\n            }\n            ans[i] = Math.min(ans[i],prev-i);\n        }\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$n是数组长度\n- 空间复杂度：$O(n)$\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biancaone":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917337981","body":"### 思路\n对于string 中的每个charater, 比较离它最近的左右两边target charater的距离，返回最小值\n\n### 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if not s:\n            return []\n\n        result = [0 for i in range(len(s))]\n\n        prev = -sys.maxsize\n\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            result[i] = i - prev\n\n        prev = sys.maxsize\n\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            result[i] = min(result[i], prev - i)\n\n        return result\n```\n### 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917339015","body":"Two pass\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int c_position = -n;\n        int[] ans = new int[n];\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                c_position = i;\n            }\n            ans[i] = i - c_position;\n        }\n        \n        for (int j = n - 1; j >= 0; j--) {\n            if (s.charAt(j) == c) {\n                c_position = j;\n            }\n            ans[j] = Math.min(ans[j], Math.abs(j - c_position));\n        }\n        return ans;\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cassiechris":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917341652","body":"### 思路\n\n先遍历一遍字符串s，把c每次出现的index记录下来存为一个list\n然后再次遍历s，每个元素计算与每个c的距离（遍历list），如果计算得到更小的距离就更新最小距离直到遍历完c的list，将得到的最小距离存到距离的list中，最后输出最终的list\n\n### 代码\n\n```python\ndef shortestToChar(s: str, c: str):\n    ls_c = []\n    for i,e in enumerate(s):\n        if e == c:\n            ls_c.append(i)\n    ls_d = []\n    for i in range(len(s)):\n        distance = abs(i-ls_c[0])\n        for c in ls_c:\n            if abs(c-i) < distance:\n                distance = abs(c-i)\n        ls_d.append(distance)\n    return ls_d\n```\n\n**复杂度分析**\n\n- 时间复杂度: $O(N)$，N为字符串s的长度\n- 空间复杂度: $O(N)$，N为字符串s的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinnXuu":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344179","body":"### 思路\n向左向右各遍历一次，比较取距离最小值。\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int pos = -10001;\n        for(int i = 0; i <= n - 1; i++){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = 10001;\n        for(int i = n - 1; i >= 0; i--){\n            if(s.charAt(i) == c){\n                pos = i;\n            }\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n### 复杂度分析\n- 时间复杂度：$O(N)$, N为数组长度\n- 空间复杂度：$O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AgathaWang":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917344743","body":"# 思路\n采用标答第二种思路，空间换时间\n\n# 代码\n```\n# python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        c_lst = [i for i in range(len(s)) if s[i]==c]\n\n        output = []\n        for w in range(len(s)):\n            min_dist = min([abs(i-w) for i in c_lst])\n            output.append(min_dist)\n        return output\n```\n# 复杂度\n- 时间复杂度： O(N*K)\n- 空间复杂度： O(K)\n\nK = length of c_lst, the number of c in s\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917350684","body":"class Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = [float('inf') for i in s]\r\n        last_c = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                last_c = i\r\n                result[i] = i-last_c\r\n            else:\r\n                result[i] = i-last_c\r\n        last_c = float('inf')\r\n        for i in range(len(s)-1, -1,-1):\r\n            if s[i] == c:\r\n                last_c = i\r\n            result[i] = min(result[i], last_c - i)\r\n        return result ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351060","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indx_c = list()\r\n        \r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                indx_c.append(i)\r\n        \r\n        # find shortest distance\r\n        \r\n        res = [10000]* len(s)\r\n\r\n        for j in range(len(s)):\r\n            if j in indx_c:\r\n                res[j] = 0\r\n            else:\r\n                tmp = [abs(x - j) for x in indx_c]\r\n                res[j] = min(tmp)\r\n\r\n\r\n        return res\r\n\r\n                \r\n\r\n            \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xvm03":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917351757","body":"### 思路\r\n找s里所有c的位置，遍历s逐一和c的数组进行差值计算，找到最小值，新建数组存放最小值\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n            List<Integer> list = new ArrayList();\r\n            int length = s.length();\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                if(b == c){\r\n                    list.add(i);\r\n                }\r\n            }\r\n            int[] result = new int[length];\r\n            for(int i=0;i<length;i++){\r\n                char b = s.charAt(i);\r\n                int diffNum=0;\r\n\r\n                for(int y=0;y<list.size();y++){\r\n                    Integer d = list.get(y);\r\n                    int innerDiffNum=0;\r\n                    if(i>d){\r\n                        innerDiffNum=i-d;\r\n                    }else{\r\n                        innerDiffNum=d-i;\r\n                    }\r\n\r\n                    if(y==0){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                    if(innerDiffNum<diffNum){\r\n                        diffNum=innerDiffNum;\r\n                    }\r\n                }\r\n                result[i]=diffNum;\r\n            \r\n            }\r\n            return result;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n需要先遍历一遍s，复杂度：n，然后再遍历一遍s，和重复c的数组进行逐一比对，n*c.length()，n+n*c.length()\r\n\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,{"url":"https://github.com/leetcode-pp/91alg-5-daily-check/issues/5#issuecomment-917353463","body":"# 代码\n```javascript\nconst shortestToChar = (s, c) => {\n  const res = Array(s.length).fill(-1)\n  let close = -1, i = 0\n  while(i < s.length) {\n    if(s[i] === c) {\n      res[i] = 0\n      close = i\n    } else {\n      res[i] = close === -1 ? -1 : i - close\n    }\n    i++\n  }\n  i = s.length - 1\n  while(i >= 0) {\n    if(s[i] === c) {\n      close = i\n    } else {\n      res[i] = res[i] === -1 ? Math.abs(i - close) : Math.min(res[i], Math.abs(i - close))\n    }\n    i--\n  }\n  return res\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}