{"29728":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843680704","body":"## 思路\r\n两个链表,  如果以相交点分割 为A+C和B+C 所以两链表遍历A+C+B和B+C+A的长度 如果遍历出节点相等 证明两链表相交,且相等点为交点\r\n## 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode currentA = headA;\r\n        ListNode currentB = headB;\r\n\r\n        if (currentA == null || currentB == null) {\r\n            return null;\r\n        }\r\n\r\n        while (currentA != currentB) {\r\n            if (currentA != null) {\r\n                currentA = currentA.next;\r\n            } else {\r\n                currentA = headB;\r\n            }\r\n\r\n            if(currentB != null){\r\n                currentB = currentB.next;\r\n            } else {\r\n                currentB = headA;\r\n            }\r\n        }\r\n        return currentA;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n- 时间O(M+N)\r\n- 空间O(1) "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844620516","body":"## 思路\r\n快慢指针,链表环内长度为b, 环外长度为a, fast 每次两个节点, slow 每次一个节点. 当fast和slow相遇时 可得fast路程f = 2 slow路程 s 扣圈可知 f = s + nb 可知 s = nb ,又因为 任意一个指针从head到入圈点走过的路程k = a + nb , 所以可得 k = a + s, 现在需要让slow再走a步可以到达环入口, 那么把fast置为head 和slow速度一样 当两点相等时, fast指针所指向的就是链表的环入口.\r\n## 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n\r\n        while(true) {\r\n            if(fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow)\r\n                break;\r\n        }\r\n        fast = head;\r\n        while(fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n## 复杂度\r\n时间复杂度 O(n) \r\n空间复杂度 O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"464244812":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841831097","body":"### 思路\r\n利用快慢指针获取尾指针tail，顺便获取链表长度length。\r\n\r\n快慢指针定位新的表尾slow。\r\n\r\n经过变换得到旋转后的链表。\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) { // 空的链表\r\n            return null;\r\n        }\r\n        // 利用快慢指针获取尾指针，顺便获取链表长度\r\n        ListNode slow = head, fast = head.next;\r\n        int length = 1;\r\n        while (fast != null) {\r\n            length++;\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        ListNode tail = slow;\r\n\r\n        // 若 k >= length，实际上要向右旋转 k % length 步\r\n        // 旋转后，倒数第 k % length + 1 个元素将作为新的表尾\r\n        // 利用快慢指针，让 slow 定位到它\r\n        int step = (k % length + 1);\r\n        slow = fast = head;\r\n        for (int i = 1; i <= step; i++) {\r\n            fast = fast.next;\r\n        }\r\n        while (fast != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        // 利用tail, head和slow经过操作变成新的链表，即旋转后的链表\r\n        tail.next = head;\r\n        head = slow.next;\r\n        slow.next = null;\r\n        return head;\r\n    }\r\n\r\n}\r\n```\r\n### 算法分析\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840280816","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843728091","body":"## 代码\r\n\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n    while(a != b){\r\n      a = a ? a.next : headB\r\n      b = b ? b.next : headA\r\n    }\r\n\r\n    return a;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 m 和 n 分别为链表 A 和 B 的长度\r\n\r\n- 时间复杂度：O(m + n)\r\n- 空间复杂度: O(1)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846497059","body":"1. press `G` go to bottom of the page\r\n2. `cmd + v` paste code\r\n3. press `comment`\r\n\r\n```py\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\ntime: $O(n)$\r\nspace:$O(n)$ for worst case like `linked-list like tree`"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"angusgenius":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835847052","body":"### 思路\r\n- 模拟数字加法，利用 `K` 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc addToArrayForm(A []int, K int) (ans []int) {\r\n    for i := len(A) - 1; i >= 0 || K > 0; i-- {\r\n        if i >= 0 {\r\n            K += A[i]\r\n        }\r\n        ans = append(ans, K%10)\r\n        K /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\nfunc reverse(A []int) {\r\n    for i, n := 0, len(A); i < n/2; i++ {\r\n        A[i], A[n-1-i] = A[n-1-i], A[i]\r\n    }\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836995457","body":"### 思路\r\n- 双向遍历，对于每个字符 `S[i]`，找出向左或者向右下一个字符 `C` 的距离，这两个值的较小值即最短距离。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, 0, n)\r\n    prev := math.MinInt32 / 2\r\n\r\n    for i := 0; i < n; i++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans = append(ans, i - prev)\r\n    }\r\n\r\n    prev = math.MaxInt32 / 2\r\n    for i := n-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        ans[i] = min(ans[i], prev - i)\r\n    }\r\n\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 `N` 是 S 的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839823744","body":"### 思路\r\n- 利用数组模拟。\r\n\r\n### 代码\r\n- Java\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] add;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int ret = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        --top;\r\n        return ret;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit >= 0) {\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(maxSize)，辅助数组空间。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552068","body":"### 思路\r\n- 模拟栈\r\n    - 若当前的字符为数位，解析出一个数字并进栈。\r\n    - 若当前的字符为字母或者左括号，直接进栈.\r\n    - 若当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，即该字符串出现的次数，据此构造出新的字符串并进栈。\r\n    - 重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串的长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234472","body":"### 思路\r\n- 将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(N)，其中 N 是操作总数。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841612498","body":"### 思路\r\n- 滑动窗口。\r\n\r\n### 代码\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(NlogN)，其中 N 为数组的长度。\r\n- 空间复杂度：O(N)，其中 N 为数组的长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841794938","body":"### 思路\r\n- 链表的长度 n，将链表的末尾节点与头节点相连。计算新链表的最后一个节点（即原链表的第 (n−1)−(k%n) 个节点），再将环形链表断开。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    n := 1\r\n    iter := head\r\n    for iter.Next != nil {\r\n        iter = iter.Next\r\n        n++\r\n    }\r\n    add := n - k%n\r\n    if add == n {\r\n        return head\r\n    }\r\n    iter.Next = head\r\n    for add > 0 {\r\n        iter = iter.Next\r\n        add--\r\n    }\r\n    ret := iter.Next\r\n    iter.Next = nil\r\n    return ret\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为链表的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842039187","body":"### 思路\r\n- 将两个节点作为一组内部进行指针交换。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    dummyHead := &ListNode{0, head}\r\n    temp := dummyHead\r\n    for temp.Next != nil && temp.Next.Next != nil {\r\n        node1 := temp.Next\r\n        node2 := temp.Next.Next\r\n        temp.Next = node2\r\n        node1.Next = node2.Next\r\n        node2.Next = node1\r\n        temp = node1\r\n    }\r\n    return dummyHead.Next\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n        ListNode temp = dummyHead;\r\n        while (temp.next != null && temp.next.next != null) {\r\n            ListNode node1 = temp.next;\r\n            ListNode node2 = temp.next.next;\r\n            temp.next = node2;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            temp = node1;\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 是链表的节点数量。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842873822","body":"### 思路\r\n- 分治 + 中序遍历\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nvar globalHead *ListNode\r\n\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    globalHead = head\r\n    length := getLength(head)\r\n    return buildTree(0, length - 1)\r\n}\r\n\r\nfunc getLength(head *ListNode) int {\r\n    ret := 0\r\n    for ; head != nil; head = head.Next {\r\n        ret++\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc buildTree(left, right int) *TreeNode {\r\n    if left > right {\r\n        return nil\r\n    }\r\n    mid := (left + right + 1) / 2\r\n    root := &TreeNode{}\r\n    root.Left = buildTree(left, mid - 1)\r\n    root.Val = globalHead.Val\r\n    globalHead = globalHead.Next\r\n    root.Right = buildTree(mid + 1, right)\r\n    return root\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    ListNode globalHead;\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        globalHead = head;\r\n        int length = getLength(head);\r\n        return buildTree(0, length - 1);\r\n    }\r\n\r\n    public int getLength(ListNode head) {\r\n        int ret = 0;\r\n        while (head != null) {\r\n            ++ret;\r\n            head = head.next;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public TreeNode buildTree(int left, int right) {\r\n        if (left > right) {\r\n            return null;\r\n        }\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode root = new TreeNode();\r\n        root.left = buildTree(left, mid - 1);\r\n        root.val = globalHead.val;\r\n        globalHead = globalHead.next;\r\n        root.right = buildTree(mid + 1, right);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 是链表的长度。\r\n- 空间复杂度：O(logn)，递归过程中栈的最大深度，即平衡二叉树的高度为 O(logn) 。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843414353","body":"### 思路\r\n- 双指针法\r\n    - 如果第一次遍历到链表尾部，就指向另一个链表的头部，继续遍历，这样会抵消长度差。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    curA,curB := headA,headB\r\n    for curA != curB {      \r\n        if curA == nil {\r\n            curA = headB\r\n        } else {\r\n            curA = curA.Next\r\n        }\r\n        if curB == nil {\r\n            curB = headA\r\n        } else {\r\n            curB = curB.Next\r\n        }\r\n    }\r\n    return curA\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode pA = headA, pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(m+n)，其中 m,n 分别为两条链表的长度。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844726565","body":"### 思路\r\n- 快慢指针。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n    slow, fast := head, head\r\n    for fast != nil {\r\n        slow = slow.Next\r\n        if fast.Next == nil {\r\n            return nil\r\n        }\r\n        fast = fast.Next.Next\r\n        if fast == slow {\r\n            p := head\r\n            for p != slow {\r\n                p = p.Next\r\n                slow = slow.Next\r\n            }\r\n            return p\r\n        }\r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null) {\r\n            slow = slow.next;\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n            if (fast == slow) {\r\n                ListNode ptr = head;\r\n                while (ptr != slow) {\r\n                    ptr = ptr.next;\r\n                    slow = slow.next;\r\n                }\r\n                return ptr;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为链表节点数目。\r\n- 空间复杂度：O(1)，常数级别。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845933494","body":"### 思路\r\n- 哈希表 + 双向链表。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\ntype LRUCache struct {\r\n    size int\r\n    capacity int\r\n    cache map[int]*DLinkedNode\r\n    head, tail *DLinkedNode\r\n}\r\n\r\ntype DLinkedNode struct {\r\n    key, value int\r\n    prev, next *DLinkedNode\r\n}\r\n\r\nfunc initDLinkedNode(key, value int) *DLinkedNode {\r\n    return &DLinkedNode{\r\n        key: key,\r\n        value: value,\r\n    }\r\n}\r\n\r\nfunc Constructor(capacity int) LRUCache {\r\n    l := LRUCache{\r\n        cache: map[int]*DLinkedNode{},\r\n        head: initDLinkedNode(0, 0),\r\n        tail: initDLinkedNode(0, 0),\r\n        capacity: capacity,\r\n    }\r\n    l.head.next = l.tail\r\n    l.tail.prev = l.head\r\n    return l\r\n}\r\n\r\nfunc (this *LRUCache) Get(key int) int {\r\n    if _, ok := this.cache[key]; !ok {\r\n        return -1\r\n    }\r\n    node := this.cache[key]\r\n    this.moveToHead(node)\r\n    return node.value\r\n}\r\n\r\n\r\nfunc (this *LRUCache) Put(key int, value int)  {\r\n    if _, ok := this.cache[key]; !ok {\r\n        node := initDLinkedNode(key, value)\r\n        this.cache[key] = node\r\n        this.addToHead(node)\r\n        this.size++\r\n        if this.size > this.capacity {\r\n            removed := this.removeTail()\r\n            delete(this.cache, removed.key)\r\n            this.size--\r\n        }\r\n    } else {\r\n        node := this.cache[key]\r\n        node.value = value\r\n        this.moveToHead(node)\r\n    }\r\n}\r\n\r\nfunc (this *LRUCache) addToHead(node *DLinkedNode) {\r\n    node.prev = this.head\r\n    node.next = this.head.next\r\n    this.head.next.prev = node\r\n    this.head.next = node\r\n}\r\n\r\nfunc (this *LRUCache) removeNode(node *DLinkedNode) {\r\n    node.prev.next = node.next\r\n    node.next.prev = node.prev\r\n}\r\n\r\nfunc (this *LRUCache) moveToHead(node *DLinkedNode) {\r\n    this.removeNode(node)\r\n    this.addToHead(node)\r\n}\r\n\r\nfunc (this *LRUCache) removeTail() *DLinkedNode {\r\n    node := this.tail.prev\r\n    this.removeNode(node)\r\n    return node\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode tail = removeTail();\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(n)，其中 n 为 capacity 大小。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846171738","body":"### 思路\r\n- 深度优先搜索。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc maxDepth(root *TreeNode) int {\r\n    if root == nil {\r\n        return 0\r\n    }\r\n    return max(maxDepth(root.Left), maxDepth(root.Right)) + 1\r\n}\r\n\r\nfunc max(a, b int) int {\r\n    if a > b {\r\n        return a\r\n    }\r\n    return b\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        } else {\r\n            int leftHeight = maxDepth(root.left);\r\n            int rightHeight = maxDepth(root.right);\r\n            return Math.max(leftHeight, rightHeight) + 1;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。\r\n- 空间复杂度：O(h)，其中 h 表示二叉树的高度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846446973","body":"### 思路\r\n- dfs。\r\n\r\n### 代码\r\n- Golang\r\n```go\r\nfunc isSameTree(p *TreeNode, q *TreeNode) bool {\r\n    if p == nil && q == nil {\r\n        return true\r\n    }\r\n    if p == nil || q == nil {\r\n        return false\r\n    }\r\n    if p.Val != q.Val {\r\n        return false\r\n    }\r\n    return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)\r\n}\r\n```\r\n\r\n- Java\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。\r\n- 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devil-lin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835849107","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int n = num.size();\r\n        for(int i = n - 1; i >= 0 || k; i --)\r\n        {\r\n            if(i >= 0)\r\n                k += num[i];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838552141","body":"\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n   vector<int> shortestToChar(string S, char C) {\r\n       vector<int> distance(S.size(), 0);\r\n       int prev = INT_MIN/2;\r\n       for(int i = 0; i < S.size(); i ++){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = i - prev;\r\n       }\r\n       prev = INT_MAX/2;\r\n       for(int i = S.size() - 1; i >= 0; i --){\r\n           if(S[i] == C) prev = i;\r\n           distance[i] = min(distance[i], prev - i);\r\n       }\r\n       return distance;\r\n   }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838831826","body":"思路没啥的，就是数组模拟而已\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int maxSize;\r\n    int[] stack;\r\n    int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == maxSize){\r\n            return;\r\n        }\r\n        stack[index++] = x;\r\n    }\r\n   \r\n    public int pop() {\r\n        if(index == 0){\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k, index);\r\n        for(int i = 0; i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841333545","body":"C++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841621666","body":"Java Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841822799","body":"\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k == 0 || head == nullptr || head -> next == nullptr) return head;\r\n\r\n        ListNode* iter = head;\r\n        int n = 1;\r\n        while (iter -> next != nullptr)\r\n        {\r\n            iter = iter -> next;\r\n            n ++;\r\n        }\r\n        int node = n - k % n;\r\n\r\n        if(node == n) return head;\r\n        \r\n        iter->next = head;\r\n\r\n        while(node --)\r\n            iter = iter -> next;\r\n        ListNode* ret = iter -> next;\r\n\r\n        iter -> next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842064822","body":"C++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */class Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* newHead = head -> next;\r\n        head -> next = swapPairs(newHead -> next);\r\n        newHead -> next = head;\r\n        return newHead;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843255650","body":"C++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* getMedian(ListNode* left, ListNode* right) {\r\n        ListNode* fast = left;\r\n        ListNode* slow = left;\r\n        while (fast != right && fast->next != right) {\r\n            fast = fast->next;\r\n            fast = fast->next;\r\n            slow = slow->next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode* left, ListNode* right) {\r\n        if (left == right) {\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = getMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = buildTree(left, mid);\r\n        root->right = buildTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return buildTree(head, nullptr);\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844199992","body":"C++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA==NULL||headB==NULL) return NULL;\r\n        ListNode *pa=headA;\r\n        ListNode *pb=headB;\r\n        int flag=0;\r\n        while(pa!=pb){\r\n            if(pa!=NULL) pa=pa->next;\r\n            else pa=headB;\r\n            if(pb!=NULL) pb=pb->next;\r\n            else pb=headA;\r\n        }\r\n\r\n        return pa;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845234883","body":"C++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return null;//此时必定无环,也就没有入环的节点\r\n        }\r\n        ListNode slowPtr = head;\r\n        ListNode fastPtr = head;\r\n        while(fastPtr != null && fastPtr.next != null){//有环，那就会一直转圈，否则就无环\r\n            slowPtr = slowPtr.next;\r\n            fastPtr = fastPtr.next.next;\r\n            if (slowPtr == fastPtr) {\r\n                ListNode index1 = fastPtr;\r\n                ListNode index2 = head;\r\n                while (index1 != index2) {\r\n                    index1 = index1.next;\r\n                    index2 = index2.next;\r\n                }\r\n                return index2; // 返回环的入口\r\n            }\r\n        }\r\n        return null;\r\n    } \r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845820089","body":"C++ Code:\r\n\r\n```c++\r\n\r\nclass LRUCache {\r\nprivate:\r\n    list<pair<int, int>> mycatch;   // 双向链表，每个节点都是<key，value>的键值对\r\n    int cap;                        // 缓存（双向链表）的最大容量\r\n    // 哈希表<key, <key, value>>, 用于双向链表的随机访问\r\n    unordered_map<int, list<pair<int, int>> :: iterator> mymap; \r\npublic:\r\n    // 构造函数只初始化cap的值即可\r\n    LRUCache(int capacity) : cap(capacity){}\r\n    \r\n    int get(int key) \r\n    {\r\n        // 要查询的关键字不在缓存中，返回-1\r\n        if (mymap.find(key) == mymap.end()) return -1;  \r\n        auto key_val = *mymap[key];     // 目标键值对\r\n        mycatch.erase(mymap[key]);      // 先从缓存中删去\r\n        mycatch.push_front(key_val);    // 重新放在最前面（代表最近刚访问）\r\n        mymap[key] = mycatch.begin();   // 更新哈希表中的映射信息\r\n        return key_val.second;          // 返回要查询的关键字的值\r\n    }\r\n    \r\n    void put(int key, int value) \r\n    {\r\n        // 如果当前缓存中没有要放入的关键字，直接放入\r\n        if (mymap.find(key) == mymap.end())\r\n        {\r\n            // 缓存已满，则需要删除最久未访问的关键字\r\n            if (mycatch.size() == cap)              \r\n            {\r\n                mymap.erase(mycatch.back().first);  // 从哈希表中删除相应的映射\r\n                mycatch.pop_back();                 // 链表尾就是久未访问的\r\n            }\r\n        }\r\n        // 如果当前缓存中已有要放入的关键字，则需要删掉原有的，再重新放在链表头\r\n        else\r\n            mycatch.erase(mymap[key]);   \r\n        mycatch.push_front({key, value});           // 放入链表头，作为缓存最最近使用的关键字\r\n        mymap[key] = mycatch.begin();               // 更新哈希表\r\n    }\r\n};\r\n//来自terry\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846417931","body":"C++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) \r\n    {\r\n        if(root==NULL) return 0;\r\n        int left = maxDepth(root->left);\r\n        int right = maxDepth(root->right);\r\n        return max(left,right)+1;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zliu1413":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835862900","body":"思路：add K to each digit of the num. \r\n语言：python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num)-1\r\n        while(i>=0 or k>0):\r\n            if i>=0:\r\n                k += num[i]\r\n            res.append(k%10)\r\n            k = k//10\r\n            i -= 1\r\n        return res[::-1]\r\n\r\n```\r\n\r\n复杂度：\r\n时间：O(max(n,logK)), logK is the how many times that K can be divided by 10 until residual is single digit\r\n空间：O(1）\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837327271","body":"解题思路：\r\n双向遍历。两次遍历的每个位置比较大小。\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        \r\n        \"\"\"\r\n        #first attemp\r\n        cLocs = []\r\n        for idx,elem in enumerate(s):\r\n            if elem == c: \r\n                cLocs.append(idx)\r\n        \r\n        res = []\r\n        for idx, elem in enumerate(s):\r\n            res.append(min(abs(mark - idx) for mark in cLocs))\r\n        \r\n        return res\r\n        \"\"\"\r\n        # second\r\n        ref = float(inf)\r\n        distanceList = []\r\n        for i,val in enumerate(s):\r\n            if val==c: ref = i\r\n            distanceList.append(abs(ref-i))\r\n        \r\n        ref = float(inf)\r\n        for i in range(len(s)-1,-1,-1):\r\n            val = s[i]\r\n            if val==c: ref = i\r\n            distanceList[i] = min(distanceList[i],abs(ref-i))\r\n        \r\n        return distanceList\r\n\r\n```\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838833786","body":"思路：pop和push都是O(1），inc把增量单独存起来，调用pop时再把增量加上去\r\n\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.delta = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            val = self.stack.pop(-1)\r\n            inc = self.delta.pop(-1)\r\n            if len(self.delta)>0: self.delta[-1] += inc\r\n            return val+inc\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k>len(self.stack): k=len(self.stack)\r\n        if k>0: self.delta[k-1] += val\r\n```\r\n\r\n复杂度: \r\n时间 O(1)\r\n空间O(N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840126932","body":"思路：用栈存储乘数和中间结果，写的太笨了，之后再优化\r\n\r\n```Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        answer = \"\"\r\n        stackElem = []\r\n        multifier = 0\r\n        for i,elem in enumerate(s):\r\n            if elem.isdigit():\r\n                multifier = 10*multifier+int(elem)\r\n            elif elem ==\"[\":\r\n                stackElem.append([multifier,\"\"])\r\n                multifier = 0\r\n            elif elem == \"]\":\r\n                multi,val = stackElem.pop()\r\n                if len(stackElem)!=0:\r\n                    stackElem[-1][1] += multi*val\r\n                else:\r\n                    answer += multi*val\r\n            else:\r\n                if len(stackElem) != 0:\r\n                    stackElem[-1][1] += elem\r\n                else:\r\n                    answer += elem\r\n        \r\n        return answer\r\n\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840705914","body":"思路：use two stacks to implement a queue. inStack will receive data, and outStack and push the data in reverse order.\r\n\r\n```Python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def in2out(self):\r\n        while (self.instack!=[]):\r\n            self.outstack.append(self.instack.pop())\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (self.outstack==[]) & (self.instack==[])\r\n\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841511635","body":"思路: 单调栈。the minimum in the next block must be higher or equal to the max of current block. create a stack to store new max, and if come across a small number, than pop out the stack until the stack peek is smaller or equal to this small number. push the max into the stack.\r\n\r\n```Python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for v in arr:\r\n            if stack!=[] and v<stack[-1]:\r\n                head = stack[-1] # max at the moment\r\n                while stack and v<stack[-1]: stack.pop() #if current element < stack peek (previous max, each max represent a block), then merge into a single block\r\n                stack.append(head) # append the max of the newly merged block\r\n            else:\r\n                stack.append(v)\r\n\r\n        return len(stack)\r\n\r\n```\r\n复杂度：\r\n时间空间：O（N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841704089","body":"思路：我写的很蠢，断开中间的node，然后重新拼接\r\n\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        length = 1\r\n        lastNode = head\r\n        \r\n        while lastNode.next:\r\n            lastNode = lastNode.next\r\n            length += 1\r\n        \r\n        if k>=length: k=k%length\r\n\r\n        if k==0: return head\r\n\r\n        numBreak = length-k\r\n\r\n        breakNode = head\r\n        for i in range(numBreak-1):\r\n            breakNode = breakNode.next\r\n        nextListNode = breakNode.next\r\n        \r\n        lastNode.next = head\r\n        breakNode.next = None\r\n\r\n        return nextListNode\r\n```\r\n复杂度：\r\n时间：O(n）\r\n空间：O(1）\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841855289","body":"思路：迭代法，先找到终止条件，然后重复head 和newHead的交换\r\n``` Python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return head\r\n        \r\n        \"\"\" approach 1 \r\n        dummyNode = ListNode(0)\r\n        dummyNode.next = head\r\n        temp = dummyNode\r\n        while(temp.next and temp.next.next):\r\n            a = temp.next\r\n            b = a.next\r\n \r\n            a.next = b.next\r\n            b.next = a\r\n            temp.next = b \r\n            temp = a \r\n        return dummyNode.next\r\n        \"\"\"\r\n        # approach 2\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n\r\n\r\n```\r\n复杂度：\r\nO(N)\r\nO(N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842658275","body":"思路：分治\r\n```Python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head: ListNode) -> int:\r\n            count = 0\r\n            while head:\r\n                count += 1\r\n                head = head.next\r\n            return count\r\n        \r\n        def buildTree(left: int, right: int) -> TreeNode:\r\n            if left > right: return None\r\n            mid = (left + right + 1) // 2\r\n            root = TreeNode()\r\n            root.left = buildTree(left, mid - 1)\r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            root.right = buildTree(mid + 1, right)\r\n            return root\r\n        \r\n        length = getLength(head)\r\n        return buildTree(0, length - 1)\r\n\r\n\r\n```\r\n复杂度：\r\nO(N)\r\nO(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843935602","body":"分析：A+B 和 B+A长度一致\r\n\r\n```Python\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p = headA\r\n        q = headB\r\n        \r\n        while p != q:\r\n            p = p.next if p!=None else headB\r\n            q = q.next if q!=None else headA\r\n        \r\n        return p;\r\n\r\n```\r\n复杂度\r\nO(M+N）\r\nO(1）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844355707","body":"思路：fast and slow pointers\r\n``` Python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        \"\"\" approach 1\r\n        curKey = head\r\n        nodeList=set()\r\n        while curKey not in nodeList:\r\n            if curKey is None:\r\n                return None\r\n            nodeList.append(curKey)\r\n            curKey = curKey.next\r\n            \r\n        return curKey\r\n        \"\"\"\r\n        # approach 2 two pointers\r\n        fNode, sNode = head, head\r\n        \r\n        while True:\r\n            if not (fNode and fNode.next): return None\r\n            fNode = fNode.next.next\r\n            sNode = sNode.next\r\n            if fNode == sNode: break    \r\n        \r\n        fNode = head\r\n        while sNode != fNode:\r\n            sNode = sNode.next\r\n            fNode = fNode.next\r\n        \r\n        return fNode\r\n```\r\n复杂度：\r\nO(N）\r\nO(1）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845856611","body":"思路：hashmap + linkedList\r\n\r\n```Python\r\nclass DLinkdNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n\r\n        self.next = None\r\n        self.prev = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.head = DLinkdNode()\r\n        self.tail = DLinkdNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        else:\r\n            node = self.cache[key]\r\n            self.moveToHead(node)\r\n            return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n        else:\r\n            node = DLinkdNode(key=key,value=value)\r\n            self.addToHead(node)\r\n\r\n        self.cache[key] = node\r\n\r\n    def addToHead(self, node:DLinkdNode):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n\r\n        self.cache[node.key]=node\r\n        self.size += 1\r\n        if self.size > self.capacity:\r\n            self.removeNode(self.tail.prev)\r\n\r\n\r\n    def removeNode(self, node:DLinkdNode):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        self.cache.pop(node.key)\r\n        self.size -= 1\r\n\r\n\r\n    def moveToHead(self, node:DLinkdNode):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        self.removeNode(self.tail.prev)\r\n\r\n```\r\n\r\n复杂度：\r\nO(1）\r\nO(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846083721","body":"思路：recursion\r\n``` Python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n    \r\n        leftDepth = self.maxDepth(root.left)\r\n        rightDepth = self.maxDepth(root.right)\r\n        \r\n        return max(leftDepth,rightDepth) + 1\r\n```\r\n复杂度：\r\nO(N)：number of nodes\r\nO(height)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846456390","body":"思路：递归\r\n\r\n```Python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p == None and q==None: \r\n            return True\r\n        elif p == None or q==None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n\r\n```\r\n复杂度：\r\nO(min(m,n))\r\nO(min(m,n))\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joe-the-plumber":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835868625","body":"思路：using string to convert back and forth\r\n语言：python\r\n复杂度：\r\n时间：O(n)\r\n空间：O(n）\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        \r\n        number_int =  functools.reduce(lambda a,b : str(a)+str(b),num)\r\n        number_int = int(number_int) + k\r\n        \r\n        result_int_array = []\r\n        for i in str(number_int):\r\n            result_int_array.append(int(i))\r\n            \r\n        return result_int_array\r\n```\r\n\r\n            \r\n        "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837583648","body":"同上： 先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #1. find all currence of c\r\n        position_array = []        \r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                position_array.append(i)\r\n       \r\n        #duplicate the last element, we can access the right boundary more easily\r\n        position_array.append(position_array[-1])  \r\n                \r\n        #initilize the return value arrary\r\n        shortest_distance_array = [0 for _ in range(len(s))]\r\n        j1 = 0\r\n            \r\n        for i, v in enumerate(s):\r\n            shortest_distance_array[i] = min( abs( i-position_array[j1] )\r\n                                             , abs(i-position_array[j1+1] ) \r\n                                            )\r\n            #if the moving left_p(j1), right_p(j1+1) pair need to be updated    \r\n            if i==position_array[j1+1]:\r\n                # the right_p should not move out of boundary\r\n                if j1+1+1<len(position_array) :\r\n                    j1 += 1\r\n\r\n        return shortest_distance_array\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839406703","body":"Copy 了前排同学的作业。。。。\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack1 = [] # for push and pop\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack1) < self.maxSize:\r\n            self.stack1.append(x)\r\n         \r\n    def pop(self) -> int:\r\n        # check if stack is empty\r\n        if self.stack1:\r\n            #About python list\r\n            #Return Value from pop()\r\n            #The pop() method returns the item present at the given index. This item is also removed from the list.\r\n            return self.stack1.pop(-1)\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack1),k)):\r\n            self.stack1[i]+=val\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315378","body":"参照答案，写了一遍\r\nhttps://leetcode-solution-leetcode-pp.gitbook.io/leetcode-solution/medium/394.decode-string\r\n1）答案是在做inplace change。\r\n2）思路是每次遇到]，就处理了到 [, 减少了一个pair。。一直到最后\r\n\r\n复杂度\r\nTime: O(N) \r\nSpace: O(N)\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for char in s:\r\n            #need to decode at the ] , find out repeat string and count\r\n            if char == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n            \r\n                #regular char, notice we use while here\r\n                while stack and stack[-1] != '[':\r\n                        repeatStr = stack.pop() + repeatStr\r\n\r\n                #stack[-1] == '['\r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n\r\n                stack.append(repeatStr*int(repeatCount))\r\n                \r\n            else:\r\n                stack.append(char)\r\n    \r\n        return \"\".join(stack)\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960537","body":"```python\r\nclass MyQueue:\r\n# 思路\r\n# 用两个栈实现队列，一个栈用来进行读操作(push)，一个栈用来写操作(pop,empty,peek)\r\n\r\n# 栈a进行push操作\r\n# 在进行pop，peek操作的时候，如果栈b有元素，直接pop，没有的话，在栈a有元素的时候，栈a进行pop添加到栈b再进行pop\r\n# 当栈a，b为空的时候才是空的\r\n# 延伸阅读\r\n# 其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n# 当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_1 = []\r\n        self.stack_2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_2.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack_1:\r\n            while self.stack_2:\r\n                self.stack_1.append(self.stack_2.pop())\r\n        return self.stack_1.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack_1:\r\n            while self.stack_2:\r\n                self.stack_1.append(self.stack_2.pop())\r\n        return self.stack_1[-1]        \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.stack_1) + len(self.stack_2)==0\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604125","body":"抄了前排同学作业\r\n\r\n单调栈\r\n很容易会想到单调栈这以数据结构\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n\r\n**_2、当出现小于栈顶head的值时，保留当前栈顶head，抛出stack中大于arr[i]的值_**\r\nif current element < stack peek (previous max, each max represent a block),\r\nthen merge into a single block\r\n复杂度分析\r\n时间：O(N)\r\n空间：O(N)\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack_max = []\r\n        \r\n        for v in arr:                       \r\n            if stack_max!=[] and v<stack_max[-1]:\r\n                head = stack_max[-1] # max at the moment\r\n                while stack_max and v<stack_max[-1]: \r\n                    stack_max.pop() \r\n                    #if current element < stack peek (previous max, each max represent a block), then merge into a single block\r\n                stack_max.append(head) # append the max of the newly merged block\r\n            else:\r\n                stack_max.append(v)\r\n                \r\n        return len(stack_max)\r\n        \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760143","body":"自己做的，edge case需要考虑。\r\n1） k=0, k=length\r\n2)  how to set up a iterator, constructed a virtual head, which caused the calculation of length to be off a bit....\r\n\r\n时间复杂度O(N)\r\n空间复杂度O(N)\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        #find out where to break\r\n        length = 0\r\n        p_current = ListNode(-1,head)\r\n\r\n        while(p_current.next):\r\n            p_current = p_current.next\r\n            length += 1 \r\n\r\n        p_last_node = p_current\r\n        \r\n        # we need to break the kth(index from 1) node\r\n        if k!= 0 :\r\n            k = length - k%length\r\n        k =  k%length  \r\n        \r\n        pos = 0\r\n        p_current = ListNode(-1,head)\r\n        new_head = head\r\n        print(length,k)\r\n        \r\n        if k!= 0 :\r\n            while(True):\r\n                if(pos==k):\r\n                    new_head = p_current.next\r\n                    p_current.next = None\r\n                    p_last_node.next = head\r\n                    break\r\n                              \r\n                p_current = p_current.next\r\n                pos += 1 \r\n                \r\n        return new_head\r\n                    \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841887357","body":"1. Python's copy always give me headache. Everything is reference like....\r\n2. New head is always Node 2,   Need to do the follow first, otherwise, head.next get changed later....\r\n        NewHead = head.next\r\n3. Also, Edge case:\r\n\r\n        # make sure we have at least two node\r\n        if not head or not head.next:\r\n            return head\r\n\r\nComplexity: time O(N), space O(1)\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        #VirtualHead = ListNode(-1, head)\r\n        CurrentNode = head\r\n\r\n        # make sure we have at least two node\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        #New head is always Node 2\r\n        NewHead = head.next\r\n        \r\n        VirtualTail = ListNode(-1, head)\r\n        while(CurrentNode and CurrentNode.next):\r\n            #set the stage, 1,2,3\r\n            node1 =  CurrentNode\r\n            node2 =  CurrentNode.next\r\n            node3 =  node2.next\r\n            \r\n            #swith the order\r\n            node2.next = node1\r\n            node1.next = node3\r\n            \r\n            #connect to the current tail\r\n            VirtualTail.next = node2\r\n            \r\n            #update the two pointers\r\n            VirtualTail = node1   \r\n            CurrentNode = node3\r\n            \r\n        return NewHead\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842820802","body":"Copied 班主任的java code and translate into python\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if( not head) :\r\n            return None\r\n        \r\n        return self.run(head,None);\r\n\r\n    def run(self, head, tail):\r\n        if(head == tail):\r\n            return None\r\n        \r\n        fast = head\r\n        slow = head\r\n        \r\n        while(fast != tail and fast.next != tail):\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n      \r\n        root = TreeNode(slow.val)\r\n        root.left = self.run(head, slow)\r\n        root.right = self.run(slow.next, tail)\r\n        \r\n        return root\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843689942","body":"班主任的code 牛B。。。\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return b\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844716168","body":"快慢指针\r\n时间: O(n)\r\n空间: O(n)\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        \r\n        p_quick, p_slow = head, head\r\n        \r\n        while(p_quick and p_quick.next) :\r\n            p_slow = p_slow.next\r\n            p_quick = p_quick.next.next \r\n            \r\n            if p_slow==p_quick:\r\n                p_slow = head\r\n                \r\n                while(p_slow!=p_quick):\r\n                    p_slow = p_slow.next\r\n                    p_quick = p_quick.next\r\n            \r\n                return p_slow\r\n        return None\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845634751","body":"昨天睡晚了 。。今天先抄同学作业了。。。\r\n明天复习。。。\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.cache = OrderedDict()\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        t = self.cache.get(key)\r\n        if t!=None:\r\n            self.cache.move_to_end(key,last=True)\r\n            return t        \r\n        return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if self.cache.get(key)!=None:\r\n            self.cache[key]=value\r\n            self.cache.move_to_end(key,last=True)\r\n            return\r\n        if self.size==0:\r\n            self.cache.popitem(last=False)\r\n            self.size+=1\r\n        self.size-=1\r\n        self.cache[key]=value\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846334813","body":"时间复杂度：O(N)\r\n空间复杂度：O(height)\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            return max( self.maxDepth(root.left), self.maxDepth(root.right) )+1\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846471657","body":"时间: O(n)\r\n空间: O(1)\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if (not p) and (q):\r\n            return False\r\n        if (p) and (not q):\r\n            return False\r\n        if (not p) and (not q):\r\n            return True\r\n        if p.val==q.val:\r\n            return self.isSameTree(p.left,q.left) and  self.isSameTree(p.right,q.right) \r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Critsu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835891780","body":"思路：add K to each digit\r\n语言：java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837609304","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int prev = -1;\r\n        \r\n        for(int i=0; i<res.length; i++){\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = i-prev;\r\n            }else {\r\n                res[i] = Integer.MAX_VALUE;\r\n            }\r\n        }\r\n        \r\n        prev=-1;\r\n        \r\n        for(int i=res.length-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }else if(prev>-1){\r\n                res[i] = Math.min((prev-i), res[i]);\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839379247","body":"```java\r\n\r\nclass CustomStack {\r\n    Stack<Integer> stack;\r\n    int size;\r\n    int count = 0;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new Stack<>();\r\n        this.size = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count < size) {\r\n            stack.push(x);\r\n            count++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stack.empty())\r\n            return -1;\r\n        else {\r\n            count--;\r\n            return stack.pop();\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n\r\n        if(count < k) {\r\n            for(int i=0; i<count; i++) {\r\n                stack.set(i, stack.get(i)+val);\r\n            }\r\n        } else {\r\n            for(int i=0; i<k; i++)\r\n                stack.set(i, stack.get(i)+val);\r\n        }\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840132950","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> numStack = new Stack<>();\r\n        Stack<String> strStack = new Stack<>();\r\n        StringBuilder res = new StringBuilder();\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            char b = s.charAt(i);\r\n            \r\n            if(Character.isDigit(b)){\r\n                int num = b - '0';\r\n                while( i+1<s.length() && Character.isDigit(s.charAt(i+1))){\r\n                    num = num * 10 + s.charAt(i+1) - '0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(b == '['){\r\n                strStack.push(res.toString());\r\n                res = new StringBuilder();\r\n            }\r\n            else if(b==']'){\r\n                StringBuilder temp = new StringBuilder(strStack.pop());\r\n                int k = numStack.pop();\r\n                for(int j=0; j<k; j++){\r\n                    temp.append(res);\r\n                }\r\n                res = temp;\r\n            }\r\n            else{\r\n                res.append(b);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923826","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        s1.push(x);\r\n        while(!s2.isEmpty()){\r\n            s1.push(s2.pop());\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        return s1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return s1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841579627","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sort_arr = arr.clone();\r\n        Arrays.sort(sort_arr);\r\n\r\n        int diff = 0;\r\n        int ans = 0;\r\n\r\n        for(int i=0; i<arr.length; i++){\r\n            diff += arr[i] - sort_arr[i];\r\n            if(diff == 0) ans++;\r\n        }\r\n\r\n\r\n        return ans;\r\n\r\n       \r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746677","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null) return null;\r\n        ListNode temp = head;\r\n        int len = 1;\r\n        while(temp.next!=null) {temp=temp.next; len++;}\r\n        temp.next = head;\r\n        temp = head;\r\n        int moves = len - (k%len);\r\n\r\n        for(int i=1; i<moves; i++){\r\n            temp = temp.next;\r\n        }\r\n        ListNode newHead = null;\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n\r\n\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841906275","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next==null) return head;\r\n        ListNode dummy = new ListNode(-1);\r\n        ListNode curr = dummy;\r\n        curr.next = head;\r\n\r\n        while(curr.next!=null && curr.next.next!=null){\r\n            ListNode first = curr.next;\r\n            ListNode second = curr.next.next;\r\n\r\n            curr.next = second;\r\n            first.next = second.next;\r\n            second.next = first;\r\n\r\n            curr = curr.next.next;\r\n        }\r\n\r\n        return dummy.next;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842737654","body":"```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return dfs(head, null);\r\n    }\r\n\r\n    private TreeNode dfs (ListNode left, ListNode right){\r\n        if(left == right) return null;\r\n\r\n        ListNode slow = left;\r\n        ListNode fast = left;\r\n        \r\n        while(fast!=right && fast.next!=right){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n\r\n        TreeNode root = new TreeNode(slow.val);\r\n\r\n        root.left = dfs(left, slow);\r\n        root.right = dfs(slow.next, right);\r\n\r\n        return root;\r\n    }\r\n}\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843647934","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n\r\n        while(a!=b){\r\n            a = a == null? headB: a.next;\r\n            b = b == null? headA: b.next;\r\n        }\r\n\r\n        return a;\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844574437","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) return null;\r\n        \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n\r\n        while(fast!=null && fast.next!=null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n\r\n            if(fast == slow) break;\r\n        }\r\n\r\n        if(fast==null || fast.next == null) return null;\r\n\r\n        fast = head;\r\n\r\n        while(fast!=slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        return slow;\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845554320","body":"```java\r\nclass LRUCache {\r\n    class Node{\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        public Node(int k, int v){\r\n            key = k;\r\n            val = v;\r\n        }\r\n    }\r\n    \r\n    Node head;\r\n    Node tail;\r\n    Map<Integer, Node> map;\r\n    int size;\r\n    int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n         head = new Node(0,0);\r\n         tail = new Node(0,0);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        map = new HashMap<>();\r\n        size = 0;\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(map.containsKey(key)){\r\n            Node cur = map.get(key);\r\n            remove(key);\r\n            addHead(key, cur.val);\r\n            return cur.val;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)){\r\n            remove(key);\r\n            addHead(key,value);\r\n        } else{\r\n            addHead(key, value);\r\n        }\r\n    }\r\n    \r\n    private void remove(int key){\r\n        Node cur = map.get(key);\r\n        Node prev = cur.prev;\r\n        Node next = cur.next;\r\n        prev.next = next;\r\n        next.prev = prev;\r\n        map.remove(key);\r\n        size--;\r\n        \r\n    }\r\n    \r\n    private void addHead(int key, int val){\r\n        Node node = new Node(key, val);\r\n        Node next = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n        node.next = next;\r\n        next.prev = node;\r\n        map.put(key, node);\r\n        size++;\r\n        \r\n        if(size>capacity){\r\n            Node preTail = tail.prev;\r\n            remove(preTail.key);\r\n        }\r\n    }\r\n    \r\n   \r\n}\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846311467","body":"```java\r\n\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n       return dfs(root);\r\n    }\r\n    \r\n    private int dfs(TreeNode root){\r\n        if(root == null) return 0;\r\n        \r\n        int left = dfs(root.left);\r\n        int right = dfs(root.right);\r\n        \r\n        return Math.max(left, right) + 1;\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835892157","body":"# Logic:\r\n```\r\nGo backward from the end of num (the least significant digit) \r\nwhile num still has unprocessed digits or k still has unprocessed digits:\r\n    get k's lowest digit \r\n    update k (k = 0 would be fine)\r\n    \r\n    # add up the current sum for the current digit\r\n    if (no digit to use in num): no need to add from num \r\n    else: add up the current sum for the current digit, decrement the index in num\r\n    \r\n    get carry\r\n    insert to the sum list\r\n    \r\nif (carry == 1): insert at sum list's head\r\n```\r\n# Caveats:\r\nStart from the least significant digit in num (go backward), consider carry, what if k's len is longer/shorter, use linkedlist.addFirst()\r\n\r\n[0]\r\n23\r\n\r\n# Complexity:\r\nTime: O(max(num.length, num of digits in k))\r\n\r\nSpace: O(max(num.length, num of digits in k)) if we consider the output list; otherwise O(1)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int carry = 0;\r\n        while (index >= 0 || k != 0) {\r\n            int curDigit = k % 10;\r\n            k = k / 10;\r\n            \r\n            if (index == -1) {\r\n               curDigit += carry; \r\n            } else {\r\n                curDigit += num[index--] + carry;\r\n            }\r\n            carry = curDigit / 10;\r\n            sum.addFirst(curDigit % 10);\r\n        }\r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838725255","body":"# Logic:\r\n```\r\ntraverse from the left to find matchPos (the closest match on the current index's left)\r\n- update for each index in s\r\n\r\ntraverse from the right (the closest match on the current index's right)\r\nno need to update the elements after the matchPos, because they have no match on the right\r\n- update for each index in s\r\n```\r\n\r\ns = \"loveleetcode\", c = \"e\"\r\nIt is guaranteed that c occurs at least once in s.\r\n\r\n\"aaba\"\r\n\"b\"\r\n\r\n# Complexity:\r\nTime: O(2n) -> O(n), n is the length of S\r\nSpace: O(1) - if we do not consider the output array\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] dist = new int[s.length()];\r\n        int matchPos = -s.length(); // the closest c position\r\n        // traverse from the left to find matchPos (the closest match on the current index's left)\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = i - matchPos;\r\n        }\r\n        // traverse from the right (the closest match on the current index's right)\r\n        // no need to update the elements after the matchPos, because they have no match on the right\r\n        for (int i = matchPos - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                matchPos = i;\r\n            }\r\n            dist[i] = Math.min(matchPos - i, dist[i]);\r\n        }\r\n        return dist;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839880724","body":"\r\n# Logic:\r\ncapacity : the max capacity of the stack\r\nsize : the current size of stack\r\nuse array to store elements\r\n\r\nPush: if it is not full, push, size++\r\nPop: if it is empty, return -1; else pop(), size--\r\nIncrement: iterate based on min(k, size) and increment \r\n\r\n// https://www.techiedelight.com/iterate-through-stack-java/\r\n\r\n# Complexity:\r\nTime: Pop, Push O(1); Increment O(min(k, size)) \r\nSpace: O(1)\r\n    \r\n\r\n# Code:\r\n```\r\nclass CustomStack {\r\n\r\n    int capacity;\r\n    int size;\r\n    int[] stack; \r\n\r\n    public CustomStack(int maxSize) {\r\n        capacity = maxSize;\r\n        size = 0;\r\n        stack = new int[capacity];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < capacity) {\r\n            stack[size] = x;\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) return -1;\r\n        size--;\r\n        return stack[size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, size); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653980","body":"# Logic: \r\n\r\nUse two stacks:\r\n(freqStack) to store the integer (freqStack)\r\n(strStack) to store the previous stringbuilders (we append the current string which has been repeated for freqStack.pop() times to strStack.pop())\r\n\r\ncurrent string: use StringBuilder()\r\n```\r\ns contains 3 cases:\r\n1. a digit which comes before '['- make sure to make \"123\" -> 123\r\n\r\n2. [: \r\npush the number to freqStack, push current string to strStack\r\nreset the number, reset the current string\r\n\r\n3. ]: \r\nset temp = cur\r\ncur = strStack.pop()\r\nfreq = freqStack.pop()\r\ncur.append(temp) for freq times\r\n\r\n4. letter: append to the current string\r\n```\r\n# Complexity:\r\nTime: O(n), n is the length of decoded S\r\n\r\nSpace: O(n), n is the length of decoded S\r\n\r\nNote: \"1[a]\" is valid\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<StringBuilder> strStack = new Stack<>();\r\n        Stack<Integer> freqStack = new Stack<>();\r\n        \r\n        StringBuilder cur = new StringBuilder();\r\n        int num = 0;\r\n\r\n        // do not use while to get multi-digit num, e.g. \"321\"\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if (c == '[') { // reach the end of number str\r\n                freqStack.push(num);\r\n                num = 0;\r\n                // \"abc3[cd]xyz\", deal with cur\r\n                strStack.push(cur);\r\n                cur = new StringBuilder();\r\n            } else if (c == ']') { // \"3[a2[c]]\"\r\n                StringBuilder temp = cur; //\"c\"\r\n                cur = strStack.pop();\r\n                int iter = freqStack.pop();\r\n                for (int i = 0; i < iter; i++) {\r\n                    cur.append(temp);\r\n                }                \r\n            } else { // see a letter\r\n                cur.append(c);\r\n            }\r\n            \r\n        }\r\n        return cur.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841319623","body":"# Logic:\r\n1. popStack is only responsible for the queue's pop op AND peek op\r\n2. pushStack is only responsible for the queue's push op\r\n\r\nBefore push, feed all elements from popStack if any to pushStack, then push into pushStack\r\nBefore pop/peek, feed all elements from pushStack if any to popStack, then pop/peek from popStack\r\nEmpty: check if both are empty\r\n```\r\ncase: \r\npush 1,2,3,4\r\npop (get 1)\r\npush 5\r\npop (get 2)\r\n```\r\n# Complexities:\r\nTime: \r\nPush/pop/peek: O(N) for N elements, O(1) amortized\r\nisEmpty: O(1)\r\n\r\nSpace: O(N)\r\n\r\n# Code:\r\n```\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> pushStack, popStack;\r\n    \r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        pushStack = new Stack<>();\r\n        popStack = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        \r\n        pushStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        \r\n        return popStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n         while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        \r\n        return popStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return pushStack.isEmpty() && popStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682692","body":"# Logic:\r\nMonotonic stack: \r\n- if subarray is not monotonically increasing, len to split = subarray.length\r\n- if subarray is not monotonically decreasing, len to split = 1\r\n\r\nEdge case:  [5,3,3,2,1,1]  -> 1\r\n\r\nmake sure the following block's min > min from its precedent blocks\r\n\r\n- \"融合区块\", 栈内每一个元素代表一个块，而栈里面的每一个元素的值就是块的最大值。(西法原创)\r\n\r\n- [2,1,3,4,4]， stack 的变化过程：\r\n\r\n[2]\r\n1 被融合了，保持 [2] 不变\r\n[2,3]\r\n[2,3,4]\r\n[2,3,4,4]\r\n将一个减序列压缩合并成最该序列的最大的值。 \r\n\r\n# Complexity:\r\nTime: O(arr.length)\r\nSpace: O(arr.length)\r\n\r\n# Code:\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && stack.peek() > num) {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > num) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            } else {\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841835819","body":"# Logic:\r\nfirst get len\r\nk = k % len\r\n\r\nafter newEnd, k nodes, traverse len - k - 1 times\r\n[newEnd | newHead, remaining k-1 nodes]\r\n\r\nfind tail of the second half, CUT AND RECONNECT\r\n\r\n# Complexity:\r\nTime: O(N), N = list len\r\nSpace: O(1)\r\n\r\n# Code:\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // edge cases\r\n        if (head == null || head.next == null) return head;\r\n        \r\n        int len = getLen(head);\r\n        k = k % len;\r\n        \r\n        // edge case\r\n        if (k == 0) return head;\r\n        \r\n        ListNode newEnd = head;\r\n        for (int i = 0; i < len - k - 1; i++) {\r\n            newEnd = newEnd.next;\r\n        }\r\n        ListNode newHead = newEnd.next;\r\n        // cut \r\n        newEnd.next = null;\r\n        // find tail\r\n        ListNode tail = newHead;\r\n        while (tail.next != null) {\r\n            tail = tail.next;\r\n        }\r\n        // reconnect\r\n        tail.next = head;\r\n        \r\n        return newHead;\r\n    }\r\n    \r\n    private int getLen(ListNode head) {\r\n        ListNode cur = head;\r\n        int len = 0;\r\n        while (cur != null) {\r\n            len++;\r\n            cur = cur.next;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842422388","body":"# Logic:\r\nuse a dummy head pointing to head -> cur\r\nfirst = head, second = head.next\r\n```\r\nwhile (first != null && second != null) {\r\n        ListNode next = second.next;\r\n        // cur->second->first->.. swap\r\n        // move to next pair, note the edge case: even number of nodes\r\n}\r\n```\r\n\r\n# Complexity:\r\nTime: O(N), N = list len\r\nSpace: O(1)\r\n\r\n# Tests:\r\n```\r\n// 1 -> 2 -> 3\r\n\r\n//c f.  s    n\r\n\r\n\r\n//0 ->2->1->3\r\n//       c  f. \r\n// 1->2\r\n```\r\n\r\n# Code:\r\n```\r\n  public class ListNode {\r\n      int val;\r\n      ListNode next;\r\n      ListNode() {}\r\n      ListNode(int val) { this.val = val; }\r\n      ListNode(int val, ListNode next) { this.val = val; this.next = next; \r\n}\r\n\r\n\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // edge cases\r\n        if (head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = new ListNode(0, head);\r\n        ListNode cur = dummy;\r\n        ListNode first = head, second = first.next;\r\n        while (first != null && second != null) {\r\n            ListNode next = second.next;\r\n            \r\n            cur.next = second;\r\n            second.next = first;\r\n            first.next = next;\r\n            \r\n            cur = first;\r\n            first = next;\r\n            if (first == null) break; // edge case: even number of nodes\r\n            second = first.next;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842842665","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n```\r\n# Logic:\r\npartition: partition the linkedlist into three parts [left, root, right] and return the head of left and right, remember to break up the links\r\n\r\ndummy node and fast/slow pointers\r\nx |y| z\r\n\r\nrecursiveTreeBuild(ListNode head): \r\nconstruct the root, pointing root to left and right subtrees (call recursion to build the subtrees)\r\n\r\nNote the edge cases (0 node and 1 node only)\r\n\r\n# Complexity:\r\nTime: \r\nlogn terms{} in total, inside {} is n\r\n{O(n)} + {O(n/2) + O(n/2)} + {O(n/4) + O(n/4) + O(n/4) + O(n/4)} ...+ {O(1)+ ..+ O(1)}= \r\n\r\nO(nlogn), n = linkedlist length\r\n\r\n【T(n)=2*T(n/2) + n/2, +n/2 for traversing the middle point】\r\n\r\nSpace: for the stack depth, each depth uses a list of len 3\r\nO(logn) * 3 (for 3 variables) = O(logn)\r\n\r\n# Test:\r\n```\r\n[-10,-3,0,5,9]\r\n sf  s  fs  f\r\n \r\n -10 -> -3                 \r\n sf     s       f\r\n pre\r\n \r\n 0\r\n 5 -> 9\r\n \r\n -10.\r\n sf\r\n -3\r\n null\r\n```\r\n# Code:\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // edge cases\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        \r\n        return recursiveTreeBuild(head); \r\n    }\r\n    \r\n    private TreeNode recursiveTreeBuild(ListNode head) {\r\n        if (head == null) return null;\r\n        List<ListNode> leftRootRight = partition(head);\r\n        TreeNode root = new TreeNode(leftRootRight.get(1).val);\r\n        \r\n        // build left subtree\r\n        TreeNode left = recursiveTreeBuild(leftRootRight.get(0));\r\n        \r\n        // build right subtree\r\n        TreeNode right = recursiveTreeBuild(leftRootRight.get(2));\r\n        \r\n        // connect the root with both subtrees\r\n        root.left = left;\r\n        root.right = right;\r\n        \r\n        return root;\r\n    }\r\n    \r\n    \r\n    private List<ListNode> partition(ListNode head) {\r\n        List<ListNode> leftRootRight = new ArrayList<>();\r\n        ListNode dummy = new ListNode(0, head);\r\n        // edge cases\r\n        if (head == null) {\r\n            leftRootRight.add(null);\r\n            leftRootRight.add(null);\r\n            leftRootRight.add(null);\r\n            return leftRootRight;\r\n        }\r\n        // one node only\r\n        if (head.next == null) {\r\n            leftRootRight.add(null);\r\n            leftRootRight.add(head);\r\n            leftRootRight.add(null);\r\n            return leftRootRight;\r\n        }\r\n\r\n        leftRootRight.add(head); // head of left part\r\n        \r\n        ListNode fast = head, slow = head, pre = dummy;\r\n        while(fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            pre = pre.next;\r\n        }\r\n        leftRootRight.add(slow); // middle node as the root\r\n        leftRootRight.add(slow.next); // head of the right part\r\n        \r\n        // break before and after slow\r\n        pre.next = null;\r\n        slow.next = null;\r\n        \r\n        return leftRootRight;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843776979","body":"# Logic:\r\nGet len(A), len(B)\r\nassume A is longer (otherwise swap)\r\n\r\nfast pointer moves len(A) - len(B) in A\r\nslow starts at 0 in B\r\n\r\nfast and slow move 1 step until they meet at the intersection\r\n\r\n# Complexity:\r\n\r\nTime: O(len(A) + len(B))\r\nSpace:O(1)\r\n\r\n# Code:\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int lenA = getLen(headA);\r\n        int lenB = getLen(headB);\r\n        if (lenA < lenB) {\r\n            ListNode temp = headA;\r\n            headA = headB;\r\n            headB = temp;\r\n        }\r\n        ListNode fast = headA, slow = headB;\r\n        for (int i = 0; i < Math.abs(lenA - lenB); i++) {\r\n            fast = fast.next;\r\n        }\r\n        while (fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n    \r\n    private int getLen(ListNode head) {\r\n        if (head == null) return 0;\r\n        if (head.next == null) return 1;\r\n        int len = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            len++;\r\n            cur = cur.next;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844727191","body":"# Logic:\r\nfast: 2 steps/time -> second run: 1 step/time\r\nslow: 1 step/time\r\n\r\nIllustration: \r\nhttps://drive.google.com/file/d/16PsamYHASN4-wetKwn39zrNX00NivoZe/view?usp=sharing\r\n\r\nwhen they first meet, start fast from head while slow remains there\r\nwhen they meet again, they meet at where the circle starts\r\n\r\ncaveat: put if inside while!\r\n\r\n# Complexity:\r\nTime: O(list.len)\r\nSpace:O(1)\r\n\r\n# Code:\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                fast = head;\r\n                while (fast != slow) {\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                return fast;\r\n            }\r\n        }\r\n        // they do not meet\r\n        return null;\r\n        \r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845666698","body":"# Logic:\r\nHashMap<Integer, Node>\r\nInside linkedlist, Node stores key, val, pre, next\r\n\r\nput: insert new records to head of linkedlist, update hashmap (if key exists, then its value gets replaced, delete the old value from linkedlist) (2 cases, note how space changes)\r\n\r\nwhen space == 0, remove the record from tail, remove that key from hashmap, space++\r\n\r\nat the end of Put, space--\r\n\r\nget: move the node to head of linkedlist\r\n\r\n# Complexity:\r\nTime:get/put: O(1)\r\nSpace: hashmap and linkedlist O(n), n = capacity\r\n\r\n# Code:\r\n```\r\nclass LRUCache {\r\n    int space;\r\n    HashMap<Integer, Node> cache = new HashMap<>();\r\n    Node head = new Node(-1, -1, null, null);\r\n    Node tail = new Node(-1, -1, null, null);\r\n    \r\n    class Node {\r\n        int key;\r\n        int val;\r\n        Node next;\r\n        Node pre;\r\n        Node(int key, int val, Node next, Node pre) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.next = next;\r\n            this.pre = pre;\r\n        }\r\n    }\r\n\r\n    public LRUCache(int capacity) {\r\n        space = capacity; // remaining size\r\n        head.next = tail;\r\n        tail.pre = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!cache.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        Node cur = cache.get(key);\r\n        // update the connections\r\n        Node curPre = cur.pre;\r\n        Node curNext = cur.next;\r\n        curPre.next = curNext;\r\n        curNext.pre = curPre;\r\n        \r\n        // move cur to head\r\n        Node curFirst = head.next;\r\n        head.next = cur;\r\n        cur.next = curFirst;\r\n        cur.pre = head;\r\n        curFirst.pre = cur;\r\n        return cur.val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            Node oldNode = cache.get(key);\r\n            // remove that from linkedlist\r\n            Node preNode = oldNode.pre;\r\n            Node nextNode = oldNode.next;\r\n            preNode.next = nextNode;\r\n            nextNode.pre = preNode;\r\n            // remove from cache\r\n            cache.remove(key, oldNode);\r\n            space++;\r\n        } \r\n        \r\n         // no space, then remove from tail, update hashmap and space\r\n        if (space == 0) {\r\n            Node curLast = tail.pre;\r\n            Node newLast = curLast.pre;\r\n            \r\n            newLast.next = tail;\r\n            tail.pre = newLast;\r\n            \r\n            cache.remove(curLast.key, curLast);\r\n            space++;\r\n        }\r\n        // insert to head if there is capacity\r\n        Node cur = new Node(key, value, null, head);\r\n        Node curFirst = head.next;\r\n        head.next = cur;\r\n        cur.next = curFirst;\r\n        cur.pre = head;\r\n        curFirst.pre = cur;\r\n        \r\n        cache.put(key, cur);\r\n        space--;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846354702","body":"# Logic:\r\nrecursion\r\n\r\n# Complexity:\r\nTime: O(n), n = number of nodes\r\nSpace: O(depth), O(logn) on average, O(n) worst in degenerate tree\r\n\r\n# Code:\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        \r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846507202","body":"# Method 1: \r\nRecursion\r\nTime Complexity: \r\nO(n), n = number of nodes in the smaller tree\r\n\r\nSpace Complexity:\r\nO(logn) on average, O(n) in degenerate tree\r\n\r\n# Method 2:\r\nLevel-order traversal\r\n\r\nInsert into the same queue\r\npull out one single level for each tree and compare\r\nsize for each level, the corresponding value\r\nthis queue can contain null\r\n\r\ncase: \r\n[1,2]\r\n[1,null,2]\r\n\r\n[1,2,1]\r\n[1,1,2]\r\n\r\nTime Complexity: \r\nO(n), n = number of nodes in the smaller tree\r\n\r\nSpace Complexity:\r\nO(the widest level of nodes), if balanced, O((n+1)/2) = O(n)\r\n\r\n\r\n# Method 3:\r\npreorder and inorder traversal the same -> the same tree\r\nsave the int into two lists and compare\r\n\r\nTime Complexity: \r\nO(n), n = number of total nodes \r\n\r\nSpace Complexity:\r\nO(n), n = number of total nodes \r\n\r\nCaveat: https://stackoverflow.com/questions/12547201/comparing-integer-objects\r\n\r\n# Code:\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n\r\nclass Solution {\r\n    // method 1: recursion\r\n    public boolean isSameTree1(TreeNode p, TreeNode q) {\r\n        // both null\r\n        if (p == null && q == null) return true;\r\n        // one of them is null\r\n        if (p == null || q == null) return false;\r\n        // cur val not equal, cur val equal need to go deeper to compare\r\n        if (p.val != q.val)  return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n    \r\n    // method 2: bfs\r\n    public boolean isSameTree2(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        Queue<TreeNode> nodeQueueP = new LinkedList<>();\r\n        Queue<TreeNode> nodeQueueQ = new LinkedList<>();\r\n        // queues can contain null later\r\n        nodeQueueP.offer(p);\r\n        nodeQueueQ.offer(q);\r\n        \r\n        while (!nodeQueueP.isEmpty() && !nodeQueueQ.isEmpty()) {\r\n            int sizeP = nodeQueueP.size();\r\n            int sizeQ = nodeQueueQ.size();\r\n            // level size not equal\r\n            if (sizeP != sizeQ) {\r\n                return false;\r\n            }\r\n            for (int i = 0; i < sizeP; i++) {\r\n                TreeNode curP = nodeQueueP.poll();\r\n                TreeNode curQ = nodeQueueQ.poll();\r\n                // both null\r\n                if (curP == null && curQ == null) {\r\n                    continue;\r\n                }\r\n                // one is null\r\n                if (curP == null || curQ == null) {\r\n                    return false;\r\n                }\r\n                // neither null\r\n                if (curP.val != curQ.val) {\r\n                    return false;\r\n                }\r\n                else { \r\n                    nodeQueueP.offer(curP.left);\r\n                    nodeQueueP.offer(curP.right);\r\n                \r\n                    nodeQueueQ.offer(curQ.left);\r\n                    nodeQueueQ.offer(curQ.right);\r\n                }\r\n                \r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    // method 3: preorder and inorder\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        // preorder\r\n        List<Integer> pretraversalP = new ArrayList<>();\r\n        List<Integer> pretraversalQ = new ArrayList<>();\r\n        preorder(p, pretraversalP);\r\n        preorder(q, pretraversalQ);\r\n        \r\n        // inorder\r\n        List<Integer> intraversalP = new ArrayList<>();\r\n        List<Integer> intraversalQ = new ArrayList<>();\r\n        inorder(p, intraversalP);\r\n        inorder(q, intraversalQ);\r\n        \r\n        return (pretraversalP+\"\").equals((pretraversalQ+\"\")) && (intraversalP+\"\").equals((intraversalQ+\"\"));\r\n        \r\n        // return compareLists(pretraversalP, pretraversalQ) && compareLists(intraversalP, intraversalQ);\r\n        \r\n    }\r\n    \r\n    private void preorder(TreeNode root, List<Integer> traversal) {\r\n        if (root == null) {\r\n            traversal.add(null);\r\n            return;\r\n        }\r\n        traversal.add(root.val);\r\n        preorder(root.left, traversal);\r\n        preorder(root.right, traversal);\r\n    }\r\n    \r\n    private void inorder(TreeNode root, List<Integer> traversal) {\r\n        if (root == null) {\r\n            traversal.add(null);\r\n            return;\r\n        }\r\n        preorder(root.left, traversal);\r\n        traversal.add(root.val);\r\n        preorder(root.right, traversal);\r\n    }\r\n    \r\n    private boolean compareLists(List<Integer> list1, List<Integer> list2) {\r\n        if (list1.size() != list2.size()) {\r\n            return false;\r\n        }\r\n        for (int i = 0; i < list1.size(); i++) {\r\n            // null\r\n            if (list1.get(i) == null && list2.get(i) == null) {\r\n                continue;\r\n            }\r\n            if (list1.get(i) == null || list2.get(i) == null) {\r\n                return false;\r\n            }\r\n            if (!list1.get(i).equals(list2.get(i))) { // do not use == here\r\n                System.out.println(list1.get(i));\r\n                System.out.println(list2.get(i));\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835903934","body":"### 思路\r\n\r\n1. Convert the array to string\r\n2. convert the string to integer for addition. \r\n3. Convert integer to array.\r\n\r\n### 代码\r\nPython\r\n\r\n\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = \"\"\r\n        for i in num:\r\n            a+=str(i)\r\n        x = int(a)+k\r\n        newList = [int(i) for i in str(x)]\r\n        return newList \r\n\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(n)\r\n- Space：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839406435","body":"#### 思路\r\n*  increment 注意取当前长度与k的最小值\r\n*  pop, push 后注意更新current position\r\n#### code\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.maxSize = maxSize\r\n        self.current = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.current < self.maxSize: \r\n            self.stack[self.current] = x\r\n            self.current += 1\r\n            \r\n\r\n    def pop(self) -> int:\r\n        if self.current > 0:\r\n            self.current -= 1\r\n            return self.stack[self.current]\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.current, k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n**复杂度分析**\r\n- Time：O(maxSize)\r\n- Space：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840305939","body":"#### 思路\r\n* 两个栈， 一个存string repeat的次数， 一个存string。 遇到 ]  pop\r\n* code太丑了，脑子没了\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        times = []\r\n        time = \"\"\r\n        for n, i in enumerate(s):\r\n            current = ''\r\n            if i.isdigit():\r\n                time += i\r\n                if not s[n+1].isdigit():\r\n                    times.append(int(time))\r\n                    time = \"\"\r\n            else:\r\n                if i == ']':\r\n                    t = times.pop()\r\n                    v = stack.pop()\r\n                    for j in range(t):\r\n                        current += v\r\n                    stack.pop()\r\n                    if len(stack)>0 and stack[-1] != '[':\r\n                        stack[-1] += current\r\n                    else:\r\n                        stack.append(current)\r\n                elif i == '[':\r\n                    stack.append(i)\r\n                else:\r\n                    if len(stack) == 0:\r\n                        stack.append('[')\r\n                        stack.append(i)\r\n                        times.append(1)\r\n                    elif(stack[-1] != '['):\r\n                        stack[-1] += i\r\n                    else:\r\n                        stack.append(i)\r\n        return stack[-1]\r\n```\r\n#### 复杂度\r\nTime: O(N) N = len(s)\r\nSpace: O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841009281","body":"### 思路\r\n* 两个栈, 一个作为push的入口，一个作为pop的出口\r\n* pop时，如果出口栈不为空，直接pop。如果为空，入口栈所有元素压入出口栈后，pop出口栈\r\n* peek同pop，返回出口栈最后一个元素\r\n* 如果两个栈都为空返回true\r\n### code\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stackpush = []\r\n        self.stackpop = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stackpush.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        while not self.stackpop:\r\n            while self.stackpush:\r\n                self.stackpop.append(self.stackpush.pop())\r\n        return self.stackpop.pop()\r\n            \r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        while not self.stackpop:\r\n            while self.stackpush:\r\n                self.stackpop.append(self.stackpush.pop())\r\n        return self.stackpop[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not(bool(self.stackpop) or bool(self.stackpush))\r\n```\r\n\r\n### 复杂度\r\n* Time：empty = push = O(1), 出口栈不为空时 peek = pop = O(1), 只有不为空时 = O(N)。均摊后为O(1) \r\n* Space：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841608951","body":"#### 思路\r\n* 单调栈\r\n* 每个chunk内部排序后再进行chunk合并后生成sorted array\r\n* 遍历数组\r\n    * 如果栈为空或当前值大于等于栈顶元素值，生成新chunk（压入）\r\n    * 如果小于，储存栈顶元素后执行出栈，直到当前元素大于等于更新后的栈顶元素后停止。压入之前储存的元素\r\n* 遍历结束后，栈中元素个数就为chunk个数\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        monostack = []\r\n        for i in range(len(arr)):\r\n            if not monostack or monostack[-1] <= arr[i]:\r\n                monostack.append(arr[i])\r\n            else:\r\n                tmp = monostack.pop()\r\n                while monostack and monostack[-1] > arr[i]:\r\n                    monostack.pop()\r\n                monostack.append(tmp)\r\n        return len(monostack)\r\n```\r\n\r\n#### 复杂度\r\n* Time = O(N)\r\n* Space = O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746730","body":"### 思路\r\n* 如果head is None，返回head\r\n* 将链表首位相接变为循环链表并得到链表长度\r\n* 从原head位开始寻找新head（if index == length-k）\r\n* 如果当前位的下一位是新头部，储存新head，并切断当前node与node.next（新head）之间的link。返回新head\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n\r\n        # if head is null, return head\r\n        if not head:\r\n            return head\r\n        \r\n        # Get length and connect the last and head to change NodeList to a circular NodeList \r\n        length = 1\r\n        newNode = head\r\n        while(newNode.next):\r\n            newNode = newNode.next\r\n            length += 1\r\n        newNode.next = head\r\n\r\n        # get real cut index\r\n        k = k % length\r\n\r\n       # find new head\r\n        index = 0\r\n        returnNode = None\r\n        while(True):\r\n            if index == length-k:\r\n                returnNode = newNode.next\r\n                newNode.next = None\r\n                return returnNode\r\n            index += 1\r\n            newNode = newNode.next \r\n```\r\n\r\n### 复杂度\r\n* Time： O(N)\r\n* Space：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841878504","body":"#### 思路\r\n* 迭代\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \r\n        # if null node or only one node in list, return head\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        # dummy head \r\n        newHead = ListNode(0)\r\n        newHead.next = head\r\n        temp = newHead\r\n        \r\n        # at least 2 nodes remain after temp\r\n        while temp.next and temp.next.next:\r\n            \r\n            node1 = temp.next\r\n            node2 = node1.next\r\n            temp.next = node2\r\n  \r\n            # swap node 1 and node 2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        \r\n        return newHead.next \r\n```\r\n\r\n#### 复杂度\r\n* Time：O(N)\r\n* Space：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842607503","body":"#### 思路\r\n* 快慢指针， 递归\r\n    * base case: none -> none, 只有一个node->Root-tree\r\n    * 选择中间节点作为root，root左侧为left subtree，右侧为right subtree（可保证左右tree高度相差不大于1）\r\n    * 快慢指针寻找中点，fast每次走两个node，slow走一个node。\r\n    * fast走到结尾，slow.next（mid）就是当前树的root\r\n    * 切断slow位置和mid的link后，左树nodeList为head，右树为mid.next\r\n    * 对于每一个子树，递归寻找中间节点与左右子树\r\n\r\n#### Code\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        # base case 1: null node\r\n        if not head:\r\n            return\r\n        # base case 2: only one node\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        else:\r\n            # slow and fast pointers\r\n            fast, slow = head.next.next, head\r\n            \r\n            # find the middle node\r\n            while fast and fast.next:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            mid = slow.next\r\n            \r\n            # cut off the middle node and the rest of the listNodes\r\n            slow.next = None\r\n            \r\n            # the middle node as the root for the current tree\r\n            root = TreeNode(mid.val)\r\n            \r\n            # left subtree recursion\r\n            root.left = self.sortedListToBST(head)\r\n            \r\n            # right subtree recursion\r\n            root.right = self.sortedListToBST(mid.next)\r\n            return root\r\n```\r\n\r\n#### 复杂度\r\n* Time：O(nlogn)，n = length of ListNode\r\n* Space：O(logn)，logn = 树的最大深度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843693785","body":"#### 思路\r\n* 双指针\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if headA is None or headB is None:\r\n            return None\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n#### 复杂度\r\n* Time：O(N)\r\n* Space：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844727236","body":"#### 思路\r\n* 快慢指针, 参考题解\r\n\r\n````python\r\n if not head:\r\n            return None\r\n        slow, fast = head, head\r\n        flag = False\r\n        while slow.next and fast.next and fast.next.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                flag = True\r\n                break\r\n        if not flag:\r\n            return None\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n````\r\n\r\n#### 复杂度\r\nTime: O(N)\r\nSpace：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845437879","body":"#### 思路\r\n* 参考题解\r\n* 双向链表， 哈希表\r\n* get过的node在最前面，超出capacity移除尾端node与hashtable中此node\r\n* help functions:\r\n    *  append到head\r\n    *  删除当前节点\r\n    * 删除尾部节点并返回key\r\n\r\n```python\r\nclass Node:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.val = v\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0 # current size\r\n        self.head = Node(0, 0)\r\n        self.tail = Node(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.data = {} # dictionary as hashtable\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        # if key exists, move the node to head of the ListNode\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        # if key exists, update the value and move the node to head of the ListNode\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            node.val = value\r\n            self.remove(node)\r\n            self.append(node)\r\n        # if does not exist:\r\n        #   1. add node to hashtable\r\n        #   2. check  capacity\r\n        #   3. if full, remove the tail node\r\n        #   4. add node to the head of the ListNode\r\n        else:\r\n            node = Node(key, value)\r\n            self.data[key] = node\r\n            if self.size < self.capacity:\r\n                self.size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n            self.append(node)   \r\n\r\n    # connect the previous node and next node of the pass-in node\r\n    def remove(self, node: Node) -> None:\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    # append to the head of the ListNode\r\n    def append(self, node: Node) -> None:\r\n        first = self.head.next\r\n        self.head.next = node\r\n        node.prev = self.head\r\n        node.next = first\r\n        first.prev = node\r\n\r\n    # remove the tail node of the ListNode\r\n    def removeTail(self) -> int:\r\n        key = self.tail.prev.key\r\n        self.remove(self.tail.prev)\r\n        return key\r\n\r\n```\r\n\r\n#### 复杂度\r\n* Time：O(1)\r\n* Space：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846204477","body":"#### 思路\r\n递归 DFS\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n#### 复杂度\r\n* Time: O(N)\r\n* Space:  O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846461320","body":"#### 思路\r\n* DFS\r\n\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n#### 复杂度\r\n* Time: O(N)\r\n* Space: O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835920262","body":"## LC 989. Add to Array-Form of Integer\r\n\r\n### 思路\r\n\r\n循环处理 k 和 num  \r\n让 k 的每一位和 num 对应的 digit 相加  \r\n并且记录是否需要进位  \r\n需要注意一些特殊 case 的处理\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let i = num.length - 1\r\n  let carry = false;\r\n\r\n  while(k > 0 || i >= 0){\r\n    let curDigit = k % 10\r\n    k = Math.floor(k / 10)\r\n\r\n    //此处注意可能有i <0 的情况，所以 || 0\r\n    //corner case: [0] 233\r\n    let newDigit = curDigit + (num[i]||0)\r\n\r\n    //如果需要进位\r\n    if(carry){\r\n      newDigit++\r\n      carry = false;\r\n    }\r\n\r\n    //判断是否需要进位\r\n    if(newDigit >=10){\r\n      carry = true;\r\n      newDigit = newDigit % 10\r\n    }\r\n\r\n    //同样需要处理 i< 0 的情况\r\n    i >= 0 ? num[i] = newDigit : num.unshift(newDigit)\r\n    i--\r\n  }\r\n\r\n  //最后看看是否需要进位\r\n  //corner case: [9,9] 1\r\n  if(carry) num.unshift(1)\r\n\r\n  return num;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N) </br>\r\n空间复杂度：O(1) 只保存了常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836997697","body":"## LC 821. Shortest Distance to a Character\r\n\r\n- Shortest Distance to a Character\r\n  - [遍历两次](#思路-遍历两次)\r\n  - [暴力](#思路-暴力)\r\n  - [双指针](#思路-双指针)\r\n  - [窗口](#思路-窗口)\r\n\r\n### 思路 遍历两次\r\n\r\n漾宝真棒！么么哒  \r\n遍历两次，一次从左到右，另一次反方向  \r\n遍历的时候分别记录从左到右和从右到左的该 s[i]对 c 的距离\r\n并且保留较小的那个\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //greedy\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    //处理一下i == 0 的情况，不然的话res[i -1] => NaN\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    //res[i + 1] 是这个数组中右边的那一位\r\n    //如果res[i] == Infinity 就说明这个i的左边没有e\r\n    //或者 res[i + 1] + 1 < res[i]说明这个res[i]离右边的更近\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 暴力\r\n\r\n暴力  \r\n先遍历数组，求出所有 c 的 index  \r\n然后再遍历数组，遇到跟 c 不同的时候，遍历 targetIndex 里的数组，求最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //brutal force\r\n  const res = [];\r\n  const targetIndex = [];\r\n  //iterate through s to get the indexs of c\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] == c) targetIndex.push(i)\r\n  }\r\n  //iterate through s to see wether a character is c\r\n  //if it is c, then the corresponding output should be 0\r\n  //if it is not c, then iterate through the targetIndex array\r\n  //    find the min of current char's index and all the target's index\r\n  //英文写真长啊下次还是打中文吧...\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != c){\r\n      let temp = Infinity;\r\n      for(let t = 0; t < targetIndex.length; t++){\r\n          temp = Math.min(temp, Math.abs(i - targetIndex[t]))\r\n      }\r\n      res.push(temp)\r\n    }else{\r\n      res.push(0)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N * M)$ M 是 c 的在 s 中的次数</br>\r\n空间复杂度：O(M) M 为 s 中 c 的个数\r\n\r\n### 思路 双指针\r\n\r\n双指针  \r\n在遍历 s 中遇到非 c 的时候，  \r\n派两个指针去寻找左边和右边的 c，并且计算最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  //two pointers\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for(let i = 0; i < s.length; i++){\r\n\r\n    if(s[i] == c){\r\n      res[i] = 0\r\n    }else{\r\n      let right = i + 1;\r\n      let left = i - 1\r\n\r\n      while(s[left] != c && left > 0){\r\n        left--\r\n      }\r\n\r\n      while(s[right] != c && right < s.length-1){\r\n        right++\r\n      }\r\n\r\n      //这里进行了边界处理，即处理了left/right越界的情况\r\n      //也处理了如果left/right 只是单纯的到边界停下了的情况\r\n      //比如s='love' 在s[i] = o i=1的时候，left就会是0\r\n      let leftSideC = s[left] != c  ? Infinity : i - left;\r\n      let rightSideC = s[right] != c ? Infinity : right - i\r\n      // console.log(i, s[i], left, leftSideC, right, rightSideC)\r\n      res[i] = Math.min(rightSideC, leftSideC)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$O(N^2)$ </br>\r\n空间复杂度：O(1) 只保存了常量\r\n\r\n### 思路 窗口\r\n\r\n\r\n我要请漾宝吃饭！   \r\n滑动的~？窗口  \r\n制造一个窗口，让他的左右两端分别为 c 或者 s 的边界  \r\n当为 s 的边界的时候，让窗口的值等于 Infinity  \r\n因为必然有 c，所以只要处理 i = 0 的时候就好了\r\n然后计算每个 s 到窗口两边的值，取最小\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n  //sliding window\r\n\r\n  let left = s[0] === c ? 0 : Infinity;\r\n  //从index = 1 的位置开始寻找c\r\n  let right = s.indexOf(c, 1);\r\n\r\n  const res = new Array(s.length);\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    res[i] = Math.min(Math.abs(i - left), Math.abs(i - right))\r\n    //变到下一个窗口\r\n    if(i === right){\r\n      left = right;\r\n      right = s.indexOf(c, left + 1)\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N · (NK)) 其中 n 是 s 的长度，indexof 的时间复杂度是 O(NK),其中 k 是每次找到的目标的长度 </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838814104","body":"## LC 1381. Design a Stack With Increment Operation\r\n\r\n- LC 1381. Design a Stack With Increment Operation\r\n  - [O(1)空间](<#思路-O(1)空间>)\r\n  - [O(1)时间](<#思路-O(1)时间>)\r\n\r\n### 思路 O(1)空间\r\n\r\n感觉现在写的比以前顺畅多了 Q_Q  \r\n这是有进步了吧？  \r\n果然跟着 Lucifer 的每日打卡做题就会有进步呢！\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length == this.maxSize) return null;\r\n  this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let last = this.stack.pop();\r\n  return last == undefined ? -1 : last;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  for(let i = 0; (i < k) && (i < this.stack.length); i++){\r\n    this.stack[i] += val\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) increment is O(N) for iterating through the stack, others are O(1) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 O(1)时间\r\n\r\n空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，并且在要 pop 的时候把操作对弹出栈的小朋友进行运算\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.record = new Map(); // index => total increment amount\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length == this.maxSize) return null;\r\n  this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(1) </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840172489","body":"## LC 394. Decode String\r\n\r\n- [辅助栈](#思路-辅助栈)\r\n- [辅助栈 2](#思路-辅助栈2)\r\n\r\n### 思路 辅助栈\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 辅助栈 2\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const numStack = [], strStack = []\r\n  let num = 0, res = ''\r\n\r\n  for(let char of s){\r\n    if(!isNaN(char)){ // !isNaN() 来判断是否是一个数字\r\n      num = num * 10 + Number(char) // Number(char)转换数字\r\n    }else if(char == '['){\r\n      strStack.push(res); //把之前存的string入栈，进入新的一层\r\n      res = '' //清空之前存的str\r\n      numStack.push(num) //把 [ 前面的 number入栈\r\n      num = 0 //清空 num\r\n    }else if(char == ']'){\r\n      //input: \"3[ab2[d]]\" 此时 ab    +  2 * d\r\n      //现在的res是[]里面的所有字符\r\n      res = strStack.pop() + res.repeat(numStack.pop())\r\n    }else{\r\n      res += char\r\n    }\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840832380","body":"## LC 232. Implement Queue using Stacks\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n### 思路\r\n\r\n### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n     // pretend to be a stack with push, peek, pop, size, and isEmpty\r\n    this.stackleft = []; //[1,2,3]\r\n    this.stackright = []; //[6,5,4]\r\n\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.stackright.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if(this.stackleft.length == 0){\r\n    while(this.stackright.length > 0){\r\n      this.stackleft.push(this.stackright.pop())\r\n    }\r\n  }\r\n  return this.stackleft.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if(this.stackleft.length == 0){\r\n    while(this.stackright.length> 0){\r\n      this.stackleft.push(this.stackright.pop())\r\n    }\r\n  }\r\n  return this.stackleft[this.stackleft.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stackleft.length == 0 && this.stackright.length == 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\r\n</br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841473071","body":"## LC 768. Max Chunks To Make Sorted II\r\n\r\n- [单调递增栈/Monotonic Queue](#思路-单调递增栈/Monotonic-Queue)\r\n- [滑动窗口/Sliding Window](#思路-滑动窗口/Sliding-Window)\r\n\r\n### 思路 单调递增栈/Monotonic Queue\r\n\r\nwant: concatenating chunks == to the sorted array\r\nequavilantly: seeking a data structure represnets a strict increasing order -> monotonic queue\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n  let queue = [];\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n\r\n    if(queue.length == 0 || (queue[queue.length - 1] <= arr[i])){\r\n      queue.push(arr[i])\r\n    }else{\r\n      //the size of the queue reprensets the size of partition\r\n\r\n      let temp = queue.pop()\r\n      while(queue[queue.length - 1] > arr[i]){\r\n        queue.pop()\r\n      }\r\n\r\n      queue.push(temp)\r\n    }\r\n\r\n  }\r\n  return queue.length\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 滑动窗口/Sliding Window\r\n\r\nThe sum of each sorted chunk equals to the sum of the original chunk regardless of the sort order.  \r\nCredit to Suukii\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n  let sum1 = 0, sum2 = 0;\r\n  let count = 0\r\n\r\n  sorted = arr.slice().sort((a,b) => a - b)\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n    sum1 += arr[i]\r\n    sum2 += sorted[i]\r\n\r\n    if(sum1 === sum2) count++\r\n  }\r\n\r\n  return count;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N logN) -> N for iterating through the array, logN for sort </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841692432","body":"## LC 61. Rotate List\r\n\r\n- [仿照 Lucifer 解的快慢指针](#思路-仿照Lucifer解的快慢指针)\r\n- [快慢指针](#思路-快慢指针)\r\n- [迭代+一点数学](#思路-迭代+一点数学)\r\n- [递归](#思路-递归)\r\n\r\n### 思路 仿照 Lucifer 解的快慢指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n\r\n  let fast = head, slow = head\r\n\r\n\r\n  //这时候的slow是newTail，这里Lucifer写的挺elegant Q_Q\r\n  while(fast.next){\r\n    if(k-- <=0) slow = slow.next\r\n    fast = fast.next\r\n  }\r\n\r\n  fast.next = head;\r\n  let newHead = slow.next\r\n\r\n  slow.next = null;\r\n  return newHead\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 快慢指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n  //如果次数是0，那么就等于没干，并且如果k = 0 后面会报错\r\n  if(k === 0) return head;\r\n\r\n  //快慢指针，让快的先走 k - 1步，这样慢的就刚好是newHead，快的刚好是现在的尾巴\r\n  let fast = head, slow = head, count = k - 1;\r\n\r\n  while(count > 0){\r\n    fast = fast.next\r\n    count--\r\n  }\r\n\r\n  //pre是newHead之前的节点，也就是newTail\r\n  let pre = null;\r\n  while(fast.next){\r\n    pre = slow\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  //在尾巴后面把这个斩断\r\n  pre.next = null;\r\n  //这里把他接上\r\n  fast.next = head;\r\n  return slow\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 迭代+一点数学\r\n\r\n把 LinkedList 想象成一个 array  \r\n遍历两次，一次求出 length  \r\n第二次通过计算求出 newHead Index，并且设置一个 pre（就是新的尾巴\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(k === 0 || !head || !head.next) return head;\r\n\r\n  let length = 1, cur = head\r\n\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  // 长度为n的列表里，如果index 是0 based，那么倒数第一个，index就是 n-1，倒数第二个，index就是n - 2 \\\r\n  // k % n 是真实的旋转次数\r\n  //那么newHead就是 newHeadIndex = length - k % length\r\n  let newHeadIndex =  length - k % length;\r\n  //\r\n  if(newHeadIndex == 0) return head;\r\n\r\n  let pre = cur;\r\n  cur.next = head;\r\n  cur = cur.next;\r\n  //现在cur 是 head，也就是index = 0 的情况\r\n  while(newHeadIndex > 0){\r\n    pre = cur\r\n    cur = cur.next\r\n    newHeadIndex--\r\n  }\r\n\r\n  //pre 是 newHead前面的一个node，所以它是尾巴\r\n  pre.next = null;\r\n\r\n  return cur;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 递归\r\n\r\n每次递归一个，模拟操作  \r\n但是要注意要求 k % length 不然会超时\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next) return head;\r\n\r\n  var rotate = function(head){\r\n    let tail = head, preTail = null;\r\n\r\n    while(tail.next){\r\n      preTail = tail\r\n      tail = tail.next\r\n    }\r\n\r\n    preTail.next = null;\r\n    tail.next = head;\r\n\r\n    return tail\r\n  }\r\n\r\n\r\n  let cur = head;\r\n  let length = 1;\r\n  //数一下length\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //实际递归的次数\r\n  k = k % length;\r\n\r\n\r\n  let res = head;\r\n\r\n  while(k >0){\r\n    res = rotate(res)\r\n    k--\r\n  }\r\n\r\n  return res;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度： O(N) </br>\r\n空间复杂度：O(K % Length)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841846270","body":"## LC 24. Swap Nodes in Pairs\r\n\r\n- [迭代 Interation](#思路-迭代-Interation)\r\n- [递归 Recursion](#思路-递归-Recursion)\r\n\r\n### 思路 递归 Recursion\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar swapPairs = function(head) {\r\n  // the number of nodes in the list is in the range [0,100]\r\n  if(!head || !head.next) return head\r\n  let next = head.next\r\n  const rest = swapPairs(next.next)\r\n  head.next = rest;\r\n  next.next = head\r\n  //returning the newhead, which is actually NEXT\r\n  return next;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N) stack's consumption\r\n\r\n### 思路 迭代 Interation\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar swapPairs = function(head) {\r\n  // the number of nodes in the list is in the range [0,100]\r\n  if(!head || !head.next) return head\r\n  //A commonly used trick for 1)better locating the head and\r\n  //2)treating head as part of the list so that we don't have to handle it seperately\r\n  const dummyHead = new ListNode(-1, head)\r\n\r\n  let slow = head, fast = head.next, preSlow = dummyHead;\r\n  //穿针引线 -> referrence to Lucifer's LinkedList notes\r\n  while(fast){\r\n    let next = fast.next;\r\n    preSlow.next = fast;\r\n    fast.next = slow;\r\n    slow.next = next;\r\n\r\n    preSlow = slow\r\n    slow = next\r\n    if(!slow) break\r\n    fast = slow.next\r\n  }\r\n\r\n  return dummyHead.next\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842505124","body":"## LC 109. Convert Sorted List to Binary Search Tree\r\n\r\n- [快慢指针](#思路-快慢指针)\r\n- [构建数组](#思路-构建数组)\r\n- [分治](#思路-分治)\r\n\r\n### 思路 分治\r\n\r\n参考笨猪爆破组\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar sortedListToBST = function(head) {\r\n  if(!head) return null;\r\n  let length = 0;\r\n  let current = head;\r\n  while(current){\r\n    current = current.next\r\n    length++\r\n  }\r\n\r\n  var buildBST = function(start, end){\r\n    if(start > end) return null;\r\n\r\n    const mid = start + ((end - start)>> 1)\r\n    const leftSide = buildBST(start, mid - 1);\r\n\r\n    const root = new TreeNode(head.val)\r\n    head = head.next;\r\n    root.left = leftSide\r\n\r\n    root.right = buildBST(mid+1, end)\r\n    return root;\r\n  }\r\n\r\n  return buildBST(0, length - 1)\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(logN)\r\n\r\n### 思路 快慢指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar sortedListToBST = function(head) {\r\n  if(!head) return null;\r\n\r\n  let slow = head, fast = head, preSlow = null;\r\n\r\n  while(fast && fast.next){\r\n    preSlow = slow\r\n    fast = fast.next.next\r\n    slow = slow.next\r\n  }\r\n\r\n  const newRoot = new TreeNode(slow.val)\r\n\r\n  if(preSlow){\r\n    //需要cut不然会影响mid的判断\r\n    preSlow.next = null;\r\n    //注意是从head开始，因为要选中点做parent\r\n    newRoot.left = sortedListToBST(head)\r\n  }\r\n  newRoot.right = sortedListToBST(slow.next)\r\n\r\n  return newRoot;\r\n\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(NlogN) </br>\r\n空间复杂度：O(NlogN)\r\n\r\n### 思路 构建数组\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar sortedListToBST = function(head) {\r\n\r\n  const arr = [];\r\n  let cur = head;\r\n\r\n  while(cur){\r\n    arr.push(cur.val)\r\n    cur = cur.next\r\n  }\r\n\r\n  var buildBFS = function(start,end){\r\n    if(start > end) return null;\r\n    const mid = start + ((end - start) >> 1)\r\n    const root = new TreeNode(arr[mid])\r\n    root.left = buildBFS(start, mid - 1)\r\n    root.right = buildBFS(mid + 1, end)\r\n    return root;\r\n  }\r\n\r\n  return buildBFS(0, arr.length - 1)\r\n\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843377626","body":"## LC 160. Intersection of Two Linked Lists\r\n\r\n- [双指针](#思路-双指针)\r\n\r\n### 思路 双指针\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    // a + c + b === b + c + a\r\n\r\n    //for intersect LinkedLists, a == b at the intersect point\r\n    //for no-intersect LinkedLists, a == b at null\r\n    let a = headA, b = headB\r\n    while(a != b){\r\n      a = a ? a.next : headB\r\n      b = b ? b.next : headA\r\n    }\r\n\r\n    return a;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(M+N) MN 分别是 LinkedList A 和 B 的长度 </br>\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844328769","body":"## LC 142. Linked List Cycle II\r\n\r\n- [Two Pointers: fast & slow pointers](#思路-Two-Pointers:-fast-&-slow-pointers)\r\n- [HashTable](#思路-Hashtable)\r\n\r\n### 思路 Two Pointers: fast & slow pointers\r\n我这图画的老匠心独运craftmanship了他怎么不给我显示呐[○･｀Д´･ ○]\r\n![LC142](https://github.com/lilyzhaoyilu/LeetCode-Notes/blob/master/assets/LC142Floyd'sCircleFinding.jpg)\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar detectCycle = function(head) {\r\n  let fast = head, slow = head;\r\n\r\n  do{\r\n    //check if there is a loop\r\n    if(!fast || !fast.next) return null;\r\n    fast = fast.next.next\r\n    slow = slow.next\r\n  }while(fast != slow)\r\n\r\n\r\n  fast = head;\r\n\r\n  //locate the entrance of the loop\r\n  while(fast != slow){\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  return fast;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(1)\r\n\r\n### 思路 Hashtable\r\n\r\nConstruct a hashtable (new Set() in JavaScript)  \r\nIterate through the linked list\r\nif there is a repeated node, then it is then entrace of the loop  \r\nif the node === null, then there is no loop\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar detectCycle = function(head) {\r\n  const memo = new Set()\r\n\r\n  while(head){\r\n    if(memo.has(head)){\r\n      return head\r\n    }else{\r\n      memo.add(head)\r\n    }\r\n    head = head.next\r\n  }\r\n\r\n  return null;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) Iterate through the linkedlist</br>\r\n空间复杂度：O(N) Hashtable to store the linkedlist\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845431712","body":"## LC 146. LRU Cache\r\n\r\n### 思路  \r\n\r\n自己构建一个 double linkedList  \r\n通过哈希表保证读是 O(1)\r\n通过 linkedList 保证 put 也是 O(1)\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar ListNode = function(key, value){\r\n     this.key = key;\r\n     this.value = value;\r\n     this.prev = null;\r\n     this.next = null;\r\n}\r\n\r\nvar LRUCache = function(capacity) {\r\n  this.capacity = capacity;\r\n  this.cache = new Map(); //用来O(1)时间返回value, 存储格式  key => ListNode(key,value)\r\n  this.count = 0; //现有数量\r\n\r\n  //构建虚拟节点，方便处理\r\n  //dummyHead -> most recently used -> least rencetly used -> dummyTail\r\n  this.dummyHead = new ListNode();\r\n  this.dummyTail = new ListNode();\r\n  //make sure to connect them\r\n  this.dummyHead.next = this.dummyTail;\r\n  this.dummyTail.prev = this.dummyHead;\r\n\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(!this.cache.get(key)) return -1;\r\n\r\n  const node = this.cache.get(key)\r\n  this.moveToHead(node)\r\n  return node.value\r\n\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n//If LRU has this key\r\n//    reassign the value of this.cache\r\n//    move the node to the Head so that we know it is the most-recent-used one\r\n\r\n//If LRU does not have this key\r\n//     if the capcity reaches the limit, remove the least used\r\n//            removeLeastUsed includes 1) remove the ListNode 2)remove it from this.cache 3)update the count\r\n//     build a new node(key, value)\r\n//     add the new node to 1)this.cache and 2)the the list (and it should be dummyHead.next = this new node)\r\n//     update count\r\n\r\n\r\n  const node = this.cache.get(key)\r\n  if(node){\r\n    node.value = value;\r\n    this.cache.set(key, node)\r\n    this.moveToHead(node)\r\n  }else{\r\n    if(this.count === this.capacity){\r\n      this.removeLeastUsed()\r\n    }\r\n    const newNode = new ListNode(key, value)\r\n    this.cache.set(key, newNode)\r\n    this.addToHead(newNode)\r\n    this.count++\r\n  }\r\n\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\nLRUCache.prototype.removeFromList = function(node){\r\n     let prevNode = node.prev\r\n     let postNode = node.next\r\n     prevNode.next = postNode\r\n     postNode.prev = prevNode\r\n   }\r\n\r\nLRUCache.prototype.addToHead = function(node){\r\n     node.prev = this.dummyHead\r\n     node.next = this.dummyHead.next;\r\n     this.dummyHead.next.prev = node;\r\n     this.dummyHead.next = node;\r\n}\r\n\r\nLRUCache.prototype.moveToHead = function(node){\r\n  this.removeFromList(node)\r\n  this.addToHead(node)\r\n}\r\n\r\nLRUCache.prototype.removeLeastUsed = function(){\r\n  this.count--\r\n  const leastUsed = this.dummyTail.prev;\r\n  this.cache.delete(leastUsed.key);\r\n  this.removeFromList(leastUsed);\r\n}\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(capacity)  \r\n更多复杂度：https://www.bigocheatsheet.com/\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846149990","body":"## LC 104. Maximum Depth of Binary Tree\r\n\r\n- [DFS](#思路-DFS)\r\n- [BFS-打包层数和 node](#思路-BFS-打包层数和node)\r\n- [BFS-记录层数，经典写法](#思路-BFS-记录层数，经典写法)\r\n\r\n### 思路 DFS\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar maxDepth = function(root, depth = 0) {\r\n  //dfs -> 前序遍历，每次+1，返回一个最大值\r\n  if(!root) return depth;\r\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) N is the number of nodes </br>\r\n空间复杂度：O(height) height of the tree\r\n\r\n### 思路 BFS-打包层数和 node\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar maxDepth = function(root) {\r\n  //注意处理root == null 的情况\r\n  if(!root) return 0;\r\n  //注意root 的层数已经是1\r\n  //这里的处理是把[node， 层]打包在一起放进queue\r\n  const queue = [[root,1]]\r\n  let maxLevel = 0\r\n  while(queue.length > 0){\r\n    //遍历每一层\r\n    const curLevelSize = queue.length\r\n    for(let i = 0; i < curLevelSize; i++){\r\n      const [node, curLevel] = queue.shift();\r\n      maxLevel = Math.max(maxLevel, curLevel)\r\n      node.left && queue.push([node.left, curLevel + 1])\r\n      node.right && queue.push([node.right, curLevel + 1])\r\n    }\r\n  }\r\n\r\n  return maxLevel\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 BFS-记录层数，经典写法\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar maxDepth = function(root) {\r\n  if(!root) return 0;\r\n  //bfs\r\n  const queue = [root]\r\n  let maxLevel = 0\r\n  while(queue.length > 0){\r\n    const curLevelSize = queue.length\r\n    for(let i = 0; i < curLevelSize; i++){\r\n      const node = queue.shift();\r\n      node.left && queue.push(node.left)\r\n      node.right && queue.push(node.right)\r\n    }\r\n    maxLevel++\r\n  }\r\n\r\n  return maxLevel\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N)  \r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846425644","body":"## LC 100. Same Tree\r\n\r\n- [DFS](#思路-DFS)\r\n- [BFS](#思路-BFS)\r\n- [BFS2-用{}解决 null 的问题](#思路-BFS2-用{}解决null的问题)\r\n\r\n### 思路 DFS\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar isSameTree = function(p, q) {\r\n  if(!p && !q) return true\r\n  if(!p || !q) return false;\r\n  if(p.val != q.val) return false;\r\n\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) 遍历每一个 node</br>\r\n空间复杂度：O(N) 栈的开销\r\n\r\n### 思路 BFS\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar isSameTree = function(p, q) {\r\n  if(!p && !q) return true;\r\n  if(!p || !q) return false;\r\n\r\n  let pqueue = [p]\r\n  let qqueue = [q]\r\n\r\n  while(pqueue.length && qqueue.length){\r\n    let pnode = pqueue.shift()\r\n    let qnode = qqueue.shift()\r\n\r\n    if(pnode.val != qnode.val) return false\r\n\r\n    if(pnode.left && qnode.left){\r\n      pqueue.push(pnode.left)\r\n      qqueue.push(qnode.left)\r\n    }else if(!pnode.left && !qnode.left){\r\n\r\n    }else{\r\n      return false;\r\n    }\r\n\r\n\r\n    if(pnode.right && qnode.right){\r\n      pqueue.push(pnode.right)\r\n      qqueue.push(qnode.right)\r\n    }else if(!pnode.right && !qnode.right){\r\n\r\n    }else{\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return (pqueue.length == 0 && qqueue.length == 0)\r\n\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n\r\n### 思路 BFS2-用{}解决 null 的问题\r\n\r\n学习了笨猪， 利用{}可以存储 null 为 value 的 特性来写\r\n\r\n#### 代码 JavaScript\r\n\r\n```JavaScript\r\nvar isSameTree = function(p, q) {\r\n  const queue = [{p,q}]\r\n\r\n  while(queue.length){\r\n    const cur = queue.shift();\r\n    //注意一定要加continue才能保证match\r\n    if(!cur.q && !cur.p) continue;\r\n    if(!cur.q || !cur.p) return false;\r\n    if(cur.q.val !== cur.p.val) return false;\r\n\r\n    queue.push({\r\n      p: cur.p.left, q: cur.q.left\r\n    },{\r\n      p: cur.p.right, q:cur.q.right\r\n    })\r\n\r\n  }\r\n\r\n  return true;\r\n};\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N) </br>\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Size-of":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835929595","body":"```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const res = []\r\n  let i = num.length - 1\r\n  let carry = 0\r\n  while (i >= 0 || k > 0 || carry > 0) {\r\n    let cur = (num[i] || 0) + k % 10 + carry\r\n    res.push(cur % 10)\r\n    carry = cur / 10 | 0\r\n    i--\r\n    k = k / 10 | 0\r\n  }\r\n  return res.reverse()\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, logk))$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837506159","body":"## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n  for (let i = 0; i < s.length; i++) {\r\n    res[i] = s.substr(i, 1) === c ? 0 : (res[i - 1] != undefined ? res[i - 1] : Infinity) + 1\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    let prev = res[i + 1] !== undefined ? res[i + 1] : Infinity\r\n    res[i] = prev + 1 < res[i] ? prev + 1 : res[i]\r\n  }\r\n\r\n  return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$, N为s的长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839766869","body":"\r\n## 代码\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length === this.maxSize) return\r\n    this.list[this.list.length] = x\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (!this.list.length) return -1\r\n    return this.list.splice(this.list.length - 1, 1)[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < (this.list.length < k ? this.list.length : k); i++) {\r\n         this.list[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840563176","body":"\r\n\r\n\r\n\r\n## 代码\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  s = s.split('')\r\n  function dfs(sub, k) {\r\n    let str = ''\r\n    let num = 0\r\n    while (sub.length) {\r\n      let char = sub.shift()\r\n      if (/\\d/.test(char)) {\r\n        num = num * 10 + +char\r\n      } else if (char === '[') {\r\n        str += dfs(sub, num)\r\n        num = 0\r\n      } else if (char === ']') {\r\n        let _str = str\r\n        while (--k) {\r\n          str += _str\r\n        }\r\n        break\r\n      } else {\r\n        str += char\r\n      }\r\n    }\r\n    return str\r\n  }\r\n\r\n  return dfs(s, 0)\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841273939","body":"\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.l1 = []\r\n    this.l2 = []\r\n    this.front \r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n   if (!this.l1.length) {\r\n       this.front = x\r\n   }\r\n   this.l1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.l2.length) {\r\n        return this.l2.pop()\r\n    }else  if (this.l1.length) {\r\n        while(this.l1.length > 1) {\r\n            this.l2.push(this.l1.pop())\r\n        }\r\n        return this.l1.pop()\r\n    }\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    let target\r\n    if (this.l2.length) {\r\n        target = this.l2.pop()\r\n        this.l2.push(target)\r\n        return target\r\n    }\r\n    \r\n    return this.front\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.l1.length === 0 && this.l2.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为队列长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844100450","body":"\r\n## 思路\r\n\r\n定义两个链表的指针，让其以相同速度遍历两个列表，长度相同即A+B = B+A，当存在相交点，一定在尾部存在一段相同的链表\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n    while (a !== b) {\r\n        a = a ? a.next : headB\r\n        b = b ? b.next : headA\r\n    }\r\n    return a\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844782263","body":"## 思路\r\n快慢针：\r\n1. 快针速度是慢针速度的两倍，则快针走过的总长度= 2 * 慢针走过总长度\r\n2. 当链表中存在环时，两个指针一定会在环中相遇\r\n3. 假设从起始点到环入口的长度为L，环的周长为R，快针走过的总长为LA, 慢针走过的总长为LB, 环入口到相遇点距离为S；LA = n1 * R + S + L; LB = n2 * R + S +L;\r\n4. LA = 2LB => LB = LA - LB => LB = (n1 - n2) * R；\r\n5, 由3,4可推出R = S + L， 故慢针再走L步就能抵达环入口\r\n6. 因为不确定L的长度，所以将快针重置到起始点，并且速度与慢针相同，这样两针相遇点即是环入口\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  let quick = head, slow = head;\r\n\r\n  while (quick && slow) {\r\n    quick = quick.next\r\n    if (!quick) return null\r\n    quick && (quick = quick.next)\r\n    slow = slow.next\r\n    if (quick === slow) {\r\n      quick = head\r\n      while (quick !== slow) {\r\n        quick = quick.next\r\n        slow = slow.next\r\n      }\r\n      return slow\r\n    }\r\n  }\r\n  return null\r\n};\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(n) \r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845922613","body":"\r\n## 思路\r\n双向链表 + 哈希表\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.head = new ListNode()\r\n  this.tail = new ListNode()\r\n  this.capacity = capacity\r\n  this.map = {}\r\n  this.head.next = this.tail\r\n  this.tail.pre = this.head\r\n  this.removeTail = () => {\r\n    const key = this.tail.pre.key\r\n    this.removeNode(this.map[key])\r\n    return key\r\n  }\r\n  this.appendToHead = (node) => {\r\n    node.next = this.head.next\r\n    node.next.pre = node\r\n    node.pre = this.head\r\n    this.head.next = node\r\n  }\r\n  this.removeNode = (node) => {\r\n    node.pre.next = node.next\r\n    node.next.pre = node.pre\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  const node = this.map[key]\r\n  if (node) {\r\n    this.removeNode(node)\r\n    this.appendToHead(node)\r\n    return node.val\r\n  }\r\n  return -1\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node = this.map[key]\r\n  if (node) {\r\n    node.val = value\r\n    this.removeNode(node)\r\n    this.appendToHead(node)\r\n  } else if (this.capacity) {\r\n    node = new ListNode(value, key)\r\n    this.appendToHead(node)\r\n    this.map[key] = node\r\n    this.capacity--\r\n  } else {\r\n    node = new ListNode(value, key)\r\n    delete this.map[this.removeTail()]\r\n    this.appendToHead(node)\r\n    this.map[key] = node\r\n  }\r\n};\r\n\r\n\r\nconst ListNode = function (val, key) {\r\n  this.val = val\r\n  this.key = key\r\n  this.pre = null\r\n  this.next = null\r\n}\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846336294","body":"\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  if (!root) return 0\r\n\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n\r\n- 时间复杂度：$O(n)$， n为节点个数\r\n- 空间复杂度：$O(depth)$, depth为树的深度\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846500929","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (p === q) return true\r\n    const left = isSameTree(p?.left, q?.left)\r\n    const right = isSameTree(p?.right, q?.right)\r\n\r\n    return p?.val === q?.val && left && right\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为节点个数。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Talent-Rain":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835930598","body":"\r\n## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/bao-li-xiang-jia-by-jzsq_lyx-pon7/)\r\n\r\n### 分析\r\n1. 给定的 k 值是数字，不好按位来和数组中的值进行比对，而这里最后返回的是一个数组，所以先把数组 k 转成字符数组 -- kArr\r\n2. 根据数组长度，从地位到高位进行相加，用遍历 addOne 表示是否进位\r\n3. 每一次相加都需要判断是否超过 9, 超出时返回余数，并更新遍历 addOne\r\n4. 由于返回的 num，所以先用 ALen 遍历，遍历结束后，根据 KLen 的值判断是否还有 kArr 的值，同时还得注意次数 addOne 是否需要进位\r\n5. 时间复杂度：遍历 k 是 O(k) -- 其中 k 是 KLen，然后是遍历两个数组，所以最后 O(N),其中 N 是 Math.max(KLen,ALen)\r\n6. 空间复杂度: O(K)  -- 其中 k 是 KLen\r\n\r\n```javascript\r\n// 989. 数组形式的整数加法\r\n\r\n/**\r\n * @分析\r\n * 1. 由于最后返回的是数组形式，所以将 k 转成单个字符加到数组中比较合适\r\n * 2. 主要考察字符串切分字符，字符与数字相加转换问题\r\n */\r\n var addToArrayForm = function (num, k) {\r\n\r\n    let addOne = false // 进位\r\n    // 转成 number[]\r\n    const kArr = String(k).split('').map(str => Number(str))\r\n    let ALen = num.length, KLen = kArr.length \r\n    while (ALen--) {\r\n        let sum = num[ALen]\r\n        if (KLen) {\r\n            KLen--\r\n            sum += kArr[KLen]\r\n        }\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        }\r\n        if (sum >= 10) {\r\n            num[ALen] = sum % 10\r\n            addOne = true\r\n        } else {\r\n            num[ALen] = sum\r\n        }\r\n    }\r\n    while (KLen--) {\r\n        // 还有的值全部加到后面\r\n        let sum = kArr[KLen]\r\n        if (addOne) {\r\n            sum++\r\n            addOne = false\r\n        } \r\n        if (sum >= 10) {\r\n            num.unshift(sum % 10)\r\n            addOne = true\r\n        } else {\r\n            num.unshift(sum)\r\n        }\r\n    }\r\n    if (addOne) {\r\n        num.unshift(1)\r\n    }\r\n    return num\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837524070","body":"[ 821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/bao-li-mei-ju-by-jzsq_lyx-ya8d/)\r\n### 直接暴力解法\r\n1. 将所有 c 的下标标记出来，用 temp 数组保存\r\n2. 遍历第二次的时候根据 temp 的值作为节点，计算对应的 abs 值\r\n3. 需要特别注意的是第一个节点和最后一个节点\r\n4. 时间复杂度：遍历了两次 s -- O(N) 其中 N 是 s 的长度\r\n5. 空间复杂度： 存储的是 c 出现的次数 -- O(C) -- 其中 C 的值为 [1,N]\r\n```javascript\r\n// 821. 字符的最短距离\r\n\r\n/**\r\n * @分析 -- 暴力解法\r\n */\r\n var shortestToChar = function (s, c) {\r\n    const len = s.length\r\n    //当结果为 c 的时候，就是 0，默认先全是 0\r\n    const ret = new Array(len).fill(0)\r\n    const temp = []\r\n    // 遍历第一次，找出所有 c 对应的 index\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) temp.push(i)\r\n    }\r\n\r\n    let index = 0\r\n    // 再遍历一次，完成所有值\r\n    for (let i = 0; i < temp.length; i++) {\r\n        const right = temp[i]\r\n        if (i === 0) {\r\n            while (index < right) {\r\n                ret[index] = right - index\r\n                index++\r\n            }\r\n        } else {\r\n            const left = temp[i - 1]\r\n            while (index > left && index < right) {\r\n                ret[index] = Math.min(right - index, index - left)\r\n                index++\r\n            }\r\n        }\r\n        // 因为相同的节点直接就是 0，所以直接跳过了\r\n        index++\r\n    }\r\n    // 走完了，如果index<len,做最后一次遍历\r\n    while (index < len) {\r\n        ret[index] = index - temp[temp.length - 1]\r\n        index++\r\n    }\r\n    return ret\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840183957","body":"## [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/solution/zhan-by-jzsq_lyx-u6lz/)\r\n### 分析\r\n1. 用栈保存临时值，每个 [ 都会入栈，所以栈中数字的值肯定和最后 ] 的值保持一致的；\r\n2. 具体规则如下：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n4. 最后会得到一个全是非数字字符串的栈和最后一个 temp，累加栈中的值并最后加上 temp 便是最终结果\r\n```javascript\r\n// 394. 字符串解码\r\n\r\n/**\r\n * @分析\r\n * 1. 创建栈，保存数字和字符串\r\n * 2. 由题目可知：当 `遇到数字而临时字符串 temp 是非数字字符串时` 或者遇到 ‘[’ 的时候，栈加一个 temp\r\n * 3. 当遇到 ] 的时候，表示临时字符串结束，需要判断栈顶是否是数字字符串，如果不是，弹出加在 temp 前面，如果是，repeat 字符串\r\n */\r\n var decodeString = function (s) {\r\n    let stack =[]; // 当 [ 和 第一次出现数字的时候，存储\r\n    let temp = '' // 临时子串\r\n    for(let i = 0;i<s.length;i++){\r\n        const item = s[i]\r\n        if(item === '['){\r\n            stack.push(temp)\r\n            temp = ''\r\n        }else if (item === ']') {\r\n            // 要一直弹出数字位置\r\n            while(isNaN(stack[stack.length-1])){\r\n                temp = stack.pop()+temp\r\n            }\r\n            temp = temp.repeat(stack.pop())\r\n        }else if (!isNaN(item) && isNaN(temp) && temp !=='') {\r\n            //  item 是数字，temp 是非数字字符串，且 temp 不能为空\r\n            stack.push(temp)\r\n            temp = item\r\n        }  else {\r\n            // 普通字符或者普通数字\r\n            temp += item\r\n        }\r\n    }\r\n    let result = ''\r\n    while(stack.length){\r\n        result+=stack.shift()\r\n    }\r\n    return result+temp\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840931530","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/yong-shu-zu-mo-ni-zhan-ran-hou-mo-ni-dui-5vow/)\r\n\r\n### 分析\r\n1. 对于 js 来说，本身就是用数组模拟栈，现在要用栈模拟队列，所以就按题意，让 stack 不允许直接 pop，然后用栈的特性来处理\r\n2. 时间复杂度:插入 O(1); pop 和 peak 都需要倾倒stack ，所以是 O(N); empty 是 O(1)\r\n\r\n```javascript\r\n// 232. 用栈实现队列\r\n\r\n/**\r\n * @分析\r\n * 1. 既然说是用栈实现，那么就用 arr 模拟栈，只能是后进先出了\r\n * 2. 其实就是用两个栈转换，实现一个队列\r\n */\r\n\r\nvar MyQueue = function () {\r\n    this.stack = []\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function () {\r\n    // 从队列头中弹出\r\n    const tempStack = []\r\n    while (this.stack.length) {\r\n        tempStack.push(this.stack.pop())\r\n    }\r\n    const result = tempStack.pop()\r\n    while (tempStack.length) {\r\n        this.stack.push(tempStack.pop())\r\n    }\r\n    return result\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0] // 这个直接返回即可，不同语言不一样，不行就按照 pop 方法倒水，一样可行\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function () {\r\n    return !this.stack.length\r\n};\r\n\r\n\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841761407","body":"[ 61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/solution/lian-biao-de-pin-jie-by-jzsq_lyx-4kl6/)\r\n\r\n### 分析\r\n1. 其实新的链表头，就是第一个走了 steps 之后，走到 null 的节点，所以使用 len-steps 找到它在链表的位置 -- 是第 newK 个节点 -- 其中节点是从 0 开始计算的。比方说 [1,2], steps === 1 ，则新的头节点是 2-1 = 1 ，也就是第 1 的节点。\r\n2. 通过 newK 获取到头节点，同时将前一个节点的 next 设置为 null，截断链表\r\n3. 新节点继续走，走到链表尾后，与旧链表拼接起来，得到新的最终链表.\r\n\r\n```javascript\r\n// 61. 旋转链表\r\n\r\n/**\r\n * @分析\r\n * 1. 先计算出 head 的长度，然后对比 k，找出最终结果相对初始结果位移的步数.\r\n * 2. 根据位移的步数，找出旋转后新的 newHead，同时阶段设置好旋转后的尾节点\r\n */\r\n var rotateRight = function(head, k) {\r\n    //  必须有2个以上节点或者进行了位移的，才可以走下面的程序\r\n    if(!head || !head.next) return head\r\n    let len = 0\r\n    let temp = head\r\n    while(temp){\r\n        temp = temp.next\r\n        len++\r\n    }\r\n    // steps 是走的步数，区间是 [0,len)\r\n    let steps = k % len\r\n    // 如果最后是走了 0 步，直接返回\r\n    if(steps === 0) return head\r\n    \r\n    // 走 newK 步后，得到的值就是新的链表头 newHead\r\n    let newK = len - steps\r\n     temp = head\r\n    while(--newK){\r\n        // 这里先减 k 后走节点，是为了得到根节点 temp\r\n        temp = temp.next\r\n    }\r\n    // 获取新的头节点\r\n    const newHead = temp.next\r\n    // 截断旧的链表，得到尾结点\r\n    temp.next = null\r\n    temp = newHead\r\n    // 遍历旧链表，使得旧链表连接到旧链表头\r\n    while(temp && temp.next){\r\n        temp=temp.next\r\n    }\r\n    temp.next = head\r\n    // 最后返回新的链表头\r\n    return newHead\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841891141","body":"[24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/di-gui-die-dai-by-jzsq_lyx-qc92/)\r\n### 递归\r\n1. 递归的时候先要确认递归的返回值是什么，这里返回的是当前交换指针后的头节点，或者没有交换的 head 节点\r\n2. 定义好递归的返回值后，就开始交换指针了，首先保存好 next 指针\r\n3. 然后 next.next = head ,head 指针指向下一个递归的头节点\r\n4. 当前计算的头节点是 next 指针\r\n5. 时间复杂度： O(N), 其中 N 是节点数\r\n```javascript\r\n// 24. 两两交换链表中的节点\r\n\r\n/**\r\n * @分析 -- 递归\r\n * 1. 每次递归确认返回值，这里返回值是两个节点的首节点或者单个节点的自身节点\r\n * 2. 所以 head.next = 下一个递归的首节点， next.next = head , return 的是 next\r\n */\r\nvar swapPairs = function (head) {\r\n    if (!head || !head.next) return head // 少于两个节点的，直接返回本身即可\r\n    const next = head.next\r\n    // 返回的下一次递归的首节点\r\n    head.next = swapPairs(next.next)\r\n    next.next = head\r\n    // 返回交换后的首节点\r\n    return next\r\n};\r\n```\r\n\r\n\r\n### 迭代\r\n1. 迭代也是每两个节点往前进行交换指针，但是需要注意的是，要保存 prev 指针作为连接每一次迭代的起点\r\n2. prev.next 连接交换后的头节点，即 next 节点\r\n3. 交换 cur = next.next,next.next = cur,最后更改 prev 的值为下一次迭代的 prev，即当前的 cur 指针\r\n4. 最后返回 emptyNode.next\r\n\r\n```javascript\r\n\r\n/**\r\n * @分析 -- 迭代\r\n * 1. 每一次迭代都必须保证有 prev 指针\r\n */\r\n\r\n var swapPairs = function (head) {\r\n    const emptyeNode = new ListNode()\r\n    emptyeNode.next = head\r\n    let prev =emptyeNode\r\n    while(prev.next && prev.next.next){\r\n        const cur = prev.next,next = prev.next.next\r\n        // prev 指针指向交换后的头节点\r\n        prev.next = next\r\n        cur.next = next.next\r\n        next.next = cur\r\n        // 设置新的 prev\r\n        prev = cur \r\n    }\r\n    return emptyeNode.next\r\n }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842719328","body":"### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/solution/zhi-jie-di-gui-zhuan-cheng-shu-zu-di-gui-dmvd/)\r\n\r\n#### 直接递归\r\n 1. 快慢指针获取到中间节点，然后切断两边作为左右子树\r\n 2. 然后直接通过获取当前子链表的中间值作为子树根节点，完成左右树的布置，最终返回 BST\r\n 3. 时间复杂度每一次都需要遍历一半 NlogN,\r\n 4. 空间复杂度 logN -- 每次遍历都要变量存储，这些遍历要到递归完成后才能撤销\r\n```javascript\r\n// 109. 有序链表转换二叉搜索树\r\n\r\n/**\r\n * @分析 -- 递归法\r\n * 1. 快慢指针获取到中间节点，然后切断两边作为左右子树\r\n * 2. 然后直接通过获取当前子链表的中间值作为子树根节点，完成左右树的布置，最终返回 BST\r\n * 3. 复杂度分析：时间复杂度每一次都需要遍历一半 NlogN -- 这个复杂度不会写\r\n */\r\n var sortedListToBST = function(head) {\r\n    if(!head) return null\r\n    const emptyNode = new ListNode()\r\n    emptyNode.next = head\r\n    let pre = emptyNode\r\n    let slow = fast = head\r\n    while(fast && fast.next){\r\n        slow = slow.next\r\n        pre = pre.next\r\n        fast = fast.next.next\r\n    }\r\n    pre.next = null // 截断左侧链表\r\n    return new TreeNode(slow.val,sortedListToBST(emptyNode.next),sortedListToBST(slow.next))\r\n};\r\n```\r\n\r\n#### 转成数组再递归\r\n- 空间上多存储了一个数组，但是找中间节点更快了\r\n- 一次遍历，余生无忧\r\n```javascript\r\n\r\n/**\r\n * @分析\r\n * 1. 链表 -> 数组 -> BST\r\n * 2. 有序链表取中间下标值，作为相应的根节点，然后左右树分别是数组的左右两边的值\r\n * 3. 转成数组比较方便取中间值，不然每一次都要使用双指针去遍历一次获取\r\n * 4. 空间复杂度 O(N),\r\n * 5. 时间复杂度: O(N)\r\n */\r\n\r\n var sortedListToBST = function(head) {\r\n     const arr = []\r\n    while(head){\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n    // 变成给定有序数组，然后求 BST 了\r\n    const recursion = arr => {\r\n        const len = arr.length\r\n        const mid = len >>1 \r\n        return new TreeNode(arr[mid],recursion(arr.slice(0,mid)),recursion(arr.slice(mid+1)))\r\n    }\r\n    return recursion(arr)\r\n }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843638044","body":"## 前端就该用 JS 刷算法139\r\n### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/bian-li-qu-tong-chang-du-lian-biao-zai-b-p1in/)\r\n#### 分析\r\n\r\n1. 先遍历一次两个链表，当其中一个链表走完之后，立刻用剩余那个链表的头指针继续走，直到两个链表都走完\r\n2. 遍历完第一次后，这个时候长的链表已经在第一次跟着多出来的长度跑了一部分了，所以现在的 headA 和 headB 长度是一直的了\r\n3. 最后遍历并判断即可 -- note：节点判断是直接判断，切忌值判定值\r\n4. 时间复杂度：O(N), 空间复杂度：O(1)\r\n\r\n```javascript\r\n// 160. 相交链表\r\n\r\n/**\r\n * @分析\r\n * 1. 先遍历一次两个链表，当其中一个链表走完之后，立刻用剩余那个链表的头指针继续走，直到两个链表都走完\r\n * 2. 遍历完第一次后，这个时候长的链表已经在第一次跟着多出来的长度跑了一部分了，所以现在的 headA 和 headB 长度是一直的了\r\n * 3. 最后遍历并判断即可 -- note：节点判断是直接判断，切忌值判定值\r\n */\r\n var getIntersectionNode = function(headA, headB) {\r\n    let tempA = headA,tempB  = headB\r\n    while(tempA ||tempB){\r\n        // 谁先遍历完，则另外一个是更长的链表，它需要重新再遍历，然后先消耗多出来的长度\r\n        if(!tempA){\r\n            headB =headB.next\r\n            tempB = tempB.next\r\n        }else if (!tempB){\r\n            headA =headA.next\r\n            tempA = tempA.next \r\n        }else{\r\n            tempA = tempA.next\r\n            tempB =tempB.next\r\n        }\r\n    }\r\n\r\n    // 跑完第一次遍历后， headA , headB 的长度已经是一致的了\r\n    while(headA){\r\n        if(headB === headA) return headB\r\n        headA = headA.next\r\n        headB = headB.next\r\n    }\r\n    return null\r\n\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844615208","body":"### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/kuai-man-zhi-zhen-by-jzsq_lyx-v9cy/)\r\n### 分析\r\n1. 经典题型，在同一起点出发，分成两个指针，如果快指针走到 null，证明无环\r\n2. 如果有环，总会在环的某一处与慢指针相遇，这个时候在起点再次定义一个 cur 指针，cur 指针和慢指针继续走，当他们相遇的时候，就是环的起点\r\n3. 注意note：所有的节点都必须从同一起点出发，有的时候会直接定义 slow 为head，fast为head.next，这是以 emptyNode 为起点，所以 cur 要从空指针开始走，千万不能以 head 为起点，否则计算会出错。\r\n```javascript\r\n// 142. 环形链表 II\r\n\r\nvar detectCycle = function (head) {\r\n    const emptyNode = new ListNode()\r\n    emptyNode.next = head\r\n    let slow = fast = emptyNode\r\n    while(fast && fast.next){\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if(slow === fast){\r\n            // 第一次相遇，再次出发\r\n            let cur =  emptyNode\r\n            while(cur !== slow){\r\n                cur = cur.next\r\n                slow = slow.next\r\n            }\r\n            return cur\r\n        }\r\n    }\r\n    // fast 出去了，证明没有环了\r\n    return null\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845568346","body":"# 前端就该用 JS 刷算法141\r\n\r\n\r\n### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/solution/shuang-xiang-lian-biao-shi-xian-by-jzsq_-3gt5/)\r\n#### 分析\r\n\r\n1. LRU 的核心是，无论是查找 get 还是设置 put，都需要先找到值，然后移动到一端，然后再做处理\r\n2. 移动操作就是 查找-删除-添加 的组合，\r\n3. 数组通过下标查找是 O(1),添加也是O(1),但是删除是 O(n)\r\n4. 链表删除为 O(1),链为添加也是 O(1),双向链表的查找还是O(1)，所以用双向链表处理比较合适\r\n5. 使用双向链表要注意表头和表尾容易出现形如 node.prev.next 不存在的错误，要不坐边界处理，要不像本题一样，做两个虚拟节点 emptyHead 和 emptyTail ；\r\n6. 使用虚拟节点后，往表头加 node 就可以方便很多，需要注意的是删除尾节点的时候，注意删除的是 emptyNode 的 prev\r\n\r\n```javascript\r\n// 146. LRU 缓存机制\r\n\r\n/**\r\n * @分析\r\n * 1. 要想获取的时候复杂度为 O(1)，可以用空间换时间，保存一个hashMap\r\n * 2. 要想设置的时候复杂度为 O(1),就得先找到对应的值，然后移动到最新的位置，这个操作如果用数组（队列），会超出了复杂度，所以使用双向链表来操作\r\n */\r\n\r\nconst DoubleLink = function (key = null, value = null) {\r\n    this.key = key\r\n    this.value = value\r\n    this.next = null\r\n    this.prev = null\r\n}\r\n\r\nvar LRUCache = function (capacity) {\r\n    this.max = capacity\r\n    this.size = 0 //缓存的长度\r\n    this.emptyHead = new DoubleLink() //空的头指针\r\n    this.emptyTail = new DoubleLink() // 空的尾指针\r\n    this.emptyHead.next = this.emptyTail\r\n    this.emptyTail.prev = this.emptyHead\r\n    this.map = new Map() // key 是 key，value 是对应的双向链表节点\r\n};\r\n\r\n/**\r\n * @分析\r\n * 1。查找，如果查到了，就移动到最近链表头\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    if (this.map.has(key)) {\r\n        const node = this.findAndMoveToHead(key)\r\n        return node.value\r\n    }\r\n    return -1\r\n};\r\n\r\n/**\r\n * @分析\r\n * 1. 注意，如果已经存在 key，则不需要先判断 size -- 本人就是 put 的时候先删除链表尾了\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    // if (this.size === this.max) {\r\n    //     // 没有缓存了，先删除链表尾的\r\n    //     const node = this.emptyTail.prev\r\n    //     this.map.delete(node.key)\r\n    //     node.prev.next = this.emptyTail\r\n    //     this.emptyTail.prev = node.prev\r\n    //     this.size--\r\n    // }\r\n    // 查一下是否已经有值了\r\n    if (this.map.has(key)) {\r\n        const node = this.findAndMoveToHead(key)\r\n        node.value = value\r\n    } else {\r\n        if (this.size === this.max) {\r\n            // 没有缓存了，先删除链表尾的\r\n            const node = this.emptyTail.prev\r\n            this.map.delete(node.key)\r\n            node.prev.next = this.emptyTail\r\n            this.emptyTail.prev = node.prev\r\n            this.size--\r\n        }\r\n        // 直接加入到链表头\r\n        const node = new DoubleLink(key, value)\r\n        this.addToHead(node)\r\n        this.map.set(key, node) //缓存到 map 中去了\r\n         this.size++\r\n    }\r\n};\r\n\r\n/**\r\n * @分析\r\n * 1. 查找到 key 所在的位置，并将其移动到链表头，最后返回这个 node\r\n */\r\nLRUCache.prototype.findAndMoveToHead = function (key) {\r\n    const node = this.map.get(key)\r\n    // 先删除这个节点对应的位置\r\n    node.prev.next = node.next\r\n    node.next.prev = node.prev\r\n    // 移动到队列头\r\n    this.addToHead(node)\r\n    return node\r\n}\r\n\r\nLRUCache.prototype.addToHead = function(node){\r\n    node.prev = this.emptyHead\r\n    node.next = this.emptyHead.next\r\n    this.emptyHead.next.prev= node\r\n    this.emptyHead.next = node\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846326695","body":"### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/dfs-bian-li-by-jzsq_lyx-9ho6/)\r\n\r\n#### 分析\r\n- dfs 深度优先遍历，带一个 depth 参数表示层数即可求得最深路径\r\n- 时间复杂度 O（N） -- 其中 N 是树的节点数\r\n\r\n```javascript\r\n// 104. 二叉树的最大深度\r\n// https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/dfs-bian-li-by-jzsq_lyx-9ho6/\r\n\r\n\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0\r\n    let max = 0\r\n    const dfs = (root,depth) => {\r\n        if(!root.left && !root.right) {\r\n            // 叶子节点\r\n            max = Math.max(max,depth)\r\n            return \r\n        }\r\n        if(root.left) dfs(root.left,depth+1)\r\n        if(root.right) dfs(root.right,depth+1)\r\n    }\r\n    dfs(root,1)\r\n    return max\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846482105","body":"# 前端就该用 JS 刷算法143\r\n## 每日一题\r\n\r\n### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/solution/zi-di-xiang-shang-di-gui-pan-duan-by-jzs-7nhs/)\r\n#### 分析\r\n1. 既然是相同的树，那必须保证每一个节点都一样，即值，左右子树一致；每次我们只比对当前节点的情况，子树节点递归到的时候再处理；\r\n2. 当前节点如果同时为 null 的时候，证明递归到最底部，证明他们的父节点（叶子节点）是相同的，这个时候就可以返回 true 了\r\n3. 如果当前只有一个节点为 null，或者两个节点的值不相等，那么我们就返回 false\r\n4. 如果不是终止情况（false或者成功到达叶子节点后的true，则递归判断子树是否相等）\r\n5. 相同的树就是保证当前节点相等的同时，子树也应该相等；递阶段判断是否出现差错，一旦 false 就开始归返回；当到达了叶子结点的null后，归回来返回这一侧子树的最终结果，只要最终 root 节点一致，左右树返回的结果也相等，则返回 true\r\n\r\n```javascript\r\n// 100. 相同的树\r\nvar isSameTree = function (p, q) {\r\n    if(!p && !q ) return true //同时到达null，证明父节点是相等的\r\n    if ( !p || !q || p.val !== q.val ) return false // 值不相等，或者有一个为 null 的时候\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835972664","body":"### 思路\r\n1.先转成整数\r\n2.相加\r\n3.再转成数组\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        inta = 0\r\n        for i in A:\r\n            inta = inta*10 + i\r\n        inta = inta+K\r\n        res = []\r\n        for i in str(inta):\r\n            res.append(int(i))\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837578403","body":"### 思路\r\n解法1：先将所有目标字符位置找出，再遍历整个列表，计算与前后目标字符的距离绝对值，取值小的。\r\n解法2：正反遍历，取小值\r\n### 代码（Python3）\r\n#### 解法1：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                l.append(i)\r\n        k = 0\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=len(l)-1 and abs(i-l[k])>abs(i-l[k+1]):\r\n                k += 1\r\n            res.append(abs(i-l[k]))\r\n        return res\r\n```\r\n#### 解法2：\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n        \r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839337499","body":"### 思路\r\n用列表实现栈\r\n### 代码（Python3）\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i]+=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n### 复杂度\r\n- 时间复杂度：push O(1)  pop O(1)  increment O(k)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840229636","body":"### 思路\r\n用栈存储，倒着遍历，设置一个标志，初始值为False。\r\n当遇到数字的时候，标志设置为True\r\n当标志为True并且是字符的时候，出栈存储到临时列表里，直到遇到\"]\"\r\n将临时列表里的字符转成字符串，再以\"[\"分割，前面的是数值，后面的是字符，进行运算，并将结果压栈\r\n持续处理，直到结束。\r\n小技巧，最后一个如果是数值的话，最后一部分是不处理的，所以在字符串前面加一个字符，最后再删除可以省很多代码。\r\n### 代码（Python3）\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        flag = False\r\n        for c in s[::-1]+\"/\":\r\n            \r\n            if c.isdigit():\r\n                flag = True\r\n            if not c.isdigit() and flag:    \r\n                flag = False            \r\n                temp = []\r\n                while True:\r\n                    t = stack.pop()\r\n                    if t!=\"]\":\r\n                        temp.append(t)\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")\r\n                stack.append(int(temp[0])*temp[1])\r\n            stack.append(c)\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n        \r\n                    \r\n```\r\n### 复杂度\r\n- 时间复杂度：不会算O(n)?\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840901033","body":"### 思路\r\n用2个列表实现，一个入一个出，入就一直入，出的时候看出列表里是否有值，如果有，直接出，如果没有，把入队列里的数据全部倒过来。\r\n### 代码（Python3）\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.outstack) + len(self.instack)==0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841575957","body":"### 思路\r\n单调递增栈\r\n用一个单调栈来记录最大和最小\r\n遍历列表，如果当前值小于最大值（最后一个栈值），那它和前面比它大的值都应该在一块，所以，记录最大值，然后把所有比它大的值都出栈，再把当前最大值入栈，表示这些值都是一块。\r\n如果当前值大于等于最大值，那它就可以单独作为一块。\r\n最后返回栈的长度即为所求。\r\n### 代码(Python)\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            big = stack[-1] if stack else 0\r\n            if i<big:\r\n                while stack and i<stack[-1]:\r\n                    stack.pop()\r\n                stack.append(big)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841748579","body":"### 思路\r\n利用虚拟头结点。\r\n先遍历，找到长度。并把最后一个的next设置为头。\r\n再次遍历，到k%length的位置，把虚拟头结点的next设置为最后一个节点的next节点。\r\n把最后一个节点的next设置为None。\r\n\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        length = 0\r\n        virtualhead = ListNode(-1,head)\r\n        cur = virtualhead\r\n        while cur.next:\r\n            length+=1\r\n            cur = cur.next\r\n        cur.next = head\r\n        k = k%length\r\n        cur = head\r\n        for i in range(length-k-1):\r\n            cur = cur.next\r\n        virtualhead.next=cur.next\r\n        cur.next=None\r\n        return virtualhead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841898945","body":"### 思路\r\n模拟\r\n交换两个节点的顺序涉及到三个节点：前前，前，当前\r\n顺序如下：\r\n前.next=当前.next\r\n当前.next=前\r\n前前.next=当前\r\n### 代码（Python）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        virtualhead = ListNode(-1,head)\r\n        prepre = virtualhead\r\n        pre = head\r\n        cur = head.next\r\n        while pre and cur:\r\n            pre.next = cur.next  # 将前面节点的next设置为当前节点的下一个节点\r\n            cur.next = pre  # 当前节点的next设置为前一个节点\r\n            prepre.next = cur  # 前前节点的next设置为当前节点\r\n            prepre = pre  # prepre向后移动2个单位\r\n            pre = pre.next  # pre向后移动一个单位\r\n            if pre:  # 如果后面有节点，就把cur也向后移动\r\n                cur = pre.next\r\n        return virtualhead.next\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842732357","body":"### 思路\r\n解法1：\r\n先把链表转成列表，然后不断取中间节点，递归构建二叉树，但是空间复杂度有点高，觉得有点low\r\n解法2：\r\n先走一遍求出链表长度\r\n中序遍历递归构建二叉树\r\n递归过程：建立左子树，建立中间节点，指针后移，连接左子树，构建并连接右子树\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        # 求出长度\r\n        l = 0\r\n        cur = head\r\n        while cur:\r\n            l+=1\r\n            cur=cur.next\r\n        # 中序遍历递归构建二叉树\r\n        def dfs(left,right):\r\n            if left>right:\r\n                return None\r\n            mid = (left+right)//2  # 求出中间值\r\n            temp = dfs(left,mid-1)  # 递归构建左子树\r\n            nonlocal head\r\n            root  = TreeNode(head.val)  # 构建根节点\r\n            root.left = temp  # 把左子树连上\r\n            head = head.next  # 链表指针后移\r\n            root.right = dfs(mid+1,right)  # 构建并连上右子树\r\n            return root\r\n        \r\n        return dfs(0,l-1)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843646981","body":"### 思路\r\n正常的解法：\r\nA和B如果有交叉点，那后半部分一定是一样的，所以只需要先进行对齐，然后再进行遍历，一定能够找到相同的对象。\r\n如果找不到，那就是没有交叉点，返回None。\r\n### 代码(Python3)\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        la,lb=0,0\r\n        cura = headA\r\n        curb = headB\r\n        while cura:\r\n            la+=1\r\n            cura=cura.next\r\n        while curb:\r\n            lb+=1\r\n            curb=curb.next\r\n        if la>lb:\r\n            for i in range(la-lb):\r\n                headA=headA.next\r\n        else:\r\n            for i in range(lb-la):\r\n                headB=headB.next\r\n        for i in range(min(la,lb)):\r\n            if headA==headB:\r\n                return headA\r\n            headA=headA.next\r\n            headB=headB.next\r\n        return None\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844595194","body":"### 思路\r\n这道题没想出来，看了别人的题解才明白的。简言之，数学太菜。\r\n快慢指针，跑到相遇或头。\r\n如果相等就是相遇，如果不相等就是到头。\r\n然后慢指针从头跑，再跑到相遇，该位置就是所求。\r\n### 代码（Python3）\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        fast = head\r\n        slow = head\r\n        while fast and fast.next:            \r\n            fast=fast.next.next\r\n            slow=slow.next\r\n            if slow==fast:\r\n                break\r\n        if slow==fast:\r\n            slow = head\r\n            while slow!=fast:\r\n                slow=slow.next\r\n                fast=fast.next\r\n            return slow\r\n        return None\r\n        \r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845564657","body":"### 思路\r\nPython大法好。\r\n使用一个OrderedDict存储。\r\n添加的时候检查有没有在字典中，如果在，挪到后面，更新值。如果不在，看是否满了，满了，就先pop最左边的，然后加进来。没满，直接加进来。\r\n查找的时候一样，先看是否存在，存在，挪到后面，更新值。不在，返回-1\r\n### 代码（Python3）\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.cache = OrderedDict()\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        t = self.cache.get(key)\r\n        if t!=None:\r\n            self.cache.move_to_end(key,last=True)\r\n            return t        \r\n        return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if self.cache.get(key)!=None:\r\n            self.cache[key]=value\r\n            self.cache.move_to_end(key,last=True)\r\n            return\r\n        if self.size==0:\r\n            self.cache.popitem(last=False)\r\n            self.size+=1\r\n        self.size-=1\r\n        self.cache[key]=value\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(size)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846322342","body":"### 思路\r\n深度优先搜索DFS\r\n### 代码（Python3）\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        \r\n        def dfs(node,depth):\r\n            if not node:\r\n                return depth\r\n            return max(dfs(node.left,depth+1),dfs(node.right,depth+1))\r\n        res = dfs(root,0)\r\n        return res\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846482132","body":"### 思路\r\n递归比较当前节点是否都不存在，都不存在则返回True\r\n如果有一个节点存在，另一个不存在返回False\r\n如果两个都存在，比较节点值，不相同则返回False\r\n相同再递归比较左右节点。返回结果\r\n### 代码（Python3）\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        def dfs(node1,node2):\r\n            if not node1 and not node2:\r\n                return True\r\n            if node1 and node2:\r\n                if node1.val!=node2.val:\r\n                    return False\r\n                return dfs(node1.left,node2.left) and dfs(node1.right,node2.right)\r\n            return False\r\n        \r\n        return dfs(p,q)\r\n            \r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pkuphy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835973571","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = int(''.join(map(str, num))) + k\r\n        sum = map(int, str(sum))\r\n        return sum\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838010994","body":"思路：单调栈\r\n\r\n代码：\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -1e4\r\n        length = len(S)\r\n        result = []\r\n\r\n        for i in range(length):\r\n            if S[i] == C: pre = i\r\n            result.append(i - pre)\r\n        pre = 20000\r\n        for i in range(length - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            result[i] = min(result[i], pre - i)\r\n        return result\r\n```\r\n\r\n复杂度：\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839389349","body":"#### 思路\r\n用 list 实现栈\r\n\r\n#### 代码\r\n\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(len(self.stack), k)\r\n        for x in range(s):\r\n            self.stack[x] += val\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(n)\r\n\r\n\r\n#### 优化\r\n\r\n另外使用一个 list 记录当前位置以下的数字应该加多少值。\r\n在 `push()` 时插入`0`，`pop()` 时更新值，传递给下一位。\r\n\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.increments = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.increments.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            val = self.stack.pop()\r\n            inc = self.increments.pop()\r\n            if self.increments:\r\n                self.increments[-1] += inc\r\n            return val + inc\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(len(self.increments), k)\r\n        if s:\r\n            self.increments[s-1] += val\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840286758","body":"#### 思路\r\n按顺序处理字符串中的每一个字符。使用一个list模拟栈来处理。\r\n```\r\n如果是数字:\r\n    如果栈顶也是数字，将这两个字符合并为一个数字\r\n    否则将该数字压栈\r\n否则：\r\n    如果不是]字符，则将该字符压栈\r\n    否则:\r\n        往前找到匹配的[字符，将这部分拼接为一个字符串，乘以前面的数字后压栈\r\n合并栈中的所有字符串\r\n```\r\n\r\n#### 代码 Python\r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n\r\n        for x in s:\r\n            if x.isnumeric():\r\n                if stack and stack[-1].isnumeric():\r\n                    stack.append(stack.pop() + x)\r\n                else:\r\n                    stack.append(x)\r\n            else:\r\n                if x != ']':\r\n                    stack.append(x)\r\n                else:\r\n                    temp = x\r\n                    while temp[0] != '[':\r\n                        temp = stack.pop() + temp\r\n                    stack.append(int(stack.pop()) * temp[1:-1])\r\n        return ''.join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960279","body":"```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.in_stack = []\r\n        self.out_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.in_stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.out_stack:\r\n            while self.in_stack:\r\n                self.out_stack.append(self.in_stack.pop())\r\n        return self.out_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.out_stack:\r\n            return self.out_stack[-1]\r\n        else:\r\n            return self.in_stack[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not (self.in_stack or self.out_stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841655707","body":"这题比较难，先抄答案……\r\n```py\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for x in arr:\r\n            if not stack:\r\n                stack.append(x)\r\n            else:\r\n                if stack[-1] > x:\r\n                    current_max = stack[-1]\r\n                    while stack and stack[-1] > x:\r\n                        stack.pop()\r\n                    stack.append(current_max)\r\n                else:\r\n                    stack.append(x)\r\n        return len(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841775305","body":"思路：双指针\r\n\r\n```py\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if head:\r\n            p1 = head\r\n            p2 = head\r\n            count = 1\r\n            i = 0\r\n            while i < k:\r\n                if p2.next:\r\n                    count += 1\r\n                    p2 = p2.next\r\n                else:\r\n                    k = k % count\r\n                    i = -1\r\n                    p2 = head\r\n                i += 1\r\n\r\n            while p2.next:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head\r\n            p1.next = None\r\n            p2.next = head\r\n            return tmp\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841966043","body":"#### 思路\r\n添加一个虚拟头，之后两两分组\r\n\r\n#### 代码\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not (head and head.next):\r\n            return head\r\n\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        tail = dummy\r\n\r\n        while tail.next and tail.next.next:\r\n            node1 = tail.next\r\n            node2 = node1.next\r\n            tail.next = node2\r\n            \r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            tail = node1\r\n\r\n        return dummy.next\r\n```\r\n\r\n#### 复杂度\r\n空间：O(1)\r\n时间：O(n)\r\n\r\n---\r\n### 另一种解法\r\n使用递归\r\n\r\n### Code Python\r\n\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not (head and head.next):\r\n            return head\r\n\r\n        node2 = head.next\r\n        # node2.next = head\r\n        #  ^^^ 注意不能在这里将 head 赋值给 node2.next 因为下面还需要用到 node2.next\r\n        head.next = self.swapPairs(node2.next)\r\n        node2.next = head\r\n\r\n        return node2\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842766024","body":"#### 思路：\r\n快慢指针找到中间节点，递归构建左右子树\r\n\r\n#### 代码 python\r\n```py\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head :\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        fast, slow = head.next.next, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n\r\n        mid = slow.next\r\n        slow.next = None\r\n\r\n        root = TreeNode(mid.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(mid.next)\r\n        return root\r\n```\r\n\r\n#### 复杂度\r\n时间：O(nlogn)\r\n空间复杂度：O(logn)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843684678","body":"#### 思路：双指针\r\n\r\n#### 代码：py\r\n```py\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ha, hb = headA, headB\r\n        while ha != hb:\r\n            ha = ha.next if ha else headB\r\n            hb = hb.next if hb else headA\r\n        return ha\r\n```\r\n\r\n#### 复杂度：\r\n\r\n时间：O(A + B)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844649748","body":"#### 思路\r\n快慢指针\r\n第一次相遇时 A + B = 0，slow 向前走 A 到达入口，fast 从头走 A 到达入口。\r\n因此，第二次相遇时，即为入口。\r\n\r\n#### Code py\r\n\r\n```py\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n\r\n        while True:\r\n            if not(fast and fast.next):\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n\r\n        return fast\r\n```\r\n\r\n#### 复杂度\r\n\r\n时间：O(N)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845774193","body":"#### 思路\r\n使用 Python 数据结构中的 OrderedDict，新元素或者最近使用的元素放在后面，旧的元素放在前面。\r\n\r\nput：\r\n如果满了，就把头部第一个pop出，\r\n之后将key设为对应的value，放在尾部\r\n\r\nget：\r\n获取 key 对应的 value，如果是 None，则返回 -1；否则返回value，将key放在末尾\r\n\r\n这样是比较简单的\r\n\r\n#### 代码\r\n```py\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.cache = OrderedDict()\r\n\r\n    def get(self, key:int):\r\n        result = self.cache.get(key)\r\n        if result is not None:\r\n            self.cache.move_to_end(key)\r\n            return result\r\n        return -1\r\n\r\n    def put(self, key:int, value: int)-> None:\r\n        if key not in self.cache.keys() and len(self.cache) == self.capacity:\r\n            self.cache.popitem(last=False)\r\n\r\n        self.cache[key] = value\r\n        self.cache.move_to_end(key)\r\n```\r\n\r\n复杂度：\r\n空间：O(N)\r\n时间：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846324509","body":"#### 思路\r\n\r\n递归\r\n\r\n#### 代码 py\r\n\r\n```py\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n\r\n        return max(left_depth, right_depth) + 1\r\n```\r\n\r\n#### 复杂度\r\n空间：O(N)\r\n时间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846493158","body":"#### 思路\r\n\r\n递归\r\n\r\n#### 代码 py\r\n\r\n```py\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p is None and q is None:\r\n            return True\r\n        elif p is None or q is None:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n#### 复杂度\r\n时间：O(N)\r\n空间：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-835995408","body":"### 思路\r\n\r\nwhile num[i]存在 或者 k不为0:\r\n    当前位sum = 进位 + nums[i](如果存在) + k mod 10 (如果k不为0)；\r\n    倒序遍历num，同时k = k /10;\r\n    进位 carry = sum / 10;\r\n    当前位 digit = sum mod 10;\r\n    输出数组记录digit;\r\n如果最后一位有进位，添加到输出数组中;\r\n倒序返回输出数组；\r\n\r\n\r\n### 代码\r\n```java\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int carry = 0;\r\n        ArrayList<Integer> res = new ArrayList<>();\r\n        while (i>=0 || k != 0) {\r\n            int sum = carry;\r\n            if (i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if (k != 0) {\r\n                sum += k % 10;\r\n                k /= 10;\r\n            }\r\n\r\n            carry = sum / 10;\r\n            res.add(sum % 10);\r\n        }\r\n\r\n        if (carry > 0) {\r\n            res.add(carry);\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n// @lc code=end\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837392702","body":"### 思路\r\n正序遍历字符串,\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离1 = c上次出现的位置 - 当前位置\r\n\r\n逆序遍历字符串，\r\n    当c出现时，记录c的位置\r\n    当前字符与c的距离2 = 当前位置 - c上次出现的位置 \r\n    同时，最短距离 = min(距离1， 距离2）\r\n\r\n### 代码\r\n\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n\r\n        c_pos = -10000 #s.length < 10^4\r\n        i = 0\r\n        for char in s:\r\n            if char == c:\r\n                c_pos = i\r\n            res.append(i - c_pos)\r\n            i = i + 1\r\n        \r\n        c_pos = 10000 #s.length < 10^4\r\n        i = i - 1\r\n        for char in s[::-1]:\r\n            if char == c:\r\n                c_pos = i;\r\n            res[i] = min(res[i], c_pos - i)\r\n            i = i - 1\r\n        \r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)，不考虑输出数组。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839237025","body":"### 思路\r\n数组记录栈元素\r\n记录最大值\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    private ArrayList<Integer> arr;\r\n    private int maxSize = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.arr = new ArrayList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (arr.size() == maxSize) {\r\n            return;\r\n        }\r\n\r\n        arr.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (arr.size() > 0) {\r\n            return arr.remove(arr.size() - 1);\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i=0; i<arr.size() && k>0; i++,k--) {\r\n            arr.set(i, arr.get(i) + val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： push: O(1), pop: O(1), increment: O(N)，其中 N 为栈长度。\r\n- 空间复杂度：O(N)，N为栈长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840167926","body":"### 思路\r\n类似用栈判断括号匹配，每次括号匹配都是一次解析子串的过程。\r\nwhile 遍历字符串：\r\n1. 数字，记录到number中（不能立刻进栈因为数字可能不止一位）\r\n2. 字符，进栈\r\n3. 左侧括号，如果number不为空，进栈，然后number字符串清空；左侧括号也进栈。\r\n4. 右侧括号，栈顶元素依次出栈同时逆向组合到临时的字符串中，碰到左侧括号后，左侧括号的下一位就是重复的次数。之后把这次处理好的字符串压进栈。\r\n遍历结束后，栈里所有解析好的字串依次出栈，逆向组成结果。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        Stack<String> stack = new Stack<>();\r\n        String number = \"\";\r\n        \r\n        for (char c: chars) {\r\n            if (c >= '0' && c<= '9') {\r\n                number += c;\r\n            } else if (c == '[') {\r\n                if (!\"\".equals(number)) {\r\n                    stack.push(number);\r\n                    number = \"\";\r\n                }\r\n                stack.push(String.valueOf(c));\r\n            } else if (c == ']') {\r\n                // pop\r\n                String topStr;\r\n                StringBuffer buffer = new StringBuffer();\r\n                while (!\"[\".equals(topStr = stack.pop())) {\r\n                    buffer.insert(0, topStr);\r\n                }\r\n \r\n                String tmp = buffer.toString();\r\n                int repeat = Integer.parseInt(stack.pop()) - 1;\r\n                while (repeat != 0) {\r\n                    buffer.append(tmp);\r\n                    repeat--;\r\n                }\r\n                stack.push(buffer.toString());\r\n            } else {\r\n                // 'a' - 'z'\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer();\r\n        while (stack.size() != 0) {\r\n            res.insert(0, stack.pop());\r\n        }\r\n\r\n        // \"\"100[a]\"\"\r\n        // \"\"3[2[a]]\"\"\r\n        // \"\"30[22[a]]\"\"\r\n        // \"\"3[b3[a]]\"\"\r\n        return res.toString();\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N), N为解析后字符串长度 。\r\n- 空间复杂度：O(N)，N为解析后字符串长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840879664","body":"### 思路\r\n入列时用一个栈来记录所有元素；\r\n因为队列头实际在栈底，所以在出列时需要另外一个辅助栈来把当前栈反转；\r\n因此入列时需要把这个辅助栈再进行反转找到队尾；\r\n判断队列为空的条件时两个栈都为空；\r\n可以在push和pop操作的同时记录队列头，peek直接返回：push时如果队列为空则更新队列头；pop时把辅助栈的栈顶第二个元素更新为队列头。\r\n\r\n### 代码\r\n\r\n```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        self.top = 0\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if self.empty():\r\n            self.top = x\r\n\r\n        while self.pop_stack:\r\n            self.push_stack.append(self.pop_stack.pop())\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        ret = self.pop_stack.pop()\r\n        if self.pop_stack:\r\n            self.top = self.pop_stack.pop()\r\n            self.pop_stack.append(self.top)\r\n        else:\r\n            self.top = 0\r\n        return ret\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.top\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.push_stack and not self.pop_stack\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： push: 最差O(N)，连续push为O(1)； pop: O(N),连续pop为O(1)；peek: O(1)；empty: O(1) 。\r\n- 空间复杂度：O(N)，N为栈长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841539143","body":"### 思路\r\n想了30分钟总结不出规律，网上搜的提示……\r\n1. 在数组任意位置i,如果[0...i]的最大值，比[i+1..len-1]的最小值要小，那么就可以算作一个“块”。否则的话，排序的时候从右侧必须要换到左侧来，根据题目要求就不能算作一个块。\r\n2. 根据上述规律，对于数组的任意位置i，先计算[0...i]的最大值max，再计算[i+1...len-1]的最小值min，如果max[i] <= min[i+1]，就可以分出一个“块”。\r\n3. 边界条件是任何数组至少会有一个块。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int len = arr.length;\r\n        if (len == 1) {\r\n            return 1;\r\n        }\r\n\r\n        int[] maxFromleft = new int[len];\r\n        int[] minFromRight = new int[len];\r\n\r\n        maxFromleft[0] = arr[0];\r\n        for (int i=1; i<len; i++) {\r\n            maxFromleft[i] = Math.max(maxFromleft[i-1], arr[i]);\r\n        }\r\n\r\n        minFromRight[len-1] = arr[len-1];\r\n        for (int i=len-2; i>=0; i--) {\r\n            minFromRight[i] = Math.min(minFromRight[i+1], arr[i]);\r\n        }\r\n\r\n        int count = 1;\r\n        for (int i=0; i<len-1; i++) {\r\n            if (maxFromleft[i] <= minFromRight[i+1]) {\r\n                count++;\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N)，N为数组长度\r\n- 空间复杂度：O(N)，N为数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841724168","body":"### 思路\r\n新的链表头应该是原链表的倒数第k个节点；\r\nk可能大于链表长度，所以首先计算链表长度，再求余计算实际向右移动了多少步\r\n之后求出原链表的倒数第k个节点，它是新链表头，修改原链表相应节点指针后返回新链表头。\r\n当链表为空或者只有一个节点或者k是链表长度整数倍的时候，直接返回原链表头。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        // get the length and last node\r\n        ListNode last = head;\r\n        int len = 1;\r\n        while (last.next != null) {\r\n            last = last.next;\r\n            len++;\r\n        }\r\n\r\n        k = k % len;\r\n        if (k == 0) {\r\n            return head;\r\n        }\r\n\r\n        // get the kth node from the last\r\n        ListNode first = head;\r\n        ListNode second = head;\r\n        ListNode preSecond = null;\r\n        while (first != null) {\r\n            first = first.next;\r\n            if (k != 0) {\r\n                k--;\r\n            } else {\r\n                preSecond = second;\r\n                second = second.next;\r\n            }\r\n        }\r\n\r\n        preSecond.next = null;\r\n        last.next = head;\r\n        return second;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841863016","body":"### 思路\r\n交换链表的两个节点，除了维护这两个节点的指针外，还需要维护这两个节点前面的那个节点指针；\r\n因此在链表头之前创建一个假链表头来简化逻辑；\r\n遍历链表交换相邻节点。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode dummyHead = new ListNode(0, head);\r\n        ListNode pre = dummyHead;\r\n        ListNode first = head;\r\n        ListNode second = head.next;\r\n        while (first != null && second != null) {\r\n            // pre->first->second->..\r\n            swap(pre, first, second);\r\n\r\n            // second->first->..\r\n            pre = first;\r\n            first = first.next;\r\n            if (first != null) {\r\n                second = first.next;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return dummyHead.next;\r\n    }\r\n\r\n    private void swap(ListNode pre, ListNode first, ListNode second) {\r\n        first.next = second.next;\r\n        second.next = first;\r\n        pre.next = second;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(N),N为链表长度\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842675741","body":"### 思路\r\nBST的根节点应该是链表正中间的那个节点。\r\n用快慢指针的方法找到链表正中间的节点（如果是偶数的话，取正中间的两个节点之一），左子树就是链表左半部分，右子树就是右半部分。\r\n把链表从中间节点之前断开，递归调用方法构建BST。递归的出口是当链表为空（返回空指针）或者只有一个链表节点（直接返回根节点）。\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (head == nullptr) {\r\n            return nullptr;\r\n        } else if (head->next == nullptr) {\r\n            return new TreeNode(head->val);\r\n        }\r\n\r\n        ListNode* fast = head;\r\n        ListNode* slow = head;\r\n        ListNode* pre = nullptr;\r\n        while (fast != nullptr && fast->next != nullptr) {\r\n            pre = slow;\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n\r\n        if (pre != nullptr) {\r\n            pre->next = nullptr;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(slow->val);\r\n        root->left = sortedListToBST(head);\r\n        root->right = sortedListToBST(slow->next);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(NLogN),N为链表长度，每N/2个节点在每次递归都要遍历一次\r\n- 空间复杂度：O(logN),递归栈深度是树的高度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843624757","body":"### 思路\r\n这题做过。最开始的思路是遍历表A，节点存哈希表里。然后遍历表B，对比哈希表里的节点找交点\r\n更好的方法是，观察题目可知规律，定义两个指针，指针1从A头开始走到B尾（1->A->B），指针2从B头开始走到A尾（2->B->A）。当AB不相交时，两个指针同时为空。当AB相交时，两个指针相等的时候就是交点。\r\n### 代码\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* pA = headA;\r\n        ListNode* pB = headB;\r\n        while (pA != pB) {\r\n            if (pA == nullptr) {\r\n                pA = headB;\r\n            } else {\r\n                pA = pA->next;\r\n            }\r\n            if (pB == nullptr) {\r\n                pB = headA;\r\n            } else {\r\n                pB = pB->next;\r\n            }\r\n        }\r\n\r\n        return pA;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： O(A+B),A和B分别为两个链表长度\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844578253","body":"### 思路\r\n依稀记得有个什么规律，但是想不起来了。。。等会看看题解。\r\n用的笨方法：先快慢指针判断是否有环。然后继续把环上所有节点记录到set里。最后从链表头遍历判断节点是否在set中，如果在，此节点为入环的节点。\r\n### 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        boolean cycleFound = false;\r\n        while (fast != null && fast.next != null) {\r\n\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (fast == slow) {\r\n                cycleFound = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (cycleFound) {\r\n            HashSet<ListNode> set = new HashSet<>();\r\n            while (true) {\r\n                set.add(slow);\r\n                slow = slow.next;\r\n                fast = fast.next.next;\r\n                if (fast == slow) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n            slow = head;\r\n            while (true) {\r\n                if (set.contains(slow)) {\r\n                    return slow;\r\n                }\r\n                slow = slow.next;\r\n            }\r\n            \r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N),N为链表长度。\r\n- 空间复杂度：O(M)，M为环长度。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845338316","body":"### 思路\r\n链表，从头到尾按照最近使用到最少使用的顺序存放节点。\r\n所以当put / get时需要把当前节点更新为头结点，缓存满时需要删除尾节点。\r\n因此创建两个假的头节点和尾节点来简化操作逻辑。\r\n由于put/get需要在O(1)时间完成，所以还需要一个哈希表来存储节点。\r\n代码写完，测试总有小问题。。。写了个printList调试了一下。\r\n### 代码\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    private class ListNode {\r\n        ListNode prev = null;\r\n        ListNode next = null;\r\n        int key;\r\n        int val;\r\n        ListNode(int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n            this.prev = null;\r\n            this.next = null;\r\n        }\r\n    }\r\n\r\n    private int cap = 0;\r\n    private int size = 0;\r\n    private ListNode head; // recent used: head.next\r\n    private ListNode tail; // least used: tail.prev\r\n    private HashMap<Integer, ListNode> map; // { node->key : node }\r\n\r\n    public LRUCache(int capacity) {\r\n        this.cap = capacity;\r\n        map = new HashMap<Integer, ListNode>();\r\n        head = new ListNode(-1, 0);\r\n        tail = new ListNode(-1, 0);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            ListNode node = map.get(key);\r\n            moveToHead(node);\r\n\r\n            // printList(\"get \" + key);\r\n            return node.val;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        ListNode node = null;\r\n        if (map.containsKey(key)) {\r\n            // update\r\n            node = map.get(key);\r\n            node.val = value;\r\n\r\n            // this is the most recent one\r\n            moveToHead(node);\r\n            // printList(\"update \" + key);\r\n        } else {\r\n            // create a new one\r\n            node = new ListNode(key, value);\r\n\r\n            map.put(key, node);\r\n            addHeadNode(node);\r\n            size++;\r\n\r\n            // printList(\"put \" + key);\r\n\r\n            if (size > cap) {\r\n                if (tail.prev != null) {\r\n                    // remove the least used one at tail\r\n                    int removeKey = tail.prev.key;\r\n                    unlinkNode(tail.prev);\r\n\r\n                    // printList(\"remove cap \" + removeKey);\r\n\r\n                    // remove from map\r\n                    map.remove(removeKey);\r\n                }\r\n\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void moveToHead(ListNode node) {\r\n        unlinkNode(node);\r\n        addHeadNode(node);\r\n    }\r\n\r\n    private void unlinkNode(ListNode node) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n\r\n        // { prev <-> node <-> next } => { prev <-> next }\r\n        ListNode prevNode = node.prev;\r\n        ListNode nextNode = node.next;\r\n        if (prevNode != null) {\r\n            prevNode.next = nextNode;\r\n        }\r\n        if (nextNode != null) {\r\n            nextNode.prev = prevNode;\r\n        }\r\n\r\n        node.prev = null;\r\n        node.next = null;\r\n    }\r\n\r\n    private void addHeadNode(ListNode node) {\r\n        if (node == null) {\r\n            return;\r\n        }\r\n        // { head <-> headNext } => { head <-> node <-> headNext }\r\n        ListNode headNext = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n        if (headNext != null) {\r\n            headNext.prev = node;\r\n            node.next = headNext;\r\n        }\r\n    }\r\n\r\n    private void printList(String note) {\r\n        ListNode node = head;\r\n        StringBuffer out = new StringBuffer(note);\r\n        while (node != null) {\r\n            out.append(node.key);\r\n            out.append(\" -> \");\r\n            node = node.next;\r\n        }\r\n        System.out.println(out.toString());\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：get - O(1), put - O(1)\r\n- 空间复杂度：O(1)，capacity固定大小\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846264133","body":"### 思路\r\n递归或者bfs\r\n### 代码\r\n```py\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n\r\n        # bfs\r\n        queue = [root]\r\n        depth = 0\r\n        while queue:\r\n            cur_level = len(queue)\r\n            for i in range(cur_level):\r\n                node = queue.pop(0)\r\n                if node.left:\r\n                    queue.append(node.left)\r\n                if node.right:\r\n                    queue.append(node.right)\r\n            depth += 1\r\n\r\n        return depth\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N为树节点总数。\r\n- 空间复杂度：O(N)，最好1，最差N/2。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846440807","body":"### 思路\r\ndfs，判断条件是当前节点值相同且左右子树都相同。\r\n递归出口是当两个根节点都为空时，相同；当只有一个根节点为空时，不相同。\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else {\r\n            return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N为树节点总数。\r\n- 空间复杂度：O(h)，h为树高度。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836052238","body":"哈？老哥你不会是发错了吧😂\n\nxmlb88 ***@***.***> 于 2021年5月9日周日 下午9:38写道：\n\n> vector<int> addToArrayForm(vector<int>& num, int k) {\n>     vector<int> res;\n>     for (int i = num.size() - 1; i >= 0; --i) {\n>         int sum = num[i] + (k % 10);\n>         k /= 10;\n>         if (sum / 10) ++k;\n>         res.push_back(sum % 10);\n>     }\n>\n>     while (k) {\n>         res.push_back(k % 10);\n>         k /= 10;\n>     }\n>\n>     reverse(res.begin(), res.end());\n>     return res;\n> }\n>\n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836050621>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AT7X2IERQBJMNHNNMTESUQLTM42KPANCNFSM44PJ5S6A>\n> .\n>\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837866279","body":"代码：JAVA\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N=s.length\r\n     for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n prev = Integer.MAX_VALUE / 2; //整型反转，防止越界\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839781395","body":"class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n时间复杂度 O（k)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841295187","body":"语言：JAVA\r\n思路：用输入栈，输出栈实现\r\nclass MyQueue {\r\n    private Stack<Integer> a;// 输入栈\r\n    private Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n}\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n时间复杂度O（1）\r\n空间复杂度O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841681227","body":"思路：并不会，复制的.....\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n时间复杂度 O(NlogN)\r\n空间复杂度：O(N)\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843080325","body":"思路：分治算法\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n时间复杂度：O(n \\log n)O(nlogn)\r\n空间复杂度：O(\\log n)O(logn)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844068252","body":"public class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        /**\r\n        定义两个指针, 第一轮让两个到达末尾的节点指向另一个链表的头部, 最后如果相遇则为交点(在第一轮移动中恰好抹除了长度差)\r\n        两个指针等于移动了相同的距离, 有交点就返回, 无交点就是各走了两条指针的长度\r\n        **/\r\n        if(headA == null || headB == null) return null;\r\n        ListNode pA = headA, pB = headB;\r\n\r\n        while(pA != pB) {\r\n            pA = pA == null ? headB : pA.next;\r\n            pB = pB == null ? headA : pB.next;\r\n        }\r\n        return pA;\r\n    }\r\n}\r\n时间复杂度 : O(n)。\r\n空间复杂度 : O(1)。"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845582013","body":"思路：mark一下，这个不太会\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n时间复杂度 O（1）\r\n空间复杂度O（n）\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xmlb88":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836051481","body":"c++:\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int sum = num[i] + (k % 10);\r\n        k /= 10;\r\n        if (sum / 10) ++k;\r\n        res.push_back(sum % 10);\r\n    }\r\n\r\n    while (k) {\r\n        res.push_back(k % 10);\r\n        k /= 10;\r\n    }\r\n\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629554","body":"```c++\r\n// 暴力\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> idx;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) idx.push_back(i);\r\n    }\r\n\r\n    vector<int> res;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = INT_MAX;\r\n        for (int j = 0; j < idx.size(); ++j) {\r\n            dis = min(dis, abs(i - idx[j]));\r\n        }\r\n        res.push_back(dis);\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n```c++\r\n// 2次遍历\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res;\r\n    int last_idx = INT_MAX;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res.push_back(abs(last_idx - i));\r\n    }\r\n\r\n    last_idx = INT_MAX;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n        if (s[i] == c) last_idx = i;\r\n        res[i] = min(res[i], abs(last_idx - i));\r\n    }\r\n    \r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383175","body":"#### 数组模拟 ####\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    int max_size;\r\n    vector<int> st;\r\n    CustomStack(int maxSize) {\r\n        max_size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= max_size) {\r\n            return;\r\n        }\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (!st.empty()) {\r\n            int temp = st.back();\r\n            st.pop_back();\r\n            return temp;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, (int)st.size());\r\n        for (int i = 0; i < k; ++i) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n#### 优化increment ####\r\n> 用一个额外的add数组先存储increment操作\r\n> pop的时候再计算结果返回，add中对应的数累加到前一个数上\r\n> 时间复杂度O(1)\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> st, add;\r\n    int idx = -1;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize, 0);\r\n        add.resize(maxSize, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (idx == st.size() - 1) return;\r\n        st[++idx] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (idx == -1) return -1;\r\n        int ret = st[idx] + add[idx];\r\n        if (idx >= 1) {\r\n            add[idx - 1] += add[idx];\r\n        }\r\n        add[idx] = 0;\r\n        --idx;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, idx);\r\n        if (k >= 0) {\r\n            add[k] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840500709","body":"```c++\r\nstring decodeString(string s) {\r\n    stack<char> st_c;\r\n    stack<int> st_i;\r\n    \r\n    int num = 0;\r\n    for (char c : s) {\r\n        if (isdigit(c)) {\r\n            num = num * 10 + (c - '0');\r\n        } else {\r\n            if (c == '[') {\r\n                st_i.push(num);\r\n                num = 0;\r\n                st_c.push(c);\r\n            } else if (c == ']') {\r\n                string s;\r\n                while (st_c.top() != '[') {\r\n                    s.push_back(st_c.top());\r\n                    st_c.pop();\r\n                }\r\n                st_c.pop();\r\n                int count = st_i.top();\r\n                st_i.pop();\r\n                string s_repeat;\r\n                while (count--) {\r\n                    s_repeat += s;\r\n                }\r\n                while (!s_repeat.empty()) {\r\n                    st_c.push(s_repeat.back());\r\n                    s_repeat.pop_back();\r\n                }\r\n            } else {\r\n                st_c.push(c);\r\n            }\r\n        }\r\n    }\r\n\r\n    string res;\r\n    while (!st_c.empty()) {\r\n        res.push_back(st_c.top());\r\n        st_c.pop();\r\n    }\r\n    reverse(res.begin(), res.end());\r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942859","body":"#### 双栈解法 ####\r\n- 进栈时直接push进输入栈，出栈时若输出栈有元素，直接输出，若没有元素，把输入栈中的所有元素倒入输出栈再输出\r\n- 语言： c++\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st_in, st_out;\r\n    MyQueue() {\r\n\r\n    }\r\n\r\n    void push(int x) {\r\n        st_in.push(x);\r\n    }\r\n\r\n    void from_in_to_out() {\r\n        if (st_out.empty()) {\r\n            while (!st_in.empty()) {\r\n                st_out.push(st_in.top());\r\n                st_in.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    int pop() {\r\n        from_in_to_out();\r\n        int res = st_out.top();\r\n        st_out.pop();\r\n        return res;\r\n    }\r\n\r\n    int peek() {\r\n        from_in_to_out();\r\n        return st_out.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return st_in.empty() && st_out.empty();\r\n    }\r\n\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841614740","body":"### 栈保存每部分最大值 ###\r\n```c++\r\nint maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> st;\r\n    for (int num : arr) {\r\n        if (!st.empty() && num < st.top()) {\r\n            int head = st.top();\r\n            st.pop();\r\n            while (!st.empty() && num < st.top()) st.pop();\r\n            st.push(head);\r\n        } else {\r\n            st.push(num);\r\n        }\r\n    }\r\n    return st.size();\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841809674","body":"```c++\r\nListNode* rotateRight(ListNode* head, int k) {\r\n    if (k == 0 || !head || !head -> next) return head;\r\n    ListNode* node = head;\r\n    int size = 1;\r\n    while (node -> next) {\r\n        node = node -> next;\r\n        ++size;\r\n    }\r\n\r\n    node -> next = head;\r\n    int add = size - k % size;\r\n    while (add--) {\r\n        node = node -> next;\r\n    }\r\n    ListNode* res = node -> next;\r\n    node -> next = nullptr;\r\n    return res;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841954304","body":"- 递归\r\n\r\n```c++\r\nListNode* swapPairs(ListNode* head) {\r\n    if (!head || !head -> next) return head;\r\n\r\n    ListNode* cur = head;\r\n    ListNode* nxt = head -> next;\r\n    cur -> next = swapPairs(nxt -> next);\r\n    nxt -> next = cur;\r\n    return nxt;\r\n}\r\n```\r\n\r\n- 迭代\r\n\r\n```c++\r\nListNode* swapPairs(ListNode* head) {\r\n    if (!head || !head -> next) return head;\r\n    ListNode* cur = head;\r\n    ListNode* newHead = head -> next;\r\n    ListNode* pre = new ListNode(0);\r\n    pre -> next = head;\r\n\r\n    while (cur && cur -> next) {\r\n        ListNode* nxt = cur -> next;\r\n        pre -> next = nxt;\r\n        cur -> next = nxt -> next;\r\n        nxt -> next = cur;\r\n        pre = cur;\r\n        cur = cur -> next;\r\n    }\r\n\r\n    return newHead;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842798964","body":"```c++\r\n// 快慢指针找链表中点，切断后分别构建树\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n    if (!head) return nullptr;\r\n    if (!head -> next) return new TreeNode(head -> val);\r\n\r\n    // 用快慢指针找到链表的中点作为根节点\r\n    // 链表长度为奇数时必须是中心，偶数都可以\r\n    // 保存slow前驱节点方便从中点切断\r\n    ListNode *slow = head, *fast = head, *pre;\r\n    while (fast && fast -> next) {\r\n        pre = slow;\r\n        slow = slow -> next;\r\n        fast = fast -> next -> next;\r\n    }\r\n\r\n    pre -> next = nullptr;\r\n    // head -> ... pre -> nullptr; slow -> ... -> fast -> nullptr;\r\n    TreeNode* root = new TreeNode(slow -> val);\r\n    root -> left = sortedListToBST(head);\r\n    root -> right = sortedListToBST(slow -> next);\r\n    return root;\r\n}\r\n// 时间O(nlogn)\r\n// 空间O(logn)\r\n```\r\n\r\n```c++\r\n// 链表转换为数组再分治\r\nvector<int> vec;\r\nTreeNode* makeTree(int start, int end) {\r\n    if (start > end) return nullptr;\r\n\r\n    int mid = start + (end - start) / 2;\r\n    TreeNode* root = new TreeNode(vec[mid]);\r\n    root -> left = makeTree(start, mid - 1);\r\n    root -> right = makeTree(mid + 1, end);\r\n    return root;\r\n}\r\n\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n    if (!head) return nullptr;\r\n    while (head) {\r\n        vec.push_back(head -> val);\r\n        head = head -> next;\r\n    }\r\n    return makeTree(0, vec.size() - 1);\r\n}\r\n// 时间O(n)\r\n// 空间O(n)\r\n```\r\n\r\n```c++\r\n// 直接进行中序遍历\r\nint getListLength(ListNode* head) {\r\n    int length = 0;\r\n    while (head) {\r\n        ++length;\r\n        head = head -> next;\r\n    }\r\n    return length;\r\n}\r\n\r\n// head必须声明成&，或者在外部保存\r\nTreeNode* makeTree(ListNode*& head, int start, int end) {\r\n    if (start > end) return nullptr;\r\n\r\n    int mid = start + (end - start) / 2;\r\n    TreeNode* root = new TreeNode();    // 先占坑，暂不赋值\r\n    root -> left = makeTree(head, start, mid - 1);\r\n    // 回来时更新值，head后移\r\n    root -> val = head -> val;\r\n    head = head -> next;\r\n    root -> right = makeTree(head, mid + 1, end);\r\n    return root;\r\n}\r\n\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n    int length = getListLength(head);\r\n    return makeTree(head, 0, length - 1);\r\n}\r\n// 时间O(n)\r\n// 空间O(logn)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843700919","body":"### 双指针 ###\r\n\r\n- 两个指针分别指向A和B开始遍历\r\n- 当指针遇到一条链表尾部时，重新从另一条链表的头部再遍历\r\n- 循环结束条件：\r\n- 存在相交点，2指针在交点相遇\r\n- 不存在相交点，2指针遍历完后均等于nullptr\r\n\r\n```c++\r\nListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\r\n    ListNode *cur_A = headA, *cur_B = headB;\r\n    while (cur_A != cur_B) {\r\n        cur_A = cur_A ? cur_A -> next : headB;\r\n        cur_B = cur_B ? cur_B -> next : headA;\r\n    }\r\n    return cur_A;\r\n}\r\n\r\n// 时间O(n)\r\n// 空间O(1)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844610714","body":"```c++\r\n// 快慢指针判断环\r\n// 相遇后将任意指针置为起点，一起移动找到环起始结点\r\nListNode* detectCycle(ListNode* head) {\r\n    ListNode *fast = head, *slow = head;\r\n    while (fast && fast -> next) {\r\n        slow = slow -> next;\r\n        fast = fast -> next -> next;\r\n        if (fast == slow) break;\r\n    }\r\n\r\n    if (!fast || !fast -> next) return nullptr;\r\n    fast = head;\r\n    while (fast != slow) {\r\n        fast = fast -> next;\r\n        slow = slow -> next;\r\n    }\r\n    return fast;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845897854","body":"### 哈希表 + 双向链表 ###\r\n\r\n> 用List类\r\n\r\n```c++\r\nclass LRUCache {\r\npublic:\r\n    int cap;\r\n    list<pair<int, int>> cache;\r\n    unordered_map<int, list<pair<int, int>>::iterator> map;\r\n\r\n    LRUCache(int capacity) {\r\n        cap = capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (map.find(key) == map.end()) return -1;\r\n        auto it = map[key];\r\n        int value = it -> second;\r\n        cache.erase(it);\r\n        cache.push_front(make_pair(key, value));\r\n        map[key] = cache.begin();\r\n        return value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (map.find(key) != map.end()) {\r\n            auto it = map[key];\r\n            cache.erase(it);\r\n            cache.push_front(make_pair(key, value));\r\n            map[key] = cache.begin();\r\n        } else {\r\n            if (cache.size() == cap) {\r\n                auto del = cache.back();\r\n                map.erase(del.first);\r\n                cache.pop_back();\r\n            }\r\n            cache.push_front(make_pair(key, value));\r\n            map[key] = cache.begin();\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n> 实现双向链表\r\n\r\n```c++\r\nstruct DulNode {\r\n    int key;\r\n    int val;\r\n    DulNode* pre;\r\n    DulNode* next;\r\n    DulNode() : key(0), val(0), pre(nullptr), next(nullptr) {}\r\n    DulNode(int x, int y) : key(x), val(y), pre(nullptr), next(nullptr) {}\r\n    DulNode(int x, int y, DulNode* _pre, DulNode* _next) :\r\n        key(x), val(y), pre(_pre), next(_next) {}\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    int cap, size = 0;\r\n    DulNode *head, *tail;\r\n    unordered_map<int, DulNode*> map;\r\n\r\n    LRUCache(int capacity) {\r\n        cap = capacity;\r\n        head = new DulNode();\r\n        tail = new DulNode();\r\n        head -> next = tail;\r\n        tail -> pre = head;\r\n    }\r\n\r\n    void delete_node(DulNode* node) {\r\n        DulNode* pre_node = node -> pre;\r\n        DulNode* next_node = node -> next;\r\n        pre_node -> next = next_node;\r\n        next_node -> pre = pre_node;\r\n        map.erase(node -> key);\r\n        delete node;\r\n        --size;\r\n    }\r\n\r\n    void push_front(int key, int value) {\r\n        DulNode* node = new DulNode(key, value);\r\n        DulNode* next_node = head -> next;\r\n        node -> next = next_node;\r\n        next_node -> pre = node;\r\n        head -> next = node;\r\n        node -> pre = head;\r\n        map[key] = node;\r\n        ++size;\r\n    }\r\n\r\n    void pop_back() {\r\n        if (size == 0) return;\r\n        DulNode* last_node = tail -> pre;\r\n        DulNode* pre_node = last_node -> pre;\r\n        pre_node -> next = tail;\r\n        tail -> pre = pre_node;\r\n        map.erase(last_node -> key);\r\n        delete last_node;\r\n        --size;\r\n    }\r\n\r\n    int get(int key) {\r\n        if (map.find(key) == map.end()) return -1;\r\n        DulNode* node = map[key];\r\n        int value = node -> val;\r\n        delete_node(node);\r\n        push_front(key, value);\r\n        return value;\r\n    }\r\n\r\n    void put(int key, int value) {\r\n        if (map.find(key) != map.end()) {\r\n            DulNode* node = map[key];\r\n            delete_node(node);\r\n            push_front(key, value);\r\n        } else {\r\n            if (size == cap) {\r\n                pop_back();\r\n            }\r\n            push_front(key, value);\r\n        }\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846398419","body":"> 递归\r\n\r\n```c++\r\nint maxDepth(TreeNode *root) {\r\n    if (!root) return 0;\r\n    return max(maxDepth(root -> left), maxDepth(root -> right)) + 1;\r\n}\r\n```\r\n\r\n> 迭代\r\n\r\n```c++\r\nint maxDepth(TreeNode* root) {\r\n    int res = 0;\r\n    queue<TreeNode*> q;\r\n    if (root) q.push(root);\r\n    while (!q.empty()) {\r\n        int size = q.size();\r\n        for (int i = 0; i < size; ++i) {\r\n            TreeNode* node = q.front();\r\n            q.pop();\r\n            if (node -> left) q.push(node -> left);\r\n            if (node -> right) q.push(node -> right);\r\n        }\r\n        ++res;\r\n    }\r\n    return res;\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Saberfish":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836053127","body":"## 代码\r\n\r\nC++ :\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int i=num.size()-1;\r\n        while(k>0){\r\n            k=k+num[i];\r\n            num[i]=k%10;\r\n            k=k/10;\r\n            i--;\r\n            if(i<0 && k>0){\r\n                num.insert(num.begin(),0);\r\n                i=0;\r\n            }\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837693091","body":"### 思路\r\n\r\n\t先把所有目标字符的下标存到数组里面，再进行遍历查找每个字符的距离。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int lenS=S.size();\r\n        vector<int> dest={};\r\n        for(int i=0;i<lenS;i++){\r\n            if(C==S[i]){\r\n                dest.insert(dest.end(),i);\r\n            }\r\n        }\r\n        int lenD=dest.size();\r\n        vector<int> output={};\r\n        for(int i=0;i<lenS;i++){\r\n            int a=i;\r\n            int distance=10000;\r\n            for(int j=0;j<lenD;j++){\r\n                int b=dest[j];\r\n                int dis=0;\r\n                if(a<b){\r\n                    dis=b-a;\r\n                }\r\n                else{\r\n                    dis=a-b;\r\n                }\r\n                if(dis<distance){\r\n                    distance=dis;\r\n                }\r\n            }\r\n            output.insert(output.end(),distance);\r\n        }\r\n        return output;\r\n    }\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839367190","body":"vector模拟\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> modifyStack;//这是声明还是定义？\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        top=-1;\r\n        modifyStack.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top==modifyStack.size()-1){\r\n            return;\r\n        }\r\n        modifyStack[++top]=x;\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n            return modifyStack[top--];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(k>modifyStack.size()) k=modifyStack.size();\r\n        for(int i=0;i<k;i++){\r\n            modifyStack[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637813","body":"维护两个栈，一个用来存数字，一个用来存字符串\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> k_stack;\r\n        stack<string> s_stack;\r\n        string curStr;\r\n        int length=s.length();\r\n        int temp=0;\r\n        for(int i=0;i<length;i++){\r\n            if(isdigit(s[i])){\r\n                //temp=temp*10+s[i]-'0';\r\n                do{\r\n                    temp=temp*10+s[i]-'0';\r\n                }while(isdigit(s[++i]));\r\n                --i;\r\n            }else if(isalpha(s[i])){\r\n                curStr+=s[i];\r\n            }else if(s[i]=='['){\r\n                k_stack.push(temp);\r\n                temp=0;\r\n                s_stack.push(curStr);\r\n                curStr.clear();\r\n            }else{//s[i]=']'\r\n                int times=k_stack.top();\r\n                k_stack.pop();\r\n                for(int j=0;j<times;j++){\r\n                    s_stack.top()+=curStr;\r\n                }\r\n                curStr=s_stack.top();\r\n                s_stack.pop();\r\n            }\r\n        }\r\n        return curStr;\r\n    }\r\n};\r\n```\r\n复杂度：\r\n时间 O(N)\r\n空间 O(N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841192447","body":"## 思路\r\n一个入栈，一个出栈。当进行pop和peak操作的时候先判断出栈是否为空，为空就将入栈的元素倒过去，非空就直接pop返回值。\r\n## 代码\r\n\r\n```C++\r\nclass MyQueue{\r\npublic:\r\n    stack<int> inStack;\r\n    stack<int> outStack;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(outStack.empty()){\r\n            while (!inStack.empty())\r\n            {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        int temp=outStack.top();\r\n        outStack.pop();\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(outStack.empty()){\r\n            while (!inStack.empty())\r\n            {\r\n                outStack.push(inStack.top());\r\n                inStack.pop();\r\n            }\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if(inStack.empty()&&outStack.empty()){\r\n            return true;\r\n        }\r\n        else return false;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- ​\t时间复杂度o(1)\r\n- ​\t空间复杂度o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841661300","body":"### 思路\r\n使用单调栈，栈内保存的是局部最大值，实际上要求达到的效果就是后一个块的最小值大于前一个块的最大值\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int len=arr.size();\r\n        stack<int> localMaxVal;\r\n        localMaxVal.push(arr[0]);\r\n        for(int i=1;i<len;i++){\r\n            int curVal=max(localMaxVal.top(),arr[i]);\r\n            while (!localMaxVal.empty() && arr[i]<localMaxVal.top())\r\n            {\r\n                localMaxVal.pop();\r\n            }\r\n            localMaxVal.push(curVal);\r\n            \r\n        }\r\n        return localMaxVal.size();\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841814580","body":"思路：先将链表串成环，然后k对长度取余，然后找链表头前面的元素，并插入链表尾，返回新的链表头\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL) return NULL;\r\n        if(head->next == NULL) return head;\r\n        //获得链表长度，并将链表串成环\r\n        int len=1;\r\n        ListNode* oldTail=head;\r\n        while(oldTail->next!=NULL){\r\n            oldTail=oldTail->next;\r\n            len+=1;\r\n        }\r\n        oldTail->next=head;\r\n        ListNode* newHead=head;\r\n        for(int i=0;i<(len+1-k%len-1-1);i++){\r\n            newHead=newHead->next;\r\n        }\r\n        ListNode *temp=newHead->next;\r\n        newHead->next=NULL;\r\n        return temp;\r\n    }\r\n};\r\n```\r\n复杂度：\r\n时间：O(n）\r\n空间：O(1）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842344330","body":"### 思路\r\n创建一个空的链表头，扫描一遍进行交换就完事儿了\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head==nullptr) return head;\r\n        if(head->next==nullptr) return head;\r\n        ListNode* prenode=new ListNode();\r\n        prenode->next=head;\r\n        head=head->next;\r\n        while(prenode->next!=nullptr && prenode->next->next!=nullptr){\r\n            ListNode* curNode=prenode->next;\r\n            ListNode* nextNode=curNode->next;\r\n            prenode->next=nextNode;\r\n            curNode->next=nextNode->next;\r\n            nextNode->next=curNode;\r\n            prenode=curNode;\r\n        }\r\n        return head;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843165629","body":"### 思路\r\n这题之前做过，思路就是快慢指针，然后递归的选择中点构造二叉搜索树。\r\n### C++代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    TreeNode* myTree(ListNode* left, ListNode *right){\r\n        if(left==right){\r\n            return nullptr;\r\n        }\r\n        ListNode* fast=left;\r\n        ListNode* slow = left;\r\n        while(fast!=right && fast->next != right){\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        }\r\n        ListNode* mid = slow;\r\n        TreeNode* root = new TreeNode(mid->val);\r\n        root->left = myTree(left, mid);\r\n        root->right = myTree(mid->next, right);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return myTree(head ,nullptr);\r\n\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(logn)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844181889","body":"### 思路\r\n这不就是快乐的双指针遍历嘛！\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* pA=headA;\r\n        ListNode* pB=headB;\r\n        while(pA!=pB){\r\n            if(pA==NULL) pA=headB;\r\n            else pA=pA->next;\r\n            if(pB==NULL) pB=headA;\r\n            else pB=pB->next;\r\n        }\r\n        return pA;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N）\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845141207","body":"例题，直接快慢指针\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(head==NULL) return NULL;\r\n        if(head->next==NULL) return NULL;\r\n        ListNode* fast,*slow;\r\n        fast=slow=head;\r\n        do{\r\n            if(fast->next!=NULL && fast->next->next!=NULL){\r\n                fast=fast->next->next;\r\n                slow=slow->next;\r\n            }\r\n            else return NULL;\r\n        }while(fast!=slow);\r\n        fast=head;\r\n        while(fast!=slow){\r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        return fast;\r\n\r\n    }\r\n};\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846041764","body":"### 思路\r\n使用双向链表和哈希表\r\n\r\n```C++\r\nstruct D_Link_Node {\r\n    int key, value;\r\n    D_Link_Node* prev;\r\n    D_Link_Node* next;\r\n    D_Link_Node(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    D_Link_Node(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, D_Link_Node*> cache;\r\n    D_Link_Node* head;\r\n    D_Link_Node* tail;\r\n    int LRU_size;\r\n    int LRU_capacity;\r\n\r\npublic:\r\n    LRUCache(int capacity): LRU_capacity(capacity), LRU_size(0) {\r\n        head = new D_Link_Node();\r\n        tail = new D_Link_Node();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        D_Link_Node* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            D_Link_Node* node = new D_Link_Node(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++LRU_size;\r\n            if (LRU_size > LRU_capacity) {\r\n                D_Link_Node* removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --LRU_size;\r\n            }\r\n        }\r\n        else {\r\n            D_Link_Node* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(D_Link_Node* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(D_Link_Node* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(D_Link_Node* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    D_Link_Node* removeTail() {\r\n        D_Link_Node* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846415125","body":"### 思路\r\n\r\nDFS就完事儿啦\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root) return 0;\r\n        int maxL=maxDepth(root->left);\r\n        int maxR=maxDepth(root->right);\r\n        return max(maxL,maxR) + 1;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiongyujie":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836058937","body":"语言：java\r\n时间复杂度：O(9n) => O(n) ,数组插入\r\n空间复杂度：除去输出结果,空间复杂度O(1)\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int out = 0 ;\r\n        int len = num.length;\r\n        int i = len - 1;\r\n        for(; i >= 0 && k > 0; i--){\r\n            int tmp =out + num[i] +  k % 10;\r\n            out = tmp / 10;\r\n            k = k / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        while(i >= 0){\r\n            int tmp = out + num[i];\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n            i--;\r\n        }\r\n        while(k > 0){\r\n            int tmp = out + k % 10;\r\n            k = k / 10;\r\n            out = tmp / 10;\r\n            res.add(0, tmp % 10);\r\n        }\r\n        if(out > 0){\r\n            res.add(0, out);\r\n        }\r\n        return res ;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837711066","body":"思路：两次遍历，第一次记住字符c的下标，第二次计算与字符c的最近距离。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        List<Integer> tmp = new ArrayList<>();\r\n        int index = 0 ;\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                tmp.add(i);\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < len; i++ ){\r\n            int cur =  tmp.get(index);\r\n            if(index < 1){\r\n                res[i] = Math.abs(i - cur);\r\n            }else{\r\n                res[i] = Math.min(Math.abs(i - cur), Math.abs(i - tmp.get(index - 1)));\r\n            }\r\n            if(i == tmp.get(index) && (index + 1) < tmp.size()){\r\n                index ++ ;\r\n            }\r\n        }\r\n        return res ;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383583","body":"思路：就是用数组记录一下\r\n时间复杂度：增量操作O(min(k,top),其他O(1)\r\n空间复杂度：使用数组O(n)\r\n\r\n```\r\nclass CustomStack {\r\n    int[] arr;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < arr.length){\r\n            arr[top++] = x;\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == 0){\r\n            return -1;\r\n        }\r\n        return arr[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < k && i < top; i++){\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840350994","body":"麻瓜，做了半天\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n        Stack<Integer> sk1 = new Stack<>();\r\n        Stack<String> sk2 = new Stack<>();\r\n        int i = 0;\r\n        int len = s.length();\r\n        StringBuilder sb = new StringBuilder();\r\n        int num = 0;\r\n        while(i < len){\r\n            char ch =  s.charAt(i);    \r\n            i++;    \r\n            if(ch - '0' >= 0 && ch - '0' < 10){\r\n               num = num * 10 + (ch - '0');\r\n            }else if(ch == '['){\r\n                sk1.add(num);\r\n                num = 0;\r\n                while(ch - 'a' >= 0 && ch - 'a' < 26 && i < len){\r\n                    ch = s.charAt(i++);\r\n                    sb.append(ch);\r\n                }\r\n                sk2.add(sb.toString());\r\n                sb = new StringBuilder();\r\n            }else if(ch == ']'){\r\n                int num2 = sk1.pop();\r\n                String str = sk2.pop();\r\n                for(int j = 0; j < num2; j++){\r\n                    sb.append(str);\r\n                }\r\n                if(sk2.isEmpty()){\r\n                    sk2.add(sb.toString());\r\n                }else{\r\n                    sk2.add( sk2.pop() + sb.toString());\r\n                }\r\n                sb = new StringBuilder();\r\n            }else{\r\n                 if(sk2.isEmpty()){\r\n                    sk2.add(\"\" + ch);\r\n                }else{\r\n                    sk2.add(sk2.pop() + \"\" + ch);\r\n                }\r\n            }\r\n\r\n        }\r\n        return sk2.pop();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840965702","body":"简单题还是好做啊\r\n分析：用两个栈模拟，一个\"出栈\"，一个\"入栈\"。每次入队的时候，判断\"出栈\"是否为空，如果不为空，将出栈的数据压入”入栈“，每次出队的时候，判断”入栈“是否为空，如果不为空，将入栈数据压入出栈。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> inSk;\r\n    Stack<Integer> outSk;\r\n    public MyQueue() {\r\n        inSk = new Stack<>();\r\n        outSk = new Stack<>();\r\n    }\r\n    \r\n\r\n    public void push(int x) {\r\n        while(!outSk.isEmpty()){\r\n            inSk.add(outSk.pop());\r\n        }\r\n        inSk.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!inSk.isEmpty()){\r\n            outSk.add(inSk.pop());\r\n        }\r\n        return outSk.pop();\r\n    }\r\n    public int peek() {\r\n         while(!inSk.isEmpty()){\r\n            outSk.add(inSk.pop());\r\n        }\r\n        return outSk.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n\r\n        return inSk.isEmpty() && outSk.isEmpty();\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841819340","body":"以前做的，链接成环\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(k==0 || head==null){\r\n            return head;\r\n        }\r\n        int n = 1 ;\r\n        ListNode end = head ;\r\n        while(end.next!=null){\r\n            end = end.next ;\r\n            n++; \r\n        }\r\n        end.next = head ;\r\n        k = k%n; \r\n        k = n - k;\r\n        while(k>0){\r\n            k--;\r\n            head = head.next;\r\n            end = end.next;\r\n        }\r\n        end.next = null;\r\n        return head ;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841946375","body":"偷懒了。以前做过\r\n空间复杂度：O(n)\r\n时间复杂度：O(1)\r\n\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null || head.next==null){\r\n            return head;\r\n        }\r\n        ListNode l1 = head;\r\n        ListNode l2 = head.next;\r\n        ListNode cur = l2 ; \r\n        l1.next = l2.next;\r\n        l2.next = l1 ;\r\n        while(l1.next!=null&&l1.next.next!=null){\r\n          l1 = l1.next;\r\n          l2 = l2.next;\r\n          l2.next = l1.next ;\r\n          l2 = l2.next;\r\n          l1.next = l2.next; \r\n          l2.next = l1 ;\r\n        }\r\n        return cur ;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842823798","body":"思路，数组存储，然后构建\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n```\r\nclass Solution {\r\n    List<Integer> tmp ;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        tmp = new ArrayList<>();\r\n        while(head != null){\r\n            tmp.add(head.val);\r\n            head = head.next ;\r\n        }\r\n        TreeNode root = helper(0, tmp.size()-1);\r\n\r\n        return root ;\r\n    }\r\n\r\n    public TreeNode helper(int l, int r){\r\n        if(r < l){\r\n            return null ;\r\n        }\r\n        int mid = l + (r - l) / 2;\r\n        TreeNode root = new TreeNode(tmp.get(mid));\r\n\r\n        root.left = helper(l, mid - 1 );\r\n        root.right = helper(mid + 1, r);\r\n\r\n        return root;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843693773","body":"思路：得到两个链表的长度，将链表长度对齐，然后遍历找到相同节点，没有相同节点，返回空；\r\n时间复杂度：O(max(m, n))\r\n空间复杂度：O(1)\r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int len1 = getLength(headA);\r\n        int len2 = getLength(headB);\r\n        ListNode res = null ;\r\n        if(len1 > len2){\r\n            res = getResult(headA, headB, len1, len2);\r\n        }else{\r\n            res = getResult(headB, headA, len2, len1);\r\n        }\r\n\r\n        return res;\r\n        \r\n    }\r\n    public ListNode getResult(ListNode headA, ListNode headB, int len1, int len2){  \r\n        int count = len1 - len2;\r\n        while(count > 0 && headA != null){\r\n            count --;\r\n            headA = headA.next;\r\n        }\r\n        while(headA != null && headB != null){\r\n            if(headB == headA){\r\n                return headA;\r\n            }\r\n            headA = headA.next;\r\n            headB = headB.next;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    public int getLength(ListNode node){\r\n        int len = 0;\r\n        ListNode tmp = node ;\r\n        while(tmp != null){\r\n            tmp = tmp.next;\r\n            len ++ ;\r\n        }\r\n\r\n        return len ;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844656354","body":"以前写过，还是想用数组存储，今天就偷懒了\r\n\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode h1 = head;\r\n        ListNode h2 = head;\r\n        ListNode h3 = head;\r\n        while(h1 != null && h2 != null){\r\n            h1 = h1.next;\r\n            h2 = h2.next; \r\n            if(h2 != null){\r\n                h2 = h2.next ;\r\n            }else{\r\n                return null;\r\n            }\r\n            if(h1 == h2){\r\n                break ;\r\n            }\r\n        }\r\n\r\n        while(h1! = null&&h3!=null){\r\n            if(h1 == h3){\r\n                return h1;\r\n            }\r\n            h1 = h1.next;\r\n            h3 = h3.next;\r\n        }\r\n        \r\n        return null ;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845932517","body":"注意细节，利用双向链表和HashMap实现\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)\r\n```\r\nclass TLinkedList{\r\n    TLinkedList pre, next;\r\n    int val, key;\r\n    public TLinkedList(int key, int val){\r\n        this.key = key;\r\n        this.val = val;\r\n        this.pre = null;\r\n        this.next = null;\r\n    }\r\n\r\n    public TLinkedList(int key, int val, TLinkedList pre, TLinkedList next){\r\n        this.key = key;\r\n        this.val = val;\r\n        this.pre = pre;\r\n        this.next = next;\r\n    }\r\n}\r\nclass LRUCache {\r\n\r\n    Map<Integer, TLinkedList> hm;\r\n    TLinkedList start, end;\r\n    int capacity;\r\n    public LRUCache(int capacity) {\r\n        hm = new HashMap<>();\r\n        start = new TLinkedList(-1, -1);\r\n        end = new TLinkedList(-1, -1);\r\n        start.next = end ;\r\n        end.pre = start;\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!hm.containsKey(key)){\r\n            return -1 ;\r\n        }\r\n        TLinkedList tmp = hm.get(key);\r\n        tmp.pre.next = tmp.next;\r\n        tmp.next.pre = tmp.pre ;\r\n        start.next.pre = tmp;\r\n        tmp.next = start.next;\r\n        tmp.pre = start;\r\n        start.next = tmp;\r\n        hm.put(key, tmp);\r\n        return tmp.val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(hm.containsKey(key)){\r\n            TLinkedList tmp = hm.get(key);\r\n            tmp.val = value;\r\n            tmp.pre.next = tmp.next;\r\n            tmp.next.pre = tmp.pre ;\r\n            start.next.pre = tmp;\r\n            tmp.next = start.next;\r\n            tmp.pre = start;\r\n            start.next = tmp;\r\n            hm.put(key, tmp);\r\n            return ;\r\n        }\r\n        if(hm.size() < capacity){\r\n            TLinkedList tmp = new TLinkedList(key, value, start, start.next);\r\n            start.next.pre = tmp;\r\n            start.next = tmp;\r\n            hm.put(key, tmp);\r\n            return ;\r\n        }\r\n        hm.remove(end.pre.key);\r\n        end.pre = end.pre.pre;\r\n        end.pre.next = end ;\r\n        TLinkedList tmp = new TLinkedList(key, value, start, start.next);\r\n        start.next.pre = tmp;\r\n        start.next = tmp;\r\n        hm.put(key, tmp);\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846365604","body":"分别找到左右子树的最大深度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0 ;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846509670","body":"判断两节点数字是否相同，如果相同就判断其左右子树节点，当一个节点为空时，另一个节点也必须为空。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null || q == null){\r\n            return p == q;\r\n        }\r\n\r\n        return  p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Syan115":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836060783","body":"思路：\r\n1. 从低位起按位相加，注意进位问题\r\n2. list反转一下\r\n\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n```class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        int sum = 0;\r\n        List<Integer> res = new ArrayList<>();\r\n        // 按位相加\r\n        for(int i=n-1; i>=0; i--){\r\n            sum = num[i] + k%10;\r\n            if(sum>=10){\r\n                sum = sum%10;\r\n                k = k+10;\r\n            }\r\n            res.add(sum);\r\n            k = k/10;          \r\n        }\r\n        while(k!=0){\r\n            res.add(k%10);\r\n            k = k/10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n} \r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837606516","body":"## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n\r\n## 思路\r\n分别从左向右和从右向左的遍历来获得当前位置字符与目标字符的距离，并取两者中较小的那一个。\r\n\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839404224","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n\r\n\r\n## 思路\r\n\r\n用数组来实现，设置一个指针top标识栈顶元素\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[]stack;\r\n    int top; // 标识栈顶\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; //最开始栈为空\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top < stack.length-1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) return top;\r\n        top--;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // 这是栈顶的K个元素 救命\r\n        // int start = Math.max(0,top-k+1);\r\n        // for(int i=start;i<=top;i++){\r\n        //     stack[i] += val;\r\n        // }\r\n\r\n        // 栈底的k个元素\r\n        int end = Math.min(top+1,k);\r\n        for(int i=0;i<end;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840459584","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n\r\n```\r\n\r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n```\r\n\r\n\r\n## 思路\r\n- 题目主要是涉及到了括号嵌套的问题，先从内从括号展开，再展开外层，这一方式联想到使用栈来解决\r\n- 利用两个栈来分别存储信息，一个存储重复次数，一个存储内容\r\n\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int times = 0; // 重复次数\r\n        StringBuilder res = new StringBuilder(); // 结果记录\r\n        Deque<Integer> numStack = new LinkedList<>();\r\n        Deque<StringBuilder> strStack = new LinkedList<>();\r\n\r\n        for(char c:s.toCharArray()){ \r\n            if(Character.isDigit(c)){ // 是数字的话记录重复次数（可能有多位数字\r\n                times = times*10 + c -'0';\r\n            }\r\n            else if(Character.isAlphabetic(c)){  // 是字母的话记录进res中\r\n                res.append(c);\r\n            }\r\n            else if(c == '['){ // 左括号的话把字母和次数都入栈\r\n                numStack.push(times);\r\n                strStack.push(res);\r\n                times = 0;\r\n                res = new StringBuilder(); //相当于把二者都清空\r\n            }else{ // 相当于c == ']'\r\n                int n = numStack.pop(); // 字符串要重复的次数\r\n                StringBuilder tmp = strStack.pop(); \r\n                for(int i=0;i<n;i++){\r\n                    tmp.append(res);\r\n                }\r\n                res = tmp;\r\n            } \r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841120667","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n\r\n```\r\n\r\n\r\n## 思路\r\n-  利用两个栈 stackIn stackOut来实现队列先进先出的特性\r\n\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> stackIn;\r\n    Deque<Integer> stackOut;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stackIn = new LinkedList<Integer>();\r\n        stackOut = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stackIn.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stackOut.isEmpty()){\r\n            while(!stackIn.isEmpty()){\r\n            stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stackOut.isEmpty()){\r\n            while(!stackIn.isEmpty()){\r\n            stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.peek();\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if(stackIn.isEmpty() && stackOut.isEmpty()) return true;\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680241","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 题目描述\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n\r\n\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n```\r\n\r\n## 思路\r\n-  对输入数组进行排序，如果数组前k项与排序后前k项相同，则可以分块\r\n\r\n## 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841696200","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n\r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n\r\n```\r\n\r\n\r\n## 思路\r\n- 用快慢指针做，快指针比慢指针先走K步\r\n- fast指向尾节点时，slow指向newHead的prev。此时令fast.next = head;  slow.next为旋转后的newHead； slow.next = null\r\n\r\n```java\r\n\r\n\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n\r\n        // 得到链表长度\r\n        ListNode node = head;\r\n        int size = 0;\r\n        while(node!=null){\r\n            size++;\r\n            node = node.next;\r\n        }\r\n\r\n        // 快指针先走K步,注意k可能大于size，故对其取余\r\n        if(k%size == 0) return head; //考虑k是size倍数的情况\r\n        for(int i=0;i<k%size;i++){\r\n            fast = fast.next;\r\n        }\r\n\r\n        while(fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n\r\n        // 此时fast指向尾节点，slow指向倒数第K+1个节点，也就是新的头节点的prev\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841925589","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n \r\n```\r\n\r\n\r\n## 思路\r\n- 用迭代方式实现，重复执行以下过程，以node0.next为空或者node0.next.next为空作为终止条件\r\n\r\n```\r\nnode0.next = node2\r\nnode1.next = node2.next\r\nnode2.next = node1\r\n\r\n```\r\n\r\n- 原本考虑用快慢指针做，node0为slow，node2为fast，每次前进两步，与上述思路完全一致。但是这样的话终止条件有点子问题：链表长度为偶数时，fast指向最后一个节点，本轮操作完成后应该停止，但是会执行fast.next.next操作导致空指针异常…就不晓得咋搞了。上面的思路相当于仅用了slow指针，就很可。\r\n\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null) return head;\r\n        ListNode newHead = new ListNode(); // 虚拟头节点\r\n        newHead.next = head;\r\n        ListNode tmp = newHead;\r\n\r\n        while(tmp.next != null && tmp.next.next != null){ // 分别考虑原链表长度为奇数和偶数的情况\r\n            ListNode node1 = tmp.next;\r\n            ListNode node2 = tmp.next.next;\r\n            tmp.next = node2;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            tmp = node1;\r\n        }\r\n        return newHead.next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)    n为链表中节点的数量\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843035208","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n```\r\n\r\n## 思路\r\n- 主要思路是利用快慢指针找到链表中的中间节点作为root，对于其左右两部分再进行递归实现查找中间节点的过程。\r\n- 注意链表划分的左右边界问题，可以理解为加入“虚拟尾节点”  => 代码中注释\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return dfs(head,null);\r\n\r\n    }\r\n\r\n    private TreeNode dfs(ListNode start, ListNode end){\r\n        if(start == end) return null;\r\n        ListNode fast = start;\r\n        ListNode slow = start;\r\n        // 快慢指针法找到链表中点作为根\r\n        while(fast!=end && fast.next!=end){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n\r\n        // 头节点开始，null结束相当于加入了“虚拟尾节点”\r\n        // 递归：left中slow为结尾，右侧end为结尾，都相当于是虚拟尾节点。\r\n        // 这样递归到最后只剩下一个节点,即if(start == end)时，也就是虚拟尾节点，结束递归。\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = dfs(start, slow);\r\n        root.right = dfs(slow.next,end);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n每一层的基本操作数为 nn\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(logn)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843951912","body":"## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\n```\r\n\r\n\r\n## 思路\r\n\r\n- 方法1 哈希表：遍历链表A将节点都存入哈希表，然后遍历链表B查找相同的节点\r\n- 方法2 双指针法：根据相交的性质，AB交替遍历时相遇即为相交点\r\n\r\n- 注意（while没有相交的情况下为什么不会死循环？）\r\n因为在while中是先移动指针到下一位再进行两者是否相等判断的，相当于两个链表中都加入了“虚拟尾节点”null，当两条链表没有相交时也会因为A null == B null 跳出循环，返回null即无交点\r\n\r\n```java\r\n\r\n\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while(a != b){\r\n            if(a == null) a = headB;\r\n            else a = a.next;\r\n\r\n            if(b == null) b = headA;\r\n            else b =b.next;           \r\n        }\r\n        return a;     \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n两条链表长度分别为m,n\r\n\r\n- 时间复杂度：O(m+n)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844637497","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n进阶：使用 O(1) 空间解决此题\r\n\r\n示例 1：\r\n\r\n输入：head = [3,2,0,-4], pos = 1\r\n输出：返回索引为 1 的链表节点\r\n解释：链表中有一个环，其尾部连接到第二个节点。\r\n```\r\n\r\n\r\n## 思路1：`哈希表`\r\n- 遍历链表将每个节点都存入哈希表，第一个重复的节点就是环的起点啦\r\n- 空间复杂度O(n)\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        HashSet<ListNode> set = new HashSet<>();\r\n        while(!set.contains(head)){\r\n            if(head == null) return null;\r\n            set.add(head);\r\n            head = head.next;\r\n        }\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n## 思路2：`快慢指针` \r\n- fast一次走两步，slow走一步，有相遇即有环\r\n- 两指针相遇后，fast指向链表头部，fast和slow均每次走一步，再次相遇即为环的起点\r\n- 空间复杂度O(1)\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        do{\r\n            // 这里不能用while循环，因为一开始fast == slow，根本无法进入循环\r\n            if(fast == null || fast.next == null) return null; // 判断没有环的情况\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }while(fast != slow);\r\n\r\n        fast = head;\r\n        while(fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;        \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846030200","body":"\r\n## 题目地址(146. LRU 缓存机制)\r\n\r\nhttps://leetcode-cn.com/problems/lru-cache/\r\n\r\n## 题目描述\r\n\r\n```\r\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。\r\n\r\n\r\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\r\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\r\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\r\n\r\n\r\n进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？\r\n \r\n\r\n示例：\r\n\r\n输入\r\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\r\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\r\n输出\r\n[null, null, null, 1, null, -1, null, -1, 3, 4]\r\n\r\n\r\n```\r\n## 思路\r\n1. 确定数据结构\r\n    - \"最近最少使用\" 要求数据的存储有顺序 ⇒ 数组，链表等\r\n    - 数据要进行频繁的增删 ⇒ 双向链表\r\n    - 关键字-值 ：HashMap\r\n    - 所以使用**HashMap + 双向链表  <key，ListNode(key,value)>**\r\n\r\n2. get操作\r\n\r\n    通过哈希表查看当前key对应的节点是否存在\r\n\r\n    1）key不存在：返回null\r\n\r\n    2）key存在：返回key对应的value，并将当前节点移至链表头\r\n\r\n3. put操作\r\n\r\n    通过哈希表查看当前key对应的节点是否存在\r\n\r\n    1）key存在：更新该节点value并移至链表头\r\n\r\n    2）key不存在：生成新结点并添加至链表头，若链表容量已满，则删除尾部节点\r\n\r\n\r\n- 在处理容量已满情况时有两种做法 ⇒ 注意判断条件\r\n    1. 先添加节点，再判断size>capacity删除尾节点\r\n    2. 先判断size≥capcity删除尾节点，再添加节点（效率低）\r\n\r\n```java\r\n\r\nclass ListNode{\r\n    int val;\r\n    int key;\r\n    ListNode prev;\r\n    ListNode next;\r\n    ListNode(){}\r\n    ListNode(int key, int val){\r\n        this.key = key;\r\n        this.val = val;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    private int capacity;\r\n    private int size; \r\n    private HashMap<Integer,ListNode> cache = new HashMap<>();\r\n    private ListNode head; //虚拟头尾节点  \r\n    private ListNode tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        this.size = 0;\r\n        head = new ListNode(); \r\n        tail = new ListNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        ListNode node = cache.get(key);\r\n        if(node == null) return -1;\r\n        moveToHead(node); //如果key存在，将当前节点移至链表头部\r\n        return node.val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        ListNode node = cache.get(key);\r\n        if(node == null){//key不存在时,添加新的节点至链表头部，并添加进哈希表\r\n            ListNode newNode = new ListNode(key,value);\r\n            cache.put(key,newNode); \r\n            addToHead(newNode);\r\n            size++;\r\n            if(size > capacity){ //容量已满       \r\n                // 处理哈希表最后一组元素\r\n                cache.remove(tail.prev.key);\r\n                // 处理链表中最后一个元素\r\n                tail.prev = removeLast();\r\n\r\n                size --;\r\n            }\r\n        }else{ //key存在时,通过哈希表定位到node，改变其值，再将其移至头部\r\n            node.val = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(ListNode node){\r\n        head.next.prev = node;\r\n        node.next = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n    }\r\n\r\n    private void moveToHead(ListNode node){\r\n        //先删除当前元素\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n\r\n        //再将当前元素添加至head后\r\n        addToHead(node);\r\n    }\r\n\r\n    private ListNode removeLast(){ //删除最后一个节点，tail前面那个\r\n        ListNode lastNode = tail.prev;\r\n        lastNode.prev.next = tail;\r\n        tail.prev = lastNode.prev;\r\n        return tail.prev; //返回新的最后一个节点（也就是最久未被使用过的节点）\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)  双向链表和哈希map操作都为O(1)\r\n- 空间复杂度：O(n) n为capacity\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846113082","body":"\r\n## 题目地址(104. 二叉树的最大深度)\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个二叉树，找出其最大深度。\r\n\r\n```\r\n## 方法一：DFS\r\n\r\n很简单不多say了，**注意复杂度**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        return 1+Math.max(leftHeight,rightHeight);     \r\n    }\r\n```\r\n\r\n树的节点数为n，树的深度为depth\r\n\r\n- 时间复杂度O(n) ：每个节点在递归中都要被遍历一次\r\n- 空间复杂度O(depth)：**递归函数占用栈空间，栈空间取决于递归深度，本题递归深度为树的深度**\r\n\r\n\r\n## 方法二：BFS\r\n\r\n利用队列来做，相当于做层序遍历，每次对每一层中的所有节点进行出队并查找其子节点的操作，保证每一次操作后队列中存放的是该层的所有节点，操作的层数就是二叉树的最大深度\r\n```java\r\n\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        int depth = 0;\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.offer(root);\r\n        while(!queue.isEmpty()){\r\n            int len = queue.size();\r\n            while(len > 0){\r\n                TreeNode node = queue.poll();\r\n                if(node.left != null) queue.offer(node.left);\r\n                if(node.right != null) queue.offer(node.right);\r\n                len --;\r\n            }\r\n            depth ++;\r\n            \r\n        }  \r\n        return depth; \r\n    }\r\n}\r\n\r\n```\r\n时间复杂度O(n)  空间复杂度O(n)  \r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846516306","body":"\r\n## 题目地址(100. 相同的树)\r\n\r\nhttps://leetcode-cn.com/problems/same-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\r\n\r\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\r\n```\r\n\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) return true;\r\n        if(p == null || q == null) return false;\r\n        if(p.val != q.val) return false;\r\n        return (isSameTree(p.left,q.left) && isSameTree(p.right,q.right));\r\n\r\n    }\r\n}\r\n\r\n```\r\n- **时间复杂度**O(min(m,n)) 其中m,n为两棵树的节点数，因为只有在两棵树都不为空时才会向下遍历\r\n- **空间复杂度**O(min(m,n)) 递归调用的空间复杂度与递归深度有关，在最差情况下树的深度等于其节点数\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NorthSeacoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063398","body":"## 思路\r\n利用 BigInt 计算\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    \r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(1),没遍历数组....\r\n- 空间复杂度：O(n), 直接把数组转成 BigInt,不确定这里对不对...."},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838453454","body":"## 思路\r\n- 字符串拆成数组,并查询c 的所有下标\r\n- 遍历数组查询每个下标到 c 的最短距离\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    const res=[],sIndexs=[];\r\n    \r\n    s.split('').forEach((char,index)=>{\r\n        if(char===c)sIndexs.push(index)\r\n    })\r\n    for(let i = 0;i<s.length;i++){\r\n        let tem = sIndexs.map(item=>Math.abs(i-item)).sort((a,b)=>a-b).shift();\r\n        res.push(tem)\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n*m) m为字符 c 在 s 中的重复次数\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839371890","body":"## 思路\r\n\r\n-   直接利用数组模拟\r\n\r\n## 代码\r\n\r\n<details>\r\n<summary>展开查看</summary>\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.unshift(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.shift() || -1;\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    const n = this.stack.length;\r\n    for (let i = n - 1; i >= 0 && n - 1 - i < k; i--) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n</details>\r\n\r\n## 复杂度分析\r\n\r\n-   时间复杂度:push/pop:O(1);inc:O(k)\r\n-   空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240878","body":"## 思路\r\n辅助栈\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840939664","body":"## 思路\r\n\r\n-   用栈模拟,则数组只能调用 push()和 pop()\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.stack = [];\r\n    this._stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    let cur = null;\r\n    while (cur = this.stack.pop()) {\r\n        this._stack.push(cur)\r\n    }\r\n    const res = this._stack.pop();\r\n    while (cur = this._stack.pop()) {\r\n        this.stack.push(cur)\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push/peek/empty:O(1);pop:O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841661238","body":"## 思路\r\n单调栈,具体见注释\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function (arr) {\r\n    let stack = [];\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        if (stack.length === 0 || stack[stack.length - 1] <= arr[i]) {\r\n            //单调递增栈,栈中的每个值就是一个分块中的极大值\r\n            stack.push(arr[i])\r\n        } else {//当前值小于栈顶元素即tem<arr[i]\r\n            //临时保存单调栈中最大值(当前值可以加入栈顶元素所代表的块)\r\n            let tem = stack.pop();\r\n            //一个元素代表一个块,当前值此时压入最大值所在的块中,该块的区间为[当前值,最大值]\r\n            //剩下单调栈中不应该存在大于当前值的元素\r\n            //因此剩余单调栈中大于当前值的元素意味着可以压入新块中\r\n            while (stack[stack.length - 1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(tem)\r\n        }\r\n    }\r\n        return stack.length\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841821934","body":"## 思路\r\n循环 k%num 次尾=>头\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    if (!head || !head.next) return head\r\n    let num = 2;\r\n    while (k > 0) {\r\n        let cur = head;\r\n        while (cur.next.next) {\r\n            cur = cur.next;\r\n            num++\r\n        }\r\n        if (k > num) k = k % num;//剪枝\r\n        if (k > 0) {\r\n            let tail = cur.next;\r\n            cur.next = null;\r\n            tail.next = head;\r\n            head = tail\r\n            k--;\r\n        }\r\n\r\n    }\r\n    return head\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(kn)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841942474","body":"\r\n## 思路\r\n- 设置虚拟头节点\r\n- 找到最终首节点\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    if (!head || !head.next) return head;\r\n    let res = head.next;//先确定最终的首节点\r\n    let pre = new ListNode(0, head);//0,1,2,3,4\r\n    let cur = head;//1234\r\n    while (cur && cur.next) {\r\n        let next = cur.next;//34\r\n        let nextnext = next.next;//4\r\n        cur.next = nextnext;//oo\r\n        next.next = cur;//\r\n        pre.next = next;//\r\n        //console.log(pre, cur, next)\r\n\r\n        pre = cur;//134\r\n        cur = cur.next;//34\r\n\r\n    };\r\n    // console.log(res)\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842770310","body":"## 思路\r\n- 快慢指针找中间节点\r\n- 递归构造二叉树\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function (head) {\r\n    if (!head) return null;\r\n\r\n    return run(head,null);\r\n\r\n};\r\nfunction run(head, tail)  {\r\n    if (head === tail) return null\r\n    let slow = head, fast = head;\r\n    while (fast !== tail && fast.next !== tail) {\r\n        fast = fast.next.next;\r\n        slow = slow.next\r\n    }\r\n    const root = new TreeNode(slow.val);\r\n    root.left = run(head, slow);\r\n    root.right = run(slow.next, tail);\r\n    return root;\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843676278","body":"## 思路\r\n- 哈希表\r\n- 双指针\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    //哈希表\r\n    const record = [];\r\n    let curA=headA\r\n    while (curA) {\r\n        record.push(curA);\r\n        curA = curA.next\r\n    }\r\n    let curB=headB;\r\n    while(curB){\r\n        if(record.includes(curB))return curB;\r\n        curB=curB.next\r\n    }\r\n    return null\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844652036","body":"## 思路\r\n- 双指针\r\n- 第一次相交后 fast 重置,步长改为 1\r\n- do-while 和 while 的区别:do 先执行再循环\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n    let fast = head, slow = head;\r\n    // while (fast !== slow) {\r\n    //     if (!fast || !fast.next) return null\r\n    //     fast =  fast.next.next;\r\n    //     slow = slow.next;\r\n    // }\r\n    do {\r\n        if (!fast || !fast.next) return null;\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    } while (fast != slow)\r\n    if (!fast) return null;\r\n    fast = head;\r\n    while (fast != slow) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    return fast;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845591699","body":"## 思路\r\n- 基于数组实现\r\n- stack 可以换成 map\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.stack = (new Array(capacity)).fill(-1);\r\n    this.keys = [];\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n\r\n    if (!this.keys.includes(key)) return -1;\r\n    let keys = this.keys.filter(val => val != key)\r\n    this.keys = [key, ...keys]\r\n    return this.stack[key]\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    this.stack[key] = value;\r\n    if (this.keys.includes(key)) {\r\n        let keys = this.keys.filter(val => val != key)\r\n        this.keys = [key, ...keys]\r\n    } else {\r\n        this.keys.unshift(key);\r\n        if (this.keys.length > this.capacity) {\r\n            this.keys.pop()\r\n        }\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846340637","body":"## 思路\r\n- 递归  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n    if (!root) return 0\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846518260","body":"## 思路\r\n递归\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n    if (!p && !q) return true;\r\n    if ((!p && q) || (p && !q)) return false;\r\n\r\n    if (q.val !== p.val) return false;\r\n\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shizukanaskytree":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836063868","body":"\r\n## 题目地址(989. Add to Array-Form of Integer)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\nThe array-form of an integer num is an array representing its digits in left to right order.\r\n\r\nFor example, for num = 1321, the array form is [1,3,2,1].\r\n\r\nGiven num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: num = [1,2,0,0], k = 34\r\nOutput: [1,2,3,4]\r\nExplanation: 1200 + 34 = 1234\r\n\r\n\r\nExample 2:\r\n\r\nInput: num = [2,7,4], k = 181\r\nOutput: [4,5,5]\r\nExplanation: 274 + 181 = 455\r\n\r\n\r\nExample 3:\r\n\r\nInput: num = [2,1,5], k = 806\r\nOutput: [1,0,2,1]\r\nExplanation: 215 + 806 = 1021\r\n\r\n\r\nExample 4:\r\n\r\nInput: num = [9,9,9,9,9,9,9,9,9,9], k = 1\r\nOutput: [1,0,0,0,0,0,0,0,0,0,0]\r\nExplanation: 9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= num.length <= 104\r\n0 <= num[i] <= 9\r\nnum does not contain any leading zeros except for the zero itself.\r\n1 <= k <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nfrom typing import List \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_val = 0\r\n\r\n        for n in num:\r\n            num_val += n            \r\n            num_val = num_val * 10\r\n        num_val //= 10\r\n        \r\n        new_val = num_val + k\r\n        \r\n        if new_val == 0:\r\n            return [0]\r\n        \r\n        res = []\r\n        last_digit = 0\r\n            \r\n        while new_val != 0:\r\n            last_digit = new_val % 10\r\n            res.append(last_digit)    \r\n            new_val = new_val // 10\r\n\r\n        res.reverse()\r\n        return res\r\n\r\na = [0]\r\ns = Solution()\r\nres = s.addToArrayForm(a, k=0)\r\nprint(res)\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838260266","body":"\r\n## 题目地址(821. Shortest Distance to a Character)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"loveleetcode\", c = \"e\"\r\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\r\nExplanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed).\r\nThe closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3.\r\nThe closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 3.\r\nFor index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1.\r\nThe closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2.\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"aaab\", c = \"b\"\r\nOutput: [3,2,1,0]\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 104\r\ns[i] and c are lowercase English letters.\r\nIt is guaranteed that c occurs at least once in s.\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n\"\"\"\r\nloveleetco d  e\r\n0123456789 10 11\r\n+++0100123 4  0\r\n3210100432 1  0\r\n3210100122 1  0\r\n\r\n 3 2 1 0 1 0 0 1 2 2 1 0\r\n[3,2,1,0,1,0,0,1,2,2,1,0]\r\n\r\n\"\"\"\r\n\r\n# 1.\r\n# https://stackoverflow.com/questions/6810036/whats-better-the-reverse-method-or-the-reversed-built-in-function#:~:text=reverse()%20actually%20reverses%20the,than%20actually%20reversing%20the%20elements.\r\n\r\n# 2.\r\n# https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n\r\n# 3.\r\n# range(start, stop, step)\r\n# 左闭右开! []start, stop)\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        anchor = float('-inf')\r\n        # distance = left - righ\r\n        # distance = curr_val - anchor\r\n        # distance = postive_val - float('-inf')\r\n        dist = []\r\n        for i, l in enumerate(s):\r\n            if l == c:\r\n                dist[i] = prev\r\n            else:\r\n                dist[i] = i - prev\r\n        for i, l in enumerate(reversed(s)):\r\n            if l == c:\r\n                dist[i] = min(dist[i], )\r\n\r\n        \r\n\"\"\"\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n\r\n作者：LeetCode\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/zi-fu-de-zui-duan-ju-chi-by-leetcode/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\n\"\"\"\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840417194","body":"\r\n## 题目地址(394. Decode String)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven an encoded string, return its decoded string.\r\n\r\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n\r\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n\r\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: s = \"3[a]2[bc]\"\r\nOutput: \"aaabcbc\"\r\n\r\n\r\nExample 2:\r\n\r\nInput: s = \"3[a2[c]]\"\r\nOutput: \"accaccacc\"\r\n\r\n\r\nExample 3:\r\n\r\nInput: s = \"2[abc]3[cd]ef\"\r\nOutput: \"abcabccdcdcdef\"\r\n\r\n\r\nExample 4:\r\n\r\nInput: s = \"abc3[cd]xyz\"\r\nOutput: \"abccdcdcdxyz\"\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\n1 <= s.length <= 30\r\ns consists of lowercase English letters, digits, and square brackets '[]'.\r\ns is guaranteed to be a valid input.\r\nAll the integers in s are in the range [1, 300].\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/solution/java-di-gui-si-lu-qing-xi-dai-ma-yi-dong-t6mn/\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def onlyString(self, s):\r\n        index = 0\r\n        while index != len(s):\r\n            c = s[index]\r\n            if c == '[' or c == ']':\r\n                return False\r\n            index += 1\r\n        \r\n        return True\r\n\r\n    def decodeString(self, s: str) -> str:\r\n        if self.onlyString(s):\r\n            return s \r\n\r\n        i = 0\r\n        len_s = len(s)\r\n\r\n        res = ''\r\n\r\n        while i < len_s:\r\n            c = s[i]\r\n            if 'a' < c < 'z':\r\n                res += c\r\n                i += 1\r\n            else:\r\n                n = 0\r\n                left = i \r\n                right = i \r\n                while right < len_s and '0' <= s[right] <= '9':\r\n                    right += 1\r\n                \r\n                n = int(s[left:right+1])\r\n                left = right + 1\r\n                right += 1\r\n                leftP = 1\r\n                while leftP != 0:\r\n                    t = s[right]\r\n                    if t == '[':\r\n                        leftP += 1\r\n                    elif t == ']'\r\n                        leftP -= 1\r\n                    \r\n                    if leftP == 0:\r\n                        break\r\n                    right += 1\r\n                \r\n                smallFrac = decodeString(s[left + 1, right])\r\n                res += smallFrac*n\r\n                i = right + 1\r\n\r\n        return res \r\n\r\n    \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：递归不知道\r\n- 空间复杂度：取决于问题吧, 如果 10000000[abc] \r\n\r\n\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843639868","body":"## 题目地址(160. Intersection of Two Linked Lists)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\r\n\r\nFor example, the following two linked lists begin to intersect at node c1:\r\n\r\nIt is guaranteed that there are no cycles anywhere in the entire linked structure.\r\n\r\nNote that the linked lists must retain their original structure after the function returns.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\r\nOutput: Intersected at '8'\r\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\r\n\r\n\r\nExample 2:\r\n\r\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\nOutput: Intersected at '2'\r\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\r\n\r\n\r\nExample 3:\r\n\r\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\nOutput: No intersection\r\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\r\nExplanation: The two lists do not intersect, so return null.\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes of listA is in the m.\r\nThe number of nodes of listB is in the n.\r\n0 <= m, n <= 3 * 104\r\n1 <= Node.val <= 105\r\n0 <= skipA <= m\r\n0 <= skipB <= n\r\nintersectVal is 0 if listA and listB do not intersect.\r\nintersectVal == listA[skipA + 1] == listB[skipB + 1] if listA and listB intersect.\r\n\r\n \r\n\r\nFollow up: Could you write a solution that runs in O(n) time and use only O(1) memory?\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\n# \r\n# 最终两个指针分别走过的路径为：\r\n# 指针A :a+c+b\r\n# 指针B :b+c+a\r\n# 明显 a+c+b = b+c+a,因而如果两个链表相交，则指针A和指针B必定在相交结点相遇。\r\n\r\n# 作者：belinda\r\n# 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/jiao-ni-yong-lang-man-de-fang-shi-zhao-dao-liang-2/\r\n# 来源：力扣（LeetCode）\r\n# 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pa, pb = headA, headB\r\n        while pa != pb:\r\n            pa = pa.next if pa else headB\r\n            pb = pb.next if pb else headA\r\n        return pa\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(m+n)$\r\n- 空间复杂度：$O(1)$ \r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BeBraveBeCurious":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072235","body":"``` Python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n\r\n        i, carry = len(num) - 1, 0\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n\r\n            sum = x + y + carry\r\n            res.append(sum % 10)\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n        if carry != 0:\r\n            res.append(carry)\r\n            \r\n        return res[::-1]\r\n```\r\n**复杂度分析**\r\nn 为数组长度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838401294","body":"### 解题思路\r\n- 从左向右遍历, 记录 `i - prev`, `prev`为前一次`c`出现的下标\r\n- 从右向左遍历, 记录 `prev - i`, `prev`为靠右的`c`出现的下标\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i \r\n            ans.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans \r\n```\r\n\r\n### 复杂度分析\r\n- **时间复杂度**：$O(n)$, 两次遍历`2n`化简为`n`\r\n- **空间复杂度**：$O(n)$, `n`为ans数组的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839745404","body":"### 解题思路\r\n- 普通栈有`push`和`pop`功能\r\n- 增加普通栈没有的`inc`功能\r\n- `push`函数判断当前的元素个数是否达到上限，没达到上限时，将`top + 1`后移一位，同时添加一个元素\r\n```python3\r\ndef push(self, x: int) -> None:\r\n    if self.top != len(self.stk) - 1:\r\n        self.top += 1\r\n        self.stk[self.top] = x\r\n```\r\n- `pop`函数首先判断当前函数是否为空，非空返回栈顶元素，并将`top`前移一位，否则返回 -1\r\n```python3\r\ndef pop(self) -> int:\r\n    if self.top == -1: return -1\r\n    self.top -= 1\r\n    return self.stk[self.top]\r\n```\r\n- `inc`函数直接多栈底**最多**`k`个元素加上`val`\r\n```python3\r\ndef increment(self, k: int, val: int) -> None:\r\n    lim = min(k, self.top + 1)\r\n    for i in range(lim):\r\n        self.stk[i] += val\r\n```\r\n\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：`push`和`pop`操作的渐进时间复杂度为$O(1)$, `inc`操作的渐进时间复杂度为$O(k)$\r\n- 空间复杂度：用到了一个`maxSize`的数组作为辅助空间，渐进空间复杂度为$O(maxSize)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840237710","body":"### 解题思路\r\n- 数字处理, `multi`初始化为0\r\n```python3\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n```\r\n- 左括号'['入栈'[multi, res]'\r\n```python3\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n```\r\n- 右括号`]`出栈\r\n```python3\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n```\r\n- 其余为数字的情况，将`c`添加至`res`\r\n``` python3\r\nelse:\r\n    res += c\r\n```\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res \r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res \r\n\r\n```\r\n[参考K神题解](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)\r\n\r\n![5.jpg](https://pic.leetcode-cn.com/1620871801-OsAwvq-5.jpg)\r\n**复杂度分析**\r\n- 时间复杂度: $O(n)$, 一次遍历s\r\n- 空间复杂度: $O(n)$, 极端情况下辅助栈需要线性空间，`2[3[4[a]]]`\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840918992","body":"### 解题思路\r\n- 初始化两个栈，一主一辅\r\n```python3\r\ndef __init__(self):\r\n    self.stack = []\r\n    self.help_stack = []\r\n```\r\n- `push`入栈时使用`help_stack`进行顺序调整\r\n```python3\r\ndef push(self, x: int) -> None:\r\n    while self.stack:\r\n        self.help_stack.append(self.stack.pop())\r\n    self.help_stack.append(x)\r\n    while self.help_stack:\r\n        self.stack.append(self.help_stack.pop())\r\n```\r\n- `pop`函数\r\n```python3\r\ndef pop(self) -> int:\r\n    return self.stack.pop()\r\n```\r\n- `peek`函数\r\n```python3\r\ndef peek(self) -> int:\r\n    return self.stack[-1]\r\n```\r\n- `empty`函数\r\n```python3\r\ndef empty(self) -> bool:\r\n    return not bool(self.stack)\r\n```\r\n\r\n\r\n### 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841624167","body":"### 解题思路\r\n- `head`记为当前排序块的最大值\r\n- `stack`记录每个排序块的最大值`head`\r\n- 依次遍历`arr`, 得到`num`值，与栈顶值`stack[-1]`(上一个排序块的最大值`head`)\r\n- 当`stack`非空 + 当前`num`影响前面的排序块时，\r\n    - `head`暂存前一个排序块的最大值\r\n    - 将栈内小于当前`num`的值(之前排序块的最大值) 全部弹出\r\n    - 将当前的`head`值加入stack\r\n- 当`stack`空 or 当前`num`不影响前面的排序块时\r\n    - 单独成块 `num > stack[-1]`\r\n    - 直接加入`stack`中\r\n- `stack`中的值为所有排序块的`head`值，返回长度即结果\r\n \r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            # 当前数 num < 栈顶元素, 即前一个排序块的 head 最大值\r\n            if stack and num < stack[-1]:\r\n                # 暂存前一个排序块的 head 最大值\r\n                head = stack.pop()\r\n                # 需要将当前 num 小于前面的排序块的 head 值都弹出 \r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                # 将受到当前 num 影响的前排序块的 head 值加入stack\r\n                # 相当于将前面的排序块和此 num 合并\r\n                stack.append(head)\r\n            # 栈为空 or 当前数字 num >= 栈顶值时 \r\n            # -----> 此num不影响前面排序块的分布\r\n            else:\r\n                stack.append(num)\r\n        # 所有排序块的 head d都在栈里面\r\n        return len(stack)\r\n```\r\n[参考K神题解](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/)\r\n\r\n### 复杂度分析\r\n- 时间复杂度$O(N)$：一次遍历`arr`为$O(N)$,修正排序块最多遍历一遍`arr`为$O(N)$ \r\n- 空间复杂度$O(N)$：极端情况下，排序块数量等于数组长度，此时`stack`占用线性大小额外空间。"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845713773","body":"### 解题思路\r\n- 实现操作需要：哈希表 + 双向链表\r\n- 面试官希望实现一个简单的双向链表\r\n- python有一种结合哈希表与双向链表的数据结构`OrderedDict`\r\n\r\n\r\n- 待做：手写哈希表 + 双向链表\r\n\r\n### 代码\r\n\r\n```python3\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self: return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self: self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last = False)\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n[参考官方题解](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846330653","body":"### 解题思路\r\n- DFS递归求解深度 \r\n- BFS层序遍历，level += 1, tmp记录节点\r\n\r\n### 代码\r\n```python3 []\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n\r\n```python3 []\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        nodes = [root]\r\n        level = 0\r\n        if not root: return level\r\n\r\n        while nodes:\r\n            level += 1\r\n            tmp = []\r\n            for node in nodes:\r\n                if node.left: tmp.append(node.left)\r\n                if node.right:  tmp.append(node.right)\r\n            nodes = tmp\r\n        return level\r\n```\r\n### DFS时间复杂度\r\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树节点的个数。每个节点在递归中只被遍历一次。\r\n- 空间复杂度：$O(height)$，其中 $height$ 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\r\n\r\n### BFS时间复杂度\r\n- 时间复杂度：$O(n)$，其中 $n$ 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。\r\n- 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 $O(n)$。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846483907","body":"### 解题思路\r\n- 递归求解\r\n- `p`和`q`均不存在，返回`True`\r\n- `p`和`q`仅存在一个，返回`False`\r\n```python3\r\nif not p and not q: return True\r\nelif not p or not q: return False\r\n```\r\n- `p`和`q`值不相等，返回`False`\r\n- 之前没有返回的话，直接返回递归左右节点的比较\r\n```python3\r\nif p.val != q.val: return False\r\nreturn self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n### 代码\r\n```python3\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q: \r\n            return True\r\n        elif not p or not q: \r\n            return False\r\n        if p.val != q.val: \r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：$O(min(m,n))$, 其中 $m$ 和 $n$ 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\r\n- 空间复杂度：$O(min(m,n))$, 其中 $m$ 和 $n$ 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\r\n\r\n[参考官方题解](https://leetcode-cn.com/problems/same-tree/solution/xiang-tong-de-shu-by-leetcode-solution/)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelonDrip":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836072251","body":"## 思路\r\n- 转int 和 k 相加\r\n- 取余逐位加到res_list里\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n         \r\n        str_num = ''.join(str(x) for x in num)\r\n        tmp = int(str_num)\r\n        int_res = tmp + k\r\n        list_res = []\r\n        if int_res == 0:\r\n            return [0]\r\n        while int_res>0:\r\n            list_res.append(int_res%10)\r\n            int_res = int_res//10\r\n        return list_res[::-1]\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837668088","body":"## 思路\r\n\r\n- 模拟\r\n- 先统计s出现的位置，两个位置的距离是odd,递增序列+递减序列。如果是even，就去掉一个中间数。\r\n如果统计s 的位置不是最后一位，最后再加一个递减序列\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        list_c = list()\r\n        for i, item in enumerate(s):\r\n            if item == c:\r\n                list_c.append(i)\r\n     \r\n        left = 0\r\n        right = 0\r\n        \r\n      \r\n        res = list()\r\n         \r\n        while  right <  len(list_c):\r\n     \r\n            if left == right:\r\n                \r\n                for i in range(list_c[right],-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n            elif list_c[right] < len(s) and left < right:\r\n                tmp = list_c[right] - list_c[left]\r\n                distance = tmp //2\r\n                distance_num = tmp%2\r\n                for i in range( 1,distance+distance_num ):\r\n                    res.append(i)\r\n                for i in range(distance,-1,-1):\r\n                    res.append(i)\r\n                right+=1\r\n                left+=1\r\n             \r\n            else:\r\n                break\r\n        len_s = len(s)\r\n       \r\n        if list_c[-1] < len_s -1:\r\n            for i in range(1, len_s - list_c[-1] ):\r\n                res.append(i)\r\n            \r\n        return res \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839372099","body":"## 思路\r\n\r\n- 模拟， stack 用来push 和pop  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack1 = [] # for push and pop\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack1) < self.maxSize:\r\n            self.stack1.append(x)\r\n         \r\n    def pop(self) -> int:\r\n        if self.stack1:\r\n            return self.stack1.pop(-1)\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        cur = min(k,len(self.stack1))\r\n        cur -=1\r\n        while cur>=0:\r\n            self.stack1[cur]+=val\r\n            cur-=1\r\n        \r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840366228","body":"## 思路\r\n \r\n-  辅助栈 \r\n-   这个题里好多的细节啊\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack =[]\r\n        res = ''\r\n        k = 0\r\n        for elem in s:\r\n            if '0' <=  elem  <= '9':\r\n                k  = k*10+ int(elem)\r\n            elif elem == '[':\r\n                stack.append([res, k])\r\n                res = ''\r\n                k =0\r\n \r\n            elif elem == ']':\r\n                tmp_str, tmp_k = stack.pop()\r\n                \r\n                res = tmp_str + res * tmp_k \r\n \r\n                \r\n            else:\r\n                res =  res + elem \r\n              \r\n        return res\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942770","body":"## 思路\r\n\r\n - 两个stack ,一个帮助pop，一个帮助Push\r\n \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = [] # input stack\r\n        self.stack2 = [] # output stack\r\n        \r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1 and not self.stack2\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631350","body":"#   思路\r\n - 单调栈\r\n#   Python3 Code:\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # Monotonous stack\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop(-1)\r\n                while stack and head > num:\r\n                    head = stack.pop(-1)\r\n\r\n            stack.append(num)\r\n```\r\n -   复杂度分析  \r\n    +    时间复杂度：$O( n)$  \r\n    +    空间复杂度：$O(n)$  \r\n\r\n "},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842939144","body":"## 关键点\r\n\r\n-  链表先变成数列\r\n- 然后重新构造二叉树，通过中序遍历\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        list_inorder = []\r\n        def get_list(head):\r\n   \r\n            while head:\r\n\r\n                list_inorder.append(head.val)\r\n                head = head.next\r\n\r\n            return list_inorder\r\n            \r\n        def inorderTraversal(nums_list):\r\n            if len(nums_list) == 0:\r\n                return\r\n            \r\n            mid_index = len(nums_list)//2\r\n\r\n            # construct binary node by setting left,right,val\r\n            node = TreeNode(nums_list[mid_index])\r\n            node.left = inorderTraversal(nums_list[:mid_index])\r\n            node.right = inorderTraversal(nums_list[mid_index+1:])\r\n            return node\r\n        \r\n        return inorderTraversal(get_list(head))\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843679533","body":"## 思路\r\n\r\n- A+B的长度不管是不是相交都是A+B\r\n- null 相当于是相交了吧哈哈哈哈哈\r\n  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        cur_A = headA\r\n        cur_B = headB\r\n        while cur_A != cur_B:\r\n            if cur_A:\r\n                cur_A = cur_A.next\r\n            else:\r\n                cur_A = headB\r\n            \r\n            if cur_B:\r\n                cur_B = cur_B.next\r\n            else:\r\n                cur_B = headA\r\n        return cur_B\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n+m)$， 分别是A,B长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844648793","body":"## 关键点\r\n\r\n-  快慢指针\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n       \r\n        \r\n        if head==None or not head.next or not head.next.next:\r\n            return None\r\n\r\n            \r\n        fast_cur = head \r\n        slow_cur = head\r\n         \r\n        pos = 0\r\n        while pos == 0 or fast_cur != slow_cur:\r\n            fast_cur = fast_cur.next.next\r\n            slow_cur = slow_cur.next\r\n            pos+=1\r\n            if not fast_cur or not fast_cur.next or not fast_cur.next.next:\r\n                return None\r\n        pre_cur = head\r\n       \r\n        while pre_cur != slow_cur:\r\n            \r\n            pre_cur = pre_cur.next\r\n            slow_cur = slow_cur.next\r\n   \r\n\r\n       \r\n\r\n        return pre_cur\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845855743","body":"## 关键点\r\n\r\n-  OrderedDict()\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.ord = collections.OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.ord:\r\n            self.ord.move_to_end(key)\r\n            return self.ord[key]\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n    \r\n        if key in self.ord:\r\n            self.ord.move_to_end(key)\r\n            self.ord[key] = value\r\n        else:\r\n            if len(self.ord) < self.capacity:\r\n                self.ord[key] = value\r\n            else:\r\n                self.ord.popitem(False)\r\n                self.ord[key] = value\r\n        return\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846359926","body":"## 关键点\r\n\r\n-  深度搜索吧\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        \r\n        if root is None:\r\n            return 0\r\n        else:\r\n            left_depth = self.maxDepth(root.left)\r\n            right_depth = self.maxDepth(root.right)\r\n            #print(left_depth)\r\n            print(root.val,left_depth,right_depth)\r\n\r\n            if left_depth >= right_depth:\r\n                return left_depth +1\r\n            else:\r\n                return right_depth + 1\r\n```\r\n\r\n \r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilia-vu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079487","body":"### 思路\r\n\r\n从低位按位计算，注意处理最高位进位的情况\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int add = 0;\r\n        for (int i = num.size() - 1; i>=0; i--) {\r\n            int digit = k % 10;\r\n            k = k / 10;\r\n            int tmp = num[i] + digit + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n        }\r\n        while (k > 0) {\r\n            int tmp = k % 10 + add;\r\n            if (tmp > 9) {\r\n                res.push_back(tmp - 10);\r\n                add = 1;\r\n            } else {\r\n                res.push_back(tmp);\r\n                add = 0;\r\n            }\r\n            k = k / 10;\r\n        }\r\n        if (add == 1) {\r\n            res.push_back(1);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562572","body":"### 思路\r\n\r\n正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n);\r\n        int prec = INT_MIN / 2;\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                ans[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = i - prec;\r\n            }\r\n        }\r\n\r\n        prec = INT_MAX / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                s[i] = 0;\r\n                prec = i;\r\n            } else {\r\n                ans[i] = min(ans[i], prec - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839431494","body":"### 思路\r\n\r\n数组模拟栈\r\n\r\n### 代码\r\n\r\n* 代码支持：C++\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> st;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize);\r\n        top = - 1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top != st.size() - 1) {\r\n            st[++top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        } else {\r\n            return st[top--];\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int n = st.size() < k ? st.size() : k;\r\n        for (int i=0; i<n; i++) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push, pop: O(1), increment: O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266167","body":"### 思路\r\n\r\n用 vector 模拟栈操作，顺序遍历输入字符串，遇到 ']' 时进行 pop 操作，并将 ']'  和 '[' 之间的字符串复制所需次数后入栈  \r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\r\n    vector<char> st;\r\n    int top = -1;\r\n\r\n    string decodeString(string s) {\r\n        for (auto c : s) {\r\n            if (c == ']') {\r\n                string tmp;\r\n                while (st[top] != '[') {\r\n                    if (isalpha(st[top])) {\r\n                        tmp += st[top];\r\n                    }   \r\n                    top--;   \r\n                }\r\n                top--;\r\n                reverse(tmp.begin(), tmp.end());\r\n                string cnt_tmp;\r\n                while (top > - 1 && isdigit(st[top])) {\r\n                    cnt_tmp += st[top];\r\n                    top--;\r\n                }\r\n                reverse(cnt_tmp.begin(), cnt_tmp.end());\r\n                int cnt = std::stoi(cnt_tmp);\r\n                string res_tmp;\r\n                for (int i=0; i<cnt; i++) {\r\n                    res_tmp.append(tmp);\r\n                }\r\n                for (auto c : res_tmp) {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n                }\r\n            } else {\r\n                    if (top + 1 < st.size()) {\r\n                        ++top;\r\n                        st[top] = c;\r\n                    } else {\r\n                        st.push_back(c);\r\n                        top++;\r\n                    }\r\n            }\r\n        }\r\n        string res;\r\n        int n = top + 1 < st.size() ? top + 1 : st.size();\r\n        for (int i=0; i<n; i++) {\r\n            res += st[i];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841197060","body":"### 思路\r\n\r\n* push 操作总放入第一个栈，push 前清空第二个栈\r\n* pop 和 peek 操作总在第二个栈进行，pop 前清空第一个栈\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st1, st2;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        while (!st2.empty()) {\r\n            int tmp = st2.top();\r\n            st2.pop();\r\n            st1.push(tmp);\r\n        }\r\n        st1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while (!st1.empty()) {\r\n            int tmp = st1.top();\r\n            st1.pop();\r\n            st2.push(tmp);\r\n        }\r\n        int res = st2.top();\r\n        st2.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while (!st1.empty()) {\r\n            int tmp = st1.top();\r\n            st1.pop();\r\n            st2.push(tmp);\r\n        }\r\n        return st2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return st1.empty() && st2.empty();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841585409","body":"### 思路\r\n\r\n* 参考题解，使用单调栈\r\n* 使用单调栈维护每个分块的最大值\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st;\r\n        st.push(arr[0]);\r\n        int n = arr.size();\r\n        for (int i=1; i<n; i++) {\r\n            if (arr[i] < st.top()) {\r\n                int head = st.top();\r\n                while (!st.empty() && arr[i] < st.top()) {\r\n                    st.pop();\r\n                }\r\n                st.push(head);\r\n            } else {\r\n                st.push(arr[i]);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)，极端情况下，栈中元素为数组所有元素"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844140104","body":"### 思路\r\n\r\n使用双指针，分别走过总路程，相遇点即是相交点\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p, *q;\r\n        p = headA;\r\n        q = headB;\r\n        while (1) {\r\n            if (p == q) {\r\n                return p;\r\n            }\r\n            if (p->next == nullptr && q->next == nullptr) {\r\n                return nullptr;\r\n            }\r\n            if (p->next == nullptr) {\r\n                p = headB;\r\n            } else {\r\n                p = p->next;\r\n            }\r\n            if (q->next == nullptr) {\r\n                q = headA;\r\n            } else {\r\n                q = q->next;\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(M + N)，M 和 N 为两个链表的长度\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845178678","body":"### 思路\r\n\r\n快慢指针，根据路程特点的推导，相遇后将快指针置于head\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *fast = head, *slow = head;\r\n        do {\r\n            if (slow == nullptr ||fast->next == nullptr || fast->next->next == nullptr) {\r\n                return nullptr;\r\n            }\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n        } while (slow != fast);\r\n        fast = head;\r\n        while (slow != fast) {\r\n            fast = fast->next;\r\n            slow = slow->next; \r\n        }\r\n        return fast;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845701542","body":"### 思路\r\n\r\n* 参考题解，双向链表+哈希表\r\n* 使用 dummy_head 和 dummy_tail\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int capacity) {\r\n        this->capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n        size = 0;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (cache.count(key)) {\r\n            DLinkedNode* node = cache[key];\r\n            moveToHead(node); \r\n            return node->value;           \r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (cache.count(key)) {\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        } else {\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            addToHead(node);\r\n            cache[key] = node;\r\n            size++;\r\n            if (size > capacity) {\r\n                DLinkedNode* deleted = removeTail();\r\n                cache.erase(deleted->key);\r\n                delete deleted;\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846334052","body":"### 思路\r\n\r\n递归\r\n\r\n### 代码\r\n\r\n* 语言支持：c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) {\r\n            return 0;\r\n        }\r\n        if (root->left == nullptr && root->right == nullptr) {\r\n            return 1;\r\n        }\r\n        if (root->left == nullptr && root->right != nullptr) {\r\n            return maxDepth(root->right) + 1;\r\n        }\r\n        if (root->right == nullptr && root->left != nullptr) {\r\n            return maxDepth(root->left) + 1;\r\n        }\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(height)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Davont":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836079739","body":"### 思路\r\n1.先反转数组\r\n2.上下相加\r\n3.再反转成正常数组\r\n\r\n### 代码（JavaScript）\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  /**\r\n   * 大数相加，先将两个数反转\r\n   */\r\n  let numAStr = num.reverse();\r\n  let numBStr = k.toString().split('').reverse();\r\n  let temp = 0;\r\n  let result = [];\r\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\r\n    if (!numAStr[i]) {\r\n      numAStr[i] = 0;\r\n    }\r\n    if (!numBStr[i]) {\r\n      numBStr[i] = 0;\r\n    }\r\n    result[i] = numAStr[i] + +numBStr[i] + temp;\r\n    if (result[i] > 9) {\r\n      result[i] -= 10;\r\n      temp = 1;\r\n    } else{\r\n        temp = 0;\r\n    }\r\n  }\r\n  if (temp === 1) {\r\n    result.push(temp);\r\n  }\r\n  return result.reverse();\r\n};\r\n``` \r\n\r\n        \r\n### 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734919","body":"### 思路\r\n先存入index，然后比较每个index和遍历到数的最小距离，进行输出\r\n\r\n### 代码\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    let len = S.length;\r\n    let cArr = [];\r\n    let res = [];\r\n    for (let i = 0; i < len; i++) {\r\n        if (S[i] === C) {\r\n            cArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        let distance = Math.abs(i - cArr[0]);\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (distance > Math.abs(i - cArr[j])) {\r\n                distance = Math.abs(i - cArr[j])\r\n            }\r\n        }\r\n        res.push(distance)\r\n    }\r\n    return res;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843237775","body":"## 思路\r\n快慢指针 （没做出来，看来题解才知道）\r\n\r\n## 代码\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\n\r\n function divideConquer (head) {\r\n    if (head === null) {\r\n        return null;\r\n    }\r\n    let slow = head;\r\n    let fast = head.next;\r\n    let prev;\r\n    // 找到链表的中点，prev是中点的前一个元素\r\n    // 方法同 leetcode 876\r\n    while (fast && fast.next) {\r\n        prev = slow;\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n    }\r\n\r\n    // 根据中点将链表分为两部分，分别构成左子树和右子树\r\n    const node = new TreeNode(slow.val);\r\n    node.right = divideConquer(slow.next);\r\n    // 处理中点就是第一个元素的特殊情况，只有1或2个元素时会遇到\r\n    if (prev) {\r\n        prev.next = null;\r\n        node.left = divideConquer(head);\r\n    }\r\n    return node;\r\n}\r\n\r\nvar sortedListToBST = function (head) {\r\n    if (head === null) {\r\n        return head;\r\n    }\r\n    return divideConquer(head);\r\n};\r\n\r\n\r\n```\r\n\r\n·"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LangqiZhao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836081583","body":"### 思路\r\n\r\n把数组从末尾开始，和k进行加法运算，并通过进位更新需要加的数值。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        ans = list()\r\n\r\n        add_value = k\r\n        for idx in range(len(num)):\r\n            val = num[len(num) - 1 - idx] + add_value\r\n            add_value = val // 10\r\n            ans.append(val % 10)\r\n\r\n            if add_value == 0:\r\n                break\r\n\r\n        while add_value > 0:\r\n            ans.append(add_value % 10)\r\n            add_value = add_value // 10\r\n\r\n        ans = ans[::-1]\r\n\r\n        if idx < len(num) - 1:\r\n            ans = num[:len(num) - idx - 1] + ans\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837627118","body":"### 思路\r\n\r\n通过类似单调栈的方法，计算到C的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        stack = list()\r\n        sig = None\r\n\r\n        for idx in range(len(s)):\r\n            while stack and (s[stack[-1]] != c) and (s[idx] == c):\r\n                temp_index = stack.pop(-1)\r\n                if sig is None:\r\n                    ans[temp_index] = abs(idx - temp_index)\r\n                else:\r\n                    ans[temp_index] = min(abs(idx - temp_index), abs(sig - temp_index))\r\n            if s[idx] == c:\r\n                sig = idx\r\n            stack.append(idx)\r\n\r\n        while stack and s[stack[-1]] != c:\r\n            temp_index = stack.pop(-1)\r\n            ans[temp_index] = abs(temp_index - sig)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839370882","body":"### 思路\r\n\r\n通过建立一个数组，实现栈的功能。increment考虑长度。\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = list()\r\n        self.max_len = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            val = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return val\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        add_len = min(k, len(self.stack))\r\n        for idx in range(add_len):\r\n            self.stack[idx] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push和pop为O(1), increment为O(min(k, maxSize))\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840240046","body":"### 思路\r\n\r\n建立栈，判断是否是\"]\"，如果不是，入栈；如果是，字符串复制。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num_list = [str(num) for num in range(10)]\r\n        stack_list = list()\r\n        for item in s:\r\n            if item != ']':\r\n                stack_list.append(item)\r\n                continue\r\n            repeat_string = ''\r\n            while stack_list and stack_list[-1] != '[':\r\n                cur_string = stack_list.pop(-1)\r\n                repeat_string = cur_string + repeat_string\r\n            if stack_list[-1] == '[':\r\n                stack_list = stack_list[:-1]\r\n            num_string = ''\r\n            while stack_list and stack_list[-1] in num_list:\r\n                cur_string = stack_list.pop(-1)\r\n                num_string = cur_string + num_string\r\n            if repeat_string and num_string:\r\n                stack_list.append(int(num_string) * repeat_string)\r\n        return ''.join(stack_list)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840973556","body":"### 思路\r\n\r\n建立两个栈，分别记录push和pop的操作。如果pop为空时，就将push逐步出栈、并存入pop栈内。出栈转入时，顺序是相反的。\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = list()\r\n        self.pop_stack = list()\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop(-1))\r\n        return self.pop_stack.pop(-1)\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop(-1))\r\n        return self.pop_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.push_stack and not self.pop_stack:\r\n            return True\r\n        return False\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841657273","body":"### 思路\r\n\r\n通过栈实现，确保栈中的数据是递增的。如果不是，可以出栈后，将较大的数重新入栈。\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = list()\r\n        for item in arr:\r\n            val = item\r\n            while stack and item < stack[-1]:\r\n                pop_val = stack.pop(-1)\r\n                val = max(val, pop_val, item)\r\n            stack.append(val)\r\n        return len(stack)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841746112","body":"### 思路\r\n\r\n链表快慢指针间隔是k，首尾连接重组链表\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k <= 0:\r\n            return head\r\n        pointer = head\r\n        length = 0\r\n        while pointer is not None:\r\n            length += 1\r\n            pointer = pointer.next\r\n\r\n        if length < 2:\r\n            return head\r\n\r\n        gap_val = k % length\r\n        if gap_val == 0:\r\n            return head\r\n        dummy_node = ListNode(0, next=head)\r\n        fast_pointer = dummy_node.next\r\n        slow_pointer = dummy_node\r\n        count = 1\r\n        while fast_pointer is not None:\r\n            if count <= gap_val:\r\n                fast_pointer = fast_pointer.next\r\n                count += 1\r\n            else:\r\n                fast_pointer = fast_pointer.next\r\n                slow_pointer = slow_pointer.next\r\n        ans = slow_pointer.next\r\n        slow_pointer.next = None\r\n        ans_pointer = ans\r\n        while ans_pointer.next is not None:\r\n            ans_pointer = ans_pointer.next\r\n        ans_pointer.next = dummy_node.next\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841918944","body":"### 思路\r\n\r\n构建链表的快慢指针，分别指向相邻的节点，进行交换\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy_node = ListNode(val=0, next=head)\r\n        if head is None or head.next is None:\r\n            return head\r\n        slow_pointer = dummy_node.next\r\n        fast_pointer = dummy_node.next.next\r\n        pointer = dummy_node\r\n        while fast_pointer.next is not None and fast_pointer.next.next is not None:\r\n            tail_node = fast_pointer.next\r\n            pointer.next = fast_pointer\r\n            pointer.next.next = slow_pointer\r\n            pointer = pointer.next.next\r\n            pointer.next = tail_node\r\n            slow_pointer = pointer.next\r\n            fast_pointer = pointer.next.next\r\n\r\n        tail_node = fast_pointer.next\r\n        pointer.next = fast_pointer\r\n        pointer.next.next = slow_pointer\r\n        pointer = pointer.next.next\r\n        pointer.next = tail_node\r\n        return dummy_node.next\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842781759","body":"### 思路\r\n\r\n由于是有序链表，且要求平衡，所以构建平衡搜索二叉树时，链表中间位置，是当前树的根节点，左右分别是树的左右节点。所以通过构建链表的快慢指针，进行递归。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        if head.next is None:\r\n            return TreeNode(val=head.val)\r\n\r\n        node = ListNode(0, next=head)\r\n        slow_pointer = node.next\r\n        fast_pointer = node.next.next\r\n        pointer = node\r\n        while fast_pointer is not None and fast_pointer.next is not None:\r\n            slow_pointer = slow_pointer.next\r\n            fast_pointer = fast_pointer.next.next\r\n            pointer = pointer.next\r\n        right_node = self.sortedListToBST(slow_pointer.next)\r\n        pointer.next = None\r\n        left_node = self.sortedListToBST(node.next)\r\n        val = slow_pointer.val\r\n        return TreeNode(val=val, left=left_node, right=right_node)\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843689495","body":"### 思路\r\n\r\n通过双指针分别指向链表A和B，每次指针指向下一位，当指针指向末尾且没有交叉过时，交叉指向B和A，判断是否存在两个指针相等的情况。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if not headA or not headB:\r\n            return None\r\n        pointer_a = headA\r\n        pointer_b = headB\r\n        convert_a = convert_b = False\r\n        ans = None\r\n        while pointer_a and pointer_b:\r\n            if pointer_a == pointer_b:\r\n                ans = pointer_a\r\n                break\r\n            if not convert_a and pointer_a.next is None:\r\n                pointer_a = headB\r\n                convert_a = True\r\n            else:\r\n                pointer_a = pointer_a.next\r\n            if not convert_b and pointer_b.next is None:\r\n                pointer_b = headA\r\n                convert_b = True\r\n            else:\r\n                pointer_b = pointer_b.next\r\n        return ans\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844605364","body":"### 思路\r\n\r\n通过快慢指针，如果两个指针能够相遇，则说明有环。把相遇的节点和起始节点，以相同的速度移动，再次相遇的节点就是环开始的节点。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = slow = head\r\n        while (fast is not None) and (fast.next is not None):\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n        if (fast is None) or (fast.next is None):\r\n            return None\r\n        while head != slow:\r\n            head = head.next\r\n            slow = slow.next\r\n        return head\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845616650","body":"### 思路\r\n\r\n需要查询和添加的时间复杂度都是O(1),首先想到的是通过哈希表来完成。又由于需要按照访问顺序删除前面的数据，使用双向链表，可以完成。\r\n\r\n### 代码\r\n\r\n```python\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None, pre=None):\r\n        self.val = val\r\n        self.next = next\r\n        self.pre = pre\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.length = capacity\r\n        self.node = ListNode(0)\r\n        self.pointer = self.node\r\n        self.data_dict = dict()\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.data_dict:\r\n            link_node = self.data_dict[key][1]\r\n            if link_node.next is not None:\r\n                link_next = link_node.next\r\n                link_pre = link_node.pre\r\n                link_pre.next = link_next\r\n                link_next.pre = link_pre\r\n                self.pointer.next = link_node\r\n                link_node.pre = self.pointer\r\n                link_node.next = None\r\n                self.pointer = self.pointer.next\r\n            return self.data_dict[key][0]\r\n        return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.data_dict:\r\n            link_node = self.data_dict[key][1]\r\n            if link_node.next is not None:\r\n                link_next = link_node.next\r\n                link_pre = link_node.pre\r\n                link_pre.next = link_next\r\n                link_next.pre = link_pre\r\n                self.pointer.next = link_node\r\n                link_node.pre = self.pointer\r\n                link_node.next = None\r\n                self.pointer = self.pointer.next\r\n            self.data_dict[key][0] = value\r\n        else:\r\n            self.pointer.next = ListNode(key, pre=self.pointer)\r\n            self.data_dict[key] = [value, self.pointer.next]\r\n            self.pointer = self.pointer.next\r\n\r\n        if len(self.data_dict) > self.length:\r\n            next_node = self.node.next.next\r\n            cur_node = self.node.next\r\n            self.node.next = next_node\r\n            next_node.pre = self.node\r\n            del self.data_dict[cur_node.val]\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846325174","body":"### 思路\r\n递归分别计算左右深度，返回较深的结果\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n        if left_depth > right_depth:\r\n            return left_depth + 1\r\n        return right_depth + 1\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846482033","body":"### 思路\r\n递归分别判断左右子树是否相同。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p is None and q is None:\r\n            return True\r\n        if p is None or q is None:\r\n            return False\r\n        left_checking = self.isSameTree(p.left, q.left)\r\n        right_checking = self.isSameTree(p.right, q.right)\r\n        if left_checking and right_checking and (p.val == q.val):\r\n            return True\r\n        return False\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taozi-taozi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836083170","body":"### 思路：\r\n数组遍历\r\n### 代码：\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        re = 0\r\n        for i in num[:-1]:\r\n            re = (re + i) * 10\r\n        re = re + num[-1] + k\r\n        return [int(x) for x in str(re)]\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649030","body":"### 思路\r\n双指针.....😮\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        re = [0]*n\r\n        slow, fast = 0,0\r\n        pre = inf\r\n        while fast<n:\r\n            while s[fast] != c:\r\n                if fast == n-1:\r\n                    break\r\n                fast+=1\r\n            while slow<=fast:\r\n                if s[fast]!=c:\r\n                    re[slow] = abs(slow-pre)\r\n                else:\r\n                    re[slow] = min(abs(slow-pre),abs(slow-fast))\r\n                slow+=1\r\n            pre = fast\r\n            fast+=1\r\n        return re\r\n```\r\n### 复杂度分析😖\r\n时间复杂度：O(n)?\r\n空间复杂度：O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840243834","body":"### 思路\r\n栈，括号匹配\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                zong = ''\r\n                re = stack.pop()\r\n                while re != '[':\r\n                    zong = zong + re[::-1]\r\n                    re = stack.pop()\r\n                shu = ''\r\n                re = stack.pop()\r\n                while re.isdigit():\r\n                    shu = shu + re\r\n                    if len(stack) == 0:\r\n                        break\r\n                    else:\r\n                        re = stack.pop()\r\n                if not re.isdigit():\r\n                    stack.append(re)\r\n                stack.append(zong[::-1]*int(shu[::-1]))\r\n            else:\r\n                stack.append(s[i])\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840978666","body":"### 思路\r\n辅助栈\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n       self.stack_1 = []\r\n       self.stack_2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack_2:\r\n            while self.stack_1:\r\n                self.stack_2.append(self.stack_1.pop())\r\n        return self.stack_2.pop()\r\n        \r\n    def peek(self) -> int:\r\n        if not self.stack_2:\r\n            while self.stack_1:\r\n                self.stack_2.append(self.stack_1.pop())\r\n        return self.stack_2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.stack_1 and not self.stack_2:\r\n            return True\r\n        else:\r\n            return False\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841602397","body":"### 思路\r\n哈希表，与排好序的数组进行比较\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s_arr = sorted(arr)\r\n        count = 0\r\n        dic = {}\r\n        j = 0\r\n        for i in range(len(arr)):\r\n            if s_arr[i] != arr[j]:\r\n                dic[s_arr[i]] = 1\r\n            elif dic and s_arr[i] == arr[j]:\r\n                j+=1\r\n                while j <= i and arr[j] in dic:\r\n                    j+=1\r\n                if j-1 == i:\r\n                    count+=1\r\n            else:\r\n                count+=1\r\n                j+=1\r\n        return count\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841801705","body":"### 思路\r\n快慢指针，特殊情况判断\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n        if k == 0 or not head.next:\r\n            return head\r\n        s,f = head,head\r\n        step = 0\r\n        while step != k:\r\n            f = f.next\r\n            if not f:          # k超过长度的情况\r\n                f = head\r\n                k = k % (step+1)\r\n                step = 0\r\n            else:\r\n                step += 1\r\n        while f.next:\r\n            f = f.next\r\n            s = s.next\r\n        if f == s:              # k和长度相等的情况\r\n            return head\r\n        tou = s.next\r\n        s.next = None\r\n        f.next = head\r\n        return tou\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842024592","body":"### 思路\r\n虚拟头结点\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        root = ListNode(-1)\r\n        pre = head\r\n        cur = head.next\r\n        a = root\r\n        while pre.next:\r\n            next = cur.next\r\n            a.next = cur\r\n            a = a.next\r\n            a.next = pre\r\n            pre.next = next\r\n            a = a.next\r\n            pre = next\r\n            if not pre:\r\n                break\r\n            else:\r\n                cur = next.next\r\n        return root.next\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842871452","body":"### 思路\r\n找到中间的节点作为根节点，递归\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        nums = []\r\n        while head:\r\n            nums.append(head.val)\r\n            head = head.next\r\n        def gou(i,j):\r\n            if i > j:\r\n                return None\r\n            mid = (i+j)//2                       # 定位中间元素\r\n            root = TreeNode(nums[mid]) \r\n            root.left = gou(i,mid-1)\r\n            root.right = gou(mid+1,j)\r\n            return root\r\n        return gou(0,len(nums)-1)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843700813","body":"### 思路\r\n双指针\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a = headA\r\n        b = headB\r\n        while a!=b:\r\n            if a == None:\r\n                a = headB\r\n            else:\r\n                a = a.next\r\n            if b == None:\r\n                b = headA\r\n            else:\r\n                b = b.next\r\n        return a\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844668636","body":"### 思路\r\n两次相遇\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        f = head.next.next\r\n        s = head.next\r\n        while s!=f:\r\n            if not f or not f.next:\r\n                return None\r\n            else:\r\n                f = f.next.next\r\n                s = s.next\r\n        f = head\r\n        while s!=f:\r\n            f = f.next\r\n            s = s.next\r\n        return s\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845661251","body":"### 思路\r\n双向链表+哈希表\r\n### 代码\r\n```python\r\nclass Listnode:       # 双链表的结点\r\n    def __init__(self,key=None,val=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.dic = {}\r\n        self.deque = deque()\r\n        # 双向链表的头和尾\r\n        self.head = Listnode()\r\n        self.tail = Listnode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n    \r\n    def move_node_to_head(self,key):\r\n        node = self.dic[key]\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n\r\n        node.next = self.head.next\r\n        node.pre = self.head\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.dic:\r\n            self.move_node_to_head(key)\r\n            return self.dic[key].val\r\n        else:\r\n            return -1\r\n        \r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dic:\r\n            self.dic[key].val = value\r\n            self.move_node_to_head(key)\r\n        else:\r\n            if len(self.dic) < self.capacity:\r\n                node = Listnode(key,value)\r\n                self.dic[key] = node\r\n                node.next = self.head.next\r\n                node.pre = self.head\r\n                self.head.next.pre = node\r\n                self.head.next = node\r\n            else:\r\n                node = Listnode(key,value)\r\n                self.dic[key] = node\r\n                node.next = self.head.next\r\n                node.pre = self.head\r\n                self.head.next.pre = node\r\n                self.head.next = node\r\n\r\n                del self.dic[self.tail.pre.key]\r\n                s_node = self.tail.pre.pre\r\n                s_node.next = self.tail\r\n                self.tail.pre = s_node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846365307","body":"### 思路\r\n递归\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root == None:\r\n            return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left, right)+1\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DIUDIU110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836088010","body":"### 思路\r\n    模拟数字加法，利用 K 保存进位，先将对应位置的数字相加，再进行取余操作保留结果。\r\n### 程序 C++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& a, int k) {\r\n        vector<int>res;\r\n        vector<int>b;\r\n        while(k)\r\n        {\r\n            b.push_back(k%10);\r\n            k/=10;\r\n        }\r\n        reverse(b.begin(),b.end());\r\n        int fl=0;\r\n        int i,j;\r\n        for(i=a.size()-1,j=b.size()-1;i>=0&&j>=0;i--,j--)\r\n        {\r\n            int te=a[i]+b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n        }\r\n        while(i>=0)\r\n        {\r\n            int te=a[i]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            i--;\r\n        }\r\n        while(j>=0)\r\n        {\r\n            int te=b[j]+fl;\r\n            fl=te/10;\r\n            res.push_back(te%10);\r\n            j--;\r\n        }\r\n        if(fl)\r\n            res.push_back(fl);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n   时间: o(max(n,m)) \r\n   空间: o(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837967947","body":"### 算法思想：\r\n首先遍历一遍数组记录c的位置  为了处理方便 最好在最前面和最后面加上一个特殊位置\r\n再遍历一遍数组求解当前字符前后c位置差的最小值即可 注意最后一个区间里的遍历需要控制一下 不让其再变动区间\r\n### 代码：\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        int v1[10005];\r\n        int cnt=0;\r\n        v1[cnt++]=n+1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(s[i]==c)\r\n                v1[cnt++]=i;\r\n        }\r\n        v1[cnt++]=-n-1;\r\n        vector<int>res(n);\r\n        cnt=1;\r\n        for(int i=0;i<n;i++)\r\n        {\r\n            if(i<=v1[cnt])\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n\r\n            else\r\n            {\r\n                if(v1[cnt]!=-n-1)\r\n                    cnt++;\r\n                res[i]=min(abs(i-v1[cnt-1]),abs(i-v1[cnt]));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839350672","body":"### 思路：\r\n需要注意两种边界即可：\r\n       1.push不能大于maxsize \r\n       2.pop栈不能为空\r\n### 代码C++：\r\n```\r\nclass CustomStack {\r\npublic:\r\n    int *st;\r\n    int cnt;\r\n    int maxx;\r\n    CustomStack(int maxSize) {\r\n        st=(int*)malloc(sizeof(int)*maxSize);\r\n        cnt=-1;\r\n        maxx=maxSize;\r\n    }\r\n    void push(int x) {\r\n        if(cnt!=maxx-1)\r\n            st[++cnt]=x;\r\n    }\r\n    int pop() {\r\n        if(cnt!=-1)\r\n            return st[cnt--];\r\n        else\r\n            return -1;\r\n    }\r\n    void increment(int k, int val) {\r\n        k=min(k,cnt+1);\r\n        for(int i=0;i<k;i++)\r\n        {\r\n            st[i]+=val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n### 复杂度\r\n时间复杂度：push O(1) pop O(1) increment O(k)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840373383","body":"### 解题思路\r\n#### 数字处理, multi初始化为0\r\nmulti = 0\r\nif '0' <= c <= '9:\r\nmulti = multi * 10 + int(c)\r\n#### 左括号'['入栈'[multi, res]'\r\nif c == '[':\r\n    stack.append([multi, res])\r\n    res, multi = '', 0\r\n#### 右括号]出栈\r\nif c == ']':\r\n    cur_multi, last_res = stack.pop()\r\n    res = last_res + cur_multi * res \r\n#### 其余为数字的情况，将c添加至res\r\nelse:\r\n    res += c\r\n### Code C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int>s1;\r\n        stack<string>s2;\r\n        string res=\"\";\r\n        int mul=0;\r\n        for(auto c:s)\r\n        {\r\n            if(c>='0'&&c<='9')//0-9之间 需要记录一下当前mul\r\n            {\r\n                mul=mul*10+c-'0';\r\n            }\r\n            else if(c=='[')\r\n            {\r\n                s1.push(mul);\r\n                s2.push(res);\r\n                res=\"\";\r\n                mul=0;\r\n            }\r\n            else if(c==']')\r\n            {\r\n                int cur_mul=s1.top();\r\n                s1.pop();\r\n                string last_res=s2.top();\r\n                s2.pop();\r\n                for(int i=0;i<cur_mul;i++)\r\n                {\r\n                    last_res+=res;\r\n                }\r\n                res=last_res;\r\n            }\r\n            else\r\n                res+=c;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840958709","body":"### 思路\r\n两个栈s1，s2（辅助栈） 实现队列\r\n#### push操作\r\npush操作符合栈的逻辑 直接push进s1即可\r\n时间复杂度：o(1)\r\n#### pop操作\r\npop操作队列需要在队头出队  不符合栈的逻辑 需要用到辅助栈s2\r\n具体操作：先全pop到s2 再pop s2栈顶 然后处理完之后记得转移到s1\r\n时间复杂度：o(n)\r\n#### empty操作\r\n看看s1为不为空就可以了\r\n时间复杂度：o(1)\r\n#### peek操作\r\n取得是队头 不符合栈的逻辑 需要用到辅助栈s2\r\n具体操作：先全pop到s2 再取s2栈顶进行记录 之后记得转移至s1\r\n时间复杂度：o(n)\r\n\r\nover！\r\n\r\n空间复杂度：两个栈 o(n) 额外 o(1) \r\n### 代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int>s1;\r\n    stack<int>s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        // while(!s2.empty())\r\n        // {\r\n        //     s1.push(s2.top());\r\n        //     s2.pop();\r\n        // }\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while(!s1.empty())\r\n        {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int x=s2.top();\r\n        s2.pop();\r\n        while(!s2.empty())\r\n        {\r\n            s1.push(s2.top());\r\n            s2.pop();\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while(!s1.empty())\r\n        {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int x=s2.top();\r\n        while(!s2.empty())\r\n        {\r\n            s1.push(s2.top());\r\n            s2.pop();\r\n        }\r\n        return x;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844770643","body":"#### 思路\r\nfast and slow pointers. 从head开始，每次快指针移动两个节点，慢指针一个。两者相遇后，增加一个新的指针temp, 从head开始，每次只移动一个节点，直到temp与slow相遇，相遇位置入环处。\r\n#### 代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(head==NULL||head->next==NULL)\r\n            return NULL;\r\n        ListNode*h1=head,*h2=head;\r\n        while(h2!=NULL&&h2->next!=NULL)\r\n        {\r\n            h1=h1->next;\r\n            h2=h2->next->next;\r\n            if(h1==h2)\r\n            {\r\n                ListNode *h3=head;\r\n                while(h3!=h1)\r\n                {\r\n                    h1=h1->next;\r\n                    h3=h3->next;\r\n                }\r\n                return h1;\r\n            }\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n#### 复杂度\r\n时间复杂度：O(n)，其中 n 为链表节点数目。\r\n空间复杂度：O(1)，常数级别。"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846365967","body":"### 思路\r\n递归比较好写\r\nBase case：head==NULL return 0；\r\n然后对比左右子树+1谁大  返回谁\r\n### 代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(root==NULL)\r\n            return 0;\r\n        int l=maxDepth(root->left)+1;\r\n        int r=maxDepth(root->right)+1;\r\n        return max(l,r);\r\n    }\r\n};\r\n```\r\n复杂度\r\n时间复杂度: O(n) ,n为节点的数量\r\n空间复杂度: O(Height) height为树的高度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846489487","body":"### 思路\r\ndfs写法比较舒服\r\nbase case\r\n基本操作\r\n### 代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p==NULL&&q==NULL)\r\n            return true;\r\n        if(p==NULL&&q!=NULL)\r\n            return false;\r\n        if(p!=NULL&&q==NULL)\r\n            return false;\r\n        if(p->val!=q->val)\r\n            return false;\r\n        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N) 遍历每一个 node\r\n\r\n空间复杂度：O(N) 栈的开销"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rfhklwt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091338","body":"## 思路\r\n* 模拟竖式加法，逐位相加，并记录`carry`位\r\n```伪代码\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        res = []\r\n        i, Sum, carry = n - 1, 0, 0\r\n        \r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 1\r\n\r\n            Sum = x + y + carry\r\n            # 当前位\r\n            res.append(Sum % 10)\r\n            # 进位\r\n            carry = Sum // 10\r\n            i, k = i - 1, k // 10\r\n        \r\n        # 最后检查进位是否为１\r\n        if carry > 0:\r\n            res.append(carry)\r\n        \r\n        return res[::-1]\r\n```\r\n* Julia\r\n```julia\r\nfunction add_to_array_form(num::Vector{Int}, k::Int)::Vector{Int}\r\n    n = length(num)\r\n    i, val, carry = n, 0, 0\r\n    res = Int[]\r\n\r\n    while i > 0 || k != 0\r\n        x = i > 0 ? num[i] : 0\r\n        y = k != 0 ? k % 10 : 0\r\n\r\n        val = x + y + carry\r\n        append!(res, val % 10)\r\n        carry = val ÷ 10\r\n        i, k = i - 1, k ÷ 10\r\n    end\r\n\r\n    if carry > 0\r\n        append!(res, carry)\r\n    end\r\n\r\n    return reverse(res)\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(max(n,log k))`，其中`n`为数组的长度。\r\n\r\n* 空间复杂度：`O(1)`，不考虑返回数组。\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838237568","body":"## 思路\r\n1. 首先正向遍历一遍，求出往右找的最短距离；\r\n2. 接着反向遍历一遍，求出往左找的最短距离；\r\n3. 算出他们的最小值就是最短距离了。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n, pos = len(s), float('-inf')\r\n        res = [n] * n\r\n        for i in list(range(n)) + list(range(n)[::-1]):\r\n            if s[i] == c:\r\n                pos = i\r\n            res[i] = min(res[i], abs(i - pos))\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(n)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839394272","body":"## 思路\r\n采用数组模拟即可\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [-1] * maxSize\r\n        self.point = 0\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.point < self.maxSize:\r\n            self.stack[self.point] = x\r\n            self.point += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.point == 0:\r\n            return -1\r\n        else:\r\n            self.point -= 1\r\n            return self.stack[self.point]\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.point)):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(min(k, maxSize))`\r\n\r\n* 空间复杂度：`O(maxSize)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840249650","body":"## 思路\r\n当遇到`[`符号时，我们知道要将括号里面的字符串重复`k`遍，所以用一个**栈**来存放`(current_string, k)`，而当遇到`]`符号的时候就可以把里面的字符串重复`k`遍。\r\n\r\n## 代码\r\n* Python3\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        current_string = \"\"\r\n        k = 0\r\n\r\n        for char in s:\r\n            if char == '[':\r\n                stack.append((current_string, k))\r\n                current_string = \"\"\r\n                k = 0\r\n            elif char == ']':\r\n                last_string, last_k = stack.pop()\r\n                current_string = last_string + last_k * current_string\r\n            elif char.isdigit():\r\n                k = k * 10 + int(char)\r\n            else:\r\n                current_string += char\r\n        \r\n        return current_string\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：`O(S)`，其中`S`为解码后的字符串长度\r\n* 空间复杂度：`O(S)`，其中`S`为解码后的字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840993799","body":"## 思路\r\n\r\n将一个栈当作输入栈，用于压入`push`传入的数据；另一个栈当作输出栈，用于`pop`和`peek`操作。\r\n\r\n每次`pop`或`peek`时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n## 代码\r\n\r\n* Python3\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        self.peek()\r\n        return self.outStack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (not self.inStack) and (not self.outStack)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`push`和`empty`为 `O(1)`，`pop`和 `peek`为均摊`O(1)`。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 `O(1)`。\r\n* 空间复杂度：`O(n)`，其中`n`是操作总数。对于有`n`次`push`操作的情况，队列中会有`n`个元素，故空间复杂度为`O(n)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841600672","body":"## 思路\r\n\r\n* 排序前和排序后的数组，其**计数信息**是一致的，故可通过这一信息来分块。把所有`计数信息一致的块`分成一个`块`即可。\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count = collections.defaultdict(int)\r\n        non_zeros, res = 0, 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count[a] += 1\r\n            if count[a] == 0: non_zeros -= 1\r\n            elif count[a] == 1: non_zeros += 1\r\n\r\n            count[b] -= 1\r\n            if count[b] == 0: non_zeros -= 1\r\n            elif count[b] == -1: non_zeros += 1\r\n\r\n            if non_zeros == 0: res += 1\r\n        \r\n        return res\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nusing DataStructures\r\n\r\nfunction max_chunks_to_sorted(arr::Vector{Int})::Int\r\n    count = DefaultDict(1)\r\n    non_zeros, res = 0, 0\r\n\r\n    for (a, b) in zip(arr, sort(arr))\r\n        count[a] += 1\r\n        if count[a] == 0\r\n            non_zeros -= 1\r\n        elseif count[a] == 1\r\n            non_zeros += 1\r\n        end\r\n\r\n        count[b] -= 1\r\n        if count[b] == 0\r\n            non_zeros -= 1\r\n        elseif count[b] == -1\r\n            non_zeros += 1\r\n        end\r\n\r\n        (non_zeros == 0) && (res += 1)\r\n    end\r\n\r\n    return res\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(NlogN)`，其中`N`为数组的长度。\r\n\r\n* 空间复杂度：`O(N)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841755019","body":"## 思路\r\n\r\n* 首先计算出链表的长度，并且头尾相连\r\n* 接着算出在哪个位置断开即可代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n\r\n        lastElement = head\r\n        length = 1\r\n        # 计算链表长度\r\n        while lastElement.next:\r\n            lastElement = lastElement.next\r\n            length += 1\r\n        # 首尾相连\r\n        lastElement.next = head\r\n        k = k % length\r\n\r\n        tempNode = head\r\n        for _ in range(length - k - 1):\r\n            tempNode = tempNode.next\r\n        \r\n        res = tempNode.next\r\n        # 断开尾巴\r\n        tempNode.next = None\r\n\r\n        return res\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction rotate_right(head::ListNode, k::Int)::ListNode\r\n    isnothing(head) && return head\r\n\r\n    last_element, length = head, 1\r\n    while !isnothing(next(last_element))\r\n        last_element = next(last_element)\r\n        length += 1\r\n    end\r\n\r\n    k = k % length\r\n    next!(last_element, head)\r\n\r\n    temp_element = head\r\n    for _ = 0:(length-k-2)\r\n        temp_element = next(temp_element)\r\n    end\r\n\r\n    answer = next(temp_element)\r\n    next!(temp_element, nothing)\r\n\r\n    return answer\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(N)`，其中`N`为链表的长度。\r\n\r\n* 空间复杂度：`O(1)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842108517","body":"## 思路\r\n\r\n从`pre->a->b->b.next`变到`pre->b->a->b.next`即可\r\n\r\n## 代码\r\n\r\n* Python3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        pre, pre.next = self, head\r\n\r\n        while pre.next and pre.next.next:\r\n            a = pre.next\r\n            b = a.next\r\n\r\n            pre.next, b.next, a.next = b, a, b.next\r\n            pre = a\r\n        \r\n        return self.next\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\n# Definition for singly-linked list.\r\n# Base.@kwdef mutable struct ListNode{V}\r\n#     val::V = 0\r\n#     next::Union{Nothing,ListNode{V}} = nothing\r\n# end\r\nfunction swap_pairs(head::ListNode)::ListNode\r\n    pre = dummpy = ListNode()\r\n    pre.next = head\r\n\r\n    while !isnothing(next(pre)) && !isnothing(next(next(pre)))\r\n        a = pre.next\r\n        b = a.next\r\n\r\n        ## `pre->a->b->b.next` => `pre->b->a->b.next`\r\n        pre.next, b.next, a.next = b, a, b.next\r\n\r\n        pre = a\r\n    end\r\n\r\n    return dummpy.next\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(n)`\r\n\r\n* 空间复杂度：`O(1)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842783123","body":"## 思路\r\n\r\n1. 快慢指针寻求中点\r\n2. 利用深度优先搜索反复遍历求左节点和右节点\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return\r\n        if not head.next: return TreeNode(head.val)\r\n\r\n        slow, fast = head, head.next.next\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        tmp = slow.next\r\n        slow.next = None\r\n        root = TreeNode(tmp.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(tmp.next)\r\n        return root\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction sorted_list_to_bst(head::Union{ListNode, Nothing})::Union{TreeNode, Nothing}\r\n    isnothing(head) && return\r\n    isnothing(head.next) && return TreeNode(head.val)\r\n\r\n    slow, fast = head, head.next.next\r\n    while !isnothing(fast) && !isnothing(fast.next)\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    end\r\n\r\n    tmp = slow.next\r\n    slow.next = nothing\r\n\r\n    root = TreeNode(tmp.val)\r\n    root.left = sorted_list_to_bst(head)\r\n    root.right = sorted_list_to_bst(tmp.next)\r\n\r\n    return root\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(nlogn)`，其中`n`是链表的长度\r\n\r\n* 空间复杂度：`O(logn)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843956624","body":"## 思路\r\n\r\n* 两个链表都跑一遍就能找到交点\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if headA is None or headB is None:\r\n            return None\r\n        p1, p2 = headA, headB\r\n        while p1 is not p2:\r\n            p1 = p1.next if p1 else headB\r\n            p2 = p2.next if p2 else headA\r\n        \r\n        return p1\r\n        \r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction get_intersection_node(head_a::ListNode, head_b::ListNode)::Union{ListNode, Nothing}\r\n    isnothing(head_a) || isnothing(head_b) && return nothing\r\n    pa, pb = head_a, head_b\r\n    \r\n    while pa != pb\r\n        pa = isnothing(pa) ? head_b : pa.next\r\n        pb = isnothing(pb) ? head_a : pb.next\r\n    end\r\n\r\n    return pa\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(m + n)`，其中`m, n`分别为两链表的长度。\r\n\r\n* 空间复杂度：`O(1)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844975513","body":"## 思路\r\n\r\n* 快慢指针（思路略）\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        x = None\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                x = slow\r\n                break\r\n\r\n        if not x: return None\r\n        while head is not x:\r\n            head, x = head.next, x.next\r\n        return head\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction detect_cycle(head::ListNode)::Union{ListNode, Nothing}\r\n    slow, fast = head, head\r\n    x = Nothing\r\n\r\n    while !isnothing(fast) && !isnothing(fast.next)\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n\r\n        if slow == fast\r\n            x = slow\r\n            break\r\n        end\r\n    end\r\n\r\n    isnothing(x) && return nothing\r\n\r\n    while head != x\r\n        head = head.next\r\n        x = x.next\r\n    end\r\n\r\n    return head\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(N)`，其中`N`为链表的长度。\r\n\r\n* 空间复杂度：`O(1)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845664811","body":"## 思路\r\n\r\n略\r\n\r\n## 代码\r\n\r\n* Python3\r\n\r\n```python\r\nclass LRUCache:\r\n    from collections import OrderedDict\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.cache = OrderedDict()\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache: return -1\r\n        val = self.cache[key]\r\n        self.cache.move_to_end(key)\r\n        return val\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.cache: del self.cache[key]\r\n        self.cache[key] = value\r\n        if len(self.cache) > self.size:\r\n            self.cache.popitem(last=False)\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：对于 `put` 和 `get` 都是 `O(1)`\r\n\r\n* 空间复杂度：`O(capacity)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846382449","body":"## 思路\r\n\r\n* 深度优先算法\r\n\r\n## Python 3\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root:\r\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n        else:\r\n            return 0\r\n```\r\n\r\n* 复杂度分析\r\n\r\n* 时间复杂度：`O(N)`。\r\n\r\n* 空间复杂度：`O(height)`。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846503134","body":"## 思路\r\n\r\n1. 深度优先搜索不断迭代比对即可\r\n\r\n## 代码\r\n\r\n* Python 3\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n* Julia\r\n\r\n```julia\r\nfunction is_same_tree(p::Union{TreeNode, Nothing}, q::Union{TreeNode, Nothing})::Bool\r\n    if isnothing(p) && isnothing(q)\r\n        return true\r\n    elseif isnothing(p) || isnothing(q)\r\n        return false\r\n    elseif p.val != q.val\r\n        return false\r\n    else\r\n        return is_same_tree(p.left, p.left) && is_same_tree(p.right, p.right)\r\n    end\r\nend\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：`O(min(m, n))`，其中`m`和`n`分别是两个二叉树的节点数\r\n\r\n* 空间复杂度：`O(min(m, n))`，其中`m`和`n`分别是两个二叉树的节点数"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HTian1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836091664","body":"思路：模拟加法\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i] += carry\r\n            carry = num[i] // 10\r\n            num[i] %= 10\r\n        \r\n        while carry:\r\n            num.insert(0, carry % 10)\r\n            carry //= 10\r\n        \r\n        return num\r\n```\r\n\r\n复杂度：time O(N), space O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837649590","body":"思路：从左到右和从右到左遍历两边\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [float('inf') for i in range(n)]\r\n\r\n        pos = s.index(c)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        pos = s.rindex(c)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pos = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i], abs(i - pos))\r\n        \r\n        return ans\r\n```\r\n\r\nComplexity: time O(N), space O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839414697","body":"思路：数组模拟栈进行操作\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop(-1)\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        size = min(k, len(self.stack))\r\n        for i in range(size):\r\n            self.stack[i] += val\r\n```\r\n\r\nComplexity: \r\ntime: push: O(1), pop O(1), increment: O(n)\r\nspace: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840200523","body":"思路：判断当前字符是否为\"]\"，如果不是就直接push进栈，是就开始一系列操作：不断弹出栈顶元素直到为\"[\"，翻转这部分然后再根据数字入栈。需要注意数字可能多位，需要累积。\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = \"\"\r\n        stack = []\r\n\r\n        for char in s:\r\n            # pop up\r\n            if char == \"]\":\r\n                repeat = \"\"\r\n                while stack[-1] != \"[\":\r\n                    repeat += stack.pop(-1)\r\n                \r\n                # reverse the repeat\r\n                repeat = repeat[::-1]\r\n                stack.pop(-1)\r\n\r\n                number = \"\"\r\n                while stack and stack[-1].isnumeric():\r\n                    number += stack.pop(-1)\r\n                \r\n                number = int(number[::-1])\r\n                \r\n                for i in range(number):\r\n                    for elem in repeat: \r\n                        stack.append(elem)\r\n            \r\n            else:\r\n                stack.append(char)\r\n        \r\n        return \"\".join(stack)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841289685","body":"思路：双栈模拟\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outStack:\r\n            self.reverse()\r\n        \r\n        return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outStack:\r\n            self.reverse()\r\n        \r\n        return self.outStack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.inStack and not self.outStack\r\n    \r\n    def reverse(self):\r\n        while self.inStack:\r\n            self.outStack.append(self.inStack.pop())\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841579226","body":"思路：单调栈\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop(-1)\r\n                while stack and num < stack[-1]:\r\n                    stack.pop(-1)\r\n                \r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n\r\n        return len(stack)\r\n```\r\nComplexity: time O(N), space O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841817776","body":"思路：k取余避免重复操作，尾首相连断开之间\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n\r\n        size = 0\r\n\r\n        prob = head\r\n        while prob:\r\n            size += 1\r\n            prob = prob.next\r\n        \r\n        k = k % size\r\n\r\n        if k == 0:\r\n            return head\r\n\r\n        slow = fast = head\r\n        for _ in range(k):\r\n            fast = fast.next\r\n        \r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        \r\n        ans = slow.next\r\n        fast.next = head\r\n        slow.next = None\r\n\r\n        return ans\r\n```\r\nComplexity: time O(N), space O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841886805","body":"思路：三个指针指向之前的一个、现在和后面，交换现在和后面的节点，移动三指针\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head:\r\n            return None\r\n        \r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n\r\n        prob = dummy\r\n        first = prob.next\r\n        second = first.next\r\n\r\n        while second:\r\n            # change\r\n            prob.next = second\r\n            first.next = second.next\r\n            second.next = first\r\n\r\n            # move pointers\r\n            prob = first\r\n            first = prob.next\r\n            if not first:\r\n                break\r\n            second = first.next\r\n\r\n        return dummy.next\r\n```\r\nComplexity: time O(N), space O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842780778","body":"思路：链表拆分为二，递归求解\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n\r\n        prev = None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            prev = slow\r\n            slow = slow.next\r\n        \r\n        nextStart = slow.next\r\n        if prev:\r\n            prev.next = None\r\n        \r\n        node = TreeNode(slow.val)\r\n        left = self.sortedListToBST(head)\r\n        right = self.sortedListToBST(nextStart)\r\n        node.left = left\r\n        node.right = right\r\n\r\n        return node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843623738","body":"思路：循环走两个链表\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        prob1, prob2 = headA, headB\r\n        while prob1 != prob2:\r\n            prob1 = prob1.next if prob1 else headB\r\n            prob2 = prob2.next if prob2 else headA\r\n        \r\n        return prob1\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844625627","body":"Two pointer\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n\r\n        while True:\r\n            if not (fast and fast.next): \r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow: \r\n                break\r\n        \r\n        fast = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        \r\n        return fast\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845535443","body":"思路：双向链表\r\n```python\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.order = collections.OrderedDict()\r\n        self.capacity = capacity\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.order.keys(): \r\n            return -1\r\n        \r\n        self.order.move_to_end(key)\r\n        return self.order[key]\r\n        \r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.order.keys() and len(self.order) == self.capacity:\r\n            self.order.popitem(last = False)\r\n        self.order[key] = value\r\n        self.order.move_to_end(key)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846294737","body":"思路：dfs\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846439285","body":"思路：对应位置对比\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if (p or q) and not (p and q):\r\n            return False\r\n        \r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"terrylijiayang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836094791","body":"**思路**\r\n两个循环。第一个循环先统一到一个数组，第二个循环再做进位处理。\r\n**代码**\r\n```\r\nvar addToArrayForm = function (A, K) {\r\n    count = 0;\r\n    len = K.toString().length;\r\n    for (let i = 0; i < len; i++) {\r\n        if (A.length < len) {\r\n            A.unshift(0);\r\n        }\r\n        count = K % 10;\r\n        K = parseInt(K / 10);\r\n        A[A.length - 1 - i] += count;\r\n    }\r\n    for (let i = 0; i < A.length; i++) {\r\n        if (A[0] > 9) {\r\n            A.unshift(0);\r\n        }\r\n        if (A[A.length - 1 - i] > 9) {\r\n            A[A.length - 2 - i]++;\r\n            A[A.length - 1 - i] = A[A.length - 1 - i] % 10;\r\n        }\r\n    }\r\n    return A;\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838562657","body":"**思路**\r\n先用数组存储距离位置，再通过外循环找位置，再内循环找最小值。\r\n\r\n**代码**\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O（n²）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839813869","body":"**思路**\r\n用数组来存栈，实现增量操作\r\n**代码**\r\n```\r\nvar CustomStack = function(maxSize) {\r\n    s = []\r\n    t=0\r\n    n = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(t<n) s[++t]=x\r\n    return s\r\n\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(t)return s[t--]\r\n    return -1\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    while(k) s[k--]+=val\r\n\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n空间复杂度O（n）\r\n时间复杂度O（n）"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842806579","body":"**思路**\r\n1、提取有序树的值\r\n2、递归 构造二叉搜索树\r\n**代码**\r\n```\r\nvar sortedListToBST = function(head) {\r\n    let vals=[];\r\n    while(head){\r\n        vals.push(head.val);\r\n        head = head.next;\r\n    }\r\n    // vals.sort((a,b)=>(a-b));\r\n    let len= vals.length;\r\n    return dfs(vals,0,len);\r\n\r\n    function dfs(vals,left,right){\r\n        if(right-left==0)return null; \r\n        let mid =left + parseInt((right-left)/2);\r\n        let root  = new TreeNode( vals[mid] ) ;\r\n        if(right- left == 1)return root;\r\n        root.left =dfs(vals,left,mid);\r\n        root.right = dfs(vals,mid+1,right);\r\n        return root;\r\n    } \r\n};\r\n```\r\n**时间复杂度**\r\n时间复杂度：O(N)\r\n空间复杂度：O(logN)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846410849","body":"**思路**\r\n深度优先搜索\r\n\r\n**代码**\r\n```\r\nvar maxDepth = function(root) {\r\n    if(root!=null){\r\n        var left = maxDepth(root.left)\r\n        var right = maxDepth(root.right)\r\n        return left>right? left+1:right+1\r\n    }\r\n    return 0\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n时间复杂度O（N）\r\n空间复杂度O（N），N为树高\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xyxy1722":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098804","body":"思路\r\n每次取num的最后一位和k运算并保存最后一位的结果\r\n\r\n代码\r\n语言支持：Python3\r\nPython3 Code:\r\n\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        result = []\r\n        while(i >= 0 or k != 0):\r\n            if i >= 0:\r\n                k = k + num[i]\r\n            result.insert(0, k % 10)\r\n            k = int(k / 10)\r\n            i = i - 1\r\n        return result\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837654968","body":"## 思路\r\ndis值只和最近的c的位置有关 从左向右遍历一遍再从右向左遍历一遍\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_loc = -10000\r\n        dis = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            dis.append(abs(i - c_loc))\r\n        c_loc = 20000\r\n        while(i >= 0):\r\n            if s[i] == c:\r\n                c_loc = i\r\n            if dis[i] > abs(i - c_loc):\r\n                dis[i] = abs(i - c_loc)\r\n            i = i - 1\r\n        return dis\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839384712","body":"\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.index = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.index < self.maxSize:\r\n            self.stack.append(x)\r\n            self.index += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.index > 0:\r\n            self.index -= 1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i >= self.index:\r\n                break\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(k)\r\n- 空间复杂度：O(maxsize)\r\n\r\n\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843103167","body":"## 思路\r\n将有序链表转化为有序数组，用分治法构建二叉树\r\n\r\n## 代码\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        arr = []\r\n        while head:\r\n            arr.append(head.val)\r\n            head = head.next\r\n        def BuildBST(start:int, end:int) -> TreeNode:\r\n            if start > end:\r\n                return\r\n            mid = (start + end) // 2\r\n            root = TreeNode(val=arr[mid])\r\n            root.left = BuildBST(start, mid - 1)\r\n            root.right = BuildBST(mid + 1, end)\r\n            return root\r\n        return BuildBST(0, len(arr) - 1)\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843925098","body":"## 思路\r\n\r\n-  pA指向A链表，pB指向B链表同时开始遍历，pA遍历结束时指向B链表，pB遍历结束时指向A链表，虽然A、B长度不一定相等，但是A+B长度一定相等，所以pA和pB一定可以同时到达相交节点。\r\n\r\n## 代码\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pA, pB = headA, headB\r\n        while pA != pB:\r\n            if not pA.next and pB.next:\r\n                pA = headB\r\n                pB = pB.next\r\n            elif not pB.next and pA.next:\r\n                pB = headA\r\n                pA = pA.next\r\n            elif pA.next and pB.next:\r\n                pA = pA.next\r\n                pB = pB.next\r\n            else:\r\n                return\r\n        return pA\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n+m)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844613592","body":"## 思路\r\n遍历链表，用哈希表记录所有节点是否被访问过，被访问过直接返回\r\n\r\n## 代码\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        visited = {}\r\n        while(head):\r\n            if visited.get(head):\r\n                return head\r\n            else:\r\n                visited[head] = True\r\n                head = head.next\r\n        return\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845883210","body":"## 思路\r\n哈希表 + 双向链表\r\n\r\n## 代码\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass BiListNode:\r\n    def __init__(self, key=0, val=0, pre=None, next=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.next = next\r\n        self.pre = pre\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.size = 0\r\n        self.capacity = capacity\r\n        self.cache = {}\r\n        self.head = BiListNode()\r\n        self.tail = BiListNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if self.cache.get(key):\r\n            self.cache[key].pre.next = self.cache[key].next\r\n            self.cache[key].next.pre = self.cache[key].pre\r\n            self.cache[key].pre = self.head\r\n            self.cache[key].next = self.head.next\r\n            self.head.next.pre = self.cache[key]\r\n            self.head.next = self.cache[key]\r\n            return self.cache.get(key).val\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if self.cache.get(key):\r\n            self.cache[key].val = value\r\n            self.cache[key].pre.next = self.cache[key].next\r\n            self.cache[key].next.pre = self.cache[key].pre\r\n            self.cache[key].pre = self.head\r\n            self.cache[key].next = self.head.next\r\n            self.head.next.pre = self.cache[key]\r\n            self.head.next = self.cache[key]\r\n        else:\r\n            if self.size >= self.capacity:\r\n                self.size -= 1\r\n                self.cache.pop(self.tail.pre.key)\r\n                self.tail.pre.pre.next = self.tail\r\n                self.tail.pre = self.tail.pre.pre\r\n            self.size += 1\r\n            new_node = BiListNode(key, value, self.head, self.head.next)\r\n            self.cache[key] = new_node\r\n            self.head.next.pre = new_node\r\n            self.head.next = new_node\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846330106","body":"## 思路\r\n深度优先\r\n\r\n## 代码\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    # DFS\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(height)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eachless":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836098983","body":"\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n =  num.length;\r\n        int cur = k;\r\n        List<Integer> ans = new ArrayList();\r\n        \r\n        int i = n;\r\n        \r\n        while(--i >=0 || cur > 0){\r\n            if( i >= 0){\r\n                cur +=num[i];\r\n            }\r\n            \r\n            ans.add(cur % 10);\r\n            cur /= 10;\r\n        }\r\n        \r\n        \r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837305634","body":"\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] arr = new int[len];\r\n        int cpos = -len;\r\n        \r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i) == c){\r\n                cpos = i;\r\n            }\r\n            \r\n            arr[i] = i - cpos;\r\n        }\r\n        \r\n        for ( int i =len -1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cpos=i;\r\n            }\r\n            arr[i] = Math.min(arr[i],Math.abs(i-cpos));\r\n        }\r\n        \r\n        return arr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840083896","body":"class Solution {\r\n    public String decodeString(String s) {\r\n        int num = 0;\r\n        Stack <Object> stack = new Stack<>();\r\n        for(char c : s.toCharArray()){\r\n            //1 number\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }else if( c == '['){\r\n                stack.push(Integer.valueOf(num));\r\n                num = 0;\r\n            }else if(c == ']'){\r\n                String newstr = dfs(stack);\r\n                Integer cnt = (Integer)stack.pop();\r\n                for(int i=0; i<cnt; i++){\r\n                    stack.push(newstr);\r\n                }\r\n            }else{//4. character\r\n                stack.push(String.valueOf(c));\r\n            }\r\n            //2 letter\r\n        }\r\n        return dfs(stack);\r\n    }\r\n    \r\n    private String dfs(Stack<Object> stack){\r\n        Stack<String> tmp = new Stack<>();\r\n        while(!stack.isEmpty()&& stack.peek() instanceof String){\r\n            tmp.push((String)stack.pop());\r\n        }\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while(!tmp.isEmpty()){\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841299738","body":"```java\r\n class MyQueue {\r\n        Stack <Integer> fstack = new Stack();\r\n        Stack <Integer> output = new Stack();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        Stack <Integer> fstack = new Stack();\r\n        Stack <Integer> output = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        fstack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        peek();\r\n       return output.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (output.empty())\r\n            while(!fstack.empty())\r\n                output.push(fstack.pop());\r\n        return output.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return fstack.empty() && output.empty();\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841821327","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next ==null){\r\n            return head;\r\n        }\r\n        \r\n        ListNode index = head;\r\n        int len = 1;\r\n        while(index.next != null)\r\n        {\r\n            index =index.next;\r\n            len++;\r\n        }\r\n        \r\n        index.next = head;\r\n        \r\n        for (int i =1;i <len - k % len; i++){\r\n            head = head.next;\r\n        }\r\n        \r\n        ListNode res = head.next;\r\n        head.next = null;\r\n        return res;\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841926862","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode temp = new ListNode(0);\r\n        temp.next = head;\r\n        ListNode current = temp;\r\n        \r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        \r\n        while(current.next !=null && current.next.next !=null){\r\n            ListNode firstNode = current.next;\r\n            ListNode secondNode = current.next.next;\r\n            firstNode.next = secondNode.next;\r\n            current.next = secondNode;\r\n            current.next.next = firstNode;\r\n            current =current.next.next;\r\n        }\r\n        \r\n        return temp.next;        \r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842794232","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return helper(head,null);\r\n    }\r\n    \r\n    private TreeNode helper(ListNode start, ListNode end){\r\n        if(start == end) return null;\r\n        \r\n        ListNode slow = start;\r\n        ListNode fast = start;\r\n        while(fast != end && fast.next != end){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        \r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(start,slow);\r\n        root.right = helper(slow.next,end);\r\n        return root;\r\n    } \r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843617137","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        int lenA = length(headA), lenB = length(headB);\r\n        while(lenA > lenB){\r\n            headA = headA.next;\r\n            lenA--;\r\n        }\r\n        while(lenA < lenB){\r\n            headB = headB.next;\r\n            lenB--;\r\n        }\r\n        \r\n        while(headA != headB){\r\n            headA = headA.next;\r\n            headB = headB.next;\r\n        }\r\n        return headA;\r\n    }\r\n    \r\n    private int length(ListNode n){\r\n        int len = 0;\r\n        while(n != null){\r\n            n = n.next;\r\n            len++;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844545059","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next ==null) return null;\r\n\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        \r\n        while(fast != null){\r\n            slow = slow.next;\r\n            if(fast.next != null){\r\n                fast = fast.next.next;\r\n            }else\r\n                return null;\r\n            \r\n            if(slow == fast){\r\n                ListNode temp = head;\r\n                while(temp != slow){\r\n                    temp = temp.next;\r\n                    slow = slow.next;\r\n                }\r\n                return temp;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845559438","body":"```java\r\nclass LRUCache {\r\n\r\n    class Node {\r\n        int key;\r\n        int value;\r\n        Node next;\r\n        Node pre;\r\n        public Node (int key, int value){\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n    }\r\n    private HashMap <Integer,Node> map;\r\n    private int capacity;\r\n    private Node head;\r\n    private Node tail;\r\n    \r\n    public LRUCache(int capacity) {\r\n        map = new HashMap<>();\r\n        this.capacity = capacity;\r\n        head = null;\r\n        tail = null;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        //node is newest return\r\n        Node node = map.get(key);\r\n        if(node == null){\r\n            return -1;\r\n        }\r\n        // if node is not head, move to tail\r\n        if(node != tail){   \r\n            if(node == head){\r\n                head = head.next;\r\n            } else{\r\n                node.pre.next = node.next;\r\n                node.next.pre = node.pre;\r\n            }\r\n\r\n            tail.next = node;\r\n            node.pre = tail;\r\n            node.next = null;\r\n            tail = node;\r\n        }\r\n            return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n      Node node = map.get(key);\r\n        if(node != null){ \r\n            node.value = value;\r\n            if(node != tail ){\r\n                if(node == head){\r\n                    head =head.next;\r\n                }else{\r\n                node.pre.next = node.next;\r\n                node.next.pre = node.pre;\r\n                }\r\n                tail.next = node;\r\n                node.pre  =tail;\r\n                node.next = null;\r\n                tail = node;   \r\n            }\r\n        }else{\r\n          // insert new node\r\n          Node newNode = new Node(key,value);\r\n          if(capacity == 0){\r\n              Node temp = head;\r\n              head = head.next;\r\n              map.remove(temp.key);\r\n              capacity ++;\r\n          } \r\n          //first elment of linkedlist\r\n          if(head==null && tail == null){\r\n              head = newNode;\r\n          }else{\r\n              tail.next = newNode;\r\n              newNode.pre = tail;\r\n              newNode.next = null;\r\n          }\r\n          \r\n          tail = newNode;\r\n          map.put(key,newNode);\r\n          //cap --\r\n          capacity--;\r\n      }\r\n    }\r\n}\r\n\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836108570","body":"【思路】记住加法进位数量，一级一级加\r\n\r\n【代码】java\r\n\r\n`        int ans = 0;\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int i = num.length-1;\r\n       \r\n        while( k>0||i>=0){  \r\n            if(i>=0){\r\n                k = num[i]+k; \r\n            } \r\n                    \r\n            int temp = k%10;\r\n            k = k/10;\r\n            arr.add(temp);\r\n            i--;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }`\r\n\r\n【复杂度】时间O(n),空间O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837697742","body":"【思路】先找出所有的index存起来，再从右往左比较每个数前后两个index的距离，如果碰到了这个数，就remove掉它的index。\r\n               这么做可以，但是太慢了。其实跟从左找一遍再从右找一遍思路差不多，而且后者会更快\r\n【复杂度】 时间O(N) 空间O(N)\r\n\r\n     `public int[] shortestToChar(String s, char c) {\r\n        ArrayList<Integer> index = new ArrayList<Integer>() ;\r\n        int[] ans = new int[s.length()] ;\r\n        int i = 0;\r\n        for(i =0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                index.add(i);\r\n                ans[i]=0;\r\n            }\r\n        }\r\n        int lastIdx = 99999;\r\n        for(i = s.length()-1; i>=0 ;i--){\r\n            int dis = 0;\r\n            if(index.size()==0){\r\n                dis = Math.abs(lastIdx-i);\r\n                \r\n            }else{\r\n            int curr = index.get(index.size()-1);\r\n            dis =Math.min(Math.abs(curr-i),Math.abs(i-lastIdx));\r\n                if(i == curr){\r\n                    index.remove(index.size()-1);\r\n                    lastIdx = curr;\r\n                }\r\n            }\r\n            ans[i] = dis;\r\n            \r\n\r\n        }\r\n        \r\n        return ans;\r\n\r\n    }`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839437752","body":"思路：一开始就想着暴力写，inc是O(n),这样可以做但是很慢。 看了官方题解才发现只需要在pop的时候算出结果就可以了，因为其他操作是不会涉及到计算value的。就可以进化成为O(1)了\r\n复杂度:O(N)\r\n\r\n``` class CustomStack {\r\n    int occp = 0;\r\n    int size = 0;\r\n    int acc = 0;\r\n    ArrayList<Integer> ans = new ArrayList<Integer>();\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.occp=maxSize;\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.size<occp){\r\n        this.ans.add(x);\r\n        this.size++;\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size==0){ return -1;}\r\n        this.size--;\r\n        return ans.remove(size);\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i<k ;i++){\r\n            if(i>=this.size) return;\r\n            this.ans.set(i, val +this.ans.get(i));\r\n        }\r\n    }```"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841969139","body":"【思路】每两个为一组，两两交换，递归下去，如果最后只剩单数，就判断next是不是null直接return\r\n【复杂度】因为递归时间O（n）空间O（1）\r\n```public ListNode swapPairs(ListNode head) {\r\n          if(head==null) return null;\r\n           ListNode next =  head.next;\r\n           if(next==null){\r\n               return head;\r\n           }\r\n           ListNode newNext = next.next;\r\n           next.next = head;\r\n           head.next = swapPairs(newNext);\r\n           return next;\r\n\r\n    }```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yeanli95":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836112944","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nFirst Idea is to convert the array into Integer, then  sum up the array and k, then convert into desire result format.\r\n\r\nBut when array size gets larger, it is easy to get overflow when converting into integer.\r\n\r\nThen we need to go through the long way, adding bits from least significant to most significant, \r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<>();\r\n\r\n        int carry = 0;\r\n        int numindex = num.length -1;\r\n        \r\n        while(numindex >=0 || k > 0 ){\r\n            int nums = numindex >=0 ? num[numindex] : 0;\r\n            int results = k > 0 ? k % 10 : 0;\r\n                                                      \r\n            int tempval = results + nums + carry;\r\n            int remainder = tempval % 10;\r\n            \r\n            carry = tempval / 10;\r\n            \r\n            result.add(0, remainder);\r\n            numindex--;\r\n            k /=10;\r\n        }\r\n        \r\n        if(carry > 0){\r\n            result.add(0, carry);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837685280","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\nIterate the array from left to right, then from right to left to find optimal solution\r\n## 关键点\r\nInitialized Array to Integer.MAX_VALUE since we will be using Math.min function;\r\nWhen we first start iterating , assume the matching character will be on the other end.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int [] result = new int[s.length()];\r\n        int cur = s.length() - 1;\r\n        Arrays.fill(result,Integer.MAX_VALUE);\r\n        for(int i =0; i < s.length(); i ++){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            \r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        cur = 0;\r\n        for(int i =s.length() - 1; i >=0; i--){\r\n            if(s.charAt(i) == c){\r\n                cur = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(cur - i));\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839399944","body":"## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nSince it is a fixed size stack, it would be easier to use an array, so that both insert and get operation is O(1)\r\n\r\n## 关键点\r\n\r\nbe careful about the index on what it should be.\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\nclass CustomStack {\r\n    int size;\r\n    int position;\r\n    int [] mystack;\r\n    public CustomStack(int maxSize) {\r\n        mystack = new int[maxSize];\r\n        size = maxSize; \r\n        position = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(position+1 < size){\r\n            mystack[position+1] = x;\r\n            position++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(position > -1)\r\n            return mystack[position--];\r\n        else\r\n            return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(k > position){\r\n            k = position+ 1;\r\n        }\r\n        for(int i =0; i < k; i ++){\r\n            mystack[i] = mystack[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840270723","body":" * - ## 394. Decode String\r\n\r\n     https://leetcode.com/problems/decode-string/\r\n\r\n      ## 题目描述\r\n\r\n      ```\r\n     Given an encoded string, return its decoded string.\r\n     \r\n     The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\r\n     \r\n     You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\r\n     \r\n     Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\r\n     \r\n      \r\n     \r\n     Example 1:\r\n     \r\n     Input: s = \"3[a]2[bc]\"\r\n     Output: \"aaabcbc\"\r\n     Example 2:\r\n     \r\n     Input: s = \"3[a2[c]]\"\r\n     Output: \"accaccacc\"\r\n     Example 3:\r\n     \r\n     Input: s = \"2[abc]3[cd]ef\"\r\n     Output: \"abcabccdcdcdef\"\r\n     Example 4:\r\n     \r\n     Input: s = \"abc3[cd]xyz\"\r\n     Output: \"abccdcdcdxyz\"\r\n      ```\r\n\r\n      ## 前置知识\r\n\r\n      - \r\n\r\n      ## 公司\r\n\r\n      - 暂无\r\n\r\n      ## 思路\r\n\r\n     没想明白。参考leetcode官方题解\r\n\r\n     使用两个Stack 一个存次数 一个存string \r\n\r\n     因为这个规律是不变的 所以如果看到[ ， 就知道这是新的开始 也是旧的结束 所以把数字跟string 都放进stack \r\n\r\n     如果看到 ]  就知道， string已经完结 可以看看有多少重复 都列入去\r\n\r\n      ## 关键点\r\n\r\n      \r\n\r\n      ## 代码\r\n\r\n      - 语言支持：Java\r\n\r\n      Java Code:\r\n\r\n      ```Java\r\n     class Solution {\r\n         public String decodeString(String s) {\r\n             Stack<Integer> number = new Stack<>();\r\n             Stack<StringBuilder> sb = new Stack<>();\r\n             int k = 0;\r\n             StringBuilder currentString = new StringBuilder();\r\n             for(char ch : s.toCharArray()){\r\n                 if(Character.isDigit(ch)){\r\n                     k = k* 10 + ch -'0';\r\n                 }\r\n                 else if(ch == '['){\r\n                     number.push(k);\r\n                     \r\n                     sb.push(currentString);\r\n                     \r\n                     currentString = new StringBuilder();\r\n                     \r\n                     k = 0;\r\n                 }\r\n                 else if( ch ==']'){\r\n                     StringBuilder temp = sb.pop();\r\n                     for(int i = number.pop(); i > 0; i --){\r\n                         temp.append(currentString);\r\n                     }\r\n                     \r\n                     currentString = temp;\r\n                 }\r\n                 else{\r\n                     currentString.append(ch);\r\n                 }\r\n             }\r\n             \r\n             return currentString.toString();\r\n         }\r\n     }\r\n      ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(maxK * n)$\r\n      - 空间复杂度：$O(m+n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840982845","body":" * ## 232. Implement Queue using Stacks\r\n\r\n   https://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n   ## 题目描述\r\n\r\n   ```\r\n   Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\r\n   \r\n   Implement the MyQueue class:\r\n   \r\n   void push(int x) Pushes element x to the back of the queue.\r\n   int pop() Removes the element from the front of the queue and returns it.\r\n   int peek() Returns the element at the front of the queue.\r\n   boolean empty() Returns true if the queue is empty, false otherwise.\r\n   Notes:\r\n   \r\n   You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\r\n   Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\r\n   Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.\r\n   \r\n    \r\n   \r\n   Example 1:\r\n   \r\n   Input\r\n   [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n   [[], [1], [2], [], [], []]\r\n   Output\r\n   [null, null, null, 1, 1, false]\r\n   \r\n   Explanation\r\n   MyQueue myQueue = new MyQueue();\r\n   myQueue.push(1); // queue is: [1]\r\n   myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\n   myQueue.peek(); // return 1\r\n   myQueue.pop(); // return 1, queue is [2]\r\n   myQueue.empty(); // return false\r\n    \r\n   \r\n   Constraints:\r\n   \r\n   1 <= x <= 9\r\n   At most 100 calls will be made to push, pop, peek, and empty.\r\n   All the calls to pop and peek are valid.\r\n   ```\r\n\r\n   ## 前置知识\r\n\r\n    - \r\n\r\n   ## 公司\r\n\r\n    - 暂无\r\n\r\n   ## 思路\r\n\r\n   一个Stack 为主Stack\r\n\r\n   另一个为副\r\n\r\n   \r\n\r\n   如果要用到Pop 或者Peek  就把两个Stack 倒过去就能看到最低的那个元素\r\n\r\n   之后完成之后再倒回来\r\n\r\n   ## 关键点\r\n\r\n    \r\n\r\n   ## 代码\r\n\r\n    - 语言支持：Java\r\n\r\n    Java Code:\r\n\r\n   ```Java\r\n   class MyQueue {\r\n       Stack<Integer> stack1;\r\n       Stack<Integer> stack2;\r\n       /** Initialize your data structure here. */\r\n       public MyQueue() {\r\n           stack1 = new Stack<>();\r\n           stack2 = new Stack<>();\r\n       }\r\n       \r\n       /** Push element x to the back of queue. */\r\n       public void push(int x) {\r\n           stack1.push(x);\r\n       }\r\n       \r\n       /** Removes the element from in front of queue and returns that element. */\r\n       public int pop() {\r\n           while(stack1.size() != 1){\r\n               stack2.push(stack1.pop());\r\n           }\r\n           int result = stack1.pop();\r\n           \r\n           while(!stack2.isEmpty()){\r\n               stack1.push(stack2.pop());\r\n           }\r\n           \r\n           return result;\r\n       }\r\n       \r\n       /** Get the front element. */\r\n       public int peek() {\r\n           while(!stack1.isEmpty()){\r\n               stack2.push(stack1.pop());\r\n           }\r\n           \r\n           int result = stack2.peek();\r\n           \r\n           while(!stack2.isEmpty()){\r\n               stack1.push(stack2.pop());\r\n           }\r\n           return result;\r\n       }\r\n       \r\n       /** Returns whether the queue is empty. */\r\n       public boolean empty() {\r\n           return stack1.isEmpty();\r\n       }\r\n   }\r\n   \r\n   /**\r\n    * Your MyQueue object will be instantiated and called as such:\r\n    * MyQueue obj = new MyQueue();\r\n    * obj.push(x);\r\n    * int param_2 = obj.pop();\r\n    * int param_3 = obj.peek();\r\n    * boolean param_4 = obj.empty();\r\n    */\r\n   ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841595277","body":"## 768. Max Chunks To Make Sorted II\r\n\r\n  https://leetcode.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\n This question is the same as \"Max Chunks to Make Sorted\" except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.\r\n\r\nGiven an array arr of integers (not necessarily distinct), we split the array into some number of \"chunks\" (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.\r\n\r\nWhat is the most number of chunks we could have made?\r\n\r\nExample 1:\r\n\r\nInput: arr = [5,4,3,2,1]\r\nOutput: 1\r\nExplanation:\r\nSplitting into two or more chunks will not return the required result.\r\nFor example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn't sorted.\r\nExample 2:\r\n\r\nInput: arr = [2,1,3,4,4]\r\nOutput: 4\r\nExplanation:\r\nWe can split into two chunks, such as [2, 1], [3, 4, 4].\r\nHowever, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.\r\nNote:\r\n\r\narr will have length in range [1, 2000].\r\narr[i] will be an integer in range [0, 10**8].\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\n 创建另外一个数组， 把它排序\r\n\r\n之后就对比两个数据 如果两边的总和一样 他们的的块就能分裂然后排倒升序\r\n\r\n  ## 关键点\r\n\r\n   \r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        int result = 0;\r\n        int sumarr= 0;\r\n        int sumsorted = 0;\r\n        for(int i =0; i < arr.length; i ++){\r\n            \r\n            sumarr += arr[i];\r\n            sumsorted += sorted[i];\r\n                \r\n            if(sumarr == sumsorted)\r\n                result++;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760336","body":"## 61. Rotate List\r\n\r\n  https://leetcode.com/problems/rotate-list/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven the head of a linked list, rotate the list to the right by k places.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4,5], k = 2\r\nOutput: [4,5,1,2,3]\r\nExample 2:\r\n\r\n\r\nInput: head = [0,1,2], k = 4\r\nOutput: [2,0,1]\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the list is in the range [0, 500].\r\n-100 <= Node.val <= 100\r\n0 <= k <= 2 * 109\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\n 找出新的head。\r\n\r\n砍开两半\r\n\r\n新的head 接旧的head  注意旧的head 就终止node 不然会形成环\r\n\r\n  ## 关键点\r\n\r\n注意边界条件\r\n\r\nhead == null \r\n\r\nhead.next ==null\r\n\r\nK == 0\r\n\r\nK == list.length\r\n\r\n以上都是List 维持不变的\r\n\r\n如果K大于length  就等于K绕了一个圈  那个圈可以直接忽略 所以用 K % count\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null ) return head;\r\n        \r\n        ListNode countList = head;\r\n        int count = 0;\r\n        while(countList != null){\r\n            countList = countList.next;\r\n            count++;\r\n        }\r\n        \r\n        k %= count;\r\n        k = count - k;\r\n        //if(k == 0 || k == count) return head;\r\n        \r\n        ListNode current = head;\r\n        ListNode prev = null;\r\n        for(int i =0; i < k; i ++){\r\n            prev = current;\r\n            current = current.next;\r\n        }\r\n        ListNode rotatedhead = current;\r\n        prev.next = null;\r\n        \r\n        ListNode endofRotatedhead = rotatedhead;\r\n        while(endofRotatedhead != null){\r\n            prev = endofRotatedhead;\r\n            endofRotatedhead = endofRotatedhead.next;\r\n        }\r\n        prev.next = head;\r\n        \r\n        return rotatedhead;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841871661","body":"## 24. Swap Nodes in Pairs\r\n\r\n https://leetcode.com/problems/swap-nodes-in-pairs/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [1,2,3,4]\r\nOutput: [2,1,4,3]\r\nExample 2:\r\n\r\nInput: head = []\r\nOutput: []\r\nExample 3:\r\n\r\nInput: head = [1]\r\nOutput: [1]\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the list is in the range [0, 100].\r\n0 <= Node.val <= 100\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\nWrite a helper function that swap the current and the next node.\r\n\r\n\r\n\r\nThen in the main function, check if there are two nodes that can be swapped, if there is, call the helper function.\r\n\r\n\r\n\r\nmaintain the prev node can help connect the previous list with the swapped list.\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode current = dummy.next;\r\n        ListNode prev = dummy;\r\n        while(current != null && current.next !=null){\r\n            prev.next = swapPair(current);\r\n            prev = prev.next.next;;\r\n            current = prev.next;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n    \r\n    public ListNode swapPair(ListNode head){\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        \r\n        if(head != null && head.next != null){\r\n            ListNode next = head.next;\r\n            head.next = next.next;\r\n            next.next = head;\r\n            dummy.next = next;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842792315","body":"## 109. Convert Sorted List to Binary Search Tree\r\n\r\n https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [-10,-3,0,5,9]\r\nOutput: [0,-3,9,-10,null,5]\r\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\r\nExample 2:\r\n\r\nInput: head = []\r\nOutput: []\r\nExample 3:\r\n\r\nInput: head = [0]\r\nOutput: [0]\r\nExample 4:\r\n\r\nInput: head = [1,3]\r\nOutput: [3,1]\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in head is in the range [0, 2 * 104].\r\n-105 <= Node.val <= 105\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\nCharacteristic is BST is that it will store all the keys that are less than the node's key on the left.\r\n\r\nand keys that are greater than the node's key on the right.\r\n\r\n\r\n\r\nWhich means, the root of the tree will always be the midpoint value of any list.\r\n\r\nEverytime we build a TreeNode, we just need to make sure it is the middle key in a sorted list.\r\n\r\n\r\n\r\nListNode are harder to traverse because to runtime for get is O(n),\r\n\r\nwe can convert it into a list data structure that have is O(1) for get operation\r\n\r\nwhich makes it easier for build a BST.\r\n\r\n\r\n\r\nWhen we have target of using the midpoint for a new TreeNode, we can just use recursive a make sure we update the boundary accordingly\r\n\r\n\r\n\r\nOR\r\n\r\n\r\n\r\nWe can traverse with fast and slow pointer everytime to find out where the midpoint of the ListNode is. But we have to make sure we cut the List into two halves.\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> list = new ArrayList<>();\r\n        while(head != null){\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        \r\n        return sortedArrayToBST(0, list.size() - 1, list);\r\n    }\r\n    \r\n    private TreeNode sortedArrayToBST(int start, int end, List<Integer> list){\r\n        if(start > end) return null;\r\n        \r\n        int midpoint = (end-start)/2 + start;\r\n        TreeNode result = new TreeNode(list.get(midpoint));\r\n        \r\n        if(start == end) return result;\r\n        \r\n        result.left = sortedArrayToBST(start, midpoint-1, list);\r\n        result.right = sortedArrayToBST(midpoint+1, end, list);\r\n        \r\n        return result;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843713731","body":"## 160. Intersection of Two Linked Lists\r\n\r\nhttps://leetcode.com/problems/intersection-of-two-linked-lists/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\r\n\r\nFor example, the following two linked lists begin to intersect at node c1:\r\n\r\n\r\nIt is guaranteed that there are no cycles anywhere in the entire linked structure.\r\n\r\nNote that the linked lists must retain their original structure after the function returns.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\r\nOutput: Intersected at '8'\r\nExplanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\r\nExample 2:\r\n\r\n\r\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\nOutput: Intersected at '2'\r\nExplanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).\r\nFrom the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\r\nExample 3:\r\n\r\n\r\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\nOutput: No intersection\r\nExplanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\r\nExplanation: The two lists do not intersect, so return null.\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes of listA is in the m.\r\nThe number of nodes of listB is in the n.\r\n0 <= m, n <= 3 * 104\r\n1 <= Node.val <= 105\r\n0 <= skipA <= m\r\n0 <= skipB <= n\r\nintersectVal is 0 if listA and listB do not intersect.\r\nintersectVal == listA[skipA + 1] == listB[skipB + 1] if listA and listB intersect.\r\n \r\n\r\nFollow up: Could you write a solution that runs in O(n) time and use only O(1) memory?\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\nFind Duplicate, Set is a good data structure that can solve the problem\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        while(headA != null){\r\n            set.add(headA);\r\n            headA = headA.next;\r\n        }\r\n        \r\n        while(headB != null){\r\n            if(set.contains(headB)){\r\n                return headB;\r\n            }\r\n            set.add(headB);\r\n            headB = headB.next;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n      - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844621920","body":"## 142. Linked List Cycle II\r\n\r\nhttps://leetcode.com/problems/linked-list-cycle-ii/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven a linked list, return the node where the cycle begins. If there is no cycle, return null.\r\n\r\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to. Note that pos is not passed as a parameter.\r\n\r\nNotice that you should not modify the linked list.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: tail connects to node index 1\r\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\r\nExample 2:\r\n\r\n\r\nInput: head = [1,2], pos = 0\r\nOutput: tail connects to node index 0\r\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\r\nExample 3:\r\n\r\n\r\nInput: head = [1], pos = -1\r\nOutput: no cycle\r\nExplanation: There is no cycle in the linked list.\r\n \r\n\r\nConstraints:\r\n\r\nThe number of the nodes in the list is in the range [0, 104].\r\n-105 <= Node.val <= 105\r\npos is -1 or a valid index in the linked-list.\r\n \r\n\r\nFollow up: Can you solve it using O(1) (i.e. constant) memory?\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\nIf I can find duplicate means the list is a loop.\r\n\r\nFind Duplicate, Set is a good data structure that can solve the problem\r\n\r\n\r\n\r\n2nd idea is to use floyd algorithm\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        \r\n        while(head != null){\r\n            if(set.contains(head))\r\n                return head;\r\n            \r\n            set.add(head);\r\n            head = head.next;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n- 时间复杂度：$O(n)$\r\n  - 空间复杂度：$O(n)$\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode intersect = getIntersect(head);\r\n        \r\n        if(intersect == null)\r\n            return null;\r\n        while(head != intersect){\r\n            head = head.next;\r\n            intersect = intersect.next;\r\n        }\r\n        \r\n        return head;\r\n    }\r\n    \r\n    public ListNode getIntersect(ListNode head){\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            \r\n            if(fast == slow)\r\n                return fast;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n}\r\n - 时间复杂度：$O(n)$\r\n  - 空间复杂度：$O(1)$\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n     - 时间复杂度：$O(n)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845634838","body":"## 146. LRU Cache\r\n\r\nhttps://leetcode.com/problems/lru-cache/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nDesign a data structure that follows the constraints of a Least Recently Used (LRU) cache.\r\n\r\nImplement the LRUCache class:\r\n\r\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\r\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\r\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\r\nFollow up:\r\nCould you do get and put in O(1) time complexity?\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput\r\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\r\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\r\nOutput\r\n[null, null, null, 1, null, -1, null, -1, 3, 4]\r\n\r\nExplanation\r\nLRUCache lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // cache is {1=1}\r\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\r\nlRUCache.get(1);    // return 1\r\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\r\nlRUCache.get(2);    // returns -1 (not found)\r\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\r\nlRUCache.get(1);    // return -1 (not found)\r\nlRUCache.get(3);    // return 3\r\nlRUCache.get(4);    // return 4\r\n \r\n\r\nConstraints:\r\n\r\n1 <= capacity <= 3000\r\n0 <= key <= 3000\r\n0 <= value <= 104\r\nAt most 3 * 104 calls will be made to get and put.\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\n上网看 HashMap + LinkedList\r\n\r\n自己建一个LinkedList 去排序, 最常用到最少用\r\n\r\n然后HashMap 用来帮助快速找Key 还有LinkedList的位置\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\nclass LRUCache {\r\n    private Node head;\r\n    private Node tail;\r\n    int cache_capacity;\r\n    HashMap<Integer, Node> map;\r\n    \r\n    public LRUCache(int capacity) {\r\n        cache_capacity = capacity;\r\n        map = new HashMap<>();\r\n        head = new Node();\r\n        tail = new Node();\r\n        \r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        int result = -1;\r\n        if(map.containsKey(key)){\r\n            Node temp = map.get(key);\r\n            remove(temp);\r\n            add(temp);\r\n\r\n\t    result = temp.val;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)){\r\n            Node temp = map.get(key);\r\n            remove(temp);\r\n            temp.val = value;\r\n            add(temp);\r\n        }\r\n        else{\r\n            Node newNode = new Node(key,value);\r\n            \r\n            if(cache_capacity == map.size()){\r\n                map.remove(tail.prev.key); \r\n                remove(tail.prev);\r\n            }\r\n            \r\n            add(newNode);\r\n            map.put(key,newNode);\r\n        }\r\n    }\r\n    \r\n    private void add(Node node){\r\n        Node headnext = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n        node.next = headnext;\r\n        headnext.prev = node;\r\n    }\r\n    \r\n    private void remove(Node node){\r\n        Node nextnode = node.next;\r\n        Node prevnode = node.prev;\r\n        \r\n        nextnode.prev = prevnode;\r\n        prevnode.next = nextnode;\r\n    }\r\n    \r\n    class Node{\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        \r\n        Node(int key, int value){\r\n            this.key = key;\r\n            this.val = value;\r\n        }\r\n        \r\n        Node(){}\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n     - 时间复杂度：$O(1)$\r\n      - 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846345626","body":"## 104. Maximum Depth of Binary Tree\r\n\r\nhttps://leetcode.com/problems/maximum-depth-of-binary-tree/\r\n\r\n  ## 题目描述\r\n\r\n  ```\r\nGiven the root of a binary tree, return its maximum depth.\r\n\r\nA binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,9,20,null,null,15,7]\r\nOutput: 3\r\nExample 2:\r\n\r\nInput: root = [1,null,2]\r\nOutput: 2\r\nExample 3:\r\n\r\nInput: root = []\r\nOutput: 0\r\nExample 4:\r\n\r\nInput: root = [0]\r\nOutput: 1\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in the tree is in the range [0, 104].\r\n-100 <= Node.val <= 100\r\n  ```\r\n\r\n  ## 前置知识\r\n\r\n   - \r\n\r\n  ## 公司\r\n\r\n   - 暂无\r\n\r\n  ## 思路\r\n\r\nBFS iterate by each level to find the last level\r\n\r\n  ## 关键点\r\n\r\n\r\n\r\n  ## 代码\r\n\r\n   - 语言支持：Java\r\n\r\n   Java Code:\r\n\r\n  ```Java\r\niteration\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        int level = 0;\r\n        Queue<TreeNode> q = new LinkedList();\r\n        q.add(root);\r\n        \r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            for(int i =0; i < size; i ++){\r\n                TreeNode temp = q.poll();\r\n                \r\n                if(temp.left != null)\r\n                    q.add(temp.left);\r\n                if(temp.right != null)\r\n                    q.add(temp.right);\r\n            }\r\n            level++;\r\n        }\r\n        \r\n        return level;\r\n    }\r\n}\r\n\r\nRecursion\r\n    /**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        \r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n  ```\r\n\r\n\r\n      **复杂度分析**\r\n    \r\n      令 n 为数组长度。\r\n    \r\n     - 时间复杂度：$O(n)$\r\n     - 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846457764","body":"## 100. Same Tree\r\n\r\nhttps://leetcode.com/problems/same-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n100. Same Tree\r\nEasy\r\n\r\n3298\r\n\r\n88\r\n\r\nAdd to List\r\n\r\nShare\r\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\r\n\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: p = [1,2,3], q = [1,2,3]\r\nOutput: true\r\nExample 2:\r\n\r\n\r\nInput: p = [1,2], q = [1,null,2]\r\nOutput: false\r\nExample 3:\r\n\r\n\r\nInput: p = [1,2,1], q = [1,1,2]\r\nOutput: false\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in both trees is in the range [0, 100].\r\n-104 <= Node.val <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\nRecursion to compare the tree node by node\r\n\r\n## 关键点\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```\r\nRecursion\r\n\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null)\r\n             return true;\r\n        else if(p == null || q == null)\r\n            return false;\r\n        else if(p.val != q.val)\r\n            return false;\r\n        else{\r\n            return isSameTree(p.left,q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nBFS\r\n  **复杂度分析**\r\n\r\n  令 n 为数组长度。\r\n\r\n - 时间复杂度：$O(1)$\r\n - 空间复杂度：$O(n)$\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836115382","body":"### **题目地址(989. 数组形式的整数加法)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 数组转数字\r\n1. 数字相加\r\n2. 数字转数组\r\n```\r\n\r\n### **代码**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = 0\r\n        for i in num:\r\n            tmp = tmp * 10 + i   # 数组转数字\r\n        tmp += k      # 加法运算\r\n        result = []\r\n        for j in str(tmp):    # 数字转数组\r\n            result.append(int(j))\r\n        \r\n        return result\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838285144","body":"### **题目地址(821. 字符的最短距离)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察数组的遍历(正向遍历和反向遍历)\r\n我的思路\r\n1. 对于字符串s的每一个字符，如果该字符等于c，输出0，进行下一个循环\r\n2. 对于字符串s的每一个字符，如果该字符不等于c，往前往后分别查找c,\r\n\t- 一方找不到c，输出另一方距离\r\n\t- 都找得到c，记录两个距离\r\n3. 输出两个距离中的最小值\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        slength = len(s)\r\n        res = []\r\n        for i in range(slength):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                continue\r\n            j = i\r\n            k = i\r\n            while(s[j] != c):\r\n                j -= 1\r\n                if j < 0:\r\n                    break  \r\n                \r\n            while(s[k] != c):\r\n                k += 1\r\n                if k >= slength:\r\n                    break\r\n                    \r\n            la = i-j    \r\n            lb = k-i    \r\n            if j < 0: \r\n                res.append(lb)\r\n            elif k >= slength:\r\n                res.append(la) \r\n            else:\r\n                res.append(min(la, lb))\r\n        return res\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n·k)，n是字符串的长度，k是查找到字符c的长度\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839440151","body":"### **题目地址(1381. 设计一个支持增量操作的栈)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1); // 栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.push(3); // 栈变为 [1, 2, 3]\r\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、类、前缀和\r\n1. push \r\n   栈到达最大值时不能再append \r\n   if 列表长度 < 最大长度\r\n   \t\tappend\r\n2. pop\r\n   else：栈为空即栈长度为0 return 0；if 列表长度 > 0: 栈顶 = pop(-1)\r\n3. increment\r\n   if 取值 > 列表长度：\r\n   \t  取值 = 列表长度\r\n4. 解法一：以时间换空间 常规解法\r\n遍历列表k个数，都加val\r\n5. 解法二：以空间换时间 辅助列表解法\r\n创建一个辅助栈，主栈append的同时辅助栈append(0)，increment时在第k个元素保存val，在pop的时候主栈和辅助栈末尾元素相加输出，然后辅助栈末尾元素向前传递，加给pop后的辅助栈末尾元素\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\n解法一：以时间换空间 常规解法\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            top = self.stack.pop(-1)\r\n            return top\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n\r\n解法二：以空间换时间 辅助列表解法\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.add_stack = []  \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n            self.add_stack.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            top = self.stack.pop(-1)\r\n            add_top = self.add_stack.pop(-1)\r\n            if len(self.add_stack) > 0:\r\n                self.add_stack[-1] += add_top\r\n            res = top + add_top\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n        if len(self.add_stack) > 0:\r\n            self.add_stack[k-1] += val\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n解法一\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(1)\r\n解法二\r\n0. 时间复杂度：O(1)\r\n1. 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840394919","body":"### **题目地址(394. 字符串解码)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、括号匹配显然是一种栈问题\r\n1. 遍历字符串：\r\n\t若不是']': 入栈\r\n\t若是']': 创建两个字符串分别记录括号内字符串和括号前数字\r\n\t\t\t若栈末尾不是'['就循环:出栈，记录出栈的字符\r\n\t\t\t弹出'[' 找出了匹配的'['并在栈中消除了该'[', 未干扰后面的']'\r\n\t\t\t若栈末尾是数字且栈不为空就循环:出栈，记录出栈的数字\r\n\t\t\t入栈:数×括号内字符串\r\n\t栈列表转字符串\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                saveStr = ''\r\n                saveNum = ''\r\n                while stack[-1] != '[':\r\n                    saveStr = stack.pop() + saveStr\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    saveNum = stack.pop() + saveNum \r\n                stack.append(int(saveNum) * saveStr)\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n²)\r\n1. 空间复杂度：O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840969872","body":"### **题目地址(232. 用栈实现队列)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n使用栈实现队列的下列操作：\r\n\r\npush(x) -- 将一个元素放入队列的尾部。\r\npop() -- 从队列首部移除元素。\r\npeek() -- 返回队列首部的元素。\r\nempty() -- 返回队列是否为空。\r\n示例:\r\n\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);\r\nqueue.peek(); // 返回 1\r\nqueue.pop(); // 返回 1\r\nqueue.empty(); // 返回 false\r\n说明:\r\n\r\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n假设所有操作都是有效的、 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、入栈、出栈、用栈模拟队列\r\n1. 解法一：用pop(0)直接弹出第一个数  \r\n2. 解法二：辅助栈\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        first_pop = self.queue.pop(0)\r\n        return first_pop\r\n\r\n    def peek(self) -> int:\r\n        first = self.queue[0]\r\n        return first\r\n\r\n    def empty(self) -> bool: \r\n        return self.queue == []\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(1)\r\n1. 空间复杂度：O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841592514","body":"### **题目地址(768. 最多能完成排序的块)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\r\n示例 2:\r\n\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n\r\n\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 考察栈、单调栈、栈内元素单调增加\r\n1. 前面数字比后面数字小且更前面没更大的，这两个必然是两块，分开\r\n   更前面有更大的，着该数与那个更大的数必然一块\r\n   stack里面放的是各个块的最大值\r\n2. 创建一个栈，遍历原数组\r\n\r\n   若栈为空，当前最大值是0\r\n   若栈不为空，当前最大值是栈最后一个数\r\n   \r\n   若元素大于当前最大值，入栈\r\n   若元素小于当前最大值，循环出栈直到栈为空或者元素大于栈尾，将当前最大值入栈\r\n   返回栈长度，也就是各个块最大值数，也就是块数\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i in arr:\r\n            if stack:\r\n                max = stack[-1]\r\n            else:\r\n                max = 0\r\n            if i < max:\r\n                while stack and i < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(max)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(n)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841752893","body":"### **题目地址( 61. 旋转链表)**\r\n\r\n```\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n```\r\n\r\n### **题目描述**\r\n\r\n```\r\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\r\n\r\n示例 1:\r\n\r\n输入: 1->2->3->4->5->NULL, k = 2\r\n输出: 4->5->1->2->3->NULL\r\n解释:\r\n向右旋转 1 步: 5->1->2->3->4->NULL\r\n向右旋转 2 步: 4->5->1->2->3->NULL\r\n示例 2:\r\n\r\n输入: 0->1->2->NULL, k = 4\r\n输出: 2->0->1->NULL\r\n解释:\r\n向右旋转 1 步: 2->0->1->NULL\r\n向右旋转 2 步: 1->2->0->NULL\r\n向右旋转 3 步: 0->1->2->NULL\r\n向右旋转 4 步: 2->0->1->NULL\r\n```\r\n\r\n### **编程语言**\r\n\r\n```\r\npython3\r\n```\r\n\r\n### **思路**\r\n\r\n```\r\n0. 链表  不太会，链表知识待补课\r\n1. 如果head is None，返回head\r\n2. 将链表首位相接变为循环链表并得到链表长度\r\n3. 从原head位开始寻找新head（if index == length-k）\r\n4. 如果当前位的下一位是新头部，储存新head，并切断当前node与node.next（新head）之间的link。返回新head\r\n```\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n\r\n        # if head is null, return head\r\n        if not head:\r\n            return head\r\n        \r\n        # Get length and connect the last and head to change NodeList to a circular NodeList \r\n        length = 1\r\n        newNode = head\r\n        while(newNode.next):\r\n            newNode = newNode.next\r\n            length += 1\r\n        newNode.next = head\r\n\r\n        # get real cut index\r\n        k = k % length\r\n\r\n       # find new head\r\n        index = 0\r\n        returnNode = None\r\n        while(True):\r\n            if index == length-k:\r\n                returnNode = newNode.next\r\n                newNode.next = None\r\n                return returnNode\r\n            index += 1\r\n            newNode = newNode.next \r\n```\r\n\r\n### **复杂度分析**\r\n\r\n```\r\n0. 时间复杂度：O(n)\r\n1. 空间复杂度：O(1)\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843991503","body":"代码\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_set = set()\r\n        \r\n        while headA:\r\n            node_set.add(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_set:\r\n                \r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N+M)，其中 N，M为两个链表的长度。\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844710161","body":"思路\r\n哈希表\r\n\r\n代码\r\npython\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        set_node = set()\r\n        while head:\r\n            if head in set_node:\r\n                return head\r\n            if head.next is None:\r\n                return None\r\n            set_node.add(head)\r\n            head = head.next\r\n复杂度\r\n时间: O(n)\r\n空间: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845837865","body":"思路\r\n参考题解\r\n双向链表， 哈希表\r\nget过的node在最前面，超出capacity移除尾端node与hashtable中此node\r\nhelp functions:\r\nappend到head\r\n删除当前节点\r\n删除尾部节点并返回key\r\nclass Node:\r\n    def __init__(self, k, v):\r\n        self.key = k\r\n        self.val = v\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0 # current size\r\n        self.head = Node(0, 0)\r\n        self.tail = Node(0, 0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.data = {} # dictionary as hashtable\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        # if key exists, move the node to head of the ListNode\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.remove(node)\r\n            self.append(node)\r\n            return node.val\r\n        else:\r\n            return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        # if key exists, update the value and move the node to head of the ListNode\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            node.val = value\r\n            self.remove(node)\r\n            self.append(node)\r\n        # if does not exist:\r\n        #   1. add node to hashtable\r\n        #   2. check  capacity\r\n        #   3. if full, remove the tail node\r\n        #   4. add node to the head of the ListNode\r\n        else:\r\n            node = Node(key, value)\r\n            self.data[key] = node\r\n            if self.size < self.capacity:\r\n                self.size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n            self.append(node)   \r\n\r\n    # connect the previous node and next node of the pass-in node\r\n    def remove(self, node: Node) -> None:\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    # append to the head of the ListNode\r\n    def append(self, node: Node) -> None:\r\n        first = self.head.next\r\n        self.head.next = node\r\n        node.prev = self.head\r\n        node.next = first\r\n        first.prev = node\r\n\r\n    # remove the tail node of the ListNode\r\n    def removeTail(self) -> int:\r\n        key = self.tail.prev.key\r\n        self.remove(self.tail.prev)\r\n        return key\r\n复杂度\r\nTime：O(1)\r\nSpace：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846324990","body":"思路：recursion\r\n\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n    \r\n        leftDepth = self.maxDepth(root.left)\r\n        rightDepth = self.maxDepth(root.right)\r\n        \r\n        return max(leftDepth,rightDepth) + 1\r\n复杂度：\r\nO(N)：number of nodes\r\nO(height)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846501253","body":"思路：\r\n递归\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p == None and q == None:\r\n            return True\r\n        elif p != None and q != None:\r\n            if p.val == q.val:\r\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n        return False\r\n复杂度\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LexieLiu01":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836117591","body":"`\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n        A[i], carry = (carry + A[i] + K % 10) % 10, (carry + A[i] + K % 10) // 10\r\n        K //= 10\r\n        B = []\r\n        carry = carry + K\r\n        while carry:\r\n        B = [(carry) % 10] + B\r\n        carry //= 10\r\n    return B + A\r\n\r\n`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838334269","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r = i\r\n            \r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            \r\n            if l == -1:\r\n                l = -10000\r\n            if r == len(s):\r\n                r = 20000\r\n            ans.append(min(r-i,i-l))\r\n            \r\n        return ans"},null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846517315","body":"class Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        \r\n        if not q or not p:\r\n            return False\r\n        \r\n        if p.val != q.val:\r\n            return False\r\n        \r\n        return self.isSameTree(p.right,q.right) and self.isSameTree(p.left, q.left)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HackBL":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836118591","body":"* 思路：Array从后往前遍历，每遍历一次，加上k，取总和的个位数，存入到list中。k /= 10，为下一个元素做准备。 遍历整个数组，如果k还存在数字（即 != 0)，继续遍历k，一一存入到list中\r\n* 误区：最开始使用int，把数组和k的数字相加在一起，导致integer overflow\r\n* 语言：Java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new LinkedList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            k += num[i];\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        while (k != 0) {\r\n            list.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n* 时间：O(n), n: max(nums.length, k的长度)\r\n* Space: O(n), n: max(nums.length, k的长度)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837785007","body":"* 思路：先正序，再倒序\r\n正序：所有在s中的元素（除了c元素），以其左边的c为参照物，求出距离，并存在answer中。若元素的左边没有参照物c，则存入string.length()与当前index的差值。\r\n倒序：所有在s中的元素（除了c元素），以其右边的c为参照物，求出最小距离（min(answer[o], pos-1)），并存在answer中。\r\n若当前元素为c，answer当前index的元素为0\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int pos = -n;\r\n        int[] answer = new int[n];\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = i - pos;\r\n        }\r\n        \r\n        for (int i = pos; i >= 0; i--) {\r\n            if (s.charAt(i) == c) pos = i;\r\n            answer[i] = Math.min(answer[i], pos - i);\r\n        }\r\n        \r\n        return answer;\r\n    }\r\n}\r\n```\r\n* 时间：O(n)， n为s的长度\r\n* 空间：O(n)， 建立新数组answer，长度为n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839428969","body":"* 思路：第一想法，用ArrayList存储所有数据\r\n```\r\nclass CustomStack {\r\n    List<Integer> stack = new ArrayList();\r\n    int maxSize;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() == maxSize) return;\r\n        stack.add(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.isEmpty()) return -1;\r\n        int val = stack.remove(stack.size()-1);\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k; i++) {\r\n            if (i >= stack.size()) break;\r\n            stack.set(i, stack.get(i) + val);\r\n            \r\n        }\r\n    }\r\n}\r\n```\r\n* 时间： Push: O(1), Pop: O(1), increment: O(n)\r\n* 空间: O(n)\r\n"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844619999","body":"```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n       ListNode fast = head;\r\n       ListNode slow = head;\r\n       if (head == null){\r\n           return null;\r\n       }\r\n    \r\n       while(fast != null){\r\n           slow = slow.next;\r\n           if(fast.next != null){\r\n               fast = fast.next.next;\r\n           } else {\r\n               return null;\r\n           }\r\n           \r\n           if (slow == fast){\r\n               ListNode temp = head;\r\n               while(slow != temp){\r\n                   temp = temp.next;\r\n                   slow = slow.next;\r\n               }\r\n               return temp;\r\n           }\r\n       }\r\n       return null;       \r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixi-jiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836121004","body":"### 思路\r\n\r\n利用 加一 那道题的思路 从个位加起\r\n最后还要处理 k 大于 0 的情况\r\n例如：num = [0];k = 23 \r\n\r\n不明白为什么耗时很多 200+ms\r\n### 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    let res = [];\r\n    for (let i = len - 1;i >= 0;i--) {\r\n        let sum = num[i] + (k % 10);\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n            res.unshift(sum);\r\n        } else {\r\n            res.unshift(sum);\r\n        }\r\n    }\r\n    while (k > 0) {\r\n        res.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837644356","body":"/* 思路\r\n- 遍历字符串\r\n- 从每个字符的左边和右边分别开始寻找目标字符\r\n- 如果找到了, 结束遍历\r\n- 如果没有找到, 给下标赋值无穷大\r\n- 选择较近的距离即可\r\n*/ \r\n// 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let res = [];\r\n    for (let i = 0;i < s.length;i++) {\r\n        let left = i, right = i;\r\n        while (left >= 0) {\r\n            if (s[left] === c) {\r\n                break;\r\n            }\r\n            left--;\r\n        }\r\n        while (right < s.length) {\r\n            if (s[right] === c) {\r\n                break;\r\n            }\r\n            right++;\r\n        }\r\n        // 如果没有找到\r\n        if (left === -1) left = -Infinity;\r\n        if (right === s.length) right = Infinity;\r\n        // 选择较近的距离\r\n        res[i] = Math.min((i - left), (right - i));\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(N ^ 2)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839377460","body":"/* 思路\r\n- js 中本身就有栈这种结构因此比较简单\r\n*/ \r\n// 代码\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = [];\r\n    this.len = maxSize;\r\n};\r\n\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.arr.length < this.len) {\r\n        this.arr.push(x);\r\n    }\r\n};\r\n\r\nCustomStack.prototype.pop = function() {\r\n    if (this.arr.length === 0) {\r\n        return -1;\r\n    } else {\r\n        return this.arr.pop();\r\n    }\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (k < this.arr.length) {\r\n        for (let i = 0;i < k;i++) {\r\n            this.arr[i] += val;\r\n        } \r\n    } else {\r\n        for (let i = 0;i <  this.arr.length;i++) {\r\n            this.arr[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840222483","body":"/* 思路\r\n- 用两个栈, 一个是存倍数的栈, 一个是存待拼接的字符串的栈\r\n- num 用来表示临时倍数\r\n- result 用来表示结果字符串\r\n- 如果碰到数字 -> 计算出倍数 -> 注意如果是连续多个数字, 要处理倍数\r\n- 如果碰到 '[' -> result 入栈(保存之前的) 并清零, num 入栈并清零\r\n- 把之前的 result 和 num 入栈, 开始寻找新的\r\n- 如果碰到 ']' -> 两个栈的栈顶元素出栈并计算\r\n- 之前的 + 现在的\r\n*/ \r\n// 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0;\r\n    let result = \"\";\r\n    for (const char of s) {\r\n        if (!isNaN(char)) {\r\n            num = num * 10 + Number(char);\r\n        } else if (char === '[') {\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(result);\r\n            result = \"\";\r\n        } else if (char === ']') {\r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += char;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840995386","body":"/* 思路\r\n- 用两个栈，关键是 push 操作时要使用到辅助栈\r\n*/ \r\n// 代码\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.stackHelper = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    while (this.stack.length) {\r\n        this.stackHelper.push(this.stack.pop());\r\n    }\r\n    this.stack.push(x);\r\n    while (this.stackHelper.length) {\r\n        this.stack.push(this.stackHelper.pop());\r\n    }\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683491","body":"/* 思路\r\n- 单调栈思路, 转化为单调递增的栈\r\n- 将递减的元素合并, 例如 2, 1 合并为 2, 相当于是一个标杆\r\n- 递增的元素进栈, 维持单调栈\r\n- 例如: 0 2 1\r\n- 则 1 先与 2 合并, 然后还要判断 1 和 0 的大小关系, 如果 1 > 0 说明还要进行合并\r\n- 因为相当于是一个块, 所以要将 0 进行出栈, 类推\r\n- 最后返回的栈的长度就是最多的块数\r\n*/ \r\n// 代码\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [];\r\n    for (let i = 0;i < arr.length;i++) {\r\n        const num = arr[i];\r\n        if (stack.length > 0 && num < stack[stack.length - 1]) {\r\n            const cur = stack[stack.length - 1];\r\n            while (stack.length > 0 && num < stack[stack.length - 1]) {\r\n                stack.pop();\r\n            }\r\n            stack.push(cur);\r\n        } else {\r\n            stack.push(arr[i]);\r\n        }\r\n    }\r\n    return stack.length;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841820586","body":"/* 思路\r\n- 利用递归\r\n- 不断找出倒数第一和倒数第二的结点, 进行处理\r\n- 注意 k = k % len 防止栈溢出\r\n*/ \r\n// 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (head === null) return null;\r\n    if (head.next === null) return head;\r\n    let temp = head;\r\n    let len = 0;\r\n    while (temp) {\r\n        len++;\r\n        temp = temp.next;\r\n    }\r\n    k = k % len;\r\n    return recursion(head, k);\r\n};\r\nconst recursion = function (head, k) {\r\n    if (k <= 0) return head;\r\n    let cur = head;\r\n    let prev = null;\r\n    while (cur && cur.next) {\r\n        prev = cur;\r\n        cur = cur.next;\r\n    }\r\n    cur.next = head;\r\n    prev.next = null;\r\n    return recursion(cur, k - 1);\r\n}\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n ^ 2)，其中 n 为数组长度。\r\n- 空间复杂度：O(n)\r\n*/\r\n/* 思路\r\n- 上面这个算法的时间复杂度是 O (n ^ 2)\r\n- 因为每次都要找到链表的倒数第一和倒数第二个结点\r\n- 这个过程肯定是可以加速的\r\n- 转变思想为寻找倒数 k 个结点和倒数第 k + 1 个结点\r\n- head = [1,2,3,4,5], k = 2 -> [4,5,1,2,3]\r\n- 倒数第 k 个结点变为第一个结点\r\n- 倒数第 k + 1 个结点变为最后一个结点\r\n- 原链表的最后一个结点也要处理\r\n*/ \r\n// 代码\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) return head;\r\n    let temp = head;\r\n    let len = 0;\r\n    while (temp) {\r\n        len++;\r\n        temp = temp.next;\r\n    }\r\n    k = k % len;\r\n    let slow = head;\r\n    let fast = head;\r\n    while (fast.next) {\r\n        fast = fast.next;\r\n        if (k <= 0) {\r\n            slow = slow.next;\r\n        }\r\n        k--;\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841910069","body":"/* 思路\r\n- 获取第一个, 第二个, 第三个结点\r\n- 递归进行交换\r\n*/ \r\n// 代码\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let one = head;\r\n    let two = head.next;\r\n    let three = two.next;\r\n    one.next = swapPairs(three);\r\n    two.next = one;\r\n    return two;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n*/\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842755243","body":"/* 思路\r\n- 二叉搜索树的任意一个节点\r\n- 当前节点的值必然大于所有左子树节点的值。\r\n- 同理,当前节点的值必然小于所有右子树节点的值\r\n- 获取链表的中点 \r\n- 通过快慢指针, 快指针一次走两步, 慢指针一次走一步\r\n- 当快指针走到尾部时, 慢指针到达终点\r\n- 以链表中点为根\r\n- 中点左边的值都小于它, 中点右边的值都大于它\r\n- 中点左边可以构造左子树, 中点右边可以构造右子树\r\n- 在左边继续找中点, 在右边继续找中点\r\n*/ \r\n// 代码\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return run(head, null);\r\n};\r\nfunction run(head, tail) {\r\n  if (head === tail) return null;\r\n  let slow = head;\r\n  let fast = head;\r\n  while (fast !== tail && fast.next !== tail) {\r\n      slow = slow.next;\r\n      fast = fast.next.next;\r\n  }\r\n  let root = new TreeNode(slow.val);\r\n  root.left = run(head, slow);\r\n  root.right = run(slow.next, tail);\r\n  console.log(root);\r\n  return root;\r\n}\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n * log n)\r\n- 空间复杂度：O(1)\r\n*/\r\n/* 思路\r\n- 因为链表访问中点的时间复杂度是 O(n)\r\n- 所以可以空间换时间, 即用数组将链表的值存储\r\n*/ \r\n// 代码\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    if (!head) return null;\r\n    let res = [];\r\n    let temp = head;\r\n    while (temp) {\r\n        res.push(temp.val);\r\n        temp = temp.next;\r\n    }\r\n    return run(res);\r\n};\r\nfunction run(res) {\r\n    if (res.length === 0) {\r\n        return;\r\n    }\r\n    let mid = Math.floor(res.length / 2);\r\n    let root = new TreeNode(res[mid]);\r\n    root.left = mid > 0 ? run(res.slice(0, mid)) : null;\r\n    root.right = mid < res.length - 1 ? run(res.slice(mid + 1)) : null;\r\n    return root;\r\n}\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844101954","body":"/* 思路\r\n- 先遍历 A 链表, 保存在 Set 中\r\n- 再遍历 B 链表, 看是否在 Set 中存在, 存在直接返回\r\n*/ \r\n// 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let set = new Set();\r\n    while (headA) {\r\n        set.add(headA);\r\n        headA = headA.next;\r\n    }\r\n    while (headB) {\r\n        if (set.has(headB)) {\r\n            return headB;\r\n        }\r\n        headB = headB.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n*/\r\n\r\n/* 思路\r\n- 双指针\r\n- 指针 a 和 b 以相同的速度向后移动\r\n- 当 a 移动到 A 链表的尾部时, 指向 B 链表的头结点\r\n- 当 b 移动到 B 链表的尾部时, 指向 A 链表的头结点\r\n- 当 a === b 时, 找到交叉点, 否则返回 null\r\n- 因为当 a === b 时, a 和 b 走的路程一样多, 所以是交叉点\r\n*/ \r\n// 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA;\r\n    let b = headB;\r\n    while (a !== b) {\r\n        a = a === null ? headB : a.next;\r\n        b = b === null ? headA : b.next;\r\n    }\r\n    return a;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844596754","body":"/* 思路\r\n- 哈希表法\r\n- 遍历链表, 如果链表元素不存在于哈希表中, 则添加, 继续遍历\r\n- 否则, 发现环, 返回当前链表元素\r\n*/ \r\n// 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let set = new Set();\r\n    while (headA) {\r\n        set.add(headA);\r\n        headA = headA.next;\r\n    }\r\n    while (headB) {\r\n        if (set.has(headB)) {\r\n            return headB;\r\n        }\r\n        headB = headB.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n*/\r\n\r\n/* 思路\r\n- 快指针一次走两步, 慢指针一次走一步\r\n- 当快慢指针第一次相遇时, 快指针回到头结点, 然后一次走一步\r\n- 当快慢指针第二次相遇时, 即为环的入口\r\n*/ \r\n// 代码\r\n```js\r\nvar detectCycle = function(head) {\r\n    if (!head || !head.next) return null;\r\n    let slow = head;\r\n    let fast = head;\r\n    do {\r\n        if (fast && fast.next) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            fast = null;\r\n        }\r\n        slow = slow.next;\r\n    } while (slow !== fast);\r\n    if (fast === null) {\r\n        return null;\r\n    }\r\n    fast = head;\r\n    while (slow !== fast) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    return slow;\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n*/\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845696903","body":"/* 思路\r\n- 双向链表 + 哈希表 \r\n- get方法根据关键字 key 获取缓存的 value 的值\r\n- 先判断哈希表中是否存在 key \r\n- 如果存在, 就要移除双向链表中的该结点, 然后追加该结点到双向链表头部\r\n- 返回该结点的值\r\n- 如果不存在, 返回 -1\r\n- put方法, 先判断哈希表中是否存在 key\r\n- 如果存在, 移除双向链表中的该结点, 再将该结点追加到双向链表的头部\r\n- 如果不存在, 先判断此时双向链表长度是否超过最大容量\r\n- 如果超过, 将双向链表中的尾部结点移除, 追加新结点到双向链表的头部\r\n- 并且在哈希表中删除旧结点\r\n- 如果没超过, 追加新结点到双向链表的头部, 双向链表长度 size++\r\n\r\n*/ \r\n// 代码\r\n```js\r\nfunction ListNode(key, val) {\r\n    this.key = key;\r\n    this.val = val;\r\n    this.pre = this.next = null;\r\n}\r\n\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.size = 0;\r\n    this.data = {};\r\n    this.head = new ListNode();\r\n    this.tail = new ListNode();\r\n    this.head.next = this.tail;\r\n    this.tail.pre = this.head;\r\n};\r\n\r\nLRUCache.prototype.get = function(key) {\r\n    if (this.data[key] !== undefined) {\r\n        let node = this.data[key];\r\n        this.removeNode(node);\r\n        this.appendHead(node);\r\n        return node.val;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\nLRUCache.prototype.put = function(key, value) {\r\n    let node = new ListNode(key, value);\r\n    if (this.data[key] !== undefined) {\r\n        node = this.data[key];\r\n        this.removeNode(node);\r\n        node.val = value;\r\n    } else {\r\n        this.data[key] = node;\r\n        if (this.size < this.capacity) {\r\n            this.size++;\r\n        } else {\r\n            key = this.removeTail();\r\n            delete this.data[key];\r\n        }\r\n    }\r\n    this.appendHead(node);\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node) {\r\n    let preNode = node.pre;\r\n    let nextNode = node.next;\r\n    preNode.next = node.next;\r\n    nextNode.pre = preNode;\r\n}\r\n\r\nLRUCache.prototype.appendHead =  function(node) {\r\n    let firstNode = this.head.next;\r\n    this.head.next = node;\r\n    node.pre = this.head;\r\n    node.next = firstNode;\r\n    firstNode.pre = node;\r\n}\r\n\r\nLRUCache.prototype.removeTail = function() {\r\n    let key = this.tail.pre.key;\r\n    this.removeNode(this.tail.pre);\r\n    return key;\r\n}\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)\r\n*/\r\n\r\n/* 思路\r\n- Map 实现\r\n*/ \r\n// 代码\r\n```js\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.map.get(key);\r\n    if (value !== undefined) {\r\n        this.map.delete(key);\r\n        this.map.set(key, value);\r\n        return value;\r\n    } else {\r\n        return -1;\r\n    }\r\n};\r\n\r\nLRUCache.prototype.put = function(key, value) {\r\n    if (this.map.has(key)) {\r\n        this.map.delete(key);\r\n    }\r\n    if (this.map.size >= this.capacity) {\r\n        this.map.delete(this.map.entries().next().value[0]);\r\n    } \r\n    this.map.set(key, value);\r\n};\r\n```\r\n\r\n/* 复杂度分析\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)\r\n*/"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846324152","body":"## 二叉树的最大深度\r\n### 思路\r\n- 树的题目很适合用来递归来做\r\n- 基本上和树的搜索有关的，都可以用递归来做\r\n- 因为树是一种递归的数据结构 , 而穷举搜索一棵树必然需要遍历其所有节点 , 而搜索的逻辑对所有的子树都是一样的 , 因此这就很适合用递归来解决了\r\n- 写递归的方法 : 产品经理法\r\n  - 定义函数功能，不用管其具体实现\r\n    - 我需要的功能是给定一个二叉树的节点 , 返回以这个节点为根节点的子树的最大深度 , 假设这个函数为 f , 那么问题转化为 f(root)\r\n  - 确定大问题和小问题的关系\r\n    - 要解决 f(root) 这个问题。可以先解决 f(root.right) 和 f(root.left)\r\n    - 1 + max(f(root.right) , f(root.left))\r\n  - 补充递归终止条件\r\n    - 如果递归到叶子节点的时候 , 返回 0 即可\r\n  \r\n```js\r\nvar maxDepth = function(root) {\r\n    if (!root) return 0;\r\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(n) , n 为节点数\r\n- 空间复杂度：O(h) , h 为树的深度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Daniel-Zheng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836131939","body":"### 思路\r\n\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int length = num.size();\r\n        int current = k;\r\n        \r\n        while (--length >=0 || current > 0) {\r\n            if (length >= 0) current += num[length];\r\n            res.push_back(current % 10);\r\n            current /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(), res.end());\r\n        return res; \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837622983","body":"### 思路\r\n\r\n正反遍历\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size());\r\n        int current = 99999;\r\n        \r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) current = i;\r\n            res[i] = abs(i - current);\r\n        }\r\n        \r\n        current = 99999;\r\n        for (int j = s.size() - 1; j >= 0; j--) {\r\n            if (s[j] == c) current = j;\r\n            res[j] = min(abs(j - current), res[j]);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839502679","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    int array[1000];\r\n    int count = 0;\r\n    int size = 0;\r\n    \r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (count < size) array[count++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (count > 0) {\r\n            return array[--count];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, count); i++) {\r\n            array[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840348543","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> numberCount;\r\n        stack<string> tempString;\r\n        int index = 0;\r\n        string result = \"\";\r\n        string temp = \"\";\r\n        \r\n        while (index < s.length()) { \r\n            if (isdigit(s[index])) {\r\n                int numberIndex = 0;\r\n                while (isdigit(s[index])) {\r\n                    numberIndex = numberIndex * 10 + s[index] - '0';\r\n                    index++;\r\n                }\r\n                numberCount.push(numberIndex);\r\n            }\r\n            else if (s[index] == '[') {\r\n                tempString.push(result);\r\n                result = \"\";\r\n                index++;\r\n            }\r\n            else if (s[index] == ']') {\r\n                int number = numberCount.top();\r\n                numberCount.pop();\r\n                temp = tempString.top();\r\n                tempString.pop();\r\n                for (int i = 0; i < number; i++) {\r\n                    temp += result;\r\n                }\r\n                result = temp;\r\n                index++;\r\n            }\r\n            else {\r\n                result += s[index];\r\n                index++;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841014898","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n        \r\n    }\r\n    \r\n    stack<int> res;\r\n    stack<int> help;\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        while (res.size() != 0) {\r\n            help.push(res.top());\r\n            res.pop();\r\n        }\r\n        res.push(x);\r\n        while (help.size() != 0) {\r\n            res.push(help.top());\r\n            help.pop();\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int firstElement = res.top();\r\n        res.pop();\r\n        return firstElement;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        return res.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        if (res.size() == 0) return true;\r\n        return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841522817","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> res;\r\n        for (int i = 0; i< arr.size(); i++) {\r\n            if (!res.empty() && arr[i] < res.top()) {\r\n                int curMax = res.top();\r\n                while (!res.empty() && arr[i] < res.top()) res.pop();\r\n                res.push(curMax);\r\n            } else {\r\n                res.push(arr[i]);\r\n            }\r\n        }\r\n        return res.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841778706","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        int len = 1;\r\n        ListNode* temp = head;\r\n        if (k == 0 || head == nullptr || head -> next == nullptr) return head;\r\n        while (temp -> next != nullptr) {\r\n            temp = temp -> next;\r\n            len++;\r\n        }\r\n        int move = len - k % len;\r\n        if (move == len) return head;\r\n        temp -> next = head;\r\n        while (move--) temp = temp -> next;\r\n        ListNode* res = temp -> next;\r\n        temp -> next = nullptr;\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842037335","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummyHead = new ListNode(0);\r\n        dummyHead->next = head;\r\n        ListNode* temp = dummyHead;\r\n        while(temp->next != nullptr && temp->next->next != nullptr) {\r\n            ListNode* node1 = temp->next;\r\n            ListNode* node2 = temp->next->next;\r\n            temp->next = node2;\r\n            node1->next = node2->next;\r\n            node2->next = node1;\r\n            temp = node1;\r\n        }\r\n        return dummyHead->next;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842559760","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<int> nums;\r\n        if (head == nullptr) return nullptr;\r\n        while (head != nullptr) {\r\n            nums.push_back(head->val);\r\n            head = head->next;\r\n        }\r\n        return buildTree(nums, 0, nums.size() - 1);\r\n    }\r\n    \r\n    TreeNode* buildTree(vector<int>& nums, int start, int end) {\r\n        if (start > end) return nullptr;\r\n        int mid = (start + end + 1) / 2;\r\n        TreeNode* root = new TreeNode(nums[mid]);\r\n        root->left = buildTree(nums, start, mid - 1);\r\n        root->right = buildTree(nums, mid + 1, end);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843768484","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode* fast = headA;\r\n        ListNode* slow = headB;\r\n        while (fast != slow) {\r\n            fast = fast != nullptr? fast->next : headB;\r\n            slow = slow != nullptr? slow->next : headA;\r\n        }\r\n        return fast;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844386562","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode* fast = head;\r\n        ListNode* slow = head;\r\n        while (1) {\r\n            if (fast == nullptr || fast->next == nullptr) return nullptr;\r\n            fast = fast->next->next;\r\n            slow = slow->next;\r\n            if (fast == slow) break;\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        return fast;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845681235","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode* removed = removeTail();\r\n                cache.erase(removed->key);\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846341251","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if (root == nullptr) return 0;\r\n        return max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846509195","body":"### 思路\r\n\r\n### 代码(C++)\r\n```C++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (p == NULL || q == NULL) {\r\n            return (p == NULL && q == NULL);\r\n        }\r\n        if (p->val != q->val) {\r\n            return false;\r\n        }\r\n        return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hannahliu-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836142144","body":"思路：先把str变成int；加上k；再转回str，放进list里\r\n\r\n代码：python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        x = int(''.join([str(s) for s in num]))\r\n        ans = x + k\r\n        array_form = [int(s) for s in str(ans)]\r\n        return array_form\r\n\r\n复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839403780","body":"cr. breadfruit (最近考试，先抄上一个好看的，交个作业，镇定一下。。)\r\n\r\n思路\r\n需要两个判断变量，一个是记录当前栈顶元素位置p，另一个是记录最大栈空间的位置q。\r\npush的时候判断当前栈顶元素位置p是否会大于最大栈空间的位置q\r\npop判断当前栈中是否有元素\r\nincrement判断k和当前栈顶元素位置p的大小\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.top = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack: \r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, len(self.stack))\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841250774","body":"cr. zliu1314 & kofzhang\r\n\r\n思路：\r\nself.instack\r\nself.outstack\r\n用2个列表实现，一个入一个出，入就一直入，出的时候看出列表里是否有值，如果有，直接出，如果没有，把入队列里的数据全部倒过来。\r\n\r\n\r\n代码：\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n    def in2out(self):\r\n        while (self.instack!=[]):\r\n            self.outstack.append(self.instack.pop())\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outstack == []:\r\n            self.in2out()\r\n        return self.outstack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (self.outstack==[]) & (self.instack==[])\r\n\r\n复杂度：\r\n时间O(1)\r\n空间O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679057","body":"cr. zliu1314 & breadfruit\r\n思路：构建一个单调栈，单调栈里只储存一个模块内最大的那个数字，栈里有几个数字，就是几个模块。后一个模块内，最小的数字，应大于或等于前一个模块内最大的数字。the minimum in the next block must be higher or equal to the max of current block. create a stack to store new max, and if come across a small number, than pop out the stack until the stack peek is smaller or equal to this small number. push the max into the stack.\r\n\r\n代码python：\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        stack = []\r\n        for i in A :\r\n            if stack and stack[-1] > i:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > i:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n\r\n复杂度：\r\n时间N(O)\r\n空间N(O)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842318681","body":"cr. 小漾\r\n\r\n递归思路：转换头两个nodes的链接（三部分：头、尾、两个间），剩下的使用递归，call the function。\r\n从js转到python的，不一定对\r\n\r\n代码：\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if head == None or head.next == None:\r\n              return head\r\n        else:\r\n              next = head.next\r\n              head.next = swapPairs(next.next)\r\n              next.next = head\r\n              return next\r\n\r\n复杂度分析\r\n时间复杂度：$O(N)$, N 为链表长度。\r\n空间复杂度：$O(N)$, N 为链表长度，递归栈的空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843163591","body":"cr.小漾\r\n思路：递归、分治\r\n代码：python\r\n\r\n```python\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not head: return None\r\n        prev, slow, fast = None, head, head\r\n        \r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        root = TreeNode(slow.val)\r\n        if slow == fast: return root\r\n        \r\n        if prev: prev.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n\r\n复杂度：\r\n时间$O(NlogN)$，N 为链表长度。\r\n空间$O(logN)$，N 为链表长度。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844168902","body":"cr. breadfruit + 小漾\r\n#思路：双指针\r\n#代码：python\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n```\r\n复杂度：\r\n时间：$O(M + N)$, M, N 分别为两个链表的长度。\r\n空间：$O(1)$。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845146776","body":"cr.小漾&breadfruit\r\n\r\n#\r\n思路：感谢小漾的图&数学证明，没有那个图和数学推导真的不行\r\n\r\n#\r\n代码：\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow = head,head\r\n        while True:\r\n            if not fast or not fast.next: return \r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n\r\n#\r\n复杂度：\r\n时间$O(n)$，n 为链表长度\r\n空间$O(1)$\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427925","body":"cr.小漾\r\n思路：1.左右树：递归；2.最大深度=max（左、右树深度）+1\r\n#\r\n代码：\r\n```\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        if not root: return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n#\r\n复杂度：\r\n时间O(N)\r\n空间O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunli2015":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836150346","body":"**思路**： 和add string一样，从末尾往前遍历，用sum， carry 记录\r\n**代码**：java\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, sum =0;\r\n        List<Integer> list = new ArrayList<>();\r\n        if(num.length == 0) return list;\r\n        int i= num.length - 1;\r\n        while(i>=0 || k != 0) {\r\n            sum = carry;\r\n            if(i >= 0) {\r\n                sum += num[i];\r\n                i--;\r\n            }\r\n            if(k != 0) {\r\n                sum += k %10;\r\n                k = k/10;\r\n            }\r\n            list.add(0, sum %10);\r\n            carry = sum /10;\r\n        }\r\n\r\n        if(carry != 0) list.add(0, carry);\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析：**\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839290372","body":"**思路**:   用一个增量数组记录增量，pop时加上increment[count-1]\r\n**代码：**\r\njava\r\n```\r\nclass CustomStack {\r\n    int[] increment;\r\n    Stack<Integer> s;\r\n    int count;\r\n    int size;\r\n    public CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        increment = new int[size + 1];\r\n        s = new Stack<Integer>();\r\n        count = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count == size) return;\r\n        s.push(x);\r\n        count++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s.isEmpty()) return -1;\r\n        int extra = increment[count -1];\r\n        if(count >= 2) increment[count - 2] += extra;\r\n        increment[count - 1] = 0;\r\n        count--;\r\n        return s.pop() + extra;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(count == 0) return;\r\n        increment[Math.min(k, count) - 1] += val;\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度：**\r\nT： O（1）\r\nS：O（k）k == maxSize"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840349815","body":"O(n)\r\nO(n)\r\n\r\n```\r\nclass Solution {\r\n    \r\n    class elem{\r\n        int n;\r\n        String s;\r\n        elem (int n, String s) {\r\n            this.n = n;\r\n            this.s = s;\r\n        }\r\n    }\r\n    public String decodeString(String s) {\r\n        Stack<elem> stack = new Stack<>();\r\n        \r\n        int number = 0;\r\n        for(int i=0; i<s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)) {\r\n                number = number * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(new elem(number, \"\"));\r\n                //System.out.println(number);\r\n                number = 0;\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            } else if (c == ']') {\r\n                Stack<String> temp = new Stack<>();\r\n                while(!stack.peek().s.equals(\"[\")) {\r\n                    temp.push(stack.pop().s);\r\n                }\r\n                \r\n                stack.pop();\r\n                int num = stack.pop().n;\r\n                StringBuilder sb = new StringBuilder();\r\n                while(!temp.isEmpty()) {\r\n                    sb.append(temp.pop());\r\n                }\r\n                \r\n                for(int j=0; j<num; j++) {\r\n                    stack.push(new elem(0, sb.toString()));\r\n                }\r\n            } else {\r\n                stack.push(new elem(0, Character.toString(c)));\r\n            }\r\n        }\r\n        \r\n        Stack<String> temp2 = new Stack<>();\r\n        while(!stack.isEmpty()) {\r\n            temp2.push(stack.pop().s);\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while(!temp2.isEmpty()) {\r\n            sb.append(temp2.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840798120","body":"```java\r\n\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n//O(1)\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n//O(1)\r\n    public int pop() {\r\n        if(s2.isEmpty()) {\r\n            popStack();\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(s2.isEmpty()) {\r\n            popStack();\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n    \r\n    private void popStack() {\r\n        while(!s1.isEmpty()) {\r\n            s2.push(s1.pop());\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841608936","body":"单调栈\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        for(int n:arr) {\r\n            if(!s.isEmpty() && n < s.peek()) {\r\n                int cur = s.pop();\r\n                while(!s.isEmpty() && n < s.peek()) {\r\n                    s.pop();\r\n                }\r\n                s.push(cur);\r\n            } else {\r\n                s.push(n);\r\n            }\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```\r\n\r\nT：O(N)\r\nS：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841776658","body":"O（N）\r\nO（1）\r\n```java\r\nclass Solution {\r\n  public ListNode rotateRight(ListNode head, int k) {\r\n    // base cases\r\n    if (head == null) return null;\r\n    if (head.next == null) return head;\r\n\r\n    // close the linked list into the ring\r\n    ListNode old_tail = head;\r\n    int n;\r\n    for(n = 1; old_tail.next != null; n++)\r\n      old_tail = old_tail.next;\r\n    old_tail.next = head;\r\n\r\n    // find new tail : (n - k % n - 1)th node\r\n    // and new head : (n - k % n)th node\r\n    ListNode new_tail = head;\r\n    for (int i = 0; i < n - k % n - 1; i++)\r\n      new_tail = new_tail.next;\r\n    ListNode new_head = new_tail.next;\r\n\r\n    // break the ring\r\n    new_tail.next = null;\r\n\r\n    return new_head;\r\n  }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842407272","body":"‘’’\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        ListNode dummyHead = new ListNode(0, head);\r\n        ListNode pre = dummyHead;\r\n        ListNode first = head;\r\n        ListNode second = head.next;\r\n        while (first != null && second != null) {\r\n            // pre->first->second->..\r\n            swap(pre, first, second);\r\n\r\n            // second->first->..\r\n            pre = first;\r\n            first = first.next;\r\n            if (first != null) {\r\n                second = first.next;\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return dummyHead.next;\r\n    }\r\n\r\n    private void swap(ListNode pre, ListNode first, ListNode second) {\r\n        first.next = second.next;\r\n        second.next = first;\r\n        pre.next = second;\r\n    }\r\n}\r\n‘’’\r\n复杂度分析\r\n\r\n时间复杂度： O(N),N为链表长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843283201","body":"T:O(N)\r\nS:O(N)\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        ListNode tmp = head;\r\n        while(tmp != null) {\r\n            arr.add(tmp.val);\r\n            tmp = tmp.next;\r\n        }\r\n        TreeNode root = buildTree(arr, 0, arr.size());\r\n        return root;\r\n    }\r\n\r\n    private TreeNode buildTree(List<Integer> arr, int  begin , int end) {\r\n        if(end - begin < 1) return null;\r\n        int mid = (begin + end - 1) / 2;\r\n        TreeNode root = new TreeNode(arr.get(mid));\r\n        root.left = buildTree(arr, begin, mid);\r\n        root.right = buildTree(arr, mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844315588","body":"快慢指针\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null) {\r\n            slow = slow.next;\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n            if (fast == slow) {\r\n                ListNode ptr = head;\r\n                while (ptr != slow) {\r\n                    ptr = ptr.next;\r\n                    slow = slow.next;\r\n                }\r\n                return ptr;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Xeraphinite":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836152663","body":"### 思路\r\n模拟即可，需要注意最终返回数组的长度\r\n\r\n### 时空复杂度\r\n**时间复杂度**：O(max(log(k), n))，只进行了一次遍历\r\n**空间复杂度**：O(1)，除了存储结果的 `vector` 之外没有用到额外的变量\r\n\r\n### Code\r\n\r\n#### C++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n      reverse(num.begin(), num.end());\r\n      int n = num.size(), i = 0;\r\n      vector<int> ans(max(n, (int)to_string(k).size()) + 1, 0);\r\n      while (i < n || k) {\r\n        ans[i] += (i < n ? num[i] : 0) + k % 10; \r\n        ans[i + 1] += ans[i] / 10, ans[i] %= 10;\r\n        k /= 10, i++;\r\n      }\r\n      if (ans.back() == 0) ans.pop_back();\r\n      return vector<int>(ans.rbegin(), ans.rend());\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838309562","body":"### 思路\r\n记录下标，并从前后两次遍历分别更新值。\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n      int n = s.size();\r\n      vector<int> res(n, 0), nextC;\r\n      for (int i = 0; i < n; i++)\r\n        if (s[i] == c) nextC.emplace_back(i);\r\n      int m = nextC.size();\r\n      for (int i = 0, j = 0; i < n; i++) {\r\n        res[i] = abs(nextC[j] - i);\r\n        if (j < m - 1 && nextC[j] == i) j++;\r\n      }\r\n      for (int i = n - 1, j = m - 1; i >= 0; i--) {\r\n        res[i] = min(abs(nextC[j] - i), res[i]);\r\n        if (j > 0 && nextC[j] == i) j--;\r\n      }\r\n      return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839457645","body":"### 思路\r\n\r\n在线处理即可（这道题与其说是前缀和，不如说只是一个从后往前的累加）。\r\n需要注意每一个变量代表的意义，不然很容易调炸。\r\n\r\n**时间复杂度：** O(n)，每个操作都是 O(1) 的，因此这里的 n 是操作个数。\r\n**空间复杂度：** O(max{k, maxSize})，其中 k 是栈中元素最多时候的个数。\r\n\r\n### 代码\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : maxSize(maxSize) {}\r\n    \r\n    void push(int x) {\r\n      if (stk.size() >= maxSize) {\r\n        return;\r\n      }\r\n      stk.emplace_back(x);\r\n      inc.emplace_back(0);\r\n    }\r\n    \r\n    int pop() {\r\n      if (stk.empty()) {\r\n        return -1;\r\n      }\r\n      int curTop = stk.back();\r\n      stk.pop_back();\r\n      int curInc = inc.back();\r\n      inc.pop_back();\r\n      if (!inc.empty()) {\r\n        inc.back() += curInc;\r\n      }\r\n      return curTop + curInc;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      if (stk.empty()) {\r\n        return;\r\n      }\r\n      int n = stk.size();\r\n      inc[(k >= n ? n - 1 : k - 1)] += val;\r\n    }\r\n\r\nprivate:\r\n  int maxSize;\r\n  vector<int> stk;\r\n  vector<int> inc;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840589861","body":"### 思路\r\n\r\n写栈不知道为啥写炸了，明天再调调看\r\n\r\n一个普通的递归下降分析。(参考官方代码写的）\r\n\r\n时间复杂度：O(n)， n 为字符串长度\r\n空间复杂度：O(n)，最多需要用到长度为 n 的系统栈储存\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int getNum() {\r\n      int repeatTimes = 0;\r\n      while (idx < src.size() && isdigit(src[idx])) {\r\n        repeatTimes *= 10;\r\n        repeatTimes += (src[idx++] - '0');\r\n      }\r\n      return repeatTimes;\r\n    }\r\n\r\n    string getString() {\r\n      if (idx >= src.size() || src[idx] == ']') {\r\n        return \"\";\r\n      }\r\n      string ret;\r\n      char cur = src[idx]; \r\n      int repTime = 1;\r\n      if (isdigit(cur)) {\r\n        repTime = getNum(); \r\n        idx++;\r\n        string str = getString(); \r\n        idx++;\r\n        while (repTime--) ret += str; \r\n      } else if (isalpha(cur)) {\r\n        ret = string(1, src[idx++]);\r\n      }\r\n      return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n      src = s, idx = 0;\r\n      return getString();\r\n    }\r\nprivate:\r\n    size_t idx;\r\n    string src;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280780","body":"### 思路\r\n\r\n模拟即可。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### 代码\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> st, st2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n      while (!st2.empty()) {\r\n        st.push(st2.top());\r\n        st2.pop();\r\n      }\r\n      st.push(x);\r\n    }\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n      auto val = peek();\r\n      st2.pop();\r\n      return val;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n      while (!st.empty()) {\r\n        auto val = st.top();\r\n        st.pop();\r\n        st2.push(val);\r\n      }\r\n      return st2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n      return st2.empty() && st.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841673299","body":"### 思路\r\n\r\n我是傻逼。\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n      vector<int> res = arr;\r\n      sort(res.begin(), res.end());\r\n      int ans = 0;\r\n      long long sum1 = 0, sum2 = 0;\r\n      for (int i = 0; i < arr.size(); i++) {\r\n        sum1 += res[i], sum2 += arr[i];\r\n        if (sum1 == sum2) ans++;\r\n      }\r\n      return ans;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841830044","body":"### 代码\r\n```Python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841976737","body":"```C++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n      if (head == nullptr || head->next == nullptr) {\r\n        return head;\r\n      }\r\n      auto newHead = head->next;\r\n      head->next = swapPairs(newHead->next);\r\n      newHead->next = head;\r\n      return newHead;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843242095","body":"```C++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n      if (head == nullptr) {\r\n        return nullptr;\r\n      }\r\n      if (head->next == nullptr) {\r\n        return new TreeNode(head->val);\r\n      }\r\n      auto pre = head, slow = head->next, fast = head->next->next;\r\n      while (fast && fast->next) {\r\n        pre = slow;\r\n        slow = slow->next;\r\n        fast = fast->next->next;\r\n      }\r\n      auto root = new TreeNode(slow->val);\r\n      pre->next = nullptr; // 需要断！\r\n      root->left = sortedListToBST(head);\r\n      root->right = sortedListToBST(slow->next);\r\n      return root;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843746116","body":"```C++\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n      auto cura = headA, curb = headB;\r\n      while (cura != curb) {\r\n        cura = (cura == nullptr ? headB : cura->next);\r\n        curb = (curb == nullptr ? headA : curb->next);\r\n      }\r\n      return cura;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844773878","body":"```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n      unordered_set<ListNode*> st;\r\n      auto cur = head;\r\n      while (cur) {\r\n        if (st.count(cur)) {\r\n          return cur;\r\n        }\r\n        st.insert(cur);\r\n        cur = cur->next;\r\n      }\r\n      return nullptr;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845746354","body":"C++, STL（list + unordered_map）\r\n```C++\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : size_(capacity) {}\r\n    \r\n    int get(int key) {\r\n      if (!mp.count(key)) return -1;\r\n      ls.splice(ls.begin(), ls, mp[key]);\r\n      return mp[key]->second;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n      if (get(key) == -1) {\r\n        if (ls.size() == size_) {\r\n          auto popKey = ls.back().first;\r\n          ls.pop_back();\r\n          mp.erase(popKey);\r\n        }\r\n        ls.emplace_front(key, value);\r\n        mp[key] = ls.begin();\r\n      } else {\r\n        mp[key]->second = value;\r\n      }     \r\n    }\r\n\r\nprivate:\r\n  unordered_map<int, list<pair<int, int>>::iterator> mp;\r\n  list<pair<int, int>> ls;\r\n  int size_;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846415066","body":"一行题，没啥好写的。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n      return root == nullptr ? 0 : max(maxDepth(root->left), maxDepth(root->right)) + 1;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846476791","body":"普通的dfs即可。\r\n```C++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n      if (p == nullptr && q == nullptr) return true;\r\n      if (p == nullptr && q != nullptr) return false;\r\n      if (p != nullptr && q == nullptr) return false;\r\n      return p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836153578","body":"思路：由低位到高位将数字逐位相加\r\nwhile(A没完 ||B没完)\r\n     A的当前位\r\n     B的当前位\r\n\r\n    和 = A的当前位 + B的当前位 + 进位carry;\r\n\r\n当前位  = 和 % 10;\r\n进位 = 和/10;\r\n\r\n判断还有进位么？\r\n\r\n代码：\r\nint* addToArrayForm(int* A, int ASize, int K, int* returnSize)\r\n{\r\n     int len = fmax(ASize, 5) + 1;//防止越界\r\n     int *res = (int*)malloc(sizeof(int) * len);\r\n     int i = ASize - 1;\r\n     int idx = 0;\r\n//k不为0，数组数据未处理完，继续处理\r\nwhile(k !=0 || i>=0)\r\n{\r\n    k += ( i >= 0) ? A[ i--]  : 0;\r\n    res[ --len] = k % 10;\r\n    k /= 10;\r\n    idx++;\r\n}\r\n*returnSize = idx;\r\nreturn res + len;\r\n}\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838112294","body":"思路：第一次从左到右遍历到最左端最短的距离，第二次从右到左遍历到最右端最短的距离\r\n代码：\r\nint* shortestToChar(char* s, char c, int* returnSize){\r\nint len=strlens(s);\r\nint* a=(int*)malloc(sizeof(int)*len);\r\nint count=0;\r\nfor(int i=0;i<len;i++){\r\nif(s[i]==c){\r\na[count++]=0;\r\n}else{\r\nint left=10001,right=10001;\r\nfor(int j=i+1;j<len;j++){\r\nif(s[j]==c){\r\nright=j;\r\nbreak;\r\n}\r\n}\r\nfor(int x=i-1;x>=0;x--){\r\nif(s[x]==c){\r\nleft=x;\r\nbreak;\r\n}\r\n}\r\nright=fmin(abs(i-left),abs(i-right));\r\na[count++]=right;\r\n}\r\n}\r\n*returnSize=len;\r\nreturn a;\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839684947","body":"代码：\r\ntypedef struct {\r\n    int key;\r\n    int value;\r\n    UT_hash_handle hh;\r\n} CustomStack;\r\n\r\nint g_size;\r\nint g_key = 0;\r\nCustomStack *g_hash = NULL;\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    g_size = maxSize;\r\n    return g_hash;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    int count = HASH_COUNT(g_hash);\r\n    if (count == g_size) {\r\n        return;\r\n    }\r\n    g_key++;\r\n    CustomStack *s = (CustomStack *)malloc(sizeof(CustomStack));\r\n    s->key = g_key;\r\n    s->value = x;\r\n    HASH_ADD_INT(g_hash, key, s);\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    int count = HASH_COUNT(g_hash);\r\n    int pos = 0;\r\n    if (count > 0) {\r\n        CustomStack *current, *tmp;\r\n        HASH_ITER(hh, g_hash, current, tmp) {\r\n            pos++;\r\n            if (pos == count) {\r\n                HASH_DEL(g_hash, current);\r\n                int value = current->value;\r\n                free(current);\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    CustomStack *current, *tmp;\r\n    int count = 0;\r\n    HASH_ITER(hh, g_hash, current, tmp) {\r\n        if (count == k) {\r\n            break;\r\n        }\r\n        current->value += val;\r\n        count++;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    CustomStack *current, *tmp;\r\n    HASH_ITER(hh, g_hash, current, tmp) {\r\n        HASH_DEL(g_hash, current);\r\n        free(current);\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841615362","body":"int maxChunksToSorted(int* arr, int arrSize){\r\n    int stack[2000]={0};\r\n    int index=1;\r\n    stack[1]=arr[0];\r\n    int tmp=0;\r\n    for(int i=1;i<arrSize;i++){\r\n        if(stack[index]<=arr[i]){\r\n            index+=1;\r\n            stack[index]=arr[i];\r\n        }\r\n        else{\r\n                tmp=stack[index];\r\n                while(arr[i]<stack[index]){\r\n                    index--;\r\n                }\r\n                index+=1;\r\n                stack[index]=tmp;\r\n        }\r\n    }\r\n    return index;\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841821896","body":"/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     struct ListNode *next;\r\n * };\r\n */\r\nstruct ListNode* rotateRight(struct ListNode* head, int k){\r\n    //对于长度为0和1的链表，怎么旋转都是本身，直接返回\r\n    if(head == NULL || head->next == NULL)\r\n    {\r\n        return head;\r\n    }\r\n\r\n    //1、先获取链表长度\r\n    int count = 0;\r\n    struct ListNode *temp = head;\r\n    while(temp != NULL)\r\n    {\r\n        count++;\r\n        temp = temp->next;\r\n    }\r\n\r\n    //2、得到真正需要旋转的长度\r\n    k = k % count;\r\n\r\n    //3、使用快慢指针，得到倒数第k个结点（为了节省内存，直接使用temp作为快指针）\r\n    temp = head;\r\n    for(int i = 0; i < k; i++)\r\n    {\r\n        temp = temp->next;\r\n    }\r\n\r\n    struct ListNode *curr = head;\r\n    while(temp != NULL && temp->next != NULL)\r\n    {\r\n        temp = temp->next;\r\n        curr = curr->next;\r\n    }\r\n\r\n    //4、将原链表的表尾指向原链表的表头，慢指针的next结点就是要返回的头节点，慢指针所指的即为表尾\r\n    temp->next = head;\r\n    temp = curr->next;\r\n    curr->next = NULL;\r\n    return temp;\r\n\r\n\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842323695","body":"代码:\r\nstruct ListNode* swapPairs(struct ListNode* head){\r\n    if (head == NULL || head->next == NULL) {\r\n        return head;\r\n    }\r\n\r\n    /* 设置 next 指针，在断开链表前，记录头节点的下一节点*/  \r\n    struct ListNode* next = head->next;  \r\n    /* 头节点后面挂接已完成交换的更短的链表 */\r\n    head->next = swapPairs(next->next); \r\n    /* 将原链表头节点的下一节点指向原链表的头节点，实现原链表的头节点与其下一节点交换 */\r\n    next->next = head;                   \r\n    return next;\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842811471","body":"代码:\r\nstruct ListNode* preMid(struct ListNode *head){       //找链表中间结点的前一个结点\r\n    struct ListNode* slow=head,*fast=head,*preslow=head;\r\n    while(fast!=NULL&&fast->next!=NULL)\r\n    {\r\n        preslow=slow;\r\n        slow=slow->next;\r\n        fast=fast->next->next;\r\n    }\r\n    return preslow;\r\n}\r\nstruct TreeNode* newTreeNode(int x){\r\n    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));\r\n    root->val=x;\r\n    root->left=root->right=NULL;\r\n    return root;\r\n}\r\nstruct TreeNode* sortedListToBST(struct ListNode* head){\r\n    if(head==NULL) return NULL;                             //递归的终止条件:链表中只有0或1个元素\r\n    if(head->next==NULL) return newTreeNode(head->val);\r\n    struct ListNode* premid=preMid(head);\r\n    struct ListNode* mid=premid->next;\r\n    premid->next=NULL;              //断开链表 分为前后两部分\r\n    struct TreeNode* root=newTreeNode(mid->val);\r\n    root->left=sortedListToBST(head);\r\n    root->right=sortedListToBST(mid->next);\r\n    return root;\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844093401","body":"思路\r\n循环思想+双指针\r\n一个指针从headA遍历，直到为NULL时改从headB遍历\r\n另一个指针同理，若有公共地址，则两个指针一定是在进入公共路径时相遇，走过的长度都是\r\nA非公共路段+B非公共路段+AB公共路段\r\n代码:\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     struct ListNode *next;\r\n * };\r\n */\r\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\r\n    if(!headA||!headB)return nanl;\r\n    struct ListNode *re1 = headA;\r\n    struct ListNode *re2 = headB;\r\n    while(re1 != re2){\r\n        re1 = re1?re1->next:headB;\r\n        re2 = re2?re2->next:headA;\r\n    }\r\n    return re1;\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845060820","body":"代码\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return null;//此时必定无环,也就没有入环的节点\r\n        }\r\n        ListNode slowPtr = head;\r\n        ListNode fastPtr = head;\r\n        while(fastPtr != null && fastPtr.next != null){//有环，那就会一直转圈，否则就无环\r\n            slowPtr = slowPtr.next;\r\n            fastPtr = fastPtr.next.next;\r\n            if (slowPtr == fastPtr) {\r\n                ListNode index1 = fastPtr;\r\n                ListNode index2 = head;\r\n                while (index1 != index2) {\r\n                    index1 = index1.next;\r\n                    index2 = index2.next;\r\n                }\r\n                return index2; // 返回环的入口\r\n            }\r\n        }\r\n        return null;\r\n    } \r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846020869","body":"/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     struct ListNode *next;\r\n * };\r\n */\r\nstruct ListNode *detectCycle(struct ListNode *head) {\r\n    if (head == NULL) {\r\n        return NULL;\r\n    }\r\n    struct ListNode *step1 = head;\r\n    struct ListNode *step2 = head;\r\n    int flag = 0;\r\n    \r\n    /* step1每次走一步，step2每次都两步，当他俩相遇时，则step2一定走了step1的两倍，并且说明有环 */\r\n    while (step2->next != NULL && step2->next->next != NULL) {\r\n        step2 = step2->next->next;\r\n        step1 = step1->next;\r\n        if (step1 == step2) {\r\n            flag = 1;\r\n            break;\r\n        }\r\n    }\r\n    /* 无环，返回NULL */\r\n    if (flag == 0) {\r\n        return NULL;\r\n    }\r\n    /* 假设起点到入环处长度为x,当前step1距离入环处长度为y ,step1走了x + n * cycle - y,step2走了2 * (x + n * cycle - y)\r\n       同时step2另外一种计算方法走了x + m * cycle - y, x + m * cycle - y =  2 * (x + n * cycle - y) \r\n       计算等式后发现, x = (m - 2n) * cycle + y, 而step1再走x步,也就是x + n * cycle - y + ((m - 2n) * cycle + y) = x + (m - n) * cycle \r\n       x + (m - n) * cycle即为入环点"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846422719","body":"/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     struct TreeNode *left;\r\n *     struct TreeNode *right;\r\n * };\r\n */\r\n\r\n\r\nint maxDepth(struct TreeNode* root){\r\n       if (root == NULL)\r\n        return 0;\r\n\r\n    int leftMax, rightMax;\r\n    leftMax = maxDepth(root->left);\r\n    rightMax = maxDepth(root->right);\r\n\r\n    if (leftMax > rightMax)\r\n        return leftMax + 1;\r\n    else\r\n        return rightMax + 1；\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Mvbbb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836163931","body":"# 思路\r\n\r\n按照竖式的个位加法来相加\r\n\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution{\r\n    public List<Integer> addToArrayForm(int[] num,int k){\r\n        int len = num.length;\r\n        int lastNum = k;\r\n        int i = len-1;\r\n        LinkedList<Integer> list = new LinkedList<>();\r\n        while(i>=0||lastNum>0){  // 循环条件: 没有遍历完num或者lastNum中的数还没有全部插入到 list 中\r\n            if(i>=0){ \r\n                lastNum+=num[i]; // 加上一个个位数\r\n            }\r\n            list.addFirst(lastNum%10); // 每一次循环都需要从 lastNum 末尾取一个数放到 list 中\r\n            lastNum/=10;\r\n            i--;\r\n        }\r\n        return list;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838027915","body":"**刚开始的思路：**\r\n\r\n遍历一遍数组， 找到 c 的位置的集合。\r\n在遍历一次数组，如果当前元素不是 c，就计算出当前元素下标到哪个c下标最近。\r\n\r\n时间复杂度 O(Nk) 。k 是 c 出现的次数\r\n\r\n**看了题解之后的思路：**\r\n\r\n\r\n离一个字符最近的 c 要不然是它右边最近的一个 c，要不然在它左边最近的一个 c\r\n\r\n遍历两次字符串\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] left = new int[s.length()]; \r\n        int[] right = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        int behind = Integer.MAX_VALUE/2;\r\n        for(int i=0,j=s.length()-1;i<s.length();i++,j--){\r\n            if(s.charAt(i)==c){\r\n                prev = i;\r\n                left[i]=0;\r\n            }else{\r\n                left[i]=i-prev;\r\n            }\r\n            if(s.charAt(j)==c){\r\n                behind = j;\r\n                right[j]=0;\r\n            }else{\r\n                right[j]=behind-j;\r\n            }            \r\n        }\r\n\r\n        for(int i=0;i<left.length;i++){\r\n            left[i]= Math.min(left[i],right[i]);\r\n        }\r\n        return left;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(N）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839806624","body":"```java\r\nclass CustomStack {\r\n\r\n    int[] arr ;\r\n    int maxSize ;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize+1];\r\n        this.maxSize=maxSize;\r\n        this.top = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top==maxSize){\r\n            return;\r\n        }\r\n        this.arr[top++]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top==0){\r\n            return -1;\r\n        }\r\n        return this.arr[--top];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = k>top?top:k;\r\n        for(int i=0;i<k;i++){\r\n            this.arr[i]+=val;\r\n        }\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840266496","body":"```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    \tDeque<Integer> numStack = new ArrayDeque<>();\r\n    \tDeque<String> strStack = new ArrayDeque<>();\r\n    \t\r\n    \tStringBuilder tail = new StringBuilder();\r\n\r\n        int n = s.length();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)){\r\n            \t// 将数字放入到操作数栈中\r\n                int num = c-'0';\r\n                while(i+1<n&&Character.isDigit(s.charAt(i+1))){\r\n                    num = num*10+s.charAt(i+1)-'0';\r\n                    i++;\r\n                }\r\n                numStack.push(num);\r\n            }\r\n            else if(c=='['){\r\n            \t// 将处于 ] 和 [ 之间的字符串放进 strStack 中\r\n                strStack.push(tail.toString());\r\n                tail = new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n            \t// 从 strStack 中取出字符串, numStack 中取出重复次数\r\n                StringBuilder tmp = new StringBuilder(strStack.pop());\r\n                int repeatedTimes = numStack.pop();\r\n                for(int j=0;j<repeatedTimes;j++){\r\n                    tmp.append(tail);\r\n                }\r\n                tail = tmp;\r\n            }\r\n            else{\r\n            \t// 当前 c 一定还没有被 [] 包围\r\n                tail.append(c);\r\n            }\r\n            \r\n        }\r\n        return tail.toString();\r\n    }\r\n}\r\n\r\n```\r\n时间复杂度 和 空间复杂度都是 O(S). S 是字符串解码之后的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841282924","body":"# 双栈实现\r\n- 一个 in 栈\r\n-  一个 out 栈\r\n\r\n入栈负责接收 push 的数\r\n\r\npop 的时候先检查 out 栈是否为空,如果为空,就将 in 栈中的数转移到 out 栈。之后将 out 栈顶弹出\r\n\r\npush 的时候直接将数放到 in 栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass MyQueue{\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n    public MyQueue(){\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n\r\n    public void push(int x){\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop(){\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek(){\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    public boolean empty(){\r\n        return inStack.isEmpty()&&outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度\r\n\r\n对于每个元素，至多在 inStack 和 outStack 之间被操作两次。时间复杂度为 O(1)\r\n\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666158","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] stack = new int[2010];\r\n        int top = 0;\r\n        for(int i=0;i<arr.length;i++){                   \r\n        \t\r\n\r\n        \tif(top==0||arr[i]>=stack[top-1]) {\r\n        \t\tstack[top++]=arr[i];\r\n        \t}else {\r\n        \t\tint topx= stack[--top];\r\n        \t\twhile(top!=0&&arr[i]<stack[top-1]) {\r\n        \t\t\ttop--;\r\n        \t\t}\r\n        \t\tstack[top++]=topx;\r\n        \t}\r\n        }\r\n        return top;\r\n    }\r\n}\r\n```\r\n# 时间复杂度\r\n\r\n每个元素最多只会入栈出栈各一次, 时间复杂度是 O(n)\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841767826","body":"今天的题有点简单了哈\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null){\r\n            return null;\r\n        }\r\n        // 将链表闭合为环， 并记录长度\r\n        // 之后将 length-k 位置上的节点指向 null\r\n        ListNode p = head;\r\n        int length = 1;\r\n        while(p.next!=null){\r\n            p=p.next;\r\n            length++;\r\n        }\r\n        p.next=head;\r\n        k%=length;\r\n        for(int i=0;i<length-k;i++){\r\n            p=p.next;\r\n        }\r\n        ListNode newHead = p.next;\r\n        p.next=null;\r\n        return newHead;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843199730","body":"# 思路\r\n\r\n递归分治、快慢指针找中间位置\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head,null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left,ListNode right){\r\n        if(left == right){\r\n            return null;\r\n        }\r\n        ListNode mid = findMid(left,right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left,mid);\r\n        root.right = buildTree(mid.next,right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode findMid(ListNode left,ListNode right){\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while(fast!=right&&fast.next!=right){\r\n            fast=fast.next;\r\n            fast=fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度 \r\n时间复杂度 O（n）\r\n空间复杂度 O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843705650","body":"# 思路\r\nhash表法\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> set = new HashSet<ListNode>();\r\n        ListNode pa = headA;\r\n        while(pa!=null){\r\n            set.add(pa);\r\n            pa = pa.next;\r\n        }\r\n\r\n        ListNode pb = headB;\r\n        while(pb!=null){\r\n            if(set.contains(pb)){\r\n                return pb;\r\n            }\r\n            pb = pb.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(n+m)\r\n\r\n双指针法\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headB==null||headB==null){\r\n            return null;\r\n        }\r\n        ListNode pa = headA;\r\n        ListNode pb = headB;\r\n        while(pa!=pb){\r\n            if(pa!=null){\r\n                pa=pa.next;\r\n            }else{\r\n                pa = headB;\r\n            }\r\n            if(pb!=null){\r\n                pb = pb.next;\r\n            }else{\r\n                pb = headA;\r\n            }\r\n        }\r\n        return pa;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度 O(n+m)\r\n\r\n感觉明天出这道题更合适 hhh"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844660231","body":"# 快慢指针\r\n不仅仅要确定是否存在环形链表，还需要确定环形链表的环入口。\r\n1. 使用快慢指针找到两个指针交汇的位置\r\n2. 另外用一个指针从头开始向后遍历，步长为1. 慢指针也向后遍历. 两个指针交汇的位置就是环入口\r\n\r\n证明见官方题解\r\n\r\n# 代码\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head,fast = head;\r\n        while(true){\r\n            if(fast==null||fast.next==null){\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(fast==slow){\r\n                break;\r\n            }\r\n        }\r\n        ListNode p = head;\r\n        while(p!=slow){\r\n            p=p.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n\r\n# 时间复杂度\r\n慢指针走过的步数不会超过链表的长度, 时间复杂度是 O(n)\r\n\r\n空间复杂度为 O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845575758","body":"```java\r\n\r\n\r\nclass LRUCache {\r\n\r\n    private MyLinkedList list ;\r\n    private HashMap<Integer,Node> map;\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>();\r\n        list = new MyLinkedList();\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(map.containsKey(key)){\r\n            Node node = map.get(key);\r\n            list.moveToFirst(node);\r\n            return node.val;\r\n        }else{\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        // 添加是一定可以成功的\r\n        Node node = map.get(key);\r\n        if(node==null){\r\n            Node add = new Node(key,value);\r\n            list.addFirst(add);\r\n            map.put(key,add);\r\n            if(list.size()>capacity){\r\n                int removeKey = list.removeLast();\r\n                map.remove(removeKey);\r\n            }\r\n        }else{\r\n            node.val = value;\r\n            list.moveToFirst(node);         \r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\nclass Node{\r\n    public Node prev;\r\n    public Node next;\r\n    public int key;\r\n    public int val;\r\n    public Node(){\r\n    }\r\n    public Node(int key,int val){\r\n    \tthis.key = key;\r\n        this.val = val;\r\n    }\r\n}\r\n\r\nclass MyLinkedList{\r\n    private Node first ;\r\n    private Node end ;\r\n    private int size;\r\n    public MyLinkedList(){\r\n        first = new Node();\r\n        end = new Node();\r\n        first.next = end;\r\n        end.prev = first;\r\n    }\r\n\r\n    public void removeNode(Node node){\r\n        if(node==null){\r\n            return ;\r\n        }\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        size--;\r\n    }    \r\n\r\n    public int removeLast(){\r\n    \tint key = end.prev.key;\r\n        end.prev.prev.next = end;               \r\n        end.prev = end.prev.prev;\r\n        size--;\r\n        return key;\r\n    }\r\n\r\n    public void addFirst(Node node){\r\n        node.next = first.next;\r\n        first.next.prev = node;\r\n        node.prev = first ;\r\n        first.next = node;   \r\n        size++;\r\n    }\r\n\r\n    public void moveToFirst(Node node){\r\n        removeNode(node);        \r\n        addFirst(node);\r\n    }\r\n    \r\n    public int size(){\r\n        return size;\r\n    }    \r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846415204","body":"些许简单了，hhh\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846497274","body":"太简单啦\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null&&q==null){\r\n            return true;\r\n        }\r\n        if(p==null||q==null){\r\n            return false;\r\n        }\r\n        if(p.val==q.val){\r\n            return isSameTree(p.left,q.left)&&isSameTree(p.right,q.right);\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisisandy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836172220","body":"# 思路\r\n各位依次相加\r\n\r\n# 代码\r\n```typescript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const num2 = []\r\n    const result = []\r\n    let diff = k\r\n    while(diff){\r\n        const unit = diff%10\r\n        num2.unshift(unit)\r\n        diff = Math.floor(diff/10)\r\n    }\r\n    let a;\r\n    let b;\r\n    let bonus = 0;\r\n    while(bonus || num.length || num2.length){\r\n        a = num.pop() || 0 \r\n        b = num2.pop() || 0\r\n        const sum = a + b + bonus\r\n        const unit = (sum) % 10\r\n        bonus = Math.floor((sum)/10)\r\n        result.unshift(unit)\r\n    }\r\n    return result\r\n};\r\n```\r\n# 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837700548","body":"```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let lastPosition = - Infinity;\r\n    const result = []\r\n    for(let i =0; i< s.length; i++){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = i - lastPosition\r\n    }\r\n    for(let i =s.length-1; i>=0; i--){\r\n        if(s[i] === c){\r\n            lastPosition = i\r\n        }\r\n        result[i] = Math.min(Math.abs(i-lastPosition),result[i])\r\n    }\r\n    return result\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478234","body":"```typescript\r\nfunction decodeString(s: string): string {\r\n    const stack = []\r\n    for(let i =0;i<s.length; i++){\r\n        if(/[[\\d\\w]/.test(s[i])){\r\n            stack.push(s[i])\r\n        }\r\n        if(/\\]/.test(s[i])){\r\n            let str = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(char!=='['){\r\n                    str = char + str\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n            let rep = ''\r\n            for(let j = stack.length-1; j>=0; j--){\r\n                const char = stack.pop()\r\n                if(!/\\d/.test(char)){\r\n                    stack.push(char)\r\n                    break;\r\n                }else{\r\n                    rep = char +rep\r\n                }\r\n            }\r\n            stack.push(str.repeat(Number(rep)))\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234171","body":"```typescript\r\nclass MyQueue {\r\n    private arr1 = []\r\n    private arr2 = []\r\n\r\n    push(x: number): void {\r\n        this.arr1.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        while(this.arr1.length!==1){\r\n            this.arr2.push(this.arr1.pop())\r\n        }\r\n        const value = this.arr1.pop()\r\n        while(this.arr2.length){\r\n            this.arr1.push(this.arr2.pop())\r\n        }\r\n        return value\r\n    }\r\n\r\n    peek(): number {\r\n        while(this.arr1.length!==1){\r\n            this.arr2.push(this.arr1.pop())\r\n        }\r\n        const value = this.arr1.pop()\r\n        this.arr2.push(value)\r\n        while(this.arr2.length){\r\n            this.arr1.push(this.arr2.pop())\r\n        }\r\n        return value\r\n    }\r\n\r\n    empty(): boolean {\r\n        return !this.arr1.length\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842256295","body":"```typescript\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n    const sanitel = new ListNode(null)\r\n    sanitel.next = head\r\n    let cur = sanitel\r\n    while(cur && cur.next && cur.next.next){\r\n        const first = cur.next\r\n        const second = cur.next.next\r\n        first.next = second.next\r\n        second.next = first\r\n        cur.next = second\r\n        cur = first\r\n    }\r\n    return sanitel.next\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzqnb":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836191824","body":"语言： java\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n\tint i = len - 1, sum = 0, carry = 0, res = 0;\r\n\tList<Integer> list = new ArrayList<>();\r\n\twhile (i >= 0 || k != 0) {\r\n\t\tsum = (i >= 0 ? num[i] : 0) + (k != 0 ? k % 10 : 0) + carry;\r\n\t\tcarry = sum / 10;\r\n\t\tres = sum % 10;\r\n\t\tlist.add(res);\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n        if (carry!=0) list.add(carry);\r\n\tCollections.reverse(list);\r\n\treturn list;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837839988","body":"左右两次遍历，参考了官方的解题方法加入了自己的思路\r\n\r\n**java**\r\n```\r\nclass Solution {\r\n\tpublic int[] shortestToChar(String s, char c) {\r\n\t\tint len = s.length(), prev = s.indexOf(c);\r\n\t\tint[] res = new int[len];\r\n\t\tfor (int i = 0; i < len; i++) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\tres[i] = tmp >= 0 ? tmp : -tmp;\r\n\t\t}\r\n\t\tprev = s.lastIndexOf(c);\r\n\t\tfor (int i = len - 1; i >= 0; i--) {\r\n\t\t\tif (s.charAt(i) == c) prev = i;\r\n\t\t\tint tmp = i - prev;\r\n\t\t\ttmp = tmp >= 0 ? tmp : -tmp;\r\n\t\t\tres[i] = tmp >= res[i] ? res[i] : tmp;\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839432610","body":"数组模拟栈\r\n```java\r\nclass CustomStack {\r\n\r\n        int[] satck;\r\n        int top;\r\n\r\n\tpublic CustomStack(int maxSize) {\r\n\t\tsatck = new int[maxSize];\r\n\t\ttop = -1;\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tif (top != satck.length - 1) {\r\n\t\t\ttop++;\r\n\t\t\tsatck[top] = x;\r\n\t\t}\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (top == -1) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\ttop--;\r\n\t\treturn satck[top + 1];\r\n\t}\r\n\r\n\tpublic void increment(int k, int val) {\r\n\t\tint limit = k > (top + 1) ? (top + 1) : k;\r\n\t\tfor (int i = 0; i < limit; i++) {\r\n\t\t\tsatck[i] += val;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841004308","body":"```java\r\nclass MyQueue {\r\n\r\n    Deque<Integer> inStack;\r\n\tDeque<Integer> outStack;\r\n\r\n\tpublic MyQueue() {\r\n\t\tinStack = new LinkedList<Integer>();\r\n\t\toutStack = new LinkedList<Integer>();\r\n\t}\r\n\r\n\tpublic void push(int x) {\r\n\t\tinStack.push(x);\r\n\t}\r\n\r\n\tpublic int pop() {\r\n\t\tif (outStack.isEmpty()) {\r\n\t\t\tin2out();\r\n\t\t}\r\n\t\treturn outStack.pop();\r\n\t}\r\n\r\n\tpublic int peek() {\r\n\t\tif (outStack.isEmpty()) {\r\n\t\t\tin2out();\r\n\t\t}\r\n\t\treturn outStack.peek();\r\n\t}\r\n\r\n\tpublic boolean empty() {\r\n\t\treturn inStack.isEmpty() && outStack.isEmpty();\r\n\t}\r\n\r\n\tprivate void in2out() {\r\n\t\twhile (!inStack.isEmpty()) {\r\n\t\t\toutStack.push(inStack.pop());\r\n\t\t}\r\n\t}\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631470","body":"找不到思路，参考题解\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int tmp = arr[0],len = arr.length,count = 1;\r\n\t\tfor (int i = 1; i < len; i++) {\r\n\t\t\tif (tmp < arr[i]) {\r\n\t\t\t\tcount++;\r\n\t\t\t\ttmp = arr[i];\r\n\t\t\t}\r\n\t\t\tif (i == len - 1 && tmp == arr[len - 1]) {\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841822480","body":"java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add-- > 0) {\r\n            iter = iter.next;\r\n        }\r\n        ListNode ret = iter.next;\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841981036","body":"似懂非懂，\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843220204","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844107138","body":"```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> hashSet = new HashSet<>();\r\n\r\n        ListNode curNode = headA;\r\n        while (curNode != null) {\r\n            hashSet.add(curNode);\r\n            curNode = curNode.next;\r\n        }\r\n\r\n        curNode = headB;\r\n        while (curNode != null) {\r\n            if(hashSet.contains(curNode)){\r\n                return curNode;\r\n            }\r\n            curNode = curNode.next;\r\n        }\r\n        return null;\r\n    }\r\n\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengyi666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836198313","body":"**思路：**\r\n• 判断长度\r\n• 考虑进位\r\n• 考虑越位开辟新空间\r\n• 正序输入，倒序输出\r\n### \r\n**力扣python打卡**\r\n\r\n\r\n```\r\n#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\nvoid  addToArrayForm(int* A, int ASize, int K)\r\n{\r\n\t//计算K的位数\r\n\tint len = 0;\r\n\tint tmp = K;\r\n\twhile (tmp)\r\n\t{\r\n\t\tlen++;\r\n\t\ttmp /= 10;\r\n\t}\r\n\t//开辟空间，注意最高位可能存在进位的情况\r\n\tint arrLen = ASize > len ? ASize + 1 : len + 1;\r\n\tint* arr = (int*)malloc(sizeof(int) * arrLen);\r\n\t//逐位相加\r\n\tint index = 0;\r\n\tint end = ASize - 1;\r\n\tint step = 0;\r\n\twhile (end >= 0 || K > 0)\r\n\t{\r\n\t\tint cursum = step;\r\n\t\tif (end >= 0)\r\n\t\t{\r\n\t\t\tcursum += A[end];\r\n\t\t}\r\n\t\tif (K > 0)\r\n\t\t{\r\n\t\t\tcursum += (K % 10);\r\n\t\t}\r\n\t\t//如果位数的值超过9需要进位\r\n\t\tif (cursum > 9)\r\n\t\t{\r\n\t\t\tstep = 1;\r\n\t\t\tcursum -= 10;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tstep = 0;\r\n\t\t}\r\n\t\tarr[index++] = cursum;\r\n\t\tend--;\r\n\t\tK /= 10;\r\n\t}\r\n\t//判断最高位是否存在进位\r\n\tif (step == 1)\r\n\t{\r\n\t\tarr[index++] = step;\r\n\t}\r\n\t//为了方便对数组进行尾插，所以数据是逆序存储，故要对数组进行逆序操作。\r\n\tint start = 0;\r\n\tend = index - 1;\r\n\twhile (start < end)\r\n\t{\r\n\t\tint tmp = arr[start];\r\n\t\tarr[start] = arr[end];\r\n\t\tarr[end] = tmp;\r\n\t\tstart++;\r\n\t\tend--;\r\n\t}\r\n\tfor (int i = 0; i < index; ++i)\r\n\t\tprintf(\"%d \", *(arr + i));\r\n}\r\n//主函数\r\nint main() {\r\n\t\tint a[10] = {};\r\n\t\tint Asize, k;\r\n\t\tprintf(\"想输入几位数组？：\\n\");\r\n\t\tscanf_s(\"%d\", &Asize);\r\n\t\tprintf(\"请输入数组：\\n\");\r\n\t\tfor (int i = 0; i < Asize; i++) {\r\n\t\t\tscanf_s(\"%d\", &a[i]);\r\n\t\t}\r\n\t\tprintf(\"请输入0~10000的整数：\\n\");\r\n\t\tscanf_s(\"%d\", &k);\r\n\taddToArrayForm(a, Asize, k);\r\n\treturn 0;\r\n}\r\n//分为1.判断位数2.逐位相加3.进位4.越位5.逆序\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837733723","body":"**思路**\r\n1.获取目标在s中的下标\r\n2.从头开始，比较相邻2个的目标\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        location = []\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                location.append(i) # 获取目标在s中的下标\r\n        k = 0\r\n        whole = len(location)-1\r\n        res = []\r\n        for i in range(len(s)):\r\n            if k!=whole and abs(i-location[k])>abs(i-location[k+1]):\r\n                k += 1\r\n            res.append(abs(i-location[k]))\r\n        return res\r\n```\r\n**复杂度分析**\r\n\r\n- 时间:O(n)\r\n\r\n- 空间:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839442207","body":"**思路：**\r\n我只管pop出的结果\r\n放弃空间要时间\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.assist = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n            self.assist.append(0) # 辅助栈\r\n\r\n    def pop(self) -> int:\r\n        if len(self.assist)>0:\r\n            temp = self.assist.pop()\r\n            res = self.stack.pop() + temp\r\n            if self.assist:\r\n                self.assist[-1] += temp\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k>len(self.stack):\r\n            k = len(self.stack)\r\n        if k > 0:\r\n            self.assist[k-1] += val \r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840512151","body":"**思路**\r\n栈\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 定义空栈\r\n        res = ''\r\n        num = 0\r\n        for c in s:\r\n            if c == \"[\":\r\n                stack.append([num,res])\r\n                res = ''\r\n                num = 0\r\n            elif c == \"]\":\r\n                last_num,last_res = stack.pop()\r\n                res = last_res + last_num * res\r\n            elif c.isdigit():\r\n                num = num * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840911309","body":"**思路**\r\n申请一个辅助栈\r\n```\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self. accpectstack = []\r\n        self. outputstack = []\r\n\r\n    def push(self, a: int):  #将一个元素放入队列的尾部。\r\n        self.accpectstack.append(a)\r\n\r\n    def pop(self) -> int:  #从队列首部移除元素。\r\n        while len(self.accpectstack) > 1:\r\n            self.outputstack.append(self.accpectstack.pop())\r\n        res = self.accpectstack.pop()\r\n        while len(self.outputstack) > 0:\r\n            self.accpectstack.append(self.outputstack.pop())\r\n        return res\r\n\r\n    def peek(self) -> int:  #返回队列首部的元素。\r\n        return self.accpectstack[0]\r\n\r\n    def empty(self) -> bool:  #返回队列是否为空。\r\n        return len(self.accpectstack) == 0\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841785092","body":"**思路**\r\n判断长度取模\r\n放2个指针，一个先跑\r\n两个一起跑\r\n再用指针链接（先拆再补）\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not k:\r\n            return head\r\n        p1 , p2 , tail  = head, head, head\r\n        total = 0\r\n        while(tail.next):\r\n            tail = tail.next\r\n        while(p1):\r\n            total +=1\r\n            p1 = p1.next\r\n        k = k % total\r\n        if k == 0:\r\n            return head\r\n        move = total -k -1\r\n        while(move > 0):\r\n            p2 = p2.next\r\n            move -= 1\r\n        rtn  = p2.next\r\n        p2.next = None\r\n        tail.next = head\r\n        return rtn\r\n```\r\n复杂度分析\r\n\r\n- 时间:O(n)\r\n- 空间:O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844161401","body":"**思路**\r\n1..将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 \r\n2 为: B + C2.当 a 指针将链表 1 遍历完后,重定位到链表 B 的头结点,然后继续遍历直至相交点(a 指针遍历的距离为 A + C + B\r\n3.同理 b 指针遍历的距离为 B + C + A\r\n\r\n\r\n**代码**\r\n``` C\r\nstruct SListNode*getIntersectionNode(SListNode* _PaNext,SListNode* _PbNext){\r\nint count1=0,count2=0;\r\nSListNode ret={0;NULL}\r\nSListNode* p = _PaNext;\r\nSListNode* q = _PbNext;//双指针\r\nSListNode* headA=_PaNext;\r\nSListNode* headB=_PbNext;//指路到头节点\r\nwhile(p!=NULL){\r\np=p._PNext;\r\n++count1;\r\n}\r\nwhile(q!=NULL){\r\nq=q._PNext;\r\n++count2;\r\n}//计数\r\np=headA;\r\nq=headB;//重新定到开头\r\nwhile（p!=q）{\r\nif(p==NULL){\r\np=headB;\r\n}else{\r\np=p._PNext;\r\n++ret._date;}\r\nif(q==NULL){\r\nq=headA;\r\n}else\r\nq=q._PNext;\r\nif(ret._date>(count1+count2))\r\nbreak;//判断没法相等\r\nret._PNext=p;}\r\nreturn ret;\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846431838","body":"**思路：**\r\n递归\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p == None and q == None:\r\n            return True\r\n        elif p != None and q != None:\r\n            if p.val == q.val:\r\n                return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)\r\n        return False\r\n```\r\n**复杂度**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nanwy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836213176","body":"思路\r\n1.各位相加，如果进位，将k加1，把相加后的数对10取余放入数组，最后反转数组\r\n\r\n代码（js）\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [],carry=0;\r\n    for(let i=num.length-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = k / 10 | 0\r\n        if(sum > 9){\r\n            k++\r\n        }\r\n        res.push(sum % 10)\r\n    }\r\n    while(k != 0){\r\n        res.push(k % 10)\r\n        k = k / 10 | 0\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n        \r\n复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837737014","body":"## 思路：先进行遍历，碰到c后，派出两个指针分别向左向右，取最小值。\r\n```js\r\nvar shortestToChar = function (s, c) {\r\n        let i = 0,res = Array(s.length).fill(Infinity);\r\n        while (i < s.length) {\r\n                if (s[i] !== c) {\r\n                        let l = i - 1,\r\n                                r = i + 1;\r\n                        while (s[l] != c && l > 0) {\r\n                                l--;\r\n                        }\r\n                        while (s[r] != c && r < s.length - 1) {\r\n                                r++;\r\n                        }\r\n                        let left = s[l] == c ? i - l : Infinity;\r\n                        let right = s[r] == c ? r - i : Infinity;\r\n                        let ans = Math.min(left, right);\r\n                        // console.log(ans)\r\n                        res[i] = ans;\r\n                } else {\r\n                        res[i] = 0;\r\n                }\r\n                i++;\r\n        }\r\n        // console.log(res)\r\n        return res;\r\n};\r\n```\r\n## 复杂度分析\r\n\r\n- 时间：O(n^2)\r\n- 空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839790812","body":"思路：\r\n用数组模拟栈的推入弹出\r\n代码：\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.max = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length == this.max){\r\n        return \r\n    }\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(!this.stack.length){\r\n        return -1\r\n    }\r\n    return this.stack.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i=0;i<k && i<this.stack.length;i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840426835","body":"思路：\r\n用两个栈分别存入重复的次数和被重复的字符串，遍历数组遇到'['将数字和字符串压入栈，遇到']'将两个栈分别弹出，并赋值给新的str。\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], strStack = [],str = '', num=0\r\n    for(let i=0;i<s.length;i++){\r\n        if(/[0-9]/.test(s[i])){\r\n            // numStack.push(s[i])\r\n            num = num * 10 + +s[i]\r\n        }else if(s[i] == '['){\r\n            strStack.push(str)\r\n            str = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        }else if(s[i] == ']'){\r\n            let newStr = str.repeat(numStack.pop())\r\n            // strStack.push(newStr)\r\n            // console.log(newStr)\r\n            str = strStack.pop() +  newStr\r\n        }else{\r\n            str += s[i]\r\n        }\r\n    }\r\n    // console.log(strStack,numStack,str)\r\n    return str\r\n};\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(2n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841086194","body":"思路：使用两个栈，用栈的先进后出特性，颠倒一下就是队列的先进先出了\r\n代码：\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\nthis.stack1 = []\r\nthis.stack2 = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length)return this.stack2.pop()\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return this.stack2.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack2.length)return this.stack2[this.stack2.length-1]\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return this.stack2[this.stack2.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n      while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    return !this.stack2.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(2n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841826563","body":"思路\r\n将链表闭合为环\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head)return head\r\n    let count = 0,now = head\r\n    while(now){\r\n        count++\r\n        now = now.next\r\n    }\r\n    k = k % count\r\n    let f=head,s=head\r\n    while(f.next){\r\n        if(k>0){\r\n            f=f.next\r\n            k--\r\n            continue\r\n        }\r\n        f=f.next\r\n        s=s.next\r\n    }\r\n    f.next = head\r\n    head = s.next\r\n    s.next=null\r\n    return head\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842982416","body":"思路：\r\n用中序遍历反构建树\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    if(!head) return null\r\n    let len = 0;\r\n    let dummy = head\r\n    while(head){\r\n        len++\r\n        head=head.next\r\n    }\r\n    const buildTree = (start,end)=> {\r\n        if(start > end) return null\r\n        // let mid = Math.floor(start + (end - start) / 2)\r\n        let mid = (start + end) >>> 1\r\n        // console.log(mid,len)\r\n        let left = buildTree(start, mid - 1)\r\n        const root = new TreeNode(dummy.val)\r\n        dummy = dummy.next\r\n        root.left = left\r\n        root.right = buildTree(mid + 1, end)\r\n        return root\r\n    }\r\n    return buildTree(0, len-1)\r\n};\r\n```\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845193435","body":"思路\r\n使用快慢指针\r\n代码\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let f = head,s = head\r\n    while(f && f.next){\r\n        f=f.next.next\r\n        s=s.next\r\n        if(f===s){\r\n            let start = head\r\n            while(start !== s){\r\n                s=s.next\r\n                start = start.next\r\n            }\r\n            return start\r\n        }\r\n    }\r\n    return null\r\n};\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"surahe":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836217045","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  将k 转换为数组 k_arr\r\n-  比较 k_arr 和 num 长度，将其中较长的一个的长度+1，定义为 max_length\r\n-  创建数组digit，长度为max_length，用来存储进位\r\n-  将 k_arr 和 num 长度补长到与 max_length相同\r\n-  从低位开始逐位计算，超过10则在digit 对应位置进1\r\n-  如果最高为是0，去除\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar addToArrayForm = function (num, k) {\r\n  var result = []\r\n  var k_arr = k.toString().split('')\r\n  var max_length = num.length > k_arr.length ? num.length + 1 : k_arr.length + 1\r\n  var digit = Array(max_length).fill(0)\r\n  var now_res\r\n\r\n  for (var i = num.length; i < max_length; i++) {\r\n    num.unshift(0)\r\n  }\r\n  for (var i = k_arr.length; i < max_length; i++) {\r\n    k_arr.unshift(0)\r\n  }\r\n\r\n  for (var i = max_length - 1; i >= 0; i--) {\r\n    if (digit[i] + num[i] + +k_arr[i] >= 10) {\r\n      digit[i-1] = 1\r\n      now_res = digit[i] + num[i] + +k_arr[i] - 10\r\n    } else {\r\n      now_res = digit[i] + num[i] + +k_arr[i]\r\n    }\r\n    result.unshift(now_res)\r\n  }\r\n\r\n  if (result[0] === 0) {\r\n    result.shift()\r\n  } \r\n\r\n  return result\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(Max(num, k)+1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837820712","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用两个数组分别存储从左遍历向左比较（→）和从左遍历向右比较（←）的情况\r\n-  对于向右查找，如果数组长度不够，需要补99999\r\n- 对于向左查找，情况更复杂点。没遇到 c前都需要补99999，只要遇到一次以后就不需要再补99999。如果遍历结束，right 长度还不够，需要把k 遍历 push 进right\r\n- 比较 left、right 各项大小，取较小的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  var length = s.length\r\n\r\n  var left = []\r\n  var i = 0\r\n  var j = 0\r\n\r\n  var right = []\r\n  var k = 0\r\n  var l = 0\r\n\r\n  while (i < length) {\r\n    if (s[i]!== c) {\r\n      j++\r\n    } else {\r\n      for (var index = j; index >= 0; index--) {\r\n        left.push(index)\r\n        j = 0\r\n      }\r\n    }\r\n    i++\r\n  }\r\n  for (var t1 = left.length; t1 < length; t1++) {\r\n    left.push(99999)\r\n  }\r\n\r\n  let flag = true\r\n  while (k < length) {\r\n    if (s[k] !== c) {\r\n      if (flag) {\r\n        right.push(99999)\r\n      } else {\r\n        l++\r\n      }\r\n    } else {\r\n      flag = false\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n      right.push(0)\r\n      l = 0\r\n    }\r\n    k++\r\n    if (k === length && l !== 0) {\r\n      for (var index = 1; index <= l; index++) {\r\n        right.push(index)\r\n      }\r\n    }\r\n  }\r\n\r\n  for (var i = 0; i < length ; i++) {\r\n    if (right[i] < left[i]) {\r\n      left[i] = right[i]\r\n    }\r\n  }\r\n  return left\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840658514","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  用栈分别存储重复次数、字符串内容\r\n- 记录左括号、右括号匹配次数\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n  var state\r\n  var multi = 1\r\n  var left = 0\r\n  var right = 0\r\n\r\n  var str = ''\r\n  var strStack = []\r\n\r\n  var repeatStack = []\r\n\r\n  var a2z = /[a-z]/\r\n  var one2nine = /[1-9]/\r\n  for (var i = 0; i < s.length; i++) {\r\n    if (a2z.test(s[i])) {\r\n      if (i === 0 || s[i - 1] === ']') {\r\n        repeatStack.push(1)\r\n      }\r\n      str += s[i]\r\n      if (i == s.length -1 && str) {\r\n        strStack.push(str)\r\n      }\r\n    }\r\n    if (one2nine.test(Number(s[i]))) {\r\n      multi = multi * Number(s[i])\r\n      if (state === 'on') {\r\n        repeatStack.push(multi)\r\n      } else {\r\n        repeatStack.push(Number(s[i]))\r\n      }\r\n      if ( str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n    }\r\n    if (s[i] === '[') {\r\n      if (state === 'on' && str) {\r\n        strStack.push(str)\r\n        str = ''\r\n      }\r\n      left ++\r\n      state = 'on'\r\n    }\r\n    if (s[i] === ']' && str) {\r\n      strStack.push(str)\r\n      str = ''\r\n      right ++\r\n      state = 'off'\r\n      if (left === right) {\r\n        multi = 1\r\n      }\r\n    }\r\n  }\r\n  var result = ''\r\n  for (var i = 0; i < repeatStack.length; i ++) {\r\n    for(var j = 0; j < repeatStack[j]; j++) {\r\n      result+=strStack[j]\r\n    }\r\n  }\r\n  return result\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为字符串长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841244636","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  构建2个栈 a，b\r\n- push操作将所有元素放到a\r\n- 每次pop操作时，a将所有元素pop，然后push到b。将b的元素pop出来，再将b的其他所有元素pop，并push到a。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n  this.mainStack = []\r\n  this.subStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  return this.mainStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  while (this.mainStack.length) {\r\n    this.subStack.push(this.mainStack.pop())\r\n  }\r\n\r\n  let top = this.subStack.pop()\r\n  while (this.subStack.length) {\r\n    this.mainStack.push(this.subStack.pop())\r\n  }\r\n  return top\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  while (this.mainStack.length) {\r\n    this.subStack.push(this.mainStack.pop())\r\n  }\r\n\r\n  let top = this.subStack.pop()\r\n  this.subStack.push(top)\r\n  while (this.subStack.length) {\r\n    this.mainStack.push(this.subStack.pop())\r\n  }\r\n  return top\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return !this.mainStack.length && !this.subStack.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\nvar myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\n\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\n\r\nconsole.log(myQueue.peek())\r\n// return 1\r\n\r\nconsole.log(myQueue.pop() )\r\n// return 1, queue is [2]\r\n\r\nmyQueue.empty(); // return false\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665051","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n- 参考suukii题解\r\n-  若数组拆分结果符合升序数组要求，则其前n项和与升序数组的前n项和是相同的\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  var sortArr = [...arr]\r\n  var sumA = 0\r\n  var sumB = 0\r\n  var result = 0\r\n  sortArr = sortArr.sort((a, b) => a-b)\r\n  \r\n  for (var i = 0; i < arr.length; i++) {\r\n    sumA += arr[i]\r\n    sumB += sortArr[i]\r\n\r\n    if (sumA === sumB) {\r\n      result++\r\n    }\r\n  }\r\n  return result\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：需要进行一次排序和遍历数组arr一次，$O(n)$\r\n- 空间复杂度：需要创建一个和arr等长的数组，$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841833372","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  快慢指针\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\nvar rotateRight = function (head, k) {\r\n  if (k == 0 || head == null || head.next == null) {\r\n    return head;\r\n  }\r\n  var fast = head\r\n  var slow = head\r\n\r\n  var len = 0\r\n\r\n  while (len < k && fast !== null) {\r\n    len++\r\n    fast = fast.next\r\n  }\r\n\r\n  if (fast == null) {\r\n    k = k % len;\r\n    if (k == 0) {\r\n      return head;\r\n    }\r\n    fast = head;\r\n    for (var i = 0; i < k; i++) {\r\n      fast = fast.next;\r\n    }\r\n  }\r\n  while (fast != null && fast.next != null) {\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  var newHead = slow.next;\r\n  slow.next = null;\r\n  fast.next = head;\r\n  return newHead;\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(min(k , n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842435950","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  创建虚拟节点，next为head\r\n-  逆转节点\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    let pre = new ListNode(0, null);\r\n    pre.next = head;\r\n    let curr = pre;\r\n    while(curr.next !== null && curr.next.next !== null){\r\n        let start = curr.next;\r\n        let end = curr.next.next;\r\n        curr.next = end;\r\n        start.next = end.next;\r\n        end.next = start;\r\n        curr = start;\r\n    }\r\n    return pre.next;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843293367","body":"\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  找了个数组生成平衡二叉树的，试了下发现搞不来\r\n- 最后还是参考了题解\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head == tail) return null;\r\n  let fast = head;\r\n  let slow = head;\r\n  // 找到中点位置\r\n  while (fast != tail && fast.next != tail) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  let root = new TreeNode(slow.val);\r\n  root.left = dfs(head, slow);\r\n  root.right = dfs(slow.next, tail);\r\n  return root;\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844223914","body":"\r\n\r\n## hash\r\n\r\n## 关键点\r\n\r\n-  遍历headA，用 new Set 存储headA的节点\r\n- 遍历headB，若在set中找到相同的点，返回该点\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar getIntersectionNode = function (headA, headB) {\r\n  var data = new Set()\r\n  while (headA) {\r\n    data.add(headA)\r\n    headA = headA.next\r\n  }\r\n  while (headB) {\r\n    if (data.has(headB)) {\r\n      return headB\r\n    }\r\n    headB = headB.next\r\n  }\r\n  return null\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n+m)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845227602","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  创建Set存储节点\r\n- 遍历链表，若在Set中发现对应的节点，返回该节点。否则存储到Set\r\n- 若遍历结束，返回Null\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\nvar detectCycle = function(head) {\r\n    var data = new Set()\r\n    while(head) {\r\n        if (data.has(head)) {\r\n            return head\r\n        } else {\r\n            data.add(head)\r\n        }\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846054092","body":"\r\n\r\n## 思路\r\n使用map\r\n\r\n## 关键点\r\n\r\n-  参考题解\r\n- 双向链表， 哈希表\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```JavaScript\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.map.get(key)\r\n    if(value === undefined){\r\n        return -1;\r\n    }\r\n    this.map.delete(key);\r\n    this.map.set(key, value);\r\n    return value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.map.has(key)){\r\n        this.map.delete(key);\r\n    }\r\n    this.map.set(key,value);\r\n    if(this.map.size > this.capacity){\r\n        let keyIterator = this.map.keys();\r\n        this.map.delete(keyIterator.next().value);\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427176","body":"思路\r\n深度优先搜索\r\n\r\n代码 JavaScript\r\n~~~\r\nvar maxDepth = function (root) {\r\n  if (!root) return 0\r\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n~~~\r\n\r\n复杂度\r\n空间：O(N)\r\n时间：O(height)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Serrust":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836227745","body":"```import java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\n/*\r\n * @lc app=leetcode id=989 lang=java\r\n *\r\n * [989] Add to Array-Form of Integer\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an arraylist to store the answer.\r\n     * loop starting from the last element of input,\r\n     * here i use an example:\r\n     * for 123 + 912, where 123 is the integer represented by A and 912 is K\r\n     * we start with [1, 2, 3+912]. \r\n     * Then we perform the addition 3+912, leaving 915. \r\n     * The 5 stays as the digit, while we 'carry' 910 into the next column which becomes 91.\r\n     * We repeat this process with [1, 2+91, 5]. \r\n     * We have 93, where 3 stays and 90 is carried over as 9. \r\n     * Again, we have [1+9, 3, 5] which transforms into [1, 0, 3, 5].\r\n     * Complexity Analysis:\r\n     * Todo: why?\r\n     * Time: O(max(N, log K)) where N is the length of A\r\n     * Space: O(max(N,log K))\r\n     * @param A\r\n     * @param K\r\n     * @return\r\n     */\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        \r\n        int N = A.length;\r\n        int temp = K;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        int i = N-1;\r\n        // Note: we are not sure if the integer that A represents is larger or k is larger\r\n        while (i >= 0 || temp > 0) {\r\n            // Note: we add this if condition because i can be negative if K is larger than the integer represented by A\r\n            if (i >= 0) {\r\n                temp += A[i];\r\n            }\r\n            ans.add(temp % 10);\r\n            temp /= 10;\r\n            i -= 1;\r\n        }\r\n        Collections.reverse(ans);\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838668830","body":"```/*\r\n * @lc app=leetcode id=821 lang=java\r\n *\r\n * [821] Shortest Distance to a Character\r\n */\r\n\r\n// @lc code=start\r\nclass Solution {\r\n    /**\r\n     * Explanation:\r\n     * create an array to store the answers\r\n     * create int c_position and set it to a negative number\r\n     * iterate through the existing string by each character twice\r\n     * in the first loop, loop from the front\r\n     * in each iteration, the distance (from the left char c) = current position - c_position\r\n     * once char c is found, update c_position to the position of c\r\n     * then set c_position to a very large positive integer and start the second loop\r\n     * in the second loop, loop from the end\r\n     * in each iteration, the distance (from the right char c) = c_position - current position IF this distance is smaller than the distance we calculated in the first iteration\r\n     * return the array with the shortest distance\r\n     * \r\n     * Complexity Analysis:\r\n     * Time: O(n) since 2 iterations, each iteration length is n\r\n     * Space: O(n) since only an array with the length of input string is used\r\n     * \r\n     * @param S\r\n     * @param C\r\n     * @return\r\n     */\r\n    public int[] shortestToChar(String S, char C) {\r\n\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        \r\n        // NOTE: for this kind of problem, remember to use Interger.MIN_VALUE or Integer.MAX_VALUE to set min/max values\r\n        int cPosition = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < N; i++) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            ans[i] = i - cPosition;\r\n        }\r\n\r\n        cPosition = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; i--) {\r\n            if (S.charAt(i) == C) {\r\n                cPosition = i;\r\n            }\r\n            // NOTE: cPosition is larger or equal to current index i\r\n            ans[i] = Math.min(ans[i], cPosition - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n// @lc code=end\r\n\r\n"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844183656","body":"We should not care about the value of difference. instead, we want to make sure two pointers reach the intersection node at the same time. In order to do that, we can use two iterations to do that. \r\nIn the first iteration, we will reset the pointer of one linkedlist to the head of another linkedlist after it reaches the tail node. \r\nIn the second iteration, we will move two pointers until they points to the same node. Our operations in first iteration will help us counteract the difference. So if two linkedlist intersects, the meeting point in second iteration must be the intersection point. If the two linked lists have no intersection at all, then the meeting pointer in second iteration must be the tail node of both lists, which is null\r\n\r\n```public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    //boundary check\r\n    if(headA == null || headB == null) return null;\r\n    \r\n    ListNode a = headA;\r\n    ListNode b = headB;\r\n    \r\n    //if a & b have different len, then we will stop the loop after second iteration\r\n    while( a != b){\r\n    \t//for the end of first iteration, we just reset the pointer to the head of another linkedlist\r\n        a = a == null? headB : a.next;\r\n        b = b == null? headA : b.next;    \r\n    }\r\n    \r\n    return a;\r\n}\r\n\r\n```\r\n\r\nComplexity:\r\nO(N) and O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836239329","body":"思路：\r\n将 array -> str -> int, 相加之后重新转换成array[int]\r\n\r\n代码：\r\n\r\n> class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # method 1 list iteration\r\n        # return [int(j) for j in str(int(''.join([str(i) for i in num])) + k)]\r\n\r\n        # method 2, same as method 1, use for-loop explicitly to analyze the complexity\r\n        # as following, the time complexity is O(n)\r\n        # the space complexity is O(1)\r\n        res = []\r\n        for i in num:\r\n            res.append(str(i))\r\n        res = str(int(''.join(res)) + k)\r\n        res = [int(i) for i in res]\r\n        return res\r\n\r\n\r\n\r\n复杂度分析：\r\n\r\n令 n 为数组长度。\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n![Uploading image.png…]()\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837653863","body":"思路\r\n遍历数组，将数组中命中c的值设为0并获得命中的c的index_list，其他值设为无穷大。\r\n再次遍历数组，将其与命中c的list index 做比较，获取绝对值大小\r\n\r\nPython Code:\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str):\r\n        res = []\r\n        zero_point = []\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                res.append(0)\r\n                zero_point.append(i)\r\n            else:\r\n                res.append(float('inf'))\r\n        for i in range(len(res)):\r\n            for j in zero_point:\r\n                if i != j:\r\n                    res[i] = min(res[i], abs(i-j))\r\n        return res\r\n```\r\n\r\n复杂度分析\r\n\r\n令 n 为字符串长度。\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839413437","body":"思路\r\n通过建立一个数组，实现栈的功能。increment考虑长度。\r\n\r\n代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.item = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.item) < self.max_size:\r\n            self.item.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.item:\r\n            return self.item.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.item)\r\n        for i in range(length):\r\n            # attention: it should be <, cannot equals to\r\n            # k is the volume starts from 1, while index start from 0\r\n            if i < min(k, length):\r\n                self.item[i] += val\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：push为O(1)；pop为O(1)，python 中内置的pop last是O(1), increment为O(n))\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840217686","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ''' stack method1 一个不太干净漂亮的栈\r\n         这里的时间复杂度 time complexity 最坏结果是 O(n^2)\r\n         '''\r\n        stack = []\r\n        for i in s:\r\n            if i == ']':\r\n                volume = ''\r\n                tmp = ''\r\n                while stack:\r\n                    val = stack.pop()\r\n                    if val == '[':\r\n                        while stack:\r\n                            a = stack.pop()\r\n                            if a.isdigit():\r\n                                volume = a + volume\r\n                            else:\r\n                                stack.append(a)\r\n                                break\r\n                        break\r\n                    tmp = val + tmp\r\n                stack.append(int(volume) * tmp)\r\n            else:\r\n                stack.append(i)\r\n        return ''.join(stack)\r\n\r\n        ''' method 2 to make it more elegant '''\r\n        # stack = []\r\n        # curNum = 0\r\n        # curString = ''\r\n        # for i in s:\r\n        #     if i == '[':\r\n        #         stack.append(curString)\r\n        #         stack.append(curNum)\r\n        #         curString = ''\r\n        #         curNum = 0\r\n        #     elif i == ']':\r\n        #         num = stack.pop()\r\n        #         prevString = stack.pop()\r\n        #         curString = prevString + curString * num\r\n        #     elif i.isdigit():\r\n        #         curNum = curNum * 10 + int(i)\r\n        #     else:\r\n        #         curString += i\r\n        # return curString\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：方法1 O(N^2)，方法2 O(N)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840925211","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.item = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.item.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.item.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.item[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.item) == 0\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n时间复杂度O(1)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841587977","body":"代码\r\n```\r\n\r\n    def maxChunksToSorted(self, A):\r\n        res, s1, s2 = 0, 0, 0\r\n        for a, b in zip(A, sorted(A)):\r\n            s1 += a\r\n            s2 += b\r\n            res += s1 == s2\r\n        return res\r\n```\r\n\r\n时间复杂度 O(n^2): for 内部嵌套了一个 sorted\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841750285","body":"思路：\r\n这题不太会，链表的内容待补课\r\n\r\n代码：\r\n```\r\nclass Solution(object):\r\ndef rotateRight(self, head, k):\r\n    \"\"\"\r\n    :type head: ListNode\r\n    :type k: int\r\n    :rtype: ListNode\r\n    \"\"\"\r\n    if not head:\r\n        return None\r\n    \r\n    if head.next == None:\r\n        return head\r\n        \r\n    pointer = head\r\n    length = 1\r\n    \r\n    while pointer.next:\r\n        pointer = pointer.next\r\n        length += 1\r\n    \r\n    rotateTimes = k%length\r\n    \r\n    if k == 0 or rotateTimes == 0:\r\n        return head\r\n    \r\n    fastPointer = head\r\n    slowPointer = head\r\n    \r\n    for a in range (rotateTimes):\r\n        fastPointer = fastPointer.next\r\n    \r\n    \r\n    while fastPointer.next:\r\n        slowPointer = slowPointer.next\r\n        fastPointer = fastPointer.next\r\n    \r\n    temp = slowPointer.next\r\n    \r\n    slowPointer.next = None\r\n    fastPointer.next = head\r\n    head = temp\r\n    \r\n    return head\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842328129","body":"思想：\r\n递归，两两交换，注意边界值\r\n\r\n代码：\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        while head and head.next:\r\n            pairs = self.swapPairs(head.next.next)\r\n            next_pairs = head.next\r\n            next_pairs.next = head\r\n            head.next = pairs\r\n            return next_pairs\r\n```\r\n\r\n复杂度分析：\r\n不知道咋分析递归的时间复杂度，空间复杂度应该是 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843253471","body":"```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        if not head.next:\r\n            # 注意此处也是需要用 treeNode 返回的\r\n            return TreeNode(head.val)\r\n\r\n        slow = fast = head\r\n        pre = None\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        pre.next = None\r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n\r\n复杂度分析：\r\n时间复杂度：O(NlogN)\r\n空间复杂度：O(logN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843805691","body":"\r\n\r\n思路：\r\n        假设 pa 是短指针，如果短指针遍历完毕，就从更长的那一个 linked list 重新开始走\r\n\r\n        如果有相交\r\n        这样 相当于拼了一个超长的链表 A(a_start + common) + B(b_start + common)\r\n        也就是无论 a_start 和 b_start 有多长，两个指针遍历结果的都是一样的\r\n        pa 的遍历为：a_start + common + b_start + common\r\n        pb 的遍历为：b_start + common + a_start + common\r\n        如果有相交，在最后一段 common 时，pointer 一定会达成 pa == pb 的循环推出条件\r\n\r\n        如果没有相交，\r\n        相当于遍历了两个链表\r\n\r\n代码：\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ''' method1\r\n        假设 pa 是短指针，如果短指针遍历完毕，就从更长的那一个 linked list 重新开始走\r\n\r\n        如果有相交\r\n        这样 相当于拼了一个超长的链表 A(a_start + common) + B(b_start + common)\r\n        也就是无论 a_start 和 b_start 有多长，两个指针遍历结果的都是一样的\r\n        pa 的遍历为：a_start + common + b_start + common\r\n        pb 的遍历为：b_start + common + a_start + common\r\n        如果有相交，在最后一段 common 时，pointer 一定会达成 pa == pb 的循环推出条件\r\n\r\n        如果没有相交，\r\n        相当于遍历了两个链表\r\n        '''\r\n        if not headA or not headB:\r\n            return\r\n\r\n        pa = headA\r\n        pb = headB\r\n\r\n        while pa != pb:\r\n            if pa:\r\n                pa = pa.next\r\n            else:\r\n                pa = headB\r\n            if pb:\r\n                pb = pb.next\r\n            else:\r\n                pb = headA\r\n        return pa\r\n```\r\n\r\n复杂度：\r\n时间O(n)\r\n空间O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844666610","body":"思路：hash 表，\r\n快慢指针：注意只有有环的时候快慢指针才会相遇，相遇后将fast指针拨回到起点，速度变成跟慢指针一样，再次相遇的时候，返回 fast/slow 所在的节点，即为环的起点\r\n\r\n代码：\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        ''' method 1 via hash'''\r\n        # i = 0\r\n        # dic = {}\r\n        # while head:\r\n        #     if head in dic:\r\n        #         return head\r\n        #     else:\r\n        #         dic[head] = i\r\n        #         i += 1\r\n        #     head = head.next\r\n\r\n        ''' method 2 via fast/slow pointer'''\r\n        fast = slow = head\r\n        while fast:\r\n            if not (fast and fast.next and fast.next.next):\r\n                return\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                fast = head\r\n                break\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n\r\n```\r\n\r\n复杂度：\r\n方法一：时间O(n)，空间O(n)\r\n方法二：时间O(n)，空间O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845687393","body":"思路：\r\n双向链表 + hashtable 讲的特别清楚的一个视频\r\nhttps://www.youtube.com/watch?v=S6IfqDXWa10\r\n\r\n思路：\r\n双向链表，创建 dummy_head 和 dummy_tail\r\n核心在于，\r\nput 要方便删除尾巴(tail)，\r\nget/put 方便的把元素移到头部(head): i.e. 在链表原有位置删除元素 + 在头部新增\r\n在双向链表中，我们都可以通过操作指针完成\r\n\r\n\r\n代码：\r\n```\r\nclass DoubleLinkedListNode:\r\n    def __init__(self, k=None, v=None):\r\n        self.k = k\r\n        self.v = v\r\n        self.next = self.prev = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashtable = {}\r\n        self.head = DoubleLinkedListNode()\r\n        self.tail = DoubleLinkedListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashtable:\r\n            node = self.hashtable[key]\r\n            self.remove_node(node)\r\n            self.add_head(node)\r\n            return node.v\r\n        return -1\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashtable:\r\n            node = self.hashtable[key]\r\n            node.v = value\r\n            self.remove_node(node)\r\n            self.add_head(node)\r\n        else:\r\n            new_node = DoubleLinkedListNode(key, value)\r\n            if len(self.hashtable) >= self.capacity:\r\n                self.remove_tail()\r\n            self.hashtable[key] = new_node\r\n            self.add_head(new_node)\r\n\r\n    def add_head(self, node):\r\n        '''\r\n        将 传入的 node 放到头部\r\n        :param node:\r\n        :return:\r\n        '''\r\n        first = self.head.next\r\n        self.head.next = node\r\n        node.prev = self.head\r\n        node.next = first\r\n        first.prev = node\r\n\r\n    def remove_node(self, node):\r\n        '''\r\n        将传入的 node 在原有位置删除\r\n        :param node:\r\n        :return:\r\n        '''\r\n        prev = node.prev\r\n        next = node.next\r\n        prev.next = next\r\n        next.prev = prev\r\n\r\n    def remove_tail(self):\r\n        '''\r\n        删除双向链表的尾巴\r\n        :return:\r\n        '''\r\n        node = self.tail.prev\r\n        self.remove_node(node)\r\n        del self.hashtable[node.k]\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```\r\n\r\n复杂度分析：\r\n时间 O(1)\r\n空间 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846401953","body":"代码：\r\n```\r\n# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\n\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n\r\n```\r\n\r\n复杂度：\r\n时间 O(n)\r\n空间 O(Height)\r\n其实不太懂怎么分析这种递归额"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836244897","body":"### 思路：\r\n将list转成数值，求和之后，分别取余/取除数，然后倒序输出\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = 0\r\n        for n in num:\r\n            res = res * 10 + n \r\n        res += k\r\n        result = []\r\n        while(res>=0):\r\n            num = res%10\r\n            res/=10\r\n            result.append(num)\r\n        return result[::-1]\r\n```\r\n### 复杂度\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838397776","body":"## 思路\r\n- 1.空间换时间\r\n 先将给定字符出现的位置保存在一个下标数组中，遍历整个数组，求整个数组的值到下标数组的最小距离绝对值\r\n- 2.双指针方法\r\n#### 方法1\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num = []\r\n        n = len(s)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                num.append(i)\r\n        result = []\r\n        for i in range(n):\r\n            result.append(min([abs(i-nu)for nu in num]))\r\n        return result\r\n```\r\n#### 方法2：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c: prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```\r\n##复杂度分析\r\n- 1.空间换时间复杂度\r\n    时间复杂度为$O(N*K)$\r\n    空间复杂度为$O(N)$\r\n- 2.双指针方法\r\n    时间复杂度为 $O(n)$\r\n    空间复杂度为$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839788489","body":"### 思路\r\n使用数组模拟栈，定义变量top记录当前数组中元素的数量\r\n### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x \r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stack[self.top+1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k,self.top+1)\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：pop函数、push函数为O(1), increment函数为O(k)\r\n空间复杂度：O（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641670","body":"### 思路\r\n构建辅助栈，从后向前遍历字符串s中每个字符，将非数字的字符入栈，后续栈需要反转\r\n### 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[]\r\n        length = len(s)\r\n        i = length - 1\r\n        while i>=0:\r\n            if not s[i].isdigit():\r\n                stack.append(s[i])\r\n                i -= 1\r\n            else:\r\n                num = ''\r\n                while s[i].isdigit() and i>=0:\r\n                    num = s[i]+num\r\n                    i -= 1\r\n                sub = ''\r\n                while stack[-1]!=']':\r\n                    tmp = stack.pop()\r\n                    if tmp != '[':\r\n                        sub += tmp\r\n                stack.pop()\r\n                sub = int(num)*sub\r\n                stack.append(sub)\r\n        stack.reverse()\r\n        return ''.join(stack)\r\n```\r\n### 复杂度分析\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841110585","body":"### 思路：\r\n两个栈，辅助栈主要是用于pop和peek时使用，保证pop和peek都是O(1)\r\n### 代码：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1=[]\r\n        self.s2=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.s2:\r\n            return self.s2.pop()\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.s2:\r\n            return self.s2[-1]\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.s1 and not self.s2\r\n\r\n```\r\n### 复杂度\r\n时间复杂度: O(N)\r\n空间复杂度: O(N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666681","body":"### 思路\r\n单调栈，注意，分成块前提是前一个块的最大值，小于后一个块的最小值\r\n维护一个单调栈，遇到大雨等于栈顶元素的数字压入栈，遇到小于栈顶元素数字后，首先是取出栈顶元素缓存，然后循环，如果栈不为空，且新的栈顶元素大于当前数字，移除栈顶元素(单调栈元素个数实际上是遍历到当前数字之前可以拆分成的块的个数)。\r\n### 代码 python\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if not stack or stack[-1] <= num:\r\n                stack.append(num)\r\n            else:\r\n                cur_max = stack.pop()\r\n                while stack and stack[-1]>num:\r\n                    stack.pop()\r\n                stack.append(cur_max)\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n时间复杂度为 O(N)\r\n空间复杂度为O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841801842","body":"### 思路\r\n采用快慢指针的方法，让快指针先走k次，然后慢指针再和快指针一起走，当快指针走完时，慢指针会刚好来到k的位置。此时慢指针的下一个节点就是新的头节点，慢指针当前的节点就是尾节点，最后把快指针当前的节点链上原来的头节点。\r\n### 代码\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next:\r\n            return head \r\n        len = 0\r\n        cur = head\r\n        while cur:\r\n            len+=1\r\n            cur = cur.next\r\n        k %= len \r\n        if k == 0:\r\n            return head \r\n        fast,slow = head,head \r\n        for _ in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            fast = fast.next \r\n            slow = slow.next \r\n        newHead = slow.next \r\n        slow.next = None\r\n        fast.next = head\r\n        return newHead \r\n```\r\n### 复杂度\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841961108","body":"### 思路\r\n终止条件：链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\r\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\r\n用 head 表示原始链表的头节点，新的链表的第二个节点，用 tmp表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 tmp.next。令 head.next = swapPairs(tmp.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 tmp.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 tmp\r\n### 代码\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        tmp = head.next\r\n        head.next = self.swapPairs(next.next)\r\n        tmp.next = head\r\n        return tmp\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842946394","body":"### 思路\r\n采用数组存放链表所有的值，由于是有序的数组，所以中间的值就是搜索树的root，递归创建二叉搜索树\r\n### 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return\r\n        nums=[]\r\n        while head:\r\n            nums.append(head.val)\r\n            head=head.next\r\n        return self.helper(nums)\r\n    def helper(self,nums):\r\n        if not nums:\r\n            return None\r\n        index = len(nums)//2\r\n        root = TreeNode(nums[index])\r\n        root.left = self.helper(nums[:index])\r\n        root.right = self.helper(nums[index+1:])\r\n        return root\r\n\r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度O(log N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844223977","body":"### 思路\r\n两个指针p,q分别从A和B开始遍历，p指针A遍历到结束接入到B，q指针B遍历到结束接入到A，p和q重合的时候返回p\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p,q = headA, headB\r\n        while p!= q:\r\n            p = p.next if p else headB\r\n            q = q.next if q else headA\r\n        return p\r\n```\r\n### 复杂度\r\n时间复杂度：O(M+N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844638388","body":"### 思路\r\n快慢指针，快指针走两步一次，慢指针走一步一次，两指针相遇后，fast指向链表头部，fast和slow均每次走一步，再次相遇即为环的起点\r\n### 代码\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow = head,head\r\n        while fast and fast.next:\r\n            \r\n            fast = fast.next.next \r\n            slow = slow.next\r\n            \r\n            if fast == slow:\r\n                fast = head \r\n                while fast != slow:\r\n                    fast = fast.next \r\n                    slow = slow.next \r\n                return fast \r\n        return None \r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846004557","body":"### 思路\r\n通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\r\n双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\r\n1.首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在O(1) 的时间内完成 get 或者 put 操作。\r\n2.对于 get 操作，首先判断 key 是否存在：\r\n      如果 key 不存在，则返回 -1；\r\n      如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\r\n3. 对于 put 操作，首先判断 key 是否存在：\r\n      如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\r\n      如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\r\n### 代码：\r\n```\r\nclass ListNode:\r\n    def __init__(self,key=None,value=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.head =  ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n\r\n    def move_to_tail(self,key):\r\n        node = self.hashmap[key]\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.prev = self.tail.prev \r\n        node.next = self.tail\r\n        self.tail.prev.next = node\r\n        self.tail.prev = node\r\n    def get(self, key: int) -> int:\r\n        if key in self.hashmap:\r\n            self.move_to_tail(key)\r\n        res = self.hashmap.get(key,-1)\r\n        if res == -1:\r\n            return res \r\n        else:\r\n            return res.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashmap:\r\n            self.hashmap[key].value = value\r\n            self.move_to_tail(key)\r\n        else:\r\n            if len(self.hashmap) == self.capacity:\r\n                self.hashmap.pop(self.head.next.key)\r\n                self.head.next = self.head.next.next\r\n                self.head.next.prev = self.head \r\n            new = ListNode(key,value)\r\n            self.hashmap[key]=new\r\n            new.prev = self.tail.prev\r\n            new.next = self.tail \r\n            self.tail.prev.next = new\r\n            self.tail.prev = new \r\n```\r\n### 复杂度：\r\n时间复杂度 ：哈希操作O(1)\r\n空间复杂度： 存取占据O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846318266","body":"### 思路\r\n递归方法\r\n找出终止条件：当前节点为空\r\n返回值：节点为空时返回0，节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值\r\n### 代码\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        def helper(root):\r\n            if not root:\r\n                return 0\r\n            left = helper(root.left)\r\n            right = helper(root.right)\r\n            return max(left,right)+1\r\n        return helper(root)\r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度，取决于树的深度，最坏则是O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846524866","body":"### 思路：\r\n递归结束条件，根节点是否相同，左子树是否相同，右子树是否相同\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        def helper(l,r):\r\n            if not l and not r:\r\n                return True\r\n            elif not l or not r:\r\n                return False \r\n            elif l.val != r.val:\r\n                return False\r\n            else:\r\n                return helper(l.left,r.left) and helper(l.right,r.right)\r\n        return helper(p,q)\r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度O(logN)，最差O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836268613","body":"## 思路：\r\n从数组尾部取值与 K 相加\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n  const ans = [];\r\n  let len = num.length;\r\n\r\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\r\n    if (i >= 0) {\r\n      k += num[i];\r\n    }\r\n    ans.push(k % 10);\r\n    k = parseInt(k / 10);\r\n  }\r\n\r\n  return ans.reverse();\r\n};\r\n```\r\n\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838192744","body":"## 代码：\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let ans = new Array(s.length).fill(10001);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      ans[i] = 0;\r\n      continue;\r\n    }\r\n    if (s[i - 1] !== void 0) {\r\n      ans[i] = ans[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let j = s.length - 1; j >= 0; j--) {\r\n    if (s[j + 1] !== void 0) {\r\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\r\n    }\r\n  }\r\n\r\n  return ans;\r\n};\r\n```\r\n\r\n## 复杂度分析：\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839741958","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nclass CustomStack {\r\n  constructor(n) {\r\n    this.maxTop = n;\r\n    this.top = 0;\r\n    this.stack = [];\r\n  }\r\n\r\n  push(element) {\r\n    if (this.top < this.maxTop) {\r\n      this.stack.push(element);\r\n      this.top++;\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    if (this.top > 0) {\r\n      this.top--;\r\n      return this.stack.pop();\r\n    }\r\n    return -1;\r\n  }\r\n\r\n  increment(k, val) {\r\n    k = Math.min(k, this.top);\r\n    for (let i = 0; i < k; i++) {\r\n      this.stack[i] += val;\r\n    }\r\n  }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840561718","body":"## 思路\r\n\r\n辅助栈\r\n\r\n## 代码\r\n```js\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n\r\n  for (const char of s) {\r\n    if (char === ']') {\r\n      let repeatStr = '';\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      stack.pop();\r\n      let repeatNum = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        repeatNum = stack.pop() + repeatNum;\r\n      }\r\n      repeatStr = repeatStr.repeat(parseInt(repeatNum));\r\n      stack.push(repeatStr);\r\n    } else {\r\n      stack.push(char);\r\n    }\r\n  }\r\n\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841189740","body":"```js\r\nclass MyQueue {\r\n  constructor() {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n  }\r\n\r\n  push(element) {\r\n    this.pushStack.push(element);\r\n  }\r\n\r\n  pop() {\r\n    if (!this.popStack.length) {\r\n      while (this.pushStack.length) {\r\n        this.popStack.push(this.pushStack.pop());\r\n      }\r\n    }\r\n    return this.popStack.pop();\r\n  }\r\n\r\n  peek() {\r\n    if (!this.popStack.length) {\r\n      while (this.pushStack.length) {\r\n        this.popStack.push(this.pushStack.pop());\r\n      }\r\n    }\r\n    return this.popStack[this.popStack.length - 1];\r\n  }\r\n\r\n  empty() {\r\n    return !this.pushStack.length && !this.popStack.length;\r\n  }\r\n\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841818849","body":"```js\r\nvar rotateRight = function(head, k) {\r\n  if (!head || !head.next || k === 0) {\r\n    return head;\r\n  }\r\n  let p = head;\r\n  let len = 1;\r\n  while (p.next) {\r\n    p = p.next;\r\n    len++;\r\n  }\r\n  k = k % len;\r\n  if (k === 0) {\r\n    return head;\r\n  }\r\n  p.next = head;\r\n  for (let i = 0; i < len - k; i++) {\r\n    p = p.next;\r\n  }\r\n  let newLink = p.next;\r\n  p.next = null;\r\n  return newLink;\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842295358","body":"## 思路\r\n递归\r\n## 代码\r\n```js\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next) {\r\n    return head;\r\n  }\r\n\r\n  const newHead = head.next;\r\n  head.next = swapPairs(newHead.next);\r\n  newHead.next = head;\r\n  return newHead;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842910938","body":"## 思路\r\n递归，快慢双指针\r\n\r\n## 代码\r\n```js\r\nvar sortedListToBST = function(head) {\r\n  if (!head) {\r\n    return null;\r\n  }\r\n\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head === tail) {\r\n    return null;\r\n  }\r\n\r\n  let fast = head;\r\n  let slow = head;\r\n\r\n  while (fast !== tail && fast.next !== tail) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  const root = new TreeNode(slow.val);\r\n\r\n  root.left = dfs(head, slow);\r\n  root.right = dfs(slow.next, tail);\r\n\r\n  return root;\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(NlogN)\r\n- 空间复杂度 O(logN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843647998","body":"## 思路\r\n双指针\r\n\r\n## 代码\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n  let P1 = headA, P2 = headB;\r\n  while (P1 != P2) {\r\n    P1 = P1 ? P1.next : headB;\r\n    P2 = P2 ? P2.next : headA;\r\n  }\r\n  return P1 ? P1 : null;\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度：O(M+N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845063452","body":"```js\r\nvar detectCycle = function(head) {\r\n  let fast = head;\r\n  let slow = head;\r\n\r\n  while (true) {\r\n    if (fast === null || fast.next === null) {\r\n      return null;\r\n    }\r\n\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n\r\n    if (fast === slow) {\r\n      break;\r\n    }\r\n  }\r\n\r\n  fast = head;\r\n  while (fast !== slow) {\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  return fast;\r\n};\r\n```\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845978652","body":"```js\r\nclass ListNode {\r\n  constructor(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.prev = null\r\n    this.next = null\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity\r\n    this.hashMap = {}\r\n    this.dummyHead = new ListNode(null, null)\r\n    this.dummyTail = new ListNode(null, null)\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyTail.prev = this.dummyHead\r\n  }\r\n\r\n  _isFull() {\r\n    return Object.keys(this.hashMap).length === this.capacity;\r\n  }\r\n\r\n  _moveToHead(node) {\r\n    const head = this.dummyHead.next;\r\n    node.next = head;\r\n    head.prev = node;\r\n    node.prev = this.dummyHead;\r\n    this.dummyHead.next = node;\r\n  }\r\n\r\n  _removeNode(node) {\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n    node.prev = null;\r\n    node.next = null;\r\n    return node;\r\n  }\r\n\r\n  get(key) {\r\n    if (key in this.hashMap) {\r\n      const node = this.hashMap[key];\r\n      this._moveToHead(this._removeNode(node));\r\n      return node.value;\r\n    } else {\r\n      return -1;\r\n    }\r\n  }\r\n\r\n  put(key, value) {\r\n    if (key in this.hashMap) {\r\n      const node = this.hashMap[key];\r\n      node.value = value;\r\n      this._moveToHead(this._removeNode(node));\r\n    } else {\r\n      if (this._isFull()) {\r\n        const node = this.dummyTail.prev;\r\n        delete this.hashMap[node.key];\r\n        this._removeNode(node);\r\n      }\r\n      const node = new ListNode(key, value);\r\n      this.hashMap[key] = node;\r\n      this._moveToHead(node);\r\n    }\r\n  }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846341830","body":"```js\r\nvar maxDepth = function(root) {\r\n  if (!root) return 0;\r\n  \r\n  return Math.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(H)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyi123456":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836270960","body":"## 题目思路\r\n1.拆开每一位，用进位相加\r\n2.当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n## 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int sum = 0, carry = 0;\r\n        int i = num.length-1;\r\n        List<Integer> res = new LinkedList<Integer>();\r\n        while(i>=0 || k>0){\r\n            int x = i>=0? num[i]:0;\r\n            int y = k>0?  k%10:0;\r\n            sum = x+y+carry;\r\n            carry = sum/10;\r\n            i -= 1;\r\n            k = k/10;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(carry!=0) res.add(0,carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度 max(n,k) n为数组长度，k为数字位数\r\n空间复杂度 max(n,k) n为数组长度，k为数字位数"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839766929","body":"`class CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840580971","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836272330","body":"# c++\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>ans;int carry=0;\r\n        for(int i=num.size()-1;i>=0;i--)\r\n        {\r\n            int a=k%10;k/=10;\r\n            int b=(num[i]+a+carry)%10;\r\n            carry=(num[i]+a+carry)/10;\r\n            ans.push_back(b);\r\n        }\r\n        while(k>0||carry>0)\r\n        {   int b=k%10;k/=10;\r\n            ans.push_back((b+carry)%10);\r\n            carry=(b+carry)/10;\r\n        }\r\n        reverse(ans.begin(),ans.end());\r\n         return ans;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838286251","body":"### 解题思路\r\n参考官方题解，用`pre`存储上一个c出现的位置，当```s[i]=c```时更新```pre=i```\r\n先从左到右遍历，`i-pre`即为到改字符往左到c的距离\r\n在从右到左遍历，`pre-i`即为到改字符往右到c的距离，取左右距离的最小值\r\n### 代码\r\n### c++\r\n```class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int>ans(s.size());\r\n        int i,pre=-999999;\r\n        for(i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=i-pre;\r\n        }\r\n        pre=999999;\r\n        for(i=s.size()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)pre=i;\r\n            ans[i]=min(ans[i],pre-i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839617277","body":"### C++\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int>st;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        st.resize(maxSize);top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=st.size()-1)st[++top]=x;\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1)return -1;\r\n        top--;return st[top+1];\r\n       // return st[top--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim=min(k,top+1);\r\n        //int lim=top+1<k?top+1:k;\r\n        for(int i=0;i<lim;i++)\r\n            st[i]+=val;\r\n    }\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630858","body":"C++\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        stack<int>num;\r\n        stack<string>str;\r\n        int curNum=0;\r\n        for(char c:s)\r\n        {\r\n            if(c>='0'&c<='9')\r\n                curNum=curNum*10+c-'0';\r\n            else if(c>='a'&&c<='z')\r\n                res+=c;\r\n            else if(c=='[')\r\n                {num.push(curNum);\r\n                 curNum=0;\r\n                 str.push(res);\r\n                 res=\"\";\r\n                }\r\n            else if(c==']')\r\n                {\r\n                    string tmp=str.top();str.pop();int n=num.top();num.pop();\r\n                    for(int i=0;i<n;i++)\r\n                        tmp+=res;\r\n                    res=tmp;\r\n                }\r\n                \r\n        }\r\n        return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840979822","body":"```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int>st1,st2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        st1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int t;\r\n       if(st2.empty())\r\n       {\r\n           while(!st1.empty())\r\n           {\r\n               t=st1.top();\r\n               st1.pop();\r\n               st2.push(t);\r\n           }\r\n       }\r\n       t=st2.top();st2.pop();\r\n       return t;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n      int t;\r\n       if(st2.empty())\r\n       {\r\n           while(!st1.empty())\r\n           {\r\n               t=st1.top();\r\n               st1.pop();\r\n               st2.push(t);\r\n           }\r\n       }\r\n       t=st2.top();\r\n       return t;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return st1.empty()&&st2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841789356","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(!head)return NULL;\r\n        ListNode*tail=head;\r\n        int len=1;\r\n        while(tail->next)\r\n        {\r\n            tail=tail->next;len++;\r\n        }\r\n        tail->next=head;tail=tail->next;\r\n        k%=len;\r\n        for(int i=1;i<=len-k-1;i++)\r\n        {\r\n            tail=tail->next;\r\n        }\r\n        head=tail->next;\r\n        tail->next=NULL;\r\n        return head;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842301088","body":"```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(!head||!head->next)return head;\r\n        ListNode*next=head->next;\r\n        head->next=swapPairs(next->next);\r\n        next->next=head;\r\n        return next;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843279406","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int>v;\r\n    TreeNode* dfs(int l,int r)\r\n    {   if(l>r)return NULL;\r\n        int mid=(l+r)/2;\r\n        TreeNode*t=new TreeNode;t->val=v[mid];\r\n        t->left=dfs(l,mid-1);\r\n        t->right=dfs(mid+1,r);\r\n        return t;\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        while(head){v.push_back(head->val);head=head->next;}\r\n        return dfs(0,v.size()-1);\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844161300","body":"```\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    if (headA == null || headB == null) return null;\r\n    ListNode pA = headA, pB = headB;\r\n    while (pA != pB) {\r\n        pA = pA == null ? headB : pA.next;\r\n        pB = pB == null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844900774","body":"```\r\nListNode *detectCycle(ListNode *head) {\r\n        if(!head||!head->next)return NULL;\r\n        ListNode*fast=head->next->next,*slow=head->next;\r\n        while(fast!=slow)\r\n        {   if(!fast||!fast->next)return NULL;\r\n            fast=fast->next->next;\r\n            slow=slow->next;\r\n        }\r\n        fast=head;\r\n        while(fast!=slow)\r\n        {   \r\n            fast=fast->next;\r\n            slow=slow->next;\r\n        }\r\n        return fast;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845951954","body":"```\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            cache[key] = node;\r\n            \r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode* removed = removeTail();\r\n                cache.erase(removed->key)\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846365283","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root)return 0;\r\n        return 1+max(maxDepth(root->left),maxDepth(root->right));\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846432781","body":"```\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p==NULL&&q==NULL)return true;\r\n        if(p==NULL||q==NULL)return false;\r\n        if(p->val!=q->val)return false;\r\n        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linzeliang1222":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836279098","body":"## 思路\r\n\r\n-   从最低位开始加，满10用carry进1，最后还要判断最终有没有进1位\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length - 1;\r\n        int carry = 0;\r\n\r\n        while (n >= 0 || k != 0) {\r\n            int a = n < 0 ? 0 : num[n];\r\n            int b = k % 10;\r\n\r\n            int temp = (a + b + carry) % 10;\r\n            carry = (a+ b + carry) / 10;\r\n            res.add(temp);\r\n            n--;\r\n            k /= 10;\r\n        }\r\n        if (carry == 1) {\r\n            res.add(1);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618559","body":"## 思路\r\n\r\n-   使用一个res数组，而且要初始化为Integer.MAX_VALUE\r\n\r\n-   从左到右遍历字符串，直到遇到我们的目标字符时候停下来\r\n\r\n-   以目标字符为中心，pre和next双指针向两边移动，并且给数组赋值，从1开始递增\r\n\r\n-   如果指针再移动过程中遇到当前的值大于等于左边/右边的值，那么就结束该指针的移动\r\n\r\n    ![](https://img2020.cnblogs.com/blog/2067154/202011/2067154-20201102004404706-1773904769.png)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Arrays;\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int len = S.length();\r\n        int[] res = new int[len];\r\n        // 填充最大值\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            //每次遇到e时候，就进行pre和next的移动\r\n            if (S.charAt(i) == C) {\r\n                res[i] = 0;\r\n                int pre = i-1;\r\n                int next = i+1;\r\n                int t = 1;\r\n                // 赋值的条件是t要小于等于前一个/后一个元素的值\r\n                // 进行左移动赋值\r\n                while (pre >= 0 && t < res[pre]) {\r\n                    res[pre--] = t++;\r\n                }\r\n                t = 1;\r\n                // 进行右移动赋值\r\n                while (next < len && t < res[next]) {\r\n                    res[next++] = t++;\r\n                }\r\n            }\r\n        }\r\n        // 得到结果\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，其中 N 为字符串长度。\r\n- 空间复杂度：$O(N)$，其中 N 为res数组长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839479151","body":"## 思路\r\n\r\n-   利用数组来存储栈的元素\r\n-   通过一个point指针的移动完成栈的操作\r\n-   进行增量操作时，需要判断操作的元素个数k是否大于当前栈中的元素容量\r\n\r\n### 代码\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    private int size;\r\n    private int[] stack;\r\n    private int point;\r\n\r\n    public CustomStack(int maxSize) {\r\n        size = maxSize;\r\n        stack = new int[size];\r\n        point = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (point < size) {\r\n            stack[point++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (point > 0) {\r\n            return stack[--point];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < point; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n-   时间复杂度：O(1)\r\n-   空间复杂度：O(N)，N为栈的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840641163","body":"## 思路\r\n\r\n-   创建两个栈进行解题，一个用来存放数字，另一个用来临时存放子字符串\r\n-   由于可能会在`[]`中还包含其他的`[]`，所以我们只要遇到`[`就先将其前面的字符串暂时入栈，稍后再进行计算\r\n-   如果遇到`]` ，则将存放数字的栈和存放子字符串的栈分别出栈一个，然后进行字符串的拼接，然后再将该字符串作为答案的一部分进行下一轮迭代计算\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<Integer> times = new LinkedList<Integer>();\r\n        Deque<String> stringStack = new LinkedList<String>();\r\n        StringBuilder res = new StringBuilder();\r\n        int count = 0;\r\n\r\n        for (Character c : s.toCharArray()) {\r\n            // 如果为数字，则记录数字，数字有可能有十位或者百位\r\n            if (isNum(c)) {\r\n                count = count * 10 + Integer.parseInt(\"\" + c);\r\n            } else if (c == '[') { // 如果为左中括号，则将数字和当前的res进栈\r\n                times.push(count);\r\n                stringStack.push(res.toString());\r\n                // 注意还要将res置空，因为要开始下一轮的字符串统计，上一轮的字符串已经先暂存到栈中去了\r\n                res = new StringBuilder();\r\n                // 次数也要置为0\r\n                count = 0;\r\n            } else if (c == ']') { // 如果为右中括号，则要开始计算本次统计的res，添加到上一个字符串的末尾\r\n                // 获取次数\r\n                count = times.pop();\r\n                StringBuilder curString = new StringBuilder(stringStack.pop());\r\n                for (int i = 0; i < count; i++) {\r\n                    curString.append(res);\r\n                }\r\n                // 将拼接好后的字符串作为结果进行下一轮迭代\r\n                res = curString;\r\n                count = 0;\r\n            } else {\r\n                // 如果都是字母的话仅进行平解字符串即可\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n\r\n    public boolean isNum(char c) {\r\n        // 判断字符是否为数字\r\n        if (c <= '9' && c >= '0') {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，N为字符串的长度\r\n- 空间复杂度：$O(N)$，N为字符串的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841318784","body":"## 思路\r\n\r\n-   即然是使用两个栈，那么一个栈就用来做辅助栈，一个栈用来存元素\r\n-   我们将栈顶作为队头，将栈底作为队尾，所以如果要push数据的话，先将stack1栈的数据暂时存到stack2辅助栈中，然后将要插入的数据push进入stack1，最后再将stack2的暂存的数据填回到stack1中**（注意，回填元素时顺序不能乱）**\r\n-   pop时，就是将栈的元素最后一个pop出去，由于我们将队头做为栈顶，所以stack1的pop其实就是出队操作\r\n-   empty：要判断队列是否为空，直接判断stack1是否为空即可\r\n-   由于栈是基于LinkedList实现的，peek时即查看的是栈顶的元素，所以直接peek就是查看队头的元素\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nclass MyQueue {\r\n\r\n    LinkedList<Integer> stack1;\r\n    LinkedList<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>();\r\n        stack2 = new LinkedList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!stack1.isEmpty()) {\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack1.push(x);\r\n        while (!stack2.isEmpty()) {\r\n            stack1.push(stack2.pop());\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        return stack1.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        return stack1.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：\r\n    - push: $O(N)$\r\n    - pop: $O(1)$\r\n    - peek: $O(1)$\r\n    - empty: $O(1)$\r\n- 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667123","body":"## 思路\r\n\r\n-   利用**单调递增栈**来解题\r\n    -   遍历数组，将元素存入栈中，再利用max记录当前栈顶的最大值\r\n    -   如果遇到比当前栈元素大的值，那么可以**直接入栈**，因为可以单独分一块；但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素**依次出栈**，直到遇到**小于等于**该值的元素停止出栈，然后将max再push入栈（push的这个max就代表了这一个块）\r\n        -   例如：有该数组 {1, 1, 3, 4, 5, 2, 6, 7}，此时栈为{1, 1, 3, 4, 5}\r\n        -   接下来遍历到2了，2比max即5小，所以开始出栈，顺序是：5、4、3，由于1小于2，所以停止出栈，接下来将max(5)入栈，此时栈为：{1, 1, 5}\r\n    -   不断遍历，直到数组遍历结束，此时栈中有多少个元素就代表有多少个块了\r\n-   分块规则：**后一块元素的最小值大于等于前一块元素的最大值**\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.LinkedList;\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        int max = arr[0];\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] < max) {\r\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            } else {\r\n                stack.push(arr[i]);\r\n                max = stack.peek();\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$， N 为数组长度\r\n- 空间复杂度：$O(N)$，N为栈的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841832633","body":"\r\n\r\n## 题目\r\n\r\n[61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n## 思路1\r\n\r\n-   可以将链表首位相连接，变成一个循环链表\r\n-   再通过`len - k % len`可得出需要将指向head的引用往后移动多少，将head前一个（即新的链表的尾部）的next指向null，最后返回head即可\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果出现链表为空、链表的元素只有一个、k为0，那么就直接返回head\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null || k == 0) {\r\n            return head;\r\n        }\r\n\r\n        //计算链表的长度\r\n        ListNode oldHead = head;\r\n        ListNode newHead = null;\r\n        int len = 1;\r\n        while (oldHead.next != null) {\r\n            oldHead = oldHead.next;\r\n            len++;\r\n        }\r\n        oldHead.next = head;\r\n        //减1是为了只获取到新的头结点前一个结点\r\n        k = len - k % len + 1;\r\n        while (k > 0) {\r\n            head = head.next;\r\n            k--;\r\n        }\r\n        \r\n        newHead = head.next;\r\n        head.next = null;\r\n        \r\n        return newHead;\r\n    }\r\n}\r\n```\r\n\r\n## 思路2\r\n\r\n-   利用双指针，先求出总的链表长度len，再在不超过链表的长度的移动距离`k = k % len`，然后让fast指针后移k个位置，然后将快慢指针同时后移，直到fast指针到达最后一个结点停止移动。然后用newHead引用记录low.next这个结点（就是我们新链表的头结点），将fast.next指向head，low.next指向null，最后返回newHead即可\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果出现链表为空、链表的元素只有一个、k为0，那么就直接返回head\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null || k == 0) {\r\n            return head;\r\n        }\r\n\r\n        //先定义快、慢指针\r\n        ListNode low = head;\r\n        ListNode fast = head;\r\n        //临时的指针\r\n        ListNode tmp = head;\r\n\r\n        //计算链表的总长度\r\n        int len = 1;\r\n        while (tmp.next != null) {\r\n            tmp = tmp.next;\r\n            len++;\r\n        }\r\n        //移动的距离不超过链表的长度\r\n        k = k % len;\r\n\r\n        //移动fast指针k长度\r\n        for (int i = 0; i < k; i++) {\r\n            fast = fast.next;\r\n        }\r\n\r\n        //双指针同时移动\r\n        while (fast.next != null) {\r\n            low = low.next;\r\n            fast = fast.next;\r\n        }\r\n        \r\n        fast.next = head;\r\n        ListNode newHead = low.next;\r\n        low.next = null;\r\n        \r\n        return newHead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841846194","body":"## 思路1\r\n\r\n-   链表可以创建一个头结点来辅助解题，再创建一个指针指向头结点（该指针是把链表连起来用的），然后按照1指向3、2指向1完成交换，指针也下移两位，一直循环，直到刚好交换完或者剩下一个结点时候结束循环，完成交换\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        //链表一般可以考虑创建一个头结点来辅助解题\r\n        ListNode newHead = new ListNode(-1);\r\n        ListNode cur = newHead;\r\n        //将头指针指向下一个要排序的head\r\n        cur.next = head;\r\n\r\n        //刚好交换完或者剩下一个结点时候结束循环\r\n        while (head != null && head.next != null) {\r\n            //改变指针指向交换后的左结点\r\n            cur.next = head.next;\r\n            \r\n            //进行交换\r\n            head.next = head.next.next;\r\n            cur.next.next = head;\r\n            \r\n            //两个指针都移动后两位\r\n            cur = head;\r\n            head = head.next;\r\n        }\r\n        //返回第一个结点\r\n        return newHead.next;\r\n    }\r\n}\r\n```\r\n\r\n## 思路2\r\n\r\n-   递归实现，下一次递归传递的是要交换的第一个结点，若还有结点，就继续递归。我们可以从后往前看，将交换完的链表返回给前一个调用该函数的他的next，然后依次推导，最后返回头结点（**注意，返回的要是第二个结点，因为第一个结点和第二个结点交换完后第二个就变成了第一个结点了**）\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        //刚好交换完或者剩下一个结点时候结束递归\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        //用来记录第二个结点的\r\n        ListNode p1 = head.next;\r\n        //第一个结点的下一个为交换好后的链表\r\n        head.next = swapPairs(p1.next);\r\n        //必须要放到执行swapPairs函数后面执行，否则如果先执行，那么函数里面的p1.next就指错了，造成栈溢出\r\n        p1.next = head;\r\n        return p1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842943488","body":"## 题目\r\n\r\n[109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n## 思路\r\n\r\n-   二叉搜索树就是左孩子比根节点小，右孩子比根节点大，而且左右两个子树的高度差不大于1称为二叉搜索树\r\n-   通过观察这个链表转换成的搜索树可以发现，根节点其实就是链表的中间的结点，左孩子就是左边一半链表的中间的结点，右孩子就是右边一半链表的中间的结点\r\n-   所以可以利用递归（自顶向下）方法来解题，递归的截止条件就是遍历到本段链表末尾\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode pre = null;\r\n        while (fast != null && fast.next != null) {\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        pre.next = null;\r\n\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(NlogN)$，其中 N 为链表的长度。\r\n- 空间复杂度：$O(logN)$，其中logN为树的深度，递归时所创建的空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843891662","body":"## 题目\r\n\r\n[160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n## 思路1\r\n\r\n-   我们可以将另一端链表虚拟拼接（如果实际改变指针的话会导致死循环）到本段链表后面（null不要省略），两个链表此时时灯等长的。然后两个链表同时从头开始遍历，如果存在相交的结点，那么`p1 != p2`就不会成立，因此找到答案，退出循环；如果没有找到答案，最后都会为null，同样跳出循环，得到结果\r\n-   例1（相交）：\r\n    -   headA={4, 2, 8, 4, 5}，headB={5, 0, 1, 8, 4, 5}，虚拟拼接后为：\r\n    -   headA={4, 2, 8, 4, 5, null, 5, 0, 1, 8, 4, 5, null}，headB={5, 0, 1, 8, 4, 5, null, 4, 2, 8, 4, 5, null}\r\n    -   当索引为9时，结点都是8，此时退出循环，找到答案\r\n-   例2（不相交）：\r\n    -   headA={1, 2, 3}，headB={4, 3, 2, 1}，虚拟拼接后为：\r\n    -   headA={1, 2, 3, null, 4, 3, 2, 1, null}，headB={4, 3, 2, 1, null, 1, 2, 3, null}\r\n    -   当索引为8时，两个指针都指向null，此时也退出循环，不过返回的时null，即没有找到答案\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // 如果其中一个存在空链表，直接返回null\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        // 当还没相遇时，一直遍历下取，如果两个都没有相遇，最终都为null，那么也会退出循环\r\n        while (p1 != p2) {\r\n            if (p1 == null) {\r\n                p1 = headB;\r\n            } else {\r\n                p1 = p1.next;\r\n            }\r\n            if (p2 == null) {\r\n                p2 = headA;\r\n            } else {\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(M+N)$，其中 M、N 为链表长度\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n\r\n## 思路2\r\n\r\n-   使用哈希表，其中一个链表存到哈希表中，然后遍历另一个链表，将其添加到原来的哈希表中，如果存在，就是找到相交的结点了\r\n\r\n### 代码\r\n\r\n```java\r\nimport java.util.HashSet;\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n\r\n        HashSet<ListNode> set = new HashSet<>();\r\n        while (headA != null) {\r\n            set.add(headA);\r\n            headA = headA.next;\r\n        }\r\n        while (headB != null) {\r\n            if (!set.add(headB)) {\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(M+N)$，其中 M、N 为链表的长度\r\n- 空间复杂度：$O(N)/O(M)$，其中 M、N 为链表的长度\r\n\r\n\r\n\r\n## 思路3\r\n\r\n-   遍历其中一个链表每一个元素时，都将该元素和另一个链表的每一个元素进行比较，如果相等就相交。时间复杂度比较大。。。\r\n\r\n### 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n\r\n        while (headA != null) {\r\n            ListNode p = headB;\r\n            while (p != null) {\r\n                if (p == headA) {\r\n                    return headA;\r\n                }\r\n                p = p.next;\r\n            }\r\n            headA = headA.next;\r\n        }\r\n        return null;\r\n        \r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(MN)$，其中 M、N 为链表的长度\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845025618","body":"\r\n\r\n## 题目\r\n\r\n[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n## 思路1\r\n\r\n-   利用哈希表HashSet，保存访问过的路径，如果未访问过，就add添加且返回true，如果已存在再添加的话就会返回该结点，而且该结点就是他们重合的结点，否则返回null\r\n\r\n### 代码\r\n\r\n```java\r\nimport java.util.HashSet;\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        //利用哈希表不重复元素的特性来存储结点判断是否存在环\r\n        HashSet<ListNode> set = new HashSet<>();\r\n\r\n        //只要没到头且还没重合就一直循环\r\n        while (head != null) {\r\n            if (!set.add(head)) {\r\n                return head;\r\n            }\r\n            head = head.next;\r\n        }\r\n        //到末尾还是没有重合的话就是返回null\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n<hr>\r\n\r\n\r\n## 思路2\r\n\r\n-   我们可以利用快慢指针，慢指针每次移动一个，快指针每次移动两个，如果确实存在环的话，最终一定会重合的\r\n\r\n-   如果快指针最后为null，肯定是到末尾了，就没有环\r\n\r\n-   我们假设头结点到重合的结点这段长度为a，重合的结点到相遇的结点为b，环的剩下部分为c\r\n\r\n    -   由于再相同的时间内，fast的速度是low的两倍，而low走的路程为a+b，fast为low的两倍那么路程应该是2(a+b)\r\n    -   由题分析可得，fast走过的长度为a+b+c+b\r\n    -   可得等式：`a+b+c+b = 2(a+b)` ，得到`c = a`\r\n    -   所以，我们可以等到相遇的时候再创建一个指向head的指针，同时以相同的速度向前移动，等到相遇的时候就是我们要的环重合的结点\r\n\r\n    ![](https://assets.leetcode-cn.com/solution-static/142/142_fig1.png)\r\n\r\n### 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        //定义快慢指针\r\n        ListNode low = head;\r\n        ListNode fast = head;\r\n\r\n        //若为空或者只有一个元素时候就是无环的\r\n        while (fast != null && fast.next != null) {\r\n            low = low.next;\r\n            fast = fast.next.next;\r\n            //如果快慢指针重合就代表存在环，然后开始寻找重合点\r\n            if (fast == low) {\r\n                //定义一个pre指针指向head，让pre和low同时移动，等到重合时就是指向重合的点\r\n                ListNode pre = head;\r\n                while (pre != low) {\r\n                    pre = pre.next;\r\n                    low = low.next;\r\n                }\r\n                return pre;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845735959","body":"## 题目\r\n\r\n[146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n## 思路\r\n\r\n-   利用双链表和HashMap来解题\r\n-   看到链表题目，我们可以使用头尾结点可以更好进行链表操作和边界判断等\r\n-   还需要使用size变量来存储双链表的当前长度\r\n-   调用get，如果存在的话，我们可以调用将在双链表中的结点通过修改指针移动到第一个；如果调用put，我们先判断是否存在该结点，如果不存在，可直接将链接插入即可，同时size++，如果存在的话，先删除原来的结点，再将新结点push到头部即可\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass LRUCache {\r\n    class Node {\r\n        int key;\r\n        int val;\r\n        Node pre;\r\n        Node next;\r\n\r\n        public Node() {}\r\n\r\n        public Node(int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n    }\r\n\r\n    // 哈希表中的node和双链表的node是同一个结点\r\n    private HashMap<Integer, Node> cache;\r\n    private Node dummyHead;\r\n    private Node dummyTail;\r\n    private int size;\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        cache = new HashMap<>();\r\n        dummyHead = new Node();\r\n        dummyTail = new Node();\r\n        dummyHead.next = dummyTail;\r\n        dummyTail.pre = dummyHead;\r\n        this.capacity = capacity;\r\n        this.size = 0;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        // 先获取看看结点存不存在\r\n        Node node = cache.get(key);\r\n        // 如果存在的话，将当前访问的结点移动到链表头，并且返回值\r\n        if (node != null) {\r\n            moveToHead(node);\r\n            return node.val;\r\n        }\r\n        // 不存在的话就返回-1\r\n        return -1;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        // 也是先看看结点是否存在\r\n        Node node = cache.get(key);\r\n        // 如果存在，那么要做的操作就是将结点移动到链表头，然后更新结点值即可\r\n        if (node != null) {\r\n            node.val = value;\r\n            moveToHead(node);\r\n        } else {\r\n            // 如果不存在的话我们就要创建新结点插入\r\n            Node newNode = new Node(key, value);\r\n            // 先添加到哈希表中\r\n            cache.put(key, newNode);\r\n            // 再添加到链表中\r\n            addToHead(newNode);\r\n            // 并且长度+1\r\n            size++;\r\n            // 因为我们设定最大容量，我们还要判断新put的结点后，容量是否超过了capacity，超过了话，删除最后一个结点，并且长度-1\r\n            if (size > capacity) {\r\n                Node tail = removeTail();\r\n                cache.remove(tail.key);\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * 将node移动到最前面\r\n    */\r\n    private void moveToHead(Node node) {\r\n        if (size > 0 && size <= capacity) {\r\n            remove(node);\r\n            addToHead(node);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * 删除node结点\r\n    */\r\n    private void remove(Node node) {\r\n        if (size > 0) {\r\n            node.pre.next = node.next;\r\n            node.next.pre = node.pre;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * 删除最后一个结点\r\n    */\r\n    private Node removeTail() {\r\n        if (size > 0) {\r\n            Node node = dummyTail.pre;\r\n            remove(node);\r\n            return node;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n    * 添加新结点到第一位去\r\n    */\r\n    private void addToHead(Node node) {\r\n        node.next = dummyHead.next;\r\n        dummyHead.next = node;\r\n        node.next.pre = node;\r\n        node.pre = dummyHead;\r\n    }\r\n}\r\n```\r\n\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(N)$，其中 N 为初始化的 capacity 容量"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yvonne1231-Wang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836281956","body":"### 解题思路\r\n将数组num的最后一位从后往前与k从个位开始依次相加，若加起来后的总数小于10则直接推入栈中；若总数大于10，则将k的进位加1，将总数减去10以后推入栈中。\r\n##需要注意点：\r\n1.不能忘记k的位数或者加起来总数的位数大于原本的数组num的长度点情况，所以数组遍历结束还要判断k是否为0了，若没有，再将k依次推入；\r\n2.不要忘记反转数组，如果改成unshift()则不用；\r\n3.最开始想的办法是将num先转换成数字，与k相加后变成字符串再变成数组，但是忽略了num长度很长变成数字后再相加会溢出的情况。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let a,res=[];\r\n    for(let i = num.length-1; i >= 0; i--)\r\n    {\r\n        a = num[i] + k % 10;\r\n        k = Math.floor(k/10);\r\n        if(a >= 10){\r\n            ++k;\r\n            a = a-10;\r\n        };\r\n        res.push(a);\r\n    }\r\n    while(k!=0){\r\n        res.push(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    return res.reverse();\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n) ----只开辟了两个新数据，a和res，其中a是常量阶的，与数据规模无关。res是一个大小与n有关的数组，所以空间复杂度为O(n)\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838232128","body":"### 解题思路\r\n把字符串s以字符串c作为separator分割为数组，然后计算数组每个元素的长度\r\n第一个元素和最后一个元素离得最近的距离单独推入\r\n数组中间的元素判断长度是偶数还是奇数，两种情况推入距离\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let sArr = s.split(c);\r\n    let len = sArr.length;\r\n    let res = [];\r\n    for(let i = sArr[0].length; i >=0; i--){\r\n        res.push(i);\r\n    }\r\n    for (let i=1; i < len-1; i++){\r\n        if(sArr[i].length % 2 == 0){\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }else{\r\n            for(let j=1; j <= Math.floor(sArr[i].length/2); j++){\r\n            res.push(j);\r\n            }\r\n            res.push(Math.floor(sArr[i].length/2) +1)\r\n            for(let j = Math.floor(sArr[i].length/2); j >=0; j--){\r\n            res.push(j);\r\n            }\r\n        }\r\n    }\r\n    for(let i = 1; i <= sArr[len-1].length; i++){\r\n        res.push(i);\r\n    }\r\n    return res\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n) n为字符串s的长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839672335","body":"### 解题思路\r\n此处撰写解题思路\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.arr.length < this.maxSize){\r\n        this.arr.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.arr.length != 0){return this.arr.pop()}\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if(this.arr.length < k){\r\n        for(i=0; i<this.arr.length; i++){\r\n            this.arr[i] += val\r\n        }\r\n    }else{\r\n            for(i=0; i<k; i++){\r\n            this.arr[i] += val\r\n        }\r\n    }\r\n    \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)-----increment操作的时候是O(N),其他时候是O(1)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840478164","body":"# 方法一：只用一个栈\r\n### 解题思路\r\n1.依次扫描字符串s的各个元素，如果遇到数字字符，不能忘记考虑\"100\"这种连续数字的情况；如果是第一次遇到数字字符，则推入栈中，若栈顶已经是数字字符，则把目前的字符拼接到栈顶数字字符的后面；（看到题解中还有一种处理连续数字字符的方法，就是把遇到\"[\"之前的数字字符拼接到一起）\r\n2.如果遇到\"[\"或者字母则直接推入栈中；\r\n3.如果遇到\"]\",则依次从栈中取出字母拼接成临时字符串，直到遇到\"[\"；然后再取出\"[\"前面的一个元素，即这个临时字符串需要重复的次数。最后把重复完的临时字符串推入栈中。\r\n4.遍历结束后，不能忘了要把stack里所有字符串拼接起来，分清楚拼接顺序。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    for (i = 0; i < s.length; i++){\r\n        if(s[i]>=\"0\" && s[i]<=\"9\"){\r\n            //考虑”100“这种连续数字字符的可能性\r\n            if(stack[stack.length-1]>=\"0\" && stack[stack.length-1]<=\"9\"){\r\n                stack[stack.length-1] += s[i]\r\n                continue;\r\n            }\r\n            stack.push((s[i]))            \r\n        }else{\r\n            if(s[i] == \"]\"){\r\n                let letter = stack.pop();\r\n                let resPart = \"\";\r\n                let resPartAll = \"\";\r\n                while( letter != '['){\r\n                    resPart = letter + resPart;\r\n                    letter=stack.pop();\r\n                }\r\n                let num = Number(stack.pop());\r\n                for (let i=0; i < num; i++){\r\n                    resPartAll = resPartAll+resPart;\r\n                }\r\n                stack.push(resPartAll);\r\n\r\n            }\r\n            //其他情况即\"[\"或者是字母时，直接入栈\r\n            else {\r\n                stack.push(s[i])\r\n            }\r\n        }\r\n    }\r\n    //最后不能忘了要把stack里所有字符串拼接起来（此处注意，不能直接let res而不赋值，会把\"undefined\"一起拼接上去）\r\n    let res=\"\";\r\n    for(i = 0; i < stack.length; i++){\r\n        res += stack[i];\r\n    }\r\n    return res\r\n    \r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度\r\n\r\n# 方法二：双栈\r\n### 解题思路\r\n和一个栈类似，需要注意的是最开始字符串栈strStack会推入一个空字符串！！\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let isNum = (e) =>  e >= \"0\" && e <= \"9\";\r\n    let numStack = [];\r\n    let strStack = [];\r\n    let num = 0; \r\n    let char = \"\";//字母暂存处,等待被处理的字符串\r\n    for(i = 0; i < s.length; i++){\r\n        if (isNum(s[i])){\r\n            num = num * 10 + Number(s[i])\r\n        }else if(s[i] == \"[\"){\r\n            numStack.push(num);\r\n            num = 0;\r\n            strStack.push(char);//如果遇到\"[\"说明是嵌套结构，推入字符串栈，等会处理\r\n            char = \"\";\r\n        }else if(s[i] == \"]\"){\r\n            char = strStack.pop() + char.repeat(numStack.pop());\r\n        }else{\r\n            char += s[i]; //遇到连续的字母要拼接起来 \r\n        }\r\n    }\r\n\r\n    return char\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(k)----k是字符串的长度\r\n空间复杂度：O(k)----k是字符串的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841121866","body":"### 解题思路\r\n双栈，一个栈是用来模拟队列，push的时间直接push进去；另一个栈负责在pop和peek操作时，先把栈里所有元素依此倒腾出来，取出栈底元素后，再倒腾回去。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stackA = [];\r\n    this.stackB = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stackA.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stackA.length){\r\n        this.stackB.push(this.stackA.pop())\r\n    };\r\n    let res = this.stackB.pop();\r\n    while(this.stackB.length){\r\n        this.stackA.push(this.stackB.pop())\r\n    };\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    while(this.stackA.length){\r\n        this.stackB.push(this.stackA.pop())\r\n    };\r\n    let res = this.stackB.pop();\r\n    this.stackA.push(res)\r\n    while(this.stackB.length){\r\n        this.stackA.push(this.stackB.pop())\r\n    };\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stackA.length){return false}\r\n    return true\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：push,empty操作时为O(1),pop和peek操作时为O(N),N为操作总数\r\n空间复杂度：push,empty操作时为O(1),pop和peek操作时为O(N),N为操作总数"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843036461","body":"### 解题思路\r\n双指针法\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(!head){return null}\r\n    return dfs(head,null)\r\n\r\n    function dfs(head,tail){\r\n        if (head == tail) {return null};\r\n        let fast = head;\r\n        let slow = head;\r\n        while(fast != tail && fast.next != tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        let root = new TreeNode(slow.val);\r\n        root.left = dfs(head,slow);\r\n        root.right = dfs(slow.next,tail);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\r\n空间复杂度：空间复杂度为O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843913686","body":"# 方法一：暴力法\r\n### 解题思路\r\n从头遍历两个链表，一一对比。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let curA = headA;\r\n    let curB = headB;\r\n\r\n    while(curA){\r\n        while (curA != curB && curB != null){\r\n            curB = curB.next;\r\n        }\r\n        if (curA == curB){return curA}\r\n        curB = headB;\r\n        curA = curA.next;   \r\n    }\r\n    return null\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(mn),m,n分别是两个链表的长度\r\n空间复杂度：O(1)\r\n\r\n# 方法二：哈希法\r\n先遍历一个链表，把它的所有节点存放到哈希表里，再遍历另一个链表，看它是否已经存放在哈希表内了。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let curA = headA;\r\n    let curB = headB;\r\n    let hash = new Set();\r\n    while(curA){\r\n        hash.add(curA);\r\n        curA = curA.next;\r\n    }\r\n    while(curB){\r\n        if(hash.has(curB)){return curB}\r\n        curB = curB.next;\r\n    }\r\n    return null\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(m+n),m,n分别是两个链表的长度\r\n空间复杂度：O(n)\r\n\r\n# 方法三：双指针\r\n1.使用两个指针如指针 a, b 分别指向 A, B 这两条链表的头节点, 两个指针以相同的速度向后移动；\r\n2.如果其中一个指针比如 a 先到达链表尾部，则将其继续指向另一个指针的头节点；\r\n3.在这过程中若两个指针相遇时，则表示有相交节点。\r\n\r\n*注意：为什么 a, b 指针相遇的点一定是相交的起始节点? *\r\n\r\n- 将两条链表按相交的起始节点继续截断，链表 1 为: A + C，链表 2 为: B + C；\r\n- 当 a 指针将链表 1 遍历完后，重定位到链表 2 的头节点，然后继续遍历直至相交点，此时 a 指针遍历的距离为 A + C + B；\r\n- 同理 b 指针遍历的距离为 B + C + A；\r\n- 如果没有相遇节点，也就是 a 指针遍历的距离为 A + B， b 指针遍历的距离为 B + A， 最后会在null处相遇，所以不用担心陷入死循环。\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let curA = headA;\r\n    let curB = headB;\r\n    while(curA != curB){\r\n        if(curA === null){curA= headB}\r\n        else{curA = curA.next;}\r\n        if(curB === null){curB = headA}\r\n        else{curB = curB.next;}\r\n    }\r\n    \r\n    return curA\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(m+n),m,n分别是两个链表的长度\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844840473","body":"### 解题思路\r\n哈希表\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Liuqibaa":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300543","body":"C++\r\n\r\n### 思路\r\n\r\n将向量编程整数，然后相加，再变成向量\r\n\r\n### 代码\r\n\r\n\r\n```c\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int nums = 0;\r\n        int tens = 1;\r\n        vector<int> result;\r\n        for(int i = num.size() - 1; i >= 0; i --){\r\n            nums += num[i] * tens;\r\n            tens *= 10;\r\n        }\r\n        nums += k;\r\n        while(nums){\r\n            int num1 = nums % 10;\r\n            result.push_back(num1);\r\n            nums /= 10;\r\n        }\r\n        reverse(result.begin(), result.end());\r\n        return result;\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838128260","body":"### 思路\r\n\r\n用双指针法：先新建一个向量，大小为字符串大小，元素值全为1，然后遍历，将为c的位置均为0；再定义两个指针，同时一前一后搜索为0的；之前的代码无法实现，现在这个代码可以实现\r\n代码是C++的\r\n\r\n### 代码\r\n\r\n\r\n``c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int size1 = s.size();\r\n        vector<int> result(size1, 1);\r\n        for(int i = 0; i < size1 ; i ++){\r\n            if(s[i] == c){\r\n                result[i] = 0;\r\n            }\r\n        }\r\n\r\n        for(int k = 0; k < size1; k ++){\r\n            int i = k;\r\n            int j = k;\r\n            if(result[k] != 0){\r\n                while(result[i] != 0 && result[j] != 0){\r\n                    i --; if(i < 0) i = 0;\r\n                    j ++; if(j > size1 - 1) j = size1 - 1;\r\n                }\r\n                if(result[i] == 0) {\r\n                    result[k] = k - i;\r\n                } else{\r\n                    result[k] = j - k;\r\n                }\r\n            } \r\n        }\r\n        return result;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841119335","body":"### 思路\r\n\r\n画图模拟，要实现先入先出的队列的话，需要两个先入先出的堆栈；一个栈用来输入，一个用来输出；接着弹出的时候如果输出占非空，就弹出，等输出栈空了就将输入栈所有元素压入输出栈；代码是 C++\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stkIn;\r\n    stack<int> stkOut;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stkIn.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(stkOut.empty()){\r\n            while(!stkIn.empty()){\r\n                stkOut.push(stkIn.top());\r\n                stkIn.pop();\r\n            }\r\n        }\r\n        int result = stkOut.top();\r\n        stkOut.pop();\r\n        return result;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        int result = this->pop();\r\n        stkOut.push(result);\r\n        return result;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stkOut.empty() && stkIn.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push() 和 peek(), empty() 都是O(1)，pop() 是 O(N)?\r\n- 空间复杂度：O(N)，\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660557","body":"### 思路\r\n\r\n好烦，看官方题解一知半解，只能是默下 C++ 的代码了\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> stk;\r\n        for(int i = 0; i < arr.size(); i ++){\r\n            if(!stk.empty() && stk.top() > arr[i]){\r\n                int cur = stk.top();\r\n                while(!stk.empty() && stk.top() > arr[i]){\r\n                    stk.pop();\r\n                }\r\n                stk.push(cur);\r\n            }\r\n            else{\r\n                stk.push(arr[i]);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843180550","body":"### 思路\r\n\r\n参考西法的打卡，就是双指针递归法\r\n\r\n### 代码\r\n\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if(head == nullptr) return nullptr;\r\n        return sortedListToBST(head, nullptr);\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail){\r\n        if(head == tail) return nullptr;\r\n        \r\n        ListNode *slowIndex = head;\r\n        ListNode *fastIndex = head;\r\n\r\n        while(fastIndex != tail && fastIndex->next != tail){\r\n            fastIndex = fastIndex->next->next;\r\n            slowIndex = slowIndex->next;\r\n        }\r\n\r\n        ListNode *root = new TreeNode(slowIndex->val);\r\n        root->left = sortedListToBST(head, slowIndex);\r\n        root->right = sortedListToBST(slowIndex->next, tail);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N\r\n- 空间复杂度：O(1)\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845961094","body":"### 思路\r\n   列表+哈希表  C++\r\n\r\n### 代码\r\n\r\n``c++\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) {\r\n        length = capacity;\r\n    }\r\n    \r\n    int get(int key) {  \r\n        auto P1 = hashTable.find(key);\r\n        if(P1 == hashTable.end()) return -1;\r\n        list1.splice(list1.begin(), list1, P1->second);\r\n        return P1->second->second;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        auto P2 = hashTable.find(key);\r\n        if(P2 != hashTable.end()) list1.erase(P2->second);\r\n        list1.push_front(make_pair(key,value));\r\n        hashTable[key] = list1.begin();\r\n        if(hashTable.size() > length){\r\n            int k = list1.rbegin()->first;\r\n            list1.pop_back();\r\n            hashTable.erase(k);\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int length = 0;\r\n    list<pair<int, int>> list1;\r\n    unordered_map<int, list<pair<int,int>>::iterator> hashTable;\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sitequ":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836300870","body":"**语言：python3**\r\n\r\n### 思路\r\n1.整型数组转化字符数组，再化为非负整数\r\n2.与k相加\r\n3.数字还原成字符数组，再化为整型数组\r\n\r\n### 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = map(str, num)\r\n        str2int = int(''.join(num)) + k\r\n        Output = list(str(str2int))\r\n        for i in range(0,len(Output)):\r\n            Output[i] = int(Output[i])\r\n        return Output\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838443247","body":"**语言：python3**\r\n\r\n### 思路\r\n1. 获得所有c的位置\r\n2. s的每个字符的位置与c的位置做差，排序找到最小，将值作为元素返回\r\n3. 返回最终最短距离列表\r\n\r\n### 代码\r\n\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = len(s)\r\n        Output = []\r\n        num_c = []\r\n        for i in range(0,l):\r\n            if s[i] == c :\r\n                num_c.append(i)\r\n\r\n        L = len(num_c)\r\n\r\n        for i in range(0,l):\r\n            K = []\r\n            for m in range(0,L):\r\n                K.append(abs(i - num_c[m]))\r\n            K = sorted(K)\r\n            Output.append(K[0])\r\n\r\n        return Output\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：Worst case O(N^2)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839728882","body":"**语言：python3**\r\n\r\n### 思路：\r\n开辟空数组，按要求执行不同函数\r\n\r\n\r\n### 代码：\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxsize = maxSize\r\n        self.Stack = list()\r\n        return None\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.Stack) < self.maxsize:\r\n            self.Stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.Stack) == 0:\r\n            return -1\r\n        else:\r\n            return self.Stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.Stack) <= k:\r\n            for i in range(0,len(self.Stack)):\r\n                self.Stack[i] += val\r\n        else:\r\n            for i in range(0,k):\r\n                self.Stack[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840414996","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.先将字符串拆分，注意两位数以上的整数情况\r\n2.依次pop字符入栈，同时开辟记录 '[' 和 ']' 的位置的数组\r\n3.当有[出现时，记录需要倍增的字符串入栈，相应的[,]，以及字符出栈，记录相应位置的元素也要清除\r\n4.最终将栈内的字符串reverse并且join，返回结果\r\n\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        A_A = re.findall(r'[a-z]+|\\d+|\\[+|\\]+',s)\r\n        a_a = list()\r\n        for p in range(0, len(A_A)):\r\n            if A_A[p].isdigit():\r\n                a_a.append(A_A[p])\r\n            else:\r\n                M = list(A_A[p])\r\n                for q in range(0, len(M)):\r\n                    a_a.append(M[q])\r\n        AA = a_a       \r\n        cache = list()\r\n        mark = list()\r\n        l = len(AA)\r\n        k = 'o'\r\n        for i in range(0,l):\r\n            cache.append(AA[l-1-i])\r\n            if AA[l-1-i] == ']' :\r\n                mark.append(len(cache)-1)\r\n            if AA[l-1-i] == '[':\r\n                mark.append(len(cache)-1)\r\n                K = cache[(mark[len(mark)-2]+1):mark[len(mark)-1]]\r\n                k = ''.join(reversed(K))\r\n                for j in range(0,(mark[len(mark)-1]+1-mark[len(mark)-2])):\r\n                    cache.pop()\r\n                cache.append(k)\r\n                for t in range(0,2):\r\n                    mark.pop()\r\n            if AA[l-1-i].isdigit():\r\n                cache.pop()\r\n                cache.append(k*(int(AA[l-1-i])-1))\r\n        Output = ''.join(reversed(cache))\r\n        return Output\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(N^2)\r\n空间复杂度：O(N^2)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840960840","body":"**语言：python3**\r\n\r\n### 代码：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.queue = list()\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.queue.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.queue.pop(0)\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.queue[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return self.queue == []\r\n```\r\n\r\n### 复杂度分析;\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680502","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.将原数组排序\r\n2.依次比较两个数组的切片，相同加一\r\n3.返回结果\r\n\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def MAxChunks(self,arr):\r\n        AA = sorted(arr)\r\n        chunks = 0\r\n        for i in range(0,len(arr)):\r\n            if sorted(arr[:i+1]) == AA[:i+1]:\r\n                chunks += 1\r\n        return chunks\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841789598","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.计算出链表长度\r\n2.找到倒数第k个内存的指针和倒数第k+1个内存的指针\r\n3.将k+1个内存的指针指向none，将最后一个元素的指针指向head，然后返回第k个元素的指针\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        p1 = head\r\n        p2 = head\r\n        if head == None:\r\n            return p1\r\n        count = 1\r\n        while p1.next:\r\n            count += 1\r\n            p1 = p1.next\r\n        k = k % count\r\n        if k == 0:\r\n            return p2\r\n        else:\r\n            for i in range(0,count-k-1):\r\n                p2 = p2.next\r\n            p3 = p2.next\r\n            p2.next = None\r\n            p1.next = head\r\n            return p3\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842036800","body":"**语言：python3**\r\n\r\n### 思路:\r\n1.在链表为空及只有一位的情况下，直接返回头部节点指针\r\n2.设置一个prehead指针起始位置位于prehead\r\n3.依次两两变换指针\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head == None or head.next == None: \r\n            return head\r\n        output = ListNode()\r\n        output.next = head.next\r\n        pre = output\r\n        while head and head.next:\r\n            next = head.next\r\n            nextt = next.next\r\n\r\n            next.next = head\r\n            pre.next = next\r\n            head.next = nextt\r\n\r\n            pre = head\r\n            head = nextt\r\n            \r\n        return output.next\r\n\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843178227","body":"**语言：python3**\r\n\r\n### 思路：\r\n找到中间值，在左右依次重复\r\n利用递归完成\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n        else:\r\n            p1 = head\r\n            p2 = head\r\n            count = 1\r\n            while p1.next:\r\n                count += 1\r\n                p1 = p1.next\r\n            for i in range(0, round((count+1)/2)-1):\r\n                tpt = p2\r\n                p2 = p2.next\r\n            cen = p2\r\n            root = TreeNode(cen.val)\r\n            tpt.next = None\r\n        \r\n            root.left = self.sortedListToBST(head)\r\n            root.right = self.sortedListToBST(cen.next)\r\n\r\n            return root\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843709796","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.分别计数\r\n2.找到第一个相等的值，返回指针\r\n\r\n### 代码:\r\n\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        p1 , p2 = headA , headB\r\n        countA = 1\r\n        countB = 1\r\n        while p1.next:\r\n            countA += 1\r\n            p1 = p1.next\r\n        while p2.next:\r\n            countB += 1\r\n            p2 = p2.next\r\n        dif = abs(countA - countB)\r\n        p1, p2 = ListNode(0), ListNode(0)\r\n        p1.next = headA\r\n        p2.next = headB\r\n        if countA > countB:\r\n            for i in range(0,dif):\r\n                p1 = p1.next\r\n        else:\r\n            for i in range(0,dif):\r\n                p2 = p2.next\r\n        while p1.next != p2.next:\r\n            p1 = p1.next\r\n            p2 = p2.next\r\n        return p1.next\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844726626","body":"**语言：python3**\r\n\r\n### 思路：\r\n快慢指针\r\n\r\n### 代码：\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast = head\r\n        slow = head\r\n        if not fast:\r\n            return None\r\n        while True:\r\n            if not (fast.next and fast.next.next):\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if  fast == slow:\r\n                break\r\n        fast = head\r\n        if slow == fast:\r\n            return head\r\n        while not fast.next == slow.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return slow.next\r\n\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845692744","body":"**语言：python3**\r\n\r\n### 思路：\r\n1.开辟一个栈，用来记录key被操作的顺序记录\r\n2.每次操作后更新一此栈的顺序\r\n3.根据栈来调整字典的元素\r\n\r\n### 代码：\r\n\r\n```\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.LUR = {}\r\n        self.sque = []\r\n\r\n    def get(self, key: int) -> int:\r\n        k = self.LUR.get(key)\r\n        if k == None:\r\n            return -1\r\n        else:\r\n            self.sque.pop(self.sque.index(key))\r\n            self.sque.append(key)\r\n            return self.LUR[key]  \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        l = len(self.LUR)\r\n        if self.LUR.get(key):\r\n            self.LUR[key] = value\r\n            self.sque.pop(self.sque.index(key))\r\n            self.sque.append(key)\r\n        elif l < self.capacity:\r\n            self.LUR[key] = value\r\n            self.sque.append(key)\r\n        else:\r\n            del self.LUR[self.sque[0]]\r\n            self.sque.pop(0)\r\n            self.sque.append(key)\r\n            self.LUR[key] = value\r\n```\r\n\r\n### 复杂度分析：\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846376929","body":"**语言：python3**\r\n\r\n### 思路：\r\n利用递归解决树的问题\r\n\r\n### 代码：\r\n\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root == None:\r\n            return 0\r\n        else:\r\n            depth = 1 + max(self.maxDepth(root.left),self.maxDepth(root.right))\r\n            return depth\r\n\r\n```\r\n### 复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(d) d为depth"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaotuanzi999":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836303348","body":"### 思路 \r\n首先，作为小白，我的第一思路就是将数组转换真正的值，然后与k相加，最后将相加的和转化为List。\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n       List<Integer> res = new ArrayList<>();\r\n       int sum=k;\r\n        int n=1;\r\n        for (int i = lenth-1; i>=0; i--){\r\n            sum+= n*num[i];\r\n            n*=10;\r\n        }\r\n        String temp = Integer.toString(sum);\r\n        for (int i = temp.length()-1; i>=0;i--){\r\n            res.add(Integer.parseInt(temp.substring(i,i+1)));\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n```\r\n\r\n然而结果不尽人意。正常的数字可以得到正确的结果。但当数字特别大的时候会出现下面的情况，我还debug了查看。之后查询才知道是溢出了，超出int的精度范围。\r\n\r\n\r\n从后往前遍历数组，就是从数组的低位开始。与k进行相加，并对k与10取余，得到最低位。然后k%10得到进位。\r\n中间存在num的数组整体的小于k的情况，所以需要对i进行判断。\r\n### 代码\r\n```\r\nclass Solution {\r\n      public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int lenth = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        for (int i = lenth-1; i>=0||k>0; i--,k/=10){\r\n            // 如果num数组存在数组，因为存在k>num的情况\r\n            if (i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838038240","body":"### 思路\r\n从左往右遍历计算离左边最近的距离；\r\n从右往左遍历计算离右边最近的距离。\r\n但是存在初始时，c位置的位置设定。从左往右设置为最小，这样他们之间差值就很大。从而在从右往左遍历时可以更新其的值。\r\n\r\n### 代码\r\n```\r\n public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for (int i=0; i<length; i++){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = i-prev;\r\n        }\r\n        prev = Integer.MAX_VALUE/2;\r\n        for (int i = length-1; i>=0; i--){\r\n            if (s.charAt(i)==c) prev = i;\r\n                res[i] = Math.min(res[i],prev-i);\r\n        }\r\n        return res;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839373330","body":"### 思路\r\n\r\n利用数组模拟栈，设置一个标志位用来模拟栈顶。pop() 需判断栈顶是否到达栈底；push() 需判断是否超过栈的大小。increment（）则需判断需要修改位数与栈中元素比较取最小者。\r\n\r\n### 代码\r\n```\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top!=stack.length-1){\r\n//            ++top;\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top==-1) return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for (int i=0; i<limit; i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n}\r\n```"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842136918","body":"### 思路\r\n由于是两两交换，我们就可以使用递归的思路进行解决。同时定义好递归出口。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head==null || head.next==null) return head;\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842785191","body":"### 思路\r\n由于二叉树特点：节点的左子树小于右子树，题目又说了链表是按照升序排列，所以我们只需要找到中间节点，前面则是左子树，后面就是右子树。然后递归的方式在形成左右子树。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        ListNode slow = head, fast = head, pre = null;\r\n        // 找到链表的中间位置\r\n        while (fast != null && fast.next != null){\r\n            pre = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        pre.next = null;\r\n        TreeNode node = new TreeNode(slow.val);\r\n        node.left = sortedListToBST(head);\r\n        node.right = sortedListToBST(slow.next);\r\n        return node;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845213210","body":"### 思路\r\n方法1：使用set记录已经访问过得节点，如果存在环，就会重复访问。\r\n方法2：使用快慢指针，如果存在环，快指针会追上慢指针，即存在环，否则没有环。\r\n\r\n### 代码\r\n```\r\npublic class Solution {\r\n    // 方法1：哈希表\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode pos = head;\r\n        Set<ListNode> set = new HashSet<>();\r\n        while (pos != null){\r\n            if (set.contains(pos)){\r\n                return pos;\r\n            }else{\r\n                set.add(pos);\r\n            }\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    // 方法2：快慢指针\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head==null) return null;\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null){\r\n            slow = slow.next;\r\n            if (fast.next != null){\r\n                fast = fast.next.next;\r\n            }else {\r\n                return null;\r\n            }\r\n            if (fast == slow){\r\n                ListNode pre = head;\r\n                while (pre != slow){\r\n                    pre = pre.next;\r\n                    slow = slow.next;\r\n                }\r\n                return pre;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845911052","body":"### 代码\r\n```\r\nclass LRUCache {\r\n\r\n    private HashMap<Integer, Node> map;\r\n    private DoubleList cache;\r\n    private int capacity;\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>();\r\n        cache = new DoubleList();\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) return -1;\r\n        int val = map.get(key).val;\r\n        put(key,val);\r\n        return val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        Node node = new Node(key, value);\r\n        if (map.containsKey(key)){\r\n            cache.remove(map.get(key));\r\n            cache.addFirst(node);\r\n            map.put(key,node);\r\n        }else {\r\n            if (capacity == cache.size()){\r\n                Node last = cache.removeLast();\r\n                map.remove(last.key);\r\n            }\r\n            cache.addFirst(node);\r\n            map.put(key,node);\r\n        }\r\n    }\r\n}\r\n\r\nclass Node{\r\n    public int key;\r\n    public int val;\r\n    public Node next, prev;\r\n    public Node(int key, int val){\r\n        this.val = val;\r\n        this.key = key;\r\n    }\r\n}\r\n\r\nclass DoubleList{\r\n    private Node head;\r\n    private Node tail;\r\n    private int size;\r\n\r\n    public DoubleList(){\r\n        head = new Node(0,0);\r\n        tail = new Node(0,0);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        size=0;\r\n    }\r\n\r\n    // 在链表头部添加节点n\r\n    public void addFirst(Node n){\r\n        n.next = head.next;\r\n        n.prev = head;\r\n        head.next.prev = n;\r\n        head.next = n;\r\n        size++;\r\n    }\r\n\r\n    // 删除链表中的n节点（n一定存在）\r\n    public void remove(Node n){\r\n        n.prev.next = n.next;\r\n        n.next.prev = n.prev;\r\n        size--;\r\n    }\r\n\r\n    public Node removeLast(){\r\n        if (tail.prev==head) return null;\r\n        Node last = tail.prev;\r\n        remove(last);\r\n        return last;\r\n    }\r\n\r\n    public int size(){\r\n        return size;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846403562","body":"### 思路\r\n本题主要考察二叉树的遍历。我们可以深度和广度遍历实现。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        // 深度优先\r\n//        if (root==null) {\r\n//            return 0;\r\n//        }else {\r\n//            int leftHeight = maxDepth(root.left);\r\n//            int rightHeight = maxDepth(root.right);\r\n//            return Math.max(leftHeight,rightHeight)+1;\r\n//        }\r\n        // 广度优先\r\n        if (root == null) return 0;\r\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\r\n        queue.offer(root);\r\n        int res = 0;\r\n        while (!queue.isEmpty()){\r\n            int size = queue.size();\r\n            while (size>0){\r\n                TreeNode node = queue.poll();\r\n                if (node.left != null) queue.offer(node.left);\r\n                if (node.right != null) queue.offer(node.right);\r\n                size--;\r\n            }\r\n            res++;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846514834","body":"### 思路\r\n通过深度优先遍历，进行比较\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p==null && q==null) return true;\r\n        if (p==null || q==null) return false;\r\n        if (p.val != q.val) return false;\r\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmaStella":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836305778","body":"## 解题思路\r\n尝试数字全拿出来然后+K再放回去，结果发现lc有很大的test case，可能就是故意不想让你用这种方法，然后 重新尝试，先把K加到最后一个A的数字，然后取%10的值，循环下去。写了第二遍了还是不能一遍写出来。。。大无语时间发生了。\r\n\r\n\r\n\r\n## 代码\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n\r\n    for(int i = A.length-1; i>=0; i--){\r\n\r\n        temp = temp+ A[i];\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    while(temp !=0){\r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n    }\r\n    return newA;\r\n    }\r\n`\r\n以为会变得更快，结果并没有\r\n`\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n\r\n    List<Integer> newA = new ArrayList<>();\r\n\r\n    int temp = K;\r\n    int index = A.length-1;\r\n    while(temp !=0 || index >=0){\r\n        if(index >=0){\r\n            temp = temp+ A[index];\r\n        }    \r\n        newA.add(0, temp%10);\r\n        temp=temp/10;\r\n        index --;\r\n    }\r\n\r\n    return newA;\r\n    }\r\n`\r\n\r\n## 复杂度分析\r\n时间复杂度O(max(n, log(K)))\r\n空间复杂度O(max(n, log(K)))\r\n\r\n\r\n喜欢解析里一个人的总结，mark一下。\r\n\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n\r\n作者：lilyunoke\r\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\r\n来源：力扣（LeetCode）\r\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837949838","body":"## 思路\r\n以为自己写的是暴力，结果好像不是？感觉比较redundant。先在string里搜一遍c，index存下来，然后再双指针（不确定是不是双指针），这个写法非常有问题，要手动handle各种edge case\r\n\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> c_index= new ArrayList<Integer>();\r\n        int result[] = new int[s.length()];\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c ==s.charAt(i)){\r\n                c_index.add(i);\r\n            }\r\n        }\r\n        int first= 0;\r\n        int second = 0;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(c_index.size()>1 && second<c_index.size() && i>=c_index.get(second)){\r\n                 first = second;\r\n                 if(second != c_index.size()-1 ){\r\n                     second++;\r\n                 }\r\n            }\r\n\r\n            if(i <= c_index.get(first)){\r\n                result[i] =Math.abs(c_index.get(first)-i);\r\n            }else if(i>c_index.get(first) && i<c_index.get(second)){\r\n                result[i] =Math.min(Math.abs(c_index.get(first)-i),Math.abs(c_index.get(second)-i));\r\n            }else{\r\n                result[i] =Math.abs(c_index.get(second)-i);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)\r\n\r\n\r\n## 思路\r\n看了答案重新写了一遍\r\n最短的距离无非就是左边的或者右边的\r\n先是从左往右loop一遍，记录，然后从右往左loop一遍，比较之前的大小，选更小的\r\n## 代码\r\n\r\n`\r\n    public int[] shortestToChar(String s, char c) {\r\n        int result[] = new int[s.length()];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] =i-prev;\r\n        }\r\n\r\n\r\n        for(int i = s.length()-1; i>=0; --i){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            result[i] = Math.min(result[i], Math.abs(prev-i));\r\n        }\r\n        return result;\r\n\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(n)\r\n空间O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839609477","body":"## 思路\r\n感觉用array比较简单, 用array然后用一个last index来追踪stack最上面的index， 来实现push和pop的方法。inc值得注意的是，如果K>stack.size()， 只加stack里有的，这个是个edge case，从output上完全看不出来，看了答案caizhidao\r\n\r\n## 代码\r\n`  int stack[];\r\n    int last_index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        //List<Integer> stack = new ArrayList<>();\r\n        stack = new int[maxSize];\r\n        last_index = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(last_index == (stack.length-1)){\r\n            return;\r\n        }\r\n        last_index++;\r\n        stack[last_index]=x;\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(last_index == -1){\r\n            return -1;\r\n        }\r\n        int result = stack[last_index];\r\n        last_index--;\r\n        return result;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i=0; i<k; i++){\r\n            if(i<=last_index){\r\n                stack[i]+=val;\r\n            }\r\n            \r\n        }\r\n    }\r\n`\r\n## 复杂度\r\n时间 push popO(1), inc O(n)\r\n空间 O(1) （这个不确定）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840390737","body":"## 思路\r\n借鉴答案还写了1个小时。。\r\n本来想直接loop一遍，然后遇到“[” 开始存repeatstring，遇到\"]\"停下来，按照数字重复几次，但是忽略了套娃情况 3[a2[c]\r\n借鉴了答案以后，用stack, \r\n遇到数字不知道有几位，先暂时保存下来。\r\n遇到“[”先把数字push上去，再push \"[\"\r\n遇到“]”，开始从stack pop，主要目的是把需要repeat的string pop出来，然后按照repeat time 重复，并最后把repeat过的string push到stack上。\r\n所有string s loop完了后，开始把完整的string pop出来\r\n \r\n## 代码\r\n`java\r\n\r\npublic String decodeString(String s) {\r\n        int repeat_time =0;\r\n        \r\n        Stack<String> stack = new Stack<>();\r\n        StringBuilder result =new StringBuilder();\r\n        for(int i=0; i< s.length(); i++){\r\n            char curr = s.charAt(i);\r\n            if(Character.isDigit(curr)){\r\n                repeat_time = repeat_time*10+ (curr-'0');\r\n                \r\n            }else if(curr =='[' ){\r\n                stack.push(String.valueOf(repeat_time) );\r\n                stack.push(\"[\");\r\n                repeat_time=0;\r\n\r\n            }else if(curr ==']'){\r\n                StringBuilder stringBuilder = new StringBuilder();\r\n                StringBuilder repeatString =new StringBuilder();\r\n                String temp = stack.pop();\r\n                while(temp != \"[\" &&stack.size()>0){\r\n                    stringBuilder.append(temp);\r\n                    temp = stack.pop();\r\n                }\r\n\r\n                repeat_time = Integer.parseInt(stack.pop());\r\n                for(int j =0; j<repeat_time; j++){\r\n                    repeatString.append(stringBuilder.toString());\r\n                }\r\n                stack.push(repeatString.toString());\r\n                repeat_time =0;\r\n            }else{\r\n                stack.push(String.valueOf(curr));\r\n            }\r\n        }\r\n        while(!stack.isEmpty()){\r\n            result.append(stack.pop());\r\n        }\r\n        return result.reverse().toString();\r\n    }\r\n`\r\n\r\n## 复杂度\r\n时间 O(N) N=length of String s\r\n空间 O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840984686","body":"## 思路\r\n\r\n用arraylist代表queue，然后用top_index来keep track到哪里了\r\n\r\n## 代码\r\n`java\r\n    List<Integer> queue;\r\n    int top_index;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        queue =new ArrayList<Integer>();\r\n        top_index =0;\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int temp = queue.get(top_index);\r\n        top_index++;\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return queue.get(top_index);\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return top_index == queue.size();\r\n    }\r\n`\r\n## 复杂度\r\n时间 O(1)\r\n空间 O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841813288","body":"## 思路\r\n思路很蠢，先loop一遍一共多长，找到tail，然后重头开是loop找到新的list的head的前一个node，即 size-size%k-1， 然后让让tail连上head，做rotate\r\n## 代码java\r\n```java\r\npublic ListNode rotateRight(ListNode head, int k) {\r\n        ListNode tail = head;\r\n        ListNode current =head;\r\n        int size =1;\r\n        if(head ==null){\r\n            return null;\r\n        }\r\n        while(tail.next != null){\r\n            tail=tail.next;\r\n            size++;\r\n        }\r\n        //System.out.println(size);\r\n        for(int i=0; i<(size- k%size -1);i++){\r\n            current = current.next;\r\n        }\r\n        tail.next = head;\r\n        head = current.next;\r\n        current.next =null;\r\n        \r\n        return head;\r\n    }\r\n```\r\n## 复杂度\r\n时间 O(n)\r\n空间 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841920219","body":"## 思路\r\n递归是我永远的痛，看答案写的。\r\n首先是找到recursive的base case，base case就是 list里面没有node或者只有一个node，即head ==null || head.next ==null\r\n其次是看如何递归，two.next=head 第二个变为第一个，注意return的时候应该返回two，因为two是新的head。\r\ntwo.next解决了，就要看one.next，这个的下一个即为下一次两两交换的node，所以形成递归swapPairs(three)。\r\n## 代码\r\n```java\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head ==null || head.next ==null){\r\n            return head;\r\n        }\r\n\r\n        ListNode one=head;\r\n        ListNode two = head.next;\r\n        ListNode three = two.next;\r\n        two.next =one;\r\n        one.next = swapPairs(three);\r\n\r\n        return two;\r\n    }\r\n```\r\n## 复杂度\r\n时间 O(n)\r\n空间 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842761294","body":"## 思路\r\n递归杀我，有没有好的方法练习递归啊。。。写不出来\r\n因为list是sorted的，所以每一次recursive找到最中间那个数即为node，然后left recursive再right recursive\r\n\r\n## 代码\r\n```java\r\npublic TreeNode sortedListToBST(ListNode head) {\r\n        \r\n        return helper(head, null);\r\n    }\r\n    public TreeNode helper(ListNode head, ListNode tail){\r\n        if(head ==tail){\r\n            return null;\r\n        }\r\n        ListNode mid = head;\r\n        ListNode end = head;\r\n        while(end !=tail && end.next!=tail){\r\n            mid = mid.next;\r\n            end = end.next.next;\r\n        }\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = helper(head, mid);\r\n        root.right = helper(mid.next, tail);\r\n        \r\n        return root;\r\n    }\r\n```\r\n## 复杂度\r\n时间:\r\nT(n) = 2 *T(n/2) + O(n)\r\nT(n)=O(nlogn)\r\n\r\n空间 O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843857778","body":"## 思路\r\n完全没思路，看了答案才知道。\r\n第一种hashSet 我真的没有想到，说明对data structure不那么熟悉，要熟练掌握每一种data structure，用的时候要知道哪种适合。\r\n第二种太巧妙了，AB 和BA 两个list这样子连起来长度一样，同时loop完，并且尾部刚好可以比较B和A，牛逼。\r\n注意这里的条件，while loop在什么情况下结束呢？\r\n- 在AB 和BA同时loop结束，这时currA和currB相等，都等于null。\r\n- 在AB和BA找到intersectionl point，这时 AB和BA相等。\r\n- 所以while loop的condition为 currA != currB\r\n所以同样，应该return currA或者currB\r\n\r\n## 代码\r\n### hashset\r\n```java\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode tailA = headA;\r\n        ListNode tailB = headB;\r\n        Set<ListNode> hashSetA = new HashSet<>();\r\n        while(tailA != null){\r\n            hashSetA.add(tailA);\r\n            tailA = tailA.next;\r\n        }\r\n        while(tailB !=null){\r\n            if(hashSetA.contains(tailB)){\r\n                return tailB;\r\n            }\r\n            tailB=tailB.next;\r\n        }\r\n        return null;\r\n    }\r\n```\r\n## 复杂度\r\n时间 O(m+n)\r\n空间 O(m)\r\n### 双指针\r\n```java\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode currA = headA;\r\n        ListNode currB = headB;\r\n\r\n        while(currA !=currB){\r\n            if(currA ==null){\r\n                currA= headB;\r\n            }else{\r\n                currA = currA.next;\r\n            }\r\n\r\n            if(currB ==null){\r\n                currB = headA;\r\n            }else{\r\n                currB = currB.next;\r\n            }\r\n        }\r\n        return currA;\r\n    }\r\n```\r\n## 复杂度\r\n时间 O(m+n)\r\n空间 O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844734706","body":"## 思路\r\n1. hashset。借鉴昨天的每日一题，把listNode存在hashset里如果里面contains这个node，就说明开始loop了，return就行\r\n## 代码\r\n```java\r\n    public ListNode detectCycle(ListNode head) {\r\n        HashSet<ListNode> list = new HashSet<ListNode>();\r\n        ListNode current = head;\r\n        while(current !=null){\r\n            if(list.contains(current)){\r\n                return current;\r\n            }else{\r\n                list.add(current);\r\n            }\r\n            current=current.next;\r\n        }\r\n        return null;\r\n    }\r\n```\r\n## 复杂度\r\n时间O(n)\r\n空间O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liucy0417":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836309752","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n- 从低位相加，组成一个新的数组\r\n\r\n## 关键点\r\n\r\n-  进位问题\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int l = num.length;\r\n        int sum = 0;\r\n        List<Integer> arr = new ArrayList<>();\r\n        for(int i = l - 1; i>=0; i--) {\r\n            sum = num[i] + k % 10;\r\n            if(sum >= 10) {\r\n                sum =sum - 10;\r\n                k = k + 10;\r\n            }\r\n            arr.add(sum);\r\n            k = k / 10;\r\n        }\r\n        while(k != 0) {\r\n            arr.add(k % 10);\r\n            k = k / 10;\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr; \r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。一个for循环，时间复杂度：$O(n)$，开辟了一个新的数组内存，空间复杂度：$O(n)$。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837680823","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 字符串、数组\r\n\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n\r\n## 关键点\r\n\r\n-  从左向右、从右向左分别遍历一遍，找出较小的值\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] res = new int[length];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < length; i++) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = length - 1; i >=0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：O(n) ，n为数组长度 \r\n- 空间复杂度：O(n) ， 新数组res[]\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839798688","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 栈\r\n\r\n## 思路\r\n\r\n-  可以发现题目要求我们实现的 push、pop 和 inc 三个功能中，前两个功能就是普通的栈所具有的功能，为什么普通的栈没有 inc 功能呢？因为普通的栈只有栈顶元素是「可见」的，所以要实现的这个功能，我们就要让栈中的所有元素「可见」。\r\n\r\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n\r\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n\r\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1−1。\r\n\r\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\r\n\r\n空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"javanlu123":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836346588","body":"# 思路\r\n1.对每个分位进行叠加（注意进位以及分位存在判断的条件）\r\n2.最后一个进位的判断\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        // 这是一个典型的使用数组（字符串）的加法魔板\r\n        // 使用双向链表储存结果集\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int len = num.length - 1;\r\n        // 定义进位,初始默认为0\r\n        int carry = 0;\r\n        // 进行循环判断\r\n        // 数组下标以0开始，k以0为分界点\r\n        while(len>=0||k!=0){\r\n            // 定义数组num和k 的每个分位\r\n            int x = len>=0 ? num[len] : 0;\r\n            int y = k!=0 ? k%10 : 0;\r\n            int sum  = x + y + carry;\r\n            // 存入双向链表中\r\n            res.addFirst(sum % 10);\r\n            // 更新进位\r\n            carry = sum / 10;\r\n            // 分位进行移动\r\n            len--;\r\n            k /=10;\r\n        }\r\n        // 若最后的进位不为0，则头部补充\r\n        if(carry!=0){\r\n            res.addFirst(carry);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837614873","body":"# 思路1\r\n- 暴力解法\r\n把包含字符c的下标储存在零时数组，再遍历原有数组，与零时数组进行比较（取距离最小值）\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int[] temp = new int[len];\r\n        int x = 0;\r\n        // 把包含字符c的下标储存在零时数组\r\n        for(int i = 0; i < len; i++){\r\n            if(s.charAt(i)==c){\r\n                temp[x++] = i;\r\n            }\r\n        }\r\n        // 在原字符串中与零时数组进行比较\r\n        int min = len;\r\n        for(int i = 0; i < len; i++){\r\n            // 这里使用x，x是有效位数\r\n            for(int j = 0; j < x; j++){\r\n                min = Math.min(min,Math.abs(i-temp[j]));\r\n            }\r\n            res[i] = min;\r\n//            每次都要重置min值\r\n            min = len;\r\n        }\r\n        return res;\r\n\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N^2)\r\n- 空间复杂度o(N)\r\n\r\n\r\n# 思路2\r\n- 正反向数组遍历\r\n正向遍历，寻找每个位置到最近的c的最小值（向右搜索），反向遍历，则是向左搜索，更新每个位置到最近的c的最小值\r\n# 代码\r\n- Java\r\n~~~java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 使用正向、反向遍历法\r\n        int len = s.length();\r\n        // 定义结果数组\r\n        int[] res = new int[len];\r\n\r\n        // 正向遍历，向右搜索\r\n        // 定义一个标识变量prev，用于标记距离\r\n        int prev = -100000;\r\n        for(int i = 0; i < len; i++){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 标记当前位置距离\r\n            res[i] = i - prev;\r\n        }\r\n        // 反向遍历，向左搜索\r\n        // prev标记为 100000\r\n        prev = 100000;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            // 发现目标字符c，则prev标记为当前的i\r\n            if(s.charAt(i)==c)   prev = i;\r\n            // 使用min函数更新当前位置距离\r\n            res[i] = Math.min(res[i],prev - i);\r\n        }\r\n        // 返回结果集\r\n        return res;\r\n    }\r\n\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度o(N)\r\n- 空间复杂度o(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840536952","body":"# 思路\r\n方法一：使用辅助栈（默写k神代码）\r\n本题难点在于括号内嵌括号，需要从内向外生成于拼接字符串，和栈的先入后出特性一致\r\n- 构建辅助栈，遍历s中每个字符c\r\n   - c为数字，转化为int的数字multi（用于倍数计算）\r\n   - c为字母，在res（零时字符串）尾部加c\r\n   - c为[，将multi和res入栈，后分别置空置0\r\n      - 记录此[ 前的零时结果res入栈，用于发现对应]后的拼接操作\r\n      - 记录此[ 前的multi倍数入栈，用于发现对应]后，获取multi*[....]字符串\r\n      - 进入到新的[后，res和multi重新记录\r\n   - 当c为]，出栈，拼接字符串res = last_res +cur_multi * res\r\n- 返回字符串res\r\n# Java代码\r\n~~~java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        // 方法一：使用辅助栈法\r\n        // 这是一个零时字符串\r\n       StringBuilder res = new StringBuilder(); \r\n    //    默认的数字倍数是0\r\n       int multi = 0;\r\n    //    定义储存数字倍数的双向链表\r\n       LinkedList<Integer> stack_multi = new LinkedList<>();\r\n    //    定义储存临时字符串的双向链表\r\n    LinkedList<String> stack_res = new LinkedList<>();\r\n    // 对字符串s进行逐个字符遍历\r\n    for(Character c : s.toCharArray()){\r\n        if(c == '['){\r\n            // 遇到 [  则将之前的数字倍数multi和临时字符串出入链表中\r\n            stack_multi.addLast(multi);\r\n            stack_res.addLast(res.toString());\r\n            // 重置数字倍数和零时字符串\r\n            multi = 0;\r\n            res = new StringBuilder();\r\n        }else if( c == ']'){\r\n            // 遇到 ] 则将数字倍数和零时字符串的尾端移除，并拼装字符串res\r\n            // 这是内层的零时字符串，用于字符串*倍数\r\n            StringBuilder tmp = new StringBuilder();\r\n            // 获取尾端的倍数\r\n            int cur_multi = stack_multi.removeLast();\r\n            // 进行内层字符*倍数=内层零时字符串\r\n            for(int i = 0; i < cur_multi; i++){\r\n                tmp.append(res);\r\n            }\r\n            // 内层零时字符串于外层res进行拼装\r\n            res = new StringBuilder(stack_res.removeLast()+tmp);\r\n\r\n        }else if(c>='0'&&c<='9'){\r\n            // 字符串可能超过10,  12 = multi * 10 + 2\r\n            multi = multi * 10 +Integer.parseInt(c+\"\");\r\n        }else{\r\n            // 遇到普通字符，则添加到零时字符串中\r\n            res.append(c);\r\n        }\r\n        \r\n    }\r\n    return res.toString();\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N）\r\n- 空间复杂度:  O（N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840920465","body":"# 思路\r\n- 使用两个栈s1和s2,\r\n- s1栈实际是倒序的队列，s2实际是正序的队列\r\n- 进队要保证s2是空的，出队要保证s1是空（这样才能实现最终结果是正序的队列）\r\n# Java代码\r\n~~~java\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n\r\n    // 定义两个栈\r\n    Stack<Integer> s1 ;\r\n    Stack<Integer> s2 ;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!s2.isEmpty()){\r\n            // 若s2是不空，先把s2的元素弹入s1中\r\n            s1.push(s2.pop());\r\n        }\r\n        // s2为空了，可以进队了\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!s1.isEmpty()){\r\n            // 若s1是不空，则说明可以进行出队操作\r\n            int x = s1.pop();\r\n            s2.push(x);\r\n        }\r\n        // 返回s2的栈顶元素（出队）\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!s1.isEmpty()){\r\n          s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if(s1.isEmpty()&&s2.isEmpty()){\r\n            // s1和s2同时为空，那么队列就空\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N），每次都要倒腾栈中元素\r\n- 空间复杂度：O（N），申请了两个栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841587073","body":"# 思路\r\n使用单调栈\r\n- 排序块的定义：此块中最大数字为head，若此块后面数字都>=head,则此块为排序块\r\n- 非排序快内部进行合并操作，需要进行循环判断（弹栈）\r\n- 最后返回栈内个数（排序块的个数）\r\n# Java代码\r\n~~~java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // 使用单调栈解决问题\r\n        /**\r\n        首先是排序块的概念，（后一个值>=前一个值，就会成立一个新的排序块）\r\n        否则，就要进行融合（内部分块），在内部分块的时候，需要进行判断分块里最大值临界点\r\n        （不可以大于上一个块内的max值，因为这会是一个新的排序块）\r\n        */\r\n\r\n        Stack<Integer> s = new Stack<>();\r\n        // 进行遍历判断(栈不空，并且后一个值<前一个值,则进入内部分块环节)\r\n        for(int num : arr)\r\n        if(!s.empty()&&num<s.peek()){\r\n            // 临时储存head值\r\n            int head = s.peek();\r\n            // 进行内部的循环分块\r\n            while(!s.empty()&&num<s.peek()){\r\n                // 把栈内元素弹出（因为在内部，这不是最大的max值）\r\n                s.pop();\r\n            }\r\n            // 将最大值head储存到栈中\r\n            s.push(head);\r\n\r\n        }else{\r\n            // 否则就是入栈，是一个新的排序块\r\n            s.push(num);\r\n        }\r\n\r\n        // 返回栈内元素个数\r\n        return s.size();\r\n\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N）\r\n- 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841801967","body":"# 思路\r\n- 使用快慢指针，快指针先走k步，当快指针到达结尾，慢指针就是倒数第k+1个位置\r\n- 对于循环问题（类似跑道的位置问题）使用取余方法\r\n- 在进行截断位置的过程中，注意顺序，否则会导致链表为空\r\n# Java代码\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n// 考察双指针：快慢指针\r\n        /**\r\n        分析：向右移动k个位置，实际上就是将倒数的第k个位置进行截断\r\n        第k+1个位置.next = null，最后一个位置.next=head\r\n        */\r\n        if(head==null||head.next==null){\r\n            return head;\r\n        }\r\n        // 获取链表长度\r\n        ListNode temp = head;\r\n        int count = 0;\r\n        while(temp!=null){\r\n            count++;\r\n            temp = temp.next;\r\n        }\r\n        // 对k取余（跟跑道赛跑一样，这是一个循环量）\r\n        k = k % count;\r\n        // 定义快慢指针\r\n        ListNode fast,slow;\r\n        fast = slow = head;\r\n        // 快指针比慢指针先走k步\r\n        while(fast.next!=null){\r\n            if(--k<0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        // 此时的slow就是倒数的k+1位置\r\n        // 一定要让fast后面先连上head\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        \r\n       \r\n        return res;\r\n\r\n    }\r\n    \r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度:O(N)\r\n- 空间复杂度:O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841933743","body":"# 思路\r\n- 使用链表的交换节点操作（需要创建虚拟节点）\r\n- 使用递归（递归的核心在于写出递归出口）\r\n# Java代码(链表操作)\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // 考察对链表的操作:如何交换节点以及虚拟节点的使用\r\n        \r\n        if(head==null||head.next==null){\r\n            return head;\r\n        }\r\n        // 创建虚拟节点和结果链表等等\r\n        ListNode virtual = new ListNode(-1);\r\n        ListNode res,firstNode,secondNode,nextNode;\r\n        firstNode = head;\r\n        // 虚拟节点的next指向head节点\r\n        virtual.next = head;\r\n        // 结果链表指向head.next\r\n        res = head.next;\r\n        // 进行交换节点操作\r\n        // while循环体这样写是为了保证链表至少有两个元素存在！\r\n        while(firstNode!=null&&firstNode.next!=null){\r\n            // 注意不要让链表为空(画草图，写出正确的指针顺序)\r\n            // 进行初始化\r\n            secondNode = firstNode.next;\r\n            nextNode = secondNode.next;\r\n            // 开始交换操作\r\n            firstNode.next = nextNode;\r\n            secondNode.next = firstNode;\r\n            virtual.next = secondNode;\r\n            // 虚拟节点回到first位置\r\n            virtual = firstNode;\r\n            // first移动到next位置,这样就可以循环迭代了\r\n            firstNode = nextNode;\r\n        }\r\n        return res;\r\n        \r\n\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度O（N）\r\n- 空间复杂度O（1）\r\n\r\n# Java代码(递归)\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n // 分析题目可以知道这是一个循环的操作，并且上一个操作结果依赖\r\n        // 下一个操作，这样子就可以使用递归(递归后相当于逆序操作，依赖倒置了)\r\n        // 使用递归一定要注意递归出口以及什么时候使用递归！！！\r\n        if(head==null||head.next==null){\r\n            // 这是递归出口，当只剩下两两交换结束或者是有单个点，就返回\r\n            return head;\r\n        }\r\n        ListNode nextNode;\r\n        nextNode = head.next;\r\n        head.next = swapPairs(nextNode.next);\r\n        nextNode.next = head;\r\n        // 这个nextNode是一直在递归的，结束的时候nextNode就是第二个位置了\r\n        return nextNode;\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度:O(N)\r\n- 空间复杂度:O（1）不考虑递归栈\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842765672","body":"# 思路\r\n快慢指针+递归\r\n- 链表是有序链表\r\n- 二叉平衡树的中序遍历得到的是一组有序的数\r\n- 使用递归，root = 链表mid值， left = 链表左侧，right = 链表右侧\r\n- 通过快慢指针法进行定位mid值（慢指针每次走一步，快指针每次走两步，当快指针走完所有的节点时候，慢指针的位置就是中间节点的位置），通过穿针引线法进行切割左右子树\r\n# Java代码\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n// class Solution {\r\n//     public TreeNode sortedListToBST(ListNode head) {\r\n        /**\r\n        分析：\r\n        - 链表是有序链表\r\n        - 二叉平衡树的中序遍历得到的是一组有序的数\r\n        - 使用递归，root = 链表mid值， left = 链表左侧，right = 链表右侧\r\n        - 通过快慢指针法进行定位mid值（慢指针每次走一步，快指针每次走两步，当快指针走完所有的节点时候，慢指针的位置就是中间节点的位置），通过穿针引线法进行切割左右子树\r\n        */\r\n        // 注意编程的完整性（如果head是null，后面操作全是扯淡，并且会报空指针异常！！！）\r\n         if(head==null){\r\n             return null;\r\n         }\r\n        // 链表中间节点就是根节点root\r\n         ListNode mid = findMid(head);\r\n         // 进行中序遍历，构造二叉平衡树\r\n         TreeNode root = new TreeNode(mid.val);\r\n         // 这个是递归出口 mid==head时候，进行回溯\r\n         if(mid == head){\r\n             // 回溯，返回节点\r\n             return root;\r\n         }\r\n         root.left = sortedListToBST(head);\r\n         root.right = sortedListToBST(mid.next);\r\n         // 返回根节点\r\n         return root;\r\n    }\r\n     // 找到链表的中间节点\r\n     public ListNode findMid(ListNode head) {\r\n         ListNode fast,slow;\r\n         ListNode prev = null;\r\n         fast = slow = head;\r\n         // 注意循环体内的写法，可以使用图解理解\r\n         while(fast!=null&&fast.next!=null){\r\n             // 定义slow指针的前驱\r\n            prev = slow;\r\n             // 慢指针走一步\r\n             slow = slow.next;\r\n             // 快指针走两步\r\n             fast = fast.next.next;\r\n         }\r\n         // 切割左边链表\r\n         if(prev!=null){\r\n            prev.next = null;\r\n        }\r\n         // 不需要切割右边链表\r\n         // 此时慢指针就是链表的中间节点\r\n         return slow;\r\n     }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度:O(Nlog(N))\r\n- 空间复杂度:O(log（N）)\r\n\r\n# 代码优化\r\n- 上面的代码中，使用了prev进行进行切割左树，在实际中，可以使用类似归并排序的方法，不进行切割\r\n # Java代码\r\n~~~java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head==null){\r\n            return null;\r\n        } \r\n        return toBST(head,null);\r\n    }\r\n//快慢指针\r\n    public TreeNode toBST(ListNode head, ListNode tail){\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        if(head==tail) return null;\r\n        while(fast!=tail&&fast.next!=tail){\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n        }\r\n//merge sort 简化版代码，有点相似\r\n        TreeNode treehead = new TreeNode(slow.val);\r\n        treehead.left = toBST(head,slow);\r\n        treehead.right = toBST(slow.next,tail);\r\n        return treehead;\r\n    }\r\n}\r\n~~~"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843689596","body":"# 思路\r\n- 使用哈希表法（相交节点的本质是哈希表中储存的地址一致，这里使用hashset 而不是hashmap）\r\n- 使用双指针法（本质是一个追赶问题，A+B+C = B+C+A）\r\n# Java代码（哈希表法，性能较低）\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        /*\r\n        分析：使用哈希表法（因为节点在引用的时候是根据地址来链接的）\r\n        - 先将A遍历，储存在哈希表中\r\n        - 遍历B，同时在哈希表中搜索有没有相应的值（哈希值一致），那么就找到相交节点了\r\n        */\r\n        // HashSet和HashMap的区别：\r\n        // HashMap储存键值对\t          HashSet仅仅存储对象\r\n        // 使用put()方法将元素放入map中\t   使用add()方法将元素放入set中\r\n        HashSet<ListNode> hash  = new HashSet<>();\r\n       while(headA!=null){\r\n            // 将A中节点储存哈希表中\r\n            hash.add(headA);\r\n            headA = headA.next;\r\n        }\r\n        // 遍历表B\r\n        while(headB!=null){\r\n            if(hash.contains(headB)){\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度:O（N）\r\n- 空间复杂度:O（N）\r\n# Java代码（双指针法）\r\n~~~java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        /**\r\n        分析：本质是一个追赶问题\r\n        使用双指针法，若相交，那么链表1 可以表示成A+C ,链表2 可以表示成B+C\r\n        相交处：A+C+B = B+C+A,说明两指针相遇时，该指针指向节点就是相交节点\r\n        不相交时：由于两者都会同时达到对方链表的null处，最后返回任意一个指针（null）\r\n        */\r\n        ListNode p1,p2;\r\n        p1 = headA;p2 = headB;\r\n        // 循环终止条件是p1==p2\r\n        while(p1!=p2){\r\n            // 核心代码，A走完，走向B\r\n            p1 = p1==null ? headB : p1.next;\r\n            // B走完，走向A\r\n            p2 = p2==null ? headA : p2.next;\r\n        }\r\n        // 返回任意一个指针\r\n        return p1;\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度:O(N)\r\n- 空间复杂度:O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845788390","body":"# 思路\r\n使用双向链表和哈希表（有点难，跟着答案敲一遍还是会出错）\r\n# Java代码\r\n~~~java\r\nclass LRUCache {\r\n    /**\r\n    分析：这是一个设计题，难度较大。\r\n    对数据进行增删改操作，并且时间复杂度为O（1）====》双向链表\r\n    对数据进行查找操作，并且时间复杂度为O（1）====》哈希表\r\n    最后选择的数据结构是 哈希表+双向链表（伪头部和伪尾部法）\r\n    主要的业务逻辑，在代码注释中说明\r\n     */\r\n\r\n    // 数据结构为 双向链表，包含了键值对，前驱后驱节点，构造函数\r\n    class DLinkedNode{\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        DLinkedNode(){\r\n        }\r\n        DLinkedNode(int _key,int _value){\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n    // 数据结构为 哈希表，用来查找\r\n    HashMap<Integer,DLinkedNode> cache = new HashMap<>();\r\n    // 定义链表的长度，伪头部，伪尾部\r\n    private int size;\r\n    private DLinkedNode head,tail;\r\n    // 定义LRUCache的容量（哈希表里面是不需要设置容量的，整体设置就行）\r\n    private int capacity;\r\n    // LRUCache的构造函数\r\n    public LRUCache(int capacity) {\r\n        // 初始化的时候，让链表长度为0\r\n        this.size = 0;\r\n        // 初始化capacity\r\n        this.capacity = capacity;\r\n        // 初始化伪头部和伪尾部信息\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        // 伪头部和伪尾部进行连接\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    /**\r\n    核心思想：\r\n    在哈希表中查找，找到就返回相应的节点值（同时将该节点移动到链表头部），未找到就返回-1\r\n     */\r\n    public int get(int key) {\r\n        // 调用哈希表的查找函数\r\n        DLinkedNode res = cache.get(key);\r\n        if(res==null){\r\n            // 未找到节点\r\n            return -1;\r\n        }\r\n        // 调用内部类的移动到头部函数（自己写，返回void）,注意：原有节点也要删除\r\n        moveToHead(res);\r\n        // 返回节点值\r\n        return res.key;\r\n\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n    /**\r\n    核心思想：\r\n    在哈希表中查找，找到就更新相应的节点值（同时将该节点移动到链表头部）\r\n    未找到就新建一个（同时将该节点移动到链表头部）\r\n    若缓存容量达到上限，就删除尾部的哈希节点（对应到链表节点中）\r\n    */\r\n    // 调用哈希表的查找函数（自己写，返归节点）\r\n        DLinkedNode res = cache.get(key);\r\n        if(res!=null){\r\n            // 找到节点,更新节点信息，将节点移动到头部去\r\n            res.value = value;\r\n            moveToHead(res);\r\n        }else{\r\n            // 未找到节点，则新建一个\r\n            DLinkedNode newNode= new DLinkedNode(key,value);\r\n            // 链表长度+1\r\n            size++;\r\n            // 添加到头部\r\n            addToHead(newNode);\r\n            // 添加到哈希表中\r\n            cache.put(key,newNode);\r\n            // 判断size和capacity的关系\r\n            if(size>capacity){\r\n                // 移除尾部的节点信息\r\n                DLinkedNode tailNode = moveTailNode();\r\n                // 删除哈希表中的项\r\n                cache.remove(tailNode.key);\r\n                // size-1\r\n                size--;\r\n            }\r\n        }\r\n    }\r\n    // 内部添加到头部函数\r\n    public void addToHead(DLinkedNode node){\r\n        // 移动节点到头部\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n    \r\n    // 内部移动到头部函数\r\n    public void moveToHead(DLinkedNode node){\r\n        // 先删除原有节点\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        // 再移动节点到头部\r\n        addToHead(node);\r\n    }\r\n    // 内部移除尾部的节点信息\r\n    public DLinkedNode moveTailNode(){\r\n        DLinkedNode node = tail.prev;\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        return node;\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（1）\r\n- 空间复杂度:   O  (N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846322022","body":"# 思路\r\n- 二叉树是一个递归的数据结构\r\n- 最大深度使用DFS\r\n- 使用递归的时候，可以套用产品经理法（只考虑逻辑，不考虑实现）\r\n# Java代码\r\n~~~java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        // 初步想法使用递归\r\n        int  depth = 0;\r\n        if(root==null){\r\n            return 0;\r\n        }\r\n        // 取左子树和右子树中的最大值\r\n        depth = Math.max(maxDepth(root.left),maxDepth(root.right));\r\n        // +1 是为了考虑原有节点\r\n        return depth + 1;\r\n         \r\n    }\r\n}\r\n~~~\r\n# 复杂度分析\r\n- 时间复杂度：O（N） 每个节点都遍历一遍\r\n- 空间复杂度:   O  (N)  不平衡二叉树的深度至少是log（N） ，最坏情况下会退化成一个链表，深度为N，因此递归情况下使用的栈空间是O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BryanMiracle":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836356594","body":"**思路**\r\n新建一个链表，存储各位相加的结果。从低位到高位，逐一相加，并将结果返回\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new ArrayList<Integer>();\r\n        int n=num.length;\r\n        int sum=0,curr=0,i=n-1;\r\n        while(i>=0 || k!=0){\r\n            int x=i>=0?num[i]:0;\r\n            int y=k!=0?k%10:0;\r\n            sum=x+y+curr;\r\n            curr=sum/10;\r\n            k=k/10;\r\n            i--;\r\n            res.add(0,sum%10);\r\n        }\r\n        if(curr!=0){\r\n            res.add(0,curr);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837667625","body":"**思路**\r\n针对给定字符串中的每个字符，试图找出距离其 向左/向右 离它最近的字符C的距离 ，并选择最近的距离\r\n-- 从左向右遍历，记录上一个字符C出现的位置 prev，此时距离就是：i-prev\r\n-- 从右向左遍历，记录上一个字符C出现的位置prev，此时距离就是 prev-i\r\n-- 取较小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n=s.length();\r\n        int[] ans=new int[n];\r\n        int prev=Integer.MIN_VALUE/2;\r\n        //从左向右遍历\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=i-prev;\r\n        }\r\n        //从右向左遍历\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i)==c){\r\n                prev=i;\r\n            }\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：（N）\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839614668","body":"**思路**\r\n借用数组模拟栈\r\n**代码**\r\n```\r\nclass CustomStack {\r\n    //数组模拟栈\r\n    int[] stack;\r\n    int top;//记录栈顶元素\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top!=stack.length-1){\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top+1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int size=Math.min(k,top+1);\r\n        for(int i=0;i<size;i++){\r\n            stack[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：push/pop:O(1) , increment: O（k）\r\n-- 空间复杂度：O（maxSize）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640094","body":"**思路**\r\n构建辅助栈，遍历字符串s中每个字符，分情况处理\r\n**代码**\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841093548","body":"**思路**\r\n双栈：进栈：**inStack**、出栈：**outStack**\r\n**push()** 时，直接压入inStack栈：inStack.push\r\n**pop()/peek()** 时，要判断outStack栈中出否还有元素：如果还有，就直接处理outStack；\r\n如果没有，就先把inStack栈里所有元素**一次性全部**弹出，并**一次性全部**压入outStack栈中。然后对outStack栈进行相应操作。\r\n**empty()** 时，只有两个栈都为空时，此时队列才为空\r\n\r\n**代码**\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> inStack;\r\n    private Stack<Integer> outStack;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack=new Stack<Integer>();\r\n        outStack=new Stack<Integer>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        //如果outStack为空，则将inStack栈全部弹出并压入outStack栈中，然后弹出\r\n        if(outStack.isEmpty()){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n        return outStack.pop();\r\n        \r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(outStack.isEmpty()){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n        return outStack.peek();\r\n        }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(1)\r\n-- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679831","body":"**思路**\r\n前后两次遍历：\r\n先遍历一遍，记录到当前数为止的最大值head；\r\n然后从后往前遍历，如果遍历过的arr数组里的最小值比前一个分块的最大值head要大，块的数量 + 1；\r\n遍历时要维护一下遍历过的arr里的最小值\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] head = new int[arr.length];\r\n        head[0] = arr[0];\r\n        for(int i = 1; i < arr.length; i++){\r\n            head[i] = Math.max(head[i - 1], arr[i]);\r\n        }\r\n        int tail = Integer.MAX_VALUE, res = 0;\r\n        for(int i = arr.length - 1; i >= 0; i--){\r\n            if(tail >= head[i]){\r\n                res++;\r\n            }\r\n            tail = Math.min(tail, arr[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841825732","body":"**思路**\r\n将链表闭合为环：先将给定的链表连接成环，然后将环从指定位置断开为新的链表\r\n**代码**\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(k==0 || head==null ||head.next==null){\r\n            return head;\r\n        }\r\n        //计算原始链表的长度：n\r\n        int n=1;\r\n        ListNode p=head;\r\n        while(p.next!=null){\r\n            p=p.next;\r\n            n++;//此时 n记录的是链表的末尾节点\r\n        }\r\n        //找到移动k位后  新链表的末尾节点\r\n        int np=n-k%n;\r\n        if(np==n){\r\n            return head;\r\n        }\r\n        //逻辑判断\r\n        p.next=head;//闭合链\r\n        while(np-->0){\r\n            p=p.next;//将p指向新链表的最后一个节点位置\r\n        }\r\n        ListNode res=p.next;\r\n        p.next=null;\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842169315","body":"**思路**\r\n**1、递归调用**\r\n如果链表中至少有两个节点，则两两交换链表中节点之后，原始链表头节点（head）变为新链表的第二个节点，原始链表第二个节点变为新链表的头节点（newHead）。之后递归调用其余节点，最后更新节点之间的指针关系，即可完成整个链表的两两交换。\r\n**代码**\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null ||head.next==null){\r\n            return head;\r\n        }\r\n        //head 原始链表头节点，新链表的第二个节点\r\n        //newHead 原始链表第二个节点，新链表的头节点\r\n        ListNode newHead=head.next;\r\n        head.next=swapPairs(newHead.next);\r\n        newHead.next=head;\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O（N）\r\n-- 空间复杂度：O（N）\r\n\r\n**2、迭代法**\r\n**代码**\r\n\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n        ListNode temp = dummyHead;\r\n        while (temp.next != null && temp.next.next != null) {\r\n            ListNode node1 = temp.next;\r\n            ListNode node2 = temp.next.next;\r\n            temp.next = node2;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            temp = node1;\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O（N）\r\n-- 空间复杂度：O（1）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843243948","body":"**思路**\r\n寻找链表中间节点作为根节点，然后再找中点两边的子链表的中点，一路递归直到子链表为空\r\n1、特殊情况处理：如果head为空返回null，如果head.next为空，返回值为head.val的树节点\r\n2、利用快慢指针寻找链表中点，slow每次都一步，fast每次走两步，同时记录slow的前一个节点pre，为后面断开链表准备\r\n3、创建树的根节点，把slow的值赋给它，并断开链表中间节点和左边子链表的连接\r\n4、递归链表中间节点左右两边的子链表，找子链表的中间节点，再找子的子链表的中间接节点.....\r\n**代码**\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head==null){\r\n            return null;\r\n        }else if(head.next==null){\r\n            return new TreeNode(head.val);\r\n        }\r\n        ListNode slow=head,fast=head;\r\n        ListNode pre=null;\r\n        while(fast!=null && fast.next!=null){\r\n            pre=slow;\r\n            slow=slow.next;\r\n            fast=fast.next.next;\r\n        }\r\n        TreeNode root =new TreeNode(slow.val);\r\n        pre.next=null;\r\n\r\n        root.left=sortedListToBST(head);\r\n        root.right=sortedListToBST(slow.next);\r\n        return root;\r\n\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n--时间复杂度：O(N)\r\n--空间复杂度：O(logn)，平衡二叉树的高度O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844190727","body":"**思路**\r\n双指针\r\n两链表的公共节点：node，链表A的长度为a,链表b的长度为b，公共部分长度为c；\r\npA指针，pB指针分别指向headA，headB。都到各自链表末尾时，指针跳转到对方的头节点处，然后继续遍历，直到相交于node处，此时pA走过的距离：a+b-c  ==pB走过的距离 b+a-c\r\n**代码**\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pA=headA,pB=headB;\r\n        while(pA!=pB){\r\n            pA=pA!=null?pA.next:headB;\r\n            pB=pB!=null?pB.next:headA;\r\n        }\r\n        return pA;        \r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(a+b)\r\n-- 空间复杂度：O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846047734","body":"**思路**\r\n双链表+哈希表\r\n**代码**\r\n```\r\nclass LRUCache {\r\n\r\n    private Map<Integer, Node> map;\r\n    private DoubleList doubleList;\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>(capacity);\r\n        doubleList = new DoubleList();\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key))\r\n            return -1;\r\n        else {\r\n            Node node = map.get(key);\r\n            doubleList.moveToFirst(node);\r\n            return node.val;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        Node node = new Node(key, value);\r\n        if (map.containsKey(key)) {\r\n            doubleList.remove(map.get(key));\r\n            doubleList.addFirst(node);\r\n            map.put(key, node);\r\n        } else {\r\n            if (doubleList.size() == capacity) {\r\n                map.remove(doubleList.removeLast().key);\r\n            }\r\n            doubleList.addFirst(node);\r\n            map.put(key, node);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n class DoubleList {\r\n\r\n    private Node head;\r\n    private Node tail;\r\n    private int count = 0;\r\n\r\n    public DoubleList() {\r\n        head = new Node();\r\n        tail = new Node();\r\n        head.pre = null;\r\n        head.next = tail;\r\n        tail.pre = head;\r\n        tail.next = null;\r\n    }\r\n\r\n    public void addFirst(Node node) {\r\n        node.next = head.next;\r\n        node.pre = head;\r\n        head.next.pre = node;\r\n        head.next = node;\r\n        count++;\r\n    }\r\n\r\n    public void remove(Node node) {\r\n        node.pre.next = node.next;\r\n        node.next.pre = node.pre;\r\n        count--;\r\n    }\r\n\r\n    public Node removeLast() {\r\n        Node node = tail.pre;\r\n        tail.pre = tail.pre.pre;\r\n        tail.pre.next = tail;\r\n        count--;\r\n\r\n        return node;\r\n    }\r\n\r\n    public void moveToFirst(Node node) {\r\n        remove(node);\r\n        addFirst(node);\r\n    }\r\n\r\n    public int size() {\r\n        return count;\r\n    }\r\n}\r\n\r\nclass Node {\r\n\r\n    public int key, val;\r\n    public Node next, pre;\r\n\r\n    public Node() {\r\n\r\n    }\r\n\r\n    public Node(int k, int v) {\r\n        this.key = k;\r\n        this.val = v;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n时间复杂度：O(1)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846424758","body":"**思路**\r\nDFS\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        } else {\r\n            int leftHeight = maxDepth(root.left);\r\n            int rightHeight = maxDepth(root.right);\r\n            return Math.max(leftHeight, rightHeight) + 1;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n-- 时间复杂度：O(N)\r\n-- 空间复杂度：O(height)， height表示二叉树的高度\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DoubleW2w":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836444832","body":"emmmmm，加油，这次看了答案，下次争取不看答案！！！！\r\n不知道空间复杂度怎么分析，就删除了。\r\n## 思路\r\n\r\n加法主要就是判断进位的问题。相加的选择，我们可以从低位往高位相加\r\n\r\n1. 如果没有产生进位，那什么情况才停止相加呢？比如 $123+23=146$和 $123+1234=1367$\r\n2. 如果产生进位，但没有发生数组越界的情况，比如$123+37=160 $和$123+1137=1260$\r\n3. 如果产生进位，但发生了数组越界呢？比如$999+1=1000$\r\n\r\n---\r\n\r\n第一种情况：当我们低位往高位相加的时候，`k=0`的时候或者`遍历完num`，我们就停止了相加。\r\n\r\n第二种情况：就在第一种情况的基础上，在中间增加个进位的处理，其停止的情况还是`k=0`的时候或者`遍历完num`。\r\n\r\n第三种情况：就在第二种情况的基础上，最后增加高位还有进位的处理情况。而停止还是一样的\r\n\r\n因此总结一下：\r\n\r\n来自题解区的一位大佬\r\n\r\n```java\r\n<公式>\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code1:\r\n\r\n```java\r\n//官方题解\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //从低位往高位相加\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        //遍历num，但k也在发生变化\r\n        for(int i = n-1;i >= 0; i--){\r\n            int sum = num[i] + k%10;\r\n            k /=10;\r\n            if(sum >= 10){\r\n                //把进位放在k上\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        //如果num的位数>k的位数，此时的k是为0或者是最高位的进位\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n\r\nJava Code2:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k){\r\n        //当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n        int n = num.length;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry =0, sum =0,index = n-1;\r\n        while(index >=0 || k!=0){\r\n            // num的当前位\r\n            int x = index >=0 ? num[index] : 0;\r\n            // K的当前位\r\n            int y = k != 0 ? k%10 : 0;\r\n\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            index --;\r\n            res.add(sum % 10);\r\n        }\r\n        if (carry != 0){\r\n            res.add(carry);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873063","body":"## 思路\r\n\r\n1. 用数组来模拟栈\r\n2. 解决`increment`功能\r\n   - 第一种：遍历循环，在数组里面提前`increment`，时间复杂度$O(n)$\r\n   - 第二种：只在**要pop出来的元素**`increment`，时间复杂度$O(1)$\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * int[] stack: 初始化的栈\r\n * int top：栈顶位置\r\n * int[] add: 增量数组\r\n */\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top!= stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top!=-1){\r\n            top--;\r\n        }else{\r\n            return -1;\r\n        }\r\n        return stack[top+1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num = Math.min(k,top+1);\r\n        for(int i=0;i<num;i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 maxSize 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(maxSize)$\r\n\r\n---\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * int[] stack: 初始化的栈\r\n * int top：栈顶位置\r\n * int[] add: 增量数组\r\n */\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top!= stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n\r\n    public int pop(){\r\n        if(top==-1){\r\n            return -1;\r\n        }\r\n        int res = stack[top] + add[top];\r\n        if(top!=0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top]=0;\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    //优化inc操作\r\n    public void increment(int k, int val) {\r\n        //k：要操作的元素个数 top+1:栈的元素个数\r\n        //limitIndex为要操作的最上面元素下标（不一定是栈顶元素）\r\n        int limitIndex = Math.min(k-1,top);\r\n        if(limitIndex>=0){\r\n            add[limitIndex]+=val;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 maxSize 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(maxSize)$"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841322477","body":"## 思路\r\n\r\n1. 摊还分析\r\n\r\n最坏情况下的操作一旦发生了一次，那么在未来很长一段时间都不会再次发生，这样就会均摊每次操作的代价。\r\n\r\n2. 利用另外一个栈来辅助，用来翻转栈的元素顺序，就可以实现出栈时的时间复杂度为O（1）\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack = new Stack<>();\r\n    Stack<Integer> popStack = new Stack<>();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!popStack.isEmpty()){\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!pushStack.isEmpty()){\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!pushStack.isEmpty()){\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return popStack.isEmpty() && pushStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680338","body":"## 思路\r\n\r\n第一种思路：单调栈\r\n\r\n一直在寻找下一个比当前小的元素，当找到了以后，就进行融合。\r\n\r\n**栈存储的每一个元素就代表一个块，而栈里面的每一个元素的值就是块的最大值**\r\n\r\n\r\n\r\n第二种思路：计数\r\n\r\n**如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的。**\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJavaCode：\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr){\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        //遍历每个数字num\r\n        for (int num : arr) {\r\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if (!stack.isEmpty() && num < stack.getLast()) {\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                int head = stack.removeLast();\r\n                // 维持栈的单调递增\r\n                //判断加入 num 需要合并的所有排序块，每pop()一个head代表合并一个块\r\n                while (!stack.isEmpty() && num < stack.getLast()) {\r\n                    stack.removeLast();\r\n                }\r\n                //将head重新加入，作为新排序块的最大值\r\n                stack.addLast(head);\r\n                //当栈为空或者num>=栈顶值时,把num压入栈---->加入了单个元素的排序块[num]\r\n            }else {\r\n                stack.addLast(num);\r\n            }\r\n        }\r\n        // 栈存的是块信息，因此栈的大小就是块的数量\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n---\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n        return ans;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841832061","body":"## 思路\r\n\r\n获取链表长度，求余是因为如果k是链表长度的倍数，那就等于没旋转。\r\n\r\n所以求余得到快慢指针的距离\r\n\r\n慢指针指向的是旋转后的尾节点，快指针指向的是形成环的那个节点。\r\n\r\n而新的头节点是慢指针指向节点的下一个节点\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //特判\r\n        if(head == null || head.next == null) return head;\r\n        ListNode fast = head,slow = head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        //计算链表长度\r\n        while(now !=null){\r\n            now = now.next;\r\n            count ++;\r\n        }\r\n        //如果k是链表长度的倍数，就直接返回该链表\r\n        //所以旋转k次其实就是旋转(k%count)次\r\n        k = k % count;\r\n        //while循环结束后，fast快于slow k步\r\n        while(fast.next != null){\r\n            if(k<=0){\r\n                slow = slow.next;\r\n            }\r\n            k -= 1;\r\n            fast = fast.next;\r\n        }\r\n        \r\n        //将尾节点 next 指向 head（拼起来）\r\n        fast.next = head;\r\n        //将倒数第 k + 1 个节点的 next 指向 null\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        //返回倒数第 k 个节点\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842431763","body":"## 思路\r\n\r\n没看懂解析！！！，在补。加油\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        //特例\r\n        if(head == null || head.next==null) {\r\n            return head;\r\n        }\r\n        //preA -> A -> B -> nextB\r\n        ListNode preNode = new ListNode(-1, head),res;\r\n        res = head.next;\r\n        preNode.next = head;\r\n        ListNode firstNode = head, secondNode, nextNode;\r\n        while(firstNode != null && firstNode.next != null){\r\n            secondNode = firstNode.next;\r\n            nextNode = secondNode.next;\r\n            //\r\n            firstNode.next = nextNode;\r\n            secondNode.next = firstNode;\r\n            preNode.next = secondNode;\r\n\r\n            preNode = firstNode;\r\n            firstNode = nextNode;\r\n        }\r\n        return res;\r\n    }\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846045029","body":"##思路\r\n双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\r\n\r\n哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置\r\n\r\n先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部。\r\n\r\n##代码\r\n```java\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache.put(key, newNode);\r\n            // 添加至双向链表的头部\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode tail = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(1)。\r\n\r\n空间复杂度：O(capacity)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ARe99s":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836448740","body":"**思路**\r\n直接把K加到A上\r\n**代码 python**\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n```\r\n**时间复杂度**\r\nO(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FontEndArt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836454805","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 思路\r\n循环判断k，k存在即代表还需要进行加法计算，每次加k的个数位，然后k抹去个数位的值，最后并判断是否有进一，有则k++。\r\n\r\n如果超出num的长度则使用unshift在数组首位增加。（其他语言如果没有动态数组的，可能需要预先申请足够的空间）\r\n\r\n## 关键点\r\n\r\n-  进一位的处理\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let i = num.length - 1\r\n    while (k > 0) {\r\n        let tmp = k % 10;\r\n        k = Math.floor((k - tmp) / 10)\r\n        if (i < 0) {\r\n            num.unshift(tmp)\r\n            // 注意是continue： [0], 10000\r\n            continue\r\n        }\r\n        // 注意是>=而不是>\r\n        if ((num[i] + tmp) >= 10) {\r\n            k++\r\n        }\r\n        num[i] = (num[i] + tmp) % 10\r\n        i--\r\n    }\r\n    return num\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838391375","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 正反遍历\r\n- Infinity\r\n\r\n## 思路\r\n正反遍历，注意res[i]初始值为Infinity\r\n\r\n> 也可以双指针, 考虑正反遍历或单次遍历，只不过单次遍历需要相当于滑动窗口，然后每次指针移动都要去判断赋值\r\n \r\n> 朋友用的中心扩展法也不是不行，只不过复杂度稍微高了一点，需要双端边界都要到头才可以。\r\n> range(0,s.length)或者匹配到与c的字符满足其一是单端边界结束调节。\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n    let cIndex = -1;\r\n    const res = Array(s.length).fill(Infinity)\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n            res[i] = 0\r\n        } else {\r\n            res[i] = Math.min(i - cIndex, res[i])\r\n        }\r\n    }\r\n    cIndex = -1;\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (s[i] !== c && cIndex < 0) {\r\n            continue\r\n        }\r\n        if (s[i] === c) {\r\n            cIndex = i\r\n        } else {\r\n            res[i] = Math.min(cIndex - i, res[i])\r\n        }\r\n    }\r\n    return res\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839694826","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 思路\r\n\r\n利用数组\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.arr = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.arr.length < this.maxSize) {\r\n        this.arr.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    let val = this.arr.pop()\r\n    return val === undefined ? -1 : val\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < k && i < this.arr.length; i++) {\r\n        this.arr[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- push\r\n    - 时间复杂度：$O(1)$\r\n    - 空间复杂度：$O(1)$\r\n\r\n- pop\r\n    - 时间复杂度：$O(1)$\r\n    - 空间复杂度：$O(1)$\r\n\r\n- increment\r\n    - 时间复杂度：$O(n)$ n为max(k, this.arr.length)\r\n    - 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840406782","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 思路\r\n\r\ndfs, 关键点看代码注释。\r\n> repeat部分其他语言可以用伪代码`let j = 0; while(j<(num||1)){str+=tmp}`或`for i in range(num||1)`替代\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s, i = 0) {\r\n    let num = '';\r\n    let str = '';\r\n    while (i < s.length) {\r\n        if (/\\d/.test(s[i])) {\r\n            num += s[i]\r\n            i++\r\n        }\r\n        if (/[a-z]/.test(s[i])) {\r\n            str += s[i]\r\n            i++\r\n        }\r\n        if ('[' === s[i]) {\r\n            // 跳过已经经过的 ']'\r\n            let [tmp, nextIndex] = decodeString(s, i + 1)\r\n            // '进行重复'\r\n            str += tmp.repeat(num || 1)\r\n            i = nextIndex\r\n            num = ''\r\n        }\r\n        // 只会出现在递归的深层中\r\n        if (']' === s[i]) {\r\n            return [str, i + 1]\r\n        }\r\n    }\r\n    return str\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$ n为s.length\r\n- 空间复杂度：$O(n)$\r\n> 额外的空间\r\n\r\n\r\n"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842236875","body":"## 思路\r\n迭代\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    let res = new ListNode(-1)\r\n    res.next = head\r\n\r\n    let pre = res;\r\n    while (pre.next && pre.next.next) {\r\n        const [a, b] = [pre.next, pre.next.next]\r\n       // 第一次矫正res.next，后续模拟滚动\r\n        pre.next = b\r\n        a.next = b.next\r\n        b.next = a\r\n        pre = a\r\n    }\r\n\r\n    return res.next\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度 $O(n)$\r\n- 空间复杂度 $O(1)$"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843705122","body":"## 思路\r\nA+B=B+A\r\n\r\n## 代码\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    let curA = headA\r\n    let curB = headB\r\n    while (curA !== curB) {\r\n        curA = curA ? curA.next : headB\r\n        curB = curB ? curB.next : headA\r\n    }\r\n    return curA\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度 $O(n)$\r\n- 空间复杂度 $O(1)$\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845004059","body":"## 思路\r\n缓存记录\r\n\r\n## 代码\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n    let set1 = new Set();\r\n    while (head) {\r\n        if (set1.has(head)) {\r\n            return head\r\n        } else {\r\n            set1.add(head)\r\n        }\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845861789","body":"## 思路\r\n先打卡\r\n## 代码\r\n```js\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.data = [];\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    const oldIndex = this.data.findIndex(item => item.key === key)\r\n    if (oldIndex === -1) {\r\n        return -1\r\n    }\r\n    this.data.push(...this.data.splice(oldIndex, 1))\r\n    return this.data[this.data.length - 1].value\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    const oldIndex = this.data.findIndex(item => item.key === key)\r\n    if (oldIndex === -1) {\r\n        if (this.data.length >= this.capacity) {\r\n            this.data.shift()\r\n        }\r\n        this.data.push({\r\n            key,\r\n            value\r\n        })\r\n    } else {\r\n        this.data[oldIndex].value = value\r\n        this.data.push(...this.data.splice(oldIndex, 1))\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n## 复杂度\r\n- O(n)\r\n- O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Siomarry":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836474356","body":"- 思路\r\n每次取出K的最后一位以及数组的最后一位进行相加，并且依次进位相加.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        //建立一个vector<int> K的数组，然后两个vector进行相加.\r\n        queue<int> Kdigit;\r\n        while(k){\r\n            Kdigit.push(k % 10);k = k / 10;\r\n        }\r\n        //第二步，将栈中的元素和num进行相加.\r\n        deque<int> ans;int endpoint = ans.size() - 1;\r\n        //设置一个最大长度的ans.\r\n        int numpoint = num.size() - 1;int plus = 0;\r\n        while(!Kdigit.empty() && numpoint >= 0){\r\n\r\n            ans.push_front((plus + Kdigit.front() + num[numpoint]) % 10);\r\n            plus = (plus + Kdigit.front() + num[numpoint]) / 10;\r\n            Kdigit.pop();numpoint--;endpoint--;\r\n        }\r\n        //结束时判断最后的条件.\r\n        while(!Kdigit.empty()){  //若数字不为空\r\n            ans.push_front((plus + Kdigit.front()) % 10);\r\n            plus = (plus + Kdigit.front()) / 10;\r\n            Kdigit.pop();\r\n        }\r\n\r\n        while(numpoint >= 0){  //若原数组不为空\r\n            ans.push_front((plus + num[numpoint]) % 10);\r\n            plus = (plus + num[numpoint]) / 10;\r\n            numpoint--;\r\n        }\r\n        if(plus)\r\n            ans.push_front(plus);\r\n\r\n        vector<int> result(ans.begin(),ans.end());\r\n        return result;\r\n    }\r\n};\r\n```\r\n- 时间复杂度\r\n    O(max(n，logk))\r\n\r\n- 空间复杂度\r\n    O(max(n,logk))\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838292817","body":"- 思路\r\n对于选定的字符，通过左右双指针来寻找贪心寻找距离最近的字符.\r\n\r\n- 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int ComputerDis(string s,int current,char c){\r\n        //在s中计算c离current最近的字符.\r\n        if(s[current] == c)\r\n            return 0;\r\n        int left = current - 1;int right = current + 1;\r\n        while(left >=0 && right <= s.size() - 1){\r\n            if(s[left] == c || s[right] == c){\r\n                return right - current;\r\n            }\r\n            else{\r\n                left--;right++;\r\n            }\r\n        }\r\n        while(left >= 0){\r\n            if(s[left] == c){\r\n                return current - left;\r\n            }\r\n            else\r\n                left--;\r\n        }\r\n        while(right <= s.size() - 1){\r\n            if(s[right] == c){\r\n                return right - current;\r\n            }else\r\n                right++;\r\n        }\r\n        return -1;\r\n    }\r\n    vector<int> shortestToChar(string s, char c){\r\n        vector<int> ans;\r\n        for(int i = 0;i<s.size();i++){\r\n            ans.push_back(ComputerDis(s,i,c));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839606626","body":"- 思路\r\n使用一个vector<int>进行模拟\r\n- 代码\r\n```c++\r\nclass CustomStack {\r\n    vector<int> stackvector;\r\n    int top = -1;\r\n    int maxSize = 0;\r\npublic:\r\n    CustomStack(int maxSize){\r\n        this->maxSize = maxSize;\r\n        top = -1;\r\n    }\r\n    void push(int x){\r\n        if(top != maxSize - 1){\r\n            stackvector.push_back(x);\r\n            top++;\r\n        }\r\n    }\r\n\r\n    int pop(){\r\n        if(top == -1)\r\n            return -1;\r\n        int result = stackvector[top--];\r\n        stackvector.pop_back();\r\n        return result;\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        for(int i = 0;i< min(k,top + 1);i++){\r\n            stackvector[i]+=val;\r\n        }\r\n    }\r\n};\r\n```\r\n- 时间复杂度: O(1)\r\n- 空间复杂度: O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miqpalzm":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836476818","body":"public class Solution {\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n        var kLen = k.ToString().Length;\r\n            int[] kArr = new int[kLen];\r\n            for (var i = kLen - 1; i >= 0; i--)\r\n            {\r\n                if (k / 10 > 0)\r\n                {\r\n                    kArr[i] = k % 10;\r\n                    k = k / 10;\r\n                }\r\n                else\r\n                {\r\n                    kArr[i] = k;\r\n                }\r\n            }\r\n\r\n            var addExtra = false;\r\n            var nLen = num.Length;\r\n            var list = new List<int>();\r\n            for (int i = nLen - 1, j = kLen - 1; i >= 0 || j >= 0; i--, j--)\r\n            {\r\n                var nValue = (i > nLen - 1 || i < 0) ? 0 : num[i];\r\n                var kValue = (j > kLen - 1 || j < 0) ? 0 : kArr[j];\r\n                var sum = nValue + kValue + (addExtra ? 1 : 0);\r\n                if (sum >= 10)\r\n                {\r\n                    addExtra = true;\r\n                    sum = sum % 10;\r\n                }\r\n                else\r\n                {\r\n                    addExtra = false;\r\n                }\r\n\r\n                list.Add(sum);\r\n            }\r\n\r\n            if (addExtra)\r\n            {\r\n                list.Add(1);\r\n            }\r\n            list.Reverse();\r\n\r\n            return list;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838451850","body":"语言：C#\r\n\r\npublic class Solution {\r\n    public int[] ShortestToChar(string s, char c) {\r\n        var charArr = s.ToCharArray();\r\n            var intArr = new int[charArr.Length];\r\n\r\n            int lastIndex = -1, aheadIndex = s.IndexOf(c);\r\n            for (var i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (i == aheadIndex)\r\n                {\r\n                    lastIndex = aheadIndex;\r\n                    charArr[lastIndex] = '#';\r\n                    aheadIndex = new string(charArr).IndexOf(c);\r\n                }\r\n                var left = Math.Abs(i - (lastIndex == -1 ? aheadIndex : lastIndex));\r\n                var right = Math.Abs((aheadIndex == -1 ? lastIndex : aheadIndex) - i);\r\n                intArr[i] = left < right ? left : right;\r\n            }\r\n\r\n            return intArr;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839758358","body":"c#\r\n\r\npublic class CustomStack {\r\n\r\n    private int[] intArr;\r\n    private int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        intArr = new int[maxSize];\r\n        index = 0;\r\n    }\r\n    \r\n    public void Push(int x)\r\n        {\r\n            if (index == intArr.Length)\r\n            {\r\n                return;\r\n            }\r\n\r\n            intArr[index] = x;\r\n            index++;\r\n        }\r\n\r\n        public int Pop()\r\n        {\r\n            if (index == 0)\r\n            {\r\n                return -1;\r\n            }\r\n\r\n            index--;\r\n            var temp = intArr[index];\r\n            intArr[index] = 0;\r\n            return temp;\r\n        }\r\n\r\n        public void Increment(int k, int val)\r\n        {\r\n            var max = k <= intArr.Length ? k : intArr.Length;\r\n            for (var i = 0; i < max; i++)\r\n            {\r\n                if (intArr[i] == 0)\r\n                {\r\n                    break;\r\n                }\r\n\r\n                intArr[i] += val;\r\n            }\r\n        }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840598152","body":"c#\r\n\r\npublic class Solution {\r\n    public string DecodeString(string s)\r\n        {\r\n            var charArr = s.ToCharArray();\r\n            var str = \"\";\r\n            int temp = 0, num = 0, start = 0, symbol = 0, symbol2 = 0;\r\n            for (int i = 0; i < charArr.Length; i++)\r\n            {\r\n                if (!int.TryParse(charArr[i].ToString(), out temp))\r\n                {\r\n                    if (charArr[i] != '[' && charArr[i] != ']' && symbol == 0)\r\n                    {\r\n                        str += s.Substring(i, 1);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    if (num == 0)\r\n                    {\r\n                        num = temp;\r\n                        start = i + 2;\r\n                    }\r\n                    else if (symbol == 0)\r\n                    {\r\n                        num = int.Parse(num + \"\" + temp);\r\n                        start++;\r\n                    }\r\n                }\r\n\r\n                switch (charArr[i])\r\n                {\r\n                    case '[':\r\n                        symbol++;\r\n                        break;\r\n                    case ']':\r\n                        symbol2++;\r\n                        break;\r\n                }\r\n\r\n                if (symbol > 0 && symbol == symbol2)\r\n                {\r\n                    var subs = s.Substring(start, i - start);\r\n                    for (int j = 0; j < num; j++)\r\n                    {\r\n                        str += subs;\r\n                    }\r\n                    num = 0;\r\n                    symbol = 0;\r\n                    symbol2 = 0;\r\n                }\r\n            }\r\n\r\n            if (str.Contains('['))\r\n            {\r\n                return DecodeString(str);\r\n            }\r\n            else\r\n            {\r\n                return str;\r\n            }\r\n\r\n        }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841234671","body":"c#\r\n\r\npublic class MyQueue {\r\n\r\n    public List<int> intList;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        intList = new List<int>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void Push(int x) {\r\n        intList.Add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int Pop() {\r\n        int e = intList[0];\r\n        intList.RemoveAt(0);\r\n        return e;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int Peek() {\r\n        return intList[0];\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public bool Empty() {\r\n        return intList.Count == 0;\r\n    }\r\n}"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841831226","body":"c#\r\n\r\npublic class Solution {\r\n    public ListNode RotateRight(ListNode head, int k)\r\n        {\r\n            if (head == null || k == 0)\r\n            {\r\n                return head;\r\n            }\r\n\r\n            int count = 0;\r\n            ListNode temp = head;\r\n            do\r\n            {\r\n                count++;\r\n                temp = temp.next;\r\n            } while (temp != null);\r\n\r\n            var remainder = k % count;\r\n            if (remainder == 0)\r\n            {\r\n                return head;\r\n            }\r\n\r\n            var element = 0;\r\n            ListNode first = null, middle = null, end = null, resultHead = null;\r\n            do\r\n            {\r\n                element++;\r\n\r\n                if (element == 1)\r\n                {\r\n                    first = head;\r\n                }\r\n\r\n                if (element == count - remainder)\r\n                {\r\n                    middle = head;\r\n                    resultHead = middle.next;\r\n                }\r\n\r\n                if (head.next == null)\r\n                {\r\n                    end = head;\r\n                }\r\n\r\n                head = head.next;\r\n            } while (head != null);\r\n\r\n            end.next = first;\r\n            middle.next = null;\r\n\r\n            return resultHead;\r\n        }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842303098","body":"public class Solution {\r\n    public ListNode SwapPairs(ListNode head) {\r\n        if (head == null || head.next == null)\r\n        {\r\n            return head;\r\n        }\r\n\r\n        ListNode temp= head.next;\r\n        head.next = SwapPairs(temp.next);\r\n        temp.next = head;\r\n\r\n        return temp;\r\n    }\r\n}"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844066058","body":"public class Solution {\r\n    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {\r\n        HashSet<ListNode> set = new HashSet<ListNode>();\r\n\r\n        var curA = headA;\r\n        while (curA != null)\r\n        {\r\n            set.Add(curA);\r\n            curA = curA.next;\r\n        }\r\n\r\n        var curB = headB;\r\n        while (curB != null)\r\n        {\r\n            if (set.Contains(curB))\r\n            {\r\n                return curB;\r\n            }\r\n            curB = curB.next;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15399618796":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836482820","body":"思路：逐位相加再插入到一个新的数组中\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n       vector<int> res;\r\n       int a=0,sum=0,b=0;\r\n       for(int i=num.size()-1;i>=0;i--){\r\n           a=k%10;\r\n           k/=10;\r\n           sum=num[i]+a;\r\n           if(sum>=10){\r\n               sum-=10;\r\n               k++;\r\n           }\r\n           res.push_back(sum);\r\n       }\r\n       while(k){\r\n           b=k%10;\r\n           k/=10;\r\n           res.push_back(b);\r\n       }\r\n       reverse(res.begin(),res.end());\r\n       \r\n       return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288962","body":"思路：分别从前到后，从后到前遍历两次数组\r\n\r\n`class Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.size(),0);\r\n        int size=s.size();\r\n\r\n        int prev=INT_MIN/2;\r\n        for(int i=0;i<size;i++){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=i-prev;\r\n        }\r\n\r\n        prev=INT_MAX/2;\r\n        for(int i=size-1;i>=0;i--){\r\n            if(s[i]==c) prev=i;\r\n            res[i]=min(res[i],prev-i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};`\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839339769","body":"思路：用数组来模拟栈\r\n语言：c++\r\n\r\n`class CustomStack {\r\npublic:\r\n    int size=0,capacity=0;\r\n    vector<int> v;\r\n\r\n    CustomStack(int maxSize) {\r\n        capacity=maxSize;\r\n        v.resize(maxSize);\r\n        size=0;\r\n    }\r\n    \r\n    \r\n\r\n    void push(int x) {\r\n        if(size<capacity){\r\n            v[size]=x;\r\n             size++;\r\n        }\r\n       \r\n        return ;\r\n    }\r\n    \r\n    int pop() {\r\n        if(size==0) return -1;\r\n        size--;\r\n        return v[size];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int n=min(size,k);\r\n        for(int i=0;i<n;i++){\r\n            v[i]+=val;\r\n        }\r\n    }\r\n};`\r\n\r\n时间复杂度：O（1）和  O（n）\r\n空间复杂度：O（n）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840934520","body":"思路：用两个栈来模拟队列\r\n语言： c++\r\n`class MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s1,s2;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void pushStack(){\r\n        while(!s1.empty()){\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(s2.empty()) pushStack();\r\n\r\n        int temp=s2.top();\r\n        s2.pop();\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(s2.empty()) pushStack();\r\n        return s2.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty()&&s2.empty();\r\n    }\r\n};`\r\n时间复杂度：O（1）和O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845140221","body":"思路：快慢指针\r\n语言：c++\r\n`public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null || head.next.next == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head.next;  \r\n        ListNode fast = head.next.next;  \r\n       \r\n        while(slow != null && fast != null && fast.next != null && slow != fast) {  \r\n            slow = slow.next;  \r\n            fast = fast.next.next;  \r\n        }\r\n        fast = head;\r\n       \r\n        while(slow != null && fast != null && fast != slow) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }`\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846514860","body":"思路：递归求解\r\n语言：c++\r\n`class Solution {\r\npublic:\r\n    bool compare(TreeNode *l, TreeNode *r)\r\n    {\r\n        if(l==NULL && r!=NULL) return false;\r\n        else if(l!=NULL && r==NULL) return false;\r\n        else if(l==NULL && r==NULL) return true;\r\n        else if(l->val!=r->val) return false;\r\n        else return compare(l->left,r->left) && compare(l->right,r->right);\r\n    }\r\n    bool isSameTree(TreeNode* p, TreeNode* q) \r\n    {\r\n        return compare(p, q);\r\n    }\r\n};\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836486673","body":"## 思路\r\n从右到左低位循环num，将其每一位与k相加，并依次进位。如果循环完k还有剩，要记得加上。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in reversed(range(len(num))):\r\n            sum_ = num[i] + k\r\n            k = sum_ // 10\r\n            res.append(sum_ % 10)\r\n        res.reverse()\r\n        if k:\r\n            res = list(map(int, str(k))) + res\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(max(n，k))\r\n- space: O(max(n，k))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837739870","body":"## 思路\r\n左右各循环一遍数组，查找和字符`c`相同的位，以此记录每一位到上一个`c`的距离。然后比较左右距离得到较小值。\r\n\r\n## 代码\r\n- python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = float('-inf')\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        \r\n        return res\r\n```\r\n\r\n## 复杂度\r\n- time: O(n)\r\n- space: O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840848724","body":"## 思路\r\n用两个stack(`self.push_stack`和`self.pop_stack`)分别用于push和pop操作。当pop而`self.pop_stack`为空时，把`self.push_stack`里的元素全部转移到`self.pop_stack`里。\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop() \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.pop_stack:\r\n            return self.pop_stack[-1]\r\n        return self.push_stack[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.push_stack)==0 and len(self.pop_stack)==0\r\n```\r\n\r\n## 复杂度\r\n- 时间: peek()和empty()为O(1)，push()和pop() 均摊是O( 1)，因为每个元素最多入栈和出栈两次\r\n- 空间: O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841834196","body":"## 思路\r\n使用快慢指针找单链表的倒数第 k 个节点\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if head:\r\n            fast = head\r\n            slow = head\r\n            i = 0\r\n            count = 1\r\n            while i < k:\r\n                if fast.next:\r\n                    fast = fast.next\r\n                    count += 1\r\n                else:\r\n                    fast = head\r\n                    k = k % count\r\n                    i = -1\r\n                i += 1\r\n            \r\n            while fast.next:\r\n                fast = fast.next\r\n                slow = slow.next\r\n            \r\n            if slow.next:\r\n                new_head = slow.next\r\n            else:\r\n                return head\r\n            slow.next = None\r\n            fast.next = head\r\n        \r\n            return new_head\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)，最多遍历两遍链表\r\n- 空间: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842310950","body":"## 思路\r\ndummy node迭代实现\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = pre = ListNode(0)\r\n        pre.next = head\r\n        while pre.next and pre.next.next:\r\n            a = pre.next\r\n            b = pre.next.next\r\n            a.next = b.next\r\n            b.next = a\r\n            pre.next = b\r\n            pre = a\r\n        return dummy.next\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843193859","body":"## 思路\r\n- 快慢指针和递归\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        \r\n        # find the middle list node\r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        \r\n        # break the link\r\n        if pre:\r\n            pre.next = None\r\n        \r\n        # only one node\r\n        node = TreeNode(val=slow.val)\r\n        if slow == fast:\r\n            return node\r\n        \r\n        # recursion\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(nlogn)，因为递归树的深度为logn\r\n- 空间: O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843521713","body":"## 思路\r\n使用哈希表存第一个链表的节点，然后再循环查找第二个链表的节点。\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        set_node = set()\r\n        while headA:\r\n            set_node.add(headA)\r\n            headA = headA.next\r\n        \r\n        while headB:\r\n            if headB in set_node:\r\n                return headB\r\n            headB = headB.next\r\n        \r\n        return None\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(m+n)\r\n- 空间: O(m)\r\n其中m,n是两个链表的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844656369","body":"## 思路\r\n哈希表\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        set_node = set()\r\n        while head:\r\n            if head in set_node:\r\n                return head\r\n            if head.next is None:\r\n                return None\r\n            set_node.add(head)\r\n            head = head.next\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845621105","body":"## 思路\r\n- 双向链表\r\n- hashmap\r\n- dummy node\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass ListNode:\r\n    \r\n    def __init__(self, key=0, val=0):\r\n        self.key = key\r\n        self.val = val\r\n        self.pre, self.next = None, None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        self.data = {}\r\n        self.head = ListNode()\r\n        self.tail = ListNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n    def get(self, key: int) -> int:\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.removeNode(node)\r\n            self.appendHead(node)\r\n            return node.val\r\n        else:\r\n            return -1\r\n        \r\n    def put(self, key: int, value: int) -> None:\r\n        node = None\r\n        if key in self.data:\r\n            node = self.data[key]\r\n            self.removeNode(node)\r\n            node.val = value\r\n        else:\r\n            node = ListNode(key, value)\r\n            self.data[key] = node\r\n            if self.size < self.capacity:\r\n                self.size += 1\r\n            else:\r\n                key = self.removeTail()\r\n                del self.data[key]\r\n        self.appendHead(node)\r\n    \r\n    def removeNode(self, node):\r\n        preNode = node.pre\r\n        nextNode = node.next\r\n        preNode.next = nextNode\r\n        nextNode.pre = preNode\r\n    \r\n    def appendHead(self, node):\r\n        headNext = self.head.next\r\n        self.head.next = node\r\n        node.pre = self.head\r\n        node.next = headNext\r\n        headNext.pre = node\r\n    \r\n    def removeTail(self):\r\n        key = self.tail.pre.key\r\n        self.removeNode(self.tail.pre)\r\n        return key\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(1)\r\n- 空间: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846290374","body":"## 思路\r\nDFS和recursion\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        return self.dfs(root)\r\n    \r\n    def dfs(self, root):\r\n        if not root:\r\n            return 0\r\n        return max(self.dfs(root.left), self.dfs(root.right)) + 1\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)\r\n其中n是节点的数量"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846471129","body":"## 思路\r\nDFS和recursion\r\n\r\n## 代码\r\n- python\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p:\r\n            return not q\r\n        if not q:\r\n            return not p\r\n        if p.val != q.val:\r\n            return False\r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n## 复杂度\r\n- 时间: O(n)\r\n- 空间: O(1)\r\n其中n是节点数目"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Cartie-ZhouMo":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836492706","body":"### 思路\r\n从个位加起，若位数超出原数组，需要进位。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        for i in range(l-1, -1, -1):\r\n            a = num[i] + k\r\n            k, num[i] = a // 10, a % 10\r\n        arr = []\r\n        while k:\r\n            arr = [k % 10] + arr\r\n            k = k // 10\r\n        return arr + num\r\n```\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837854541","body":"### 思路\r\n暴力法：先遍历获得s中c的位置list，再遍历计算s中每个字符位置与位置list中元素的最小值。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        arr, ans = [], []\r\n        dis = float(\"inf\") \r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                arr.append(i)\r\n        for i, ss in enumerate(s):\r\n            if ss == c:\r\n                ans.append(0)\r\n            else:\r\n                for a in arr:\r\n                    dis = min(abs(a - i), dis)\r\n                ans.append(dis)\r\n                dis = float(\"inf\") \r\n        return ans\r\n```\r\n### 复杂度：\r\n时间：O(N^2)\r\n空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839390701","body":"### 思路\r\npython中list作为栈\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxsize = maxSize\r\n        self.length = 0\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.maxsize:\r\n            self.stack.append(x)\r\n            self.length += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0: return -1\r\n        self.length -= 1\r\n        return self.stack.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, self.length)):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n### 复杂度\r\nk = maxSize\r\n- 时间：push、pop: O(1); increment: O(k)\r\n- 空间：O(k)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840412803","body":"### 思路\r\n主要是处理括号嵌套的情况，利用辅助栈存储。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840940404","body":"### 思路\r\n两个栈实现队列\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack2.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack1.pop()\r\n\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack1[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack1)\r\n\r\n\r\n```\r\n### 复杂度\r\n时间：pop:O(n), 其余O(1)\r\n空间：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841611648","body":"### 思路\r\n单调栈，栈中存每排序块中的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for i, a in enumerate(arr):\r\n            if stack and stack[-1] > a:\r\n                m = stack.pop()\r\n                while stack and stack[-1] > a:\r\n                    stack.pop()\r\n                stack.append(m)\r\n            else: stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841768170","body":"### 思路\r\n两次遍历，第一次求出链表长度 len 并将头尾连接成环，第二次找到要断开的位置 len - k % len\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head: return head\r\n        p = head\r\n        l = 1\r\n        while p.next:\r\n            p = p.next\r\n            l += 1\r\n        p.next = head\r\n        for _ in range(l - k % l):\r\n            p = p.next\r\n        newhead = p.next\r\n        p.next = None\r\n        return newhead\r\n```\r\n\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842328821","body":"### 思路\r\n三个指针分别指向要交换的两节点以及再下一个节点，交换完成后移动三个指针。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head: return head\r\n        dhead = ListNode()\r\n        dhead.next = head\r\n        p = dhead\r\n        while p.next and p.next.next:\r\n            n1 = p.next\r\n            n2 = p.next.next\r\n            n3 = n2.next\r\n            n2.next = n1\r\n            n1.next = n3\r\n            p.next = n2\r\n            p = n1\r\n        return dhead.next\r\n```\r\n### 复杂度\r\n时间：O(N)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842895150","body":"### 思路\r\n通过快慢指针找到中点作为树的根节点，之后递归左右链表作为左、右子树。注意结束条件。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return None\r\n        if not head.next: return TreeNode(head.val)\r\n        pre = None\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        pre.next = None\r\n        root = TreeNode(slow.val)\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(logN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843683638","body":"### 思路\r\n同讲义法二，双指针。\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n### 复杂度\r\n- 时间：O(M+N)\r\n- 空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844628728","body":"### 思路\r\n快慢指针。\r\n快指针每次前进两步，慢指针每次前进一步。当两个指针相遇时，将其中一个指针移至头部，两指针同时前进，每次一步，当两个指针再次相遇时，就是环的入口，否则无环。\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head: return None\r\n        fast, slow = head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                fast = head\r\n                while fast != slow:\r\n                    fast = fast.next\r\n                    slow = slow.next\r\n                return fast\r\n        return None\r\n```\r\n### 复杂度\r\n- 时间：O(N)\r\n- 空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845915560","body":"### 思路\r\n理解讲义后实现\r\n### 代码\r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, val=0):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.len = 0\r\n        self.dict = {}\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.dict:\r\n            return -1\r\n        else:\r\n            node = self.dict[key]\r\n            self.movetohead(node)\r\n            return node.val\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.dict:\r\n            node = self.dict[key]\r\n            node.val = value\r\n            self.movetohead(node)\r\n        else:\r\n            node = DLinkedNode(key, value)\r\n            self.dict[key] = node\r\n            self.len += 1\r\n            self.addtohead(node)\r\n            if self.len > self.capacity:\r\n                node = self.removeTail()\r\n                self.len -= 1\r\n                self.dict.pop(node.key)\r\n\r\n\r\n    def movetohead(self, node):\r\n        self.removenode(node)\r\n        self.addtohead(node)\r\n\r\n\r\n    def addtohead(self, node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n        \r\n\r\n    def removenode(self, node):\r\n        node.next.pre = node.pre\r\n        node.pre.next = node.next\r\n\r\n\r\n    def removeTail(self):\r\n        node = self.tail.pre\r\n        self.removenode(node)\r\n        return node\r\n```\r\n### 复杂度\r\n- 时间：O(1)\r\n- 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846340617","body":"### 思路\r\n递归\r\n主逻辑：1 + max(左子树深度，右子树深度)\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n### 复杂度\r\n- 时间：O(N) 节点数\r\n- 空间：O(h) 树高度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mystoryshine":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836511738","body":"### 思路\r\n\r\n- 用空字符串拼接输入数组\r\n- 转化为整形相加\r\n- 最后再转化为字符串遍历输出\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for n in num:\r\n            tmp += str(n)\r\n        res_int = int(tmp) + k\r\n        res = [int(i) for i in str(res_int)]\r\n        return res\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838438194","body":"### 思路\r\n\r\n- 左右两次遍历\r\n- 每次遍历时用一个临时变量记住最近的一次c的位置，求出距离\r\n- 比较两次遍历结果，取较小值即可\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        # 记第一次c的位置为 -length\r\n        preTargetIndex = - len(s)\r\n        # 正向遍历\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                # 若遍历到了c，将上一次c的位置改为当前位置，这样计算距离才为0\r\n                preTargetIndex = i\r\n            res.append(i - preTargetIndex)\r\n        \r\n        preTargetIndex = 2*len(s)\r\n        # 逆向遍历\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                preTargetIndex = i\r\n            res[i] = min(res[i], preTargetIndex - i)\r\n        return res\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$，其中 $N$ 为数组长度。\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839761598","body":"### 思路\r\n\r\n- 使用list实现栈\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.capacity = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.capacity:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k < len(self.stack):\r\n            for i in range(k):\r\n                self.stack[i] += val\r\n        else:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i] += val\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$，$O(k)$\r\n- 空间复杂度：$O(1)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840578314","body":"### 思路\r\n\r\n- 利用栈与递归\r\n- 遍历原字符串，遇到非'**]**'压栈，遇到'**]**'弹出构成 **数字+[字符串]** 形式\r\n- 将这个子串解码玩后继续压入到栈中\r\n- 递归\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841249374","body":"### 思路\r\n\r\n- 利用2个栈，inStack和outStack\r\n- push时push到inStack中\r\n- pop时，若outStack非空，outStack弹出栈顶；若空，将inStack每个元素弹出并依次压入到outStack中\r\n- peek，若outStack非空，获得outStack栈顶;若空，同上\r\n- empty，两个栈均空才为空\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.empty():\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            elif self.inStack:\r\n                while self.inStack:\r\n                    self.outStack.append(self.inStack.pop())\r\n                return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.empty():\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            elif self.inStack:\r\n                while self.inStack:\r\n                    self.outStack.append(self.inStack.pop())\r\n                return self.outStack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not self.inStack and not self.outStack:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(N)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812576","body":"### 思路\r\n\r\n- 获取链表倒数第k+1个与最后一个节点\r\n- 使倒数第k+1个节点指向空，最后一个节点指向头，并且令倒数第k个节点为头结点\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 双指针\r\n        if head:\r\n            p1 = head\r\n            p2 = head\r\n            count = 1\r\n            i = 0\r\n            # 如果 k<链表长度,一次遍历即可，反之，二次遍历。不需要提前遍历一次获取链表长度\r\n            while i < k:\r\n                if p2.next:\r\n                    count += 1\r\n                    p2 = p2.next\r\n                else:\r\n                    k = k % count\r\n                    i = -1\r\n                    p2 = head\r\n                i += 1\r\n\r\n            while p2.next:\r\n                p1 = p1.next\r\n                p2 = p2.next\r\n\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head\r\n            p1.next = None\r\n            p2.next = head\r\n            return tmp\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842349654","body":"### 思路\r\n\r\n- 先获取需要调换的两个节点和这两个节点前后两个节点，共4个节点\r\n- 使用这4个节点调换中间两个节点\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: \r\n            return head\r\n        ans = ListNode()\r\n        ans.next = head.next\r\n        pre = ans\r\n        # 递归出口\r\n        while head and head.next:\r\n            next = head.next\r\n            n_next = next.next\r\n\r\n            next.next = head\r\n            pre.next = next\r\n            head.next = n_next\r\n            # 更新入参\r\n            pre = head\r\n            head = n_next\r\n        return ans.next\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843147160","body":"### 思路\r\n\r\n- 使用快慢指针获取链表的后中点\r\n- 令中点为树根，递归构建左右子节点\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(NlogN)$\r\n- 空间复杂度：$O(logN)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ezrealcong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836567186","body":"### **思路**\r\nC实现\r\n- 申请A.length+5个元素的数组空间p[]\r\n- 从后往前遍历数组p[]，计算最低位ktmp=k%10;更新kk=(int)(k/10),在遍历长度小于A.length时，p[i]=nums[i]+ktmp+进位ctmp,大于时p[i]=ktmp+ctmp\r\n- 过程中计数，直到发现nums遍历完，进位为0，k更新为0，那么计数器就是要返回的位数，然后将p指向数组对应位置上返回即可\r\n### **代码**\r\n    \r\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\r\n        int* p = calloc(numSize+5,sizeof(int));\r\n        int j=numSize-1;\r\n        int ktmp;//用来保存模10的值（某一位）\r\n        int atmp;//按位加未处理进位值\r\n        int ctmp=0;//保存进位\r\n        int b=0;\r\n        for(int i=numSize+4;i>=0;i--){\r\n            if(j<0&&k==0&&ctmp==0)\r\n                b++;\r\n            ktmp=k%10;\r\n            k=(int)(k/10);\r\n            if(j>=0)\r\n                atmp=num[j]+ctmp+ktmp;\r\n            else\r\n                {atmp=ctmp+ktmp;\r\n                }\r\n            p[i]=atmp%10;\r\n            ctmp=(int)(atmp/10);\r\n            j-=1;      \r\n        }    \r\n        *returnSize=numSize+5-b;\r\n        return p+b;\r\n    }\r\n### **复杂度分析**\r\n\r\n- 时间复杂度：只遍历了一遍P[]，复杂度为O(N)\r\n\r\n- 空间复杂度：基本是用于返回的空间，O(N)\r\n\r\n> "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706343","body":"（python实现）\r\n### 思路：\r\n1.建立相应长度的数组，全部初始化-1，总共遍历两次\r\n2.第一次从左往右遍历，遇到字符匹配的位置，该元素变0，同时启动计数器num\r\n3.其他位置都赋值为num，赋值完后num自加1，一直到第一次遍历完毕，完成右边最近统计\r\n4.第二次从右往左遍历，遇到字符匹配的位置，启动计数器num\r\n5.其他位置都赋值为min{当前值，num}，赋值完后num自加1，一直到第二次遍历完毕，完成最近距离统计\r\n注意：边界处理时要注意最左边的-1，取最小值要避开-1（-1不参与比较）\r\n### 实例题解展示：\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n第一遍：\r\n\r\n>      [-1,-1,-1,0,1,0,0,1,2,3,4,0]\r\n\r\n第二遍：\r\n\r\n>     [ 3, 2, 1,0,1,0,0,4,3,2,1,0]\t不比较最小值\r\n\r\n>     [ 3, 2, 1,0,1,0,0,1,2,2,1,0]\t比较最小值（-1不参与比较）\r\n\r\n### 代码：\r\n\r\n>     \r\n\r\n    class Solution(object):\r\n            def shortestToChar(self, s, c):\r\n                slen=len(s)\r\n                slist=[-1]*slen\r\n                i=0\r\n                num=-1\r\n                while i<slen:\r\n                    if -1!=num:\r\n                        slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        slist[i]=0\r\n                        num=1\r\n                    i+=1\r\n                i=slen-1\r\n                num=-1    \r\n                while i>=0:\r\n                    if -1!=num:\r\n                        if slist[i]>num or -1==slist[i]:\r\n                            slist[i]=num\r\n                        num+=1\r\n                    if s[i]==c:\r\n                        num=1\r\n                    i-=1\r\n                return slist\r\n\r\n### 复杂度分析\r\n1.时间复杂度：遍历两次数组（列表），时间复杂度O(N)\r\n2.空间复杂度：除去用来返回的列表，空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839785105","body":"### **思路**\r\n\r\n1. 多创建一个delta列表（开始全是零），随着栈列表一起增长，每当有increase操作时，min(k-1,top)位置就增加val\r\n2. push时，top+=1，栈和delta列表的top位置分别变为x和0\r\n3. pop时， 取出栈和delta列表top位置的值a和b，top-=1，delta的新top（减过之后的）位置的值加上刚旧top取出来的值a，返回a+b\r\n4. increase时，min（k-1，top）位置的值加上val即可\r\n\r\n### **代码**\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[0]*maxSize\r\n        self.delta=[0]*maxSize\r\n        self.top=-1\r\n        self.maxSize=maxSize-1\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if(self.top < self.maxSize):\r\n            self.top+=1\r\n            self.stack[self.top]=x\r\n            self.delta[self.top]=0\r\n\r\n\r\n    def pop(self) -> int:\r\n        if -1 == self.top:\r\n            return -1\r\n        a = self.stack[self.top]\r\n        b = self.delta[self.top]\r\n        self.top-=1\r\n        self.delta[self.top]+=b\r\n        return a+b \r\n       \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if -1 == self.top:\r\n            return\r\n        k_top=min(self.top,k-1)\r\n        self.delta[k_top]+=val\r\n```\r\n\r\n\r\n### **复杂度分析**\r\n\r\n1. 时间复杂度：均为O(1)\r\n2. 空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840585056","body":"### **思路**\r\n\r\n> 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n1. 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n2. 当 c 为字母时，在 res 尾部添加 c；\r\n3. 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n    记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n    记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n    进入到新 [ 后，res 和 multi 重新记录。\r\n4. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n    last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n    cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n    返回字符串 res。\r\n\r\n### **代码**\r\n```python\r\n     \r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### **复杂度分析**\r\n1.  时间复杂度 O(N)\r\n2.  空间复杂度 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841324750","body":"\r\n### **思路**\r\n1. 辅助栈\r\n\r\n### **代码**\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.size=0\r\n        self.stack=[]\r\n        self.help_stack=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack.append(x)\r\n        self.size+=1\r\n\r\n\r\n    def pop(self) -> int:\r\n        self.size-=1\r\n        for i in range(self.size):\r\n            self.help_stack.append(self.stack.pop())\r\n        tmp=self.stack.pop()\r\n        for i in range(self.size):\r\n            self.stack.append(self.help_stack.pop())\r\n        return tmp\r\n\r\n    def peek(self) -> int:\r\n        for i in range(self.size-1):\r\n            self.help_stack.append(self.stack.pop())\r\n        tmp=self.stack.pop()\r\n        self.stack.append(tmp)\r\n        for i in range(self.size-1):\r\n            self.stack.append(self.help_stack.pop())\r\n        return tmp\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if(self.size):\r\n            return False\r\n        else:\r\n            return True\r\n\r\n```\r\n\r\n\r\n### **复杂度分析**\r\n1. 时间复杂度：O(N)\r\n2. 空间复杂度：O(N)"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846023394","body":"### 代码\r\n\r\n\r\n      class LRUCache(collections.OrderedDict):\r\n      \r\n          def __init__(self, capacity: int):\r\n              super().__init__()\r\n              self.capacity = capacity\r\n      \r\n      \r\n          def get(self, key: int) -> int:\r\n              if key not in self:\r\n                  return -1\r\n              self.move_to_end(key)\r\n              return self[key]\r\n      \r\n          def put(self, key: int, value: int) -> None:\r\n              if key in self:\r\n                  self.move_to_end(key)\r\n              self[key] = value\r\n              if len(self) > self.capacity:\r\n                  self.popitem(last=False)\r\n\r\n\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Huzhixin00":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836573445","body":"### 思路\r\n1. 按照最自然的想法，应该是将K的各位切分出来，即：将int类型的K转化为各位为int类型的数组，然后将K的对应位与给定数组的对应位进行相加，并考虑进位的情况。\r\n2. 上述想法需要对K进行处理，而且处理进位的逻辑会影响到下一轮更高位的相加处理，所以应考虑更为通用的算法。\r\n3. 在上述过程中，唯一不能省略的就是进位过程，因为作为”必要项“的进位过程如果可以和相加过程相结合，自然可以得出相对通用的算法。\r\n4. 如果要将进位过程与相加过程结合，那么就应该是”依次从低位开始加起，K与个位相加的结果对10取余，即个位的最终结果，而是否向上进位，则取决于k与个位相加的结果除以十，是否大于0（整数/10即意味着求高1位数的结果，因为小数点后的数字被截掉了）“。\r\n5. 反复进行第4步，即每除1次10，即求得都是K累加和的高一次幂，只要K的累加和除10结果不为零，或是数组的位数没有加到最高位，这样的循环就不会停止。\r\n\r\n### 代码（Java）\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k = k / 10) {\r\n            if (i >= 0) {\r\n                k = k + num[i];\r\n            }\r\n            arr.add(k % 10);\r\n        }\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(max(logK,num.length)) \r\n循环次数取决于k和数组长度的最大值，但比较值得注意的是，当K>0，但i<0时，意味着数组的最高位已经没有了，此时应该出现数组越界异常，只不过leetcode只判定到不越界为止，所以就没有考虑越界的问题。\r\n\r\n空间复杂度：O(1)\r\n没有用到额外的空间，所以空间复杂度为常数\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838368278","body":"## 思路\r\n写在代码注释里面了\r\n## 代码\r\n```\r\n class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        // 创建一个数组来存放各个位置距离字符 c 的最小距离\r\n        int[] minDistances = new int[s.length()];\r\n        /*\r\n        * 每个位置相对于c的情况有三种：\r\n        * 1、该下标只有左边有字符c         [x  c]\r\n        * 2、该下标左右两边都有字符c       [c   x   c]\r\n        * 3、该下标只有右边有字符c         [c  x]\r\n        * 其中只有第二种情况，需要比较两边的字符c究竟哪个距离x更近。\r\n        * 所以取最复杂情况，设置两个指针cursor1和cursor2，分别指向当前下标的左侧c字符和右侧c字符\r\n        * */\r\n        // 先将两个指针指向String中最左侧的字符c，然后从数字0开始迭代\r\n        int cursorFirst = s.indexOf(c), cursorSecond = cursorFirst;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            /*\r\n            * 如果数字下标处，正好是字符c，那么将该位置到字符c的距离必为0，并且更新两个指针的数据\r\n            * 原来的的cursor1，也就是左侧字符c指针，需要更新为当前下标的位置（因为下一次该位置就成为下一个位置的左侧字符c）\r\n            * 原来的cursor2，也就是右侧字符c指针，需要更新为更右边（即从i+1位置开始，找到的下一个字符c位置）的字符c位置*/\r\n            if (s.charAt(i) == c) {    //\r\n                minDistances[i] = 0;\r\n                cursorFirst = i;\r\n                cursorSecond = s.indexOf(c, i + 1);\r\n                // 如果数组下标所处位置的字符不是字符c，则计算该处与最近的左右两侧字符c的距离，并取最小值\r\n            } else {\r\n                minDistances[i] = Math.min(Math.abs(cursorFirst - i), Math.abs(cursorSecond - i));\r\n            }\r\n        }\r\n        return minDistances;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839861272","body":"## 思路\r\n1. 用数组模拟栈，设定一个top变量模拟栈顶\r\n## 代码（Java）\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top + 1];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度：\r\n定义栈，put和pop操作均为O(1)，而increment操作为O(k)\r\n\r\n2. 空间复杂度：\r\n用到了一个数组长度为maxsize的数组，所以复杂度为O(maxsize)"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843649397","body":"## 思路\r\n先遍历第一个链表，将每个节点都存到对应的hashSet中，然后再遍历第二个链表，如果在hashSet中存在该节点，则说明该节点就是相交的节点\r\n## 代码（Java）\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        HashSet<ListNode> nodeCache = new HashSet<ListNode>();\r\n        ListNode cursorNode = headA;\r\n        while (cursorNode != null) {\r\n            nodeCache.add(cursorNode);\r\n            cursorNode = cursorNode.next;\r\n        }\r\n\r\n        cursorNode = headB;\r\n        while (cursorNode != null) {\r\n            if (nodeCache.contains(cursorNode)) {\r\n                return cursorNode;\r\n            }\r\n            cursorNode = cursorNode.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(M+N)\r\n2. 空间复杂度 O(M) 或 O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gentlemancj":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836575050","body":"```var addToArrayForm = function(num, k) {\r\n  let isOverflow = false, index = num.length - 1, res = [];\r\n  while(index > -1 || k) {\r\n     const num1 = num[index] || 0, num2 = k % 10;\r\n     let sum = num1 + num2;\r\n     if(isOverflow) {\r\n          sum = sum + 1;\r\n     }\r\n      isOverflow = sum >= 10;\r\n      res.unshift(sum % 10);\r\n      k = (k / 10) | 0;\r\n      index--;\r\n      \r\n  }\r\n  if(isOverflow) res.unshift(1);\r\n  return res;\r\n};\r\n**复杂度分析**\r\n\r\n- 空间复杂度O(n)\r\n- 时间复杂度O(n) "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837600585","body":"**暴力破解法**\r\n\r\n```\r\nvar shortestToChar = function (s, c) {\r\n  let index = 0, len = s.length, res = [];\r\n  while (index < len) {\r\n    let head = tail = index;\r\n    while (head > -1 || tail < len) {\r\n      const headC = s[head], tailC = s[tail];\r\n      if (headC === c) {\r\n        res.push(index - head);\r\n        break;\r\n      };\r\n      if (tailC === c) {\r\n        res.push(tail - index);\r\n        break;\r\n      }\r\n      head--;\r\n      tail++;\r\n    }\r\n    index++;\r\n  }\r\n  return res\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839365646","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\nthis.stack = new Array(maxSize);\r\n  this.maxSize = maxSize;\r\n  this.currentSize = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\nif (this.currentSize < this.maxSize) {\r\n    this.currentSize++;\r\n    this.stack[this.currentSize - 1] = x;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.currentSize > 0) {\r\n    const val = this.stack[this.currentSize - 1];\r\n    this.currentSize--;\r\n    return val;\r\n  }\r\n  return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\nconst size = Math.min(k, this.currentSize);\r\n  for (let i = 0; i < size; i++) {\r\n    this.stack[i] = this.stack[i] + val;\r\n  }\r\n};\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841127080","body":"```\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n  this.outStack = [];\r\n  this.inStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.popStack();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.popStack();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return !this.inStack.length && !this.outStack.length\r\n};\r\n\r\nMyQueue.prototype.popStack = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n};"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842208960","body":"- 时间复杂度O(n)\r\n- 空间复杂度O(1)\r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n if (!head || !head.next) return head;\r\n  let newHead = null, preTail = null;\r\n  while (head && head.next) {\r\n    let current = head.next;\r\n    head.next = current.next;\r\n    current.next = head;\r\n    if (preTail) {\r\n      preTail.next = current;\r\n    }\r\n\r\n    if (!newHead) {\r\n      newHead = current;\r\n    }\r\n    preTail = head;\r\n    head = head.next;\r\n  }\r\n  return newHead;\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843266877","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n     function getMid(left, right) {\r\n       let fast = left, slow = left;\r\n       while (fast !== right && fast.next !== right) {\r\n           slow = slow.next;\r\n           fast = fast.next.next;\r\n       }\r\n       return slow;\r\n     }\r\n     function buildTree(left, right) {\r\n        if(left === right) return null;\r\n        const mid = getMid(left, right);\r\n        let _left = buildTree(left,mid);\r\n        let _right = buildTree(mid.next, right);\r\n        const root = new TreeNode(mid.val, _left, _right);\r\n        return root;   \r\n     }\r\n     return buildTree(head, null);\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843694539","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n  let currentA = headA, currentB = headB;\r\n  if (!headA || !headB) return null;\r\n  while (currentA !== currentB) {\r\n    if (!currentA) {\r\n      currentA = headB;\r\n    } else {\r\n      currentA = currentA.next;\r\n    }\r\n    if (!currentB) {\r\n      currentB = headA;\r\n    } else {\r\n      currentB = currentB.next;\r\n    }\r\n  }\r\n  return currentA;\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844658321","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n  let fast = head, slow = head;\r\n  if (!head) return null;\r\n  while (fast) {\r\n    slow = slow.next;\r\n    if (fast.next) {\r\n      fast = fast.next.next;\r\n    } else {\r\n      return null;\r\n    }\r\n    if (fast === slow) {\r\n      let ptr = head;\r\n      while (ptr !== slow) {\r\n        ptr = ptr.next;\r\n        slow = slow.next;\r\n      }\r\n      return ptr;\r\n    }\r\n  }\r\n  return null;\r\n};"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846403614","body":"```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n   if(!root) return 0;\r\n   return Math.max(maxDepth(root.left), maxDepth(root.right))+1;\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LiangZheCoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836576433","body":"思路：模拟进位加法，同样适用于链表\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //用于标识数组的位置\r\n        int len = num.length - 1;\r\n        //用于标识是否发生进位\r\n        int isCarry = 0;\r\n        //统计每一轮的值，提前创建，增加效率\r\n        int val = 0;\r\n        //用于保存结果，使用头插法插入链表\r\n        List<Integer> res = new LinkedList<>();\r\n        while(len > -1 || k > 0){\r\n            if(k > 0){\r\n                val = k % 10;\r\n                k = k / 10;\r\n            }\r\n            if(len > -1){\r\n                val += num[len];\r\n            }\r\n            val += isCarry;\r\n            isCarry = val / 10;\r\n            val = val % 10;\r\n            res.add(0,val);\r\n            len--;\r\n            val = 0;\r\n        }\r\n        if(isCarry > 0){\r\n            res.add(0,1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837861038","body":"- 思路\r\n\r\n暴力法，判断前后的距离，找到第一个目标字符的位置则停止，然后左右比较大小\r\n```\r\n\r\n- 代码\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int min1 = Integer.MAX_VALUE;\r\n        int min2 = Integer.MAX_VALUE;\r\n        for(int i = 0 ; i < s.length() ; i++){\r\n            if(s.charAt(i) == c){\r\n                answer[i] = 0;\r\n                continue;\r\n            }\r\n            for(int j = i ; j < s.length() ; j++){\r\n                if(s.charAt(j) == c){\r\n                    min1 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            for(int j = i ; j > -1 ; j--){\r\n                if(s.charAt(j) == c){\r\n                    min2 = Math.abs(i-j);\r\n                    break;\r\n                }\r\n            }\r\n            answer[i] = Math.min(min1,min2);\r\n            min1 = Integer.MAX_VALUE;\r\n            min2 = Integer.MAX_VALUE;\r\n        }\r\n        return answer;\r\n    }\r\n}\r\n```\r\n\r\n- 复杂度\r\n时间：O(N^2) 外层循环数组长度，内层循环近似数组长度\r\n空间：O(N) 开辟和数组长度相等的数组\r\n"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842306472","body":"**思路**\r\n使用辅助指针\r\n**代码**\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(-1);\r\n        dummy.next = head;\r\n\r\n        ListNode pre  = dummy;\r\n\r\n        while (pre.next != null && pre.next.next != null){\r\n            ListNode node1 = pre.next;\r\n            ListNode node2 = node1.next;\r\n            ListNode nex = node2.next;\r\n\r\n            node2.next = node1;\r\n            node1.next = nex;\r\n            pre.next = node2;\r\n            \r\n            pre = node1;\r\n        }\r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846529662","body":"思路\r\n**递归**\r\n代码\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null){\r\n            return true;\r\n        }\r\n        if(p == null || q == null){\r\n            return false;\r\n        }\r\n        if(p.val != q.val){\r\n            return false;\r\n        }\r\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-z-hub":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836584325","body":"语言：java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n\r\n        for(int i=num.length-1; i>=0; i--){\r\n \r\n            int temp = num[i] + k;\r\n            int temp1 = temp%10;\r\n            ans.add(0, temp1);\r\n            k= temp/10;\r\n            \r\n        }\r\n\r\n        while(k>0){\r\n            ans.add(0, k%10);\r\n            k/=10;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839797486","body":"class CustomStack {  \r\n    int[] ans;  \r\n    int cursor;  \r\n  \r\n    public CustomStack(int maxSize) {  \r\n        ans = new int[maxSize];  \r\n        cursor = -1;  \r\n    }  \r\n  \r\n    public void push(int x) {  \r\n        if (cursor == ans.length - 1) return;  \r\n        cursor += 1;  \r\n        ans[cursor] = x;  \r\n    }  \r\n  \r\n    public int pop() {  \r\n        if (cursor == -1) return -1;  \r\n        cursor -= 1;  \r\n        return ans[cursor + 1];  \r\n    }  \r\n  \r\n    public void increment(int k, int val) {  \r\n        int max_inc = Math.min(k, cursor + 1);  \r\n        for (int i = 0; i < max_inc; i++) {  \r\n            ans[i] += val;  \r\n        }  \r\n    }  \r\n}  "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840572016","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        num, ans = 0, ''\r\n        # 辅助栈\r\n        stack = []\r\n        for ss in s:    \r\n            if ss == '[':\r\n                # 存 '[' 前的字母和数字\r\n                stack.append([num, ans])\r\n                num, ans = 0, ''\r\n            elif ss == ']':\r\n                if stack:\r\n                    n, a = stack.pop()\r\n                ans = a + n * ans\r\n            elif '0' <= ss <= '9':\r\n                num = num * 10 + int(ss)\r\n            else: ans += ss\r\n        return ans"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Kuroky-Chen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836597120","body":"#### 思路：逐位将数字加一起\r\n代码：javascript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843275320","body":"### 思路\r\n* 先构建左子树，再构建根节点，再构建右子树。——遵循中序遍历。\r\n* 其实，BST 的中序遍历，打印的节点值正是这个有序链表的节点值顺序\r\n### 代码 JavaScript\r\n```\r\nvar sortedListToBST = (head) => {\r\n  if (head == null) return null\r\n  let len = 0\r\n  let h = head\r\n  while(head) {\r\n    len++\r\n    head = head.next\r\n  }\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null\r\n    const mid = (start + end) >>> 1\r\n    const left = buildBST(start, mid - 1)\r\n    const root = new TreeNode(h.val)\r\n    h = h.next\r\n    root.left = left\r\n    root.right = buildBST(mid + 1, end)\r\n    return root\r\n  }\r\n  return buildBST(0, len - 1)\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(logn)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yulecc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836599276","body":"思路\r\n遍历数组,不断做空k,从k的个位数开始提取 , 和数组最后一项开始相加 , 一直往前 , 和大于10, k就加1, 最后遍历k,最后反转数组\r\n\r\n关键点\r\n代码\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n\r\n复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n时间复杂度：O(n)O(n)\r\n空间复杂度：O(1)O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838266285","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n遍历字符串,两个指针从左找一次,从右找一次\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    var res = new Array(s.length).fill(0)\r\n\r\n    for(var i=0;i <s.length; i++) {\r\n        var l = i, r=i, shortest = Infinity\r\n        if(s[i] === c) continue\r\n        while(l>=0){\r\n            if(s[l] === c){\r\n                shortest = Math.min(shortest, i - l)\r\n                break;\r\n            }\r\n            l--\r\n        }\r\n        while(r<s.length){\r\n            if(s[r] === c){\r\n                shortest = Math.min(shortest, r - i)\r\n                break;\r\n            }\r\n            r++\r\n        }\r\n        res[i] = shortest\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839600534","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.list.length < this.maxSize) {\r\n        this.list.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const item = this.list.pop()\r\n    return item === void 0 ? -1 : item\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(var i=0; i<k && i<this.list.length;i++){\r\n        this.list[i] +=val\r\n    }\r\n    \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840505699","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\nlet numStack = [];        // 存倍数的栈\r\n    let strStack = [];        // 存 待拼接的str 的栈\r\n    let num = 0;              // 倍数的“搬运工”\r\n    let result = '';          // 字符串的“搬运工”\r\n    for (const char of s) {   // 逐字符扫描\r\n        if (!isNaN(char)) {   // 遇到数字\r\n            num = num * 10 + Number(char); // 算出倍数\r\n        } else if (char == '[') {  // 遇到 [\r\n            strStack.push(result); // result串入栈\r\n            result = '';           // 入栈后清零\r\n            numStack.push(num);    // 倍数num进入栈等待\r\n            num = 0;               // 入栈后清零\r\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\r\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\r\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\r\n        } else {                   \r\n            result += char;        // 遇到字母，追加给result串\r\n        }\r\n    }\r\n    return result;\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841175391","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helpStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    var cur = null\r\n    while(cur = this.stack.pop()){\r\n        this.helpStack.push(cur)\r\n    }\r\n    this.helpStack.push(x)\r\n    while(cur = this.helpStack.pop()){\r\n        this.stack.push(cur)\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n    \r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844969001","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\r\n\r\n说明：不允许修改给定的链表。\r\n\r\n进阶：\r\n\r\n你是否可以使用 O(1) 空间解决此题？\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [3,2,0,-4], pos = 1\r\n输出：返回索引为 1 的链表节点\r\n解释：链表中有一个环，其尾部连接到第二个节点。\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = [1,2], pos = 0\r\n输出：返回索引为 0 的链表节点\r\n解释：链表中有一个环，其尾部连接到第一个节点。\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1], pos = -1\r\n输出：返回 null\r\n解释：链表中没有环。\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目范围在范围 [0, 104] 内\r\n-105 <= Node.val <= 105\r\npos 的值为 -1 或者链表中的一个有效索引\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n     const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n\r\n\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fyyjyx-github":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836606794","body":"### 思路\r\n\r\n先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加，再将得到的数值结果转为int类型的数组。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        # 先将整数数组A转为一个字符串，再将字符串转为数值类型后与整数K相加\r\n        res_num = eval(''.join(map(str, A))) + K\r\n        # 将得到的数值结果先转为字符串，再将其转为int类型的数组\r\n        return list(map(int, str(res_num)))\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)。"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665056","body":"### 思路\r\n\r\n根据分块的思想得到前一个块的最大值应该小于等于后一个块的最小值，因此，想到数组中如果索引i所在的元素及之前的元素的最大值小于索引i所在的元素之后的元素的最小值，那么就可以分成一个块，如果整个数组中都没有这样的i，那么整个数组可分成的最大块数就是1，先想到的是递归，然后想到可以用递推。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # arrlen = len(arr)\r\n        # if arrlen == 1:\r\n        #     return 1\r\n        # for i in range(1,arrlen):\r\n        #     if max(arr[:i]) <= min(arr[i:]):\r\n        #         return self.maxChunksToSorted(arr[:i]) +self.maxChunksToSorted(arr[i:])\r\n        # return 1\r\n        arrlen = len(arr)\r\n        f = [0 for _ in range(arrlen)]\r\n        f[0] = 1\r\n        for i in range(1,arrlen):\r\n            if max(arr[:i]) <= min(arr[i:]):\r\n                f[i] = f[i-1] + 1\r\n            else:\r\n                f[i] = f[i-1]\r\n        return f[-1]\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n^2)\r\n- 空间复杂度：O(n)"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846351019","body":"### 思路\r\n\r\n如果我们知道了整棵树的左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为max(l,r) + 1，同样，对于左子树和右子树，同样可以用这种方式求深度。\r\n\r\n### 代码\r\n\r\nPython3\r\n\r\n```\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为节点个数。\r\n- 空间复杂度：O(logN)。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuanWenLai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836610752","body":"### 思路 \r\n \r\n数组的数值操作\r\n1、倒序遍历数组\r\n2、用一个进位数来保存溢出状态carryNum\r\n3、k值每次使用后剔除个位数的值\r\n \r\n \r\n### 代码 \r\n### js\r\n \r\n``` js\r\n \r\n    let len = num.length - 1\r\n    // 用一个进位数来保存上一位的溢出情况\r\n    let carryNum = 0\r\n    let number = []\r\n    while(len >= 0 || k!=0) {\r\n        let sum = carryNum\r\n        if(len >= 0) {\r\n            sum += num[len]\r\n            len--\r\n        }\r\n        if(k!=0) {\r\n            sum += k%10\r\n            // 剔除k的个位\r\n            k = Math.floor(k/10)\r\n        }\r\n        // 保存新的进位数\r\n        carryNum = Math.floor(sum/10)\r\n        number.unshift(sum % 10)\r\n    }\r\n    if(carryNum > 0) {\r\n        number.unshift(carryNum)\r\n    }\r\n    return number\r\n \r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837560949","body":"### 思路 \r\n \r\n数组的遍历(正向遍历和反向遍历)\r\n1、先得到一个反向的字符串\r\n2、获取正向反向目标字符的下标\r\n3、正向遍历和反向遍历获取对应距离的数组\r\n4、正向遍历和反向遍历的数组间比较最小值返回\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    if(s.length === 1) return [0]\r\n    let antiS = s.split('').reverse().join('')\r\n    let antiArr = []\r\n    let arr = []\r\n    let index = s.indexOf(c)\r\n    let antiIndex = antiS.indexOf(c)\r\n    for(let i=0;i<s.length;i++) {\r\n        // 正序数组遍历\r\n        if(s[i] !=c){\r\n            arr.push(Math.abs(i - index))\r\n        }else {\r\n            arr.push(0)\r\n            index = i\r\n        }\r\n\r\n        // 反序数组遍历\r\n        if(antiS[i] != c ){\r\n            antiArr.unshift(Math.abs(i - antiIndex))\r\n        }else {\r\n            antiArr.unshift(0)\r\n            antiIndex = i\r\n        }\r\n    }\r\n    return arr.map((item,index) => Math.min(item,antiArr[index]))\r\n};\r\n``` \r\n \r\n**复杂度分析** - 时间复杂度：O(N)，其中 N 为数组⻓度。 - 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839307877","body":"### 思路 \r\n \r\n数组模拟栈\r\n1、初始化记录数据的数组和最大值\r\n2、判断入栈时是否超出maxSize的长度\r\n3、判断出栈时，栈是否为空\r\n4、增量时，判断当前k值和栈的长度大小\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.data = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.data.length < this.maxSize) {\r\n        this.data.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.data.length === 0) return -1\r\n    return this.data.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.data.length < k ? this.data.length : k\r\n    for(let i=0;i<k;i++) {\r\n        this.data[i] += val\r\n    }\r\n};\r\n\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840216126","body":"### 思路 \r\n \r\n1、遍历字符串，将数字存入numArr，非数字存入stack\r\n2、如果不是']'，入栈\r\n3、否则计算当前匹配括号内的字符串\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []\r\n    let numArr = []\r\n    for(let i=0;i<s.length;i++) {\r\n        if(Number.isInteger(s[i]*1) && i > 0 && Number.isInteger(s[i-1]*1)) {\r\n            numArr[numArr.length-1] += s[i]\r\n        }else if(Number.isInteger(s[i]*1)) {\r\n            numArr.push(s[i])\r\n        }else if(s[i] != ']') {\r\n            stack.push(s[i])\r\n        }else {\r\n            formatStack(stack,numArr)\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n\r\nfunction formatStack(stack,numArr) {\r\n    let str = ''\r\n    let retStr = ''\r\n    let num = numArr.pop()\r\n    while(s = stack.pop(), s != '[') {\r\n        str = s + str\r\n    }\r\n    retStr = str\r\n    for(let i = 0;i<num*1 -1;i++) {\r\n        retStr += str\r\n    }\r\n    stack.push(retStr)\r\n}\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840900103","body":"### 思路 \r\n \r\n1、用数组来维护一个队列\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n /**\r\n * Initialize your data structure here.\r\n */\r\n var MyQueue = function() {\r\n    this.queue = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    if(x) this.queue.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length == 0\r\n};\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(1) \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841583446","body":"### 思路 \r\n \r\n1、利用求栈stack的最大值的思想，储存可分块的最大值\r\n2、当出现小于栈顶head的值时，保留当前栈顶head，抛出stack中大于arr[i]的值\r\n3、最终得出stack的长度的就可分块的最大值\r\n\r\n思想和 769. 最多能完成排序的块 的题目一致\r\n \r\n \r\n### 代码 \r\n \r\n \r\n``` js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted2 = function(arr) {\r\n    let stack = []\r\n    for(let i=0;i<arr.length;i++) {\r\n        let len = stack.length\r\n        // 栈为空 or 栈顶小于当前值\r\n        if(len == 0 || stack[len-1] <= arr[i]) {\r\n            stack.push(arr[i])\r\n        }else {\r\n            // 保存栈顶的最大值为头，抛出大于当前值的栈内元素\r\n            const head = stack.pop()\r\n            while(stack[stack.length-1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(head)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：O(N) \r\n- 空间复杂度：O（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841805144","body":"### 思路\r\n\r\n模仿快慢指针\r\n\r\n### 代码\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1,\r\n    cur = head;\r\n\r\n  //找出长度\r\n  while (cur.next) {\r\n    cur = cur.next;\r\n    length++;\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n  //如果次数是0，那么就等于没干，并且如果k = 0 后面会报错\r\n  if (k === 0) return head;\r\n\r\n  //快慢指针，让快的先走 k - 1步，这样慢的就刚好是newHead，快的刚好是现在的尾巴\r\n  let fast = head,\r\n    slow = head,\r\n    count = k - 1;\r\n\r\n  while (count > 0) {\r\n    fast = fast.next;\r\n    count--;\r\n  }\r\n\r\n  let pre = null;\r\n  while (fast.next) {\r\n    pre = slow;\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  pre.next = null;\r\n  fast.next = head;\r\n  return slow;\r\n};\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(N) 。 - 空间复杂度：O（1）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842320067","body":"### 思路\r\n\r\n模仿快慢指针,穿针引线法\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\n var swapPairs = function(head) {\r\n    \r\n    if(!head || !head.next) return head\r\n    const dummyHead = new ListNode(-1, head)\r\n  \r\n    let slow = head, fast = head.next, preSlow = dummyHead;\r\n    //穿针引线 \r\n    while(fast){\r\n      let next = fast.next;\r\n      preSlow.next = fast;\r\n      fast.next = slow;\r\n      slow.next = next;\r\n  \r\n      preSlow = slow\r\n      slow = next\r\n      if(!slow) break\r\n      fast = slow.next\r\n    }\r\n  \r\n    return dummyHead.next\r\n  };\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(N) 。 - 空间复杂度：O（1）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842742796","body":"### 思路\r\n\r\n1、用快慢指针来确定链表的中间节点\r\n2、构造中间节点为数的根\r\n3、用递归的方式来继续构造左右子树的树\r\n\r\n### 代码\r\n\r\n```js\r\n\r\nvar sortedListToBST = function(head) {\r\n    if(!head) return null\r\n    \r\n    let slow = head,\r\n        fast = head,\r\n        preSlow = null\r\n    \r\n    while(fast && fast.next) {\r\n        preSlow = slow\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n\r\n    // 如果快指针到达尾部，则慢指针到达中间点\r\n    // 通过中间点来构建树\r\n    const root = new TreeNode(slow.val)\r\n\r\n    if(preSlow) {\r\n        // 剪掉preSlow对中间节点（root）的指向\r\n        preSlow.next = null\r\n        root.left = sortedListToBST(head)\r\n    }\r\n    root.right = sortedListToBST(slow.next)\r\n\r\n    return root\r\n};\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(NlogN) 。 - 空间复杂度：O（NlogN）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843652652","body":"### 思路\r\n\r\n1、哈希表存储ListA遍历的值\r\n2、遍历ListB，若存在与HashA相同的节点，返回节点，否则返回null\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\n var getIntersectionNode = function(headA, headB) {\r\n    let hashList = new Set()\r\n    while(headA) {\r\n        hashList.add(headA)\r\n        headA = headA.next\r\n    }\r\n    while(headB) {\r\n        if(hashList.has(headB)) return headB\r\n        headB = headB.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(N) 。 - 空间复杂度：O（N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844677795","body":"### 思路\r\n\r\n#### 哈希表+链表\r\n1、用hash表存储遍历过的链表节点\r\n2、若出现重复在hash表的节点，抛出该节点\r\n3、若无，则返回null，代表该链表没有环\r\n\r\n#### 快慢指针\r\n1、用快慢指针判断出是否有环\r\n2、二次相遇时，得到环的起始点\r\n\r\n### 代码\r\n\r\n```js\r\n\r\n// 快慢指针\r\nvar detectCycle1 = function(head) {\r\n    if(head == null || !head.next == null) return null\r\n    let fast = head, slow = head\r\n\r\n    do {\r\n        if(fast != null && fast.next != null) {\r\n            fast = fast.next.next\r\n        } else {\r\n            fast = null\r\n        }\r\n        slow = slow.next\r\n    } while (fast != slow)\r\n\r\n    // 若快指针走到尾 null\r\n    if(fast == null) return null\r\n\r\n    // 否则快慢指针已经相遇，让快慢指针二次相遇时，即为环的起点\r\n    fast = head\r\n    while(fast != slow) {\r\n        fast = fast.next\r\n        slow = slow.next\r\n    }\r\n    return fast\r\n};\r\n```\r\n**复杂度分析** - 时间复杂度：O(logN) 。 - 空间复杂度：O（1）\r\n\r\n```js\r\n\r\n// 用哈希表来存储遍历过的节点，若出现一致，则抛出该节点\r\n var detectCycle2 = function(head) {\r\n    let hashList = new Set()\r\n    while(head) {\r\n        if(hashList.has(head)) {\r\n            return head\r\n        }else {\r\n            hashList.add(head)\r\n        }\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(logN) 。 - 空间复杂度：O（N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845589069","body":"### 思路\r\n\r\n#### 哈希表+双链表\r\n1.使用哈希表，能快速判断node是否在链表中并获取链表，操作时间o(1)\r\n2.使用双链表，对链表节点的删除操作节省了遍历的o(N)时间，操作时间o(1)\r\n3.使用虚拟节点dummyHead和dummyTail，标记处头尾和尾部的位置\r\n4.缓存规则：\r\n    -用count来记录节点数，判断是否超过容器的最大值\r\n    -若缓存未满，直接将此节点插入头部\r\n    -若缓存已满，先删除链表的尾节点，再新增node到头部\r\n5.达到最新使用的会在头部，最久未使用的，会在尾部\r\n\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number} capacity\r\n */\r\n\r\nvar ListNode  = function(key,val) {\r\n    this.key = key\r\n    this.val = val\r\n    this.pre = null\r\n    this.next = null\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\n var LRUCache = function(capacity) {\r\n    this.capacity = capacity\r\n    // 用map函数来存储节点，key\r\n    this.cache = new Map()\r\n    // 存储节点数量\r\n    this.nodeCount = 0\r\n\r\n    // 构造虚拟节点，来指向最多使用和最少使用\r\n    this.dummyHead = new ListNode()\r\n    this.dummyTail = new ListNode()\r\n\r\n    // 关联这两个虚拟点\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyTail.pre = this.dummyHead\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    // 在缓存中找不到该节点时，返回-1\r\n    if(!this.cache.get(key)) return -1\r\n\r\n    let node = this.cache.get(key)\r\n    this.moveTohead(node)\r\n\r\n    return node.val\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n\r\n    // 在缓存获取这个key的值\r\n    const node = this.cache.get(key)\r\n\r\n    //若缓存中出现这个节点\r\n    if(node) {\r\n        // 更新该节点的值\r\n        node.val = value\r\n        // 再保存到缓存中\r\n        this.cache.set(key,node)\r\n        // 更新最新使用的链表\r\n        this.moveTohead()\r\n    }else {\r\n        // 先判断是否超过容器的最大值\r\n        if(this.nodeCount == this.capacity) {\r\n            // 删除最少应用\r\n            this.removeLeastUsedNode() \r\n        }\r\n        const newNode = new ListNode(key,value)\r\n        this.cache.set(key,newNode)\r\n        // 最新加入的节点保存到头部\r\n        this.addNodeToHead(newNode)\r\n        // 节点数量增加\r\n        this.nodeCount ++\r\n    }\r\n};\r\n\r\n\r\n/** \r\n * @param {list} node \r\n * @return {void}\r\n */\r\nLRUCache.prototype.moveTohead = function(node) {\r\n    this.removeNode(node)\r\n    this.addNodeToHead(node)\r\n};\r\n\r\n/** \r\n * @param {list} node \r\n * @return {void}\r\n */\r\n LRUCache.prototype.removeNode = function(node) {\r\n    node.pre.next = node.next\r\n    node.next.pre = node.pre\r\n};\r\n\r\n/** \r\n * @param {void}\r\n * @return {void}  \r\n */\r\n LRUCache.prototype.removeLeastUsedNode = function() {\r\n    this.nodeCount --\r\n    const leastUsedNode = this.dummyTail.pre\r\n    this.cache.delete(leastUsedNode.key)\r\n    this.removeNode(leastUsedNode)\r\n};\r\n\r\n\r\n/** \r\n * @param {list} node \r\n * @return {void}\r\n */\r\n LRUCache.prototype.addNodeToHead = function(node) {\r\n     // 在虚拟节点头和真实节点之间，插入node\r\n     node.pre = this.dummyHead\r\n     node.next = this.dummyHead.next\r\n     this.dummyHead.next.pre = node\r\n     this.dummyHead.next = node\r\n};\r\n```\r\n\r\n**复杂度分析** - 时间复杂度：O(1) 。 - 空间复杂度：O（N）\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846336633","body":"### 思路 \r\n \r\n1、`DFS`,递归树\r\n \r\n### 代码 \r\n \r\n``` js\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\n var maxDepth = function(root) {\r\n    if(root === null) return 0\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n \r\n``` \r\n \r\n**复杂度分析** \r\n- 时间复杂度：`O(N) `\r\n- 空间复杂度：`O(N)`"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mengwwww":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836631365","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        queue<int> temp;\r\n        stack<int> res;\r\n        while(k!=0){\r\n            temp.push(k%10);\r\n            k = k/10;\r\n        }\r\n        int i=num.size()-1;\r\n        int jinwei = 0;\r\n        while(i>=0 && !temp.empty()){\r\n            res.push((num[i]+temp.front()+jinwei)%10);\r\n            jinwei = (num[i]+temp.front()+jinwei)/10;\r\n            i--;\r\n            temp.pop();\r\n        }\r\n        if(i>=0){\r\n            for(int k = i;k>=0;k--){\r\n                res.push((num[k]+jinwei)%10);\r\n                jinwei = (num[k]+jinwei)/10;\r\n            }\r\n        }\r\n        if(!temp.empty()){\r\n            while(!temp.empty()){\r\n                res.push((temp.front()+jinwei)%10);\r\n                jinwei = (temp.front()+jinwei)/10;\r\n                temp.pop();\r\n            }\r\n            \r\n        }\r\n        if(jinwei>0){\r\n            res.push(jinwei);\r\n        }\r\n        vector<int> m;\r\n        while(!res.empty()){\r\n            m.push_back(res.top());\r\n            res.pop();\r\n        }\r\n        return m;\r\n    }\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837634708","body":"### 思路\r\n使用队列存储对应字符下标所在位置\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        queue<int> q;\r\n        for(int i=0;i<s.length();i++){\r\n            if(c==s[i]){\r\n                q.push(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        int a = q.front();\r\n        q.pop();\r\n        for(int i=0;i<s.length();i++){\r\n            if(q.empty() || abs(i-a)<=abs(i-q.front())){\r\n                res.push_back(abs(i-a));                \r\n            }else if(!q.empty() && abs(i-a)>abs(i-q.front())){\r\n                a = q.front();\r\n                q.pop();\r\n                i--;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 o(n)\r\n空间复杂度o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839496224","body":"```\r\nclass CustomStack {\r\npublic:\r\nvector<int> s;\r\nint top;\r\n    CustomStack(int maxSize) {\r\n        s.resize(maxSize);\r\n        top = 0;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=s.size()){\r\n            s[top]=x;\r\n            top++;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top>0){\r\n            top--;\r\n            return s[top];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for(int i=0;i<min(k,top);i++){\r\n            s[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841064627","body":"```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        stack<int> temp;\r\n        while(!s.empty()){\r\n            temp.push(s.top());\r\n            s.pop();\r\n        }\r\n        int res = temp.top();\r\n        temp.pop();\r\n        while(!temp.empty()){\r\n            s.push(temp.top());\r\n            temp.pop();\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        stack<int> temp;\r\n        while(!s.empty()){\r\n            temp.push(s.top());\r\n            s.pop();\r\n        }\r\n        int res = temp.top();\r\n        //temp.pop();\r\n        while(!temp.empty()){\r\n            s.push(temp.top());\r\n            temp.pop();\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842303895","body":"### 递归\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head==nullptr || head->next==nullptr) return head;\r\n        ListNode *temp = head->next;\r\n        head->next = swapPairs(temp->next);\r\n        temp->next = head;\r\n        return temp;\r\n    }\r\n};\r\n```\r\n###复杂度\r\n时间复杂度 o(n)\r\n空间复杂度 o(n)\r\n\r\n### 迭代\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head==nullptr || head->next==nullptr) return head;\r\n        ListNode *dummyHead = new ListNode(0);\r\n        dummyHead->next = head;\r\n        ListNode *dummy = dummyHead;\r\n        while(dummy->next!=nullptr && dummy->next->next!=nullptr){\r\n            ListNode *node1  = dummy->next;\r\n            ListNode *node2 = dummy->next->next;\r\n            dummy->next = node2;\r\n            node1->next = node2->next;\r\n            node2->next = node1;\r\n            dummy = node1;\r\n        }\r\n        return dummyHead->next;\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度 o(n)\r\n空间复杂度 o(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842766114","body":"```\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if(head==nullptr) return nullptr;\r\n        vector<int> nums;\r\n        while(head!=nullptr){\r\n            nums.push_back(head->val);\r\n            head = head->next;\r\n        }\r\n        return help(nums,0,nums.size()-1);\r\n    }\r\n    TreeNode* help(vector<int> nums,int left,int right){\r\n        if(left>right) return nullptr;\r\n        int mid = (left+right+1)/2;\r\n        TreeNode *root = new TreeNode(nums[mid]);\r\n        root->left = help(nums,left,mid);\r\n        root->right = help(nums,mid+1,right);\r\n        return root;\r\n    }\r\n\r\n};\r\n```\r\n###复杂度\r\n时间复杂度 o(n)\r\n空间复杂度 o(n)\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\nint getLength(ListNode* head){\r\n    int len=0;\r\n    ListNode* p = head;\r\n    while(p!=nullptr){\r\n        len++;\r\n        p = p->next;\r\n    }\r\n    return len;\r\n}\r\nTreeNode *help(ListNode*& head,int left,int right){\r\n    if(left>right) return nullptr;\r\n    int mid = (left+right+1)/2;\r\n    TreeNode *root = new TreeNode();\r\n    root->left = help(head,left,mid-1);\r\n    root->val = head->val;\r\n    head = head->next;\r\n    root->right = help(head,mid+1,right);\r\n    return root;\r\n}\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int len = getLength(head);\r\n        return help(head,0,len-1);\r\n    }\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度 o(n)\r\n空间复杂度 o(log(n))"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843765257","body":"```\r\n ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p = headA,*q = headB;\r\n        if(!p || !q) return NULL;\r\n        while(p!=q){\r\n            p = p!=NULL?p->next:headB;\r\n            q = q!=NULL?q->next:headA;\r\n        }\r\n        return p;\r\n    }\r\n```\r\n### 复杂度\r\n时间复杂度 o(m+n)\r\n空间复杂度 o(1)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JohnVSD":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836632025","body":"## 思路\r\n\r\n参考了官方题解。\r\n\r\n从低位向高位依次计算。例如：123+912，计算过程是 3+2，2+1，1+9 可以得出结果为 1035；可以转换为如下代码：\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let n = num.length;\r\n    \r\n    for (let i = n - 1; i>=0; i--) {\r\n        // 利用取余操作，取出k值最后一位进行加运算\r\n        let sum = num[i] + k % 10;\r\n        // 利用向下取整的方式，去掉k最后一位数，依次计算\r\n        k = Math.floor(k / 10);\r\n        \r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        \r\n        res.push(sum);\r\n    }\r\n    \r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    \r\n    res.revers();\r\n    \r\n    return res;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(max(n, log k))\r\n* 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838735759","body":"## 思路\r\n\r\n分别从字符串左右进行遍历，比较然后取最小值。\r\n\r\n## 代码\r\nTypeScript\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n  let res: number[] = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) continue;\r\n\r\n    let l: number = i;\r\n    let r: number = i;\r\n    let shortest: number= Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r<s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N²)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839493322","body":"## 思路\r\n\r\n使用数组方法模拟栈操作。\r\n\r\n## 代码 (TS)\r\n\r\n```typescript\r\nclass CustomStack {\r\n    maxSize: number;\r\n    stack: number[];\r\n\r\n    constructor(maxSize: number) {\r\n        this.maxSize = maxSize;\r\n        this.stack = new Array();\r\n    }\r\n    \r\n    push(x: number): void {\r\n        if (this.stack.length < this.maxSize) {\r\n            this.stack.push(x);\r\n        }\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.stack.length > 0) {\r\n            return this.stack.pop();\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        for (let i = 0; i<this.stack.length; i++) {\r\n            if (i < k) {\r\n                this.stack[i] = this.stack[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：push、pop 都是 O(1), increment 为O(n) n为stact长度\r\n* 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840614479","body":"## 思路\r\n\r\n利用栈进行实现，遍历字符串，在遇到闭合符号 ']' 之前一直进行入栈操作 --> 直到遇到 ‘]’ 便进行出栈操作 --> 创建变量存储 “需要重复的字符” 和 “重复次数” \r\n 内部使用 while 循环进行逐个判断与出栈。\r\n\r\n## 代码 (TS)\r\n\r\n```typescript\r\nfunction decodeString(s: string): string {\r\n  let stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 遇到 ']' 就出栈\r\n    if (s[i] === ']') {\r\n      let repeatStr = ''; // 记录需要重复的字符\r\n      let num = ''; // 记录数字\r\n\r\n      // 将需要重复的字符进行存储\r\n      while (stack[stack.length - 1] !== '[') {\r\n        repeatStr = stack.pop() + repeatStr;\r\n      }\r\n      // 去除 '['\r\n      stack.pop();\r\n\r\n      // 取出数字\r\n      while (!isNaN(stack[stack.length - 1])) {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      // 重复 num 次 repeatStr\r\n      repeatStr = repeatStr.repeat(parseInt(num));\r\n      stack.push(repeatStr)\r\n    } else {\r\n      // 值不等于 ']' 就入栈\r\n      stack.push(s[i]);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840977986","body":"## 思路\r\n\r\njs中使用数组模拟栈操作。\r\n\r\n## 代码（TS）\r\n```TypeScript\r\nclass MyQueue {\r\n    stack: number[];\r\n\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        return this.stack.shift()\r\n    }\r\n\r\n    peek(): number {\r\n        return this.stack[0]\r\n    }\r\n\r\n    empty(): boolean {\r\n        return !this.stack.length\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：push、pop、peek、empty 都是 O(1)\r\n* 空间复杂度：O(N)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842362539","body":"## 思路\r\n参考了Lucifer的题解😅\r\n如：preNode -> A -> B -> Bnext\r\n变换后：preNode.next = B；B.next = A；A.next = Bnext；\r\n根据上述规律可以先保存一个前置节点、第一个节点、然后进行遍历。遍历中对第二个节点和第一个节点进行交换。代码如下：\r\n\r\n## 代码 (JS)\r\n\r\n```JavaScript\r\nvar swapPairs = function (head) {\r\n\tif (!head || !head.next) return head;\r\n\r\n\tlet res = head.next; // 返回结果\r\n\tlet preNode = new ListNode(); // 前置指针\r\n\tpreNode.next = head;\r\n\tlet now = head; // 第一个节点\r\n\r\n\twhile (now && now.next) {\r\n\t\tlet nextNode = now.next; // 保存第二个节点\r\n\t\tlet nnNode = nextNode.next; // 保存后置指针\r\n\r\n\t\t// 对节点进行交换\r\n\t\tnow.next = nnNode;\r\n\t\tnextNode.next = now;\r\n\t\tpreNode.next = nextNode;\r\n\r\n\t\t// 修改指针，进行下一轮交换\r\n\t\tpreNode = now;\r\n\t\tnow = nnNode;\r\n\t}\r\n\r\n\treturn res;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：O(N) 为链表长度。\r\n* 空间复杂度：O(1) 没有使用多余空间。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843155609","body":"## 思路\r\n\r\n已知信息：有序链表；二叉搜索树(二叉搜索树的任意一个节点，当前节点的值必然大于所有左子树的节点，同理当前节点必然小于所有右子树节点)\r\n\r\n根据得到的信息可以想到：\r\n\r\n* 将链表中心位置作为二叉树搜索树的根节点，然后利用 “深度优先遍历(dfs)” 依次创建左子树和右子树。\r\n* 可以使用快慢指针获取链表中心点，快指针走两步，慢指针走一步，当快指针走到链表结尾时，慢指针正好在链表中心位置。\r\n\r\n## 代码 (JS)\r\n\r\n```JavaScript\r\nvar sortedListToBST = function (head) {\r\n\tif (!head) return null;\r\n\r\n\t// 利用深度优先搜索遍历二叉树\r\n\tconst dfs = (head, foot) => {\r\n\t\tif (head === foot) return null;\r\n\r\n\t\t// 利用快慢指针寻找链表中心点。\r\n\t\tlet fast = head;\r\n\t\tlet slow = head;\r\n\t\twhile (fast !== foot && fast.next !== foot) {\r\n\t\t\tfast = fast.next.next; // 快指针走两步\r\n\t\t\tslow = slow.next; // 慢指针走一步\r\n\t\t}\r\n\r\n\t\t// slow.val 即是“有序单链表”的中心点\r\n\t\tlet root = new TreeNode(slow.val);\r\n\t\troot.left = dfs(head, slow);\r\n\t\troot.right = dfs(slow.next, foot);\r\n\r\n\t\treturn root;\r\n\t};\r\n\r\n\treturn dfs(head, null);\r\n};\r\n```\r\n\r\n## 复杂度分析\r\nn为链表长度\r\n* 时间复杂度：递归深度为 logn，每一层的基本操作数为n，所以总体复杂度为 O(nlogn)\r\n* 空间复杂度：O(logn) "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844058836","body":"## 思路\r\n#### 思路一：利用哈希表\r\n\r\n创建一个 哈希表（hashList） 遍历链表A将每一个节点进行存储，然后遍历链表B判断哈希表中如果存在则直接返回。\r\n此方法比较好理解，但是用到了额外空间（hashList）\r\n\r\n#### 思路二：利用双指针\r\n\r\n创建两个指针 a、b 分别遍历 A、B 两个链表，当 a 指针走到 A 表尾部时就将 a 指针定向到 B表的头结点再次遍历B表。b指针同理先遍历B表再遍历A表。直到a、b指针相等的时候就是相交点。\r\n\r\n举例：\r\n* A表为：[A, B, C]；B表为：[E, C]\r\n* A表走过的路径为：A+B+C+E+C\r\n* B表走过的路径为：E+C+A+B+C\r\n\r\n双指环方法很巧妙，在同样时间复杂度的情况下，空间复杂度控制在了O(1);\r\n（路西大法好👍）\r\n\r\n## 代码 (TS)\r\n\r\n```TypeScript\r\n/**\r\n * todo 方法 1：利用哈希表\r\n * * 时间复杂度：O(m+n)\r\n * * 空间复杂度：O(n)\r\n */ \r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n  let hashNode = new Set();\r\n\r\n  while (headA != null) {\r\n    hashNode.add(headA);\r\n    headA = headA.next;\r\n  }\r\n\r\n  while (headB != null) {\r\n    if (hashNode.has(headB)) return headB;\r\n    headB = headB.next;\r\n  }\r\n  \r\n  return null;\r\n}\r\n\r\n/**\r\n * todo 方法 2：利用双指针\r\n * * 时间复杂度：O(n)\r\n * * 空间复杂度：O(1)\r\n */\r\nfunction getIntersectionNodeB(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n  if (headA === null || headB === null) return null;\r\n\r\n  let a = headA;\r\n  let b = headB;\r\n\r\n  while (a !== b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n\r\n  return a;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n假设：m 为 headA 长度，n 为 headB 长度\r\n\r\n* 时间复杂度：\r\n  * 哈希表法：O(m + n) => O(n)\r\n  * 双指针法：O(n)\r\n* 空间复杂度：\r\n  * 哈希表法：O(n) n为哈希list\r\n  * 双指针法：O(1) 没有使用额外的空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845067114","body":"## 思路\r\n双指针之快慢指针：\r\n参考西法的讲义，创建快慢指针，快指针走两步，慢指针走一步，两者相遇第一次时可能不是在环的入口，此时将快指针重新定位至head节点，然后快慢指针每次各走一步，两者再次相遇时就是环的入口。\r\n\r\n## 代码 (TS)\r\n\r\n```TypeScript\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n  if (head === null || head.next === null) return null;\r\n\r\n  let fast = head;\r\n  let slow = head;\r\n\r\n  do {\r\n    fast = fast && fast.next ? fast.next.next : null;\r\n    slow = slow.next;\r\n  } while (fast !== slow)\r\n\r\n  if (fast === null) return null;\r\n\r\n  fast = head;\r\n  while (fast !== slow) {\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n\r\n  return fast;\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn 为 链表 长度\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiZhongdd":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836634467","body":"思路\r\n数组的数值操作\r\n1：新建一个数组用于存储变量\r\n2:倒序遍历数组，每个值与K的余数相加，如果和小于0，那么push这个和，如果大于0，那么push该和的个位数，K为十位数。\r\n3：依次遍历，重复第一步骤，等到遍历完后，如果k继续大于0,那么依次将k的值一个个添加进res数组。\r\n4：对结果进行翻转得到数字\r\n\r\nfunction add(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838362553","body":"思路1\r\n左右各遍历一次,找到相同值的位置，比较左右最快找到值的坐标，然后得到绝对值比较，取小值\r\n\r\nvar shortestToChar = function(s, c) {\r\n   let prev=-Infinity,result=[];\r\n   for(let i=0;i<s.length;i++){\r\n       if(s.charAt(i)===c){\r\n           prev=i\r\n       }\r\n       result[i]=Math.abs(i-prev)\r\n   }\r\n   prev=Infinity\r\n   for(let j=s.length-1;j>=0;--j){\r\n        if(s.charAt(j)===c){\r\n           prev=j\r\n       }\r\n       result[j]=Math.min(result[j],Math.abs(prev-j))\r\n   }\r\n   return result\r\n};\r\n复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n思路2\r\n先循环遍历一次，找到相同值的位置保存在一个数组ans中\r\n再次循环，将坐标与ans中的坐标差的绝对值，取最小的值\r\nvar shortestToChar = function(s, c) {\r\n    let ans=[],result=[];\r\n    for(let i=0;i<s.length;i++){\r\n        if(s.charAt(i)===c){\r\n            ans.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min=Math.abs(i-ans[0])\r\n        for(let j=1;j<ans.length;j++){\r\n            min=Math.min(min,Math.abs(i-ans[j]))\r\n        }\r\n        result[i]=min\r\n    }\r\n    return result\r\n};\r\n复杂度\r\n时间复杂度：O(n2)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839449634","body":"思路：暴力求解\r\nvar CustomStack = function (maxSize) {\r\n  this.stack = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.stack.length < this.maxSize) {\r\n    this.stack.push(x)\r\n  }\r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function () {\r\n if(this.stack.length){\r\n     return this.stack.pop()\r\n }else{\r\n     return -1\r\n }\r\n};\r\n\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.stack.length; i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n时间复杂度：o(n),空间复杂度o(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840550016","body":"\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n    const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n    while (reg.lastIndex < s.length) {\r\n        let token = reg.exec(s)[0];\r\n        if (token !== ']') {\r\n            // 数字，字母，左括号通通入栈\r\n            stack.push(token);\r\n        } else {\r\n            // 遇到右括号就开始出栈\r\n            let str = '';\r\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n            while (peek() !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            // 丢掉左括号\r\n            stack.pop();\r\n            // 左括号前面的一定是模式重复的次数\r\n            const num = +stack.pop();\r\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n            stack.push(str.repeat(num));\r\n        }\r\n    }\r\n    return stack.join('');\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841220184","body":"解题思路：运用两个栈\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stackOne=[]\r\n    this.stackTwo=[]\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stackOne.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    let index=this.stackOne.length-1;\r\n    while(index>0){\r\n        this.stackTwo.push(this.stackOne.pop())\r\n        index--\r\n    }\r\n    let temp=this.stackOne.pop()\r\n    let length=this.stackTwo.length;\r\n    while(length){\r\n        this.stackOne.push(this.stackTwo.pop())\r\n        length--\r\n    }\r\n    return temp\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stackOne[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stackOne.length===0\r\n};\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841794801","body":"\r\nvar rotateRight = function(head, k) {\r\n    if(!head)return head\r\n    if(!head.next)return head;\r\n    let n=1;\r\n    let cur=head;\r\n    while(cur.next){\r\n        cur=cur.next;\r\n        n++;\r\n    }\r\n    let add = n - k % n;\r\n    if(add===n)return head;\r\n    cur.next=head;\r\n    while(add--){\r\n        cur=cur.next;\r\n    }\r\n    const res=cur.next;\r\n    cur.next=null;\r\n    return res\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842149251","body":"var swapPairs = function(head) {\r\n    if (!head|| !head.next) {\r\n        return head;\r\n    }\r\n    const newHead = head.next;\r\n    head.next = swapPairs(newHead.next);\r\n    newHead.next = head;\r\n    return newHead;\r\n};\r\n时间复杂度O(N),空间复杂度O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842858623","body":"var sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head == tail) return null;\r\n  let end = head;\r\n  let start = head;\r\n  while (end != tail && end.next != tail) {\r\n    end = end.next.next;\r\n    start = start.next;\r\n  }\r\n  let mid = new TreeNode(start.val);\r\n  mid.left = dfs(head, start);\r\n  mid.right = dfs(start.next, tail);\r\n  return mid;\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843709449","body":" if(!headA||!headB){\r\n        return null\r\n    }\r\n    let nodeA=headA,nodeB=headB;\r\n    while(nodeA!=nodeB){\r\n        if(nodeA!=null){\r\n            nodeA=nodeA.next\r\n        }else{\r\n            nodeA=headB\r\n        }\r\n        if(nodeB!=null){\r\n            nodeB=nodeB.next\r\n        }else{\r\n            nodeB=headA\r\n        }    \r\n    }\r\n    return nodeA"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844699450","body":"方式一\r\nvar detectCycle = function(head) {\r\n   let slow=fast=head;\r\n   while(fast!=null){\r\n       if(fast.next!==null){\r\n           fast=fast.next.next;\r\n           slow=slow.next;\r\n           if(fast===slow){\r\n              let pre=head;\r\n              while(pre!==slow){\r\n                pre=pre.next;\r\n                slow=slow.next;\r\n            }\r\n         return pre\r\n        }\r\n       }else{\r\n           return null\r\n       }\r\n   }\r\n   return null\r\n};\r\n\r\n方式二\r\n\r\nvar detectCycle = function(head) {\r\n    let map=new Map();\r\n    let node=head;\r\n    let pos=-1\r\n    while(node){\r\n        pos++\r\n        if(map.has(node)){\r\n            return node\r\n        }else{\r\n            map.set(node,pos)\r\n            node=node.next\r\n        }\r\n    }\r\n    return null;\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845674480","body":"function ListNode(key, val) {\r\n  this.key = key;\r\n  this.val = val;\r\n  this.pre = this.next = null;\r\n}\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.capacity = capacity;   \r\n  this.size = 0;\r\n  this.data = {};\r\n  this.head = new ListNode();\r\n  this.tail = new ListNode();\r\n  this.head.next = this.tail;\r\n  this.tail.pre = this.head;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if (this.data[key] !== undefined) {\r\n    let node = this.data[key];\r\n    this.removeNode(node);\r\n    this.appendHead(node);\r\n    return node.val;\r\n  } else {\r\n    return -1;\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n   let node;\r\n  if (this.data[key] !== undefined) {\r\n    node = this.data[key];\r\n    this.removeNode(node);\r\n    node.val = value;\r\n  } else {\r\n    node = new ListNode(key, value);\r\n    this.data[key] = node;\r\n    if (this.size < this.capacity) {\r\n      this.size++;\r\n    } else {\r\n      key = this.removeTail();\r\n      delete this.data[key];\r\n    }\r\n  }\r\n  this.appendHead(node);\r\n};\r\n\r\nLRUCache.prototype.removeTail = function(node) {\r\n   let key = this.tail.pre.key;\r\n  this.removeNode(this.tail.pre);\r\n  return key;\r\n};\r\nLRUCache.prototype.removeNode=function(node){\r\n    let preNode = node.pre,\r\n    nextNode = node.next;\r\n    preNode.next = nextNode;\r\n    nextNode.pre = preNode;\r\n}\r\nLRUCache.prototype.appendHead = function(node) {\r\n     let firstNode = this.head.next;\r\n  this.head.next = node;\r\n  node.pre = this.head;\r\n  node.next = firstNode;\r\n  firstNode.pre = node;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846403281","body":"var maxDepth = function(root) {\r\n    if(root===null){\r\n        return 0\r\n    }\r\n    return 1+Math.max(maxDepth(root.left),maxDepth(root.right))\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LS-King":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635602","body":"### 思路\r\n\r\n重点关注进位：\r\n\r\n1. 设置中间变量digit，存放数字k、数组num和前位进位到该数位值的和（可以大于9），模10之后作为新的该数位数值，除10后的进位进入下层循环\r\n2. 对于最高位，需要考虑进位的位数增加带来的数组长度改变的问题，设置判断条件插入新的最高位，同时注意下标的改变\r\n\r\n### 代码\r\nC++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int length = num.size();\r\n        int index = length;\r\n        int digit = 0;\r\n        while (k != 0 || digit != 0) {\r\n            //如果上一轮循环中已更新到num最高位，则在前面添加一个数位，将其值置为0\r\n            if (index == 0) {\r\n                num.insert(num.begin(), 0);\r\n            //下标迭代，每层循环向高位移动1位\r\n            } else {\r\n                index -= 1;\r\n            }\r\n            //上层循环的进位加上本轮循环对应数位上的值构成新的待定数位新值（可能超过9）\r\n            digit += k % 10;\r\n            //k去掉最后一位，等待下一轮循环\r\n            k /= 10;\r\n            //相同数位上数字相加（可能超过9）\r\n            digit += num[index];\r\n            //取个位部分作为该数位的新值\r\n            num[index] = digit % 10;\r\n            //将超过9的部分留到下一次循环\r\n            digit /= 10;\r\n        }\r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)，使用传进来的源数组num的空间。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838681307","body":"### 思路\r\n\r\n开辟一个数组 chIndex 存放匹配字符的下标，之后遍历字符串，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> chIndex;\r\n        vector<int> res;\r\n        //遍历字符串，将匹配字符下标存入数组chIndex\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] == c) {\r\n                chIndex.push_back(i);\r\n            }\r\n        }\r\n        //遍历数组，逐字符计算其下标与所有匹配字符下标差的绝对值，取最小值存入res数组\r\n        for (int i = 0; i < s.size(); i++) {\r\n            //最大距离不超过10000\r\n            int distance = 10000;\r\n            for (int index : chIndex) {\r\n                distance = min(distance, abs(index - i));\r\n            }\r\n            res.push_back(distance);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N^2)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)，其中 N 为字符串长度。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839881313","body":"### 思路\r\n\r\n\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass CustomStack {\r\n    vector<int> customstack;\r\n    int top = -1, maxSize = 0;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        if (maxSize >= 0) {\r\n            this->maxSize = maxSize;\r\n        }\r\n    }\r\n    //压栈\r\n    void push(int x) {\r\n        if (top + 1 < maxSize) {\r\n            customstack.push_back(x);\r\n            top += 1;\r\n        }\r\n        return;\r\n    }\r\n    //弹栈\r\n    int pop() {\r\n        if (top + 1 > 0) {\r\n            int back = customstack.at(top);\r\n            customstack.pop_back();\r\n            top -= 1;\r\n            return back;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < top + 1; i++) {\r\n            customstack.at(i) += val;\r\n        }\r\n        return;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：increment函数 O(min(maxSize, k)), 其余 O(1)。\r\n- 空间复杂度：O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840569699","body":"### 思路\r\n\r\n开辟一个存放整型的栈 sig 用来匹配和存放前中括号的下标，遇到 [ 将其下标入栈；遇到 ] 则弹栈，并向前寻找出重复次数，将重复后的新子串替换掉”数字+[原子串]“。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string nums = \"0123456789\", res = s, numstr = \"\", sub = \"\";\r\n        //前括号下标栈\r\n        stack<int> sig;\r\n        int num, front, back, p = 0;\r\n        while (res[p] != '\\0') {\r\n            //若匹配到[，则将下标入栈\r\n            if (res[p] == '[') {\r\n                sig.push(p);\r\n            //若匹配到]，则将sig栈顶下标出栈，并对front, back赋值\r\n            } else if (res[p] == ']') {\r\n                front = sig.top();\r\n                sig.pop();\r\n                back = p;\r\n                //使用q作为下标寻找数字\r\n                int q = front - 1;\r\n                //向前寻找数字，跳出循环时，数字开始下标为q + 1\r\n                while (q >= 0 && nums.find(res[q]) != string::npos) {\r\n                    numstr += res[q];\r\n                    q--;\r\n                }\r\n                //将numstr逆序并转换为整型存入num\r\n                reverse(numstr.begin(), numstr.end());\r\n                num = stoi(numstr);\r\n                //将数字字符串重新置空\r\n                numstr = \"\";\r\n                //替换括号中的字符串\r\n                for (int i = 0; i < num; i++) {\r\n                    sub += res.substr(front + 1, back - front - 1);\r\n                }\r\n                res.replace(q + 1, back - (q + 1) + 1, sub);\r\n                //将字串重新置空\r\n                sub = \"\";\r\n                //修改遍历下标p的位置，使其指向替换后子串的结尾\r\n                p = q + 1 + num * (back - front - 1);\r\n                continue;\r\n            }\r\n            p++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N), 其中N为字符串s的长度。\r\n- 空间复杂度：O(k), k为原字符串中中括号的对数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840998573","body":"### 思路\r\n\r\n做到均摊时间复杂度O(1)，关键在于将双栈看作整体，两者一起组成队列，而非一个模拟队列，一个作为辅助。\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> in, out;\r\n    void intoout () {\r\n        while (!in.empty()) {\r\n            out.push(in.top());\r\n            in.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {}\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (out.empty()) {\r\n            intoout();\r\n        }\r\n        int res = out.top();\r\n        out.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (out.empty()) {\r\n            intoout();\r\n        }\r\n        return out.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return in.empty() && out.empty();\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1), push和pop操作的均摊时间复杂度为O(1)，因为对于每个元素，从其入队到出队，一共经历两次入栈两次出栈，操作次数固定。\r\n- 空间复杂度：O(N)。\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841800857","body":"### 思路\r\n\r\n遍历确定链表长度，计算新链表头尾位置，再次遍历到新头尾，断掉原有链接，并链接原头尾\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        ListNode* newhead = head;\r\n        ListNode* newtail = head;\r\n        ListNode* tail = head;\r\n        int length = 1;\r\n        //若所给链表为空，直接返回\r\n        if (head == nullptr) {\r\n            return head;\r\n        }\r\n        //遍历获得尾结点和链表总长\r\n        while (tail->next != nullptr) {\r\n            length++;\r\n            tail = tail->next;\r\n        }\r\n        //计算位移个数\r\n        k %= length;\r\n        //当需要位移时\r\n        if (k != 0) {\r\n            //计算新链表的尾结点位置\r\n            int pos = length - k - 1;\r\n            //找到新尾结点\r\n            while (pos != 0) {\r\n                newtail = newtail->next;\r\n                pos--;\r\n            }\r\n            //确定新头结点\r\n            newhead = newtail->next;\r\n            //断掉新头尾间的链接\r\n            newtail->next = nullptr;\r\n            //链接原尾结点与原头结点\r\n            tail->next = head;\r\n        }\r\n        return newhead;        \r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N), 其中N为链表长度。\r\n- 空间复杂度：O(1)。\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843863784","body":"### 思路\r\n\r\n双指针法\r\n\r\n### 代码\r\n\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        ListNode *p1 = headA;\r\n        ListNode *p2 = headB;\r\n        while (p1 != p2) {\r\n            if (p1 == NULL) {\r\n                p1 = headB;\r\n            }\r\n            else {\r\n                p1 = p1->next;\r\n            }\r\n            if (p2 == NULL) {\r\n                p2 = headA;\r\n            }\r\n            else {\r\n                p2 = p2->next;\r\n            }\r\n        }\r\n        return p1;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heartinn":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836635929","body":"思路\r\n列表转数字直接相加再转回列表\r\n\r\n代码\r\nPython3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return map(int,str(int(''.join(map(str,A))) + K))\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838007634","body":"算法思想：\r\n前向遍历记录下每个位置和出现在前面的目标字符的距离，后向遍历记录每个位置和出现在后面的目标字符的距离\r\n\r\n代码：\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [len(s)] * len(s)\r\n        previous = -1\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                previous = i\r\n            if previous != -1:\r\n                result[i] = i - previous\r\n        latter = -1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                latter = i\r\n            if latter != -1:\r\n                result[i] = min(result[i], latter - i)\r\n        return result\r\n\r\n复杂度\r\n时间：o(n)\r\n空间：o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839381199","body":"思路\r\n使用一个额外的数组记录末尾的增量，在弹出时将增量往前传递\r\n\r\npython\r\nfrom collections import deque\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.top = -1\r\n        self.stack = deque()\r\n        self.add = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            if len(self.add) > 1:\r\n                self.add[-2] += self.add[-1]\r\n            return self.stack.pop() + self.add.pop()\r\n        return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        idx = min(k, len(self.add)) - 1\r\n        if idx >= 0:\r\n            self.add[idx] += val\r\n\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度:O(n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840651779","body":"思路：\r\n遇到[时push进数字，遇到]时pop出子字符串，push进倍乘后的字符串\r\n\r\n复杂度分析：\r\n时间：单次for O(n)\r\n空间：O(n)\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        string = \"\"\r\n        for token in s:\r\n            if token.isdigit():\r\n                num = num * 10 + int(token)\r\n            elif token == \"[\":\r\n                stack.append(num)\r\n                num = 0\r\n            elif token.isalpha():\r\n                stack.append(token)\r\n            else:\r\n                while isinstance(stack[-1], str):\r\n                    string = stack.pop() + string\r\n                stack.append(stack.pop() * string)\r\n                string = \"\"\r\n        return \"\".join(stack)\r\n"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842239198","body":"思路\r\n递归 \r\n代码\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        end = self.swapPairs(head.next.next)\r\n        next = head.next\r\n        next.next = head\r\n        head.next = end\r\n        return next\r\n复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844207430","body":"class Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        current_a, current_b = headA, headB\r\n        while (current_a or current_b) and current_a != current_b:\r\n            current_a = current_a.next if current_a else headB\r\n            current_b = current_b.next if current_b else headA\r\n        if current_a == current_b:\r\n            return current_b\r\n        else:\r\n            return None\r\n复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"UCASHurui":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836637454","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n先把数组A扩展到和K相加后可能的最长长度，然后模拟加法，每次取K的最低位和A中对应位以及进位相加，然后更新进位并将K除10后取整。（其实也可以把A转换成整数后相加，考虑到其他语言可能不像python能够自动进行大数运算所以还是转换成数组相加更好）\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = 0\r\n        len_K, len_A = len(str(K)), len(A)\r\n        A = [0]*(max(len_A, len_K)-len_A + 1) + A\r\n        pos = len(A) - 1\r\n        while K or carry:\r\n                tmp = A[pos] + K%10 + carry\r\n                carry = tmp // 10\r\n                A[pos] = tmp%10\r\n                K = int(K/10)\r\n                pos -= 1\r\n        if A[0]==0: return A[1:]\r\n        return A\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837870441","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n两趟遍历分别找到每一个位置左方和右方距离最近的目标字符，取其中最小值计入最终结果。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        povit = -float('inf')\r\n        res = [0] * len(S)\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = i-povit\r\n        povit = float('inf')\r\n        for i in range(len(S)-1, -1, -1):\r\n            if S[i] == C:\r\n                povit = i\r\n            else:\r\n                res[i] = min(res[i], povit-i)\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762508","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 思路\r\n首先一趟遍历找到链表末尾并找到链表的长度length，因为k有可能比链表的长度要大，所以对长度求模一下，如果求模后的k为0的话就直接返回head即可，否则从头开始遍历length-k-1个位置找到切割节点，将切割节点的下一个节点设置为新的head，之前找到的链表末尾节点的next设置为原本的head，切割节点的next设置为空即可。\r\n\r\n## 关键点\r\n\r\n- 认识到旋转链表就是找到一个切割点将链表切成两部分，并把前一段拼到后一段的后面。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head or not head.next or k==0: return head\r\n        tail = p = head\r\n        length = 1\r\n        while tail.next:\r\n            tail = tail.next\r\n            length += 1\r\n        k %= length\r\n        if k == 0: return head\r\n        for _ in range(length - k - 1):\r\n            p = p.next\r\n        new_head = p.next\r\n        p.next = None\r\n        tail.next = head\r\n        return new_head\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842861307","body":"## 思路\r\n\r\n二叉搜索树的中序遍历正好是按所有节点排序的顺序，所以我们可以使用快慢指针找到中序遍历的中点，把它当做根节点，然后根节点左边的节点正好可以递归的生成根节点的左子树，根节点右边部分可以递归地生成根节点的右子树，递归的时候限制对应的头和尾结点即可。\r\n\r\n## 代码(Python3)\r\n\r\n```python\r\nclass Solution:\r\n    def helper(self, head, tail):\r\n        if head == tail:\r\n            return None\r\n        fast = slow = head\r\n        while fast != tail and fast.next != tail:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        root = TreeNode(val=slow.val)\r\n        root.left = self.helper(head, slow)\r\n        root.right = self.helper(slow.next, tail)\r\n        return root\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return None\r\n        return self.helper(head, None)\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(NlogN), 其中N为结点数，因为最多递归logN次，每次递归会遍历一部分结点。\r\n* 空间复杂度：O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845169328","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 思路\r\n使用快慢指针分别从head结点出发，分别每次走两步和一步，如果fast指针先遇到None结点则说明链表中无环；假如相遇了，将快指针指向头结点，之后快慢指针以相同的速度走，第二次相遇的节点就是目标节点。\r\n## 关键点\r\n\r\n-  发现第二次相遇的节点就是目标节点这一性质，由于github不方便写公式就略过了。（其实就是通过快慢指针走过的节点数是两倍关系来列方程，得出头结点到环开始节点和第一次相遇的节点到环开始节点的距离是相等的这一结论）\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return None\r\n        slow, fast = head.next, head.next.next\r\n        while fast != slow:\r\n            if fast and fast.next:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            else:\r\n                return None\r\n        fast = head\r\n        while slow != fast:\r\n            fast, slow = fast.next, slow.next\r\n        return slow\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为链表长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BraveSage":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836638684","body":"## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n### 思路\r\n\r\n1. 模拟数字加法，倒序遍历数组和每次取得整数K的各位数的值进行相加\r\n2. 判断当前位数的数是否大于10，如果大于10在整数k中进行+1\r\n3. 让k除以10，确保计算的位数与数组一致\r\n\r\n\r\n\r\n### 代码（两种思路一致，不过下方节省了一个while循环）\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0; i--){\r\n            int temp = num[i] + k%10;\r\n            ans.add(temp%10);\r\n            k /= 10;\r\n            if(temp >= 10) k++;\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList();\r\n        for(int i = num.length-1; i >= 0 || k > 0; i--, k/=10){\r\n            if(i >= 0){\r\n                k += num[i];\r\n            }\r\n            ans.add(k%10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(max(n,log(k))) 整数与数组长度之间取最大\r\n\r\n空间：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838733842","body":"## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n- 字符串 S 的长度范围为 [1, 10000]。\r\n- C 是一个单字符，且保证是字符串 S 里的字符。\r\n- S 和 C 中的所有字母均为小写字母。\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n获取指定string的当前前一个为c的索引位置与当前索引位置的最小值即可，然后记录在res数组当中\r\n\r\n### 代码\r\n\r\n- Java\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int length = S.length();\r\n        int[] res = new int[length];\r\n        int prev = S.indexOf(C),next = S.indexOf(C, prev+1);\r\n        for (int i = 0; i < length; i++){\r\n            res[i] = Math.abs(i-prev);\r\n            if(next!=-1){\r\n                res[i] = Math.min(res[i],next-i);\r\n                if(i==next){\r\n                    prev = next;\r\n                    next = S.indexOf(C,next+1);\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n) 创建了为S.length()长度的数组"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873183","body":"## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1); // 栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.pop(); // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2); // 栈变为 [1, 2]\r\ncustomStack.push(3); // 栈变为 [1, 2, 3]\r\ncustomStack.push(4); // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100); // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100); // 栈变为 [201, 202, 103]\r\ncustomStack.pop(); // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop(); // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop(); // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop(); // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n### 思路\r\n\r\n使用数组实现一个简单的栈\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\nclass CustomStack {\r\n\r\n    int [] stack;\r\n    int size = 0;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return ;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0) return -1;\r\n        return stack[--size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < stack.length && i < k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n- push：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)\r\n\r\n- push：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)\r\n\r\n- push：\r\n\r\n时间：O(min(n,m)) n为数组长度，m为k的大小\r\n\r\n空间：O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841656439","body":"## 题目描述\r\n\r\n```\r\n这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。\r\n\r\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n示例 1:\r\n\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。\r\n示例 2:\r\n\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。\r\n注意:\r\n\r\narr的长度在[1, 2000]之间。\r\narr[i]的大小在[0, 10**8]之间。\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 思路\r\n\r\n该题本质上就是求出正序排序的个数，在遍历数组的同时，如果当前栈顶没有大于当前下标数组元素，就可以组成两块，否则就只有一块。通过求出每次的当前下标是否是栈顶最大值即可求出最多的块数\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack();\r\n        for(int i = 0; i < arr.length; i++){\r\n            int num = arr[i];\r\n            if(stack.isEmpty() || stack.peek() <= num){\r\n                stack.push(num);\r\n            }else{\r\n                if(!stack.isEmpty() && stack.peek() > num){\r\n                    stack.pop();\r\n                }\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(N)\r\n\r\n空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841822127","body":"## 题目描述\r\n\r\n```\r\n给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。\r\n\r\n示例 1:\r\n\r\n输入: 1->2->3->4->5->NULL, k = 2\r\n输出: 4->5->1->2->3->NULL\r\n解释:\r\n向右旋转 1 步: 5->1->2->3->4->NULL\r\n向右旋转 2 步: 4->5->1->2->3->NULL\r\n示例 2:\r\n\r\n输入: 0->1->2->NULL, k = 4\r\n输出: 2->0->1->NULL\r\n解释:\r\n向右旋转 1 步: 2->0->1->NULL\r\n向右旋转 2 步: 1->2->0->NULL\r\n向右旋转 3 步: 0->1->2->NULL\r\n向右旋转 4 步: 2->0->1->NULL\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n1. 获取链表长度\r\n2. 通过链表长度和旋转k个位置进行计算实际旋转的位置次数\r\n3. 设置一个新的尾结点，将链表成环，然后进行遍历实际次数即可\r\n\r\n### 代码\r\n\r\n-  java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) { val = x; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null || head.next==null){\r\n            return head;\r\n        }\r\n        ListNode ring = head;\r\n        int length = 1;\r\n        while(ring.next!=null){\r\n            ring = ring.next;\r\n            length ++;\r\n        }\r\n        ring.next = head;\r\n        ListNode newTail = head;\r\n        int index = length - k % length - 1;\r\n        while(index!=0){\r\n            index--;\r\n            newTail = newTail.next;\r\n        }\r\n        ListNode newHead = newTail.next;\r\n   \t\t//取消成环\r\n        newTail.next = null;\r\n\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842392444","body":"## 题目描述\r\n\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n示例 1：\r\n```\r\n\r\n[![image](https://camo.githubusercontent.com/37e86afda9f65871e855a3affee582b2c887ab3087927b4dc92801bc6d4ad26f/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30332f737761705f6578312e6a7067)](https://camo.githubusercontent.com/37e86afda9f65871e855a3affee582b2c887ab3087927b4dc92801bc6d4ad26f/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30332f737761705f6578312e6a7067)\r\n\r\n```\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n创建一个dummy的节点作为head节点的上节点，创建临时节点temp，将每个节点和其下一个节点两两交换，然后遍历去下两个节点即可\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode temp = dummy;\r\n        while(temp.next!=null &&temp.next.next!=null){\r\n            ListNode node1 = temp.next;\r\n            ListNode node2 = temp.next.next;\r\n            node1.next = node2.next;\r\n            node2.next = node1;\r\n            temp.next = node2;\r\n            temp = node1;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843145483","body":"## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n    0\r\n   / \\\r\n -3   9\r\n /   /\r\n-10  5\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n1. 获取链表长度\r\n2. 以中间节点作为根节点递归实现左右赋值，分治思想\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n\r\n    ListNode node;\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        int length = getLength(head);\r\n        node = head;\r\n        return buildTree(0, length-1);\r\n    }\r\n\r\n    public int getLength(ListNode node){\r\n        int i = 0;\r\n        while(node!=null){\r\n            i++;\r\n            node = node.next;\r\n        }\r\n        return i;\r\n    }\r\n\r\n    public TreeNode buildTree(int left, int right){\r\n        if(right < left){\r\n            return null;\r\n        }\r\n        int mid = (left+right+1)/2;\r\n        TreeNode root = new TreeNode();\r\n        root.left = buildTree(left,mid-1);\r\n        root.val = node.val;\r\n        node = node.next;\r\n        root.right = buildTree(mid + 1, right);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(nlogn) \r\n\r\n空间：O(nlogn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844218768","body":"### 思路\r\n\r\n链表A和链表B同时进行遍历，当遍历为null时，指向另一个链表，直到两个链表相同即可\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        ListNode node1 = headA, node2 = headB;\r\n\r\n        while(node1 != node2){\r\n           if(node1 != null){\r\n               node1 = node1.next;\r\n           }else{\r\n               node1 = headB;\r\n           }\r\n           if(node2 != null){\r\n               node2 = node2.next;\r\n           }else{\r\n               node2 = headA;\r\n           }\r\n        }\r\n        return node2;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(m+n)\r\n\r\n空间：O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845232551","body":"## 题目描述\r\n\r\n```\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\r\n\r\n说明：不允许修改给定的链表。\r\n\r\n进阶：\r\n\r\n你是否可以使用 O(1) 空间解决此题？\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n1. 使用快慢指针，获取到快指针和慢指针的相交点\r\n2. 然后从头遍历与相交节点同时进行遍历，即可拿到答案\r\n   1. 慢指针走的距离为s，快指针为2s，圈数必定是慢指针的两倍+头结点到成环节点的位置（即假设尾结点直接指向头结点时必定遍历两圈快慢指针相遇）\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode fast = head, slow  = head;\r\n        while(fast != null  && fast.next!=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(slow == fast){\r\n                fast = head;\r\n                while(fast != slow){\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                return fast;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846035913","body":"## 题目描述\r\n\r\n```\r\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。\r\n实现 LRUCache 类：\r\n\r\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\r\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\r\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\r\n\r\n\r\n进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？\r\n\r\n\r\n\r\n示例：\r\n\r\n输入\r\n\r\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\r\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\r\n输出\r\n[null, null, null, 1, null, -1, null, -1, 3, 4]\r\n解释\r\n\r\nLRUCache lRUCache = new LRUCache(2);\r\nlRUCache.put(1, 1); // 缓存是 {1=1}\r\nlRUCache.put(2, 2); // 缓存是 {1=1, 2=2}\r\nlRUCache.get(1);    // 返回 1\r\nlRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}\r\nlRUCache.get(2);    // 返回 -1 (未找到)\r\nlRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}\r\nlRUCache.get(1);    // 返回 -1 (未找到)\r\nlRUCache.get(3);    // 返回 3\r\nlRUCache.get(4);    // 返回 4\r\n```\r\n\r\n\r\n\r\n### 思路\r\n\r\n使用链表+hashMap的结构来实现\r\n\r\n\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    private Map<Integer, Node> cache = new HashMap<Integer, Node>();\r\n    private int size;\r\n    private int capacity;\r\n    private Node head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点\r\n        head = new Node();\r\n        tail = new Node();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        Node node = cache.get(key);\r\n        if(node==null){\r\n            return -1;\r\n        }\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        Node node = cache.get(key);\r\n        if (node == null) {\r\n            Node newNode = new Node(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            size++;\r\n            if (size > capacity) {\r\n                Node tail = removeTail();\r\n                cache.remove(tail.key);\r\n                size--;\r\n            }\r\n        }else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(Node node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(Node node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(Node node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private Node removeTail() {\r\n        Node tailPrevNode = tail.prev;\r\n        removeNode(tailPrevNode);\r\n        return tailPrevNode;\r\n    }\r\n\r\n}\r\nclass Node {\r\n    Node prev, next;\r\n    int key, value;\r\n\r\n    public Node(){}\r\n    public Node(int key,int value){\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\nput：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)\r\n\r\nget：\r\n\r\n时间：O(1)\r\n\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846394503","body":"## 题目描述\r\n\r\n```\r\n给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n示例：\r\n给定二叉树 [3,9,20,null,null,15,7]，\r\n\r\n  3\r\n / \\\r\n9  20\r\n  /  \\\r\n 15   7\r\n返回它的最大深度 3 。\r\n```\r\n\r\n## 题目地址\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree\r\n\r\n\r\n\r\n### 思路\r\n\r\ndfs实现\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left) + 1,maxDepth(root.right) + 1);\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(depth)\r\n\r\n\r\n\r\n### 思路\r\n\r\nbfs实现\r\n\r\n### 代码\r\n\r\n- java\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        Queue<TreeNode> queue = new LinkedList();\r\n        queue.offer(root);\r\n        int ans = 0;\r\n        while(!queue.isEmpty()){\r\n            int size = queue.size();\r\n            while(size > 0){\r\n                TreeNode node = queue.poll();\r\n                if(node.left != null){\r\n                    queue.offer(node.left);\r\n                }\r\n                if(node.right != null){\r\n                    queue.offer(node.right);\r\n                }\r\n                size--;\r\n            }\r\n            ans++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"KevinWorkSpace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836639151","body":"## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int index = A.length - 1;\r\n        int add = 0;\r\n        while (index >= 0 || K > 0 || add > 0) {\r\n            int a = 0;\r\n            if (index >= 0) a = A[index];\r\n            int b = K % 10;\r\n            int tmp = (a + b + add) % 10;\r\n            add = (a + b + add) / 10;\r\n            res.add(tmp);\r\n            K /= 10;\r\n            index --;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838339270","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int index = -1;\r\n        for (int i=0; i<res.length; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Integer.MAX_VALUE;\r\n            else res[i] = i - index;\r\n        }\r\n        index = -1;\r\n        for (int i=res.length-1; i>=0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            else if (index == -1) res[i] = Math.min(Integer.MAX_VALUE, res[i]);\r\n            else res[i] = Math.min(index - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841182191","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841752932","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        int cnt = 0;\r\n        ListNode n = head;\r\n        while (n != null) {\r\n            cnt ++;\r\n            n = n.next;\r\n        }\r\n        if (k % cnt == 0) return head;\r\n        ListNode node = head;\r\n        for (int i=0; i<k%cnt; i++) {\r\n            node = node.next;\r\n        }\r\n        ListNode pre = null;\r\n        ListNode tmp = head;\r\n        ListNode last = null;\r\n        while (node != null) {\r\n            pre = tmp;\r\n            tmp = tmp.next;\r\n            last = node;\r\n            node = node.next;\r\n        }\r\n        last.next = head;\r\n        pre.next = null;\r\n        return tmp;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842099558","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null) return head;\r\n        ListNode dummyHead = new ListNode();\r\n        dummyHead.next = head;\r\n        ListNode end = dummyHead;\r\n        ListNode pre = dummyHead;\r\n        while (end.next != null) {\r\n            for (int i=0; i<2; i++) {\r\n                end = end.next;\r\n                if (end == null) return dummyHead.next;\r\n            }\r\n            ListNode start = pre.next;\r\n            ListNode next = end.next;\r\n            end.next = null;\r\n            ListNode p = null;\r\n            ListNode node = start;\r\n            while (node != null) {\r\n                ListNode n = node.next;\r\n                node.next = p;\r\n                p = node;\r\n                node = n;\r\n            }\r\n            pre.next = end;\r\n            start.next = next;\r\n            end = start;\r\n            pre = start;\r\n            start = pre.next;\r\n        }\r\n        return dummyHead.next;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843110679","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 思路\r\n用双指针法找到链表中点, 作为根节点, 再递归地用在链表左半部分和右半部分作为左右子树\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return new TreeNode(head.val);\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode pre = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            pre = slow;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        pre.next = null;\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogN)$\r\n- 空间复杂度：$O(logN)$\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845033587","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        if (head.next == null) return null;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        while (fast != null && fast.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) break;\r\n        }\r\n        if (fast == null || fast.next == null) return null;\r\n        ListNode node = head;\r\n        while (node != slow) {\r\n            node = node.next;\r\n            slow = slow.next;\r\n        }\r\n        return node;\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846519165","body":"\r\n## 题目地址(100. 相同的树)\r\n\r\nhttps://leetcode-cn.com/problems/same-tree/\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null && q != null || p != null && q == null) return false;\r\n        if (p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ssxgit":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836641307","body":"# 989. 数组形式的整数加法\r\n主要是需要一个进位的表示，最终要保证三个部分都加完\r\n\r\n## 代码\r\n- 语言：c++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n\r\n        vector<int> res;\r\n\r\n        int carry_bit = 0;\r\n\r\n        int loc = num.size() - 1;\r\n\r\n        while(loc>-1 || k > 0 || carry_bit > 0){\r\n            int num1 = loc>-1?num[loc]:0;\r\n            int num2 = k % 10;\r\n\r\n            int value = num1 + num2 + carry_bit;\r\n\r\n            res.emplace_back((value % 10));\r\n            carry_bit = value / 10; \r\n\r\n            --loc;\r\n            k /= 10;\r\n        }\r\n        \r\n        reverse(res.begin(),res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838312453","body":"# 821. 字符的最短距离\r\n[leetcode 821](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n## 思路：\r\n1. 从左到右遍历保存每一个字符距离其左边最近的字符 c 的 距离\r\n2. 从右到左遍历保存每一个字符距离其右边最近的字符 c 的 距离\r\n3. 取上面两个距离的更小值即可，可以只用一个数组来存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        if(s.empty()) return {};\r\n        vector<int> res(s.size(),INT_MAX);\r\n        int pre_c_loc = -1;\r\n        for(int i=0;i<s.size();++i){\r\n            if(s[i] == c){\r\n                pre_c_loc = i;\r\n                res[i] = 0;\r\n            }\r\n            else if(pre_c_loc != -1) res[i] = i - pre_c_loc;\r\n        }\r\n\r\n        pre_c_loc = s.size();\r\n        for(int i=s.size()-1;i>-1;--i){\r\n            if(s[i] == c) pre_c_loc = i;\r\n            else if(pre_c_loc != s.size()) res[i] = min(res[i],pre_c_loc - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)  //最终需要返回的结果数组不计算复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839728875","body":"# 1381. 设计一个支持增量操作的栈\r\n[leetcode 1381](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n## 思路\r\n1. 最直观的想法就是用可变长数组来模拟\r\n2. 但是这样inc操作的时间复杂度是O(k)\r\n3. 所以要新加一个数组来表示加val,而且只能是一位加,不断往前推\r\n\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    int top;\r\n    vector<int> sta,increase;\r\n    CustomStack(int maxSize) {\r\n        top = -1;\r\n        sta.resize(maxSize);  //resize之后默认全0\r\n        increase.resize(maxSize);\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top < (int)sta.size()-1){   //必须转int,因为size_type是无符号整数\r\n            sta[++top] = x;\r\n        } \r\n    }\r\n    \r\n    int pop() {\r\n        if(top == -1) return -1;\r\n\r\n        if(top > 0) increase[top-1] += increase[top];  //增量往前推\r\n\r\n        int res = sta[top] + increase[top];\r\n        increase[top] = 0;\r\n\r\n        --top;\r\n\r\n        return res;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n       int d = min(k-1,top);\r\n       if(d > -1 && d < (int)sta.size()) increase[d] += val; \r\n       //可能在数组没有元素的时候调用inc\r\n       //可能在数组满的时候调用inc\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n### 复杂度分析\r\n时间复杂度：push:O(1),pop:O(1),inc:O(1)\r\n空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840552440","body":"# 394. 字符串解码\r\n[leetcode 394](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n## 思路: 栈\r\n1. 遍历字符串，字母、数字、左括号直接入栈（变换为字符串）\r\n2. 遇到右括号，一直出栈直到遇到左括号，弹出左括号，按照出栈顺序反向拼接字符串为s1\r\n3. 此时栈顶为数字字符串，即为s1的出现次数t，将s1重复t次，重复后的字符串再入栈\r\n4. 继续上述过程，直到遍历到编码字符串尾部，将栈中字符串弹出，按照出栈顺序反向拼接字符串为r,即为最终答案\r\n5. 这个思路的关键是遇到左括号直接入栈，遇到右括号需要出栈，一直到左括号，将中间的字符串拼接起来\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        vector<string> stk;\r\n        int i=0;\r\n        while(i<s.size()){\r\n            if((s[i]>='a' && s[i]<='z') || s[i] == '['){\r\n                stk.push_back(string(1,s[i]));\r\n                ++i;\r\n            }\r\n            else if(s[i]>='0' && s[i]<='9'){\r\n                stk.push_back(getTime(s,i));\r\n            }\r\n            else{\r\n                string ret;\r\n                vector<string> st_vec;\r\n                while(stk.back() != \"[\"){\r\n                    st_vec.emplace_back(stk.back());stk.pop_back();\r\n                }\r\n                reverse(st_vec.begin(),st_vec.end());  //反向\r\n                string in_st = getString(st_vec); //拼接\r\n                stk.pop_back();\r\n                int times = stoi(stk.back());stk.pop_back();\r\n                while(times--){\r\n                    ret += in_st;\r\n                }\r\n                stk.push_back(ret);\r\n\r\n                ++i;\r\n            }\r\n        }\r\n        for(auto& st:stk){\r\n            res += st;\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    string getTime(const string& s,int& i){\r\n        string times;\r\n        while(s[i]>='0' && s[i]<='9'){\r\n            times.push_back(s[i]);\r\n            ++i;\r\n        }\r\n        return times;\r\n    }\r\n\r\n    string getString(vector<string> str_vector){\r\n        string st;\r\n        for(auto &str:str_vector){\r\n            st += str;\r\n        }\r\n        return st;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(S)  //S为解码后的字符串长度\r\n空间复杂度：O(S) //"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841193008","body":"# 223. 用两个栈实现队列\r\n[leetcode 232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。\r\n\r\n\r\n## 思路\r\n1. 栈先进后出，队列先进先出，那么需要想办法将先进入栈stack1的元素先拿出来\r\n2. 再将其放到另一个栈stack2中，则最前面进去的元素就在stack2的栈顶了，弹出即可\r\n3. 但是需要注意当stack2为空时将stack1的全部元素放到stack2中才行\r\n\r\n### 代码\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> stack1;\r\n    stack<int> stack2;\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stack2.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int res = peek();\r\n        stack1.pop();\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(stack1.empty()){\r\n            while(!stack2.empty()){\r\n                stack1.push(stack2.top());\r\n                stack2.pop();\r\n            }\r\n        }\r\n\r\n        return stack1.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n\r\n        return stack1.empty() && stack2.empty();\r\n\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(1)  //push的复杂度为O(1),pop,peek操作的均摊复杂度为O(1)\r\n空间复杂度：O(n)  //两个栈存储元素 "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841647662","body":"# 768. 最多能完成排序的块 II\r\n\r\n## 思路：\r\n1. 直观来说，就是把数组划分为几个块，使得块之间有序，问最多能划分为几个块\r\n2. 考虑arr[:j]已经生成几个块b[0],b[1],..,b[k],再加入arr[j]之后能有多少个块？\r\n3. 当arr[j]>b[m].max,arr[j] < b[m+1].max, 则b[m+1:k]与arr[j]可以合并成一个块\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        if(arr.empty()) return 0;\r\n\r\n        vector<vector<int> > tmp{{arr[0],arr[0]}};\r\n\r\n        for(int i=1;i<arr.size();++i){\r\n            //可以自成一个块\r\n            if(arr[i] >= tmp.back()[1]) tmp.push_back({arr[i],arr[i]});\r\n            else{\r\n                int minValue = tmp.back()[0],maxValue=tmp.back()[1];\r\n                //一直找到可以合并的块\r\n                while(!tmp.empty() && arr[i] < tmp.back()[1]){\r\n                    minValue = tmp.back()[0];\r\n                    tmp.pop_back();\r\n                }\r\n                minValue  = min(minValue,arr[i]);\r\n                tmp.push_back({minValue,maxValue});\r\n            }\r\n            \r\n        }\r\n\r\n        return tmp.size();\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n) //均摊时间复杂度O(n)\r\n空间复杂度：O(n) "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841794225","body":"# 61. 旋转链表\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 思路\r\n1. 在倒数第k+1个节点与倒数第k个节点处断开\r\n2. 倒数第k+1个节点指向空，最后一个节点指向头节点\r\n3. 但是要考虑各种特征情况\r\n\r\n### 代码\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        //链表没有节点，或者k不合法\r\n        if(head == nullptr || k<0) return nullptr;\r\n        //链表只有一个节点或者k==0,则不需要翻转\r\n        if(head->next == nullptr || k==0) return head;\r\n\r\n        int len = 0;\r\n        ListNode* fast = head;\r\n        while(len < k){       //快指针右移k位\r\n            fast = fast->next;\r\n            ++len;\r\n\r\n            if(fast == nullptr){  //说明k大于链表长度\r\n                k %= len;  //取余数\r\n                if(k == 0) return head;  //说明k是链表长度的倍数，相当于不用翻转\r\n                len = 0;\r\n                fast = head;\r\n            }\r\n        }\r\n\r\n        ListNode* slow = head;  //快慢指针，获取倒数第k+1个节点\r\n        while(fast->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n\r\n        ListNode* newHead = slow->next;\r\n\r\n        slow->next = nullptr;\r\n        fast->next = head;\r\n\r\n        return newHead;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842215810","body":"# 24. 两两交换链表中的节点\r\n(https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n \r\n提示：\r\n- 链表中节点的数目在范围 [0, 100] 内\r\n- 0 <= Node.val <= 100\r\n\r\n\r\n## 思路\r\n1. 递归和迭代\r\n2. 递归时链表节点两两交换，要影响前面节点的指向，所以前面的节点迭代过程中要保存\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n\r\n        //递归\r\n        ListNode* node = head->next;\r\n        head->next = swapPairs(node->next);\r\n        node->next = head;\r\n\r\n        return node;\r\n\r\n    }\r\n};\r\n```\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if(head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n\r\n        //迭代\r\n        ListNode* newHead = head->next;\r\n        ListNode* pre = nullptr;\r\n        while(head != nullptr && head->next != nullptr){\r\n            ListNode* node = head->next;\r\n            head->next = node->next;\r\n            node->next = head;\r\n            \r\n            if(pre != nullptr) pre->next = node;\r\n            pre = head;\r\n\r\n            head = head->next;\r\n        }\r\n\r\n        return newHead;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843235606","body":"# 109. 有序链表转换二叉搜索树\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 思路1：\r\n每次通过快慢指针找中间节点，递归左右链表\r\n\r\n递归深度 O(logn), 每一个搜索O(n)\r\n时间复杂度: $O(nlogn)$\r\n空间复杂度：$O(logn)$\r\n\r\n### 代码\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if(head==nullptr) return nullptr;\r\n        if(head->next==nullptr) return new TreeNode(head->val);\r\n\r\n        ListNode* fast = head->next;\r\n        ListNode* slow = head;   //快慢指针\r\n        while(fast->next!=nullptr && fast->next->next!=nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }  //slow指向中间节点的上一个节点\r\n\r\n        TreeNode* treeHead = new TreeNode(slow->next->val);  //中间节点建立树跟结点\r\n        treeHead->right = sortedListToBST(slow->next->next); //中间节点右边建立平衡二叉树，为根节点右子树\r\n        ListNode* tmp = slow->next;delete tmp;               //删除链表的中间节点\r\n        slow->next = nullptr;                                //中间节点的上一个节点指向为空\r\n        treeHead->left = sortedListToBST(head);              //中间节点左边建立平衡二叉树，为根节点左子树\r\n         \r\n        return treeHead;\r\n    }\r\n};\r\n```\r\n\r\n\r\n## 思路2:\r\n建树过程\r\n```c++\r\nTreeNode* tree = new TreeNode();\r\ntree->left = buildTree(); //建左子树\r\ntree.val=..//这里访问到的就是中序遍历的顺序\r\ntree->right = buildTree(); //建右子树\r\n```\r\n### 代码\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int ListLen = 0;\r\n        ListNode* newHead = head;\r\n        for(;head!=nullptr;++ListLen,head=head->next);\r\n\r\n        return buildTree(newHead,0,ListLen-1);\r\n    }\r\n\r\n    TreeNode* buildTree(ListNode*& head,int left,int right){  //ListNode*& head 关键\r\n        if(left>right) return nullptr;\r\n\r\n        int mid = (left+right) / 2;\r\n\r\n        TreeNode* tree = new TreeNode();          //建树\r\n        tree->left = buildTree(head,left,mid-1);  //建左子树\r\n        tree->val = head->val;                    //中序遍历一直到最左边的叶子节点\r\n        head = head->next;                        //head右移一位\r\n        tree->right = buildTree(head,mid+1,right);  //建右子树\r\n        \r\n        return tree;\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843894869","body":"# 160. 相交链表\r\n(https://leetcode-cn.com/problems/intersection-of-two-linked-lists/submissions/)\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\n\r\n## 思路1：先求长度差距，再找公共节点\r\n1. 两个指针统计链表A和B的长度\r\n2. 两个指针再指向两个链表头部，指向更长的的链表的头部指针先走长度之差步\r\n3. 之后两个指针再一起走，直到两个指针指向同一个节点，即为两个链表相交节点\r\n\r\n### 代码\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA == nullptr || headB == nullptr) return nullptr;\r\n\r\n        int lenA=1,lenB=1;\r\n        ListNode* nodeA=headA,*nodeB=headB;\r\n        while(nodeA->next != nullptr || nodeB->next != nullptr){\r\n            if(nodeA->next != nullptr) ++lenA,nodeA = nodeA->next;\r\n            if(nodeB->next != nullptr) ++lenB,nodeB = nodeB->next;\r\n        }\r\n\r\n        //最后一个节点不相同，说明两个链表不相交\r\n        if(nodeA != nodeB) return nullptr; \r\n        nodeA=headA,nodeB=headB;\r\n\r\n        //长度更长的链表指针先走\r\n        if(lenA > lenB){\r\n            int dis = lenA-lenB;\r\n            for(int i=0;i<dis;++i) nodeA = nodeA->next;\r\n        }\r\n        else{\r\n            int dis = lenB - lenA;\r\n            for(int i=0;i<dis;++i) nodeB = nodeB->next;\r\n        }\r\n\r\n        //一起走\r\n        while(nodeA != nodeB){\r\n            nodeA = nodeA->next;\r\n            nodeB = nodeB->next;\r\n        }\r\n\r\n        return nodeA;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(1)\r\n\r\n## 思路2：指针直接搞定\r\n1. 指针a指向链表A，指针b指向链表B，一起往后走\r\n2. 指针a走到链表A末尾时，记录链表A末尾节点，然后指针a指向链表B头节点\r\n3. 指针b走到链表B末尾时，记录链表B末尾节点，然后指针a指向链表A头节点\r\n4. 当链表A与链表B末尾节点不相同时，说明链表不相交\r\n5. 最终指针a和指针b指向同一个节点，则为两个链表的第一个相交节点\r\n\r\n### 代码\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA == nullptr || headB == nullptr) return nullptr;\r\n\r\n        ListNode* nodeA=headA,*nodeB=headB;\r\n\r\n        ListNode* tailA=nullptr,*tailB=nullptr;\r\n        //一起走\r\n        while(nodeA != nodeB){\r\n            if(nodeA->next == nullptr){\r\n                tailA = nodeA;\r\n                nodeA = headB;\r\n            }\r\n            else nodeA = nodeA->next;\r\n\r\n            if(nodeB->next == nullptr){\r\n                tailB = nodeB;\r\n                nodeB = headA;\r\n            }\r\n            else nodeB = nodeB->next;\r\n\r\n            if(tailA != nullptr && tailB != nullptr && tailA != tailB){\r\n                return nullptr;\r\n            }\r\n        }\r\n\r\n        return nodeA;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(m+n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845044084","body":"# 142 链表中环的入口节点\r\n(https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/)\r\n给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。\r\n\r\n## 思路1： 获取环的长度\r\n#### 1、判断有没有环\r\n快慢指针，一个每次走两步，另一个每次走一步，如果最终能相遇，则链表有环。\r\n最终能够相遇说明有环，那为什么有环一定能相遇呢？\r\n设快慢指针之间相距d，则快指针每次比慢指针多走一步，所以一定能追上\r\n\r\n#### 2、找出环的入口节点\r\n如果有环，快慢指针的交点一定在环中\r\n1. 此交点走一圈，获取一个环中一个点走一圈的步数n\r\n2. 两个指针指向链表头节点,一个指针先走n步，然后两个指针同时以步长1往前走，最终相遇点一定是环入口节点(因为此时两个指针在同一个节点且相距步数为n)\r\n\r\n### 代码\r\n```c++\r\n/*\r\nstruct ListNode {\r\n    int val;\r\n    struct ListNode *next;\r\n    ListNode(int x) :\r\n        val(x), next(NULL) {\r\n    }\r\n};\r\n*/\r\nclass Solution {\r\npublic:\r\n    ListNode* EntryNodeOfLoop(ListNode* pHead)\r\n    {\r\n        if(pHead==nullptr || pHead->next==nullptr) return nullptr;\r\n        ListNode* slow=pHead,*fast=pHead->next; //不一定要一起从头走\r\n        \r\n        while(fast!=slow && fast->next!=nullptr && fast->next->next!=nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        //链表是否有环\r\n        if(fast->next==nullptr || fast->next->next==nullptr) return nullptr;\r\n        \r\n        int nodeInLoop=1;\r\n        ListNode* pileNode = fast;\r\n        while(fast->next!=pileNode){\r\n            fast=fast->next;\r\n            ++nodeInLoop;\r\n        } //回到原点的步数\r\n        \r\n        fast=pHead;\r\n        for(int i=0;i<nodeInLoop;++i) fast = fast->next; //先走n步\r\n        slow = pHead;\r\n        while(slow!=fast){ //再一起走\r\n            slow = slow->next;fast=fast->next;\r\n        }\r\n        return slow; //最终相遇点一定是环的起点\r\n    }\r\n};\r\n```\r\n### 复杂度分析:\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n\r\n## 思路2：利用快慢指针的相遇点\r\n#### 1、如果快慢指针都从头开始走，则:\r\n$$2*(a+k_1n+b)=a+k_2n+b$$\r\na为链表头节点到环入口节点的步数,b为环入口节点到相遇节点的步数,$a+k_1n+b$为慢指针所走的步数，$a+k_2n+b$为快指针所走的步数。\r\n#### 2、推一下公式\r\n$$a+b=(k_2-2*k_1)n$$\r\n说明链表头节点到相遇节点的步数为n的整数倍,此时再让一个指针从链表头节点出发（每次走一步），另一个指针从相遇节点出发（每次走一步），最终两个指针一定在相遇节点在再相遇，由于两个指针走一步，所以最开始相遇的点一定在环入口节点\r\n#### 3、这时再使一个节点从头节点出发,相遇节点也同时出发,最终相遇的节点一定是环入口节点\r\n\r\n### 代码\r\n```c++\r\n/*\r\nstruct ListNode {\r\n    int val;\r\n    struct ListNode *next;\r\n    ListNode(int x) :\r\n        val(x), next(NULL) {\r\n    }\r\n};\r\n*/\r\nclass Solution {\r\npublic:\r\n    ListNode* EntryNodeOfLoop(ListNode* pHead)\r\n    {\r\n        if(pHead==nullptr || pHead->next==nullptr || pHead->next->next==nullptr) return nullptr;\r\n        ListNode* slow=pHead->next,*fast=pHead->next->next;\r\n        //初始化的时候不能把两个指针都初始化为链表头节点\r\n        while(fast!=slow && fast->next!=nullptr && fast->next->next!=nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n        if(fast->next==nullptr || fast->next->next==nullptr) return nullptr;\r\n        \r\n        slow = pHead;\r\n        while(slow!=fast){\r\n            slow = slow->next; fast=fast->next;\r\n        }\r\n        return slow;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析:\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845780775","body":"# 146. LRU 缓存机制\r\n（https://leetcode-cn.com/problems/lru-cache/）\r\n\r\n## 思路：hash表+双向链表\r\n1. hash表O(1)时间取出值\r\n2. 双向链表方便得到某个节点的上一个节点\r\n### 代码\r\n```c++\r\n\r\nclass Node{\r\npublic:\r\n    int key;\r\n    int value;\r\n    Node* pre;\r\n    Node* next;\r\n    Node(int key1,int value1):key(key1),value(value1),pre(nullptr),next(nullptr){}\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    Node* fakeHead;\r\n    Node* fakeTail;\r\n    unordered_map<int,Node*> m;\r\n    int cap;\r\n    LRUCache(int capacity) {\r\n        fakeHead = new Node(-1,-1);\r\n        fakeTail = new Node(-1,-1);\r\n        fakeHead->next = fakeTail;\r\n        fakeTail->pre = fakeHead;\r\n        cap = capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n       if(m.find(key) != m.end()){\r\n           Node* node = m[key];\r\n\r\n           if(fakeHead->next != node){  //不是头\r\n               node->pre->next = node->next; \r\n               node->next->pre = node->pre;\r\n\r\n               put_head(node);  //放到链表头部\r\n           }\r\n           return node->value;\r\n       }\r\n       return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        Node* node;\r\n        if(m.find(key) != m.end()){\r\n           node = m[key];\r\n\r\n           if(fakeHead->next != node){  //不是头\r\n               node->pre->next = node->next;\r\n               node->next->pre = node->pre;\r\n               put_head(node);\r\n           }\r\n           node->value = value;  //更新值\r\n       }\r\n       else{\r\n           if(m.size() == cap){  //到了瓶颈\r\n               Node* tmp = fakeTail->pre;\r\n               tmp->pre->next = fakeTail;\r\n               fakeTail->pre = tmp->pre;\r\n\r\n               m.erase(tmp->key);  //字典中也要删掉，所以节点中要存储key\r\n               delete tmp;\r\n           }\r\n           node = new Node(key,value);\r\n           m[key] = node;\r\n           put_head(node);  //插入头部\r\n       }\r\n    }\r\n\r\n    void put_head(Node* node){\r\n        Node* tmp = fakeHead->next;\r\n        fakeHead->next = node;\r\n        node->pre = fakeHead;\r\n        node->next = tmp;\r\n        tmp->pre = node;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度\r\n1. put O(1)\r\n2. get O(1)\r\n空间复杂度：O(capacity)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846395323","body":"# 104. 二叉树的最大深度\r\n(https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\n## 思路：dfs\r\n1. 根节点为空，深度为0\r\n2. 树深度 = 1 + 根节点左子树深度 + 根节点右子树深度\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(root == nullptr) return 0;\r\n        \r\n        return 1 + max(maxDepth(root->left),maxDepth(root->right));\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846517945","body":"# 100. 相同的树\r\n(https://leetcode-cn.com/problems/same-tree/)\r\n\r\n\r\n## 思路：dfs\r\n1. 判断两棵树是否相同，有三个条件\r\n    1. 根节点是否相同\r\n    2. 左子树是否相同\r\n    3. 右子树是否相同\r\n2. 边界条件考虑根节点是否为空的情况\r\n\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if(p == nullptr && q == nullptr) return true;\r\n        if(p == nullptr || q == nullptr) return false;\r\n\r\n        return p->val == q->val && isSameTree(p->left,q->left) &&\r\n            isSameTree(p->right,q->right);\r\n\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(logn)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenglei110":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644430","body":"python\r\n\r\npython语言的设计就是太动态了，int和str可以互转。\r\n\r\n列表迭代式 + lambda表达式\r\n平时也是这样写，感觉代码很简洁。但是你要问我这样的代码有什么不足，还真答不上来。\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return  list(map(int, str(int(''.join(map(str, num)))+k)))\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839817225","body":"> ### 思路\r\n> 给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n> \r\n> ### 代码\r\n> ```python\r\n> class CustomStack:\r\n> # use array in function makes the each elenments in stack \"visable\"\r\n> \r\n>     def __init__(self, maxSize: int):\r\n>         self.stk = [0]*maxSize\r\n>         self.top = -1\r\n> \r\n>     def push(self, x: int) -> None:\r\n>         # if stack size is smaller than maxSize, push in\r\n>         # maxSize is not defined in this function, so use len of stack instead\r\n>         if self.top < len(self.stk)-1:\r\n>             self.stk[self.top+1] = x\r\n>             self.top += 1\r\n> \r\n>     def pop(self) -> int:\r\n>         # if stack is empty, return -1\r\n>         # if stack is not empty, return the top value and delete it in the stack (no need)\r\n>         if self.top == -1:\r\n>             return -1\r\n>         self.top -= 1\r\n>         return self.stk[self.top + 1]\r\n> \r\n>     def increment(self, k: int, val: int) -> None:\r\n>         # use the minimum value between k and self.stk length, then traverse\r\n>         if k>-1:\r\n>             for i in range(min(self.top+1,k)):\r\n>                 self.stk[i]+=val\r\n> ```\r\n> \r\n> **复杂度分析**\r\n> \r\n> * 时间复杂度：O(min(k, maxSize)),\r\n> * 空间复杂度：O(maxSize)\r\n\r\n跑错场了兄弟"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841953186","body":"### python3\r\n\r\n双指针\r\n\r\n```py\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        pre = ListNode(None)\r\n        pre.next = head\r\n        start = head.next\r\n        while pre.next and pre.next.next:\r\n            a = pre.next\r\n            b = pre.next.next\r\n            # 为了交换后仍能保持最初的状态，处于头指针的前一个\r\n            a.next = b.next\r\n            pre.next = b\r\n            b.next = a\r\n            # 使得pre仍然处于下一个头节点的前一个\r\n            pre = pre.next.next\r\n        return start\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846530484","body":"## python\r\n\r\n递归\r\n```py\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        if not p or not q:\r\n            return False\r\n        \r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1998yyh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836644503","body":"### 思路\r\n循环数组按位相加，同时对应修改k，循环完成后当k大于0，再对k处理。\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const len = num.length;\r\n    const resultArr = [];\r\n    for(let i = len -1; i>=0;i--){\r\n        const _num = k%10;\r\n        k = Math.floor(k/10);\r\n        const sum = _num + num[i];\r\n        if(sum>9){\r\n            k++\r\n        }\r\n        resultArr.unshift(sum%10);\r\n    }\r\n    while(k>0){\r\n        resultArr.unshift(k%10)\r\n        k = Math.floor(k/10);\r\n    }\r\n    return resultArr\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838434616","body":"### 思路\r\n用一个变量保存出现的位置，从左往右，从右往左分别遍历一次，取最小值\r\n### 代码\r\njavascript\r\n``` javascript\r\nvar shortestToChar = function (s, c) {\r\n    let flag = -1;\r\n    const len = s.length;\r\n    const result = new Array(len).fill(Infinity);\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(i - flag, result[i])\r\n        }\r\n    }\r\n    flag = -1;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] !== c && flag < 0) continue;\r\n        if (s[i] === c) {\r\n            result[i] = 0;\r\n            flag = i\r\n        } else {\r\n            result[i] = Math.min(flag - i, result[i])\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839752845","body":"### 思路\r\n### 代码\r\njavascript\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    const len = this.stack.length;\r\n    if(len < this.maxSize){\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const result = this.stack.pop();\r\n    return result || -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len = Math.min(k,this.stack.length);\r\n    for(let i = 0;i < len;i++){\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840577967","body":"### 思路\r\n使用两个栈分别存储数字与字母\r\n### 代码\r\njavascript\r\n```javascript\r\nvar decodeString = function (s) {\r\n    const numStack = [];\r\n    const strStack = [];\r\n    const len = s.length;\r\n    let num = 0;\r\n    let result = '';\r\n    for (let i = 0; i < len; i++) {\r\n        if (!isNaN(s[i])) {\r\n            num = num * 10 + Number(s[i])\r\n        } else if (s[i] === '[') {\r\n            strStack.push(result);\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (s[i] === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        } else {\r\n            result += s[i]\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215878","body":"### 思路\r\n### 代码\r\nJavaScript\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.restack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.restack.length === 0){\r\n        while(this.stack.length){\r\n            this.restack.push(this.stack.pop())\r\n        }\r\n    }\r\n    return this.restack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.restack.length === 0){\r\n        while(this.stack.length){\r\n            this.restack.push(this.stack.pop())\r\n        }\r\n    }\r\n    return this.restack[this.restack.length-1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.restack.length === 0 && this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842316790","body":"### 思路\r\n递归\r\n### 代码\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let nextNode = head.next;\r\n    head.next = swapPairs(nextNode.next);\r\n    nextNode.next = head;\r\n    return nextNode;\r\n};\r\n```\r\n### 复杂度分析\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844179993","body":"### 思路\r\n遍历A 用Set记录 遍历B 查看是否有\r\n### 代码\r\njavascript\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if(headA === null || headB === null ){\r\n        return null\r\n    }\r\n\r\n    const map = new Set();\r\n    while(headA !== null) {\r\n        map.add(headA)\r\n        headA = headA.next\r\n    }\r\n    while(headB !== null) {\r\n        if(map.has(headB)) return headB\r\n        headB = headB.next\r\n    }\r\n\r\n    return null\r\n    \r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)。\r\n空间复杂度：O(n)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845149411","body":"### 思路\r\n### 代码\r\nJavaScript\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    const _set = new Set();\r\n    while(head){\r\n        if(_set.has(head)){\r\n            return head\r\n        }else{\r\n            _set.add(head)\r\n        }\r\n        head = head.next;\r\n    }\r\n    return null\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：o(n)\r\n空间复杂度：o(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846402172","body":"### 思路\r\n树的层序遍历\r\n### 代码\r\nJavaScript\r\n``` javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function (root) {\r\n    if (!root) return 0\r\n    let len = 0;\r\n    const stack = [root];\r\n    while (stack.length) {\r\n        const curlen = stack.length;\r\n        for (let i = 0; i < curlen; i++) {\r\n            const node = stack.shift();\r\n            node.left && stack.push(node.left)\r\n            node.right && stack.push(node.right)\r\n        }\r\n        len++\r\n    }\r\n    return len\r\n};\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836661706","body":"# 思路\r\n先将k转成数组，再利用双指针分别从k和num的最后一位开始按位计算。注：需要考虑最后一次进位的情况。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=989 lang=javascript\r\n *\r\n * [989] 数组形式的整数加法\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  const kArr = (k + '').split('')\r\n  const ret = []\r\n\r\n  let i = num.length - 1\r\n  let j = kArr.length - 1\r\n  let tmp = 0\r\n  while (i >= 0 || j >= 0 || tmp) {\r\n    const count = parseInt(num[i] || 0) + parseInt(kArr[j] || 0) + tmp\r\n    ret.unshift(count % 10)\r\n    tmp = parseInt(count / 10)\r\n    i--\r\n    j--\r\n  }\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(max(n, log k))，其中 n 为数组的长度。log k为k的位，即log 10(k)，10为底k的对数。\r\n空间复杂度：O(max(n, log k))。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838475940","body":"# 思路\r\n通过字符串正反向遍历，从两种方式中找到最接近的值。\r\n- 注：正反向遍历时，默认值都为正无穷大\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=821 lang=javascript\r\n *\r\n * [821] 字符的最短距离\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const ret = []\r\n  let near = Infinity\r\n  // 从左到右，记录距离\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      ret.push(0)\r\n      near = 0\r\n    } else {\r\n      ret.push(++near)\r\n    }\r\n  }\r\n\r\n  // 从右到左了，要将距离设为正无穷大\r\n  near = Infinity\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    const char = s[i]\r\n    if (char === c) {\r\n      near = 0\r\n    } else {\r\n      // 比较当前值和右到左的距离，取最小的那个\r\n      ret[i] = Math.min(ret[i], ++near)\r\n    }\r\n  }\r\n\r\n  return ret\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了两次字符串\r\n\r\n空间复杂度：O(n)，结果跟字符串长度一样"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839821696","body":"# 思路\r\n- push方法要限制超过长度时不入栈\r\n- pop方法为了让所有操作都为O(1)的话，在出栈时再进行增加操作\r\n  - 出栈时要取出对应的增加值，并与栈顶值相加\r\n  - 由于数据出栈了，对应位置的加值无用，故对应位置的加值设为0，即默认值\r\n  - 由于inc方法的k是指栈底的 k 个元素，故此时下一位的加值要加上此次取出的加值，inc方法是栈底k个元素都增加val。\r\n- increment方法在对应的位置累加上加值即可 O(1)\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=1381 lang=javascript\r\n *\r\n * [1381] 设计一个支持增量操作的栈\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.size = maxSize\r\n  this.stack = []\r\n  this.add = []\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 方法一\r\n  // return this.stack.pop() || -1\r\n\r\n  // 方法二\r\n  const len = this.stack.length\r\n  if (len === 0) {\r\n    return -1\r\n  }\r\n\r\n  const add = this.add[len] || 0\r\n  // 由于只记录当前栈顶的增加值\r\n  // 故要更新下一个栈顶\r\n  this.add[len - 1] = this.add[len - 1] || 0\r\n  this.add[len - 1] += add\r\n  // 出栈后，对应位置的增加值无用，重置为0\r\n  this.add[len] = 0\r\n\r\n  const curr = this.stack.pop()\r\n\r\n  return curr + add\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  // 方法一\r\n  // const len = Math.min(this.stack.length, k)\r\n  // for (let i = 0; i < len; i++) {\r\n  //   this.stack[i] += val\r\n  // }\r\n\r\n  // 方法二\r\n  const index = Math.min(this.stack.length, k)\r\n  this.add[index] = this.add[index] || 0\r\n  this.add[index] += val\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(1)，三个方法都是O(1)\r\n\r\n空间复杂度：O(n)，一个栈空间和一个加值存放空间，两个都是n的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840560534","body":"# 思路\r\n- 使用栈来存放最终的输出的内容\r\n- 遍历字符串\r\n  - 当非]右括号时，直接入栈\r\n  - 当遇到]右括号时，开始出栈，直到遇到[左括号。此时的子字符串是要重复的字符串\r\n  - 继续出栈，取重复次数的数值，考虑到大于9的情况，需要不断取栈的值并判断是否为数字\r\n  - 由于栈是最终的结果，再加上需要考虑2[3[ab]]嵌套括号的情况，故待重复的子字符串在组合后，要重新入栈中\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let result = ''\r\n  const stack = []\r\n  for (let i = 0; i < s.length; i++) {\r\n    const char = s[i]\r\n    if (char !== ']') {\r\n      stack.push(char)\r\n      continue\r\n    }\r\n\r\n    // 当是]时\r\n    let prev = stack.pop()\r\n    let subStr = ''\r\n    // 找到[]里面的字符串\r\n    while (prev !== '[') {\r\n      subStr = prev + subStr\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 继续往前找数字\r\n    let num = ''\r\n    prev = stack.pop()\r\n    while (!Number.isNaN(Number(prev))) {\r\n      num = prev + num\r\n      prev = stack.pop()\r\n    }\r\n\r\n    // 上面先出栈一个字符，再判断是否为数字，会多取一个字符了。\r\n    stack.push(prev)\r\n    // 经过上面解开一个[]括号后，将拼接好字符串，重新入栈\r\n    stack.push(subStr.repeat(Number(num)))\r\n  }\r\n  return stack.join('')\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只遍历了一次字符串，当中可能涉及出栈的操作\r\n\r\n空间复杂度：O(n)，只用一个栈来存放最终的结果，当中有重复的字符串，最终是大于s.length"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841256843","body":"# 思路\r\n使用双栈，在push方法时，将数据反序再插入，即存放数据的栈出栈放入另一个栈实现反序，最后还原原来的顺序。\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=232 lang=javascript\r\n *\r\n * [232] 用栈实现队列\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.stack = []\r\n  this.helpStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue.\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  let cur = null;\r\n  while ((cur = this.stack.pop())) {\r\n    this.helpStack.push(cur)\r\n  }\r\n  this.helpStack.push(x)\r\n\r\n  while ((cur = this.helpStack.pop())) {\r\n    this.stack.push(cur)\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of the queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  return this.stack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，在push方法需要全部出栈入栈，故为O(n)，其他都是O(1)\r\n\r\n空间复杂度：O(n)，两个栈，但是同时只有一个栈不为空"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665160","body":"# 思路\r\n- 滑动窗口\r\n- 一段区间内，若原数组的总和与排序后的数组的总和相等，则说明该区间排序后所在的位置与全部排序后相对应\r\n- 判断可以分块后，故要将重新保持一致，找下一个分块\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=768 lang=javascript\r\n *\r\n * [768] 最多能完成排序的块 II\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  const sortArr = [...arr].sort((a, b) => a - b)\r\n  let sum1 = 0\r\n  let sum2 = 0\r\n  let count = 0\r\n  for (let i = 0; i < arr.length; i++) {\r\n    // 判断原数组与排序后的数组的总和是否一样\r\n    sum1 += arr[i]\r\n    sum2 += sortArr[i]\r\n    // 若一样，则说明当前区间可以排序最终的结果，可以分块\r\n    if (sum1 === sum2) {\r\n      count += 1\r\n      // 由于已经分块，故要将重新保持一致，找下一个分块\r\n      // 其实两个结果都相等才能成立分块，已经保持一致了，下面的可不用置零\r\n      // 考虑到可以溢出的问题，建议设置为零\r\n      sum1 = 0\r\n      sum2 = 0\r\n    }\r\n  }\r\n  return count\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(NlogN)，只遍历一次数组，但是数组的排序更加耗时，数组排序大概是O(NlogN)\r\n\r\n空间复杂度：O(N)，用了三个变量，还有存放排序后的数组，故为O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841818880","body":"# 思路\r\n- 先遍历链表求出链表的长度\r\n- 将链表首尾相连成环，再移动相应的位置\r\n- 在k小于len时，实际移动的次数为len - k次\r\n  - 但k有可能大于len，此时可以减少不必要的移动，真实的k可以为k % len，故为len - k % len次\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=61 lang=javascript\r\n *\r\n * [61] 旋转链表\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if (k === 0 || !head || !head.next) {\r\n    return head\r\n  }\r\n\r\n  let tail = head\r\n  let count = 1\r\n  while (tail.next) {\r\n    tail = tail.next\r\n    count++\r\n  }\r\n\r\n  tail.next = head\r\n\r\n  let remain = count - k % count\r\n  while (remain) {\r\n    tail = tail.next\r\n    remain--\r\n  }\r\n\r\n  head = tail.next\r\n  tail.next = null\r\n  return head\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，必须先遍历一次链表算出长度，正常情况下，只需要移动 len - k % len。最坏情况下，要遍历两次。\r\n\r\n空间复杂度：O(1)，只需要常数的空间的变量"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842300310","body":"# 思路\r\n- 当链表不足两个节点时，不用互换\r\n- 用一个新链表来记录转换的结果，默认头部为空节点。同时需要用一个变量指向尾节点。\r\n- 判断是否区间是否有两个节点\r\n  - 有则进行互换\r\n  - 互换后，将新节点连接到新链表上（即与上次的结果相连接）\r\n  - 移动新链表的指向到尾节点（方便于将新结果连接上次的结果）\r\n  - 下移到下一个区间\r\n- 当不足两个节点时，将剩余的节点连接到新链表上\r\n- 返回转换好的新链表\r\n\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=24 lang=javascript\r\n *\r\n * [24] 两两交换链表中的节点\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next) {\r\n    return head;\r\n  }\r\n\r\n  const res = new ListNode()\r\n  let curr = res\r\n  while (head && head.next) {\r\n    // switch\r\n    const newHead = head.next\r\n    head.next = newHead.next\r\n    newHead.next = head\r\n\r\n    // 把新链表连上新的头节点\r\n    curr.next = newHead\r\n    // 移动到尾节点\r\n    curr = head\r\n    // 尾节点下移，即进入下一个两两相交的区间\r\n    head = head.next\r\n  }\r\n\r\n  // 最后剩下一个元素时，直接保持原来的位置连接起来\r\n  curr.next = head\r\n  return res.next\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，只需要遍历一次链表\r\n\r\n空间复杂度：O(1)，只需要常数的空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843194635","body":"# 思路\r\n- 链表已经按升序排序\r\n- 最终结果是二叉搜索树\r\n  - 二叉搜索树的定义是，根节点>=左节点，根节点<=右节点\r\n- 获取当前链表的中点\r\n- 以链表中点为根\r\n- 中点左边的值都小于等于它，可以构造左子树\r\n- 中点右边的值都大于等于它，构造右子树\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=109 lang=javascript\r\n *\r\n * [109] 有序链表转换二叉搜索树\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n  // 用数组缓存所有节点，达到O(1)的时间算出中间节点\r\n  const treeArr = []\r\n  while (head) {\r\n    treeArr.push(head)\r\n    head = head.next\r\n  }\r\n\r\n  return buildTree(treeArr)\r\n};\r\n\r\nfunction buildTree (list) {\r\n  // 由于链表已经按升序排序\r\n  // 同时最后生成的树是二叉搜索树\r\n  // 二叉搜索树的定义是，根节点>=左节点，根节点<=右节点\r\n  // 故每次取中间节点\r\n  const mid = Math.trunc(list.length / 2)\r\n\r\n  if (!list[mid]) {\r\n    return null\r\n  }\r\n  const root = new TreeNode(list[mid].val)\r\n\r\n  root.left = buildTree(list.slice(0, mid))\r\n  root.right = buildTree(list.slice(mid + 1))\r\n\r\n  return root\r\n}\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，每次只处理一个节点，由于用数组缓存了节点，一个节点处理时间为O(1)，但有n个节点，故为O(n)\r\n\r\n空间复杂度：O(n)，需要用数组来存放所有节点"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843636022","body":"# 思路\r\n- 当不相交部分的长度一样时，故两个指针同时前进，最终相遇\r\n- 当不相交部分的长度不一致时，可使用双指针消除不相交部分的长度差\r\n  - 两指针分别从a,b链表头节点开始，同时前进\r\n  - 当有一个指针走到尾节点时，改成指向另一个链表\r\n  - 当两个指针都进行了交换时，此时链表的长度差消除\r\n  - 即可以当成不相交部分长度一致了，同时前进最终会相遇\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=160 lang=javascript\r\n *\r\n * [160] 相交链表\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n  if (!headA || !headB) {\r\n    return null\r\n  }\r\n\r\n  let pA = headA\r\n  let pB = headB\r\n  // 当不相交部分的长度一样时，故两个指针同时前进，最终相遇\r\n  // 通过双指针消除不相交部分的长度差\r\n  // 当两个指针都交换后，必然存在a + c + b === b + c + a (c是相交部分，a, b分别是不相交部分)\r\n  // 当A、B指针都交换后，此时长度差消除了\r\n  while (pA !== pB) {\r\n    if (!pA) {\r\n      pA = headB\r\n    } else {\r\n      pA = pA.next\r\n    }\r\n\r\n    if (!pB) {\r\n      pB = headA\r\n    } else {\r\n      pB = pB.next\r\n    }\r\n  }\r\n\r\n  return pA\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，每个链表最多被遍历两次，即2*n次，n = lenA + lenB\r\n\r\n空间复杂度：O(1)，只用了常数空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845174825","body":"# 思路\r\n- 双指针的方法\r\n- 首先要判断是否链表有环\r\n- 当链表有环时，两个指针会在环内相遇\r\n- 存在环外长度 = 相遇点到入环点长度 + n次环的长度\r\n- 因此，相遇后将另一个指针重新从表头部走，最终将再入环点相遇\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=160 lang=javascript\r\n *\r\n * [160] 相交链表\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  let slow = head\r\n  let fast = head\r\n  while (fast && fast.next && fast.next.next) {\r\n    slow = slow.next\r\n    fast = fast.next.next\r\n\r\n    // 找到相遇点，但是相遇点不一定是入环点\r\n    if (slow === fast) {\r\n      // 找入环点\r\n      // 入环点的寻找思路，由于fast是slow的两倍速度\r\n      // fast: a+n(b+c)+b = a+(n+1)b+nc\r\n      // slow: a+b\r\n      // a+(n+1)b+nc = 2(a+b) ⟹ a = c+(n−1)(b+c)\r\n      // 此时，相遇点到入环点的距离(c) + n-1 圈的环长(b+c)等于链表开头到入环点(a)\r\n      // 因此，一个指针重新走a的长度，另一个指针在相遇点开始走，最后c走完后，就是到了入环点\r\n\r\n      // 令一个指向头部\r\n      slow = head\r\n\r\n      // 由于相遇点与入环点的距离是等于环外路径，\r\n      // 相等时说明节点也入环点\r\n      while (slow !== fast) {\r\n        slow = slow.next\r\n        fast = fast.next\r\n      }\r\n\r\n      return slow\r\n    }\r\n  }\r\n\r\n  return null\r\n};\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，对于慢指针，走a+b到相遇点，后面再走c到入环点，刚好把整个链表走完\r\n\r\n空间复杂度：O(1)，只用了两个指针空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845942643","body":"# 思路\r\n- 数据结构选择\r\n  - 要保持一定的顺序，则使用数组或者链表来存数据\r\n  - 对数据要频繁的增删，且时间要求O(1)，则使用链表\r\n  - 对数据进行读取时, 且时间复杂度 O(1)，则使用哈希表\r\n- 数据结构使用\r\n  - 双向链表：用于控制数据根据使用近远来排序，最近使用的在头部，很久未使用的在尾部\r\n  - 哈希表：用于存放值和所在链表的位置\r\n- 算法步骤\r\n  - get：判断哈希表是否有key了，有的话，返回值并修改数据的排序\r\n  - put：判断是否有key，有key更新值。无key超过存放大小时，要先删除尾部节点。最后两种情况都要更新节点的排序。\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=146 lang=javascript\r\n *\r\n * [146] LRU 缓存机制\r\n */\r\n\r\n// @lc code=start\r\nfunction ListNode(key, val) {\r\n  this.key = key;\r\n  this.val = val;\r\n  this.pre = this.next = null;\r\n}\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.max = capacity\r\n  this.size = 0\r\n  // 同时需要对数据进行频繁的增删, 时间复杂度 O(1) ==> 使用链表等\r\n  // 对数据进行读取时, 时间复杂度 O(1) ===> 使用哈希表\r\n  // 双向链表按最后一次访问的时间的顺序进行排列, 链表头部为最近访问的节点\r\n  this.map = {}\r\n\r\n  this.head = new ListNode()\r\n  this.tail = new ListNode()\r\n  this.head.next = this.tail\r\n  this.tail.next = this.head\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if (this.map[key]) {\r\n    const node = this.map[key]\r\n    this.removeNode(node)\r\n    this.appendHead(node)\r\n    return node.val\r\n  } else {\r\n    return -1\r\n  }\r\n};\r\n\r\n/**\r\n * @param {number} key\r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node\r\n  if (this.map[key]) {\r\n    node = this.map[key]\r\n    this.removeNode(node)\r\n    node.val = value\r\n  } else {\r\n    node = new ListNode(key, value)\r\n    this.map[key] = node\r\n    if (this.size < this.max) {\r\n      this.size++\r\n    } else {\r\n      key = this.removeTail()\r\n      delete this.map[key]\r\n    }\r\n  }\r\n\r\n  this.appendHead(node)\r\n};\r\n\r\n\r\nLRUCache.prototype.removeNode = function(node) {\r\n  const pre = node.pre\r\n  const next = node.next\r\n  pre.next = next\r\n  next.pre = pre\r\n};\r\n\r\nLRUCache.prototype.appendHead = function(node) {\r\n  const first = this.head.next\r\n  this.head.next = node\r\n  node.pre = this.head\r\n  node.next = first\r\n  first.pre = node\r\n};\r\n\r\nLRUCache.prototype.removeTail = function() {\r\n  const key = this.tail.pre.key\r\n  this.removeNode(this.tail.pre)\r\n  return key\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n// @lc code=end\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(1)，get和put方法都为O(1)\r\n\r\n空间复杂度：O(n)，双向链表空间+哈希表空间，双向链表是n+2(头尾节点)，哈希表是n，即2n+2，故为O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846354463","body":"# 思路\r\n- 使用广度优先遍历\r\n- 在遍历时，进入下一层，深度+1，\r\n- 然后整一层遍历，一层遍历完后，重新进入下一层，重复到队列为空\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=104 lang=javascript\r\n *\r\n * [104] 二叉树的最大深度\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  let depth = 0\r\n  const queue = []\r\n  // 有节点才入队列\r\n  if (root) queue.push(root)\r\n  while (queue.length) {\r\n    depth++\r\n    // 一次整层判断\r\n    const len = queue.length\r\n    for (let i = 0; i < len; i++) {\r\n      // 边删除边判断是否有下一层\r\n      const node =  queue.shift()\r\n      if (node.left) queue.push(node.left)\r\n      if (node.right) queue.push(node.right)\r\n    }\r\n  }\r\n\r\n  return depth\r\n};\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，每一层全部节点都要判断一下是否有下一层节点\r\n\r\n空间复杂度：O(n)，最大的时候，空间占用是n个节点"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846491500","body":"# 思路\r\n- 递归遍历判断\r\n- 当前节点是否都为空或者值相等，若成立，则同时比较下一层次的\r\n- 重复判断直至不相等或者树全部遍历时，结束\r\n# 代码\r\njavascript\r\n\r\n```javascript\r\n/*\r\n * @lc app=leetcode.cn id=100 lang=javascript\r\n *\r\n * [100] 相同的树\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n  if (!p && !q) {\r\n    return true\r\n  }\r\n  if (p && q && p.val === q.val) {\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n  }\r\n\r\n  return false\r\n};\r\n// @lc code=end\r\n\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O(n)，每个节点都需要比较\r\n\r\n空间复杂度：O(h)，空间主要是递归调用栈花费了空间，空间为树的深度，这里的h是两树的最小深度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836666773","body":"## 思路\r\n遍历数组， 因为知道在第i位 数等于 i* 10**(len(num)-1) 可以得到数组的和。分解成数组形式时，可以用python的特性转换int 和 str，也可以使用whole divde 和 modulo 一位一位得分别append 到 数组中。这里使用了第一种方法\r\n## 代码\r\nPython\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        leng = len(num)\r\n        sum = 0\r\n        for i in num:\r\n            sum += i* 10**(leng-1)\r\n            leng-=1\r\n        return [int(i) for i in str(sum+k)]\r\n```\r\n### 复杂度分析\r\n时间：O(n)\r\n空间：O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840323210","body":"## 思路：\r\n先声明一个 array of infinity，从左向右遍历，用prev记录c出现的index，即每个元素等于curr-prev。再从右向左遍历，用nex 记录c出现的index， 即每个元素等于min(output[curr], next-curr)\r\n## 复杂度：\r\nO(n) 时间，空间\r\n## 代码：\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        output = [float(\"inf\")] * len(s)\r\n        prev = float(\"-inf\")\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                output[i] = 0\r\n                prev = i\r\n            else:\r\n                output[i] = i-prev\r\n        \r\n        j = len(s)-1\r\n        nex = float(\"inf\")\r\n        while j >=0:\r\n            if s[j] == c:\r\n                nex = j\r\n            else:\r\n                if nex-j < output[j]:\r\n                    output[j] = nex-j \r\n            j-=1\r\n        return output\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657658","body":"## 思路\r\n辅助栈，自己想了好久，感觉到了应该使用 递归和 辅助栈，但是具体操作不太会，参考了力扣题解第一篇：\r\nstack 储存前缀的其他字母和本次res 需要重复的次数，遇到\"]\" 即 开始 更新 res\r\n## 复杂度\r\n空间复杂度： O(N)\r\n时间复杂度：O(N)\r\n## Code\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # stack is used to remember the nested relation \r\n        stack = []\r\n        res = \"\"\r\n        multi = \"\"\r\n        for i in range(0, len(s)):\r\n            if s[i] == \"[\":\r\n                stack.append((res, multi))\r\n                res = \"\"\r\n                multi = \"\"\r\n            elif \"0\" <= s[i] <= \"9\":\r\n                multi += s[i]\r\n            elif \"a\" <= s[i] <= \"z\" or \"A\" <= s[i] <= \"Z\":\r\n                res += s[i]\r\n            elif s[i] == ']':\r\n                (last_res, last_multi) = stack.pop()\r\n                res = last_res + int(last_multi)*res\r\n        return res\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840991023","body":"## 思路：\r\n一开始自己想的时候用了一个时间空间都为O(N) 的方式，即每次push 都需要使用一个辅助栈，pop，peek 都为 O(1)。看了热评思路，知道了所有代码可以达到 amortized O(1)。每次push element 只需要push到 辅助栈，**pop时，因为我们不care 后面来的 element （因为 FIFO)， 我们只需要return 已经 push 到主栈 的top element （主栈的顺序是 我们想达到的FIFO)**，只有当主栈为空时，我们就可以通过辅助栈更新主栈。 peek 类似\r\n\r\n## Code：\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outStack:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n        return self.outStack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return True if not self.outStack and not self.inStack else False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n## Time Complexity:\r\npeek, pop: amortized O(1)\r\npush: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841635629","body":"## 思路一：\r\n如果所有这个块后面的数都大于块的最大数head，即块成立\r\n参考了高赞题解的思路一：遍历arr，初始化window 为一个element，判断每个块是否成立； 如果不成立则右扩window，如果成立则count+=1 并右移window\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        p1,p2 = 0,0\r\n        count = 0\r\n        while p2 < len(arr):\r\n            head = max(arr[p1:p2+1])\r\n            if p2 == len(arr) -1:        # window reaches the last element, it must be a valid block\r\n                count+=1\r\n                p2+=1\r\n            for j in range(p2+1, len(arr)):\r\n\r\n                if j == len(arr) -1 and arr[j] >= head:\r\n                    p1,p2 = p2+1, p2+1\r\n                    count += 1\r\n                elif arr[j]<head:\r\n                    p2+=1\r\n                    break\r\n        return count\r\n```\r\n时间O(N^2) 空间O(1)\r\n\r\n## 思路2：\r\n参考了高赞题解的思路二：排序块的成立只需要使用到head，那我们可以利用栈来记录可能的排序块的head，遍历所有元素，如果当前数字大于等于栈顶，则说明当前数字对上一个块没有影响，单独push这个数字入栈。 如果当前数字小于栈顶，说明当前数字对当前栈顶 块有影响，先pop出这个块的head（先pop并标记为head是为了记忆更新后的块的最大值也会为 head，这个head 一定是更新后的块的最大值），再遍历pop出会被当前数字影响的head，即pop 意味着 块的合并，当块再也不能被合并时（即当前数字大于栈顶head 时），说明当前栈顶不会被当前数字给影响，就再次push 记忆的head。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        i = 0\r\n        stack = []\r\n        while i < len(arr):\r\n            # arr[i] has no impact on the block\r\n            if (not stack) or (arr[i] >= stack[-1]):\r\n                stack.append(arr[i])\r\n            # arr[i] has impact\r\n            elif stack and arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                # determine where does this arr[i] will impact\r\n                # this will ends when arr[i] >= stack[-1]: which means no further impact\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n\r\n        return len(stack)\r\n```\r\n## 复杂度\r\n时间 O(n) 因为只需要遍历一次array\r\n空间 O(n)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844239604","body":"## 思路 使用了 哈希表的方法\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        theSet = set()\r\n        while headA:\r\n            theSet.add(headA)\r\n            headA=headA.next\r\n        while headB:\r\n            if headB in theSet:\r\n                return headB\r\n            headB=headB.next\r\n        return None\r\n```\r\n时间 O(m+n), 空间 O(m)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wonderful1234":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836682410","body":"解题思路：数组的末尾与k的末尾相加，分别求出进位与余数。\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n    int carry = 0;  \r\n    int len = num.length - 1;\r\n\r\n    while (len >= 0 || k != 0) {\r\n        int sum = 0;\r\n        if (len >= 0) {\r\n            sum += num[len];\r\n            len--;\r\n        }\r\n        sum += k % 10 + carry;\r\n        carry = sum / 10;\r\n        list.add(sum % 10);\r\n       k /= 10;\r\n    }\r\n\r\n    if (carry == 1) {\r\n        list.add(carry);\r\n    }\r\n    Collections.reverse(list);\r\n    return list;\r\n\r\n    }\r\n}`\r\n复杂度分析：\r\n时间：O(n)\r\n空间：O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838630501","body":"思路：定义两个数组，分别用于记录正序与倒序遍历字符串 S 时，各元素与字符元素 C 之间的距离，最后将两个数组进行比较，取最小值。\r\n`public static int[] shortestToChar(String S, char C) {\r\n    int[] ascArr = new int[S.length()];\r\n    int[] descArr = new int[S.length()];\r\n\r\n    char[] sarr = S.toCharArray();\r\n    int count = sarr.length;\r\n\r\n    for (int i = 0; i < sarr.length; i++) {\r\n        if (sarr[i] == C) {\r\n            ascArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            ascArr[i] = ++count;\r\n        }\r\n    }\r\n    count = sarr.length;\r\n    for (int i = sarr.length - 1; i >= 0; i--) {\r\n        if (sarr[i] == C) {\r\n            descArr[i] = 0;\r\n            count = 0;\r\n        } else {\r\n            descArr[i] = ++count;\r\n        }\r\n    }\r\n    for (int i = 0; i < ascArr.length; i++) {\r\n        ascArr[i] = Math.min(ascArr[i], descArr[i]);\r\n    }\r\n    return ascArr;\r\n}`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839872956","body":"思路：利用数组来进行操作。\r\n`class CustomStack {\r\n    int idx = 0, s, count = 0, v, i;\r\n    vector<int> a;\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        a.resize(maxSize);\r\n        s = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(count < s)\r\n        {\r\n            a[idx++] = x;\r\n            count++;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(count)\r\n        {\r\n            v = a[idx-1];\r\n            idx--;\r\n            count--;\r\n            return v;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k, count);\r\n        for(i = 0; i < k; ++i)\r\n            a[i] += val;\r\n    }\r\n};\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840622862","body":"  思路：将[]之间的字符串存储在字符串栈中，将数字存储在数字栈中，当遇到]时，出栈。\r\n`class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string t = \"\";\r\n        stack<int> s_num;\r\n        stack<string> s_str;\r\n        int cnt = 0;\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                cnt = 10 * cnt + s[i] - '0';\r\n            } else if (s[i] == '[') {\r\n                s_num.push(cnt);\r\n                s_str.push(t);\r\n                cnt = 0; t.clear();\r\n            } else if (s[i] == ']') {\r\n                int k = s_num.top(); s_num.pop();\r\n                for (int j = 0; j < k; ++j) s_str.top() += t;\r\n                t = s_str.top(); s_str.pop();\r\n            } else {\r\n                t += s[i];\r\n            }\r\n        }\r\n        return s_str.empty() ? t : s_str.top();\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841294438","body":"思路：利用两个栈来实现，一个栈为输入栈，一个为中间栈，进栈时，直接加入到输入栈，出栈时，把输入栈中的数据加入到中间栈，然后再还原输入栈。访问队首元素时，与出栈相同。\r\n`class MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n     stack<int> s1;\r\n     stack<int> s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while (!s1.empty())\r\n        {\r\n            int temp = s1.top();\r\n            s1.pop();\r\n            s2.push(temp);\r\n        }\r\n        int result = s2.top();\r\n        s2.pop();\r\n        while (!s2.empty())\r\n        {\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            s1.push(temp);\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while (!s1.empty())\r\n        {\r\n            int temp = s1.top();\r\n            s1.pop();\r\n            s2.push(temp);\r\n        }\r\n        int result = s2.top();\r\n        while (!s2.empty())\r\n        {\r\n            int temp = s2.top();\r\n            s2.pop();\r\n            s1.push(temp);\r\n        }\r\n        return result;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n         if (!s1.empty())\r\n        {\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return true;\r\n        }\r\n\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(1)\r\n时间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841684154","body":"思路：如果遇到比当前栈元素大的值，那么可以直接入栈，但是如果遇到比当前栈顶元素小的值，那么应该将之前的元素依次出栈，直到遇到小于等于该值的元素停止出栈，然后将max再push入栈。利用单调栈。\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        int max = arr[0];\r\n\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] < max) {\r\n                while (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            } else {\r\n                stack.push(arr[i]);\r\n                max = stack.peek();\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n    }\r\n}\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841825315","body":"思路：先遍历整个链表获得链表长度n，然后此时把链表头和尾链接起来，再往后走n - k % n个节点就到达新链表的头结点前一个点，这时断开链表即可。\r\n`class Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (!head)\r\n        { return NULL;}\r\n       int n = 1;\r\n         ListNode *cur = head;\r\n          while (cur->next) {\r\n              ++n;\r\n              cur = cur->next;\r\n         }\r\n         cur->next = head;\r\n         int m = n - k % n;\r\n         for (int i = 0; i < m; ++i) {\r\n             cur = cur->next;\r\n         }\r\n         ListNode *newhead = cur->next;\r\n         cur->next = NULL;\r\n         return newhead;\r\n\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842164330","body":"思路：交换前面的两个节点，首先要连接1和3节点，之后再进行节点交换。\r\n`class Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n         if(!head || !head->next)   return head;\r\n        ListNode* dummy = new ListNode(-1),*pre = dummy;\r\n        dummy->next = head;\r\n        while(pre->next && pre->next->next){\r\n            ListNode*t = pre->next->next;\r\n            pre->next->next = t->next;\r\n            t->next = pre->next;\r\n            pre->next = t;\r\n            pre = t->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843270707","body":"思想：将有序链表转换为数组去查找中心点。\r\n`class Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<int>v;\r\n        while(head!=nullptr)\r\n        {\r\n            v.push_back(head->val);\r\n            head=head->next;\r\n        }\r\n        return buildTree(v,0,v.size());\r\n    }\r\n    TreeNode*buildTree(vector<int>&v,int begin,int end)\r\n    {\r\n        if(begin==end) return nullptr;\r\n        int mid=(begin+end)/2;\r\n        TreeNode*root=new TreeNode(v[mid]);\r\n        root->left=buildTree(v,begin,mid);\r\n        root->right=buildTree(v,mid+1,end);\r\n        return root;\r\n    }\r\n};\r\n`\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844088033","body":"思路：A+B和B+A是一样大，A链表遍历完后，遍历B链表；B链表遍历完后，遍历A链表。\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL)\r\n            return NULL;\r\n        ListNode *pa=headA;\r\n         ListNode *pb=headB;\r\n        while(pa!=pb)\r\n        {\r\n            pa = pa == NULL ? headB : pa->next;\r\n            pb = pb== NULL ? headA : pb->next;\r\n        }\r\n        return pa;\r\n        \r\n    }\r\n};\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845193761","body":"思路：设定一个快慢指针，慢指针每次往前走一格，快指针每次往前走2格，如果快指针遇到null的话，则表示无环，如果快指针和慢指针相等的话，则表示有环。\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slow = head, *fast = head;\r\n        while (fast && fast -> next) {        //判断是否有环\r\n            slow = slow -> next;\r\n            fast = fast -> next -> next;\r\n            if (slow == fast) {                //找环的起点\r\n                ListNode *ret = head;\r\n                while (ret != slow) {\r\n                    ret = ret -> next;\r\n                    slow = slow -> next;\r\n                }\r\n                return ret;\r\n            }\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846037482","body":"思路：用一个链表记录当前缓存中所有的键值对，并且每次新来的访问都对链表进行重新调整，把最近访问的键值对放到链表头部。然后为了快速访问缓存中的值，维护一个map，key是实际数据的key，对应的value指向该key在链表中的位置节点，这样每次添加键值对时，先判断map中是否有该key，若有则修改链表中对应节点的value；若没有则把该键值对添加到链表头部，去除链表尾部超过规定长度的节点，并在map中添加key以及对应的链表节点指针。\r\nclass LRUCache {\r\n public:\r\n     LRUCache(int capacity) {\r\n       size = capacity;\r\n     }\r\n    \r\n    int get(int key) {\r\n        auto it = hash.find(key);\r\n        if(it == hash.end()) return -1;\r\n        cache.splice(cache.begin(), cache, it->second);\r\n        return it->second->second;\r\n     }\r\n     \r\n    void put(int key, int value) {\r\n        auto it = hash.find(key);\r\n        if(it != hash.end()){\r\n           it->second->second = value;\r\n             return cache.splice(cache.begin(), cache, it->second);\r\n         }\r\n        cache.insert(cache.begin(), make_pair(key, value));\r\n         hash[key] = cache.begin();\r\n         if(cache.size() > size){\r\n             hash.erase(cache.back().first);\r\n             cache.pop_back();\r\n         }\r\n     }\r\n private:\r\n     unordered_map<int, list<pair<int, int>>::iterator> hash;\r\n     list<pair<int, int>> cache;\r\n     int size;\r\n };\r\n复杂度分析：\r\n时间复杂度：O(1)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836683816","body":"### 思路\r\n\r\n循环数组从最低位开始带进位累加，额外考虑k位数比较大的情况，最后处理最高位进位。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int c = 0;\r\n        for (int i = num.length-1; i >=0; i--) {\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add + num[i] +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        \r\n        while (k>0){\r\n            int add = k% 10;\r\n            k /=10;\r\n            int sum = add +c;\r\n            if (sum>= 10) {\r\n                sum = sum%10;\r\n                c = 1;\r\n            } else {\r\n                c = 0;\r\n            }\r\n            res.addFirst(sum);\r\n        }\r\n        if (c>0){\r\n            res.addFirst(c);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-836954949","body":"### 思路\r\n\r\n\t从左到右，从右到左。c无非在左或者右。先从左到右找到离左边c的距离，再从右到左找离右边c的距离，并判断大小。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n   class Solution {\r\n  public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n       \r\n        int left = -length;\r\n        for (int i = 0; i <length ; i++) {\r\n            if (chars[i] == c){\r\n                left = i;\r\n                res[i] = 0;\r\n            }else {\r\n               res[i] = i-left;\r\n            }\r\n        }\r\n        int right = 2*length;\r\n        for (int i = length-1; i >=0; i--) {\r\n            if (chars[i] == c){\r\n                right = i;\r\n            }else {\r\n                \r\n                    res[i] = Math.min(right-i,res[i]);\r\n                \r\n            }\r\n\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839356693","body":"### 思路\r\n\r\n\t数组加栈顶下标\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class CustomStack {\r\n    private int[] arr;\r\n    private int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        index = -1;\r\n        arr = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (index < arr.length-1) {\r\n            arr[++index] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (index == -1){\r\n            return -1;\r\n        }else {\r\n            return arr[index--];\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k,index+1);\r\n        for (int i = 0; i <min ; i++) {\r\n            arr[i]+=val;\r\n        }\r\n    }\r\n\r\n}\r\n\t\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)、除了increment O(k)。\r\n- 空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839987215","body":"### 思路\r\n\r\n 栈，(写得好笨重)\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n     class Solution {\r\n   public String decodeString(String s) {\r\n        char[] chars = s.toCharArray();\r\n        LinkedList<Character> stackIn = new LinkedList<>();\r\n        LinkedList<Character> stackOut = new LinkedList<>();\r\n        for (int i = 0; i < chars.length; i++) {\r\n            if (chars[i] == ']') {\r\n                while (stackIn.peekFirst() != '[') {\r\n                    stackOut.addFirst(stackIn.pollFirst());\r\n                }\r\n                stackIn.pollFirst();\r\n                int sumK = 0;\r\n                int index=1;\r\n                while (!stackIn.isEmpty() && stackIn.peekFirst() < 58 && stackIn.peekFirst() > 47) {\r\n                    sumK +=   (stackIn.pollFirst() - 48)*index;\r\n                    index *=10;\r\n                }\r\n                index = 1;\r\n                for (int j = 0; j < sumK; j++) {\r\n                    for (Character character : stackOut) {\r\n                        stackIn.addFirst(character);\r\n                    }\r\n                }\r\n                stackOut.clear();\r\n            } else {\r\n                stackIn.addFirst(chars[i]);\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = stackIn.size() - 1; i >= 0; i--) {\r\n            sb.append(stackIn.get(i));\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(N)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840922187","body":"### 思路\r\n\r\n\t2个栈，1个pop，1个push，pop队列空了，就迁移push队列数据到pop。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> stackIn;\r\n    private Stack<Integer> stackOut;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stackIn = new Stack<>();\r\n        stackOut = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stackIn.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (stackOut.isEmpty()){\r\n            while (!stackIn.isEmpty()){\r\n                stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (stackOut.isEmpty()){\r\n            while (!stackIn.isEmpty()){\r\n                stackOut.push(stackIn.pop());\r\n            }\r\n        }\r\n        return stackOut.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stackOut.isEmpty() && stackIn.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(N)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665005","body":"### 思路\r\n\r\n单调栈，大于等于最大值就入栈，小于需要重新审视栈中比栈顶小的元素(出栈)。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr){\r\n        Stack<Integer> stack = new Stack<>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (stack.isEmpty() || arr[i]>=stack.peek()){\r\n                stack.push(arr[i]);\r\n            }else {\r\n                Integer top = stack.pop();\r\n                while (!stack.isEmpty()&&stack.peek()>arr[i]){\r\n                    stack.pop();\r\n                }\r\n                stack.push(top);\r\n            }\r\n\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlgN)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841795200","body":"### 思路\r\n\r\n 走两圈，第一圈确定链表长度size，第二圈走K取模size。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n public ListNode rotateRight(ListNode head, int k){\r\n        if (head == null){\r\n            return null;\r\n        }\r\n        ListNode dummy = head;\r\n\r\n        int size = 1;\r\n        while (head.next != null) {\r\n            head = head.next;\r\n            size++;\r\n        }\r\n        head.next = dummy;\r\n        int rot =size- k%size;\r\n        \r\n        while (rot-- > 0) {\r\n            head = head.next;\r\n        }\r\n        ListNode res = head.next;\r\n        head.next = null;\r\n        return res;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841909873","body":"### 思路\r\n\r\n 递归\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n       if (head == null || head.next == null) return head;\r\n        ListNode temp =  swapPairs(head.next.next);\r\n        ListNode res = head.next;\r\n        res.next = head;\r\n        head.next = temp;\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842751657","body":"### 思路\r\n\r\n快慢指针+递归\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head){\r\n        if (head == null) return null;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        ListNode left = head;\r\n        while (fast.next!=null && fast.next.next!=null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode treeNode = new TreeNode(slow.val);\r\n        if (head != slow){\r\n            while (left.next!=null&&left.next != slow){\r\n                left = left.next;\r\n            }\r\n            left.next = null;\r\n            treeNode.left = sortedListToBST(head);\r\n        }\r\n        treeNode.right = sortedListToBST(slow.next);\r\n        return  treeNode;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843584383","body":"### 思路\r\n\r\n交叉链表，a+b = b+a,有相交在1~a+b步之间相等，否则在最终null == null\r\n\r\n### 代码\r\n\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB){\r\n          if (headA == headB) {\r\n            return headA;\r\n        }\r\n        ListNode dummyA = headA;\r\n        ListNode dummyB = headB;\r\n\r\n        while (headA != headB) {\r\n            if (headA == null) {\r\n                headA = dummyB;\r\n            } else {\r\n                headA = headA.next;\r\n            }\r\n            if (headB == null) {\r\n                headB = dummyA;\r\n            } else {\r\n                headB = headB.next;\r\n            }\r\n        }\r\n        return headA;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(a+b)，其中 a,b分别为链表长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844592399","body":"### 思路\r\n\r\n先快慢指针，第一次相遇时：L + s =  2(x+s)  =>  L = 2x +s   =>    L- x = x + a 。\r\n（L为链表长度，s为慢指针到交点的距离, x为交点到head的距离）\r\n相遇之后从head走x步，慢指针也继续走x步。慢指针刚好走一圈，在交点处相遇。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) return null;\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        if (head.next == null) {\r\n            return null;\r\n        }\r\n        while (fast.next != null && fast.next.next != null) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                while (head != slow) {\r\n                    head = head.next;\r\n                    slow = slow.next;\r\n                }\r\n                return head;\r\n            }\r\n        }\r\n        return null;\r\n\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845600187","body":"### 思路\r\n\r\nput、get都是O(1)，需要插入删除并且扩缩容，则不能用数组，选用双向链表。\r\n但是又想查询快则用map（key，链表节点（key,val））。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass LRUCache{\r\n    private HashMap<Integer, DNode> map;\r\n    private int size;\r\n    private int capacity;\r\n    DNode head = new DNode();\r\n    DNode tail = new DNode();\r\n\r\n    public LRUCache(int capacity) {\r\n        head.next = tail;\r\n        tail.pre = head;\r\n        map = new HashMap<>(capacity);\r\n        this.capacity = capacity;\r\n        size = 0;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DNode node = map.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        } else {\r\n            if (head.next != node) {\r\n                //解綁\r\n                node.pre.next = node.next;\r\n                node.next.pre = node.pre;\r\n                //頭插\r\n                headInsert(node);\r\n            }\r\n\r\n            return node.val;\r\n        }\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DNode node = map.get(key);\r\n        if (node != null) {\r\n            node.val = value;\r\n            //解綁\r\n            node.pre.next = node.next;\r\n            node.next.pre = node.pre;\r\n            headInsert(node);\r\n            return;\r\n        }\r\n        if (size >= capacity) {\r\n            map.remove(tailDelete());\r\n            --size;\r\n        }\r\n        DNode newNode = new DNode(key, value);\r\n        headInsert(newNode);\r\n        map.put(key, newNode);\r\n        ++size;\r\n\r\n\r\n    }\r\n\r\n    class DNode {\r\n        DNode pre;\r\n        DNode next;\r\n        private int key;\r\n        private int val;\r\n\r\n        public DNode(int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n\r\n        public DNode() {\r\n        }\r\n    }\r\n\r\n    private void headInsert(DNode node) {\r\n        head.next.pre = node;\r\n        node.next = head.next;\r\n        head.next = node;\r\n        node.pre = head;\r\n    }\r\n\r\n    private int tailDelete() {\r\n        DNode pre = tail.pre;\r\n        pre.pre.next = pre.next;\r\n        pre.next.pre = pre.pre;\r\n        pre.pre = null;\r\n        pre.next = null;\r\n        return pre.key;\r\n    }\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)。\r\n- 空间复杂度：O(1)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846295639","body":"### 思路\r\n\t递归，前序遍历\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        } else {\r\n            return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点个数。\r\n- 空间复杂度：O(logN)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846477597","body":"### 思路\r\n\r\n递归\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p != null && q != null && p.val == q.val) {\r\n            return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n            \r\n        } else {\r\n            return false; \r\n        } \r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为树节点个数。\r\n- 空间复杂度：O(h)，h为树高。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836691767","body":"### 思路\r\n\r\n将k从最后一位往前加，每次加法的结果对10取余，压入返回数组。然后除以10，与前一位相加。\r\n\r\n可能忘记讨论的情况：\r\n\r\n1. k可能比num的位数要长，因此，要确保k的剩余位数都压入结果数组\r\n2. 压入结果数组的内容是倒序的，collections.reverse()使其倒序（以前用的是C++刷题，java的collections要去了解一下）\r\n\r\n\r\n\r\n### JAVA\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tint fin = num.length - 1;\r\n\t\tList<Integer> res = new ArrayList<Integer>();\r\n\t\tint temp = 0;\r\n\t\tfor (int i = fin; i >= 0; i--) {\r\n\t\t\ttemp = num[i] + k;\r\n\t\t\tres.add(temp % 10);\r\n\t\t\tk = temp / 10;\r\n\t\t}\r\n\t\twhile (k > 0) {\r\n\t\t\tres.add(k % 10);\r\n\t\t\tk /= 10;\r\n\t\t}\r\n\t\tCollections.reverse(res);\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837942324","body":"### 思路\r\n\r\n一开始的思路是用双指针，一个表示左边界，一个表示有边界。但是现实实现的时候，需要考虑的情况太多了。\r\n\r\n第一次遍历数组，记录目标字符的位置。\r\n\r\n第二次遍历数组，记录所有元素与左右边界距离的最小值。\r\n\r\n其中，第二次遍历要考虑左右边界的多种情况，没想明白。\r\n\r\n\r\n\r\n第一次写大概花了25分钟，然后去干其他事情。\r\n\r\n第二次修改+debug花了10分钟。\r\n\r\n结果虽然通过了，思路也比较简单，但是代码的逻辑不是很好。\r\n\r\n写完之后大概看了一下题解，又其他更好的方法，晚一点再学习一下。\r\n\r\n\r\n\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n\t\tint m=0;\r\n\t\tint[] res = new int[s.length()];\r\n\t\tList<Integer> list = new ArrayList<>();\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) list.add(i);\r\n\t\t}\r\n\t\tint index1=0,index2=0;\r\n\t\tif(list.size()==1) {\r\n\t\t\tindex1=index2=list.get(0);\r\n\t\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\t\tres[i] = Math.abs(i-index1);\r\n\t\t\t}\r\n\t\t\treturn res;\r\n\t\t}\t\r\n\t\tindex1 = list.get(m);\r\n\t\tindex2 = list.get(m+1);\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tres[i] = Math.min(Math.abs(i-index1), Math.abs(i-index2));\r\n\t\t\tif(i==index2) {\r\n\t\t\t\tif(index2!=list.get(list.size()-1)) {\r\n\t\t\t\t\tm++;\r\n\t\t\t\t\tindex1 = list.get(m);\r\n\t\t\t\t\tindex2 = list.get(m+1);\r\n\t\t\t\t}\r\n\t\t\t}\t\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n### 法二：正序倒序两遍遍历\r\n\r\n参考题解后，又用思路更加清晰的方法写了一遍。这个不算是自己的产出内容，不仅看了思路，还看了代码的实现方式。\r\n\r\n用时：15min\r\n\r\n第一次从左向右遍历的时候，第一个元素和谁比较，有两种情况\r\n\r\n- 第一个char就是我的目的char，那么令比较索引temp等于第一个字符，后续的字符与它比较，遇到新的目标字符就更新temp 的索引\r\n- 第一个char不是目标字符，那么就要设置比较索引值temp让第一个目标字符出现之前res记录的值足够大，因此，选择Integer.MIN_VALUE/2，这是一个很小的复数，i-temp就是一个很大的整数。\r\n\r\n第二次从又向左遍历，同理。需要考虑最右边的原色和谁比较的问题。设置temp = Integer.MAX_VALUE/2，这样temp-i就是一个足够大的正数。\r\n\r\njava实现\r\n\r\n```java\r\nint[] shortestToChar1(String s,char c) {\r\n\t\tint[] res = new int[s.length()];\r\n\t\tint temp = Integer.MIN_VALUE/2;\r\n\t\tfor(int i=0;i<s.length();i++) {\r\n\t\t\tif(s.charAt(i)==c) temp =i;\r\n\t\t\tres[i]= i-temp;\r\n\t\t}\r\n\t\ttemp = Integer.MAX_VALUE/2;\r\n\t\tfor(int i=s.length()-1;i>=0;i--) {\r\n\t\t\tif(s.charAt(i)==c) temp = i;\r\n\t\t\tres[i] = Math.min(res[i],temp-i);\r\n\t\t}\r\n\t\treturn res;\r\n\t}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839432343","body":"### 思路\r\n\r\n一开始就想到用一个vector模拟栈，因为increment需要能够访问所有元素。\r\n\r\n总体思路还是比较简单的。\r\n\r\n构造函数，将容器最大值记录。\r\n\r\npush：先判断容器容量是否超限，然后决定是否将元素压栈。\r\n\r\npop：判断容器是否为空，为空返回-1；不为空返回vector尾部元素\r\n\r\nincrement：先判断k和容器容量大小，再简单的遍历。\r\n\r\n\r\n\r\n### 用时\r\n\r\n思路+代码 20min\r\n\r\ndebug 5min\r\n\r\n### C++\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int>mem;\r\n    int _size;\r\n    \r\n    CustomStack(int maxSize) {\r\n        this->_size = maxSize;\r\n    }\r\n\r\n    void push(int x) {\r\n        if (mem.size() < _size) mem.push_back(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (mem.empty()) return -1;\r\n        else {           \r\n            int ret = mem.back();\r\n            mem.pop_back();\r\n            return ret;\r\n        }\r\n    }\r\n\r\n    void increment(int k, int val) {\r\n        if (k > mem.size()) {\r\n            for (int i = 0; i < mem.size(); i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n        else {\r\n            for (int i = 0; i < k; i++) {\r\n                mem[i] += val;\r\n            }\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n\r\n空间复杂度O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840603298","body":"### 思路\r\n\r\n没有什么思路，提示是用栈编写，我的感觉也是栈的内容，但是没想好到底怎么实现。所以一开始花了25分钟用从前到后遍历的方式写了一个简单的能够识别\"23[ab]\"这样的代码。想着这样笔试的时候，多少也能拿一点分数。\r\n\r\n再思考一下，到了晚上想不出来就参考一下别人的题解。\r\n\r\n### C++\r\n\r\n```c++\r\n#include<iostream>\r\n#include<string>\r\n#include<vector>\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        \r\n        //简单的2[a]3[abc]编码\r\n        int n = 0;\r\n        vector<int> temp;\r\n        string res=\"\";\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                int num = s[i] - '0';\r\n                temp.push_back(num);\r\n            }\r\n            if (s[i] == '[') {\r\n                int j = i + 1;\r\n                string sub = \"\";\r\n                while (s[j] != ']') {\r\n                    sub += s[j];\r\n                    j++;\r\n                }\r\n                for (int k = 0; k < temp.size(); k++) {\r\n                    n += temp[k] * pow(10, temp.size()-k-1);\r\n                }\r\n                for (int k = 0; k < n; k++) {\r\n                    res += sub;\r\n                }\r\n                temp.clear();\r\n                i = j;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\nint main() {\r\n    Solution mySolu;\r\n    string res=mySolu.decodeString(\"10[A]\");\r\n    cout << res << endl;\r\n}\r\n```\r\n\r\n###  未完成，先打卡，明早修改"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841124879","body":"### 思路\r\n\r\npush设置一个栈\r\n\r\npop和peak设置一个栈\r\n\r\nempty由两个栈共同决定\r\n\r\n这一题在牛客做过原题，10分钟\r\n\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n\tstack<int>stk1,stk2;\r\n\tvoid push(int x) {\r\n\t\tstk1.push(x);\r\n\t}\r\n\r\n\tint pop() {\r\n\t\tif (stk2.empty()) {\r\n\t\t\twhile (!stk1.empty()) {\r\n\t\t\t\tstk2.push(stk1.top());\r\n\t\t\t\tstk1.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\tint ret = stk2.top();\r\n\t\tstk2.pop();\r\n\t\treturn ret;\r\n\t\t\r\n\t}\r\n\r\n\tint peek() {\r\n\t\tif (stk2.empty()) {\r\n\t\t\twhile (!stk1.empty()) {\r\n\t\t\t\tstk2.push(stk1.top());\r\n\t\t\t\tstk1.pop();\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stk2.top();\r\n\t}\r\n\r\n\tbool empty() {\r\n\t\treturn stk1.empty() && stk2.empty();\r\n\t}\r\n};\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度： push,empty是O(1)； pop,peek 是 O(n)\r\n\r\n空间复杂度： 都是O(n)\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841806262","body":"## 思路\r\n\r\n维护一个list，将所有结点的地址存储\r\n\r\n每次循环，将list.back()的next指向list.front()，将list.back()插入作为list的front\r\n\r\n==首先将k对结点个数取余，不然时间超限==\r\n\r\n### C++\r\n\r\n法一\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr || k == 0 || head->next == nullptr) return head;\r\n        list<ListNode*> m_list;\r\n        ListNode* p = head;\r\n        while (p != nullptr) {\r\n            m_list.push_back(p);\r\n            p = p->next; \r\n        }\r\n        int num = m_list.size();\r\n        k = k % num;\r\n        for (int i = 0; i < k; i++) {\r\n            ListNode* temp = m_list.back();\r\n            temp->next = m_list.front();\r\n            m_list.push_front(temp);\r\n            m_list.pop_back();\r\n            m_list.back()->next = nullptr;\r\n        }\r\n        return m_list.front();\r\n    }\r\n};\r\n```\r\n\r\n\r\n\r\n法二：参考题解，将原单向链表维护成一个循环链表\r\n\r\n\r\n\r\n### JAVA\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n\t\tif(head==null||head.next==null||k==0) return head;\r\n\t\tint num=0;\r\n\t\tListNode p=head;\r\n\t\twhile(p.next!=null) {\r\n\t\t\tp=p.next;\r\n\t\t\tnum++;\r\n\t\t}\r\n\t\tp.next = head;\r\n\t\tnum++;\r\n\t\tk =num- k%num;\r\n\t\twhile(k!=1) {\r\n\t\t\thead = head.next;\r\n            k--;\r\n\t\t}\r\n\t\tp = head.next;\r\n\t\thead.next = null;\r\n\r\n\t\treturn p;\r\n\t}\r\n\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841984998","body":"### 补充\r\n\r\n参考题解，用递归的方法解题。\r\n\r\n因为每两个结点，遇到的问题就是重复的，需要再次将相邻节点的元素交换，因此可以归纳为递归问题。\r\n\r\n递归结束条件：没有剩余结点或剩余一个结点\r\n\r\n\r\n\r\n递归函数：\r\n\r\n输入：某个结点\r\n\r\n先判断剩余结点是否大于等于2\r\n\r\n生成新的头节点 ListNode newHead\r\n\r\n先求解head.next  = swapPairs(head.next.next)；\r\n\r\n再赋值newHead = head；\r\n\r\n\r\n\r\n### java\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\t\t\tif(head == null||head.next==null) return head;\r\n\t\t\tListNode newHead = head.next;\r\n\t\t\thead.next = swapPairs(head.next.next);\r\n\t\t\tnewHead.next = head;\r\n\t\t\treturn newHead;\r\n\t\t}\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843247013","body":"### 思路\r\n\r\n法一：快慢指针\r\n\r\n为了满足平衡搜索二叉树的高度要求，每一个子树的根节点选择对应子块的中点。\r\n\r\n因此快指针每次走两步，慢指针每次走一步，这样满足高度要求。\r\n\r\n每次根节点将当前数据块分为左子块和右子块，要解决的问题重复出现，因此想到这是一个递归的问题。\r\n\r\n\r\n\r\n法二：\r\n\r\n思路相同，但是不是用快慢指针的方法得到中间那个结点。\r\n\r\n先将所有元素存入数组，然后根据索引值直接访问中间元素。\r\n\r\n剩下的是一样的递归建立树。\r\n\r\n**注意**：边界值，int除以2结果取整数部分，不恰当的边界取值可能导致某些元素被漏掉\r\n\r\n\r\n\r\n小结：\r\n\r\n关于树的遍历，建立一般第一个想到的知识点应该是递归。\r\n\r\n第一种方法适合面试的时候说出来。\r\n\r\n第二种方法易于理解也易于实现，在笔试的时候一定要能想到。\r\n\r\n\r\n\r\n### C++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\tTreeNode* sortedListToBST(ListNode* head) {\r\n\t\tvector<int> vec;\r\n\t\twhile (head != nullptr) {\r\n\t\t\tvec.push_back(head->val);\r\n\t\t\thead = head->next;\r\n\t\t}\r\n\t\tint n = vec.size();\r\n\t\treturn sortedListToBST(vec, 0, n);\r\n\t}\r\n\tTreeNode* sortedListToBST(vector<int>vec, int begin, int end) {\r\n\t\tif (begin >= end) return nullptr;\r\n\t\tint mid = begin + (end - begin) / 2;\r\n\t\tTreeNode* root = new TreeNode(vec[mid]);\r\n\t\troot->left = sortedListToBST(vec, begin, mid );\r\n\t\troot->right = sortedListToBST(vec, mid + 1, end);\r\n\t\treturn root;\r\n\t}\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843832137","body":"### 思路\r\n\r\n知识点，hash表\r\n\r\n两遍遍历链表\r\n\r\n第一遍遍历，将链表A的所有结点存入map，value值为1\r\n\r\n第二遍遍历，将链表B的结点存入map，判断value值是否为2，若为2则返回当前结点，否则继续遍历。\r\n\r\n### C++\r\n\r\n````c++\r\nclass Solution {\r\npublic:\r\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\r\n        if (!headA || !headB) return nullptr;\r\n        unordered_map<ListNode*, int> mp;\r\n        ListNode* ptr = headA;\r\n        while (ptr != nullptr) {\r\n            mp[ptr]++;\r\n            ptr = ptr->next;\r\n        }\r\n        ptr = headB;\r\n        while (ptr != nullptr) {\r\n            mp[ptr]++;\r\n            if (mp[ptr] == 2) {\r\n                return ptr;\r\n            }\r\n            ptr = ptr->next;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n\r\n````\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)：两次链表遍历\r\n\r\n空间复杂度O(n)：建立map\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n第二种方法：双指针，参考的是西法的官方题解，以前做过，但是这一次依旧没想到。\r\n\r\n![image-20210519152018527](C:\\Users\\53072\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210519152018527.png)\r\n\r\n定义两个双指针，速度一样前进，当两个指针的结点相同时，就是第一个公共结点。\r\n\r\n指针1走过的长度:A+C+B\r\n\r\n指针2走过的长度:B+C+A\r\n\r\n### java\r\n\r\n```java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n\t\tif(headA==null || headB==null) return null;\r\n\t\tListNode ptr1 = headA;\r\n\t\tListNode ptr2 = headB;\r\n\t\t\r\n\t\twhile(ptr1 != ptr2) {\r\n\t\t\tptr1 = ptr1==null?headB:ptr1.next;\r\n\t\t\tptr2 = ptr2==null?headA:ptr2.next;\r\n\t\t}\r\n\t\tif(ptr1==ptr2) return ptr1;\r\n\t\treturn null;\t\t\r\n\t}\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845028633","body":"### 思路\r\n\r\n法一：hash表\r\n\r\n法二：快慢指针\r\n\r\n第一次追赶：快指针每次移动两个结点，慢指针每次移动一个结点。如果链表是循环链表，那么第一次相遇在环内相遇。\r\n\r\n第二次追赶：将快指针速度设为1，第二次相遇的结点就是环的入口结点。\r\n\r\n![image-20210520195252955](C:\\Users\\53072\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210520195252955.png)\r\n\r\n### c++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n\tListNode* detectCycle(ListNode* head) {\r\n\t\tunordered_map<ListNode*, int>mp;\r\n\t\tListNode* ptr = head;\r\n\t\twhile (ptr != nullptr) {\r\n\t\t\tif (mp.find(ptr) == mp.end()) {\r\n\t\t\t\tmp[ptr]++;\r\n\t\t\t\tptr = ptr->next;\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn ptr;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nullptr;\r\n\t}\r\n};\r\n\r\nclass Solution {\r\npublic:\r\n\tListNode* detectCycle(ListNode* head) {\r\n\t\tListNode* slow = head;\r\n\t\tListNode* fast = head;\r\n\t\twhile (fast && fast->next) {\r\n\t\t\tslow = slow->next;\r\n\t\t\tfast = fast->next->next;\r\n\t\t\tif (slow == fast) {\r\n\t\t\t\tfast = head;\r\n\t\t\t\twhile (slow != fast) {\r\n\t\t\t\t\tfast = fast->next;\r\n\t\t\t\t\tslow = slow->next;\r\n\t\t\t\t}\r\n\t\t\t\treturn slow;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn nullptr;\r\n\t}\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n哈希法：\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(n)\r\n\r\n双指针法\r\n\r\n时间复杂度O(n)\r\n\r\n空间复杂度O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846001627","body":"### 思路\r\n\r\n自己没有a出来，参考leetcode官方题解\r\n\r\n题目涉及键，值 想到用哈希表\r\n\r\n题目涉及对数据访问先后的排序，想到用栈，队列，或者链表。\r\n\r\nhash表结构 unordered_map<int,ListNode*>\r\n\r\nmap的第一个参数是键，第二个链表结点，而且是双向链表，不能是单向链表。\r\n\r\n### C++\r\n\r\n```c++\r\n//定义双向链表\r\nstruct ListNode {\r\n    int key;\r\n    int val;\r\n    ListNode* left;\r\n    ListNode* right;\r\n    ListNode() :key(0), val(0), left(nullptr), right(nullptr) {};\r\n    ListNode(int x, int y) :key(x), val(y), left(nullptr), right(nullptr) {\r\n    }\r\n    ListNode(ListNode* node) {\r\n        this->key = node->key;\r\n        this->val = node->val;\r\n        this->left = node->left;\r\n        this->right = node->right;\r\n    }\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, ListNode*>mp;\r\n    ListNode* head;\r\n    ListNode* tail;\r\n    int m_capacity = 0;\r\n    int m_size = 0;\r\npublic:\r\n\r\n    LRUCache(int capacity) {\r\n        this->m_capacity = capacity;\r\n        head->right = tail;\r\n        tail->left = head;\r\n    }\r\n\r\n    int get(int key) {\r\n        if (mp.find(key) == mp.end()) return -1;\r\n        else {\r\n            moveToHead(mp[key]);\r\n            return mp[key]->val;\r\n        }\r\n    }\r\n\r\n    void put(int key, int value) {\r\n        if (mp.find(key) != mp.end()) {\r\n            mp[key]->val = value;\r\n            moveToHead(mp[key]);\r\n        }\r\n        else {\r\n            if (m_size < m_capacity) {\r\n                auto node = new ListNode(key, value);\r\n                addToHead(node);\r\n                m_size++;\r\n            }\r\n            else if (m_size == m_capacity) {\r\n                auto node = new ListNode(key, value);\r\n                addToHead(node);\r\n                removeTail();\r\n                    \r\n            }\r\n        }\r\n    }\r\n\r\n    void moveToHead(ListNode* node) {\r\n        node->left->right = node->right;\r\n    }\r\n\r\n    void addToHead() {\r\n\r\n    }\r\n\r\n    void removetail() {\r\n\r\n    }\r\n};\r\n\r\n```\r\n\r\n参考题解，程序的整体框架搭建好了，还有部分未来得及填充，今天晚一点或者明早填充完。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846373203","body":"### 思路：\r\n\r\n深度优先搜索dfs\r\n\r\n看见leetcode一条评论：我发誓这一次我没有复制\r\n\r\n哈哈，我也可以说：我发誓这一次我没有复制\r\n\r\n### C++\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int dfs(TreeNode* root, int val) {\r\n\t\tif (root == nullptr) return val;\r\n\t\telse {\r\n\t\t\tval++;\r\n\t\t\treturn max(dfs(root->left,val), dfs(root->right,val));\r\n\t\t}\r\n\t}\r\n    int maxDepth(TreeNode* root) {\r\n\t\tif (root == nullptr) return 0;\r\n\t\treturn dfs(root, 0);\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(height)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846527555","body":"## 思路：\r\n\r\n从根结点开始判断和从任意一个结点开始判断两个树知否相等时一样的操作，因此用递归。\r\n\r\n判断条件：\r\n\r\n- 当两个结点都是null，返回true\r\n- 当有一个结点时null，另一个不是null，返回fales\r\n- 当两个结点都不是null，先判断结点值是否相等，在判断左右子树是否相等\r\n\r\n\r\n\r\n### C++\r\n\r\n```c++\r\nstruct TreeNode {\r\n\tint val;\r\n\tTreeNode* left;\r\n\tTreeNode* right;\r\n\tTreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n\tTreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\r\n};\r\n\r\n\r\nclass Solution {\r\npublic:\r\n\tbool isSameTree(TreeNode* p, TreeNode* q) {\r\n\t\tif (p == nullptr && q == nullptr) return true;\r\n\t\tif (p == nullptr && q != nullptr) return false;\r\n\t\tif (p != nullptr && q == nullptr) return false;\r\n\t\telse{\r\n\t\t\tif (p->val == q->val) {\r\n\t\t\t\treturn isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\r\n\t\t\t}\r\n\t\t\telse return false;\r\n\t\t}\r\n\t}\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(N)\r\n\r\n空间复杂度O(logN)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oborc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836695695","body":"### 解题思路\r\n刚开始以为这个题是大数相加的简单版，却发现其实是两个题目。\r\n直接遍历数组，用竖式相加的思路，从低位开始加起\r\n初始化一个空数组用来存放结果\r\n1.用加数加上被加数的低位，对和取余 为当前位的结果。\r\n2.对和除以10取整，作为加数向第二低位相加，重复1的步骤，直到数组遍历结束或者加数除以10取整之后为0.\r\n### javascript\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let result = [];\r\n    for(let i = num.length-1;i>=0 || k>0;i--){\r\n        if(i>=0){\r\n            k = k + num[i];\r\n        }\r\n        result.unshift(k%10);\r\n        k = Math.floor(k/10);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度:\r\no(max(N,K/10)) = > O(N),线性复杂\r\n空间复杂度:\r\no(N)= > O(N),线性复杂"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838275025","body":"### 解题思路\r\n\r\n根据官方题解：\r\n1.初始化一个空数组，记录数组中每个字符到目标字符的距离\r\n2.从左向右遍历数组，遍历到目标字符，记录当前下标为index，用遍历下标 i - index  为当前字符距离它右边边的目标字符的距离 ，记录在 result[i] 中，在下次遍历中作比较。\r\n3.从右向左遍历数组，遍历到目标字符，记录当前下标为index，用index - 遍历下标 i  为当前字符距离它左边的目标字符的距离。取result[i] 和 差值中最小的记录为result[i]。result 即为所求\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let str = s.split(\"\");\r\n    let cIndex = -Infinity;\r\n    let result = [];\r\n    for(let i=0;i<str.length;i++){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = i-cIndex;\r\n    }\r\n    cIndex = Infinity;\r\n    for(let i=str.length-1;i>=0;i--){\r\n        if(str[i] == c ){\r\n            result[i]=0;\r\n            cIndex = i;\r\n        }\r\n        result[i] = Math.min(result[i],cIndex-i);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n时间复杂度：\r\no(2n) => o(n)\r\n空间复杂度：\r\no(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839694066","body":"### 解题思路\r\n数组的操作，根据数组的特性和API 实现\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.maxSize > this.stack.length) {\r\n        this.stack.push(x)\r\n    } else {\r\n        return null\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < Math.min(k ,this.stack.length); i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215711","body":"### 解题思路\r\njs数组本身就是一个队列。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.data = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.data.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.data.shift();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.data[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.data.length >0 ? false : true;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n### 复杂度分析\r\n空间复杂度o(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841759595","body":"### 解题思路一\r\n将链表置为一个环，用位移的个数对链表长度取余计算要断开的位置，在断开的位置置为null.\r\n（因为是只有一个头指针的链表，所以如果要位移的话，无论如何都要遍历一遍全链表。）\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\n\r\nvar rotateRight = function(head, k) {\r\n    let tail = head;\r\n    if(k == 0 || head == null || head.next == null){\r\n        return head;\r\n    }\r\n    let count = 1;\r\n    while(tail.next!=null){\r\n        tail = tail.next;\r\n        count++;\r\n    }\r\n    let actk = count - k % count;\r\n    if(actk == 0){\r\n        return head;\r\n    }\r\n    tail.next = head;\r\n    while(actk > 0){\r\n        tail = tail.next;\r\n        actk -- ;\r\n    }\r\n    let newHead = tail.next;\r\n    tail.next = null;\r\n    return newHead;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度o(N+K)\r\n空间复杂度 o（1)\r\n\r\n\r\n### 思路二\r\n和思路一大致一样，\r\n通过计算要截断的位置，先截断成两个链表，再将第二个链表的taile指向第一个链表的头，\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n    let tail = head;\r\n    if(k == 0 || head == null || head.next == null){\r\n        return head;\r\n    }\r\n    let count = 1;\r\n    while(tail.next!=null){\r\n        tail = tail.next;\r\n        count++;\r\n    }\r\n    let actk = count - k % count;\r\n    if(actk == 0 || actk == count){\r\n        return head;\r\n    }\r\n\r\n    let tempTail = head;\r\n    actk --;\r\n    while(actk > 0){\r\n        head = head.next;\r\n        actk -- ;\r\n    }\r\n    let newHead = head.next;\r\n    head.next = null;\r\n    tail.next = tempTail;\r\n    return newHead;\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度o(N+K)\r\n空间复杂度 o（1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842385489","body":"### 解题思路\r\n遍历即可解决\r\n通过遍历链表，取一个空节点为头节点，以便记录最终链表的头部，并作为是否继续的标识\r\n当该节点的下一个和下下一个节点都存在的时候，才有继续遍历的必要，否则就是剩下一个节点或者没有节点、无法交换\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if(head == null || head.next == null){\r\n        return head\r\n    }\r\n    let acHead = new ListNode();\r\n    acHead.next = head;\r\n    let fateHead = acHead;\r\n    while(fateHead.next!=null && fateHead.next.next!=null){\r\n        let start = fateHead.next;\r\n        let end = fateHead.next.next;\r\n        fateHead.next = end;\r\n        start.next = end.next;\r\n        end.next = start;\r\n        fateHead = start;\r\n    }\r\n    return acHead.next;\r\n\r\n};\r\n```\r\n### 复杂度分享\r\n时间复杂度: o(N)\r\n空间复杂度: o(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843119806","body":"### 解题思路\r\n\r\n#### 预备知识：\r\n1.二叉搜索树是跟节点的左子树的值都小于跟节点、右子树的值都大于跟节点\r\n2.由于链表是有序的，所以初始根为链表中的最中间的节点\r\n3.二叉搜索树的递归性决定改题需要用到递归解决\r\n\r\n#### 结合以上三点，得出算法步骤为：\r\n1.找到链表的中间节点，新建一个根节点\r\n2.以根节点左边链表为初始链表递归建立该根节点的左子树\r\n3.以根节点右边链表为初始链表递归建立该根节点的右子树\r\n\r\n#### 待解决问题：\r\n1.不是数组，如何快速找到中间节点\r\n    利用链表的特性，采用快慢指针的方式遍历链表，快指针每次走两步、慢指针每次走一步\r\n    当快指针走到链表尾部的时候，慢指针指向的节点为中间节点\r\n    此时，左边链表为head,middle 右边链表为，middle.next,tail;\r\n    其中，tail为null,因为链表的右边最终始终会是null.\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(!head){\r\n        return null;\r\n    }\r\n    return dfs(head,null);\r\n};\r\nvar dfs = function(head,tail){\r\n    if(head == tail){\r\n        return null;\r\n    }\r\n    let slow = head;\r\n    let fast = head;\r\n    while(fast!=tail && fast.next!=tail){\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n    }\r\n    let root = new TreeNode(slow.val);\r\n    root.left = dfs(head,slow);\r\n    root.right = dfs(slow.next,tail);\r\n    return root;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：N(logN)\r\n空间复杂度：log(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844046883","body":"### 解题思路\r\n快慢指针法：\r\n链表的长度和是不变的，A+B = B+A\r\n可以得到：\r\n用两个指针分别指向两个链表的头，当一个链表遍历到尾部时，将该指针指向另一个链表的头。此时，产生了快慢指针，短链list1的指针slow表先走到尾，再指向长链表list2的时候，长链表的指针和短链表的指针之间的位置相差就是链表的长度差list2-list1，等长链表的指针走到尾的时候，再指向短链list1,则slow指向的长链已经走过了list2-list1个节点。此时slow和fast一起向前移动，会在相交的点相遇。\r\n\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let first = headA;\r\n    let second = headB;\r\n    while(first != second){\r\n        if(first!=null){\r\n            first = first.next;\r\n        }else{\r\n            first = headB;\r\n        }\r\n        if(second!=null){\r\n            second = second.next;\r\n        }else{\r\n            second = headA;\r\n        }\r\n    }\r\n    return first;\r\n\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(M+N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845146586","body":"### 解题思路\r\n\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let first = head;\r\n    let slow = head;\r\n    if(head == null){\r\n        return null;\r\n    }\r\n    while(slow.next!=null && first.next!=null){\r\n        first = first.next.next;\r\n        slow = slow.next;\r\n        if(slow==null || first==null){\r\n            return null;\r\n        }\r\n        if(slow == first){\r\n            let point = head;\r\n            while(point!=slow){\r\n                point = point.next;\r\n                slow = slow.next;\r\n            }\r\n            return point;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：o(N)\r\n空间复杂度：o(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846385260","body":"### 解题思路\r\n深度遍历二叉树\r\n节点为null返回0\r\n然后left = 1+左子树高度\r\nright = 1+ 右子树高度\r\n\r\n返回左右子树的较大值即可\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(root == null){\r\n        return 0 ;\r\n    }\r\n    let left = 1 + maxDepth(root.left);\r\n    let right = 1 + maxDepth(root.right);\r\n    return left > right ? left : right;\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度o(nlogn)\r\n空间复杂度o(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846515598","body":"### 解题思路\r\n遍历树\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if(p == null && q==null){\r\n        return true;\r\n    }\r\n    if(p == null || q==null){\r\n        return false;\r\n    }\r\n    if(p.val != q.val){\r\n        return false;\r\n    }\r\n    return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度: o(N)\r\n空间复杂度：o(H)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liandmin":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836696480","body":"### 思路\r\n\r\n1. 直接遍历数组，从后往前加，满10进位，放入结果数组中\r\n2. 如果 k 比数组的number更大的话，继续遍历 k，放入结果数组\r\n3. 反转结果数组返回即可\r\n\r\n### JS\r\n\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n  const res = [];\r\n  const length = num.length;\r\n\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    let sum = num[i] + (k % 10);\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.push(sum);\r\n  }\r\n\r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n    res.push(k % 10);\r\n  }\r\n  res.reverse();\r\n\r\n  return res;\r\n};\r\n```\r\n \r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(N,lg k))，其中 N 为数组长度。\r\n* 空间复杂度：O(N)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838758803","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n正向和反向各遍历一次数组，取两次遍历中最小的值即可\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  const res = new Array(s.length);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] === c) {\r\n      res[i] = 0;\r\n    } else {\r\n      res[i] = i === 0 ? Infinity : res[i - 1] + 1;\r\n    }\r\n  }\r\n\r\n  for (let i = s.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) {\r\n      res[i] = res[i + 1] + 1;\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655638","body":"## JavaScript\r\n\r\n### 思路\r\n\r\n辅助栈，一个或两个都可以\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] != ']') {\r\n      stack.push(s[i]);\r\n    } else if (s[i] == ']') {\r\n      let temp = '';\r\n      while (stack[stack.length - 1] != '[') {\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop();\r\n\r\n      let num = '';\r\n      while (stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9') {\r\n        num = stack.pop() + num;\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num));\r\n      stack.push(temp);\r\n    }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n* 空间复杂度： O(N)\r\n* 时间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680006","body":"## JS\r\n\r\n### 思路\r\n\r\n看了官方题解，没想到还能用单调栈来解\r\n\r\n### 代码\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const num = arr[i];\r\n\r\n    if (stack.length && stack[stack.length - 1] > num) {\r\n      const cur = stack[stack.length - 1];\r\n      while (stack.length && stack[stack.length - 1] > num) stack.pop();\r\n      stack.push(cur);\r\n    } else {\r\n      stack.push(num);\r\n    }\r\n  }\r\n\r\n  return stack.length;\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841817133","body":"### JS\r\n\r\n快慢指针\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!head || !head.next) return head;\r\n\r\n  let count = 0;\r\n  let now = head;\r\n  while (now) {\r\n    count++;\r\n    now = now.next;\r\n  }\r\n  k = k % count;\r\n  let slow = (fast = head);\r\n  while (fast.next) {\r\n    if (k-- <= 0) {\r\n      slow = slow.next;\r\n    }\r\n    fast = fast.next;\r\n  }\r\n  fast.next = head;\r\n  let res = slow.next;\r\n  slow.next = null;\r\n  return res;\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843293073","body":"## JS\r\n\r\n### 思路\r\n\r\n* 使用数组保存链表的值\r\n* 拿到数组的中间值作为根节点\r\n* 前序遍历创建二叉树\r\n\r\n### 代码\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  \r\n  const res = [];\r\n  \r\n  while (head) {\r\n    res.push(head.val);\r\n    head = head.next;\r\n  }\r\n\r\n  function dfs(left, right) {\r\n    if (left > right) return null;\r\n    const mid = (left + right) >>> 1;\r\n    const root = new TreeNode(res[mid]);\r\n    root.left = dfs(left, mid - 1);\r\n    root.right = dfs(mid + 1, right);\r\n\r\n    return root;\r\n  }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844224241","body":"## JS\r\n\r\n### 思路\r\n\r\n双指针\r\n\r\n### 代码\r\n\r\n```js\r\n var getIntersectionNode = function(headA, headB) {\r\n    let a = headA;\r\n    let b = headB;\r\n\r\n    while (a !== b) {\r\n      a = a === null ? headB : a.next;\r\n      b = b === null ? headA : b.next;\r\n    }\r\n\r\n    return a;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836712891","body":"### 思路\r\n\r\n逐位相加\r\n\r\n首先新建一个链表，从数组num尾部和K的低位开始反向遍历，依次求和得到对应的sum，根据求和结果判断是否进位（carry=1表示进位，carry=0表示无进位），将sum对10取模后加入到链表头部。\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public static List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int carry = 0;      //进位数，1表示进位，0表示无进位\r\n        int sum;    //每次求和的值\r\n        int n = num.length - 1;     //遍历数组时的索引\r\n        while (k != 0 || n >= 0){\r\n            sum = carry + (k % 10);\r\n            if (n >= 0){\r\n                sum += num[n];\r\n            }\r\n\r\n            carry = (sum > 9) ? 1:0;\r\n            res.addFirst(sum % 10);\r\n            n--;\r\n            k = k / 10;\r\n        }\r\n        if (carry == 1){res.addFirst(1);}\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n, k))，其中 n 为数组长度, k为数值K的长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838514773","body":"解题思路：暴力寻找，首先生成长度为s.length()的结果数组res。遍历字符串的字符，当遇到不是c的字符时，向左和向右寻找最近的c字符的索引，然后与当前字符索引进行距离计算，取最小值存入结果数组res中；遍历时遇到字符c则存入0。\r\n\r\n代码\r\n\r\n```java\r\npublic class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l, r;\r\n        int[] res = new int[s.length()];\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) != c) {\r\n                l = r = i;\r\n                while (l > 0 && (s.charAt(l) != c)){\r\n                    l--;\r\n                }\r\n                while (r < s.length()-1 && (s.charAt(r) != c)){\r\n                    r++;\r\n                }\r\n                if (s.charAt(l) != c){\r\n                    res[i] = Math.abs(i - r);\r\n                }else if (s.charAt(r) != c){\r\n                    res[i] = Math.abs(i - l);\r\n                }else {\r\n                    res[i] = Math.min(Math.abs(i - l), Math.abs(i - r));\r\n                }\r\n            }else {\r\n                res[i] = 0;\r\n            }\r\n\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n复杂度分析\r\n\r\n- 时间复杂度：O(n<sup>2</sup>)，其中 n 为字符串长度。\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839785134","body":"思路\r\n使用数组模拟栈，定义变量size记录当前数组中元素的数量\r\n\r\n代码\r\nclass CustomStack {\r\n\r\n    private int[] stack;\r\n    private int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (size < stack.length){\r\n            stack[size] = x;\r\n            size++;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        stack[size - 1] = 0;\r\n        size--;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < k && i < stack.length; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：构造函数、pop函数、push函数为O(1), increment函数为O(k)\r\n空间复杂度：O（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840570391","body":"#### **思路**：栈操作\r\n自己想了半个小时，只想到了使用栈操作，思路和官方解法一有点接近，但是代码还是没能写出来，以下为官方解法一\r\n本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：\r\n\r\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n如果当前的字符为字母或者左括号，直接进栈\r\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n重复如上操作，最终将栈中的元素按照从栈底到栈顶的顺序拼接起来，就得到了答案。注意：这里可以用不定长数组来模拟栈操作，方便从栈底向栈顶遍历。\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：记解码后得出的字符串长度为 SS，除了遍历一次原字符串 ss，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为 O(S+|s|)O(S+∣s∣)，即 O(S)O(S)。\r\n- 空间复杂度：记解码后得出的字符串长度为 SS，这里用栈维护 TOKEN，栈的总大小最终与 SS 相同，故渐进空间复杂度为 O(S)O(S)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841263081","body":"#### **思路**\r\n\r\n题目要求仅使用两个栈实现先入先出队列，那么首先想到的方法就是一个栈s1存储数据，一个栈s2中转数据，为了减少操作，可以设置一个变量存储栈顶元素。这里有一个技巧是在弹出一次数据时，将数据存到s2中，这样一来s2的栈顶相当于队首，之后push的数据存入s1，直到s2中的数据清空。\r\n\r\n**代码**\r\n\r\n```java\r\npublic class MyQueue3 {\r\n\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n    private int front;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue3() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if (s1.isEmpty()) {\r\n            front = x;\r\n        }\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        return front;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n\r\n\r\n    public static void main(String[] args) {\r\n        MyQueue3 myQueue = new MyQueue3();\r\n        myQueue.push(1);\r\n        myQueue.push(2);\r\n        System.out.println(myQueue.peek());\r\n        System.out.println(myQueue.pop());\r\n        System.out.println(myQueue.empty());\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：弹出数据时的时间复杂度为O(1)~O(n), 其他操作均为O(1)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660245","body":"#### **思路**\r\n自己没解出来\r\n采用官方题解的思路一：\r\n\t首先还是要找到从左边开始最小的块。\r\n\t我们知道数组 arr 在排序之后一定跟整个数组排序后相应的地方完全相同，即 expect = sorted(arr)。如果前 k 个元素的个数减去排序后前 k 个元素的个数都为 0 的话，那这前 k 个元素是可以成为一个合法的分块的。对于整个数组可以重复这一过程。\r\n\r\n用变量 nonzero 来计数目前差值不等于 0 的字符的个数。\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：*O*(*N*log*N*)，其中 *N* 为 `arr` 的长度。\r\n- 空间复杂度：*O*(*N*)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841809960","body":"#### **思路**\r\n\r\n先闭环在解开。首先遍历链表得到长度l，然后计算实际位移后链表头部所在的索引，如果位移的长度与链表长度相等，直接返回head，否则执行闭环再解开的操作\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //判断特殊情况\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        //迭代求出链表长度l\r\n        ListNode iter = head;\r\n        int l = 1;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            l++;\r\n        }\r\n\r\n        //计算实际需要位移的长度\r\n        int add = l - k % l;\r\n        //当add与l相等时，直接返回head即可(未发生位移)\r\n        if (add == l) {\r\n            return head;\r\n        }\r\n        //否则先闭环，再找到平移后的链表头部\r\n        iter.next = head;\r\n        while (add > 0) {\r\n            iter = iter.next;\r\n            add--;\r\n        }\r\n        //解开闭环\r\n        ListNode res = iter.next;\r\n        iter.next = null;\r\n\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：两次遍历链表，所以时间复杂度为O(N)\r\n- 空间复杂度：所有操作都在原始链表上操作，只使用了个别整型变量，所以空间复杂度为O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842338875","body":"#### **思路**\r\n\r\n递归\r\n\r\n交换链表两个结点的思路是先将后一个结点单独保存为lis，然后将前一个结点的next设置为已经完成交换操作的lis的后续结点（head=swapPairs(lis.next)）。递归的终止条件是链表没有结点或者只有一个结点，此时直接返回head即可\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode lis = head.next;\r\n        head.next = swapPairs(lis.next);\r\n        lis.next = head;\r\n        return lis;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：对于结点都需要进行操作，所以时间复杂度为O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843146969","body":"**思路**\r\n\r\n**1.自己的思考**\r\n\r\n首先想到的是先将链表中的数据遍历存入一个临时数组中，由于链表的元素已经按照升序排列，所以直接对数组分割即可，然后根据分割后的数据生成二叉树\r\n\r\n**代码**\r\n\r\n```java\r\n未能自己实现\r\n```\r\n\r\n**2.题解**\r\n\r\n方法一：分治\r\n\r\n首先利用快慢指针找到链表的中间结点，然后使用递归方法找到前半部分的中间结点和后半部分的中间结点，构造相应的子树，作为原始链表中间结点的左右子树\r\n\r\n**代码**\r\n\r\n```\r\npublic class Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return sortedListToBST(head, null);\r\n    }\r\n\r\n    public TreeNode sortedListToBST(ListNode left, ListNode right) {\r\n        //如果输入的left和right相同说明都为null，返回null即可(不考虑重复元素的情况)\r\n        if (left == right){\r\n            return null;\r\n        }\r\n        ListNode mid = getMid(left, right);        //利用快慢指针找到中间结点\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = sortedListToBST(left, mid);        //递归构造左子树\r\n        root.right = sortedListToBST(mid.next, right);        //递归构造右子树\r\n        return root;\r\n\r\n    }\r\n\r\n    public ListNode getMid(ListNode left, ListNode right){\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：***O*(*n*log*n*)**\r\n- 空间复杂度：***O*(log*n*)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844094898","body":"**思路**\r\n\r\n**1.自己的思考**\r\n想法1：对两个链表进行遍历，遍历的同时进行比对，找到相同的结点即为相交节点\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        while (headA != null) {\r\n            ListNode hb = headB;\r\n            while (hb != null) {\r\n                if (hb == headA) {\r\n                    return hb;\r\n                }\r\n                hb = hb.next;\r\n\r\n            }\r\n            headA = headA.next;\r\n\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：***O*(*mn*)**\r\n- 空间复杂度：***O*(*1*)**\r\n\r\n想法2：对两个链表各遍历一次，将数据存入两个栈中，然后查看栈顶元素，如果不同，则两个链表没有相交点；如果相同，则同时向外弹出元素，直到找到第一个不同的结点，该节点的下一个结点即为所求相交点\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution1 {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Stack<ListNode> stackA = new Stack<>();\r\n        Stack<ListNode> stackB = new Stack<>();\r\n        while (headA != null){\r\n            stackA.push(headA);\r\n            headA = headA.next;\r\n        }\r\n        while (headB != null){\r\n            stackB.push(headB);\r\n            headB = headB.next;\r\n        }\r\n        if (stackA.peek() == stackB.peek()){\r\n            while (stackA.peek() == stackB.peek()){\r\n                if (stackA.size() == 1){\r\n                    return stackA.pop();\r\n                }else if (stackB.size() == 1){\r\n                    return stackB.pop();\r\n                }\r\n                stackA.pop();\r\n                stackB.pop();\r\n            }\r\n            return stackA.pop().next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：***O*(*n*)**\r\n- 空间复杂度：***O*(*n*)**\r\n\r\n**2.官方题解**\r\n\r\n**思路1：哈希表法**\r\n\r\n遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 b<sub>i</sub>是否在哈希表中。若在，则 b<sub>i</sub>为相交结点\r\n\r\n    public class Solution {\r\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n            Set<ListNode> hashSet = new HashSet<>();\r\n    \r\n            ListNode curNode = headA;\r\n            while (curNode != null) {\r\n                hashSet.add(curNode);\r\n                curNode = curNode.next;\r\n            }\r\n    \r\n            curNode = headB;\r\n            while (curNode != null) {\r\n                if(hashSet.contains(curNode)){\r\n                    return curNode;\r\n                }\r\n                curNode = curNode.next;\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 : O*(*m*+*n*)。\r\n- 空间复杂度 : *O*(*m*) 或 *O*(*n*)\r\n\r\n**思路2：双指针法**\r\n\r\n创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。\r\n当 pA 到达链表的尾部时，将它重定位到链表 B 的头结点 (你没看错，就是链表 B); 类似的，当 pB 到达链表的尾部时，将它重定位到链表 A 的头结点。\r\n若在某一时刻 pA和 pB 相遇，则 pA/pB 为相交结点。\r\n想弄清楚为什么这样可行, 可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 由于 B.length (=4) < A.length (=6)，pB 比 pA少经过 22 个结点，会先到达尾部。将 pB 重定向到 A 的头结点，pA 重定向到 B 的头结点后，pB 要比 pA多走 2 个结点。因此，它们会同时到达交点。\r\n如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交。\r\n\r\n一段话总结：A和B两个链表长度可能不同，但是A+B和B+A的长度是相同的，所以遍历A+B和遍历B+A一定是同时结束。 如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 如果A,B不相交的话两个指针就会同时到达A+B（B+A）的尾节点\r\n\r\n    public class Solution {\r\n    \tpublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n            // 特判\r\n            if (headA == null || headB == null) {\r\n                return null;\r\n            }\r\n    \r\n            ListNode head1 = headA;\r\n            ListNode head2 = headB;\r\n    \r\n            while (head1 != head2) {\r\n                if (head1 != null) {\r\n                    head1 = head1.next;\r\n                } else {\r\n                    head1 = headB;\r\n                }\r\n    \r\n                if (head2 != null) {\r\n                    head2 = head2.next;\r\n                } else {\r\n                    head2 = headA;\r\n                }\r\n            }\r\n            return head1;\r\n    \t}\r\n    }\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度 : O(m+n)*O*(*m*+*n*)。\r\n- 空间复杂度 : O(1)*O*(1)。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844851841","body":"**思路**\r\n\r\n使用hashSet存储结点，遍历过程中查询set中是否存在当前遍历的结点，若存在即返回，否则返回null\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return null;\r\n        }\r\n        HashSet<ListNode> set = new HashSet<>();\r\n        ListNode iter = head;\r\n        while (iter != null){\r\n            if (set.contains(iter)){\r\n                return iter;\r\n            }\r\n            set.add(iter);\r\n            iter = iter.next;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。\r\n- 空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845979820","body":"**思路**\r\n\r\n1.自己的思考\r\n\r\n可以考虑使用hashMap存储数据，返回操作可以直接调用hashMap的get方法，关键点在于如何维护map\r\n\r\n**代码（未完成）**\r\n\r\n```java\r\npublic class LRUCache {\r\n\r\n    //定义变量维护缓存上限\r\n    private int size;\r\n    private HashMap<Integer, Integer> lruCache;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = capacity;\r\n        lruCache = new HashMap<>();\r\n    }\r\n\r\n    public int get(int key) {\r\n        int isExist = lruCache.get(key);\r\n        if (isExist != -1){\r\n            //维护hashMap中的键值\r\n        }\r\n        return isExist;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if (lruCache.containsKey(key)){\r\n            lruCache.replace(key, value);\r\n        }else {\r\n            if (lruCache.size() >= size){\r\n                //移除最近使用次数最少的键值\r\n                //添加新的键值对\r\n            }else {\r\n                lruCache.put(key, value);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：\r\n- 空间复杂度：\r\n\r\n2.双向链表+哈希表（官方题解思路）\r\n\r\n1. 双向链表按最后一次访问的时间的顺序进行排列, 链表头部为最近访问的节点\r\n2. 哈希表,以关键字为键,以链表节点的地址为值\r\n\r\n**代码**\r\n\r\n```java\r\npublic class LRUCache {\r\n\r\n    class Node {\r\n        //链表结点类\r\n        private int key, value;\r\n        public Node prev, next;\r\n\r\n        public Node(int k, int v) {\r\n            key = k;\r\n            value = v;\r\n        }\r\n    }\r\n\r\n    class DoubleLinkedList {\r\n\r\n        //设置虚拟头尾结点\r\n        private Node head, tail;\r\n        //链表元素数\r\n        private int size;\r\n\r\n        public DoubleLinkedList() {\r\n            //初始化双向链表\r\n            head = new Node(0, 0);\r\n            tail = new Node(0, 0);\r\n            head.next = tail;\r\n            tail.prev = head;\r\n            size = 0;\r\n        }\r\n\r\n        //双向链表向头部添加元素\r\n        public void addFirst(Node node) {\r\n            node.next = head.next;\r\n            head.next.prev = node;\r\n            head.next = node;\r\n            node.prev = head;\r\n            size ++;\r\n        }\r\n\r\n        // 删除链表中的 node 节点（node 一定存在）\r\n        // 由于是双链表且给的是目标 Node 节点，时间 O(1)\r\n        public void remove(Node node){\r\n            node.prev.next = node.next;\r\n            node.next.prev = node.prev;\r\n            size--;\r\n        };\r\n\r\n        public Node removeLast(){\r\n            Node last = tail.prev;\r\n            last.prev.next = tail;\r\n            tail.prev = last.prev;\r\n            size--;\r\n            return last;\r\n        }\r\n\r\n        public int size(){\r\n            return size;\r\n        }\r\n    }\r\n\r\n    private HashMap<Integer, Node> map;\r\n    private DoubleLinkedList cache;\r\n    private int capacity;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>();\r\n        cache = new DoubleLinkedList();\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (!map.containsKey(key)){\r\n            return -1;\r\n        }\r\n        int val = map.get(key).value;\r\n        put(key, val);\r\n        return val;\r\n    }\r\n\r\n    public void put(int key, int val) {\r\n        // 先把新节点 x 做出来\r\n        Node x = new Node(key, val);\r\n\r\n        if (map.containsKey(key)) {\r\n            // 删除旧的节点，新的插到头部\r\n            cache.remove(map.get(key));\r\n            cache.addFirst(x);\r\n            // 更新 map 中对应的数据\r\n            map.put(key, x);\r\n        } else {\r\n            if (capacity == cache.size()) {\r\n                // 删除链表最后一个数据\r\n                Node last = cache.removeLast();\r\n                map.remove(last.key);\r\n            }\r\n            // 直接添加到头部\r\n            cache.addFirst(x);\r\n            map.put(key, x);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n) n 为容量的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846373259","body":"**思路**\r\n\r\n使用递归，每棵二叉树的深度可以通过 maxDepth(l,r)+1 得到，即左右子树的最大深度+1\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n\r\n        return 1 + Math.max(left, right);\r\n\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\r\n- 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SunStrongChina":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836713429","body":"> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> \r\n\r\n\r\n> # 989. 数组形式的整数加法\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n> \r\n> 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> \r\n> 输入：A = [1,2,0,0], K = 34\r\n> 输出：[1,2,3,4]\r\n> 解释：1200 + 34 = 1234\r\n> 示例 2：\r\n> \r\n> 输入：A = [2,7,4], K = 181\r\n> 输出：[4,5,5]\r\n> 解释：274 + 181 = 455\r\n> 示例 3：\r\n> \r\n> 输入：A = [2,1,5], K = 806\r\n> 输出：[1,0,2,1]\r\n> 解释：215 + 806 = 1021\r\n> 示例 4：\r\n> \r\n> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n> 输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n> 解释：9999999999 + 1 = 10000000000\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 1 <= A.length <= 10000\r\n> 0 <= A[i] <= 9\r\n> 0 <= K <= 10000\r\n> 如果 A.length > 1，那么 A[0] != 0\r\n> ```\r\n**思路**\r\n1.将k转化为字符串\r\n2.比较k和num那个位数多，先进行少位数的求和相加\r\n3.添加更多的那几位\r\n\r\n**python**\r\n\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        k_str=str(k)\r\n        result=[]\r\n        if len(k_str)>len(num):\r\n            len1=len(num)\r\n            len2=len(k_str)\r\n            num,k_str=k_str,num\r\n        else:\r\n            len1=len(k_str)\r\n            len2=len(num)\r\n            \r\n        value_2=0    \r\n        for i in range(-1,-len1-1,-1):\r\n            value1=int(num[i])+int(k_str[i])+value_2\r\n          \r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        \r\n        for j in range(-len1-1,-len2-1,-1):\r\n            value1=int(num[j])+value_2\r\n            if value1>=10:\r\n                value_1=value1%10\r\n                value_2=1\r\n            else:\r\n                value_1=value1\r\n                value_2=0\r\n            result.append(value_1)\r\n        if value_2!=0:\r\n            result.append(value_2)\r\n        result.reverse()    \r\n        return result\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n时间复杂度：O(max(N,k))，其中 N 为数组长度，k为数值k的长度。\r\n空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839377844","body":"### 思路\r\npython的数组本身就是栈，只需要设定栈元素总量就行\r\n### python\r\n\r\n```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.size=maxSize\r\n        self.stack=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)!=self.size:\r\n            self.stack.append(x)\r\n         \r\n\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)>=1:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<k:\r\n            self.stack=[value1+val for value1 in self.stack]\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n```\r\n\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度:O(n）\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841308053","body":"### 思路\r\n队列每次弹出一个值时，弹出第一个值，并更新\r\n### python代码\r\n```\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.queue1=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.queue1)!=0:\r\n            a=self.queue1[0]\r\n            self.queue1=self.queue1[1:]\r\n            return a\r\n        else:\r\n            return -1\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.queue1)!=0:\r\n            return self.queue1[0]\r\n        else:\r\n            return -1\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.queue1)==0:\r\n            return True\r\n        else:\r\n            return False\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842252125","body":"> # 24. 两两交换链表中的节点\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n> \r\n> ## 前置知识\r\n> 暂无\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n> \r\n> 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n> \r\n>  \r\n> \r\n> 示例 1：\r\n> ```\r\n> \r\n> ![image](https://camo.githubusercontent.com/37e86afda9f65871e855a3affee582b2c887ab3087927b4dc92801bc6d4ad26f/68747470733a2f2f6173736574732e6c656574636f64652e636f6d2f75706c6f6164732f323032302f31302f30332f737761705f6578312e6a7067)\r\n> \r\n> ```\r\n> 输入：head = [1,2,3,4]\r\n> 输出：[2,1,4,3]\r\n> 示例 2：\r\n> \r\n> 输入：head = []\r\n> 输出：[]\r\n> 示例 3：\r\n> \r\n> 输入：head = [1]\r\n> 输出：[1]\r\n>  \r\n> \r\n> 提示：\r\n> \r\n> 链表中节点的数目在范围 [0, 100] 内\r\n> 0 <= Node.val <= 100\r\n> ```\r\n### 思路\r\n迭代法，先创建一个虚指针，指向该链表头结点，然后不断迭代，两两交换，直至链表末端\r\n```\r\ndef swapPairs(self,head) :\r\n    fakeHead= ListNode(0)\r\n    fakeHead.next = head\r\n    temp = fakeHead\r\n    while temp.next and temp.next.next:\r\n        node1 = temp.next\r\n        node2 = temp.next.next\r\n        temp.next = node2\r\n        node1.next = node2.next\r\n        node2.next = node1\r\n        temp = node1\r\n    return fakeHead.next\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843675237","body":"### 思路\r\n总体上就是一个链表的结果进入哈希表，然后再去查看另一个链表中是否有这个元素，有的话就找到了相交点\r\n### python\r\n```\r\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        data=set()\r\n        while headA!=None:\r\n            data.add(headA)\r\n            headA=headA.next\r\n        while headB!=None:\r\n            if headB in data:\r\n                return headB\r\n            headB=headB.next \r\n        return None\r\n```\r\n时间复杂度：O(M+N)\r\n空间复杂度：O(M) 或者O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844690577","body":"###思路：\r\n 快慢指针，快慢指针相遇，然后相交后，再从起始指针处移动，最后相遇处就是环的开始处，然后分别移动至指针相等，就成了\r\n### python\r\n\r\n```\r\ndef detectCycle(self, head: ListNode) -> ListNode:\r\n        first=head\r\n        slow=head\r\n        if head==None:\r\n            return None\r\n        while first!=None:\r\n            slow=slow.next\r\n            if first.next!=None:\r\n                first=first.next.next #移动两次\r\n            else:\r\n                return None\r\n            if first==slow:\r\n                temp=head\r\n                while(temp!=slow):\r\n                    temp=temp.next\r\n                    slow=slow.next\r\n                return temp\r\n        return None\r\n\r\n```\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836721643","body":"### 思路\r\n\r\n倒叙逐位加，先倒着遍历数组`num`，逐位相加，可以把要保存的进位存储到`k`里面，就不容易造成混乱。要注意的是`k`是可以比`num`大的，这里就和66加一不是很一样\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num, k):\r\n        result = []\r\n        for i in range(len(num)-1, -1, -1):  # 先遍历num\r\n            sum = num[i] + k % 10  # 逐位相加\r\n            k = k // 10  # k降一个位数\r\n            if sum >= 10:  # 这里是一个技巧，进位的时候，不直接处理num，而是k加一\r\n                k += 1\r\n            result.append(sum % 10)  # 不用insert降低复杂度\r\n        while k > 0:  # 若k的值不为0，直接加上去即可，同时也考虑k比num大的情况\r\n            result.append(k % 10)\r\n            k = k // 10\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(n,k)) 整数与数组长度之间取最大，为什么官方写的是log(k)？\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329768","body":"### 思路\r\n\r\n左右各遍历一次。每次遍历，记录`c`的位置，左侧开始遍历就计算每个数到最近的左边的`c`的距离，要注意如果左边没有`c`可以记录无穷大。右侧开始遍历，记录每个数到右边的`c`的距离，是`c`的位置减掉该数的位置。如果右边没有`c`，那应该也是无穷大，所以右侧开始的话`c`初始应该是无穷大。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        result = []\r\n        left_position = float('-inf')\r\n        right_position = float('inf')\r\n        for idx, value in enumerate(s):\r\n            if value == c:\r\n                left_position = idx\r\n            result.append(idx-left_position)\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right_position = i\r\n            result[i] = min(right_position-i, result[i])\r\n        return result\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历2遍\r\n- 空间复杂度：O(1) 除了返回值result以外，使用的空间为常数。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839698463","body":"### 思路\r\n\r\n用数组（在python中一个list）模拟栈\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = list()\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            pop_item = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return pop_item\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：push O(1)；pop O(1); increment O(N) \r\n- 空间复杂度：O(N) 这里用到了一个长度为 `maxSize` 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618316","body":"### 思路\r\n\r\n用栈辅助来判断左右括号拆出来的情况。为碰到`]`的时候可以全部进栈，需要注意，数字进栈的时候，要判断是否是连续的数字，如果是连续的，需要和前面的数字拼起来；碰到`[`的时候，用一个辅助的`temp_str`记录拼起来的字符串，这个`temp_str`在碰到数字的时候（其实就是碰到`[`）要乘数字的个数作为拼完的临时字符串。再判断此时栈是否还有`[`有的话说明临时字符串还要继续拼，把现有的临时串先入栈；如果`[`没有在栈中，可以拼到最终结果串中。全部结束，再判断一次栈是否为空，不空的话要拼进结果。这版写太长了，比较挫\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 没碰到[的话全部进栈\r\n        stack = []\r\n        temp_str = \"\"\r\n        result = \"\"\r\n        for val in s:\r\n            if val != ']':\r\n                if stack:\r\n                    if val.isdigit() and stack[-1].isdigit():  # 这里处理有可能多个数字的情况，比如100\r\n                        stack[-1] = stack[-1] + val\r\n                    else:\r\n                        stack.append(val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                while stack:  # 只要碰到]就出栈\r\n                    item = stack.pop()\r\n                    if item != '[' and not item.isdigit():\r\n                        temp_str = item + temp_str\r\n                    elif item.isdigit():\r\n                        temp_str = int(item) * temp_str\r\n                        break\r\n                if '[' not in stack:\r\n                    while stack:\r\n                        temp_str = stack.pop() + temp_str\r\n                    result = result + temp_str\r\n                else:\r\n                    stack.append(temp_str)\r\n                temp_str = \"\"\r\n        while stack:\r\n            temp_str = stack.pop() + temp_str\r\n        result = result + temp_str\r\n        return result\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)，遍历一遍 \r\n- 空间复杂度：O(N) 这里用到了一个最大长度为 `N` 的数组作为辅助空间stack，渐进空间复杂度为 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840982607","body":"### 思路\r\n\r\n两个栈倒来倒去的感觉。在`pop`和`peak`的时候，把左栈的元素全部倒入右栈，取栈顶即可\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_left = []\r\n        self.stack_right = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_left.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        result = None\r\n        while self.stack_left:  # 左栈非空的时候，全部倒到右栈\r\n            self.stack_right.append(self.stack_left.pop())\r\n        if self.stack_right:\r\n            result = self.stack_right.pop()\r\n        while self.stack_right: # 右栈非空的时候，全部倒回左栈\r\n            self.stack_left.append(self.stack_right.pop())\r\n        return result\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        result = None\r\n        while self.stack_left:\r\n            self.stack_right.append(self.stack_left.pop())\r\n        if self.stack_right:\r\n            result = self.stack_right[-1]\r\n        while self.stack_right:\r\n            self.stack_left.append(self.stack_right.pop())\r\n        return result\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        length = len(self.stack_right) + len(self.stack_left)\r\n        if not length:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：push O(1) pop O(N) peak O(N) empty O(1)\r\n- 空间复杂度：O(N) 这里用到了一个最大长度为 `N` 的栈作为辅助空间，渐进空间复杂度为 O(N)\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842298481","body":"### 思路\r\n\r\n需要一个dummy head作为开头的，不然开头的位置不好记录。\r\n\r\n需要找到交换的最小单位进行循环迭代，本题最小单位是四个节点，`preNode -> A -> B -> tailNode`其中`preNode`可以是`dummy`也可以是链表中要交换的两个节点上面的那个节点，`tailNode`是下面一组要交换的家电的开始，也可以是`None`。找到最小的单位，只需要注意最小单位里面需要交换三个链表指针。交换完就需要找下一个最小单位，我们需要两个记录指针记录`node`的位置，只需要`preNode`和`curNode`即可。需要注意的是，本题要直接改变原来的链表的，修改节点本身。\r\n\r\n![image](https://user-images.githubusercontent.com/47736085/118491406-8e25ad80-b751-11eb-814f-538e10737284.png)\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        ans = ListNode()\r\n        ans.next = head  # 最前面放一个空的node\r\n        pre_node = ans  # 初始化最开始的节点\r\n        while head and head.next:\r\n            # 定义一个变换单位的节点\r\n            cur_node = head\r\n            next_node = head.next\r\n            next_cur_node = next_node.next\r\n            # 对三个指针进行改动\r\n            next_node.next = cur_node\r\n            pre_node.next = next_node\r\n            cur_node.next = next_cur_node\r\n            # 移动pre和head到下一个最小单位\r\n            pre_node = head\r\n            head = next_cur_node\r\n\r\n        return ans.next\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(N)，遍历一遍 \r\n- 空间复杂度：O(1) 这里没用多余的内存空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843156914","body":"### 思路\r\n\r\n利用快慢指针，找到最中间的node作为一个根节点，根节点左边的用于构造左子树，右边的用于构造右子树。用递归的方式构造完整的树。（快慢指针会了，递归树和平衡二叉树还没完全理解）\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n# Definition for a binary tree node.\r\nclass TreeNode:\r\n    def __init__(self, val=0, left=None, right=None):\r\n        self.val = val\r\n        self.left = left\r\n        self.right = right\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre_node_of_slow = None  # 要记录slow的前一个位置\r\n        slow = head\r\n        fast = head\r\n        while fast and fast.next:  # 这个循环结束的时候slow是中点\r\n            fast = fast.next.next\r\n            pre_node_of_slow = slow\r\n            slow = slow.next\r\n        if pre_node_of_slow:\r\n            pre_node_of_slow.next = None\r\n\r\n        node = TreeNode(val=slow.val)\r\n        if fast == slow:\r\n            return node\r\n\r\n        node.left = self.sortedListToBST(head=head)\r\n        node.right = self.sortedListToBST(head=slow.next)\r\n        return node\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(logn) 递归树的深度是logn，每层的操作是n\r\n- 空间复杂度：O(logn) \r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843779831","body":"## 思路1：哈希方法\r\n\r\n先遍历一遍A，把A节点都存入哈希表，再遍历一遍B，若节点已经在哈希表中，直接返回，若遍历完都不在哈希表中说明没有重合节点\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, x):\r\n        self.val = x\r\n        self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_dic = dict()\r\n        while headA:\r\n            node_dic[headA] = 1\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_dic:\r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历两遍\r\n- 空间复杂度：O(n) 需要一个哈希表存储node \r\n\r\n\r\n\r\n## 思路2：双指针方法\r\n\r\n把相交链表看作是三段，没有相交部分为两段`a,b`，相交部分为一段`c`。一个指针从a开始，走到结束再从b开头往后走，另一个指针从b开始，走到结束再从a开始往后走。两者相等的时候就是相交点。\r\n\r\n为什么可以这样？从a开始的指针到交点走的路是`a+c+b`，从b开始的指针到交点走的路是`b+c+a`，路程一样的肯定会相交。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA, headB):\r\n        a = headA\r\n        b = headB\r\n        while a != b: # 如果a和b不相交的话，不会退不出循环，会在a、b都是None时退出\r\n            if not a:\r\n                a = headB\r\n            else:\r\n                a = a.next\r\n            if not b:\r\n                b = headA\r\n            else:\r\n                b = b.next\r\n        return a\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 需要遍历\r\n- 空间复杂度：O(1) 不需要额外的空间存储 "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845120585","body":"## 思路：哈希方法\r\n\r\n先遍历一遍A，把A节点都存入哈希表，再遍历一遍B，若节点已经在哈希表中，直接返回，若遍历完都不在哈希表中说明没有重合节点\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, x):\r\n        self.val = x\r\n        self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_dic = dict()\r\n        while headA:\r\n            node_dic[headA] = 1\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_dic:\r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) 遍历两遍\r\n- 空间复杂度：O(n) 需要一个哈希表存储node \r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846059392","body":"## 思路：哈希表+双向链表\r\n\r\n没有完全理解，似懂非懂，根据官方题解，加了自己的理解改写的。尽力加了自己理解的注释。\r\n\r\n\r\n\r\n### 代码\r\n\r\n```python\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity # 存储最大容量\r\n        # 两个数据结构，一个双向链表，一个哈希表\r\n        # 生成一个双向链表, 同时保存该链表的头结点与尾节点\r\n        self.head = DoubleLinkedNode()\r\n        self.tail = DoubleLinkedNode()\r\n        # 把头尾连起来生成初始的双向链表\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.size = 0 \r\n        # 生成存储值的哈希表\r\n        self.cache = dict()\r\n\r\n    def get(self, key: int) -> int:\r\n        # 如果哈希表中不存在该值，不用考虑\r\n        if key not in self.cache:\r\n            return -1\r\n        else:\r\n\r\n        # 如果哈希表中存在该值, 获取改值，并移动到头部\r\n        node = self.cache[key]\r\n        self.move_to_head(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # key 不在哈希表的情况\r\n            node = DoubleLinkedNode()\r\n            # node 添加到哈希表\r\n            self.cache[key] = node\r\n            # node 放进双向链表头部\r\n            self.add_to_head(node)\r\n            self.size += 1\r\n            # 判断是否要删除\r\n            if self.size > self.capacity:\r\n                # 超出了容量，需要删掉双向链表的尾部节点\r\n                removed_node = self.remove_tail()\r\n                self.cache.pop(removed_node.key)\r\n                self.size -= 1\r\n        else:\r\n            # key 在哈希表中的情况，需要修改value，并移动到头部\r\n            node = self.cache[key]\r\n            node.value = value # 更新\r\n            self.remove_to_head(node)\r\n\r\n    def add_to_head(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n\r\n    def remove_node(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def move_to_head(self, node):\r\n        self.remove_node(node)\r\n        self.add_to_head(node)\r\n\r\n    def remove_tail(self):\r\n        node = self.tail.prev\r\n        self.remove_node(node)\r\n        return node\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(1) \r\n- 空间复杂度：O(capacity) "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846412680","body":"\r\n\r\n## 思路：递归\r\n\r\n递归计算左子树和右子树的最大高度，+1就是一起的高度。递归出口是root为空的时候\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n) n为节点数量\r\n- 空间复杂度：O(h) h是树的深度\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newVincentFong":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836729444","body":"# Add to Array-Form of Integer\r\n\r\n## Discuss\r\n\r\n* `num` can be longer than `k`, or can be shorter than k\r\n \r\nso, the times of iterations should be the max between their lengths\r\n\r\n* save the result in the given array\r\n\r\nspace: O(n) -> O(1), less use of `splice`, better timing\r\n\r\n## Code\r\n\r\n```typescript\r\n/**\r\n * @remarks\r\n * * `num` can be longer than `k`, or can be shorter than k\r\n * \r\n * so, the times of iterations should be the max between their lengths\r\n * \r\n * * save the result in the given array\r\n * \r\n * space: O(n) -> O(1), less use of `splice`, better timing\r\n */\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let shouldCarry = false\r\n    const length = Math.max(num.length, k.toString().length)\r\n    const difference = length - num.length\r\n    for (let i = length - 1; i >= 0; i--) {\r\n        const original = num[i - difference] || 0\r\n        const toAdd = k % 10\r\n        const added = original + toAdd + (shouldCarry ? 1 : 0) as number\r\n        const toSave = added % 10\r\n        if (i - difference >= 0) {\r\n            num[i- difference] = toSave\r\n        } else {\r\n            num.splice(0, 0, toSave)\r\n        }\r\n        shouldCarry = Math.floor(added / 10) === 1\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (shouldCarry) {\r\n        num.splice(0, 0, 1)\r\n    }\r\n    return num\r\n};\r\n// time O(n)\r\n// space O(1)\r\n``"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838642501","body":"# Shortest Distance to a Character\r\n\r\n## Discuss\r\n\r\n* the min distance of str[i] is only related to the **two** closest c char that are on both sides of str[i]\r\n\r\nBefore:\r\n\r\n`Min(abs(c1 - str[i]), abs(c2 - str[i]), ... abs(cN - str[i]))`\r\n\r\nAfter:\r\n\r\n`Min(abs(cLEFT - str[i]), abs(cRIGHT - str[i]))`\r\n\r\n* iterate forward and then backward\r\n\r\nwatch out for those `empty` Array items\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const result = []\r\n    // forwards\r\n    let prevC = -1\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            prevC = i\r\n            result[i] = 0\r\n        } else if (prevC !== -1) {\r\n            result[i] = i - prevC\r\n        }\r\n    }\r\n    prevC = -1\r\n    // backwards\r\n    for (let i = s.length - 1; i >= 0; i--) {\r\n        if (prevC !== -1) {\r\n            // CAUTION\r\n            result[i] = typeof result[i] === 'number' ? Math.min(prevC - i, result[i]) : prevC - i\r\n        }\r\n        if (s[i] === c) {\r\n            prevC = i\r\n        }\r\n    }\r\n    return result\r\n};\r\n// time O(n)\r\n// space O(n)\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841220028","body":"# Implement Queue using Stacks\r\n\r\n## Discuss\r\n\r\n* a stack can only `push()` and `pop()`\r\n\r\nnot allowed to `shift()`\r\n\r\nuse another reverse stack\r\n\r\nthen `shift()` can be performed by `pop()`\r\n\r\n## Code\r\n\r\n```typescript\r\nclass MyQueue {\r\n    toPush: number[]\r\n    toPop: number[]\r\n    constructor() {\r\n        this.toPush = []\r\n        this.toPop = []\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.toPush.push(x)\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.toPop.length === 0) {\r\n            this.pour()\r\n        }\r\n        return this.toPop.pop() as unknown as number\r\n    }\r\n\r\n    peek(): number {\r\n        if (this.toPop.length === 0) {\r\n            this.pour()\r\n        }\r\n        return this.toPop[this.toPop.length - 1]\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.toPop.length + this.toPush.length === 0\r\n    }\r\n\r\n    /**\r\n     * transfer items from toPush to toPop\r\n     */\r\n    private pour(): void {\r\n        for (let i = this.toPush.length - 1; i >= 0; i--) {\r\n            this.toPop.push(this.toPush.pop() as unknown as number)\r\n        }\r\n    }\r\n}\r\n// time amortized O(n)\r\n// space O(n)\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841819525","body":"# Rotate List\r\n\r\n## Discuss\r\n\r\n* watch out for the edge cases\r\n\r\n## Code\r\n```typescript\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    // CAUTION!\r\n    if (k === 0 || head === null || head.next === null) {\r\n        return head\r\n    }\r\n    let length = 1\r\n    let ptr: any = head\r\n    while (ptr.next !== null) {\r\n        length++\r\n        ptr = ptr.next\r\n    }\r\n    // CAUTION!\r\n    if (k === length) {\r\n        return head\r\n    }\r\n    const last = ptr\r\n    k = k % length\r\n    // CAUTION!\r\n    if (k === 0) {\r\n        return head\r\n    }\r\n    ptr = head\r\n    for (let i = 1; i < length - k; i++) {\r\n        ptr = ptr.next\r\n    }\r\n    const newHead = ptr.next\r\n    ptr.next = null\r\n    last.next = head\r\n    return newHead\r\n};\r\n// time O(n)\r\n// space O(1)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842317305","body":"# Swap Nodes in Pairs\r\n\r\n## Code\r\n```typescript\r\ntype NullableListNode = ListNode | null\r\nlet pre: NullableListNode\r\nlet current: NullableListNode\r\nlet next: NullableListNode\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n    if (head === null || head.next === null) {\r\n        return head\r\n    }\r\n    const originHead = new ListNode(0, head)\r\n    pre = originHead\r\n    current = head\r\n    next = head.next\r\n    while (current !== null && next !== null) {\r\n        // pre -> current -> next -> ...\r\n        current.next = next.next\r\n        // pre -> current -> ...\r\n        //           next __/\r\n        next.next = current\r\n        // pre -> current -> ...\r\n        // next__/\r\n        pre.next = next\r\n        // pre -> next -> current -> ...\r\n        pre = current\r\n        current = current.next\r\n        next = (current !== null ? current.next : null)\r\n    }\r\n    return originHead.next\r\n};\r\n// time O(n)\r\n// space O(1)\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845973690","body":"#  LRU Cache\r\n\r\n## Discuss\r\n\r\n* lru = doubly linked list + hashmap\r\n\r\n* the Map of javascript is implemented by hashmap and linked list\r\n\r\nit would be much faster to use it as an LRU\r\n\r\nsince it is just raw C++\r\n\r\nbut it won't update the element when double [SET]\r\n\r\nso we have to delete it then set a new item but of the same value\r\n\r\nwhich makes more space expense\r\n\r\n## Code\r\n\r\n```typescript\r\nclass LRUCache {\r\n    capacity: number\r\n    map: Map<number, number>\r\n    length: number\r\n\r\n    constructor(capacity: number) {\r\n        this.capacity = capacity\r\n        this.map = new Map()\r\n        this.length = 0\r\n    }\r\n\r\n    get(key: number): number {\r\n        const item = this.map.get(key)\r\n        if (item === undefined) {\r\n            return -1\r\n        } else {\r\n            this.map.delete(key)\r\n            this.map.set(key, item)\r\n            return item\r\n        }\r\n    }\r\n\r\n    put(key: number, value: number): void {\r\n        const item = this.map.get(key)\r\n        if (item === undefined) {\r\n            if (this.length === this.capacity) {\r\n                const oldest = this.map.keys().next().value\r\n                this.map.delete(oldest)\r\n                this.length--\r\n            }\r\n            // add\r\n            this.map.set(key, value)\r\n            this.length++\r\n        } else {\r\n            this.map.delete(key)\r\n            this.map.set(key, value)\r\n        }\r\n    }\r\n}\r\n// time O(1)\r\n// space O(n)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846423186","body":"# Maximum Depth of Binary Tree\r\n\r\n## Discuss\r\n\r\n* `bfs` uses the most space when given a balanced b-tree\r\n\r\n* `dfs` uses the most space when given a linked-list-like b-tree\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction maxDepth(root: TreeNode | null): number {\r\n    // dfs\r\n    return root === null ? 0 : Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1)\r\n    // bfs\r\n    if (root === null) {\r\n        return 0\r\n    }\r\n    let height: number = 0\r\n    let queue: (TreeNode | null)[] = [root]\r\n    while (queue.length > 0) {\r\n        height++\r\n        const length = queue.length\r\n        for (let i = 0; i < length; i++) {\r\n            // quite slow here\r\n            // since js doesn't have native queue\r\n            // and shift() is an O(n) operation\r\n            const node = queue.shift()\r\n            if (node.left !== null) {\r\n                queue.push(node.left)\r\n            }\r\n            if (node.right !== null) {\r\n                queue.push(node.right)\r\n            }\r\n        }\r\n    }\r\n    return height\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846495869","body":"# Same Tree\r\n\r\n## Discuss\r\n\r\nnone\r\n\r\n## Code\r\n\r\n```typescript\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n    // pre-order dfs\r\n    return p === q ||\r\n        (\r\n            p !== null &&\r\n            q !== null &&\r\n            p.val === q.val &&\r\n            isSameTree(p.left, q.left) &&\r\n            isSameTree(p.right, q.right)\r\n        )\r\n};\r\n// time O(n)\r\n// space O(height)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DAXIAdaxia":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836737171","body":"### **思路：**\r\n从个位数开始，每个数从后往前依次相加\r\n\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        ArrayList<Integer> list = new ArrayList<Integer>();\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            int temp = num[i] + k % 10;\r\n            k /= 10;\r\n            if (temp >= 10){\r\n                k++;\r\n                temp -= 10;\r\n            }\r\n            list.add(temp);\r\n        }\r\n\r\n        while (k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：最坏的情况下，需要遍历n次，所以时间复杂度为O(n)\r\n空间复杂度：最坏的情况下，需要一个长度为(n+1)的列表来存储结果，所以空间复杂度为O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838528608","body":"### **思路：**\r\n先从左往右计算出当前字符距离上一个字符c的距离（第一个需要用最小整数的一半来代替，保证 i-pre 为正），紧接着就是从右往左计算出当前字符距离上一个字符c的距离（第一个需要用最大整数的一半来代替，保证 post-i 为正），同时比较两个距离的大小，只保留距离短的\r\n### **代码：**\r\npublic class Solution {\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n\r\n        int pre = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < len; i++) {\r\n            if (c == s.charAt(i)) pre = i;\r\n            res[i] = i - pre;\r\n        }\r\n\r\n        int post = Integer.MAX_VALUE / 2;\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            if (c == s.charAt(i)) post = i;\r\n            res[i] = Integer.min(res[i],post - i);\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：需要单独进行两个for循环，所以时间复杂度为O(n)，n为字符串长度\r\n空间复杂度：最短距离需要用数组来存，所以空间复杂度为O(n)，n为字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839753729","body":"### **思路：**\r\n因为栈需要存储，所以先定义一个整型数组来存储push的数据，定义变量stackSize来指定栈的最大长度，变量currentSize来表示当前栈实际已经存储的位置。由于定义了数组没有初始化，所以在构造函数中需要对数组进行初始化，并显示指定栈的最大容量。在push()中需要考虑的是当栈已经满了，就不可以往栈加入数据。在pop()函数中需要考虑的是当所有元素出栈之后，要返回-1。在increment()函数中需要考虑的是在k和currentSize取最小值来完成加值操作。\r\n\r\n### **代码：**\r\npublic class CustomStack {\r\n\r\n    private int stackSize;\r\n    private int currentSize = 0;\r\n    private int[] stack;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stackSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (currentSize < stackSize){\r\n            stack[currentSize++] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (currentSize >0 && currentSize <= stackSize){\r\n            return stack[--currentSize];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        if (currentSize >= k){\r\n            for (int i = 0; i < k; i++) {\r\n                stack[i] += val;\r\n            }\r\n        }else {\r\n            for (int i = 0; i < currentSize; i++) {\r\n                stack[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：构造函数、push()、pop()函数的时间复杂度为O(1)，而increment()函数的空间复杂度为O( min(k , currentSize) )\r\n空间复杂度：需要一个数组来存储数据，所以空间复杂度为O(stackSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840602618","body":"### **思路：**\r\n第一步：把'['左边的数字解析出来，并压入栈\r\n第二步：接着把字母和‘[’以字符串的形式压入栈\r\n第三步：但遇到‘]’时，把栈中的元素出栈，直到遇到“[”，并把出栈后的字符串进行反转、重复后重新压入栈\r\n重复以上的步骤，最后出栈的字符串即为结果。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n### **复杂度分析**\r\n时间复杂度：O（n）其中n为字符串的长度\r\n空间复杂度：O（n）其中n为字符串的长度\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841284660","body":"### **思路：**\r\n用ArrayList来充当一个队列，队列头在左边，队列为在右边，每次添加使用ArrayList封装的函数add()，每次出栈使用remove()函数，队列头移除一个元素，查询使用get()函数。\r\n\r\n### **代码：**\r\nclass MyQueue {\r\n    private int top;\r\n    private ArrayList<Integer> queue;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        top = -1;\r\n        queue = new ArrayList<Integer>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.add(x);\r\n        top++;\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(top == -1) return 0;\r\n        Integer res = queue.remove(0);\r\n        top--;\r\n        return res;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(top == -1) return 0;\r\n        int res = queue.get(0);\r\n        return res;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (queue.size()==0) return true;\r\n        return false;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：O(1)\r\n空间复杂度：需要定义一个ArrayList数组来存储入队列的数据，所以空间复杂度为O(n)，n为入队列数据的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841659345","body":"### **思路：**\r\n排序后的数组和排序前的数组进行比较，若在同个索引下，两个元素的值相等，则可以分桶。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, count= 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) count--;\r\n            if (count.get(x) == 1) count++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) count++;\r\n            if (count.get(y) == 0) count--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：O( nlg(n) )\r\n空间复杂度：最坏的情况下，需要存储n个数据，所以空间复杂度为O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841811982","body":"### **思路：**\r\n先遍历一次链表，得到链表的总长度len，并把链表的尾和头连接起来。因为k可能超过链表的总长度，所以使用k%len得到实际需要移动actualK次。紧接着就是需要找到移动后链表的尾，找到链表的尾，把尾的next存起来，后设置为null，最后返回这个next，即为需要的结果。找到链表的尾需要结合actualK和len，从分析我们不难发现，当actualK=1时，指针需要移动len-actualK次。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null) return null;\r\n        ListNode dum = new ListNode(0,head);\r\n        ListNode cur = dum;\r\n        int len = 0;\r\n        while(cur.next != null){\r\n            len++;\r\n            cur = cur.next;\r\n        }\r\n        cur.next = head;\r\n        int actualK = k % len;\r\n        cur = dum;\r\n        for(int i = 0;i < len - actualK; i++){\r\n            cur = cur.next;\r\n        }\r\n        dum = cur.next;\r\n        cur.next = null;\r\n        return dum;\r\n    }\r\n}\r\n\r\n### **复杂度分析**\r\n时间复杂度：需要遍历一次链表，所以空间复杂度为O(n)，n为链表的长度\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842276980","body":"### **思路：**\r\n对于链表，最重要的就是要学会画图。首先先定义一个哑结点dum，然后定义两个节点变量cur1和cur2分别指向dum和dum.next。最关键在于怎么交换，首先cur1.next指向cur2.next；然后把cur1.next.next的链表存到temp中，然后cur1.next.next指向cur2，最后cur2.next指向temp指向的链表。\r\n\r\n### **代码：**\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode dum = new ListNode(0,head);\r\n        ListNode cur1 = dum;\r\n        ListNode cur2 = dum.next;\r\n        while(cur1.next != null && cur2.next != null){\r\n            cur1.next = cur2.next;\r\n            ListNode temp = cur1.next.next;\r\n            cur1.next.next = cur2;\r\n            cur2.next = temp;             \r\n            cur1 = cur2;\r\n            cur2 = cur2.next;      \r\n        }\r\n        return dum.next;\r\n    }\r\n}\r\n### **复杂度分析：**\r\n时间复杂度：因为需要遍历整个链表，所以时间复杂度为O(n)，其中n为链表的长度\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843187601","body":"### **思路：**\r\n\r\n因为需要建立一颗二叉搜索树，所以根节点一般是取中间值（链表为奇数时，取中间即可；链表为偶数时，此时有两个，取任何一个都可以）。然而取中间节点需要使用快慢指针fast、slow，slow走一步，fast走两步，直到fast 或 fast.next 指向最后一个节点时，此时slow指向的节点即为中间节点。后使用递归即可得到二叉搜索树。\r\n\r\n注意：[left,right)采取左闭右开，方便左右子树的递归\r\n\r\n### **代码：**\r\n\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return getBST(head,null);\r\n    }\r\n\r\n    public TreeNode getBST(ListNode left,ListNode right){\r\n\r\n        if (left == right) return null;\r\n\r\n        ListNode mid = getMidListNode(left,right);\r\n        TreeNode treeNode = new TreeNode(mid.val);\r\n        treeNode.left = getBST(left,mid);\r\n        treeNode.right = getBST(mid.next,right);\r\n        return treeNode;\r\n    }\r\n\r\n    public ListNode getMidListNode(ListNode left,ListNode right){\r\n        ListNode slow = left;\r\n        ListNode fast = left;\r\n        while(fast != right && fast.next != right){\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析（不懂分析）\r\n\r\n时间复杂度：O(nlogn)\r\n\r\n空间复杂度：O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844105171","body":"### **思路：**\r\n分析可知，要是两个链表的长度一致，同时向后移动一次，然后比较地址值，如果地址值相同，则说明有相交点；否则则没有相交点。所以可以先求出两个链表的长度，长度较长的链表先向后移动长度差次，则可使两个链表的长度一致。\r\n\r\n### **代码**\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        int lenA = getListNodeLength(headA);\r\n        int lenB = getListNodeLength(headB);\r\n\r\n        int moveLen = lenA >= lenB ? (lenA - lenB) : (lenB - lenA);\r\n        if (lenA >= lenB){\r\n            for (int i = 0; i < moveLen; i++) {\r\n                headA = headA.next;\r\n            }\r\n        }else {\r\n            for (int i = 0; i < moveLen; i++) {\r\n                headB = headB.next;\r\n            }\r\n        }\r\n\r\n        while (headA != null && headB != null){\r\n            if (headA == headA){\r\n                return headA;\r\n            }\r\n            headA = headA.next;\r\n            headB = headB.next;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public int getListNodeLength(ListNode head){\r\n        int len = 0;\r\n        while(head != null){\r\n            len++;\r\n            head = head.next;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n\r\n### **复杂度分析：**\r\n时间复杂度：O(m + n + (m - n))，其中m，n分别为两个链表的长度\r\n空间复杂度：O( 1 )"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844853429","body":"### 思路：\r\n把每一个链表的地址都存到HashMap中，然后比较地址即可。若是循环链表，则一定会有重复的，且把第一次重复的结果返回即可。\r\n\r\n### **代码**\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null) return null;\r\n        HashMap hashMap = new HashMap();\r\n        while (head != null){\r\n            if(hashMap.containsKey(head)){\r\n                return head;\r\n            }\r\n            hashMap.put(head,head);\r\n            head = head.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n### 复杂度分析：\r\n时间复杂度：需要遍历一次链表，所以时间复杂度为O( n )\r\n空间复杂度：需要一个HashMap来存储，所以空间复杂度为O( n )"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846016636","body":"### **思路：**\r\n需要使用一个双向链表和一个哈希表，哈希表用来存储key和链表节点的地址，这样就可以快速定位到该节点在双向链表中的位置。当节点被操作过，应该把此节点放到head后，\r\n提示：双向链表的头表示最近被操作过的节点，离head越远，则说明操作过的时间越长。\r\n\r\n### **代码：**\r\n```java\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                DLinkedNode tail = removeTail();\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n### **复杂度分析：**\r\n时间复杂度：因为使用的是双向链表，删除和插入操作的时间复杂度都为O(1)\r\n空间复杂度：需要使用一个HashMap来存储键值对，所以空间复杂度为O(N)，其中N为HashMap的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846409988","body":"### 思路\r\n\r\n关于树，最先想到的解法应该就是递归。从题目分析可知，只需要使用深度优先搜索算法就可以得该到该树的最大深度。\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        int res = Integer.max(maxDepth(root.left),maxDepth(root.right)) + 1;\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：因为需要遍历树的每一个节点，所以时间复杂度为O(N)，其中N为该树的节点数\r\n\r\n空间复杂度：因为使用到了递归，所以需要使用到栈，空间复杂度为O(deepth)，deepth为树的深度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836744653","body":"\r\n## 思路\r\n进位用k通过加一保存\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        //List<Integer>初始化，需要返回值\r\n        int n = num.length;\r\n        List<Integer>res = new ArrayList<>();\r\n        //List<Integer>指的是存int类型数据的列表\r\n        for(int i = n-1;i>=0;i--){\r\n            //%（取余）和 /（取整）\r\n            //取num的最低位和k值的个位\r\n            int sum = num[i]+k%10;\r\n            //取k值的个位以上\r\n            k/=10;\r\n            if (sum>=10){\r\n                //和有进位加一\r\n                k++;\r\n                //sum-10\r\n                sum-=10;\r\n            }\r\n            //赋值到链表\r\n            res.add(sum);\r\n        }\r\n        //多余的k值位数直接加上去\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838595332","body":"## 思路\r\n1、正向取值为i-prev\r\n2、逆向取值为prev-i\r\n3、比较两个值赋值给ans[]\r\n4、打印\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //s.length()括号不能丢\r\n        int n = s.length();\r\n        int [] ans = new int[n];\r\n        //prev初始值为int整型的最小值的一半\r\n        //保证有prev参与的加减运算不会溢出。同时起到最小值的效果\r\n        //不知道为什么不能是0呢？\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        //charAt() 方法可返回指定位置的字符\r\n        //语法stringObject.charAt(index)\r\n        //s.charaT(i)\r\n        for(int i = 0;i < n;i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //结果在if外，跟着每一次的for循环而不是if\r\n                ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i = n-1;i >= 0;i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n                //min和max需要Math调用\r\n                ans[i] =Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839821304","body":"\r\n## 思路\r\n\r\n本身只有栈顶是可见的，该题为让栈中的所有元素都可见\r\n每一次的进出栈都会被模拟记录在stack中\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n//自定义栈类\r\nclass CustomStack {\r\n    int[] stack;\r\n    //栈顶\r\n    int top;\r\n    //构造器\r\n    public CustomStack(int maxSize) {\r\n        //给定stack长度\r\n        stack = new int[maxSize];\r\n        //栈为空时赋值top给定栈顶为-1\r\n        top = -1;\r\n    }\r\n    //定义push方法\r\n    public void push(int x) {\r\n        //判断是否达到上限，每次push都会判断总会有一次top会等于的\r\n        //因为-1为初始值，所以不等于的时候都是小于，不存在大于的情况\r\n        if(top != (stack.length - 1)){\r\n            //后移top一位\r\n            top++;\r\n            //赋值push\r\n            stack[top] =x;\r\n        }\r\n    }\r\n    //定义pop方法\r\n    public int pop() {\r\n        //判断栈是否为空\r\n        if (top == -1){\r\n            return-1;\r\n        }\r\n        //不为空，则出栈-1\r\n        top--;\r\n        //返回top-1之前的top值\r\n        return stack[top+1];\r\n    }\r\n    //定义inc方法\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for(int i = 0;i<limit;i++){\r\n            stack[i] +=val; \r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655478","body":"\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  不太会啊今天，难顶，主判断\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```Java\r\n\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843210045","body":"\r\n## 菜鸟抄题思路\r\n如果元素个数为偶数，那么唯二的中间值都可以作为中位数，而不是常规定义中二者的平均值\r\n分治:\r\n快指针fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数\r\n当前根节点的元素，递归构造左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树\r\n\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n//寻找树根root\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746047","body":"### 思路\r\n\r\n模拟加法按位逐位相加\r\n\r\n### 代码 js\r\n\r\n\r\n``` javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const result = [];\r\n    const length = num.length;\r\n    for (let i = length - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        result.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        result.push(k % 10);\r\n    }\r\n    result.reverse();\r\n    return result;\r\n};\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：忽略返回值创建的数组，O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837629522","body":"### 思路\r\n\r\n暴力解法，先存取c下标数组，再遍历数组算s中每个字符的最小距离\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const index = [];\r\n    const result = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            index.push(i);\r\n        }\r\n    }\r\n    for (let j = 0; j < s.length; j++) {\r\n        if (s[j] === c) {\r\n            result.push(0);\r\n        } else {\r\n            result.push(Math.min(...index.map(item => Math.abs(j - item))));\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839500604","body":"### 思路\r\n\r\n似乎不需要什么思路，不过需要一个maxSize的类成员变量，作为push判断的存储依据.\r\n### 代码\r\n\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = [];\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length >= this.maxSize) return;\r\n    this.list.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.list.length === 0) return -1;\r\n    return this.list.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const length = this.list.length;\r\n    for (let i = 0; i < length; i ++) {\r\n        if (i <= k - 1) {\r\n            this.list[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：其他O(1)，increment则是O(N)\r\n- 空间复杂度：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840974886","body":"## 思路\r\n内部维护两个栈，一个为基础栈，一个为缓冲的栈，当pop peek的时候将左边的倒到右边的栈，然后取出栈顶元素即是原来的队头元素，pop的时候还要额外的倒回。empty就判断基础栈是否为空即可\r\n## 代码\r\n``` javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.leftStack = [];\r\n    this.rightStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.leftStack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const leftLength = this.leftStack.length;\r\n    this.rightStack = [];\r\n    for (let i = leftLength - 1; i >= 0; i--) {\r\n        this.rightStack.push(this.leftStack[i]);\r\n    }\r\n    const pop = this.rightStack.pop();\r\n    this.leftStack = [];\r\n    const rightLength = this.rightStack.length;\r\n    for (let i = rightLength - 1; i >= 0; i--) {\r\n        this.leftStack.push(this.rightStack[i]);\r\n    }\r\n    return pop;\r\n\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const leftLength = this.leftStack.length;\r\n    this.rightStack = [];\r\n    for (let i = leftLength - 1; i >= 0; i--) {\r\n        this.rightStack.push(this.leftStack[i]);\r\n    }\r\n    return this.rightStack[leftLength - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    const length = this.leftStack.length;\r\n    return length === 0;\r\n};\r\n\r\n```\r\n## 复杂度分析\r\n+ 时间复杂度：pop和peek是O(N) 其他是O(1)\r\n+ 空间复杂度：O(N)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842366644","body":"## 思路 借助官方思路\r\n迭代，弄出一个辅助的头部节点指向当前head，然后就迭代链表，做每后两个节点node1，node2的交换，交换一次后，将当前节点指向node1，然后反复。之所以利用一个辅助节点，原因也在这儿方便返回。\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let returnHead = new ListNode(0);\r\n    returnHead.next = head;\r\n    let cur = returnHead;\r\n    while (cur && cur.next && cur.next.next) {\r\n        let node1 = cur.next;\r\n        let node2 = cur.next.next;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        cur.next = node2;\r\n        cur = node1;\r\n    }\r\n    return returnHead.next;\r\n};\r\n```\r\n## 思路\r\n变体：官方思路基础上，去除辅助的头部节点，利用一些判断，和每次迭代保存下来prevNode的方法，做交换当前和下一个节点的操作，另外返回的头部节点其实就是第一次迭代的cur.next。\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let returnHead;\r\n    let cur = head;\r\n    let prevNode;\r\n    while (cur && cur.next) {\r\n        if (!returnHead) {\r\n            returnHead = cur.next;\r\n        }\r\n        let node = cur.next;\r\n        cur.next = node.next;\r\n        node.next = cur;\r\n        if (prevNode) {\r\n            prevNode.next = node;\r\n        }\r\n        prevNode = cur;\r\n        cur = cur.next;\r\n    }\r\n    return returnHead;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843024683","body":"## 思路\r\n找到中间节点，然后就把链表分成了两段分别就是二叉排序树的左子树和右子树，然后再分别递归求左子树和右子树，一般二叉树相关的题目就要想到递归.\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if (!head) return null;\r\n    return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n    if (head == tail) return null;\r\n    let slow = head;\r\n    let fast = head;\r\n    while (fast != tail && fast.next != tail) {\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n    }\r\n    let root = new TreeNode(slow.val);\r\n    root.left = dfs(head, slow);\r\n    root.right = dfs(slow.next, tail);\r\n    return root;\r\n}\r\n```\r\n\r\n## 复杂度分析 遇到递归就不太会了 抄抄lucifer\r\n<https://algo91.herokuapp.com/solutionDetail?type=3&id=9&max_id=2> 学习一下这里面的复杂度分析\r\n+ 时间复杂度 O(nlogn)\r\n+ 空间复杂度 O(logn)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843672565","body":"## 思路\r\n双指针p1, p2，分别指向两条链表的头节点headA, headB，然后迭代，当\b各自的链表走到尾再指向另一条链表的头部，当他们相遇的时候，该节点就是交点，当他们没有交点，那就是p1指到headB的末尾，p2指到了headA的末尾，此时都为null，所以边界情况就是p1 == p2\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) return null;\r\n    let p1 = headA;\r\n    let p2 = headB;\r\n    while (p1 !== p2) { // 相等等于null的情况就是没有交点\r\n        p1 = p1 ? p1.next : headB;\r\n        p2 = p2 ? p2.next : headA;\r\n    }\r\n    return p1;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n+ 时间复杂度：O(m + n) m,n分别为链表的长度\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845160412","body":"## 思路\r\n- 快慢指针，快指针从头节点每次步进两个节点，慢指针从头节点每次步进一个。\r\n- 快指针每次步进都检测是否为 null 和是否等于 head，等于 head 返回 head，等于 null 表示没有环。\r\n- 当快慢指针第一次相遇后，快指针重新指向 head。\r\n- 快慢指针分别步进一个节点，当两个指针相遇的时候就是第一个环的入口点。\r\n\r\n## 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  if (!head || !head.next) return null;\r\n  let slow = head;\r\n  let fast = head;\r\n  while (slow != fast || fast == head) {\r\n    if (fast.next != null) {\r\n      fast = fast.next.next;\r\n    } else {\r\n      return null;\r\n    }\r\n    slow = slow.next;\r\n    if (fast == head) return head; // 回环\r\n    if (fast == null) return null; // 空了就没有环\r\n  }\r\n  fast = head;\r\n  while (slow != fast) {\r\n    fast = fast.next;\r\n    slow = slow.next;\r\n  }\r\n  return slow;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845654144","body":"## 思路\r\n先不考虑O(1)时间复杂度，用O(N)先完成。数据存储用map存，维护一个key值的队列。\r\n\r\n### put操作\r\n+ 步骤1：map中不存在该key，且不超过容量，key值推入队尾，存储数据到map。\r\n+ 步骤2：map中不存在该key，且超过容量，keyQueue队头出队，并移除map中该队头key值数据，并用新key进行步骤1。\r\n+ 步骤3：map中存在该key，改变map中key值数据，将该key在keyQueue中调整到队头。\r\n\r\n### get操作\r\n+ 步骤1：map中不存在该key，返回-1。\r\n+ 步骤2：map中存在该key，返回map中key值数据，将该key在keyQueue中调整到队头。\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n  this.capacity = capacity;\r\n  this.keyQueue = [];\r\n  this.map = {};\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n  if (this.map[key] === undefined) {\r\n    return -1;\r\n  } else {\r\n    const index = this.keyQueue.findIndex(item => item === key);\r\n    this.keyQueue.splice(index, 1);\r\n    this.keyQueue.push(key);\r\n    return this.map[key];\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n  if (this.map[key] === undefined) {\r\n    if (this.keyQueue.length < this.capacity) {\r\n      this.keyQueue.push(key);\r\n      this.map[key] = value;\r\n    } else {\r\n      delete this.map[this.keyQueue.shift()];\r\n      this.keyQueue.push(key);\r\n      this.map[key] = value;\r\n    }\r\n  } else {\r\n    const index = this.keyQueue.findIndex(item => item === key);\r\n    this.keyQueue.splice(index, 1);\r\n    this.keyQueue.push(key);\r\n    this.map[key] = value;\r\n  }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n+ 空间复杂度：O(N)\r\n+ 时间复杂度：将key值调整到队头这部操作需要O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846328750","body":"## 思路\r\n二叉树，基本都要想到用递归方法来做。\r\n+ 递归出口：没有节点返回0；没有左子树和没有右子树返回1。\r\n+ 递归主逻辑：父节点当层深度1 + Math.max(左子树深度，右子树深度)。\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  if (!root) return 0;\r\n  if (!root.left && !root.right) return 1;\r\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(h)，h为递归深度，最差情况为N"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846431372","body":"## 思路\r\n递归 DFS\r\n+ 递归出口：当根节点都为空就返回true，当根节点其中一个有值，其中一个没有值返回false。\r\n+ 递归主逻辑：两个根节点都不为空时，根节点值相等&&根节点间的左子树相等&&根节点间的右子树相等。\r\n\r\n## 代码\r\n``` javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if (!p && !q) return true;\r\n    if (p && q) {\r\n        return p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n    return false;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(N) 递归堆栈的开销"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836746634","body":"#### 思路：\r\n数组逆序遍历，然后从个位数开始相加，将结果push新数组，最后将新数组翻转\r\n要注意进位尤其是最后一位的进位还要注意k位数比num多的情况\r\n#### 代码 JS\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let res = []\r\n  for(let i = num.length-1; i>= 0; --i) {\r\n      let sum = num[i] + k%10\r\n      k = Math.floor(k / 10)\r\n\r\n      if(sum >=10) {\r\n          sum = sum % 10   \r\n          k++      \r\n        \r\n      }     \r\n\r\n      res.push(sum) \r\n  }\r\n   \r\n  for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n  for(let i =0; i<Math.floor(res.length/2); i++){\r\n      [res[i], res[res.length-1-i]] =  [res[res.length-1-i], res[i]]\r\n  }\r\n  return res\r\n};\r\n```\r\n#### 复杂度分析：\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335642","body":"#### 思路\r\n左右各遍历一次，然后看最小距离\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar shortestToChar = function(s, c) {\r\n   const l = s.length\r\n\r\n   let res = []\r\n   for(let i = 0; i< l; i++) {\r\n      if(s.charAt(i) === c){\r\n          res[i] = 0\r\n      } else {\r\n          res[i] = res[i-1] === void 0 ? Infinity : res[i-1] + 1\r\n      }\r\n   }\r\n   for(let i = l-1; i>=0; i--) {\r\n      if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n   }\r\n   return res\r\n};\r\n```\r\n#### 复杂度\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839693953","body":"#### 思路\r\n用js写栈还是比较简单的\r\n\r\n#### javascript\r\n``` javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n   this.data=[]\r\n   this.top = 0\r\n   this.length = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n   if(this.top>=this.length) {\r\n       return -1\r\n   }else {\r\n       this.data[this.top++] = x\r\n   }\r\n   \r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.top === 0 ? -1 : this.data[--this.top]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < this.top && i < k; i++){\r\n      this.data[i]+= val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n#### 复杂度\r\n+ 时间复杂度 O(n)\r\n+ 空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840637417","body":"#### 思路\r\n一个栈解决不了就用两个栈，一个用来存放重复的次数，一个用来存放字符串。比较关键的是入栈和出栈的时机。遇到`[`入栈遇到`]`出栈拼接子字符串，然后返回完整字符串。字符串的栈需要用空字符串占位\r\n#### 代码 JavaScript\r\n```JavaScript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let strStack = []\r\n  let numStack = []\r\n  let num = 0\r\n  let result = ''\r\n  for(let i =0; i<s.length; i++) {\r\n      let r = s.charAt(i) \r\n      if(isNaN(r) === false) {\r\n        num = num * 10 + Number(r)\r\n      } else if (r === '[') {\r\n        strStack.push(result)\r\n        result = ''\r\n        numStack.push(num)\r\n        num = 0\r\n      } else if (r === ']') {\r\n        result = strStack.pop() + result.repeat(numStack.pop())\r\n      } else {\r\n        result += r\r\n      }\r\n  }\r\n  return result\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度O(n) \r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841301485","body":"#### 思路\r\n用两个栈，一个存输入相关，一个存输出相关。输出为空时，就遍历输入栈压入输出栈，pop的正好是队列先入的元素\r\n#### 代码 javascript\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.data = []\r\n    this.temp = []\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.data.push(x)\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n       \r\n    } \r\n    return this.temp.pop()\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n   if(!this.temp.length){\r\n        while(this.data.length){\r\n             this.temp.push(this.data.pop())\r\n        }\r\n    } \r\n    return this.temp[this.temp.length-1]\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n   return !this.data.length && !this.temp.length\r\n};\r\n```\r\n#### 复杂度分析\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812842","body":"#### 思路\r\n首先确定最小移动位数，即k%len，然后快慢双指针找打倒数第一位和倒数k+1位，然后倒数第一位指向头，返回倒数第k位并将k+1位末尾指向null设为链表尾\r\n#### 代码 js\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) { \r\n  if (!head || !head.next) return head;\r\n  let res\r\n  let count = 0\r\n  let now = head\r\n  while(now) {\r\n      now = now.next\r\n      count++\r\n  }\r\n   k = k % count\r\n  let slow = (fast = head)\r\n  while(fast.next) {\r\n      if(k-- <= 0){\r\n        slow = slow.next\r\n      }\r\n      fast = fast.next\r\n  }\r\n  fast.next = head\r\n  res = slow.next;\r\n  slow.next = null\r\n  return res\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842315755","body":"#### 思路\r\n递归实现，头结点为空或者头结点的下一个节点为空时递归结束\r\n\r\n#### 代码 javascript\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (head === null|| head.next === null) {\r\n        return head;\r\n    }\r\n    const newHead = head.next;\r\n    head.next = swapPairs(newHead.next);\r\n    newHead.next = head;\r\n    return newHead;\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n空间复杂度：O(n)\r\n时间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843134361","body":"#### 思路\r\n快慢指正确定根节点然后递归 \r\n\r\n#### 代码 javascript\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n  return dfs(head, null);\r\n};\r\n\r\nfunction dfs(head, tail) {\r\n  if (head == tail) return null;\r\n  let fast = head;\r\n  let slow = head;\r\n  while (fast != tail && fast.next != tail) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n  }\r\n  let root = new TreeNode(slow.val);\r\n  root.left = dfs(head, slow);\r\n  root.right = dfs(slow.next, tail);\r\n  return root;\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n空间复杂度：O(nlogN)\r\n空间复杂度：O(logN)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845065418","body":"#### 思路\r\n其实用hash表更简单点，如果要空间复杂度O1的话使用快慢指针好一点。\r\n\r\n#### 代码 javascript\r\n```javascript\r\nvar detectCycle = function (head) {\r\n  let slow = head;\r\n  let fast = head;\r\n  while (fast) {\r\n    if (fast.next == null) { // fast.next走出链表了，说明无环\r\n      return null;\r\n    }\r\n    slow = slow.next;        // 慢指针走一步\r\n    fast = fast.next.next;   // 慢指针走一步\r\n    if (slow == fast) {      // 首次相遇\r\n      fast = head;           // 让快指针回到头节点\r\n      while (true) {         // 开启循环，让快慢指针相遇\r\n        if (slow == fast) {  // 相遇，在入环处\r\n          return slow;\r\n        }\r\n        slow = slow.next;\r\n        fast = fast.next;    // 快慢指针都走一步\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845949929","body":"#### 思路\r\n双向链表、哈希表\r\n#### 代码 js\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nfunction ListNode(key, val) {\r\n    this.key = key\r\n    this.val = val\r\n    this.pre = null\r\n    this.next = null\r\n}\r\n\r\nvar LRUCache = function(capacity) {\r\n    this.size = 0\r\n    this.capacity = capacity\r\n    this.map = {}\r\n    this.head = new ListNode()\r\n    this.tail = new ListNode()\r\n    this.head.next = this.tail\r\n    this.tail.pre = this.head\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(this.map[key]!== undefined) {\r\n      let node = this.map[key]\r\n      this.removeNode(node)\r\n      this.appendHead(node)\r\n      return node.val\r\n  } else {\r\n      return -1\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node;\r\n  if (this.map[key] !== undefined) {\r\n    node = this.map[key];\r\n    this.removeNode(node);\r\n    node.val = value;\r\n  } else {\r\n    node = new ListNode(key, value);\r\n    this.map[key] = node;\r\n    if (this.size < this.capacity) {\r\n      this.size++;\r\n    } else {\r\n      key = this.removeTail();\r\n      delete this.map[key];\r\n    }\r\n  }\r\n  this.appendHead(node);\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node){\r\n    let preNode = node.pre,\r\n    nextNode = node.next;\r\n    preNode.next = nextNode;\r\n    nextNode.pre = preNode;\r\n}\r\n\r\nLRUCache.prototype.appendHead  = function(node) {\r\n    let firstNode = this.head.next\r\n    this.head.next = node\r\n    node.pre = this.head\r\n    node.next = firstNode\r\n    firstNode.pre = node\r\n}\r\n\r\nLRUCache.prototype.removeTail = function() {\r\n    let key = this.tail.pre.key\r\n    let node = this.tail.pre\r\n    this.removeNode(node)\r\n    return key\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846410508","body":"#### 思路\r\ndfs\r\n\r\n#### 代码javascript\r\n```javascript\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0\r\n    } else {\r\n        let left = maxDepth(root.left)\r\n        let right = maxDepth(root.right)\r\n        return Math.max(left, right) + 1\r\n\r\n    }\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(h)h为树的高度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzdFeiFei":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836747177","body":"**思路**\r\n官方解法\r\n\r\n**代码：**\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const res = []\r\n    const n = num.length\r\n    for(let i = n-1;i>=0;i--){\r\n        let sum = num[i] + k % 10\r\n        k = Math.floor(k/10)\r\n        if(sum>=10){\r\n            k++\r\n            sum -= 10\r\n        }\r\n        res.push(sum)\r\n    }\r\n    for(;k>0;k = Math.floor(k/10)){\r\n        res.push(k % 10)\r\n    }\r\n    res.reverse()\r\n    return res\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n- 空间复杂度：O(1)O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838672483","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839832262","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631219","body":"```\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841283761","body":"```\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LASIWan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836748306","body":"### 思路\r\n采用每一位分别相加，并判断是否进位的方法：\r\n1、声明一个空数组\r\n2、从末位开始循环数组的每一位，并与加数k按位相加\r\n3、判断是否需要进位，当和大于10时，将结果存入下一位\r\n4、通过数组方法将存入顺序颠倒即可\r\n\r\n\r\n\r\n### JavaScript\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0; --i) {\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if (sum >= 10) {\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);\r\n    }\r\n    for (; k > 0; k = Math.floor(k / 10)) {\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838531788","body":"### 思路\r\n\r\n判断目标字符与数组每一位的最小距离，那么则有几种情况\r\n目标在左侧，直接用当前位置减去目标index；\r\n目标在右侧，直接用目标index减去当前位置；\r\n两侧都有目标，则比较两侧之前的距离取最小值。\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar shortestToChar = function(s,c){\r\n    let res = Array(s.length).fill(0);\r\n    \r\n\r\n    for(let i=0; i<s.length; i++){\r\n        if (s[i] === c) continue;\r\n\r\n        let l = i;\r\n        let r = i;\r\n        let shortest = Infinity;\r\n\r\n        while(l>=0){\r\n            if(s[l]===c){\r\n                shortest = Math.min(shortest, i-l); \r\n                break;\r\n            }\r\n            l--;\r\n        }\r\n        while(r<s.length){\r\n            if(s[r]===c){\r\n                shortest = Math.min(shortest,r-i);\r\n                break;\r\n            }\r\n            r++;\r\n        }\r\n        res[i]=shortest;\r\n    }\r\n    return res;\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N方)，两层循环。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839846195","body":"### 思路\r\n通过数组来模拟栈，使用push（）和pop（）方法实现入栈和出栈的操作。\r\n\r\n### 代码\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.list = []\r\n  this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n    this.list.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  const item = this.list.pop()\r\n  return item === void 0 ? -1 : item\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < k && i < this.list.length; i++) {\r\n    this.list[i] += val\r\n  }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(n)"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842303197","body":"### 思路\r\n\r\n1、给定一个虚拟的初始节点\r\n2、通过这个虚拟的初始节点可以找到真实的头节点\r\n3、用这个虚拟节点加上需要交换的节点，进行改变\r\n\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar swapPairs = function(head) {\r\n    let thead = new ListNode(0);\r\n    thead.next = head;\r\n    let tmp = thead;\r\n    while(tmp.next != null && tmp.next.next != null){\r\n        let start = tmp.next;\r\n        let end = start.next;\r\n        tmp.next = end;\r\n        start.next = end.next;\r\n        end.next = start;\r\n        tmp = start;\r\n    }\r\n    return thead.next;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fakerbaby":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751618","body":"## [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n难度:**简单**\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\r\n\r\n---\r\n\r\n**思路1**\r\n\r\n首先将原属组转化成字符串，然后转换成整型相加然后在切分成数组。最后返回数组为所求。\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        tmp = ''\r\n        for index in num:\r\n            tmp += str(index)\r\n        res_int = int(tmp) + k\r\n        res = [int(x) for x in str(res_int)]\r\n        return res\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(1)\r\n\r\n---\r\n\r\n**思路2**\r\n\r\n```\r\n<加法模板>    \r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗\r\n```\r\n\r\n**代码**\r\n\r\n~~~python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        i = len(A) - 1\r\n        while K:\r\n            A[i] += K\r\n            K, A[i] = A[i] // 10, A[i] % 10\r\n            i -= 1\r\n            if i < 0 and K:\r\n                A.insert(0,0)\r\n                i = 0\r\n        return A\r\n\r\n\r\n~~~\r\n\r\n\r\n\r\n**复杂度**\r\n\r\n时间：O(n)\r\n\r\n空间：O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838706823","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 难度简单\r\n\r\n给你一个字符串 `s` 和一个字符 `c` ，且 `c` 是 `s` 中出现过的字符。\r\n\r\n返回一个整数数组 `answer` ，其中 `answer.length == s.length` 且 `answer[i]` 是 `s` 中从下标 `i` 到离它 **最近** 的字符 `c` 的 **距离** 。\r\n\r\n两个下标 `i` 和 `j` 之间的 **距离** 为 `abs(i - j)` ，其中 `abs` 是绝对值函数。\r\n\r\n---\r\n\r\n### 思路baseline:\r\n\r\n朴素算法，首先把c字符位置用数组记录，然后依次比较所有来得到最近的距离。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        pos,i = [],0 #pos记录位置\r\n        for e in s:\r\n            if e == c:\r\n                pos.append(i)\r\n            i += 1\r\n        Len = len(s)\r\n        ans = [0]*(Len)\r\n        min = Len\r\n        for b in range(Len):\r\n            min = Len\r\n            for c in pos:\r\n                min = min if min <= abs(b-c) else abs(b-c)\r\n                print(b)\r\n            ans[b] = min\r\n        return ans\r\n        \r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n^2)\r\n\r\n空间：$O(n)\r\n\r\n---\r\n\r\n### 思路strongline:\r\n\r\n从左向右和从右向左分别遍历一边，然后取最小的距离\r\n\r\n### 代码：\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：$O(n)\r\n\r\n空间：$O(n)\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839838332","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x`添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n\r\n\r\n---\r\n\r\n### 思路1\r\n\r\n直接模拟法\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.top = -1\r\n        self.stk = [0] * maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        x = self.stk[self.top]\r\n        self.top -= 1\r\n        return x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0,min(self.top+1, k)):\r\n            self.stk[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n\r\n\r\n\r\n### 算法复杂度\r\n\r\n时间:$O(1)\r\n\r\n空间:$O(1)\r\n\r\n\r\n\r\n\r\n\r\n---\r\n\r\n### 思路2（前缀和）\r\n\r\n见力扣++\r\n\r\n### 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n        self.incrementals = [0] * size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        if self.cnt >= 2:\r\n            self.incrementals[self.cnt - 2] += self.incrementals[self.cnt - 1]\r\n        ans = self.st.pop() + self.incrementals[self.cnt - 1]\r\n        self.incrementals[self.cnt - 1] = 0\r\n        self.cnt -= 1\r\n        return ans\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n            if self.cnt:\r\n                self.incrementals[min(self.cnt, k) - 1] += val\r\n```\r\n\r\n### 复杂度：\r\n\r\n都是O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644881","body":"\r\n\r\n# [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k*，例如不会出现像 `3a` 或 `2[4]` 的输入。 \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n```\r\n\r\n**示例 4：**\r\n\r\n```\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n```\r\n\r\n---\r\n\r\n### 思路(迭代)\r\n\r\n主要还是利用栈的思想，然后使用迭代的方法。吧“】”前的内容入栈，当遇到“】”需要出栈，结合【】的内容和数字进行不断迭代直到字符串s结尾。\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for cha in s:\r\n            if cha == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                #pop '['\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount  \r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(cha)\r\n        return \"\".join(stack)\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间:$O(n)$\r\n\r\n空间:$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841172315","body":"# [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n难度简单\r\n\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\r\n\r\n实现 `MyQueue` 类：\r\n\r\n- `void push(int x)` 将元素 x 推到队列的末尾\r\n- `int pop()` 从队列的开头移除并返回元素\r\n- `int peek()` 返回队列开头的元素\r\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\r\n\r\n \r\n\r\n**说明：**\r\n\r\n- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\r\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n**进阶：**\r\n\r\n- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n**示例：**\r\n\r\n```\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n```\r\n\r\n\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= x <= 9`\r\n- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`\r\n- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）\r\n\r\n---\r\n\r\n思路：\r\n\r\n无非是用两个栈来模拟队列，经典题目，一个为主栈，另一个是辅助栈保证queue的先进后出涉及到两个栈的互相“倾倒”\r\n\r\n代码：\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk1 = []\r\n        self.stk2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stk1:\r\n            self.stk2.append(self.stk1.pop())\r\n        self.stk2.append(x)\r\n        while self.stk2:\r\n            self.stk1.append(self.stk2.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stk1.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stk1[-1]\r\n        \r\n        \r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stk1)\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841648560","body":"# [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n难度困难\r\n\r\n*这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为`2000`，其中的元素最大为`10**8`。*\r\n\r\n`arr`是一个可能包含**重复元素**的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\r\n\r\n我们最多能将数组分成多少块？\r\n\r\n**示例 1:**\r\n\r\n```\r\n输入: arr = [5,4,3,2,1]\r\n输出: 1\r\n解释:\r\n将数组分成2块或者更多块，都无法得到所需的结果。\r\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \r\n```\r\n\r\n**示例 2:**\r\n\r\n```\r\n输入: arr = [2,1,3,4,4]\r\n输出: 4\r\n解释:\r\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\r\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \r\n```\r\n\r\n**注意:**\r\n\r\n- `arr`的长度在`[1, 2000]`之间。\r\n- `arr[i]`的大小在`[0, 10**8]`之间。\r\n\r\n---\r\n\r\n思路：\r\n\r\n类似于“融合区块”的思维，在遍历的时候找到比栈自己大或相等的入栈，如果小的话则融合。\r\n\r\n代码：\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for a in arr:\r\n            if stack and stack[-1] > a:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > a:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else: stack.append(a)\r\n        return len(stack)\r\n```\r\n\r\n\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841761582","body":"# [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n难度中等\r\n\r\n给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。\r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n```\r\n\r\n**示例 2：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg)\r\n\r\n```\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n```\r\n\r\n**提示：**\r\n\r\n- 链表中节点的数目在范围 `[0, 500]` 内\r\n- `-100 <= Node.val <= 100`\r\n- `0 <= k <= 2 * 109`\r\n\r\n---\r\n\r\n思路：\r\n\r\n​\t单链表成环，然后确定新链表的头节点，然后断开即可。\r\n\r\n代码：\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    # 融合成环找到头节点再断开\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n\r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        print(n)\r\n        start = n - k % n\r\n        \r\n        #连接成环\r\n        cur.next = head\r\n        while start > 0:\r\n            cur = cur.next\r\n            start -= 1\r\n        newhead = cur.next\r\n        cur.next = None\r\n        return newhead      \r\n```\r\n\r\n复杂度：\r\n\r\n时间：$O(n)$\r\n\r\n空间：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842409446","body":"#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n难度中等\r\n\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\r\n\r\n```\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：head = []\r\n输出：[]\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：head = [1]\r\n输出：[1]\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- 链表中节点的数目在范围 `[0, 100]` 内\r\n- `0 <= Node.val <= 100`\r\n\r\n\r\n\r\n---\r\n\r\n思路：\r\n\r\n利用递归解决这种规律性的题目很快，把后半段看成整体，然后做前后交换的操作。\r\n\r\n代码：\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newHead = head.next\r\n        head.next = self.swapPairs(newHead.next)\r\n        newHead.next = head\r\n        return newHead\r\n```\r\n\r\n\r\n\r\n复杂度：\r\n\r\n时间: $O(n)$\r\n\r\n空间: $O(1)$\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843735395","body":"\r\n\r\n\r\n\r\n# [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n难度简单1132\r\n\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\n如下面的两个链表**：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\r\n\r\n在节点 c1 开始相交。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\r\n\r\n```\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Reference of the node with value = 8\r\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n```\r\n\r\n \r\n\r\n**示例 2：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\r\n\r\n```\r\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Reference of the node with value = 2\r\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n```\r\n\r\n \r\n\r\n**示例 3：**\r\n\r\n[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\r\n\r\n```\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n解释：这两个链表不相交，因此返回 null。\r\n```\r\n\r\n \r\n\r\n**注意：**\r\n\r\n- 如果两个链表没有交点，返回 `null`.\r\n- 在返回结果后，两个链表仍须保持原有的结构。\r\n- 可假定整个链表结构中没有循环。\r\n- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。\r\n\r\n思路：\r\n\r\n​\ta + b +c = b + a + c\r\n\r\n代码：\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        curr1, curr2 = headA, headB\r\n        while curr1 != curr2:\r\n            curr1 = curr1.next if curr1 else headB\r\n            curr2 = curr2.next if curr2 else headA\r\n        return curr1\r\n        \r\n```\r\n\r\n复杂度：\r\n\r\n时间：$O(n+m)$,n,m两个单链表的长度\r\n\r\n空间：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845183851","body":"# [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n难度中等\r\n\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。\r\n\r\n为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**\r\n\r\n**说明：**不允许修改给定的链表。\r\n\r\n**进阶：**\r\n\r\n- 你是否可以使用 `O(1)` 空间解决此题？\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)\r\n\r\n```\r\n输入：head = [3,2,0,-4], pos = 1\r\n输出：返回索引为 1 的链表节点\r\n解释：链表中有一个环，其尾部连接到第二个节点。\r\n```\r\n\r\n**示例 2：**\r\n\r\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\r\n\r\n```\r\n输入：head = [1,2], pos = 0\r\n输出：返回索引为 0 的链表节点\r\n解释：链表中有一个环，其尾部连接到第一个节点。\r\n```\r\n\r\n**示例 3：**\r\n\r\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\r\n\r\n```\r\n输入：head = [1], pos = -1\r\n输出：返回 null\r\n解释：链表中没有环。\r\n```\r\n\r\n---\r\n\r\n思路：\r\n\r\n快慢指针\r\n\r\n代码：\r\n\r\n```python3\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n```\r\n\r\n\r\n\r\n复杂度：\r\n\r\n时间:O(n)\r\n\r\n空间:O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuris304":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836751629","body":"## 思路\r\n从末尾开始依次往前模拟加法运算\r\n\r\n## 关键点\r\n\r\n-  结束条件 num到首位& k加完 & 进位为0\r\n-  每次循环中要判断数组索引是否越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<Integer>();\r\n        int n=num.length-1;int flag=0;\r\n        while(n>-1||k!=0||flag!=0){\r\n            int tep;\r\n            if(n<0) tep=k%10+flag;\r\n            else tep=k%10+num[n]+flag;\r\n            k/=10;\r\n            flag=tep/10;\r\n            tep=tep%10;\r\n            res.add(0,tep);\r\n            n--;\r\n        }\r\n        return res;      \r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(log(k),n))$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838315989","body":"## 思路\r\n正反各一次遍历，第一次正向记录每一个字符与上一个目标字符的距离，第二次反向保留距离最小值\r\n\r\n## 关键点\r\n\r\n-  初始化用MAX_VALUE/2的形式，避免越界\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] S=s.toCharArray();\r\n        int[] res=new int[S.length];\r\n        int dis=Integer.MAX_VALUE/2;\r\n        for(int i=0;i<S.length;i++){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=dis++;\r\n        }\r\n        for(int i=S.length-1;i>-1;i--){\r\n            if(S[i]==c) dis=0;\r\n            res[i]=Math.min(dis++,res[i]);\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840242460","body":"\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res=new StringBuilder();\r\n        int times=0;\r\n        Stack<Integer> timesStack=new Stack<Integer>();\r\n        Stack<String> strStack=new Stack<String>();\r\n        for(char c:s.toCharArray()){\r\n            if(c>='0'&&c<='9'){\r\n                times=times*10+c-'0';\r\n            }\r\n            else if(c=='['){\r\n                timesStack.push(times);\r\n                times=0;\r\n                strStack.push(res.toString());\r\n                res=new StringBuilder();\r\n            }\r\n            else if(c==']'){\r\n                int multi=timesStack.pop();\r\n                StringBuilder tem=new StringBuilder();\r\n                for(int i=0;i<multi;i++){\r\n                    tem.append(res);\r\n                }\r\n                res=new StringBuilder(strStack.pop()+tem);\r\n            }\r\n            else{\r\n                res.append(c);\r\n            }\r\n        }\r\n\r\n        return res.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841070258","body":"class MyQueue {\r\n    private Stack<Integer> stack1;\r\n    private Stack<Integer> stack2;\r\n    private int front;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(stack1.empty()){front=x;}\r\n        stack1.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.empty()){\r\n            while(!stack1.empty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!stack2.empty()){\r\n            return stack2.peek();\r\n        }\r\n        return front;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return(stack1.empty()&&stack2.empty());\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841622622","body":"\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s=new Stack<>();\r\n        for(int i:arr){\r\n            if(!s.empty()&&s.peek()>i){\r\n                int max=s.peek();\r\n                while(!s.empty()&&s.peek()>i){\r\n                s.pop();\r\n                }\r\n                s.push(max);\r\n            }else{\r\n                s.push(i);\r\n            }      \r\n        }\r\n        return(s.size());\r\n    }\r\n}\r\n\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842372452","body":"```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy=new ListNode(0);\r\n        dummy.next=head;\r\n        ListNode pre=dummy;\r\n        while(pre.next!=null&&pre.next.next!=null){\r\n            ListNode n1=pre.next;\r\n            ListNode n2=n1.next;\r\n            n1.next=n2.next;\r\n            n2.next=n1;\r\n            pre.next=n2;\r\n\r\n            pre=n1;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Hazelnuttt":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836754397","body":"### 思路\r\n把 num 和 k 都转成数组，进行大数相加\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  k = k.toString().split(\"\").map(item => Number(item));\r\n\r\n  let carry = 0;\r\n  let result = []\r\n  while(num.length || k.length) {\r\n    carry += ~~num.pop() + ~~k.pop();\r\n    if(carry < 10){\r\n      result.unshift(carry);\r\n      carry = 0;\r\n    }else{\r\n      result.unshift(carry - 10);\r\n      carry = 1;\r\n    }\r\n  }\r\n\r\n  if(carry){\r\n    result.unshift(carry);\r\n    return result;\r\n  }else{\r\n    return result;\r\n  }\r\n\r\n\r\n};\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838578435","body":"### 解题思路\r\n贪心算法\r\n左边遍历，最小距离是多少，右边遍历，最小距离是多少，最后遍历取最小值\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar shortestToChar = function (s, c) {\r\n  let n = s.length;\r\n  let dp = new Array(n).fill(0);\r\n  let leftDp = new Array(n).fill(0);\r\n  let rightDp = new Array(n).fill(0);\r\n\r\n  let prev = -Infinity;\r\n  for(let i = 0; i < n; i++) {\r\n    if(s[i] === c) prev = i;\r\n    leftDp[i] = i - prev;\r\n  }\r\n\r\n  prev = Infinity;\r\n  for(let i = n - 1; i >= 0; i--) {\r\n    if(s[i] === c) prev = i;\r\n    rightDp[i] = prev - i;\r\n  }\r\n\r\n  for(let i = 0; i < n; i++){\r\n    dp[i] = Math.min(rightDp[i], leftDp[i])\r\n  };\r\n\r\n  return dp;\r\n\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839808257","body":"### 解题思路\r\n考察数组实现栈的一些基本操作，入栈 => 数组push，出栈 => 数组pop，inc => 数组遍历\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length === this.maxSize) return;\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length === 0) return -1;\r\n  return this.stack.pop();\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  if(k > this.stack.length) k = this.stack.length;\r\n  for(let i = 0; i < k; i++) {\r\n    this.stack[i] += val\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618300","body":"### 解题思路\r\n没有完成栈，暂时实现的没有嵌套的\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  let num = 0;\r\n  let str ;\r\n  let result = \"\";\r\n  for(let i = 0; i < s.length; i++) {\r\n    if(s[i] >= \"0\" && s[i] <= \"9\") {\r\n      num = num * 10 + Number(s[i]);\r\n    }\r\n    if(s[i] === \"[\") {\r\n      str = \"\";\r\n    }\r\n    if(s[i] === \"]\") {\r\n      for(let j = 0; j < num; j++) {\r\n        result += str;\r\n      }\r\n      str = \"\";\r\n      num = 0\r\n    }\r\n    if(s[i] >= \"a\" && s[i] <= \"z\") {\r\n      str += s[i];\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n```"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843241164","body":"### 解题思路\r\n先处理特殊情况，接着把链表遍历成数组，能用二分法获取到中位数\r\n然后根据中位数构建根节点，递归构建根节点的左子树和右子树\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n  if(head === null) return null;\r\n  if(head.next === null) return new TreeNode(head.val);\r\n\r\n  let arr = []\r\n  //遍历链表成数组\r\n  while(head) {\r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n\r\n  let tree = buildTree(arr, 0, arr.length - 1);\r\n  return tree;\r\n};\r\n\r\nfunction buildTree(arr, left, right) {\r\n  if(right < left) return null;\r\n\r\n  if(left === right) return new TreeNode(arr[left]);\r\n\r\n  let mid = Math.floor((left + right) / 2);\r\n  let tree = new TreeNode(arr[mid]);\r\n  tree.left = buildTree(arr, left, mid - 1);\r\n  tree.right = buildTree(arr, mid + 1, right);\r\n  return tree;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844150025","body":"### 解题思路\r\n首先处理边界条件，如果headA或headB其中一个为null，则没有公共节点。\r\n然后用双指针，只要head1 不等于 和 head2，让它一直递归到最后。然后到另一个节点头。\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n  if(headA === null || headB === null) {\r\n    return null;\r\n  }\r\n\r\n  let head1 = headA;\r\n  let head2 = headB;\r\n  while(head1 != head2) {\r\n    if(head1 != null) {\r\n      head1 = head1.next;\r\n    }else{\r\n      head1 = headB\r\n    }\r\n\r\n    if(head2 != null) {\r\n      head2 = head2.next;\r\n    }else {\r\n      head2 = headA;\r\n    }\r\n  }\r\n\r\n  return head1;\r\n    \r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845163238","body":"### 解题思路\r\n使用一个map记录节点，如果map存在该节点了，它就是环形链表里的第一个\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n  let map = new Map();\r\n\r\n  while(head) {\r\n    if(map.has(head)) {\r\n      return head;\r\n    }\r\n    map.set(head, true);\r\n    head = head.next;\r\n  }\r\n  return null;\r\n    \r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846401085","body":"### 解题思路\r\n层序遍历\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  let arr = [];\r\n  let res = 0;\r\n  if(root) {\r\n    arr.push(root);\r\n  }\r\n  while(arr.length != 0) {\r\n    let n = arr.length;\r\n    while(n != 0) {\r\n      let temp = arr.shift();\r\n      if(temp.left) arr.push(temp.left);\r\n      if(temp.right) arr.push(temp.right);\r\n      n--\r\n    }\r\n    res ++;\r\n  }\r\n  return res;\r\n\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"WIN0624":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836759785","body":"## 思路\r\n\r\n* 把K加入A中，降低空间复杂度\r\n    * 从A的最后一位开始遍历，先将K（carry初始化为K）与最后一位相加，保留余数，整除10之后进位，直至carry为0\r\n    * 时间复杂度：O(N+max(0, K-N))\r\n    * 空间复杂度：O(max(1, K-N))\r\n* 难点：两者长度不等的情况，如何处理\r\n    * 若两者相等，最后多出的carry，新建B，把往A头部补位，变成B和A相加\r\n    * 若A长于B，则carry为0，不影响A继续补位\r\n    * 若B长于A， 则等同于有多出carry，B的补位可以直接通过数组相加，把当前位当做一个数组\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        carry = k\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (num[i] + carry) % 10, (num[i] + carry) // 10\r\n\t# deal with remain\r\n        B = []\r\n        while carry > 0:\r\n            B = [carry % 10] + B\r\n            carry //= 10\r\n        \r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：O(N+max(0, K-N))\r\n  * 空间复杂度：O(max(1, K-N))"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717744","body":"## 思路\r\n\r\n  * 从左往右遍历一次，只记录到上一个C元素的距离（即在其右边的C），为`i-prev`\r\n  * 从右往左遍历一次，只记录到上一个C元素的距离(即在其左边的C）, 为`prev-i`\r\n  * 两个数组对应位数取最小值\r\n  * 要点\r\n      * 记住上一个，而非下一个，使得可以一边往后遍历，一边往ans加元素\r\n      * 不必分开两个数组存储，就存到一个，只不过第二次遍历的时候增加一个min的比较\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nClass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        ans = []\r\n        # left to right iteration\r\n        prev = float('-inf')\r\n        for num, val in enumerate(S):\r\n            if val == C:\tprev = num\r\n            ans.append(num - prev)\r\n\t\t\r\n        # right to left iteration\r\n        prev = float('inf')\r\n        for num in range(len(S) - 1, -1, -1):\r\n            if S[num] == C:\tprev = num\r\n            ans[num] = min(ans[num], prev - num)\r\n        \r\n        return ans\r\n```\r\n\r\n## 复杂度分析\r\n\r\n  * 时间复杂度：$O(N)$\r\n  * 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839874545","body":"## 思路\r\n\r\n* 用数组`incremental`存储当前栈中每个元素的增加信息，之后pop的时候直接加上\r\n\r\n* **数据结构**\r\n\r\n    * 数组的第i位，存储第0-i个元素的增加信息\r\n    * 栈顶元素的增加信息 = incremental[-1]\r\n    * 其余元素的增加信息 = sum(incremental[i:-1]) => 所以在pop栈顶的时候，需要把栈顶元素的数值保留到倒数第二位元素以作穿成\r\n\r\n* **算法**\r\n\r\n    * 当push一个元素，incremental也push一个0；\r\n\r\n    * 当pop一个元素，incremental也pop作为当前元素的增加\r\n\r\n    * 但是当前pop的元素也是剩余元素需要的增加信息，这个时候，将这个信息加到incremental[-2] \r\n\r\n        > 每次只有栈顶元素能找到准确的增加信息incremental[-1]，其余元素都需要等叠加\r\n\r\n## 代码 | Python\r\n\r\n```\r\nclass CustomStack(object):\r\n    \"\"\"A class of stack with increment method.\"\"\"\r\n    \r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack, self.size, self.memo = [], 0, []\r\n    \r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n            self.memo.append(0)\r\n    \r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            self.size -= 1\r\n            add_num = self.memo.pop()\r\n            if self.memo:\r\n                self.memo[-1] += add_num \r\n            return self.stack.pop() + add_num\r\n        else:\r\n            return -1\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if k < len(self.memo):\r\n            self.memo[k - 1] += val\r\n        elif self.memo:\r\n            self.memo[-1] += val\r\n```\r\n\r\n\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度: O(1)\r\n* 平均空间复杂度：O(cnt/N)，N为操作数，cnt为操作过程中栈的最大长度（<=maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655220","body":"## 思路\r\n\r\n* 四种可能字符\r\n    * 遇到数字，开始累加\r\n    * 遇到左括号，累加数字放入栈，获取括号内部字符串，清空数字\r\n    * 遇到右括号，在当前字符串 * 累加数字（从栈中pop出）\r\n    * 普通字母，直接加到当前函数的解码字符串中\r\n* def：记得更新索引\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def get_inner_str(s, i, stack):\r\n            decode_str = ''      # init decode_str\r\n            accum_num = []\r\n            while i < len(s):\r\n                if s[i] >= '0' and s[i] <= '9':\r\n                    accum_num.append(s[i])\r\n                elif s[i] == '[':\r\n                    stack.append(int(''.join(accum_num)))\r\n                    inner_str, i = get_inner_str(s, i+1, stack)\r\n                    decode_str += inner_str\r\n                    accum_num = []\r\n                elif s[i] == ']':\r\n                    return stack.pop() * decode_str, i\r\n                else:\r\n                    decode_str += s[i]\r\n                i += 1\r\n            return decode_str\r\n                    \r\n        return get_inner_str(s, 0, [])\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(N)，N为当前字符串长度\r\n* 空间复杂度：O(M)，M为解码后字符串长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841023385","body":"## 思路\r\n\r\n* 难点：时间复杂度如何实现 => 要认识到这是平均时间复杂度\r\n\r\n* 在需要pop/peek的时候，若输出栈空，则将输入栈的元素依次pop到输出栈\r\n\r\n    > 转移操作的时间复杂度为$O(N)$，N为当前已压入元素，但可以保证此后N次PEEK/POP的操作为$O(1)$时间复杂度，总用时也是$O(N)$\r\n    >\r\n    > 题目中的提示：In other words, performing `n` operations will take overall `O(n)` time even if one of those operations may take longer.\r\n\r\n## 代码 | Python\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.input_stack = []\r\n        self.output_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.input_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.output_stack:\r\n            self._transfer()\r\n        if not self.empty():\r\n            return self.output_stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.output_stack:\r\n            self._transfer()\r\n        if not self.empty():\r\n            return self.output_stack[-1]\r\n        else:\r\n            return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not (self.input_stack or self.output_stack)\r\n    \r\n    def _transfer(self):\t# 注意封装复用的代码\r\n        while self.input_stack:\r\n            self.output_stack.append(self.input_stack.pop())\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 平均时间复杂度\t\r\n    * push: $O(1)$\r\n    * pop：$O(N)$\r\n* 空间复杂度：$O(N)$，N是压入的元素总数"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842275602","body":"## 思路\r\n\r\n* head为空或仅有一个节点 => 返回头节点\r\n* 两两交换，每个节点存储前一个节点，当遍历到单数需要的节点就进行交换操作\r\n    * 下一个节点非空的时候进行如下操作\r\n    * temp = curr.next.next\r\n    * prev.next = curr.next\r\n    * curr.next.next = curr\r\n    * curr.next = temp\r\n* 初次交换时，需要存储新链表的头节点，即原链表的第二个节点\r\n* 终止条件\r\n    * 每次只遍历单数节点，若链表长度为偶数，则出现head=None的情况\r\n    * 若长度为奇数，则head.next为None，该节点也不必交换\r\n\r\n## 代码 | Python\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        # special case\r\n        if not head or not head.next:\r\n        \treturn head\r\n        count, prev = 1, ListNode(-1)\r\n        # 遇到最后一个节点即终止\r\n        while head and head.next:\t\r\n            if count % 2 != 0:\r\n                temp = head.next.next\r\n                prev.next = head.next\r\n                head.next.next = head\r\n                head.next = temp\r\n            if count == 1:\r\n                listhead = prev.next\r\n            prev = head\r\n            head = head.next\r\n            count += 1\r\n        \r\n        return listhead\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(N)，N是链表长度\r\n* 空间复杂度：O(1)\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844118507","body":"## 思路\r\n\r\n* 当结束当前自己链表的遍历后，切换到对方头节点，则两方相遇时，A+C+B=B+C+A\r\n* 如何判断没有相交点：只用看一个指针是否第二次为None即可，因为两个指针是同时达到第二次None（路程均为A+B）\r\n\r\n## 代码 | Python\r\n\r\n```\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n\r\n        return a\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(A+B)，复杂度最差为没有相交节点的情况，A和B都要遍历\r\n\r\n    > 若有相交节点，则遍历A之后，只用遍历B的一部分\r\n\r\n* 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845204497","body":"## 思路\r\n\r\n* 快慢指针：当两节点第一次相遇时，将一个指针移至链表头，另一个指针保留在原地，则第二次相遇为环的入口\r\n\r\n    > fast = A + (B+C) * n = A +  B + C + (B+C)*(n-1)\r\n    >\r\n    > slow = A + B\r\n    >\r\n    > 2xslow = fast => A = C + (B+C)*(n-1)\r\n\r\n* 无环的时候会如何？\r\n\r\n    * fast会为None\r\n\r\n* corner case\r\n\r\n    * 只有一个头节点或头节点为空\r\n    * 自循环？目前算法支持，但也可事先处理\r\n\r\n* 整体流程\r\n\r\n    * 第一次循环：fast两步，slow一步，直至两者相等 => fast初始化易错（不能跟slow同时被head赋值，进不去循环）\r\n\r\n        > 若fast为None（偶数个时发生）或fast.next为None（奇数个时发生）\r\n        >\r\n        > [1,2,3,4]或[1,2,3,4,5]\r\n\r\n    * 将fast重定位至listhead\r\n\r\n    * 第二次循环：fast一步，slow一步，直至两者相等\r\n\r\n    * 返回fast\r\n\r\n* **易错点**\r\n\r\n    * 快慢指针初始化必须都为head\r\n\r\n        > 之前保持条件为fast!=slow, 初始化改为fast, slow = head.next.next, head.next => 导致推理失效，以为两者起点不同了，则2*slow=fast也不对！！\r\n\r\n    * 条件不能写fast != slow，否则直接返回head\r\n\r\n## 代码 | Python\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        # 处理边界情况\r\n        if not head or not head.next:\r\n            return None\r\n        elif head == head.next:\r\n            return head\r\n        \r\n        fast = slow = head\r\n        while True:\r\n            if fast and fast.next:\r\n                fast, slow = fast.next.next, slow.next\r\n            else:\r\n                return None\r\n            if fast == slow:\tbreak\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        \r\n        return fast\r\n```\r\n\r\n## 复杂度分析\r\n\r\n* 时间复杂度：O(N), N是链表长度\r\n\r\n    > 只看慢指针走的步数，第一次相遇时，路程为A+B，第二次相遇时，路程为A+B+C，恰为链表长度\r\n\r\n* 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShunzWu012":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836761592","body":"### 思路\r\n按位相加，注意k的长度可能比num大\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int n = num.length;\r\n        for(int i = n - 1; i >= 0; i--){\r\n            int sums = num[i] + k % 10;\r\n            k /= 10;\r\n            if(sums >= 10){\r\n                k++;\r\n            }\r\n            ans.add(sums%10);\r\n        }\r\n        while(k != 0){\r\n            ans.add(k%10);\r\n            k /= 10;\r\n        }\r\n        n = ans.size();\r\n        for(int i = 0; i < n/2; i++){\r\n            int temp = ans.get(i);\r\n            ans.set(i, ans.get(n-i-1));\r\n            ans.set(n-i-1, temp);\r\n        }\r\n        return  ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(max(n, log(10, k)))\r\n- S:O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837715789","body":"### 思路\r\n对于每个字符而言，只需要比较当前字符到两边c的最短距离即可。\r\n\r\n注;为了不讨论左端点和右端点，对索引数组进行预处理，两端加上一个大值。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> idx = new ArrayList<>();\r\n        int n = s.length();\r\n        idx.add(n);\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                idx.add(i);\r\n            }\r\n        }\r\n        idx.add(n*2);\r\n        int[] ans = new int[n];\r\n        int j = 0;\r\n        for(int i = 0; i < n; i++){\r\n            if(s.charAt(i) == c){\r\n                ans[i] = 0;\r\n                j++;\r\n            }\r\n            else{\r\n                ans[i] = Math.min(Math.abs(i - idx.get(j)), Math.abs(idx.get(j+1) - i));\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839779296","body":"### 思路\r\n要保持栈底的Inc运算，如果真的使用一个栈，那么在每次操作时候，都会全部入栈出栈一次，花销增加。\r\n使用一个数组代替这个固定栈，用索引位置记录栈顶位置。\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n    private int curPos;\r\n    private int[] stack;\r\n    private int stackSize;\r\n    public CustomStack(int maxSize) {\r\n        curPos = -1;\r\n        stackSize = maxSize;\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(curPos + 1 < stackSize){\r\n            curPos++;\r\n            stack[curPos] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return curPos == -1 ? -1: stack[curPos--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < Math.min(k, curPos+1); i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n### 复杂度分析\r\n&bnsp; | Time | Space\r\n--- | --- | ---\r\npush | O(1) | O(maxSize)\r\npop| O(1) | O(maxSize)\r\ninc| O(min(k, maxSize)) | O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840430499","body":"### 思路\r\n一个字符栈，一个数字栈。\r\n题目规定了，一定为k[encoding]的形式，\r\n那么，把每一个括号对中的内容提取出来后，和前一个数字做一个乘法运算就搞定啦。\r\n\r\n1. 遇到数字，继续遍历，直到非数字，入数字栈；\r\n2. 遇到 \"]\"，字符栈出栈，直到“[”，重新入栈；\r\n3. 其他情况，入字符栈\r\n\r\n### 代码(Java/Cpp/python3)\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> charStack = new Stack<>();\r\n        Stack<Integer> cnts = new Stack<>();\r\n        int i = 0;\r\n        int n = s.length();\r\n        while(i < n){\r\n            if(Character.isDigit(s.charAt(i))){\r\n                int k = i;\r\n                while(i < n && Character.isDigit(s.charAt(i))){\r\n                    i++;\r\n                }\r\n                int cnt = Integer.parseInt(s.substring(k, i));\r\n                cnts.push(cnt);\r\n            }\r\n            else if(s.charAt(i) == ']'){\r\n                String str = \"\";\r\n                while(!charStack.isEmpty()){\r\n                    if(charStack.peek() == '['){\r\n                        charStack.pop();\r\n                        break;\r\n                    }\r\n                    else{\r\n                        str = charStack.peek() + str;\r\n                        charStack.pop();\r\n                    }\r\n                }\r\n                for(int j = 0; j < cnts.peek(); j++){\r\n                    for(char ch:str.toString().toCharArray()){\r\n                        charStack.push(ch);\r\n                    }\r\n                }\r\n                cnts.pop();\r\n                i++;\r\n\r\n            }\r\n            else {\r\n                charStack.push(s.charAt(i));\r\n                i++;\r\n            }\r\n        }\r\n        String ans  = \"\";\r\n        while(!charStack.isEmpty()){\r\n            ans = charStack.peek() + ans;\r\n            charStack.pop();\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string decodestrs) {\r\n        stack<string> strs;\r\n        stack<int> nums;\r\n        string res=\"\";\r\n        int times=0;\r\n        for(auto s: decodestrs){\r\n            if('0' <= s && s <= '9'){\r\n                times = times*10 + int(s-'0');\r\n            }\r\n            else if('[' == s){\r\n                nums.push(times);\r\n                times = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if(('a' <= s && s <= 'z') || ('A' <= s && s <= 'Z') ){\r\n                res += s;\r\n            }\r\n            else{\r\n                int n = nums.top();\r\n                nums.pop();\r\n                for(int i=0;i<n;i++){\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n                \r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        if s:\r\n            stack = [s[0]]\r\n            i = 0\r\n            res = ''\r\n            while stack and i < len(s)-1:\r\n                i += 1\r\n                if s[i] != ']':\r\n                    stack.append(s[i])\r\n                else:\r\n                    tmp = ''\r\n                    # 取字符后缀\r\n                    while stack[-1] != '[':\r\n                        tmp = stack.pop() + tmp\r\n                    stack.pop()\r\n                    n = stack.pop()\r\n                    num = ''\r\n                    # 取数字前缀\r\n                    while '0' <= n and n <= '9' and stack:\r\n                        num = n + num\r\n                        n = stack.pop()\r\n                    if not ('0' <= n and n <= '9'):\r\n                        stack.append(n)\r\n                    else:\r\n                        num = n + num\r\n                    num = int(num)\r\n                    tmp = num*tmp\r\n                    stack.append(tmp)\r\n            res = ''\r\n            for s in stack:\r\n                res += s\r\n            return res\r\n        return s\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840940272","body":"### 思路\r\n入栈，再全部出栈都另一站栈。\r\n### 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stk1;\r\n    Stack<Integer> stk2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stk1 = new Stack<>();\r\n        stk2 = new Stack<>();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stk2.isEmpty()){\r\n            stk1.push(stk2.peek());\r\n            stk2.pop();\r\n        }\r\n        stk1.push(x);\r\n        while(!stk1.isEmpty()){\r\n            stk2.push(stk1.peek());\r\n            stk1.pop();\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int res = stk2.peek();\r\n        stk2.pop();\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return stk2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stk2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841601105","body":"### 思路\r\n按快排序后的结果和直接排序的结果相同,这是何意?\r\n\r\n假设排序后的结果为$[x_1, x_2, x_3, x_4, x_5, x_6, x_7]$\r\n\r\n如何确定能否分块，在这里，我们继续假设$[x_1, x_2, x_3]$为一块\r\n\r\n那么这个三个数的顺序就能随便排，比如$[x_1, x_3, x_2]$，$[x_3, x_2, x_1]$...\r\n\r\n如何确定$[x_1, x_2, x_3]$为一块，而不是$[x_1, x_2]$或者$[x_1, x_2, x_3, x_4]$呢？\r\n\r\n根据有序这一性质，我们可以得到这样一个结论，**如果$x_4 >= max (x_1, x_2, x_3)$，那么$[x_1, x_2, x_3]$可以分成一块**\r\n\r\n#### 思路1:单调栈\r\n很容易会想到**单调栈**这以数据结构\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n\r\n\r\n#### 思路2：前缀和\r\n观察有序序列$[x_1, x_2, x_3]$与无序序列$[x_1, x_3, x_2]$之间的关系，会发现无论怎样改变，这两个序列的和一样，也就是说对有序序列和无序序列从前到后遍历相加，只要和相同，那么就可以分成块。\r\n\r\n#### 思路3：峰值检测\r\n对于块的右临界值，一定满足小于等于右边的所有值，大于等于左边左右值。\r\n首先找出每个值，前面的最大值，然后倒序遍历，对于最大值小于后序最小值的，可作为分快点。\r\n### 代码\r\n#### 代码1\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        int ans = 0;\r\n        for(int num:arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int tmp = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(tmp);\r\n            }\r\n            else{\r\n                stack.push(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n#### 代码2\r\n```java\r\nclass Solution{\r\n    public int maxChunkToSorted(int[] arr){\r\n        int n = arr.length;\r\n        int[] presum = new int[n];\r\n        presum[0] = arr[0];\r\n        for(int i=1; i < n; i++){\r\n            presum[i] += presum[i-1] + arr[i];\r\n        }\r\n        Arrays.sort(arr);\r\n        int tmp = 0;\r\n        int ans = 0;\r\n        for(int i = 0; i < n; i++){\r\n            tmp += arr[i];\r\n            if(presum[i] == tmp){\r\n                ans += 1;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n#### 代码3\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int ans = 0;\r\n        int n = arr.length;\r\n        int[] curMax = new int[n];\r\n        curMax[0] = arr[0];\r\n        for(int i = 1; i < n; i++){\r\n            curMax[i] = Math.max(curMax[i-1], arr[i]);\r\n        }\r\n        int tmp = Integer.MAX_VALUE;\r\n        for(int  i = n -1; i >= 0; i--){\r\n            if(tmp >= curMax[i]){\r\n                ans++;\r\n            }\r\n            tmp = Math.min(tmp, arr[i]);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\nMethod | Time | Space\r\n--- | --- | ---\r\n单调栈 | O(n) | O(n)\r\n前缀和 | O(nlogn) | O(n)\r\n峰值检测 | O(n) | O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841780801","body":"### 思路\r\n1. 制作循环链表\r\n2. 重新计算偏移值\r\n\r\n### 代码\r\n```java\r\nlass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null){\r\n            return head;\r\n        }\r\n        if(k == 0){\r\n            return head;\r\n        }\r\n        ListNode p = head;\r\n        int cnt = 1;  // 节点个数\r\n        while(p.next != null){\r\n            p = p.next;\r\n            cnt++;\r\n        }\r\n        p.next = head;\r\n        p = p.next;\r\n        cnt -= k%cnt;\r\n        while(cnt-- != 1){\r\n            p = p.next;\r\n        }\r\n        head = p.next;\r\n        p.next = null;\r\n        return head;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842284483","body":"### 思路\r\nListNode tmp1 = p.next;\r\nListNode tmp2 = p.next.next;\r\np.next = tmp2;\r\ntmp1.next = tmp2.next;\r\ntmp2.next = tmp1;\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummyNode = new ListNode(-1);\r\n        dummyNode.next = head;\r\n        ListNode p = dummyNode;\r\n        while(p.next != null && p.next.next != null){\r\n            ListNode tmp1 = p.next;\r\n            ListNode tmp2 = p.next.next;\r\n            p.next = tmp2;\r\n            tmp1.next = tmp2.next;\r\n            tmp2.next = tmp1;\r\n            p = tmp1;\r\n        }\r\n        return dummyNode.next;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842996247","body":"### 思路\r\n明白两点：子树高度差不超过1，所以为了保证这一性质，每次都会尽可能将数据分为平等的两部分。\r\n\r\n也就相当于选取数据的中间节点为根节点\r\n- 二倍速快慢指针。\r\n```java\r\nslow = slow.next;\r\nfast = fast.next.next;\r\n```\r\n选出了第一个根节点，左右子树该如何选择？\r\n1. 中间节点左边为左子树\r\n2. 中间节点右边为右子树\r\n\r\n- 递归地进行构建\r\n```java\r\nTreeNode helper(ListNode left, ListNode right){\r\n    TreeNode root = new TreeNode(mid.val)\r\n    root.left = helper(left, mid)\r\n    root.right = helper(mid.next, right)\r\n    return root;\r\n}\r\n```\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public TreeNode helper(ListNode left, ListNode right){\r\n        if(left == right){\r\n            return null;\r\n        }\r\n        ListNode slow = left;\r\n        ListNode fast = left;\r\n        while(fast != right && fast.next != right && fast.next.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        ListNode mid = slow;\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = helper(left, mid);\r\n        root.right = helper(mid.next, right);\r\n        return root;\r\n    }\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return helper(head, null);\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:(nlogN), T(n) = 2*T(n/2) +O(n) \r\n- S:O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843730336","body":"### 解题思路\r\n\r\n设A、B链表的长度分别为m, n\r\n\r\n根据加法的交换律有m + n == n + m\r\n\r\n也就是说，两个指针p1、p2分别从A和B同时出发，最终p1会走到B的末尾、p2会走到p1的末尾。\r\n\r\n且用时相同。\r\n\r\n** 那么从终点往回走，如果有相交节点，在这个节点之前，p1和p2都是指向同一个值**\r\n\r\n### 代码\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        \r\n        ListNode p1 = headA;\r\n        ListNode p2 = headB;\r\n        while(p1 != p2){\r\n            if(p1 == null){\r\n                p1 = headB;\r\n            }else{\r\n                p1 = p1.next;\r\n            }\r\n            if(p2 == null){\r\n                p2 = headA;\r\n            }\r\n            else{\r\n                p2 = p2.next;\r\n            }\r\n        }\r\n        return p1;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n + m)\r\n- S:O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844704244","body":"### 思路\r\n快慢指针：一个每次前进一步，一个每次前进两步。\r\n显然，若存在环结构，则两指针一定相遇，且慢指针走完一圈前环中某处与快指针相遇。\r\n此时，设置一个新的指针，从头节点开始出发，保持与慢指针相同的速度，最终相遇点即为环结构入口。\r\n![环链表入口](https://img-blog.csdnimg.cn/20201110232039786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMwMTI0MjQx,size_16,color_FFFFFF,t_70)\r\n证明：\r\n\r\n> 假设s1-s2-s3-s4长度为a、b、c(s3为相遇点)，快指针走了n圈。\r\n>            则slow走过的距离：a+b， fast走过的距离：a+n*(b+c) + b\r\n>            根据快慢指针定义可得：2*(a+b) = a+b+n*(b+c)==>a=(n-1)*b+nc=（n-1)*(b+c) + c\r\n>            又因为b+c是环的长度\r\n>            所以a == c\r\n>            则此时只需要一个指针从头节点出发，保持与慢指针相同速度，最后相遇点即为环入口。\r\n\r\n得证。\r\n### 代码\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null || head.next.next == null){\r\n            return null;\r\n        }\r\n        ListNode slow = head.next;\r\n        ListNode fast = head.next.next;\r\n        while(slow != fast){\r\n            if(fast.next != null && fast.next.next != null){\r\n                fast = fast.next.next;\r\n            }else{\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n        }\r\n        ListNode p = head;\r\n        while(p != slow){\r\n            slow = slow.next;\r\n            p = p.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845661172","body":"### 解题思路\r\n前置知识：\r\n双向链表的插入和删除\r\n1. 插入    \r\n    ![image.png](https://pic.leetcode-cn.com/1621574154-JjBExj-image.png)\r\n    每一步中，先连接前还是后，并没有影响。顺序有很多种，这里只写了自己比较喜欢的一种。\r\n2. 删除\r\n    ![image.png](https://pic.leetcode-cn.com/1621574358-ilTUpt-image.png)\r\n\r\n### 数据结构的定义\r\n- 双向链表节点定义如下：\r\n    ```java\r\n    class ListNodes{\r\n        public int val;\r\n        public ListNodes next;\r\n        public ListNodes parent;\r\n        ListNodes(int val){\r\n            this.val = val;\r\n        }\r\n    }\r\n    ```\r\n- 哈希表定义如下：{key={ListNode(key), value}}\r\n\r\n1. 首先引入头结点和尾节点，所有操作均在这两个节点之间进行操作，也能够避免一些临界情况的讨论，比如只有一个点、两个点的情况。。\r\n![image.png](https://pic.leetcode-cn.com/1621572804-ikTmqT-image.png)\r\n\r\n    - 最近使用的节点插入到头结点：（以下例讲解）\r\n    - [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"put\", \"put\", \"get\", \"get\", \"get\"]\r\n      [[2], [1, 10], [2, 10], [1], [2, 20] [3, 30], [4, 40], [1], [3], [4]]\r\n        1). 插入1\r\n        ![image.png](https://pic.leetcode-cn.com/1621572981-mVAQvV-image.png)\r\n        此时哈希表：{1={ListNode(1), 10}}\r\n        2). 插入2      \r\n        ![image.png](https://pic.leetcode-cn.com/1621573114-qtMrFd-image.png)\r\n        此时哈希表：{1={ListNode(1), 10}, 2={ListNode(2), 10}}\r\n        3). 取出1:1存在于哈希表中，1被使用，值不变，移动至最前\r\n        ![image.png](https://pic.leetcode-cn.com/1621573271-auXuLt-image.png)\r\n        4). 插入2:2已存在，更新2的值，并移动2到最前面\r\n        ![image.png](https://pic.leetcode-cn.com/1621573114-qtMrFd-image.png)\r\n        此时哈希表：{1={ListNode(1), 10}, 2={ListNode(2), 20}}\r\n        5). 取出2:2存在哈希表中，2被使用，移动至最前面\r\n        ![image.png](https://pic.leetcode-cn.com/1621573114-qtMrFd-image.png)\r\n        6).插入3：已达到最大缓存，最靠近尾部的删除，3插入到最前面\r\n        ![image.png](https://pic.leetcode-cn.com/1621573715-HIQQnm-image.png)\r\n        此时哈希表：{2={ListNode(2), 20}, 3={ListNode(3), 30}}\r\n        7).插入4：已达到最大缓存，最靠近尾部的删除，4插入到最前面\r\n        ![image.png](https://pic.leetcode-cn.com/1621573862-MIfWYp-image.png)\r\n        此时哈希表：{3={ListNode(3), 30}, 4={ListNode(4), 40}}\r\n        8)取出1：不存在哈希表中\r\n        9)-10)同理。。。\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 代码\r\n```java\r\nclass ListNodes{\r\n    public int val;\r\n    public ListNodes next;\r\n    public ListNodes parent;\r\n    ListNodes(int val){\r\n        this.val = val;\r\n    }\r\n}\r\n\r\npublic class LRUCache {\r\n    public Map<Integer, Object[]> maps;\r\n    public ListNodes head;\r\n    public ListNodes tail;\r\n    private int capacity;\r\n    public int length;\r\n    public LRUCache(int capacity) {\r\n        head = new ListNodes(-1);\r\n        tail = new ListNodes(-1);\r\n        maps = new HashMap<>();\r\n        this.capacity = capacity;\r\n        head.next = tail;\r\n        tail.parent = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        if(maps.containsKey(key)){\r\n            ListNodes cur = (ListNodes) maps.get(key)[0];\r\n            ListNodes parent = cur.parent;\r\n            ListNodes next = cur.next;\r\n            parent.next = next;\r\n            next.parent = parent;\r\n            ListNodes tmp = head.next;\r\n            head.next = cur;\r\n            cur.next = tmp;\r\n            tmp.parent = cur;\r\n            cur.parent = head;\r\n            return (Integer) maps.get(key)[1];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        if(maps.containsKey(key)){\r\n            ListNodes cur = (ListNodes) maps.get(key)[0];\r\n            ListNodes parent = cur.parent;\r\n            ListNodes next = cur.next;\r\n            parent.next = next;\r\n            next.parent = parent;\r\n            ListNodes tmp = head.next;\r\n            head.next = cur;\r\n            cur.next = tmp;\r\n            tmp.parent = cur;\r\n            cur.parent = head;\r\n            maps.put(key, new Object[]{cur, value});\r\n            return;\r\n        }\r\n        if(length == capacity){\r\n            ListNodes tmp = tail.parent.parent;\r\n            ListNodes del = tail.parent;\r\n            tmp.next = tail;\r\n            tail.parent = tmp;\r\n            maps.remove(del.val);\r\n            length--;\r\n        }\r\n        ListNodes cur = new ListNodes(key);\r\n        ListNodes tmp = head.next;\r\n        head.next = cur;\r\n        cur.next = tmp;\r\n        tmp.parent = cur;\r\n        cur.parent = head;\r\n        maps.put(key, new Object[]{cur, value});\r\n        length++;\r\n        return;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n- T:O(1)\r\n- S:O(k)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846350306","body":"### 思路\r\nleftDepth = maxDepth(root.left) + 1\r\n\r\nrightDepth = maxDepth(root.right) + 1\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)， 递归栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846515210","body":"### 思路\r\n递归第比较左右子树上的val是否相等，\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null){\r\n            return true;\r\n        }\r\n        if(p == null || q == null){\r\n            return false;\r\n        }\r\n        if(p.val != q.val){\r\n            return false;\r\n        }\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n- T:O(n)\r\n- S:O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangpengzhen":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281496","body":"### 思路\r\n辅助栈\r\n### 代码\r\n\r\n` function CodeStr(s) {\r\n    let repeats = 0, res = ''; const strStack = [], numStack = [];\r\n    for (let str of s) {\r\n        if (!isNaN(str)) {//是数字\r\n            repeats = 10 * repeats + +str;\r\n        } else if (str === '[') {\r\n            //进入下一层\r\n            numStack.push(repeats);\r\n            repeats = 0;\r\n            strStack.push(res);\r\n            res = ''\r\n        } else if (str === ']') {\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        } else {\r\n            res += str\r\n        }\r\n    }\r\n        return res\r\n\r\n};`\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841141023","body":"```\r\nvar MyQueue = function () {\r\n    this.stack = []\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function () {\r\n    // 从队列头中弹出\r\n    const tempStack = []\r\n    while (this.stack.length) {\r\n        tempStack.push(this.stack.pop())\r\n    }\r\n    const result = tempStack.pop()\r\n    while (tempStack.length) {\r\n        this.stack.push(tempStack.pop())\r\n    }\r\n    return result\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function () {\r\n    return this.stack[0] // 这个直接返回即可，不同语言不一样，不行就按照 pop 方法倒水，一样可行\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function () {\r\n    return !this.stack.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841631439","body":"```\r\nvar maxChunksToSorted = function(arr) {\r\n  let queue = [];\r\n\r\n  for(let i = 0; i < arr.length; i++){\r\n\r\n    if(queue.length == 0 || (queue[queue.length - 1] <= arr[i])){\r\n      queue.push(arr[i])\r\n    }else{\r\n      //the size of the queue reprensets the size of partition\r\n\r\n      let temp = queue.pop()\r\n      while(queue[queue.length - 1] > arr[i]){\r\n        queue.pop()\r\n      }\r\n\r\n      queue.push(temp)\r\n    }\r\n\r\n  }\r\n  return queue.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841813711","body":"```\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n  //如果次数是0，那么就等于没干，并且如果k = 0 后面会报错\r\n  if(k === 0) return head;\r\n\r\n  //快慢指针，让快的先走 k - 1步，这样慢的就刚好是newHead，快的刚好是现在的尾巴\r\n  let fast = head, slow = head, count = k - 1;\r\n\r\n  while(count > 0){\r\n    fast = fast.next\r\n    count--\r\n  }\r\n\r\n  //pre是newHead之前的节点，也就是newTail\r\n  let pre = null;\r\n  while(fast.next){\r\n    pre = slow\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  //在尾巴后面把这个斩断\r\n  pre.next = null;\r\n  //这里把他接上\r\n  fast.next = head;\r\n  return slow\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843116572","body":"```\r\nvar sortedListToBST = function(head) {\r\n  if(!head) return null;\r\n  let length = 0;\r\n  let current = head;\r\n  while(current){\r\n    current = current.next\r\n    length++\r\n  }\r\n\r\n  var buildBST = function(start, end){\r\n    if(start > end) return null;\r\n\r\n    const mid = start + ((end - start)>> 1)\r\n    const leftSide = buildBST(start, mid - 1);\r\n\r\n    const root = new TreeNode(head.val)\r\n    head = head.next;\r\n    root.left = leftSide\r\n\r\n    root.right = buildBST(mid+1, end)\r\n    return root;\r\n  }\r\n\r\n  return buildBST(0, length - 1)\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844086240","body":" /**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n   \t// 哈希\r\n    let data = new Set()\r\n    while(headA !== null) {\r\n        data.add(headA)\r\n        headA = headA.next\r\n    }\r\n    while(headB !== null) {\r\n        if(data.has(headB)) return headB\r\n        headB = headB.next\r\n    }\r\n\r\n    return null\r\n\t// 双指针\r\n    // let a = headA,\r\n    //     b = headB;\r\n    // while (a != b) {\r\n    //     a = a === null ? headB : a.next;\r\n    //     b = b === null ? headA : b.next;\r\n    // }\r\n    // return a;\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845115221","body":"var detectCycle = function(head) {\r\n  let fast = head, slow = head;\r\n\r\n  do{\r\n    //check if there is a loop\r\n    if(!fast || !fast.next) return null;\r\n    fast = fast.next.next\r\n    slow = slow.next\r\n  }while(fast != slow)\r\n\r\n\r\n  fast = head;\r\n\r\n  //locate the entrance of the loop\r\n  while(fast != slow){\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  return fast;\r\n};"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846396908","body":"**var maxDepth = function(root) {\r\n  if(!root) return 0;\r\n  //bfs\r\n  const queue = [root]\r\n  let maxLevel = 0\r\n  while(queue.length > 0){\r\n    const curLevelSize = queue.length\r\n    for(let i = 0; i < curLevelSize; i++){\r\n      const node = queue.shift();\r\n      node.left && queue.push(node.left)\r\n      node.right && queue.push(node.right)\r\n    }\r\n    maxLevel++\r\n  }\r\n\r\n  return maxLevel\r\n};**"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836766743","body":"## 前置知识\r\n\r\n- 数组的遍历，整数的运算\r\n\r\n## 思路\r\n- 从后往前遍历数组，得到的是X的从低到高的每一位\r\n- k%10得到最低位，k/10更新当前k的倒数第二位为最低位\r\n- 通过将k的最低位与X的最低位诸位相加得到新的结果value，并用count = value /10保存当前加法后的进位数值，用value/10保留当前加法后的最低位\r\n\r\n## 关键点\r\n\r\n-  可以吧k当做一个数组来看，本题类似于两个数组的加法运算，加法循环的终止条件是两个数组(k和nuns)都便利了一遍，且进位count为0\r\n- 在本题中直接得到的结果在list中是逆序排列的，因此需要反转\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int count = 0; // 表示进位符\r\n        List<Integer> list = new ArrayList<>();\r\n        int n = num.length;\r\n        int value = 0;\r\n        for(int i=n-1;i>=0;i--){\r\n            int kNum = k % 10;\r\n            value = num[i] + kNum + count;\r\n            count = value / 10;\r\n            list.add(value % 10);\r\n            if(k > 0)\r\n                k /= 10;\r\n        }\r\n        k += count;\r\n        while(k > 0){\r\n            list.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(list);\r\n        return list;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(max(n, log k)$\r\n- 空间复杂度：$O(1)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838216276","body":"## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n## 思路\r\n- 由题意可知每个字符的最短距离，即是左边离该字符最近的c字符与右边离该字符最近的c字符的距离的较小值\r\n- 因此通过一次顺序遍历，得到左边离该字符最近的c字符到该字符的距离；然后一次逆序遍历，得到右边离该字符最近的c字符到该字符的距离，两者比较去较小值即可\r\n\r\n## 关键点\r\n\r\n-  怎样实现只取左边最近的c字符的距离与右边最近的c字符的距离 --> 分别通过顺序和逆序遍历得到\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java {15}\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = -n;\r\n        for(int i=0;i<n;i++){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 2 * n;\r\n        for(int i=n-1;i>=0;i--){\r\n            if(s.charAt(i) == c)\r\n                prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839393265","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 前置知识\r\n\r\n- 栈的实现\r\n\r\n## 思路\r\n- 使用数组来模拟栈\r\n## 关键点\r\n\r\n-  用数组下标为0的位置表示栈底\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        size = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(size < stack.length)\r\n            stack[size++] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if(size == 0)\r\n            return -1;\r\n        return stack[--size];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int m = Math.min(k, size);\r\n        for(int i=0;i<m;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n令 nmaxSize为栈的容量。\r\n- 时间复杂度：$O(maxSize)$ --> inc操作的时间复杂度为O(maxSize)\r\n- 空间复杂度：$O(maxSize)$ --> 使用了一个数组来模拟栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840273846","body":"## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 前置知识\r\n- 字符串的判断：是不是数字\r\n- 用栈进行符号匹配\r\n## 思路\r\n- 将s的字符进栈，当碰到‘]’时将栈顶元素去除，直到碰到'['，即得到要重复的字符串，然后继续取出栈顶元素直到碰到‘]’或栈为空，此即为该字符串要重复的次数，然后将重复后的字符串重新入栈。\r\n- 栈的作用即为再不改变字符串相对顺序的情况下，消除s中的 '[' 和 ']' 字符\r\n## 关键点\r\n-  ‘[’ 字符只用作匹配 ']' 字符，一旦匹配成功，则将 '[' 字符出栈\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        StringBuilder res = new StringBuilder();\r\n        for(int i=0;i<n;i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            }\r\n            else{\r\n                StringBuilder str = new StringBuilder();\r\n                while(!stack.isEmpty() && stack.peek() != '['){\r\n                    str.append(stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder digit = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\r\n                    digit.insert(0, stack.pop());\r\n                }\r\n                int count = Integer.parseInt(digit.toString());\r\n                for(int j=0;j<count;j++){\r\n                    for(int k=str.length()-1;k>=0; k--){\r\n                        char ch = str.charAt(k);\r\n                        stack.push(ch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        while (!stack.isEmpty()){\r\n            res.append(stack.pop());  //最后反转能降低所用时间 \r\n        }\r\n        return res.reverse().toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n^2)$ --> 每个元素至多进栈和出栈n/2次\r\n- 空间复杂度：$O(n)$  --> 使用了一个stack,容量至多为n；两个StringBuildere类型数据str和digit，长度之和不会超过n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841030717","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 前置知识\r\n\r\n- 栈的使用\r\n- 栈和队列的特点\r\n\r\n## 思路\r\n- 将元素先经过输入栈，然后再经过输出栈，就实现了队列的功能\r\n\r\n## 关键点\r\n\r\n-  每当输出栈为空时，需要将输入栈的所有元素都出栈到输出栈中\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> stack1;\r\n    Deque<Integer> stack2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>(); // 输入栈\r\n        stack2 = new LinkedList<>(); // 输出栈\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack2.isEmpty() && stack1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：$O(1)$ --> 每个元素至多在输入栈和输出栈里面分别入栈和出栈了一次\r\n- 空间复杂度：$O(n)$ --> 最多所有元素都进入输入栈或者输出栈"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841626107","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 前置知识\r\n- 单调栈的应用\r\n\r\n## 思路\r\n- 将遍历到i为止的最大值存入栈中，表示一个合理的分块\r\n- 从左到右遍历数组，比较当前元素num与栈顶元素peek，若当前元素小于栈顶元素，则出栈。并进入循环：若num小于栈顶元素，则出栈知道栈为空或者当前元素大于栈顶元素\r\n## 关键点\r\n-  若后面遇到比栈顶元素小的元素num，则证明之前的分块需要调整，因此，需要将栈中大于num的元素都出栈(因为这些分块都不是合理的分块了)\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<>();\r\n        for(int value: arr){\r\n            if(!stack.isEmpty() && value < stack.peek()){\r\n                int head = stack.pop();\r\n                while (!stack.isEmpty() && value < stack.peek())\r\n                    stack.pop();\r\n                stack.push(head);\r\n            }\r\n            else stack.push(value);\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$ --> 一次遍历整个数组，且栈中至多有一个元素入站出栈n次，平均每个元素入栈和出栈各1次，因此为O(n)\r\n- 空间复杂度：$O(n)$ --> 使用了栈，最大容量为O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841799727","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 前置知识\r\n- 链表\r\n\r\n## 思路\r\n- 首先遍历一遍链表得到链表的长度count\r\n- 再次从头开始遍历链表找到第count - k % count 个元素，即为新链表的表头\r\n## 关键点\r\n-  使用dummy.next记录链表的头结点\r\n- 在第一遍遍历链表时，要将链表链接成环(尾结点指向头结点)\r\n- 对于链表的题目，一般只要不是成封闭的环，就不会超时，可以直接用暴力(朴素)的方法来解决\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        ListNode dummy = new ListNode(0, head);\r\n        ListNode node = dummy;\r\n        int count=0;\r\n        while(node.next != null){\r\n            node = node.next;\r\n            count++; \r\n        }\r\n        node.next = head;\r\n        node = dummy;\r\n        int num = 0;\r\n        while(node.next != null){\r\n            node = node.next;\r\n            num++;\r\n            if(num == count - k%count){\r\n                dummy.next = node.next;\r\n                node.next = null;\r\n                break;\r\n            }\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$  --> 遍历两遍链表\r\n- 空间复杂度：$O(1)$ --> 只使用了两个额外的dummy和node结点"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842062335","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 前置知识\r\n\r\n- 链表的递归\r\n\r\n## 思路\r\n- 在递归的过程中改变链表的指针指向\r\n\r\n## 关键点\r\n\r\n-  合理修改next指针的指向，即达到目的交换链表，也必须构成闭环(代码永不停止)\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null)\r\n            return head;\r\n        ListNode newHead = head.next;\r\n        head.next = newHead.next;\r\n        newHead.next = head;\r\n        head.next = swapPairs(head.next);\r\n        return newHead;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(n)$ --> 递归遍历了一遍链表\r\n- 空间复杂度：$O(n)$ --> 递归栈的深度最大为n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843057648","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n```\r\n\r\n## **方法1：利用数组分治**\r\n- ## 前置知识\r\n  - 用链表构建数组，BST的构建，分治思想\r\n- ## 思路\r\n  - 使用数组存储结点信息，找到中点为root，然后分治构建左右子树\r\n- ## 关键点\r\n  -  找到数组的中点，然后将其分为两部分(左右子树)\r\n- ## 代码\r\n  - 语言支持：Java\r\n  - Java Code:\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    private ListNode head;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        /* 方法1：将链表转化为数组,递归构建左右子树*/\r\n       ArrayList<Integer> list = new ArrayList<>();\r\n        while(head != null){\r\n            list.add(head.val);\r\n            head = head.next;\r\n        }\r\n        int len = list.size();\r\n        return dfs(list, 0, len-1);\r\n    }\r\n\r\n    private TreeNode dfs(ArrayList<Integer> list, int left, int right){\r\n        if(left > right) return null;\r\n        int mid = left + (right - left) / 2;\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        root.left = dfs(list, left, mid-1);\r\n        root.right = dfs(list, mid+1, right);\r\n        return root;\r\n    }\r\n\r\n}\r\n```\r\n- **复杂度分析**\r\n  - 时间复杂度：$O(n)$ --> 每个结点的值使用了两次，构建数组和访问数组构建树节点时\r\n  - 空间复杂度：$O(n)$ --> 分治时递归栈的深度为log n, 数组的容量为n\r\n\r\n## **方法2**\r\n- ## 前置知识\r\n  - 快慢指针找链表的中点，分治思想\r\n\r\n- ## 思路\r\n  - 直接在链表上进行分治\r\n- ## 关键点\r\n  -  利用快慢指针找到链表的中点，使用preSlow记录slow节点的前驱结点，将链表分为两部分，分别构建左右子树\r\n  - 在分为两个链表之后，要令preSlow.next = null;\r\n- ## 代码\r\n  - 语言支持：Java\r\n  - Java Code:\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    private ListNode head;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        /* 方法2：快慢指针找中点，左右子树分治法*/\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode preSlow = slow;\r\n        while(fast != null && fast.next != null){\r\n            preSlow = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        preSlow.next = null;\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(slow.next);\r\n        return root;\r\n    }\r\n}\r\n```\r\n- **复杂度分析**\r\n  - 时间复杂度：$O(nlogn)$ --> 递归进行了O(logn)层，每层遍历一遍链表找到中间节点$O(n)$, 因此为$O(nlogn)$\r\n  - 空间复杂度：$O(logn)$  --> 递归栈的深度最大为$O(logn)$\r\n\r\n## **方法3**\r\n- ## 前置知识\r\n  - BST的中序遍历\r\n- ## 思路\r\n  - 根据BST的中序遍历结果与链表值得顺序是相同的，因此考虑逐个移动链表的节点构建BST\r\n- ## 关键点\r\n  -  链表的节点要设置为全局变量，使得其不会随着递归的深度而发生突变\r\n- ## 代码\r\n  - 语言支持：Java\r\n  - Java Code:\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    private ListNode head;\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        /* 方法3：利用中序遍历的特性构建BST*/\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        this.head = head;\r\n        int len = 0;\r\n        while (head != null){\r\n            len++;\r\n            head = head.next;\r\n        }\r\n        return buildBST(0, len - 1);\r\n    }\r\n\r\n    private TreeNode buildBST(int left, int right){\r\n        if(left > right) return null;\r\n        int mid = left + (right - left) / 2;\r\n        TreeNode leftNode = buildBST(left, mid-1);\r\n        TreeNode root = new TreeNode(head.val);\r\n        head = head.next;     // 保证链表中结点一直在按中序顺序传递\r\n        root.left = leftNode;\r\n        root.right = buildBST(mid+1, right);\r\n        return root;\r\n    }\r\n}\r\n```\r\n- **复杂度分析**\r\n  - 时间复杂度：$O(n)$     --> 遍历了一遍链表中的节点\r\n  - 空间复杂度：$O(logn)$  --> 调用的递归栈的深度不超过$logn$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843686357","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n```\r\n## 前置知识\r\n- 双指针\r\n\r\n## 思路\r\n- 将两个链表拼接，双指针分别从headA和headB开始遍历，当相遇时，即为相交节点\r\n## 关键点\r\n-  两链表拼接后的长度相同\r\n## 代码\r\n- 语言支持：Java\r\nJava Code:\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode first = headA;\r\n        ListNode second = headB;\r\n        while(first != second){\r\n            if(first == null)\r\n                first = headB;\r\n            else\r\n                first = first.next;\r\n            if(second == null)\r\n                second = headA;\r\n            else\r\n                second = second.next;\r\n        }\r\n        return first;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n令 m,n 为分别为两链表长度。\r\n- 时间复杂度：$O(m+n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844737861","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 前置知识\r\n- 快慢指针\r\n## 思路\r\n- 使用Floyd判圈法\r\n## 关键点\r\n-  当两指针首次相遇时，将fast值为head，并且两指针开始每次都只移动一步，当再次相遇时，即为环的起点\r\n- if(fast==null || fast.naxt ==null) return null;\r\n## 代码\r\n- 语言支持：Java\r\nJava Code:\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if(fast == slow) {\r\n                fast = head;\r\n                break;\r\n            }\r\n        }\r\n        if(fast == null || fast.next == null) return null;\r\n        while (fast != slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n令 n 为链表中不同节点的数量。\r\n- 时间复杂度：$O(n)$ --> slow指针最多每个节点遍历两遍（而slow指针一直在移动）\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845932243","body":"\r\n## 题目地址(146. LRU 缓存机制)\r\n\r\nhttps://leetcode-cn.com/problems/lru-cache/\r\n\r\n## 前置知识\r\n- 双向链表，哈希表\r\n\r\n## 思路\r\n- 使用HashMap实现O(1)的查询，使用双向链表实现O(1)的插入、删除和更新\r\n\r\n## 关键点\r\n-  每次更新时，都将最近使用的节点放在链表的头部，最远使用的节点放在链表的尾部，然后每次只从尾部进行删除\r\n## 代码\r\n- 语言支持：Java\r\nJava Code:\r\n```java\r\n\r\nclass LRUCache {\r\n    HashMap<Integer, DlinkedList<Integer>> map;\r\n    DlinkedList<Integer> list;\r\n    int size;\r\n    DlinkedList<Integer> head = new DlinkedList<>();\r\n    DlinkedList<Integer> tail = new DlinkedList<>();\r\n    static class DlinkedList<Item>{\r\n        Item key;\r\n        Item value;\r\n        DlinkedList<Item> prev;\r\n        DlinkedList<Item> next;\r\n        DlinkedList(){this.key=null;this.value=null;}\r\n        DlinkedList(Item key, Item value){this.key = key; this.value = value;}\r\n        DlinkedList(Item key, Item value, DlinkedList<Item> prev, DlinkedList<Item> next){\r\n            this.key = key;\r\n            this.value = value;\r\n            prev.next = this;\r\n            this.prev = prev;\r\n            this.next = next;\r\n            next.prev = this;\r\n        }\r\n    }\r\n    public LRUCache(int capacity) {\r\n        map = new HashMap<>();\r\n        list = new DlinkedList<Integer>(0, 0, head, tail);\r\n        size = capacity;\r\n    }\r\n\r\n    public int get(int key) {  // 查询, 如果存在则更新 --> 将其移动到链表的头部\r\n        if(map.containsKey(key)) {\r\n            DlinkedList<Integer> node = map.get(key);\r\n            removeNode(node); // 删除节点\r\n            moveToHead(head, node); // 移到开头\r\n            return node.value;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {  // 更新\r\n        if(map.containsKey(key)){\r\n            DlinkedList<Integer> node = map.get(key);\r\n            node.value = value;\r\n            removeNode(node);\r\n            moveToHead(head, node);\r\n            map.put(key, node);\r\n        }\r\n        else{\r\n            if(size == 0) {\r\n                map.remove(tail.prev.prev.key); // 多占用了一个list节点\r\n                removeNode(tail.prev.prev);\r\n                size++;\r\n            }\r\n            DlinkedList<Integer> node = new DlinkedList<>(key, value);\r\n            map.put(key, node);\r\n            moveToHead(head, node);\r\n            size--;\r\n        }\r\n    }\r\n\r\n    private void moveToHead(DlinkedList<Integer> head, DlinkedList<Integer> node){\r\n        node.next = head.next;\r\n        node.next.prev = node;\r\n        head.next = node;\r\n        node.prev = head;\r\n    }\r\n\r\n    private void moveToTail(DlinkedList<Integer> tail, DlinkedList<Integer> node){\r\n        tail.prev.next = node;\r\n        node.prev = tail.prev;\r\n        node.next = tail;\r\n        tail.prev = node;\r\n    }\r\n    private void removeNode(DlinkedList<Integer> node){\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n**复杂度分析**\r\n令 n 为链表长度。\r\n- 时间复杂度：$O(1)$ --> 双向链表和HashMap保证了每个操作都在O(1)的时间复杂度内完成\r\n- 空间复杂度：$O(n)$  --> 要储存整个链表"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846339007","body":"\r\n## 题目地址(104. 二叉树的最大深度)\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n## 前置知识\r\n\r\n- 递归\r\n\r\n## 思路\r\n- 遍历二叉树的左右子树，得到的深度(取较大值)+1就是root的深度\r\n\r\n## 关键点\r\n\r\n-  return的是root的深度\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return dfs(root);\r\n    }\r\n\r\n    private int dfs(TreeNode root){\r\n        if(root == null) return 0;\r\n        int ld = dfs(root.left);\r\n        int rd = dfs(root.right);\r\n        return Math.max(ld, rd) + 1;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n令 n 为节点个数。\r\n- 时间复杂度：$O(n)$ --> 每个节点都遍历到了\r\n- 空间复杂度：$O(n)$ --> 递归栈的最大容量为所有的节点"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846490212","body":"\r\n## 题目地址(100. 相同的树)\r\n\r\nhttps://leetcode-cn.com/problems/same-tree/\r\n\r\n## 前置知识\r\n- 树的递归遍历\r\n\r\n## 思路\r\n- 在递归的逐层检查两树是否相同\r\n## 关键点\r\n-  在递归的时候，不要多想，只要确定在root的时候判断两树相同的条件，然后将这一条件推广(递归加层)到root.left和root.right就行\r\n## 代码\r\n\r\n- 语言支持：Java\r\nJava Code:\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) return true;\r\n        if(p!=null && q != null){\r\n            if(p.val == q.val)\r\n                return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n**复杂度分析**\r\n令 $m,n$ 为两棵树的节点个数。\r\n- 时间复杂度：$O(min(m,n))$  --> 最多遍历一遍较小树上的每个节点\r\n- 空间复杂度：$O(min(m, n)$  --> 递归调用的层数取决于树的高度， 树的高度最坏情况下为结点个数，即最大容量为$min(m,n)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Forschers":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836774703","body":"\r\n## 思路\r\n将k中的数取出一个个加入到数组中\r\n\r\n\r\neg:将【2，3，4】+ k=32 计算 4+32 因为4+32  = 36将6留在当前位 将k/10 以进为的形式加入到下个位中\r\n重复过程计算 【2，3】+ 3\r\n\r\n## 关键点\r\n\r\n-  将k放入到数组后\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> arr = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        //将k以 k/10的形式进位\r\n        for(int i = n-1;i>=0 || k>0;--i,k/=10){\r\n            if(i >= 0){\r\n                k +=num[i];\r\n            }\r\n            //加上k取出来的最后一位\r\n            arr.add(k%10);\r\n        }\r\n        //反转\r\n        Collections.reverse(arr);\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(max(n,logk))\r\n- 空间复杂度：O(1)\r\n\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838618318","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n整形反转\r\n\r\n## 思路\r\n对每个字符串 找出左右中c的距离 比较左右的距离 选择最小值\r\n\r\n\r\n左向右：\r\n\r\n上个字符出现的位置prev  距离 : i - prev\r\n\r\n右向左：\r\n\r\n上个字符出现的位置prev 则距离: prev - i\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        //创建新的数组ans\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE/2;\r\n\r\n        for(int i = 0;i < n;++i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //左 ==》 右 遍历\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n         prev = Integer.MAX_VALUE/2;\r\n\r\n        for(int i = n-1;i >= 0;--i){\r\n            //法返回指定索引处的char值\r\n            if(s.charAt(i) == c){\r\n                //当遍历的值和c相等 位置prev为当前i 的位置\r\n                prev = i;\r\n            }\r\n            //选择其中最小的\r\n            ans[i] = Math.min(ans[i],prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845115321","body":"\r\n## 题目地址(142. 环形链表 II)\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\r\n\r\n说明：不允许修改给定的链表。\r\n\r\n进阶：\r\n\r\n你是否可以使用 O(1) 空间解决此题？\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [3,2,0,-4], pos = 1\r\n输出：返回索引为 1 的链表节点\r\n解释：链表中有一个环，其尾部连接到第二个节点。\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = [1,2], pos = 0\r\n输出：返回索引为 0 的链表节点\r\n解释：链表中有一个环，其尾部连接到第一个节点。\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1], pos = -1\r\n输出：返回 null\r\n解释：链表中没有环。\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目范围在范围 [0, 104] 内\r\n-105 <= Node.val <= 105\r\npos 的值为 -1 或者链表中的一个有效索引\r\n```\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        //定义两个指针 都在同一起点\r\n        ListNode    fast = head ,slow = head;\r\n        while(true){\r\n            //当这个链表为空链表或者只有一个元素直接返回null\r\n            if(fast == null || fast.next == null){\r\n                return null;\r\n            }else{\r\n                //fast每次移动两位 slow每次移动一位\r\n                fast = fast.next.next;\r\n                slow = slow.next;\r\n                //当他们两个指针碰到了就跳出循环\r\n                if(fast == slow){\r\n                    break;\r\n                }    \r\n            }\r\n        }\r\n            fast = head;\r\n            while(slow != fast){\r\n                slow = slow.next;\r\n                fast = fast.next;\r\n            }\r\n             return fast;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XinlingQiu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836776627","body":"- 语言 python\r\n- 时间复杂度：O(max(n,log(k)))\r\n- 空间复杂度：O(1)\r\n- 无需反转\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(num)\r\n        count=0#进位符\r\n        for i in range(n-1,-1,-1):\r\n            new_i=num[i]+k%10+count\r\n            count=new_i/10\r\n            num[i]=new_i%10\r\n            if k>0:\r\n                k=k/10\r\n        k+=count\r\n        while k>0:\r\n            num.insert(0,k%10)\r\n            k/=10\r\n        return num\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630323","body":"```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        symbol=[]\r\n        for i in s:\r\n            try:\r\n                num=int(i)\r\n                num=symbol.pop()*10+num if symbol and isinstance(symbol[-1],int) else num\r\n                symbol.append(num)\r\n            except ValueError:\r\n                if i==']':\r\n                    s1=''\r\n                    while symbol[-1]!='[':\r\n                        s1=symbol.pop()+s1\r\n                    symbol.pop()\r\n                    symbol.append(symbol.pop()*s1)\r\n                else:\r\n                    symbol.append(i)\r\n        return ''.join(symbol)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841259914","body":"# Runtime: 4 ms, faster than 100.00% of Python online submissions for Implement Queue using Stacks.\r\n# Memory Usage: 13.4 MB, less than 89.07% of Python online submissions for Implement Queue using Stacks.\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack=[]\r\n        self.stk_aid=[]\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        top=self.stack[0]\r\n        while self.stack:\r\n            self.stk_aid.append(self.stack.pop())\r\n        self.stk_aid.pop()\r\n        while self.stk_aid:\r\n            self.stack.append(self.stk_aid.pop())\r\n        return top\r\n        \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.stack[0] if self.stack else self.stk_aid[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.stack)==0 and len(self.stk_aid)==0\r\n        \r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842392164","body":"```python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        new_head=ListNode(0)\r\n        new_head.next=head\r\n        current=head\r\n        pre=new_head\r\n        while current and current.next:\r\n            temp=current.next\r\n            nextnode=temp.next\r\n            pre.next=temp\r\n            temp.next=current\r\n            current.next=nextnode\r\n            pre=current\r\n            current=nextnode\r\n        return new_head.next\r\n```\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845055322","body":"```python\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        A=set()\r\n        while head:\r\n            if head not in A:\r\n                A.add(head)\r\n                head=head.next#找环的起点都可以用hash\r\n            else:\r\n                return head\r\n        return None\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suffocatingly0":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836783424","body":"- 语言 java\r\n- 时间复杂度O（n）\r\n- 空间复杂度O（n）\r\n- n = Math.max(num.length, k.length)\r\n```\r\nclass Solution {\r\n   public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res =new ArrayList<>();\r\n        int count=0;\r\n        for(int i=num.length-1;i>=0;i--){\r\n            int sum=num[i]+k%10;\r\n            k=k/10;\r\n            res.add((sum+count)%10);\r\n            count=(sum+count)/10;\r\n        }\r\n        if(count>0) k++;\r\n        for(;k>0;k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837657821","body":"- 语言：Java\r\n- 时间复杂度：O（N*M）\r\n- 空间复杂度：O（N）\r\n- N是s的长度，M是c在s中重复的个数\r\n\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        List<Integer> list=new ArrayList<>();\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)==c){\r\n                list.add(i);\r\n            }\r\n        }\r\n       int [] distance=new int[list.size()];\r\n        for(int i=0;i<list.size();i++){\r\n            distance[i]=list.get(i);\r\n        }\r\n        int [] res =new int[s.length()];\r\n        Arrays.fill(res,Integer.MAX_VALUE);\r\n        for(int i=0;i<s.length();i++){\r\n            for(int j=0;j<distance.length;j++){\r\n                int a=Math.abs(i-distance[j]);\r\n                if(a<res[i]) res[i]=a;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839714684","body":"方法一：双栈\r\n\r\n- 时间复杂度：push O(1)；pop O(1); increment O(N)\r\n- 空间复杂度：O（N）\r\n```\r\n- class CustomStack {\r\n    Stack<Integer> stack =new Stack<>();\r\n    int len;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.len= maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        //如果栈长>len 返回null；\r\n        //否则，直接利用stack.push()\r\n       if(stack.size()<len){\r\n            stack.push(x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        //栈为空，->-1\r\n        //栈不是空，利用栈本身的函数pop（）\r\n        if(stack.size()==0||stack.isEmpty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            return stack.pop();\r\n        }\r\n\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        Stack<Integer> temp =new Stack<>();\r\n        int size= stack.size();\r\n        while(!stack.isEmpty()){\r\n            temp.push(stack.pop());\r\n        }\r\n        if(k<size){\r\n           while(!temp.isEmpty()){\r\n             while(k>0){\r\n                stack.push(temp.pop()+val);\r\n                k--;\r\n                } \r\n            stack.push(temp.pop());\r\n            }\r\n        }\r\n        else{\r\n            while(!temp.isEmpty()) {\r\n                stack.push(temp.pop() + val);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n方法二：\r\n- 时间复杂度：push O(1)；pop O(1); increment O（k)\r\n- 空间复杂度：O（maxSize）\r\n```\r\nclass CustomStack {\r\n    \r\n     int [] stack ;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack =new int[maxSize];\r\n        top=0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        //栈长<len,直接利用stack.push(),最后一次stack[2]=x;top=3\r\n        //stack[0] top=1 stack[1]  stack[2]  top=3\r\n       if(top< stack.length){\r\n           stack[top++]=x;\r\n       }\r\n    }\r\n\r\n    public int pop() {\r\n    \r\n        if(top==0){\r\n            return -1;\r\n        }\r\n        else{\r\n            //--top=2 --top=1 --top=0 \r\n            return stack[--top];\r\n        }\r\n\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n       k=Math.min(k,top);\r\n       for(int i=0;i<k;i++){\r\n           stack[i]+=val;\r\n       }\r\n    }\r\n\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841033684","body":"语言：java\r\n时间复杂度：O（1）\r\n空间复杂度：O（N）\r\n```\r\nclass MyQueue {\r\n  public Stack<Integer> a;// 输入栈\r\n    public Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843265961","body":"- 语言：java\r\n- 时间复杂度：O(nlogn)\r\n- 空间复杂度：O(logn),构造树的空间\r\n```\r\n-class Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n       if(head==null) return null;\r\n       if(head.next==null) return new TreeNode(head.val);\r\n       ListNode slow= head;\r\n       ListNode fast=head;\r\n       ListNode pre =null;\r\n       while(fast!=null&&fast.next!=null){\r\n           pre=slow;\r\n           slow=slow.next;\r\n           fast=fast.next.next;\r\n       }\r\n       pre.next=null;\r\n\r\n       TreeNode tree =new TreeNode(slow.val);\r\n       tree.left=sortedListToBST(head);\r\n       tree.right=sortedListToBST(slow.next);\r\n       return tree;\r\n    }\r\n\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844991982","body":"时间复杂度：O（N）\r\n空间复杂度：O（1）\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow =head;\r\n        ListNode fast =head;\r\n        if(head==null||head.next==null) return null;\r\n        ListNode res=null;\r\n        while((fast.next!=null)&&(fast.next.next!=null)){\r\n            slow=slow.next;\r\n            fast=fast.next.next;\r\n            if(slow==fast){\r\n                 slow=head;\r\n                 while(slow!=fast){\r\n                    slow=slow.next;\r\n                    fast=fast.next;\r\n                }\r\n                res=fast;\r\n                break;\r\n                \r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846394889","body":"复杂度\r\n\r\n- 时间：O（N）\r\n- 空间：O（depth）\r\n\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n       // int depth=0;\r\n        if(root==null) return 0;\r\n        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"S-T-D":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836785905","body":"# 思路\r\n\r\n对数组 `A` 从后往前遍历，同时对 `K` 取 10 的余数，将遍历的数字和余数相加得到新值，并更新数组对应位置的值，同时注意是否进位。\r\n\r\n注意：`K` 的位数可能比 `A` 的长度要长。\r\n\r\n&nbsp;\r\n\r\n# 代码\r\n\r\n```javascript\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    const len = num.length;    \r\n    let i = len - 1;\r\n    let carry = 0;\r\n    while (i >= 0) {\r\n        let addNum = 0;\r\n        if (k !== 0) {\r\n            addNum = k % 10;\r\n            k = Math.floor(k / 10);\r\n        }\r\n        let sum = num[i] + carry + addNum;\r\n        carry = sum >= 10 ? 1 : 0;\r\n        num[i] = sum % 10;\r\n        i--;\r\n    }\r\n    k += carry;\r\n    while (k !== 0) {\r\n        num.unshift(k % 10);\r\n        k = Math.floor(k / 10);\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n&nbsp;\r\n\r\n# 复杂度分析\r\n\r\n令 `n` 为数组长度，`m` 为 `k` 的位数，按最坏情况\r\n\r\n时间：O(n + (m - n)^2)，第一个循环为 O(n)，第二个循环内在数组头部插入元素涉及数组的移动操作\r\n\r\n空间：O(m - n)，如果 `m` 大于 `n`，数组需要增加 `m - n` 的长度"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837706722","body":"## 思路\r\n\r\n可以分两次遍历。\r\n\r\n第一次遍历，从左往右，计算每个字符离左边的最近的 `c` 的距离。\r\n\r\n第二次遍历，从右往左，计算每个字符离右边最近的 `c` 的距离，再取最小值。\r\n\r\n## 代码\r\n\r\n```javascript\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    const ans = [];\r\n    const len = s.length;\r\n\r\n    let prev = -10000;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans.push(i - prev);\r\n    }\r\n\r\n    prev = 20000;\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            prev = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], prev - i);\r\n    }\r\n\r\n    return ans;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间：O(n)，`n` 为字符串的长度。  \r\n- 空间：O(1)，忽略返回的数组所占空间。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836787849","body":"思路：\r\n    转化为数组， 从末位起，两两相加，\r\n\r\n代码：\r\n```\r\n var addToArrayForm = function(num, k) {\r\n        let result = []\r\n        k = k.toString().split('')\r\n        let carryBit = 0\r\n        let _temp = 0\r\n        while(num.length > 0 || k.length > 0) {\r\n            let num1 = num.pop() \r\n            let num2 = k.pop() \r\n            num1 = num1 ? num1 * 1 : 0\r\n            num2 = num2 ? num2 * 1 : 0\r\n            _temp = num1 + num2 + carryBit\r\n            if(_temp > 9) {\r\n                carryBit = 1\r\n                _temp = _temp - 10\r\n            }else {\r\n                carryBit = 0\r\n            }\r\n            result.unshift(_temp)\r\n        }\r\n\r\n        if(carryBit > 0) {\r\n            result.unshift(1)\r\n        }\r\n        return result;\r\n    };\r\n```\r\nn = Math.max(num.length, k.length)\r\n时间复杂度：O(n)\r\n空间复杂度O(n)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838184466","body":"思路: 字符串转化为数组，找出匹配字符串在数组中的下标存为数组2；遍历数组，找出数组中差值最小的下标并返回\r\n语言: javascript\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    s = s.split('')\r\n    // 先遍历出C在数组中的位置\r\n    let subscript = []\r\n    let result = []\r\n    s.forEach((item, index) => {\r\n        if(item === c) {\r\n            subscript.push(index)\r\n        }\r\n    })\r\n    // \r\n    s.forEach((item, index) => {\r\n        let _min = subscript.reduce((pre, next) => {\r\n            return Math.min(pre, Math.abs(next - index))\r\n        }, Math.abs(subscript[0] - index))\r\n        result.push(_min)\r\n    })\r\n    return result\r\n};\r\n```\r\n\r\n复杂度：\r\n    字符串的长度 为m  \r\n    字符在字符串的个数为n \r\n    时间复杂度：O(m*n)\r\n    空间复杂度：O(m)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839398896","body":"思路：\r\n    使用数组模拟栈， 处理好边界问题\r\n 代码：javascript\r\n```js\r\nvar CustomStack = function(maxSize) {\r\n    // 初始化一个数组\r\n    this.list = []\r\n    this.maxSize = maxSize\r\n    return this.stack\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.list.length < this.maxSize){\r\n        this.list.push(x);\r\n    }\r\n    return this.list\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.list.length > 0){\r\n        return this.list.pop();\r\n    }else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\n/* 栈底的 k 个元素增加 val , 如果栈底的元素数量小于 k 个则所有的都增加 val\r\n 在这里注意 k 的值，其实栈是从下面向上面递增的，也就是说下面是从零开始的。即 i<k就好了。\r\n*/\r\nCustomStack.prototype.increment = function(k, val) {\r\n   let _index = 0\r\n    k =Math.min(k, this.list.length)\r\n    while(_index < k) {\r\n        let value = this.list[_index]\r\n        if(value != undefined) {\r\n            this.list[_index] = value *1 + val *1\r\n        }\r\n        _index ++\r\n    }\r\n    return this.list\r\n};\r\n```\r\n复杂度：push、pop  O(1)   increment O(k)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840321754","body":"思路： 递归 + 栈\r\n自己最开始没有想明白，参考其他同学思路，最终想明白且理解\r\n代码：\r\n```\r\nvar decodeString = function (s) {\r\n    let strStack = []  \r\n    let numStack = []\r\n    let result = ''\r\n    let num = 0\r\n    for(let value of s) {\r\n        if(!isNaN(value)) {\r\n            num =num * 10 + Number(value)\r\n        }else if(value === '[') {\r\n            strStack.push(result); \r\n            result = ''\r\n            numStack.push(num) \r\n            num = 0 \r\n        }else if(value === ']') {\r\n            result = strStack.pop() + result.repeat(numStack.pop())\r\n        }else {\r\n            result += value\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841304695","body":"思路：\r\n1. 用两个栈，stack1/stack2\r\n2. 入队时，push 到stack1\r\n3. 出队时：\r\n   如果stack2为空，将stack1中的所有元素逐一弹出，push到stack2中，stack2弹出栈顶元素\r\n   如果stack2不为空，stack2弹出栈顶元素\r\n\r\n代码：\r\n```\r\nvar MyQueue = function() {\r\n   this.stack1=[];//数据都保存在stack1\r\n   this.stack2=[];//数据从stack1出栈进入stack2\r\n   \r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if(this.stack2.length){//如果stack2不为空，说明数据全都移入了stack2，直接pop操作移除stack2的最后一位即为stack1 的第一位\r\n        return this.stack2.pop();\r\n    }else{\r\n        if(this.stack1.length){//如果stack1不为空\r\n            var len = this.stack1.length;\r\n            for(var i=0;i<len;i++){\r\n                this.stack2.push(this.stack1.pop());//将元素全部移入到stack2\r\n            }\r\n            return this.stack2.pop()//pop操作移除stack2的最后一位即为stack1 的第一位\r\n        }else{\r\n             return null\r\n        }\r\n         \r\n    }\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if(this.stack1.length==0){\r\n        return this.stack2[this.stack2.length-1]\r\n    }else if(this.stack2.length==0)\r\n    return this.stack1[0];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stack1.length==0&& this.stack2.length==0){//只有当两个stack均为空的时候才能证明队列为空\r\n        return true;\r\n    }else {\r\n        return false;\r\n    }\r\n};\r\n\r\n```\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841824842","body":"思路：\r\n    计算出链表的长度\r\n    计算出真正的翻转次数（k%len）\r\n    根据计算， 将链表分成两段， 将后面的分段放置在前面\r\n\r\n代码：\r\n```\r\nvar rotateRight = function(head, k) {\r\n    let len = 0  \r\n    let l = head  \r\n    let prev = null  \r\n    let last = null \r\n    // 计算出链表的长度\r\n    while(l){\r\n        len++\r\n        l=l.next\r\n    }\r\n    // 处理边界\r\n    if(len==0 || len==1 || k%len==0) return head \r\n    l = head\r\n    if(k>len){\r\n        k = k%len\r\n    }\r\n    let Nums = len - k\r\n    while(Nums>0){\r\n        if(Nums==1){\r\n            prev = l\r\n        }\r\n        l = l.next\r\n        Nums--\r\n    }\r\n    prev.next = null  \r\n    last = l  \r\n    while(l!==null){  \r\n        if(l.next==null){  \r\n            l.next = head \r\n            break\r\n        }\r\n        l = l.next\r\n    }\r\n    return last\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842130088","body":"思路：\r\n    因为是 n , n+ 1 的位置进行交换，所有可以使用递归的思想进行操作，写好边界条件进行递归\r\n\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    if(head === null) return null\r\n    if(head.next === null) return head\r\n\r\n    let newHead = head.next\r\n    let next = head.next.next\r\n    newHead.next = head\r\n    newHead.next.next = swapPairs(next)\r\n    return newHead\r\n};\r\n```\r\n复杂度：\r\n    时间：O(N)\r\n    空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843232889","body":"思路：链表转数组， 数组转tree\r\n代码：\r\n```javascript\r\nvar sortedListToBST = function(head) {\r\nlet array=[]\r\n  listToArray(head)\r\n   function listToArray(head) {\r\n     if(!head) return 0;\r\n     array.push(head.val)\r\n     listToArray(head.next)\r\n   }\r\n\r\n  function arrayToTree(array) {\r\n    if(array.length===0) return null;\r\n    let midIndex=Math.floor(array.length/2);\r\n    let root=new TreeNode(array[midIndex]);\r\n    root.left=arrayToTree(array.slice(0,midIndex))\r\n    root.right=arrayToTree(array.slice(midIndex+1))\r\n\r\n    return root\r\n  }\r\n  return arrayToTree(array)\r\n};\r\n```\r\n复杂度: \r\n "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844232212","body":"思路：\r\n\r\n代码:\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let tempA = headA,tempB  = headB\r\n    while(tempA ||tempB){\r\n        // 谁先遍历完，则另外一个是更长的链表，它需要重新再遍历，然后先消耗多出来的长度\r\n        if(!tempA){\r\n            headB =headB.next\r\n            tempB = tempB.next\r\n        }else if (!tempB){\r\n            headA =headA.next\r\n            tempA = tempA.next \r\n        }else{\r\n            tempA = tempA.next\r\n            tempB =tempB.next\r\n        }\r\n    }\r\n\r\n    // 跑完第一次遍历后， headA , headB 的长度已经是一致的了\r\n    while(headA){\r\n        if(headB === headA) return headB\r\n        headA = headA.next\r\n        headB = headB.next\r\n    }\r\n    return null\r\n\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845081089","body":"思路：\r\n    通过快慢指针的方式找出链表是否循环，当遇到循环的时候，重置慢指针为链表起点，然后两个指针在同时进行走，当再次相遇的时候， 则表示他们重复\r\n\r\n代码:\r\n```javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let slow = head\r\n    let fast = head\r\n    if(fast === null || fast.next === null) return null\r\n    while (fast) {\r\n        if(fast.next === null) return null\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n        if(fast === slow) {\r\n            fast = head\r\n            break\r\n        }\r\n    }\r\n    if(fast === null || fast.next === null) return null\r\n    //  当两个指针再次相交的时候， 则说明他们已经重合了\r\n    while (true) {\r\n        if(slow === fast) {\r\n            return fast\r\n        }\r\n        slow = slow.next\r\n        fast = fast.next\r\n    }\r\n};\r\n```\r\n复杂度:\r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845710748","body":"思路： 看见大家的双向链表用的这么6 我留下了不争气的泪水\r\n            先把自己的MAP 大法献上，在去慢慢研究双向链表\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.stack = new Map()\r\n    this.maxSize = capacity\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    key = key + ''\r\n    let value = this.stack.get(key)\r\n    if(value !== undefined) {\r\n        this.stack.delete(key)\r\n        this.stack.set(key, value)\r\n        return value\r\n    }else{\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    key = key + ''\r\n    let _value = this.stack.get(key)\r\n    // 如果当前已经有了 直接替换 且放在末尾\r\n    if(_value !== undefined) {\r\n        this.stack.delete(key)\r\n        this.stack.set(key, value)\r\n    }else {\r\n        if(this.stack.size >= this.maxSize) {\r\n            let stack = this.stack\r\n            let firstKey = [...stack.keys()][0]\r\n            this.stack.delete(firstKey)\r\n            this.stack.set(key, value)\r\n        }else {\r\n            this.stack.set(key, value)\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n----------更新------------\r\n看了力扣的解决方案，重新写了一次\r\n```javascript\r\n/*\r\n* @description 链表节点\r\n* @param {}\r\n */\r\n var ListNode = function(key, value) {\r\n     this.key = key\r\n     this.value = value\r\n     this.prev = null\r\n     this.next = null\r\n }\r\n\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity     // 最大数量\r\n    this.cache = new Map()   // 用来O(1)时间返回value, 存储格式  key => ListNode(key,value)\r\n    this.count = 0\r\n\r\n    this.dummyHead = new ListNode()\r\n    this.dummyTail = new ListNode()\r\n    // 双向链表  首尾相互连接\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyHead.prev = this.dummyHead\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if(!this.cache.get(key)) return -1;\r\n    const node = this.cache.get(key)\r\n    this.moveToHead(node)\r\n    return node.value\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    const node = this.cache.get(key)\r\n    if(node){\r\n        node.value = value;\r\n        this.cache.set(key, node)\r\n        this.moveToHead(node)\r\n    }else{\r\n        if(this.count === this.capacity){\r\n        this.removeLeastUsed()\r\n        }\r\n        const newNode = new ListNode(key, value)\r\n        this.cache.set(key, newNode)\r\n        this.addToHead(newNode)\r\n        this.count++\r\n    }\r\n   \r\n};\r\n\r\n/**\r\n* @description 移动当前节点头部\r\n* @return {Number} \r\n*/\r\nLRUCache.prototype.moveToHead = function(node){\r\n  this.removeFromList(node)\r\n  this.addToHead(node)\r\n}\r\n\r\nLRUCache.prototype.addToHead = function(node){\r\n    node.prev = this.dummyHead\r\n    node.next = this.dummyHead.next;\r\n    this.dummyHead.next.prev = node;\r\n    this.dummyHead.next = node;\r\n}\r\n\r\nLRUCache.prototype.removeLeastUsed = function(){\r\n  this.count--\r\n  const leastUsed = this.dummyTail.prev;\r\n  this.cache.delete(leastUsed.key);\r\n  this.removeFromList(leastUsed);\r\n}\r\n\r\nLRUCache.prototype.removeFromList = function(node){\r\n    let prevNode = node.prev\r\n    let postNode = node.next\r\n    prevNode.next = postNode\r\n    postNode.prev = prevNode\r\n}\r\n```\r\n\r\n时间和空间复杂度还是太高了 ， 就不分析了"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846348812","body":"```javascript\r\nvar maxDepth = function(root) {\r\n    if(root === null) return 0\r\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziwh":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836788224","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        int sum = 0;\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i >= 0 || k != 0 || sum != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            sum += x + y;\r\n            ans.add(sum % 10);\r\n            sum = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837651373","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n当前字符距离c最短距离 = Math.min(当前字符距离左边c字符最短距离, 当前字符距离右边边c字符最短距离)\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] prev = new int[s.length()];\r\n        int[] next = new int[s.length()];\r\n\r\n        int begin = -1;\r\n        int end = s.length();\r\n        for(int i = 0; i < s.length(); i++) {\r\n            int endLoc = s.length() - i - 1;\r\n            if(s.charAt(i) == c) {\r\n                begin = i;\r\n                prev[i] = 0;\r\n            } else {\r\n                if(begin < 0) prev[i] = Integer.MAX_VALUE;\r\n                else prev[i] = i - begin;\r\n            }\r\n            if(s.charAt(endLoc) == c) {\r\n                end = endLoc;\r\n                next[end] = 0;\r\n            } else {\r\n                if(end > s.length() - 1) next[endLoc] = Integer.MAX_VALUE;\r\n                else next[endLoc] = end - endLoc;\r\n            }\r\n        }\r\n\r\n        for(int i = 0; i < s.length(); i++) {\r\n            prev[i] = Math.min(prev[i], next[i]);\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839616610","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n用一个数组数组模拟栈的操作\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass CustomStack {\r\n\r\n    private int maxSize;\r\n    private List<Integer> list;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        list = new ArrayList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(list.size() >= maxSize) return;\r\n        else {\r\n            list.add(x);\r\n        }\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        if(list.size() < 1) return -1;\r\n        else {\r\n            int res = list.get(list.size() - 1);\r\n            list.remove(list.size() - 1);\r\n            return res;\r\n        }\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(list.size() < k) {\r\n            for(int i = 0; i < list.size(); i++) {\r\n                list.set(i, list.get(i) + val);\r\n            }\r\n        } else {\r\n            for(int i = 0; i < k; i++) {\r\n                list.set(i, list.get(i) + val);\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：push: O(1), pop: O(1), increment: O(k)\r\n\r\n空间复杂度: O(maxSize)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840929751","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n一个栈专门用作入栈，一个栈专门用作出栈，当出栈为空时，则把入栈中的元素全部转移到出栈中\r\n\r\n通过这种入栈出栈操作，保证了元素在入栈是先入，在出栈是先出的，达到了模拟队列的效果\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inputStack.push(x);\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        shift();\r\n        return outputStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        shift();\r\n        return outputStack.peek();\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inputStack.isEmpty() && outputStack.isEmpty();\r\n    }\r\n\r\n    public void shift() {\r\n        if(outputStack.isEmpty() && !inputStack.isEmpty()) {\r\n            while(!inputStack.isEmpty()) {\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: 均摊复杂度为O(1)\r\n\r\n空间复杂度: O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841765357","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n1.处理边界条件，当链表长度<=1时或者k==0时，直接把head return\r\n2.计算链表长度，同时记录下尾结点\r\n3.判断k与链表长度的关系，listSize % k == 0, 也直接return head\r\n4.寻找新的头结点，同时转换尾结点的指向和新头结点前一个节点的指向\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        int listSize = 1;\r\n        ListNode tmp = head;\r\n        while(tmp.next != null) {\r\n            listSize++;\r\n            tmp = tmp.next;\r\n        }\r\n\r\n        k = k % listSize;\r\n        if(k == 0) return head;\r\n        ListNode newHead = head;\r\n        for(int i = 1; i < listSize - k; i++) {\r\n            newHead = newHead.next;\r\n        }\r\n\r\n        ListNode lastNode = newHead;\r\n        newHead = lastNode.next;\r\n        lastNode.next = null;\r\n\r\n        tmp.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841936153","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n递归调用\r\n\r\n1.判断当前head是否为空或者是否只包含一个元素，是则返回\r\n\r\n2.交换前两个节点\r\n\r\n3.递归交换后续节点\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode tmp1 = head;\r\n        ListNode tmp2 = head.next;\r\n        ListNode tmp3 = tmp2.next;\r\n        tmp2.next = tmp1;\r\n        tmp1.next = swapPairs(tmp3);\r\n        return tmp2;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842728873","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n\r\n1.将链表转换为数组代替\r\n\r\n2.然后我们每次找到当前数组的中间节点，作为当前头结点，头结点的左孩子指向左数组的头结点，头结点的右孩子指向右数组的头结点\r\n\r\n3.递归调用\r\n\r\n\r\n## 代码\r\nJava\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        List<Integer> arr = new ArrayList<>();\r\n        ListNode tmp = head;\r\n        while(tmp != null) {\r\n            arr.add(tmp.val);\r\n            tmp = tmp.next;\r\n        }\r\n        TreeNode root = buildTree(arr, 0, arr.size());\r\n        return root;\r\n    }\r\n\r\n    private TreeNode buildTree(List<Integer> arr, int  begin , int end) {\r\n        if(end - begin < 1) return null;\r\n        int mid = (begin + end - 1) / 2;\r\n        TreeNode root = new TreeNode(arr.get(mid));\r\n        root.left = buildTree(arr, begin, mid);\r\n        root.right = buildTree(arr, mid + 1, end);\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843645828","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。\r\n当 pA到达链表的尾部时，将它重定位到链表 B 的头结点 \r\n当 pB到达链表的尾部时，将它重定位到链表 A 的头结点\r\n一直判断两链表是否相等\r\n\r\n## 代码\r\nJava\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA == null || headB == null) return null;\r\n        ListNode tmpA = headA;\r\n        ListNode tmpB = headB;\r\n        while(tmpA != tmpB) {\r\n            tmpA = tmpA != null ? tmpA.next : headB;\r\n            tmpB = tmpB != null ? tmpB.next : headA;\r\n        }\r\n\r\n        return tmpA;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(m +n)\r\n\r\n空间复杂度: O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844591531","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n哈希表+迭代\r\n\r\n## 代码\r\nJava\r\n```Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) return null;\r\n        HashMap<ListNode, Integer> map = new HashMap<>();\r\n        ListNode tmp = head;\r\n        int loc = 0;\r\n        while(tmp != null) {\r\n            if(map.containsKey(tmp)) {\r\n                return tmp;\r\n            } else {\r\n                map.put(tmp, loc);\r\n                tmp = tmp.next;\r\n            }\r\n        }\r\n        return null;\r\n\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845981942","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/lru-cache/\r\n\r\n哈希表+双向链表\r\n\r\n## 代码\r\nJava\r\n```Java\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int val;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int key, int val) {\r\n            this.key = key;\r\n            this.val = val;\r\n        }\r\n    }\r\n\r\n    private HashMap<Integer, DLinkedNode> cache = new HashMap<>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if(node == null) return -1;\r\n        moveToHead(node);\r\n        return node.val;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if(node == null) {\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if(size > capacity) {\r\n                DLinkedNode tail = removeTail();\r\n                cache.remove(tail.key);\r\n                --size;\r\n            } \r\n        } else {\r\n            node.val = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n    \r\n}\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: put get O(1)\r\n\r\n空间复杂度: O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846306019","body":"## 思路\r\n\r\n#### 题目地址：\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n递归\r\n\r\n## 代码\r\nJava\r\n```Java\r\npublic int maxDepth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n    }\r\n```\r\n\r\n## 复杂度\r\n时间复杂度: O(n)\r\n\r\n空间复杂度: O(height)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CruiseYuGH":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836790900","body":"## 思路\r\n\r\nsum_temp = num[i]+k%10 +temp\r\n分别更新temp 和 num[i]\r\n最后判别下是否有剩余的K or temp\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        temp = 0\r\n        for i in range(len(num)-1,-1,-1):\r\n            if k > 0 or temp>0:\r\n                sum_temp = num[i]+k%10 +temp\r\n                num[i]=sum_temp%10\r\n                temp = sum_temp//10\r\n                k = k//10\r\n        k+=temp\r\n        if k >0 :\r\n            while K:\r\n                num.insert(0,k%10)\r\n                k = k//10\r\n        return num\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838684275","body":"## 思路\r\n找出左右两边距离最近的，再取其中最小的\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        left  = [999 for i in range(len(s))]\r\n        right = [999 for i in range(len(s))]\r\n        for i in range(len(s)):\r\n            #print(i,len(s))\r\n            if s[i]==c:\r\n                left[i]=0\r\n            elif i!=0 and left[i-1]!=999 :\r\n                left[i] = left[i-1]+1\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i]==c:\r\n                right[i]=0\r\n            elif i!=len(s)-1 and right[i+1]!=999 :\r\n                right[i] = right[i+1]+1\r\n        res = [min(right[i],left[i]) for i in range(len(s))]\r\n        return res\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839885468","body":"思路\r\n用列表实现栈\r\n\r\n代码（Python3）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i]+=val\r\n\r\n\r\n复杂度\r\n时间复杂度：push O(1) pop O(1) increment O(k)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840618054","body":"1. 用栈实现括号匹配\r\n给定的字符串可以存储到一个栈中\r\n出栈入栈条件为：\r\n如果非]，就入栈\r\n如果是]，那么就循环出栈，直到找到一个匹配的[\r\n注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n代码\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        cur_num = 0\r\n        cur_str=\"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                cur_num = cur_num*10+int(c)\r\n            elif c is \"[\":\r\n                stack.append(cur_str)\r\n                stack.append(cur_num)\r\n                cur_str = ''\r\n                cur_num = 0\r\n            elif c is \"]\":\r\n                temp_num = stack.pop()\r\n                temp_str = stack.pop()\r\n                cur_str = temp_str + temp_num * cur_str\r\n            else:\r\n                cur_str+=c \r\n        return cur_str              \r\n复杂度分析\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841296621","body":"## 思路\r\n利用两个队列，来回倒腾\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #print(self.stack)\r\n        if len(self.stack)==0:\r\n            return\r\n        x = self.stack.pop()\r\n        #print(x)\r\n        return x\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        x = self.pop()\r\n        self.help_stack.append(x)\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n        #print(self.stack,self.help_stack)\r\n        return x\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680705","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count = collections.defaultdict(int)\r\n        ans = nonzero = 0\r\n        for x, y in zip(arr, sorted(arr)):\r\n            count[x] += 1\r\n            if count[x] == 0: nonzero -= 1\r\n            if count[x] == 1: nonzero += 1\r\n\r\n            count[y] -= 1\r\n            if count[y] == -1: nonzero += 1\r\n            if count[y] == 0: nonzero -= 1\r\n\r\n            if nonzero == 0: ans += 1\r\n\r\n        return ans\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(n)$\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842361356","body":"## 思路\r\nl 利用指针两两交换\r\n2 利用递归方式\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        newHead = ListNode(0)\r\n        newHead .next = head\r\n        temp = newHead \r\n        while temp.next and temp.next.next:\r\n            node1= temp.next\r\n            node2= temp.next.next\r\n            temp.next =node2\r\n            node1.next = node2.next\r\n            node2.next =node1\r\n            temp = node1\r\n        return newHead.next\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newhead = head.next\r\n        head.next = self.swapPairs(newhead.next)\r\n        newhead.next = head\r\n        return newhead\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843225758","body":"## 思路\r\n快慢指针+递归\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def mediu_node(left,right):\r\n            slow = left\r\n            fast = left\r\n            while fast!=right and fast.next!=right:\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        def build_tree(left,right):\r\n            if left == right:\r\n                return None\r\n            med = mediu_node(left,right)\r\n            root = TreeNode(med.val)\r\n            root.left = build_tree(left,med)\r\n            root.right = build_tree(med.next,right)\r\n            return root\r\n        return build_tree(head,None)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844199079","body":"## 思路\r\n双指针，\r\n利用双指针同时后移位，抹去listA 、listB之间的差距。找到相连节点\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        P_A, P_B = headA,headB\r\n        while P_A!=P_B:\r\n            if P_A: P_A=P_A.next\r\n            else: P_A=headB\r\n            if P_B: P_B=P_B.next\r\n            else: P_B=headA\r\n        return P_A\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845182890","body":"\r\n## 思路\r\n快慢指针：首先找到快指针与慢指针相遇的位置，然后让快指针指向头，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow =slow.next\r\n            fast =fast.next.next\r\n            if fast ==slow:\r\n                fast =head\r\n                while fast!=slow:\r\n                    fast = fast.next\r\n                    slow = slow.next\r\n                return fast\r\n        return None\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846018107","body":"## 思路\r\n利用哈希表存储key node ，利用双向链表实现时间复杂度为O(1)\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Dlink:\r\n    def __init__(self,key=0,value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.pre = None\r\n        self.next = None\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache =dict()\r\n        self.head = Dlink()\r\n        self.tail = Dlink()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.move_to_head(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = Dlink(key,value)\r\n            self.cache[key] = node\r\n            self.add_to_head(node)\r\n            self.size +=1\r\n            if self.size > self.capacity:\r\n                tail = self.remove_tail()\r\n                self.cache.pop(tail.key)\r\n                self.size -=1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.move_to_head(node)\r\n\r\n    def add_to_head(self,node):\r\n        #print(node)\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n    \r\n    def remove_node(self, node):\r\n        #print(node.value)\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n\r\n    def move_to_head(self, node):\r\n        self.remove_node(node)\r\n        self.add_to_head(node)\r\n    def remove_tail(self):\r\n        tail = self.tail.pre\r\n        self.remove_node(tail)\r\n        return tail\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846423950","body":"## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(heigh)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johanazhu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836791845","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位) % 10\r\n\r\n注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\r\n\r\n```\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位\r\n    \r\n    // 循环条件调整\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n```\r\n\r\n## 代码\r\n\r\nJavascript\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    k = k.toString();\r\n    let aLen = num.length, kLen = k.length;\r\n    num.reverse();\r\n    if(aLen > kLen) {\r\n        k = '0'.repeat(aLen - kLen) + k;\r\n    } else if(aLen < kLen) {\r\n        for(let i = 0; i < kLen - aLen; i++) {\r\n            num.push(0);\r\n        }\r\n    }\r\n    k = k.split('').reverse();\r\n    let sum = 0, carry = 0, res = [];\r\n    num.forEach((item, i)=>{\r\n        sum = item + + k[i] + carry;\r\n        carry = parseInt(sum / 10);\r\n        res.push(sum % 10)\r\n    })\r\n    if(carry > 0) {\r\n        res.push(carry)\r\n    }\r\n    return res.reverse();\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(max(n, log(k))\r\n空间复杂度: O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839255302","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/submissions/\r\n\r\n栈是由数组构成，原型中的push、pop是利用数组原有的方法push、pop做封装，而increment则通过传入的参数与栈的长度作对比，大于则给每个元素加上val；小于，则截至到k\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length >= this.maxSize) {\r\n        return \r\n    }\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length === 0) {\r\n        return -1\r\n    }\r\n    return this.stack.pop()\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (this.stack.length <= k) {\r\n        for (var i = 0; i < this.stack.length; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    } else {\r\n        for(var i =0; i<k; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：..\r\n空间复杂度: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840621336","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n栈，\r\n\r\n如果是遇到的不是“]”，就往栈里压\r\n\r\n如果遇到“]”，就往栈里压“[]”前的数字*“[]”中的字母\r\n\r\n设置重复的数字为repeatCount，重复的字母为repeatStr，如何获取\r\n\r\n\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n      let stack = []; // 保存需要 repeat 的字符串\r\n    let times = ''; // 乘以的倍数\r\n\r\n    for (let i = 0, len = s.length; i < len; i++) {\r\n        let item = s[i];\r\n\r\n        if (/[0-9]/.test(item)) {\r\n            if (i === 0 || /[0-9]/.test(s[i - 1])) {\r\n                times += item;\r\n            } else {\r\n                times = item\r\n            }\r\n        } else if (item === '[') {\r\n            times && stack.push(Number(times));\r\n            times = '';\r\n        } else if (item === ']') {\r\n            var curr = stack.pop();\r\n            var temp = '';\r\n            while (typeof curr !== 'number') {\r\n                temp = curr + temp;\r\n                curr = stack.pop();\r\n            }\r\n            temp = temp.repeat(curr);\r\n            stack.push(temp);\r\n        } else {\r\n            stack.push(item);\r\n        }\r\n    }\r\n    return stack.join('');\r\n\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840882273","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/submissions/\r\n\r\n注意分析：仅使用两个栈实现先入先出队列。而且使用的是pop和push，没说不能用shift，但估计是不希望我们用\r\n\r\n思考一下其实就是两个壶装水问题\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helperStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null;\r\n    // 关键是这步，如果 this.stack 有值，当它 this.stack.pop() 后得到的是出栈的值\r\n    // 当它无值时，cur = undefined，while 退出循环\r\n    while((cur = this.stack.pop())) {\r\n        this.helperStack.push(cur)\r\n    }\r\n    this.helperStack.push(x)\r\n    while((cur = this.helperStack.pop())) {\r\n        this.stack.push(cur)\r\n    }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841569441","body":"## 思路\r\n\r\n#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n不会，看刷题秘籍抄的\r\n\r\n我的理解是 压入的值不能比当前的值小，如果小的话，就循环弹出\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    var stack = []\r\n    for (var i = 0; i < arr.length; i++) {\r\n        var a = arr[i];\r\n        if (stack.length > 0 && stack[stack.length - 1] > a) {\r\n            const cur = stack[stack.length - 1]\r\n            while(stack && stack[stack.length - 1] > a) stack.pop()\r\n            stack.push(cur)\r\n        } else {\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841747740","body":"#### 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n\r\n\r\n## 思路\r\n\r\n不会，看刷题秘籍抄的\r\n\r\n对于零基础的我来说，算法里还有快慢指针之说，快指针比慢指针走的快一步\r\n\r\n刷了几天题，发现大多数算法里都用到了while\r\n\r\n满足条件时，就在{}执行，不满足时退出，\r\n\r\n牛逼牛逼\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) return head;\r\n    let count = 0,\r\n        now = head;\r\n    while(now) {\r\n        now = now.next;\r\n        count++\r\n    }\r\n    k = k % count;\r\n    let slow = (fast = head);\r\n\r\n    while (fast.next) {\r\n        if (k-- <= 0) {\r\n            slow = slow.next\r\n        }\r\n        fast = fast.next\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res;\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841891250","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n\r\n\r\n## 思路\r\n\r\n不会，看刷题秘籍抄的\r\n\r\n简单来说使用递归的方法来实现\r\n\r\n关注最小子实现，即将两个节点进行逆转\r\n\r\n链表是痛，要看 [链表专题](https://leetcode-solution.cn/solutionDetail?url=https%3A%2F%2Fapi.github.com%2Frepos%2Fazl397985856%2Fleetcode%2Fcontents%2Fthinkings%2Flinked-list.md&type=1) 好好学习\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let nextNode = head.next;\r\n    head.next = swapPairs(nextNode.next);\r\n    nextNode.next = head;\r\n    return nextNode;\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842697571","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n\r\n\r\n## 思路\r\n\r\n最主要是对数据结构的了解，在不动单链表和二叉搜索树的前提，真的不会做\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if (!head) return null;\r\n    return run(head, null)\r\n};\r\n\r\nfunction run(head, tail) {\r\n    if (head === tail) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while(fast != tail && fast.next != tail) {\r\n        fast = fast.next.next;\r\n        slow = slow.next\r\n    }\r\n    let root = new TreeNode(slow.val)\r\n    root.left = run(head, slow)\r\n    root.right = run(slow.next, tail)\r\n    return root\r\n}\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：节点最多只遍历 N*logN 遍，时间复杂度为O(NlogN)O(NlogN)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843625396","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n\r\n\r\n## 思路\r\n\r\n两种解题思路\r\n\r\n一种是哈希\r\n\r\n​\t先循环headA，把其中的值存起来，再循环headB，查找headB中是否存在其值，如果有，返回之，没有返回null\r\n\r\n一种是双指针\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n   \t// 哈希\r\n    let data = new Set()\r\n    while(headA !== null) {\r\n        data.add(headA)\r\n        headA = headA.next\r\n    }\r\n    while(headB !== null) {\r\n        if(data.has(headB)) return headB\r\n        headB = headB.next\r\n    }\r\n\r\n    return null\r\n\t// 双指针\r\n    // let a = headA,\r\n    //     b = headB;\r\n    // while (a != b) {\r\n    //     a = a === null ? headB : a.next;\r\n    //     b = b === null ? headA : b.next;\r\n    // }\r\n    // return a;\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845169044","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n\r\n\r\n## 思路\r\n\r\n今天早起看《凤凰项目——一个IT运维的传奇故事》看入迷了，加上睡眠不足，就没有早起打卡。\r\n\r\n经过一段时间的链表训练，对链表的第一反应：while(head !== null) { ... head = head.next }\r\n\r\n这题使用哈希法解决，设置set值，遍历整个链表，如果data中没有，存到data中，如果有，则返回这个head\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let data = new Set()\r\n    while(head !== null) {\r\n       if(data.has(head)) {\r\n           return head\r\n       }else {\r\n           data.add(head)\r\n       }\r\n       head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845982686","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n\r\n\r\n\r\n## 思路\r\n\r\n设计个缓存机制，关键在于 map 的使用\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity\r\n    this.cache = new Map()\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.cache.get(key)\r\n    if(value === undefined){\r\n        return -1;\r\n    }\r\n    this.cache.delete(key);\r\n    this.cache.set(key, value);\r\n    return value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.cache.has(key)){\r\n        this.cache.delete(key);\r\n    }\r\n    this.cache.set(key,value);\r\n    if(this.cache.size > this.capacity){\r\n        let keyIterator = this.cache.keys();\r\n        this.cache.delete(keyIterator.next().value);\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846319227","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n\r\n\r\n## 思路\r\n\r\n这个题简单，使用二叉树，先循环左边的，再循环右边的，递归思想\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0; // root 为 null 时，说明这一层没有节点数\r\n    }\r\n    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846482785","body":"## 题目地址：\r\n\r\nhttps://leetcode-cn.com/problems/same-tree/\r\n\r\n\r\n\r\n## 思路\r\n\r\n看到 **[lilyzhaoyilu](https://github.com/lilyzhaoyilu)** 大老师的解题，有三种，我只选择了DFS（深度优先），比较好理解，左边和右边的每一个值是否相同来做判断\r\n\r\n\r\n\r\n## 代码\r\n\r\nJavaScript\r\n\r\n```javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n    if(!p && !q) return true;\r\n    if(!p || !q) return false;\r\n    if(p.val !== q.val) return false;\r\n\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zengwmFE":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836792060","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let target = 0\r\n    let sum = 0\r\n    for(let i=num.length-1;i>=0;i--){\r\n        sum = num[i]+k%10+target \r\n        num[i] = sum%10\r\n        target = Math.floor(sum/10)   \r\n         k = Math.floor(k/10)\r\n\r\n    }\r\n    k = target + Number(k)\r\n    if(k){\r\n        let str = String(k)\r\n        for(let i=str.length-1;i>=0;i--){\r\n            num.unshift(str[i])\r\n        }\r\n    }\r\n    return num\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838635265","body":"[题解同步到leetcode](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/liang-duan-xun-huan-que-ding-ju-chi-by-z-iryn/)\r\n自己写写思路，希望下次不要忘了，91奥利给\r\n## 思路\r\n令当前起始值为-1，如果第一个值\r\n这里采用，左右两端分别进行循环\r\n这里的关键在于如何处理匹配`c`之后的值：\r\n\r\n> 从右往左循环，可以拿到值离右边最近的`c`的距离\r\n> 如果当前这个值`s[i]`恰好等于`c`的时候，那么这个地方的pos[i] = 0，当然如果当前这个值之前还没有发现有`c`的存在的时候，这个时候，咱也不晓得（🤷‍♂️）这值是啥啊，那就可以先跳过这个位置：**即保留-1的状态值**，当找到了这个值的时候，就拿个东东（current）标识一哈：**current=i**，老铁开始出现了，那么就可以着手去更改位置的值了，那么这个位置是什么呢:?令i=2,current=1,距离是:高减低`current-i`.这样就得出了一个位置表达式\r\n\r\n> 从左往右循环，可以拿到值离左边最近的`c`的距离，一开始需要填填之前没有找到位置的地方，给他填好值吧，然后操作基本跟从右往左是一致的，但是距离表达式为**高减低`i-current`**，而且当遇到不为`-1`值的时候，我们需要判断两者的距离位置，最后肯定是要取一个小小的值！\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let pos = new Array(len).fill(-1)\r\n    let current = -1\r\n    for(let i=len-1;i>=0;i--){\r\n        if(s[i] == c){\r\n            current = i\r\n            pos[i] = 0\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = current-i\r\n        }\r\n\r\n    }\r\n    current = -1\r\n    for(let i=0;i<len;i++){\r\n        if(pos[i]===-1){\r\n            pos[i] = i-current\r\n        }\r\n        if(current!==-1){\r\n            pos[i] = Math.min(i-current,pos[i])\r\n        }\r\n        if(s[i]===c){\r\n            current = i\r\n        }\r\n    }\r\n    return pos\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840604606","body":"### 辅助栈法：\r\n思路：\r\n1. 数字首先需要单独取出来  要记住这个地方不是单独取一个，因为可能是10位也可能是百位\r\n2. 然后是`[`,先分析一下这个位置的，有什么内容，我们得到了一串数字，以及上一个集合留下的字符串res,以及`[`前的数字num\r\n     - 如果遇到了`[`，需要做的就是将字符串和数字入栈\r\n     - 同时清空这个字符串，可以避免和下次的重叠，同时将数字置为0\r\n3. 接着`]`，遇到这个内容，很明显就是已经把当前有效的字符都加完了，剩下的事就是按照这串文字前面的数字重复得到真正的明文res，那么这个值在哪？**栈顶**，因为很明显，`[`，肯定是立马有一个对应`]`，不管是`[[]]`还是`[]`，总有一个`[`对应着一个`]`,这个时候刚放进的，肯定是对应我们新的`]`，将栈顶出栈，res.repeat(pop[1])，这个就是我们这一次有效字符的真正解了，然后当然需要将我们之前一部分的有效集合接起来，即：`pop[0]+res.repeat(pop[1])`这样就是一个有效集合如：`a3[b]`的真正的解\r\n4. 最后处理正常的字符直接连接起来\r\n```\r\n let num = 0\r\n    let list = []\r\n    let res = ''\r\n    for(let i=0;i<s.length;i++){\r\n        if(/\\d/.test(s[i])){\r\n            // 数字\r\n            num = num*10+Number(s[i])\r\n            continue\r\n        }\r\n        if(s[i]==='['){\r\n            list.push([res,num])\r\n            res = '',num=0\r\n        }else if(s[i]===']'){\r\n            let top = list.pop()\r\n            res = top[0] + res.repeat(top[1])\r\n            \r\n        }else{\r\n            res += s[i]\r\n        }\r\n    }\r\n    return res\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### 深度优先遍历\r\n思路：\r\n1. 首先对于数字的处理跟辅助栈是一样的\r\n2. 对`[`进行处理，这个时候标志了一个集合的开始，那么我们就可以从`i+1`的位置开始进行递归，而递归返回的就是这次有效集合的`res`和下次开始的位置，res+=temp.repeat(num)，同时从下一个位置继续循环\r\n3. 对`]`进行处理，这个标志了一个集合的结束，我们得到的`res`就是我们这一次所有的内容，记录结束位置，将[res,i]返回\r\n4.对普通字符处理同上\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let dfs = function(s,index){\r\n        let res = '',num=0\r\n           while(index<s.length){\r\n               if(/\\d/.test(s[index])){\r\n                   num = num*10+Number(s[index])\r\n               }else if(s[index]==='['){\r\n                   let [temp,i] = dfs(s,index+1)\r\n                   res+=temp.repeat(num)\r\n                   index = i\r\n                   num = 0\r\n               }else if(s[index]===']'){\r\n                   return [res,index]\r\n               }else{\r\n                   res+=s[index]\r\n               }\r\n               index++\r\n           }  \r\n        return res\r\n    }\r\n    return dfs(s,0)\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841679248","body":"```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let current = [...arr].sort((a,b)=>a-b)\r\n    let sum0=0,sum1=0;\r\n    let sum = 0\r\n    let len = current.length;\r\n    for(let i=0;i<len;i++){\r\n        sum0+=current[i]\r\n        sum1+=arr[i]\r\n        if(sum0===sum1){\r\n            sum++\r\n        }\r\n    }\r\n    return sum\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841817180","body":"### 旋转链表\r\n要考虑：\r\n令链表长度为n\r\n1. 首先k分为：0，1-n   m*n这几种情况，所以需要增加求余的过程，如果k为小余n的数，则需要将多少个移动出去。那么真正链表指针移动的距离：`deep-k%deep` 的位置如【[1,2,3,4,5],2】=>我们需要移动到3的位置，然后断开3和4的连接，我们移动的次数为`deep-k%deep-1`，这样得到的就是2个链表，将最右边的值next指向head，接着更改head的位置\r\n\r\n> 在这里需要提前得到的值为，链表的最后一个值的`next` ，`last.next` 来接到`head` 的位置，要断开的位置`check` \r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head||!head.next||!k) return head\r\n    let tail = head\r\n    let deep = 0\r\n    while(tail){\r\n        tail = tail.next\r\n        deep++\r\n    }\r\n    if(k%deep===0) return head\r\n    let last = head\r\n    while(last.next){\r\n        last = last.next\r\n    }\r\n    k = deep-k%deep-1\r\n    let check = head\r\n    while(k>0){\r\n        check = check.next\r\n        k--\r\n    }\r\n    let next = check.next\r\n    check.next = null\r\n    last.next = head\r\n    head = next\r\n    return head\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842371915","body":"思路：\r\n头插法（穿针引线）\r\n首先，链表解法，多数需要增加一个空头（切记），题目会好解点\r\n关键就是：\r\n1. 首先将头指向要交换的后者，这样就能保证dyHead，永远是头节点。\r\n2. 然后将第一个节点指向第二个节点的下一个节点\r\n3. 然后将第二个节点指向第一个节点，这样就形成了正确的链式结构\r\n4. 然后移动newNode的指针，准备进行下一步操作\r\n         \r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    let hyHead = new ListNode()\r\n    let newNode = hyHead\r\n    hyHead.next = head\r\n    while(newNode.next&&newNode.next.next){\r\n        let temp = newNode.next\r\n        let next = newNode.next.next\r\n        newNode.next = next\r\n        temp.next = next.next\r\n        next.next = temp\r\n        newNode = temp\r\n    }\r\n    return hyHead.next\r\n};\r\n```\r\n时间复杂度：O（N）\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843267892","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    let root = head\r\n    let list = []\r\n    while(root){\r\n        list.push(root.val)\r\n        root = root.next\r\n    }\r\n    return dfs(list,0,list.length-1)\r\n};\r\nfunction dfs (list,l,r){\r\n    let mid = (l+r)>>1\r\n    if(l>r) return null\r\n    let newTree = new TreeNode(list[mid])\r\n    newTree.left = dfs(list,l,mid-1)\r\n    \r\n    newTree.right = dfs(list,mid+1,r)\r\n    return newTree\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844122826","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let A = headA\r\n    let B = headB\r\n    while(A!=B){\r\n        A = !A?headB:A.next\r\n        B = !B?headA:B.next\r\n    }\r\n    return A\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845155181","body":"### 哈希表\r\n属于暴力解法之一\r\n就是判断第一个存在的节点\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let type = new Set()\r\n    while(head){\r\n        if(type.has(head)){\r\n            return head\r\n        }else{\r\n             type.add(head)\r\n        }\r\n        \r\n        head = head.next\r\n    }\r\n    \r\n    return null\r\n};\r\n\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n### 快慢指针\r\n快慢指针是验证是否有环的方法之一\r\n用的就是，快（一次走两格）慢（一次走一格）指针同时往前走，第一次相遇后，然后将快指针指向头，然后快指针以走一格的方法来走\r\n当第二次相遇的时候，就是交集的地方。\r\n\r\n首先肯定是要让他们一起往前走啦，否则，第一次的判断就不成立了。\r\n\r\n公式推导：\r\n设head到入圈的长度为l\r\n相遇点为K\r\n整个圈的长度为L\r\n他们要相遇的话，就能有一个相交点：\r\n2*(l+K) = l+K+n*L  (n取值为0～MAX_VALUE，取值为正整数)\r\n=>l = -K+n*L\r\n然后看慢指针的走势：L-K+m*L   => (m+1)*L -K  是不是跟-K+n*L很像\r\n那么我们可以知道无论之前快指针走了几圈，还是l长度，都是无关的 。所以我们知道两点会在入口点相遇，这也就是为什么快指针要重置会头部的缘由，然后以速度一样来走\r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let fast = head,slow = head\r\n    do{\r\n        if(!fast||!fast.next) return null\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }while(fast!==slow);\r\n\r\n    fast = head\r\n    while(fast!=slow){\r\n        fast = fast.next\r\n        slow = slow.next\r\n    }\r\n    return fast\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846381350","body":"### BFS\r\n一眼看过去，层序遍历，肯定能搞\r\n要求层，肯定要分层\r\n套公式，首先将root放入\r\n然后遍历整个数组长度，记住，这个地方的len一定要保存起来，因为我们后续还要加入进去\r\n由于我们采用的是从前面加入，那么就一定要从前面移出。这样就能保证我们在队列里面的一直是最新的，即队列的基本原理，队尾加入，队首出\r\n\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0\r\n    let res = [root]\r\n    let sum = 0\r\n    while(res.length){\r\n        sum+=1\r\n        let len = res.length\r\n       for(let i=0;i<len;i++){\r\n           let result = res.pop()\r\n            if(result.left){\r\n                res.unshift(result.left)\r\n            }\r\n            if(result.right){\r\n                res.unshift(result.right)\r\n            }\r\n       }\r\n    }\r\n    return sum\r\n};\r\n\r\n```\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n### DFS\r\n\r\n思路：\r\n1. 进行边界值判断\r\n2. 比较左右两个子树的深度\r\n```\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0\r\n    return Math.max(maxDepth(root.right),maxDepth(root.left))+1\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dorothyDing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836793890","body":"javascript\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let numStr = num.join('')\r\n    let maxLength = Math.max(numStr.length, k.toString().length)\r\n    numArr = numStr.padStart(maxLength, '0').split('').reverse()\r\n    kArr = k.toString().padStart(maxLength, '0').split('').reverse()\r\n    let flag = 0\r\n    for(let i = 0; i < maxLength; i++) {\r\n        let sum = Number(numArr[i]) + Number(kArr[i]) + flag\r\n        if (sum >= 10) {\r\n            flag = 1\r\n            sum -= 10\r\n        } else {\r\n            flag = 0\r\n        }\r\n        numArr[i] = sum\r\n    }\r\n    if (flag) {\r\n        numArr.push(flag)\r\n    }\r\n    return numArr.reverse().map(i => Number(i))\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度:  O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838686757","body":"javascript\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let indexs = s.split('').map((item, index) => item === c ? index : null).filter(item => item != null)\r\n    return s.split('').map((_, index) => Math.min(...indexs.map(i => Math.abs(i - index))))\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886372","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n    s = []\r\n    t=0\r\n    n = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(t<n) s[++t]=x\r\n    return s\r\n\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(t)return s[t--]\r\n    return -1\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    while(k) s[k--]+=val\r\n\r\n};\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682291","body":"javascript\r\n```js\r\n// 滑动窗口\r\nvar maxChunksToSorted = function(arr) {\r\n    let arrSorted = [...arr]\r\n    arrSorted.sort((a, b) => a - b)\r\n    let sum1 = 0\r\n    let sum2 = 0\r\n    let count = 0\r\n    for(let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += arrSorted[i]\r\n        if (sum1 == sum2) {\r\n            count ++\r\n        }\r\n    }\r\n\r\n    return count\r\n};\r\n```\r\n\r\n复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762669","body":"javascript\r\n```js\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n\r\n    let add = n - k % n;\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```\r\n复杂度分析\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842428176","body":"javascript\r\n```js\r\nvar swapPairs = function(head) {\r\n    if (head === null|| head.next === null) {\r\n        return head;\r\n    }\r\n    const newHead = head.next;\r\n    head.next = swapPairs(newHead.next);\r\n    newHead.next = head;\r\n    return newHead;\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843284453","body":"```js\r\nvar sortedListToBST = function(head) {\r\n    let arr = []\r\n    while(head){\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n\r\n    const buildBST = function (start, end) {\r\n        if (start > end) return null\r\n        const mid = (start + end) >>> 1\r\n        const root = new TreeNode(arr[mid])\r\n        root.left = buildBST(start, mid - 1)\r\n        root.right = buildBST(mid + 1, end)\r\n        return root\r\n    }\r\n\r\n    return buildBST(0, arr.length - 1)\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843779462","body":"- javascript\r\n## hash\r\n```js\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) return null\r\n    const s = new Map()\r\n    while(headA) {\r\n        s.set(headA, headA.val)\r\n        headA = headA.next\r\n    }\r\n\r\n    while(headB) {\r\n        if (s.has(headB)) {\r\n            return headB\r\n        } else {\r\n            headB = headB.next\r\n        }\r\n    }\r\n    return null\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n## 双指针\r\n```js\r\nvar getIntersectionNode = (headA, headB) => {\r\n    if (!headA || !headB) return null\r\n\r\n    let a = headA\r\n    let b = headB\r\n    while(a !== b) {\r\n        a = a.next == null ? headB : a.next\r\n        b = b.next == null ? headA : b.next      \r\n    }\r\n    return a\r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845008401","body":"- javascript\r\n## 标记方法\r\n```js\r\nvar detectCycle = function(head) {\r\n    if (!head || !head.next) return null\r\n    \r\n    while(head) {\r\n        if (head.flag == 1) return head\r\n        head.flag = 1\r\n        head = head.next\r\n    }\r\n\r\n    return null\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n\r\n## 双指针\r\n```js\r\nvar detectCycle = function(head) {\r\n    if (!head || !head.next) return null\r\n\r\n    let slow = head\r\n    let fast = head\r\n    while(slow && fast) {\r\n        if (slow == fast) {\r\n            return slow\r\n        } else {\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        }\r\n    }\r\n\r\n    return null\r\n}\r\n```\r\n时间复杂度\b：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846044947","body":"```js\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.prev = null;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        // Mappings of key->node.\r\n        this.hashmap = {};\r\n        // Use two dummy nodes so that we don't have to deal with the head/tail seperately.\r\n        this.dummyHead = new DoubleLinkedListNode(null, null);\r\n        this.dummyTail = new DoubleLinkedListNode(null, null);\r\n        this.dummyHead.next = this.dummyTail;\r\n        this.dummyTail.prev = this.dummyHead;\r\n    }\r\n\r\n    _isFull() {\r\n        return Object.keys(this.hashmap).length === this.capacity;\r\n    }\r\n\r\n    _removeNode(node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        node.prev = null;\r\n        node.next = null;\r\n        return node;\r\n    }\r\n\r\n    _addToHead(node) {\r\n        const head = this.dummyHead.next;\r\n        node.next = head;\r\n        head.prev = node;\r\n        node.prev = this.dummyHead;\r\n        this.dummyHead.next = node;\r\n    }\r\n\r\n    get(key) {\r\n        if (key in this.hashmap) {\r\n            const node = this.hashmap[key];\r\n            this._addToHead(this._removeNode(node));\r\n            return node.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    put(key, value) {\r\n        if (key in this.hashmap) {\r\n            // If key exists, update the corresponding node and move it to the head.\r\n            const node = this.hashmap[key];\r\n            node.value = value;\r\n            this._addToHead(this._removeNode(node));\r\n        } else {\r\n            if (this._isFull()) {\r\n                const node = this.dummyTail.prev;\r\n                delete this.hashmap[node.key];\r\n                this._removeNode(node);\r\n            }\r\n            // Create a new node and add it to the head.\r\n            const node = new DoubleLinkedListNode(key, value);\r\n            this.hashmap[key] = node;\r\n            this._addToHead(node);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846525532","body":"- javascript\r\n```js\r\n // DFS\r\nvar isSameTree = function(p, q) {\r\n    if (p == null && q == null) return true\r\n    if (q == null || p == null) return false\r\n    if (q.val !== p.val) return false\r\n\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```\r\n- 复杂度分析\r\n 空间复杂度 O(min(left, right)) left左子树的节点数 right右子树的节点数\r\n 时间复杂度 O(min(left, right)) "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mittacy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836795620","body":"### 思路\r\n\r\n从后往前遍历num，和k进行加法运算并进位，每次存入数组(该数组是从低位往高位存储的)，直到k=0，最后反转数组\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    ans := make([]int, 0)\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k%10)\r\n        k /= 10\r\n    }\r\n\r\n    i, j := 0, len(ans)-1\r\n    for i < j {\r\n        ans[i], ans[j] = ans[j], ans[i]\r\n        i++\r\n        j--\r\n    }\r\n    return ans\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(max(N, logk))，其中 N 为数组长度。(k / 10^n = 1 => logk)\r\n- 空间复杂度：O(1)，除了返回值为数组外，其他都为常量\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838160036","body":"### 思路\r\n\r\n两端遍历\r\n1. 从前往后，res[curIndex] = curIndex - newTargetIndex\r\n2. 从后往前，res[curIndex] = min(res[curIndex], newTargetIndex-curIndex)\r\n其中，newTargetIndex为目标字符最新出现索引位置\r\n\r\n### 代码\r\n\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    res := make([]int, len(s))\r\n    // 1<=s.length<=10000, targetIndex-10000<0, 所以应该设置targetIndex为-10000\r\n    targetIndex := -10000\r\n    for i := 0; i < len(s); i++ {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = i - targetIndex\r\n    }\r\n\r\n    // 1<=s.length<=10000, targetIndex-10000>10000, 所以应该设置targetIndex为20000\r\n    targetIndex = 20000 \r\n    for i := len(s)-1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            targetIndex = i\r\n        }\r\n        res[i] = min(res[i], targetIndex - i)\r\n    }\r\n    return res\r\n}\r\n\r\nfunc min(i, j int) int {\r\n    if i < j {\r\n        return i\r\n    }\r\n    return j\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串s的长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839715318","body":"### 思路\r\n\r\n创建一个数组作为栈存储数据，使用i和size字段分别表示当前存储到的位置以及栈的容量\r\n\r\n```go\r\ntype CustomStack struct {\r\n    val []int\r\n    size int\r\n    i int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{\r\n        val: make([]int, maxSize),\r\n        size: maxSize,\r\n        i: 0,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.i >= this.size {\r\n        return\r\n    }\r\n    this.val[this.i] = x\r\n    this.i++\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() (res int) {\r\n    if this.i == 0 {\r\n        return -1\r\n    }\r\n    this.i--\r\n    res = this.val[this.i]\r\n    return\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > this.size {\r\n        k = this.size\r\n    }\r\n    for cur := 0; cur < k; cur++ {\r\n        this.val[cur] += val\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、pop:O(1)，Increment: O(k)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840640798","body":"### 思路\r\n1. 建立栈，遍历字符串往栈内添加字符\r\n2. 如果字符为 ] , 出栈直到找到 [ ,再取数字, 处理字符放回栈中\r\n3. 最后栈即为结果字符串\r\n\r\n### 代码\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tres := Stack{}\r\n\tsByte := []byte(s)\r\n\r\n\tfor _, v := range sByte {\r\n\t\tif v != ']' {\r\n\t\t\tres.Push(v)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\trepeatStr := \"\"\r\n\t\trepeatCount := \"\"\r\n\t\tfor !res.Empty() && res.Top() != '[' {\r\n\t\t\trepeatStr = string(res.Pop()) + repeatStr\r\n\t\t}\r\n\r\n\t\tres.Pop()\r\n\r\n\t\tfor !res.Empty() && res.Top() >= '0' && res.Top() <= '9' {\r\n\t\t\trepeatCount = string(res.Pop()) + repeatCount\r\n\t\t}\r\n\t\tcount, _ := strconv.Atoi(repeatCount)\r\n\t\ttmp := \"\"\r\n\t\tfor count > 0 {\r\n\t\t\ttmp += repeatStr\r\n\t\t\tcount--\r\n\t\t}\r\n\r\n\t\tres.PushSlice([]byte(tmp))\r\n\t}\r\n\treturn string(res.Val())\r\n}\r\n\r\ntype Stack struct {\r\n\tval []byte\r\n}\r\n\r\nfunc (s *Stack) Val() []byte {\r\n\treturn s.val\r\n}\r\n\r\nfunc (s *Stack) PushSlice(b []byte) {\r\n\ts.val = append(s.val, b...)\r\n}\r\n\r\nfunc (s *Stack) Push(b byte) {\r\n\ts.val = append(s.val, b)\r\n}\r\n\r\nfunc (s *Stack) Pop() byte {\r\n\tb := s.val[len(s.val)-1]\r\n\ts.val = s.val[:len(s.val)-1]\r\n\treturn b\r\n}\r\n\r\nfunc (s *Stack) Top() byte {\r\n\treturn s.val[len(s.val)-1]\r\n}\r\n\r\nfunc (s *Stack) Empty() bool {\r\n\treturn len(s.val) == 0\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为解码后 s 的长度\r\n- 空间复杂度：O(N)，其中 N 为解码后 s 的长度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841332718","body":"### 思路\r\n在结构体内有个栈，一个用来push入队，另一个用来实现 peek 和 pop 出队\r\n+ push：把元素直接插入val栈尾部\r\n+ pop / peek：检查 top 栈是否为空，为空则需要把 val 栈依次出栈、入栈到 top 栈，然后取栈顶元素返回\r\n+ empty：top 栈 和 val 栈 都为空返回 true，否则返回 false\r\n\r\n### 代码\r\n```go\r\ntype MyQueue struct {\r\n    val []int\r\n    top []int\r\n}\r\n\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{\r\n        val: make([]int, 0),\r\n        top: make([]int, 0),\r\n    }\r\n}\r\n\r\n\r\n/** Push element x to the back of queue. */\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.val = append(this.val, x)\r\n}\r\n\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.top) == 0 {\r\n        for len(this.val) > 0 {\r\n            this.top = append(this.top, this.val[len(this.val)-1])\r\n            this.val = this.val[:len(this.val)-1]\r\n        }\r\n    }\r\n    val := this.top[len(this.top)-1]\r\n    this.top = this.top[:len(this.top)-1]\r\n    return val\r\n}\r\n\r\n\r\n/** Get the front element. */\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.top) == 0 {\r\n        for len(this.val) > 0 {\r\n            this.top = append(this.top, this.val[len(this.val)-1])\r\n            this.val = this.val[:len(this.val)-1]\r\n        }\r\n    }\r\n    return this.top[len(this.top)-1]\r\n}\r\n\r\n\r\n/** Returns whether the queue is empty. */\r\nfunc (this *MyQueue) Empty() bool {\r\n    return len(this.val) == 0 && len(this.top) == 0\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push、empty都为O(1)，pop 和 peek 均摊 O(1)。\r\n- 空间复杂度：O(N)，N是操作总数"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841665969","body":"### 思路\r\n\r\n（此处撰写思路）\r\n\r\n### 代码\r\n\r\n```go\r\nfunc maxChunksToSorted(arr []int) int {\r\n    stack := make([]int, 0)\r\n\r\n    for _, v := range arr {\r\n        if len(stack) > 0 && v < stack[len(stack)-1] {\r\n            head := stack[len(stack)-1]\r\n            stack = stack[:len(stack)-1]\r\n            for len(stack) > 0 && v < stack[len(stack)-1] {\r\n                stack = stack[:len(stack)-1]\r\n            }\r\n            stack = append(stack, head)\r\n        } else {\r\n            stack = append(stack, v)\r\n        }\r\n    }\r\n    return len(stack)\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为 arr 长度\r\n- 空间复杂度：O(N)，使用了栈\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841817293","body":"### 思路\r\n1. 计算链表长度n\r\n2. k = k % n\r\n3. 双指针找到旋转点的前置节点和尾节点\r\n4. 旋转\r\n\r\n### 代码\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n\r\n    n := 1\r\n    cur := head    // 计算链表长度，同时记录尾节点\r\n    for cur.Next != nil {\r\n        cur = cur.Next\r\n        n++\r\n    }\r\n    k = k % n\r\n\r\n    // 双指针找旋转节点的前置节点\r\n    pre, tail := head, head\r\n    for i := 0; i < k; i++ {\r\n        tail = tail.Next\r\n    }\r\n    for tail.Next != nil {\r\n        tail = tail.Next\r\n        pre = pre.Next\r\n    }\r\n\r\n    // 旋转链表\r\n    tail.Next = head\r\n    head = pre.Next\r\n    pre.Next = nil\r\n    return head\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为链表长度\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842406567","body":"### 思路\r\n\r\n定位移动节点，插入到后两个节点中间，需要特别注意，移动节点的前置节点需要重置到新的节点\r\n\r\n\r\n### 代码\r\n\r\n```go\r\nfunc swapPairs(head *ListNode) *ListNode {\r\n    if head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n\r\n    guard := &ListNode{Next: head}\r\n    move := head\r\n    movePre := guard\r\n    for move != nil && move.Next != nil {\r\n        pre := move.Next\r\n        after := pre.Next\r\n\r\n        pre.Next = move\r\n        move.Next = after\r\n        movePre.Next = pre\r\n\r\n        movePre = move\r\n        move = after\r\n    }\r\n    return guard.Next\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为链表长度\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843248939","body":"### 思路\r\n1. 遍历链表，存入数组\r\n2. 递归，每次锁定中间位置，左边为左子树，右边为右子树\r\n\r\n### 代码\r\n```go\r\nfunc sortedListToBST(head *ListNode) *TreeNode {\r\n    res := make([]int, 0)\r\n    for head != nil {\r\n        res = append(res, head.Val)\r\n        head= head.Next\r\n    }\r\n    return dfs(res, 0, len(res)-1)\r\n}\r\n\r\nfunc dfs(res []int, l int, r int) *TreeNode {\r\n    if l > r {\r\n        return nil\r\n    }\r\n\r\n    mid := (l - r) / 2 + r\r\n    root := &TreeNode{Val: res[mid]}\r\n    root.Left = dfs(res, l, mid-1)\r\n    root.Right = dfs(res, mid+1, r)\r\n    return root\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为链表长度\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844186278","body":"### 思路\r\na从链表A走到尾部，随后换到链表B头部继续走；\r\nb从链表B走到尾部，随后换到链表A头部继续走；\r\n期间如果相等了直接返回，如果没有交叉，将都为空时相等返回空\r\n\r\n### 代码\r\n```go\r\nfunc getIntersectionNode(headA, headB *ListNode) *ListNode {\r\n    a, b := headA, headB\r\n    for a != b {\r\n        if a == nil {\r\n            a = headB\r\n        } else {\r\n            a = a.Next\r\n        }\r\n        if b == nil {\r\n            b = headA\r\n        } else {\r\n            b = b.Next\r\n        }\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 N, M为两个链表的长度\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845206775","body":"### 思路\r\n使用哈希表记录，每次判断是否出现过，第一次出现的节点就是入环节点\r\n\r\n\r\n### 代码\r\n\r\n```go\r\nfunc detectCycle(head *ListNode) *ListNode {\r\n    seen := map[*ListNode]struct{}{}\r\n    for head != nil {\r\n        if _, ok := seen[head]; ok {\r\n            return head\r\n        }\r\n        seen[head] = struct{}{}\r\n        head = head.Next\r\n    }\r\n    return nil\r\n}\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n+ 时间复杂度：O(N)，其中 N 为链表的长度\r\n+  空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797246","body":"语言：Java\r\n\r\n思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\n`class Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        // 初始化参数\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = A.length;\r\n\r\n        // 1. 从后往前逐位相加\r\n        for(int i = n - 1;i >= 0;i--){\r\n            // 1.1 逐位相加\r\n            int sum = A[i] + K % 10;         // 每次重置sum\r\n            K /= 10;    \r\n            // 1.2 处理两位相加 进位的情况\r\n            if(sum >= 10){\r\n                K++;                        // 进位到K的末尾\r\n                sum -= 10;                  // 进位清掉\r\n            }\r\n            // 1.2 当前相加的结果 添加到结果集\r\n            res.add(sum);\r\n        }\r\n\r\n        // 2. K的数字长度大于数组的数字长度\r\n        for(;K > 0;K /= 10){                // 每次K左移一位\r\n            res.add(K % 10);                // 添加到结果集\r\n        }\r\n\r\n        // 3. 将结果集翻转即是所求答案\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}`\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838563251","body":"**语言：** Java\r\n\r\n**leetcode官方题解思想：**\r\n\r\n从前往后遍历一遍，记住各个位置离上一个C字符的距离，再从后往前遍历一遍，同样记住离上一个C字符的距离，最后比较两次遍历各个位置离C字符的距离，较小的那个被选用做为最终距离\r\n\r\n**复杂度：**\r\n\r\n时间：O(N)\r\n\r\n空间：O(N) \r\n\r\n**代码：**\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839798463","body":"**java**\r\n**leetcode官方题解：**用数组模拟，方便除了栈顶的其他值都可以看到，然后就可以实现底部k个值增加val\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841215925","body":"**python**\r\n设置一个主栈 一个辅助栈\r\n**时间**O（n）每次push操作需要移动n个元素\r\n**空间**O（n）额外开辟了一个辅助栈空间\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842351663","body":"```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummyhead = ListNode(0)\r\n        dummyhead.next = head\r\n        temp = dummyhead\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp.next = node2\r\n            temp = node1\r\n        return dummyhead.next\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843189141","body":"```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        root = TreeNode(slow.val)\r\n        pre.next = None\r\n\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844117245","body":"```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A,B = headA,headB\r\n        while A!=B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845103192","body":"```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        x = None\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if slow == fast:\r\n                x = slow\r\n                fast = head\r\n                break\r\n        if x == None:\r\n            return None\r\n        \r\n        while x!= fast:\r\n            fast = fast.next\r\n            x = x.next\r\n        return fast\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836797976","body":"思路：\n  1、从数组最后一位向前遍历，进行相加，考虑进位操作\n  2、考虑进位超出当前长度的操作\n  3、输出结果进行翻转 collections.reverse（res）\n代码：\n```\npublic List<Integer> addToArrayForm(int[] A, int K) {\n    List<Integer> res = new ArrayList<>();\n    int carry = 0;\n    int l1 = A.length - 1;\n    while (l1 >= 0 || K != 0) {\n        int x = l1 < 0 ? 0 : A[l1];\n        int y = K == 0 ? 0 : K % 10;\n\n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry = sum / 10;\n\n        l1--;\n        K = K / 10;\n    }\n    if (carry != 0) res.add(carry);\n    Collections.reverse(res);\n    return res;\n}\n\n```\n复杂度分析：（不懂）\n    时间复杂度：Ｏ（n）\n    空间复杂度：Ｏ（n）\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838694006","body":"思路：\n   从左向右遍历，记录字符c出现的位置p，距离为i-p\n   从右向左遍历，记录字符c出现的位置p，距离为p-i\n   得较小值\n代码：\n```\n\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;//防止越界\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);//判断最小值\n        }\n\n        return ans;\n    }\n}\n\n\n```\n复杂度分析：\n   时间复杂度：Ｏ（n）\n   空间复杂度：Ｏ（n）数组 ans 的大小"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839873718","body":"#\t思路\n\t（官方解法）用数组模拟栈 用变量top记录栈顶位置\n#\t代码\n```\n\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n\n```\n#\t复杂度分析\n*\t时间复杂度：Ｏ（1）  inc操作为Ｏ（K）\n*\t空间复杂度：Ｏ（maxSize）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840632691","body":"#\t思路（官方解法）\n\t1.将括号嵌套转化成 用栈维护 \n\t2.遍历栈 \n当前字符为数位，解析数字并进栈\n字母或者左括号，直接进\n右括号，开始出栈直到左括号出栈，反转拼接为字符串取栈顶数字\n#\t代码 \n```\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n\n\n```\n\n#\t复杂度分析\n*\t时间复杂度：Ｏ（s） 字符串长度为s\n*\t空间复杂度：Ｏ（s）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841324701","body":"#\t思路\n一个输入栈 push传入的数据\n一个栈做输出栈，用于pop和peek操作\n进行pop、peek时，若为空输出栈弹出全部数据并压入输出栈\n#\t代码\n```\n\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n\n```\n#\t复杂度分析\n时间复杂度：Ｏ（1）\n空间复杂度：Ｏ（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678790","body":"#\t思路\n贪心算法找到最边开始最小的块\n#\t代码\n```\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = expect[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n\n```\n#\t复杂度分析\n时间复杂度：Ｏ（NlogN）\n空间复杂度：Ｏ（N）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841836719","body":"#    代码\n```\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (k == 0 || head == null || head.next == null) {\n            return head;\n        }\n        int n = 1;\n        ListNode iter = head;\n        while (iter.next != null) {\n            iter = iter.next;\n            n++;\n        }\n        int add = n - k % n;\n        if (add == n) {\n            return head;\n        }\n        iter.next = head;\n        while (add-- > 0) {\n            iter = iter.next;\n        }\n        ListNode ret = iter.next;\n        iter.next = null;\n        return ret;\n   }\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842430778","body":"###   思路（官方解法）\r\n递归交换链表中的节点\r\n终止条件：链表中没有节点，或者链表中只有一个节点\r\n交换过后原始头节点变为新链表的头结点\r\n###    代码\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843284858","body":"#\t思路\r\n官方解法\r\n分治 \r\n用快慢指针找出链表中位数节点，初始fast和low均指向链表的左端点left\r\n将快指针 fast 向右移动两次的同时，将慢指针slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）\r\n#\t代码\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n```\r\n#\t复杂度分析\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(nlogn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844228531","body":"### 思路\r\n（双指针、链表）\r\n1、创建2个指针pA、pB，然给他们分别为链表A、B的头结点，向后遍历\r\n2、pA指针到链表尾部后，重定位为链表B的头结点，pB同样操作\r\n3、pA、pB同时到达节点即为相交节点；尾结点元素不同，则没有相交节点\r\n### 代码\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        // 特判\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n\r\n        ListNode head1 = headA;\r\n        ListNode head2 = headB;\r\n\r\n        while (head1 != head2) {\r\n            if (head1 != null) {\r\n                head1 = head1.next;\r\n            } else {\r\n                head1 = headB;\r\n            }\r\n\r\n            if (head2 != null) {\r\n                head2 = head2.next;\r\n            } else {\r\n                head2 = headA;\r\n            }\r\n        }\r\n        return head1;\r\n    }\r\n}  \r\n```\r\n### 复杂度分析\r\n时间复杂度;O（m+n）\r\n空间复杂度：O（1）\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845236088","body":"### 思路\r\n快慢指针\r\n### 代码\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        }\r\n        ListNode slow = head, fast = head;\r\n        while (fast != null) {\r\n            slow = slow.next;\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n            if (fast == slow) {\r\n                ListNode ptr = head;\r\n                while (ptr != slow) {\r\n                    ptr = ptr.next;\r\n                    slow = slow.next;\r\n                }\r\n                return ptr;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846016057","body":"### 思路\r\n官方解法\r\n哈希表+双向链表\r\n用一个哈希表和一个双向链表维护所有在缓存中的键值对，靠近头部的键值对是最近使用的，靠近尾部的是最久未使用的\r\n### 代码\r\n```\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache.put(key, newNode);\r\n            // 添加至双向链表的头部\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode tail = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n### 复杂度分析\r\n时间：O(1)\r\n空间：O（n）\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846426830","body":"### 思路\r\n深度优先\r\n### 代码\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) {\r\n            return true;\r\n        } else if (p == null || q == null) {\r\n            return false;\r\n        } else if (p.val != q.val) {\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n### 时间复杂度\r\n时间复杂度:   O（min（m，n））\r\n空间复杂度：O（min（m，n））"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Auto-SK":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836800746","body":"## 方法一：逐位相加\r\n\r\n**当前位 = (A 的当前位 + B 的当前位 + 进位 carry) % 10**\r\n\r\n### 算法流程\r\n\r\n```\r\nwhile A 没完 or B 没完\r\n\tA 的当前位\r\n\tB 的当前位 (B % 10)\r\n\r\n\t和 = A 的当前位 + B 的当前位 + 进位 carry\r\n\t进位 = 和 // 10\r\n\r\n\t当前结果位 = 和 % 10\r\n判断还有进位吗\r\n反转数组\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(max(len(num), len(k)))\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = len(num) - 1\r\n        sum = 0\r\n        carry = 0\r\n        res = []\r\n        while i >= 0 or k != 0:\r\n            x = num[i] if i >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + carry\r\n            carry = sum // 10\r\n\r\n            i -= 1\r\n            k //= 10\r\n\r\n            res.append(sum % 10)\r\n        \r\n        if carry != 0:\r\n            res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n\r\n## 方法二：转换+逐位取出\r\n\r\n### 算法流程\r\n\r\n1. 逐位取 num，将其转为字符串\r\n2. 将 num 字符串转为整数\r\n3. 求出 num 和 k 之和 sum\r\n4. 逐位取 sum % 10，sum = sum // 10\r\n5. 反转，res[::-1]\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''\r\n        for i in num:\r\n            x += str(i)\r\n        x = int(x)\r\n        res = x + k\r\n        if res == 0:\r\n            return [0]\r\n        ans = []\r\n        while res != 0:\r\n            ans.append(res % 10)\r\n            res = res // 10\r\n        return ans[::-1]\r\n```\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838717787","body":"## 方法一：两次扫描\r\n\r\n### 算法流程\r\n\r\n从左向右遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `i - prev`。\r\n\r\n从右向左遍历，记录上一个字符 `c` 出现的位置 `prev`，那么答案就是 `prev - i`。\r\n\r\n这两个值取最小就是答案。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，s 数组的长度。\r\n* 空间复杂度：O(n)，ans 数组的大小。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        prev = float('-inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886268","body":"## 方法一：增量数组\r\n\r\n### 算法流程\r\n\r\n用数组模拟栈，`stack`用来存储栈的元素，`add`用来存储增量。当调用`pop`和`increment`方法时，改变`add`数组的元素。\r\n\r\n* 当`pop`时，若操作后，栈不为空，`add[-1]`加上上一个`add[-1]`；\r\n* 当`increment`时，如果栈为空，不操作；若 k > 栈长，add[-1] += val；若 k < 栈长，add[k - 1] += val。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(maxSize)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.length = 0\r\n        self.max_length = maxSize\r\n        self.stack = []\r\n        self.add = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.length < self.max_length:\r\n            self.stack.append(x)\r\n            self.add.append(0)\r\n            self.length += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.length == 0:\r\n            return -1\r\n        s = self.stack.pop()\r\n        a = self.add.pop()\r\n        self.length -= 1\r\n        if self.length > 0:\r\n            self.add[-1] += a\r\n        return s + a\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.length == 0:\r\n            return\r\n        elif self.length < k:\r\n            self.add[-1] += val\r\n        else:\r\n            self.add[k - 1] += val\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627801","body":"## 方法一：辅助栈法\r\n\r\n本题难点在于括号内嵌套括号，需要**从内向外**生成与拼接字符串，这与栈的**先入后出**特性相应。\r\n\r\n### 算法流程\r\n\r\n1. 构建辅助栈`stack`，遍历字符串`s`中每个字符`c`；\r\n   * 当`c`为数字时，将数字字符转换为数字`multi`，用于后续倍数计算；\r\n   * 当`c`为字母时，在`res`尾部添加`c`；\r\n   * 当`c`为`[`时，将当前的`multi`和`res`入栈，并分别置空置0：\r\n     * 记录此`[`前的临时结果`res`至栈，用于发现对应`]`后的拼接操作；\r\n     * 记录此`[`前的倍数`multi`至栈，用于发现对应`]`后，获取`multi * [...]`字符串；\r\n     * 进入到新`[`后，`res`和`multi`重新记录。\r\n   * 当`c`为`]`时，`stack`出栈，拼接字符串`res=last_res + cur_multi * res`，其中：\r\n       * `last_res`是上个`[`到当前`]`的字符串，例如`3[a2[c]]`中的`a`；\r\n       * `cur_multi`是当前`[`到`]`内字符串的重复倍数，例如`3[a2[c]]`中的`2`；\r\n2. 返回字符串`res`。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，一次遍历`s`；\r\n* 空间复杂度：辅助栈在极端情况下需要线性空间，例如`2[2[2[a]]]`。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], '', 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = '', 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif c.isdigit():\r\n                multi = multi * 10 + int(c)\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841315408","body":"## 方法一：用两个栈模拟队列\r\n\r\n### 算法流程\r\n\r\n栈是一种**后进先出** (last in - first out, LIFO) 的数据结构，元素从栈顶压入，也从栈顶弹出。\r\n\r\n队列是一种**先进先出** (first in - first out, FIFO) 的数据结构，元素从队尾入队，从队头出队。\r\n\r\n栈的**后进先出**特性相当于“逆转”了队列**先进先出**的效果，所以为了实现队列，我们需要使用两个栈，经过两次 “逆转” 满足队列的正常操作顺序。\r\n\r\n不妨设两个栈分别为 a, b，我们 使用 a 的栈顶模拟队尾，使用 b 的栈顶模拟队头 。为了保证结果的正确性，我们需要在每一次操作后都将所有元素保存在其中一个栈内（否则若分散在两个栈内，进行下一步操作后一定会改变元素顺序，就无法模拟队列的**先进先出**特性了）。\r\n\r\n我们不妨将所有元素都时刻保存在栈 b 中，也即任何操作过后，要保证全部元素保存在栈 b 中。需要模拟的操作如下：\r\n\r\n模拟元素“入队”时，要从队尾入队，也即要压入栈 a，但在此之前要先把栈 b 中的所有元素放入 a 中，压栈后再将 a 中元素再放回 b 中；\r\n\r\n模拟元素“出队”时，要从队头出队，也即从 b 的栈顶弹出元素。\r\n\r\n模拟 top/pop 操作时，类似元素“出队”操作，由于全部元素时刻保存在栈 b 中，所以只需对栈 b 进行取栈顶操作或弹出栈顶元素操作即可。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(1)\r\n* 空间复杂度：O(n)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.b:\r\n            self.a.append(self.b.pop())\r\n        self.a.append(x)\r\n        while self.a:\r\n            self.b.append(self.a.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.b[-1] \r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.b) == 0\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841630954","body":"## 方法一：\r\n\r\n### 算法流程\r\n\r\n* **排序块定义**：\r\n    * **排序块** 充分条件： 设此块中最大数字为`headhead`, 若此块后面的所有数字都`>= head`，则此块为排序块。\r\n    * **排序块** 最短长度为 1，即单个元素可以独立看作一个排序块。\r\n\r\n* **贪心法则**（划分出尽可能多的排序块）：\r\n    * 思路一：\r\n        * 设定双指针指向数组头部，判断双指针内数字集合形成的块是否满足排序块条件，并尽量使窗口最小（贪心）。\r\n        * 每次形成排序块时计数，并越过此排序块重新指定双指针位置，重复以上步骤直到划分完整个数组。\r\n        * 此思路容易理解，但每次确定 1 个块都需要遍历整个数组，在某些极端情况（例如 [1,2,3,4,5]）时间复杂度达到 O(N^2) 。\r\n    * 思路二（本题解采用）：\r\n        * 判断是否是排序块只需要用到该块的 **元素最大值**`head`。我们联想到，是否可以遍历一遍数组`arr`，动态判断到目前数字`num`为止最多能分出多少排序块，并保存每个排序块的最大值`head`。每遍历到下个数字`num`，动态判断前面所有的排序块是否成立，并更新所有排序块：\r\n            * 当某排序块`num < head`：将此排序块`[A]`与`num`合并，形成新排序块`[A | num]`，最大值仍未`head`；\r\n            * 当某排序块`num >= head`：原排序块保留，并新加排序块`[num]`。\r\n        * 而对于整个数组的排序块，其`head`大小是从左到右递增的。例如：数组`[1, 2, 1, 3, 4, 7, 5, 6]`最多可划分为`[1|2, 1|3|4|7, 5, 6]`。因此，若给数组尾部加入一个随机正整数`n`，尾部的排序块更容易被合并（最先满足`num < head`）。当`n`值较小时（`< 前面多个排序块的 head`），则需按尾部到首部的顺序合并多个排序块。\r\n        * 这种先入（首部到尾部添加排序块）后出（尾部到首部判断并合并排序块）的特性，让我们联想到使用 **栈** 保存排序块最大值`head`。在遍历过程中，通过维护栈的`head`序列，实现排序块的动态更新。\r\n* 算法流程：\r\n    1. 遍历数组`arr`中的每个数字`num`；\r\n    2. 当栈 `stack`不为空且数字`num < 栈顶值`时：（代表此`num`会改变前面排序块分布）\r\n        * 栈顶`pop()`出栈，并保存栈顶值为`head`。（此情况下，新排序块最大值还为`head`，因此先暂存）\r\n        * 当`stack`不为空且数字`num < 栈顶值`时，循环栈顶`pop()`出栈。（判断加入`num`需要合并的所有排序块，每`pop()`一个`head`代表合并一个块）\r\n        * 将保存的栈顶值`head`重新`push()`入栈。（将`head`重新加入，作为新排序块的最大值）\r\n    3. 当栈`stack`为空或数字`num >= 栈顶值`时：（代表此`num`不影响前面排序块分布）\r\n        * 将`num`数字`push()`入栈。（加入单个元素的新排序块`[num]`）\r\n    4. 遍历完成后，栈中保存 **所有排序块的对应最大值`head`**，因此返回栈`stack`长度即可获得排序块数量。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，遍历一遍`arr`为 O(N)，修正排序块最多遍历一遍`arr`为 O(N)；\r\n* 空间复杂度：O(N)，极端情况下排序块数量等于数组长度，此时`stack`占用线性大小额外空间。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841834712","body":"## 方法一：闭合为环\r\n\r\n### 算法流程\r\n\r\n记给定链表的长度为`n`，注意到当向右移动的次数`k >= n`时，我们仅需向右移动`k mod n`次即可。新链表的最后一个节点为原链表的第`(n - 1) - (k mod n)`个节点（从 0 开始计数）。\r\n\r\n1. 首先计算出链表的长度`n`，并找到该链表的尾节点，将其与头节点相连。这样就得到了闭合为环的链表；\r\n2. 然后找出新链表的最后一个节点（即原链表的第`(n - 1) - (k mod n)`个节点），将当前闭合为环的链表断开，即可得到结果；\r\n3. 特别的，当链表长度不为 1，或者`k`为`n`的倍数时，新链表与原链表相同，无需处理。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，最坏的情况需要遍历链表两次。\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842434106","body":"## 方法一：递归\r\n\r\n### 算法流程\r\n\r\n1. 返回值：交换完成的子链表；\r\n2. 调用单元：设需要交换的两个点为`head `和`next`，`head `连接后面交换完成的子链表，`next `连接`head`，完成交换；\r\n3. 终止条件：`head `为空指针或者`next `为空指针，也就是当前无节点或者只有一个节点，无法进行交换。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n* 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head == None or head.next == None:\r\n            return head\r\n        head_next = head.next\r\n        head.next = self.swapPairs(head_next.next)\r\n        head_next.next = head\r\n        return head_next\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843279649","body":"## 方法一：双指针法\r\n\r\n### 算法流程\r\n\r\n1. 获取当前链表的中点\r\n2. 以链表中点为根\r\n3. 中点左边的值都小于它,可以构造左子树\r\n4. 同理构造右子树\r\n5. 循环第一步\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(nlogn)，递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)；\r\n* 空间复杂度：空间复杂度为O(logn)。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        if pre:\r\n            pre.next = None\r\n        node = TreeNode(slow.val)\r\n        if slow == fast:\r\n            return node\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844238548","body":"## 方法一：双指针法\r\n\r\n### 算法流程\r\n\r\n两个结点不断的去对方的轨迹中寻找对方的身影，只要二人有交集，就终会相遇​ :heart:\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        hA = headA;\r\n        hB = headB;\r\n        while hA != hB:\r\n            hA = hA.next if hA else headB\r\n            hB = hB.next if hB else headA\r\n        return hA\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845243082","body":"## 方法一：快慢指针\r\n\r\n### 算法流程\r\n\r\n第一次相遇后，从头开始走，再次相遇为相遇节点。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(1)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                if not slow:\r\n                    return None\r\n                fast = head\r\n                while fast != slow:\r\n                    fast = fast.next\r\n                    slow = slow.next\r\n                return fast\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846048655","body":"## 方法一：\r\n\r\n### 算法流程\r\n\r\nLRU 缓存机制可以通过哈希表辅以双向链表实现，用一个哈希表和一个双向链表维护所有在缓存中的键值对。\r\n\r\n* 双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\r\n\r\n* 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：对于 `put` 和 `get` 都是 O(1)。\r\n* 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。\r\n\r\n### 代码\r\n\r\n``` python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427019","body":"## 方法一：深度优先搜索\r\n\r\n### 算法流程\r\n\r\n左子树的深度为`l`，右子树的深度为`r`，树的深度为`max(l, r) + 1`。\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)\r\n* 空间复杂度：O(height)\r\n\r\n### 代码\r\n\r\n``` python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            left_height = self.maxDepth(root.left)\r\n            right_height = self.maxDepth(root.right)\r\n        return max(left_height, right_height) + 1\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836802914","body":"### 思路\r\n\r\n#### 模板\r\n```\r\n当前位=0\r\nwhile ( A 没完 || B 没完)\r\n    //根据下标找到\r\n    A 的当前位\r\n    B 的当前位\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\n\r\n判断还有进位吗,进位不为 0 ,加在目标值前面。\r\n```\r\n#### 注意点\r\n1. 循环结束条件\r\n2. 当前位的计算,注意防空\r\n3. 和的计算,carry初始值为0\r\n4. js中取整/后要转整数\r\n  \r\n### 代码\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let i = num.length - 1,\r\n    carry = 0,\r\n    arr = [];\r\n  while (i >= 0 || k > 0) {\r\n    let n = i>=0 ? num[i] : 0;\r\n    let m = k != 0 ? k % 10 : 0;\r\n    let sum = n + m + carry;\r\n    carry = parseInt(sum / 10);\r\n    arr.unshift(sum % 10);\r\n    i--;\r\n    k = parseInt(k / 10);\r\n  }\r\n  if (carry) arr.unshift(1);\r\n  return arr;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度:`O(n)` \r\n空间复杂度:`O(n)`\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838288784","body":"### 思路\r\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\r\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\r\n### 复杂度\r\n时间复杂度：$O(N)$, N 为S数组长度。\r\n空间复杂度：$O(N)$, N 为S数组长度。\r\n### 代码\r\n```\r\nvar shortestToChar = function (S, C) {\r\n  let arr = [],\r\n    prevC = -Infinity,\r\n    map = [];\r\n  //清空暂存栈\r\n  function clear(prev, next = Infinity) {\r\n    for (const targetIndex of map) {\r\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\r\n      arr.push(Index);\r\n    }\r\n    map = [];\r\n  }\r\n  for (let index = 0; index < S.length; index++) {\r\n    const ele = S[index];\r\n    if (ele === C) {\r\n      clear(prevC, index);\r\n      arr.push(0);\r\n      prevC = index;\r\n    } else {\r\n      map.push(index);\r\n    }\r\n  }\r\n  if (map.length > 0) {\r\n    clear(prevC);\r\n  }\r\n  return arr;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839486308","body":"#### 思路\r\n两种做法,一种常规遍历,一种运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈\r\n\r\n#### 复杂度\r\n\r\n1.  复杂度分析\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2. 辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n```\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841042265","body":"#### 思路\r\n使用辅助栈,用空间换时间.\r\n注意:辅助栈的栈顶就是队列的队首,即原始栈当栈底\r\n#### 复杂度\r\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\r\n\r\n空间复杂度：O(N)\r\n#### 代码\r\n```\r\nvar MyQueue = function () {\r\n    this.stack1 = [];\r\n    this.stack2 = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.stack2.length === 0) {\r\n        while (this.stack1.length > 0) {\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        // return this.stack2.pop();\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    if (this.stack2.length === 0) {\r\n        while (this.stack1.length > 0) {\r\n            this.stack2.push(this.stack1.pop())\r\n        }\r\n        // return this.stack2.pop();\r\n    }\r\n    return this.stack2[this.stack2.length-1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\nreturn this.stack2.length===0 && this.stack1.length===0\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841627957","body":"#### 最多能完成排序的块 II\r\n\r\n#### 思路\r\n\r\n借助辅助栈,存储每一块的最大值,因而栈是正序排列的.\r\n遍历数组,当遇到比辅助栈栈顶元素大的元素或栈为空时直接压入栈,\r\n否则需要找到栈中所有比元素大的块,合为一块,最大值就是栈顶的值.so,递归遍历栈,若块的值比元素大,则出栈,块的值比元素小则停止循环,给栈加上值为栈顶的块\r\n#### 复杂度\r\n时间复杂度 O(N) ：遍历一遍 arr 为 O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)；\r\n空间复杂度 O(N) ：极端情况下排序块数量等于数组长度，此时 stack 占用线性大小额外空间。\r\n#### 代码\r\n```\r\nvar maxChunksToSorted = function (arr) {\r\n  let stack = [];\r\n  for (const ele of arr) {\r\n      if (stack.length && ele < stack[stack.length - 1]) {\r\n        let max = stack.pop()\r\n        while (stack.length && ele < stack[stack.length - 1]) {\r\n         stack.pop()\r\n      }\r\n          stack.push(max);\r\n      }\r\n      else {\r\n          stack.push(ele);\r\n      }\r\n  }\r\n\r\n  return stack.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841773711","body":"#### 思路\r\n记给定链表的长度为 n，注意到当向右移动的次数 k  时，我们仅需要向右移动 k %n 次即可。因为每 n次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n - 1) - (k% n) 个节点（从 00 开始计数）。\r\n\r\n这样，我们可以先将给定的链表连接成环，然后将指定位置断开。\r\n\r\n具体代码中，我们首先计算出链表的长度 nn，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k%n) 个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。\r\n\r\n特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。\r\n\r\n#### 复杂度\r\n时间复杂度：O(n)，最坏情况下，我们需要遍历该链表两次。\r\n\r\n空间复杂度：O(1)，我们只需要常数的空间存储若干变量。\r\n#### 代码\r\n```\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    let n = 1;\r\n    let cur = head;\r\n    //遍历链表,获得长度\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n\r\n    let add = n - k % n;\r\n    if (add === n) {\r\n        return head;\r\n    }\r\n     //将链表尾部指向头部,形成环\r\n    cur.next = head;\r\n    while (add) {\r\n        cur = cur.next;\r\n        add--;\r\n    }\r\n    //获得新链表头部\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842235436","body":"### 迭代\r\n#### 思路\r\n创建哑结点 dummyHead,令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。\r\n\r\n交换之前的节点关系是 temp -> node1 -> node2，交换之后的节点关系要变成 temp -> node2 -> node1\r\n\r\n再令 temp = node1,对链表中的其余节点进行两两交换，直到全部节点都被两两交换。\r\n\r\n#### 代码\r\n\r\n```\r\nvar swapPairs = function(head) {\r\n    const dummyHead = new ListNode(0);\r\n    dummyHead.next = head;\r\n    let temp = dummyHead;\r\n    //如果 temp后面没有节点或者只有一个节点，则不需要交换\r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next;\r\n        const node2 = temp.next.next;\r\n        temp.next = node2;\r\n        node1.next = node2.next;\r\n        node2.next = node1;\r\n        temp = node1;\r\n    }\r\n    //链表的头节点\r\n    return dummyHead.next;\r\n};\r\n```\r\n\r\n#### 复杂度分析\r\n- 时间复杂度：O(N)，其中 nn 是链表的节点数量。需要对每个节点进行更新指针的操作.\r\n- 空间复杂度：O(1)\r\n\r\n### 递归\r\n\r\n#### 代码\r\n\r\n```\r\n//递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\r\nvar swapPairs = function(head) {\r\n    if (head === null|| head.next === null) {\r\n        return head;\r\n    }\r\n    const newHead = head.next;\r\n    head.next = swapPairs(newHead.next);\r\n    newHead.next = head;\r\n    return newHead;\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n- 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842846129","body":"### 思路\r\n\r\n将有序链表转成数组，去递归分治这个数组，构建二叉树，就成了 BST 的模样。\r\n\r\n### 代码\r\n\r\n```\r\nconst sortedListToBST = (head) => {\r\n  const arr = [];\r\n  while (head) { // 将链表节点的值逐个推入数组arr\r\n    arr.push(head.val);\r\n    head = head.next;\r\n  }\r\n  // 根据索引start到end的子数组构建子树\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null;        // 指针交错，形成不了子序列，返回null节点\r\n    const mid = (start + end) >>> 1;     // 求中间索引 中间元素是根节点的值\r\n    const root = new TreeNode(arr[mid]); // 创建根节点\r\n    root.left = buildBST(start, mid - 1); // 递归构建左子树\r\n    root.right = buildBST(mid + 1, end);  // 递归构建右子树\r\n    return root;                          // 返回当前子树\r\n  };\r\n\r\n  return buildBST(0, arr.length - 1);  // 根据整个arr数组构建\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843996901","body":"### 思路\r\n哈希法:(摘自讲义)\r\n有 A, B 这两条链表, 先遍历其中一个，比如 A 链表, 并将 A 中的所有节点存入哈希表。\r\n遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\r\n\r\n### 代码\r\n\r\n```\r\nvar getIntersectionNode = function(A, B) {\r\nlet data = new Set();\r\nwhile (A !== null) {\r\n  data.add(A);\r\n  A = A.next;\r\n}\r\nwhile (B !== null) {\r\n  if (data.has(B)) return B;\r\n  B = B.next;\r\n}\r\nreturn null;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844948928","body":"### 环形链表\r\n#### 思路\r\n我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。\r\n#### 代码\r\n```\r\nvar detectCycle = function(head) {\r\n    const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n#### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846424573","body":"#### 思路\r\n递归\r\n终止条件是当前节点为null,则其深度为0.\r\n#### 代码\r\n```\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(root ===null){\r\n        return 0;\r\n    }\r\n    return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n};\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(height)-- 递归深度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846514571","body":"**递归**\r\n\r\n#### 思路\r\n 判断当前两个节点是否相同,要看它们的值以及左右节点是否相同\r\n#### 代码\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n  //都为null节点返回true\r\nif (!p || !q) {\r\n    return !p && !q;\r\n  }\r\n  return (\r\n    p.val === q.val &&\r\n    isSameTree(p.left, q.left) &&\r\n    isSameTree(p.right, q.right)\r\n  );\r\n};\r\n```\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(N)，其中 N 为树的节点数。\r\n空间复杂度：O(h)，其中 h 为树的高度。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caoyuyuyu":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836813414","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 思路\r\n\r\n-  最终结果由数组变成的数值和数值相加，再转化为数组\r\n-  所以解题过程完全按照结果的生成过程for循环实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```Python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a=''\r\n        b=[]\r\n        for i in num:\r\n            a=a+str(i)\r\n        re=str(int(a)+k)\r\n        for j in re:\r\n            b.append(int(j))\r\n        return b\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 还不会分析复杂度,后面补上相关知识～\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838728328","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n\r\n-  题目是求每个字符串到最近到给定字符的距离，\r\n- 逆向思维，先求出给定字符到所有字符的距离，再求出其中的最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        a=[]\r\n        b=[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                a.append(i)\r\n\r\n        for i in range(len(s)):\r\n            re=len(s)\r\n            for j in a:\r\n                re=min(re,abs(int(i)-int(j)))\r\n            b.append(re)\r\n        return b\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839886323","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n\r\n## 思路\r\n\r\n-  用python的list 和append、pop实现\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack=[]\r\n        self.maxsize=maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack)< self.maxsize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack)>0:\r\n            p=self.stack.pop()\r\n            return p\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack)<k:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]=self.stack[i]+val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844209450","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n\r\n## 思路\r\n\r\n-  两个链表到达相等位置时走过的是相同的距离。\r\n- a走完了则指向b，反之一样\r\n- leetcode大佬到思路。。。\r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        h1,h2=headA,headB\r\n        while h1!=h2: \r\n            h1=h1.next if h1 else headB\r\n            h2=h2.next if h2 else headA\r\n        return h1\r\n\r\n        \r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"keepchasing":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836818313","body":"### 思路\r\n+ 遍历数组与K的对应位相加，并记录进位carryNum，carryNum默认值为0\r\n+ 判断K的位数与A对应的数字的位数，如果K的位数更大 取出前边的数据依次加到A中\r\n### 语言：\r\n javascript\r\n\r\n### 复杂度分析\r\n+ 时间复杂度： O(N)\r\n+ 空间复杂度：O(1)\r\n```\r\n/**\r\n * @param {number[]} A\r\n * @param {number} K\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = (A, K) => {\r\n    let len = A.length // 数组A的长度\r\n    let carryNum = 0 // 进位\r\n    A.forEach((item, index) => {\r\n        let curNum = Math.floor(K % Math.pow(10, index + 1) / Math.pow(10, index))\r\n        let tmpCurNum = (curNum + A[len - index -1 ] + carryNum)\r\n        A[len - index - 1] = tmpCurNum % 10\r\n        carryNum = Math.floor(tmpCurNum / 10)\r\n    })\r\n    let kStrLen = (K + '').length\r\n    // 如果K的位数大于A对应的数字的位数\r\n    if (kStrLen >= len) {\r\n        let tmpK = Math.floor(K / Math.pow(10, len)) + carryNum\r\n        let tmpKStrLen = (tmpK + '').length\r\n        for (let i = 0; i < tmpKStrLen; i ++) {\r\n            let tmpNum = Math.floor(tmpK % Math.pow(10, i + 1) / Math.pow(10, i))\r\n            i === tmpKStrLen - 1 && tmpNum === 0 ? '' : A.unshift(tmpNum)\r\n        }\r\n    } else {\r\n        carryNum ? A.unshift(carryNum) : ''\r\n    }\r\n    return A\r\n}\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838608422","body":"### 思路分析\r\n+ 从左到右遍历数组， res存储当前字符到左边数下标最大的目标C的距离\r\n+ 从右到左遍历，比较下标i对应的字符到从右边数下标最小的目标C的距离与res[i]的大小，取最小值\r\n\r\n### 语言\r\n+ javascript\r\n### 复杂度分析\r\n+ 时间复杂度：O(n)\r\n+ 空间复杂度：O(n)\r\n```\r\nlet S = \"loveleetcode\", C = 'e'\r\nconst shortestToChar = (S, C) => {\r\n    let res = []\r\n    let sLen = S.length\r\n    let leftMaxIndex = -10000\r\n    let rightMinIndex = 20000\r\n    for(let i = 0; i < sLen; i++) {\r\n        if(S[i] === C) {\r\n            leftMaxIndex = i\r\n        }\r\n        res[i] = i - leftMaxIndex\r\n    }\r\n    for(let i = sLen - 1; i >= 0; i--) {\r\n        if(S[i] === C) {\r\n            rightMinIndex = i\r\n        }\r\n        res[i] = Math.min(rightMinIndex - i, res[i])\r\n    }\r\n    return res\r\n}\r\nconsole.log(shortestToChar(S, C))\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839811027","body":"### 语言\r\n + javascript\r\n### 复杂度\r\n+ 空间 ：O(n)\r\n+ 时间 ：O(n)\r\n```\r\n\r\nclass CustomStack {\r\n    constructor(maxSize){\r\n        this.maxSize = maxSize\r\n        this.stack = []\r\n    }\r\n    push(val) {\r\n        if (this.stack.length < this.maxSize) {\r\n            this.stack.push(val)\r\n            return val\r\n        }\r\n        return null\r\n    }\r\n    pop() {\r\n        return this.stack.length === 0 ? -1 : this.stack.pop()\r\n    }\r\n    increment(k, val) {\r\n        let stackLen = this.stack.length\r\n        for (let i = 0; i < k && i < stackLen; i++) {\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840650185","body":"### 语言\r\n+ javascript\r\n### 思路分析\r\n+ 将字符串每个字符从前到后依次压入数组模拟的栈中\r\n+ 判断下一个字符串为’]‘时操作出栈 ，直到下一个’[‘，将这个中间出栈的元素存入一个变量\r\n+ 找到’[‘之后再找出它之前的数字times，然后重复步骤2中的变量times次，然后将它压入栈\r\n+ 最后返回这个栈中所有元素拼起来的字符串\r\n\r\n### 复杂度分析\r\n+ 空间复杂度： O(N)\r\n+ 时间复杂度：\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let stack = []\r\n    let sLen = s.length\r\n    for (let i = 0; i < sLen; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i])\r\n        } else {\r\n            let times = 0\r\n            let tmpItem = ''\r\n            for (let m = stack.length - 1; m >= 0; m--) {\r\n                if (stack[m] === '[') {\r\n                    stack.pop()\r\n                    // 取出数字\r\n                    let num = 0\r\n                    for (let j = m - 1; j >= 0; j--) {\r\n                        if (/\\d/.test(stack[j])) {\r\n                            times += Number(stack.pop())*Math.pow(10, num)\r\n                            num ++\r\n                        } else {\r\n                            break\r\n                        }\r\n                    }\r\n                    break\r\n                } else {\r\n                    tmpItem = `${stack.pop()}${tmpItem}`\r\n                }\r\n            }\r\n            if (i) {\r\n                stack.push(tmpItem.repeat(times))\r\n            }\r\n        }\r\n    }\r\n    return stack.join('')\r\n}\r\nconst s = \"3[a]2[bc]\"\r\nconsole.log(decodeString(s))\r\n```"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845981750","body":"### 语言\r\n+ javascript\r\n``` \r\nclass LinkedListNode {\r\n    constructor(key, value) {\r\n      this.key = key\r\n      this.value = value\r\n      this.next = null\r\n      this.prev = null\r\n    }\r\n  }\r\n  \r\n  class LRUCache {\r\n    constructor(maxCount) {\r\n      this.maxCount = maxCount\r\n      this.hash = {}\r\n      this.count = 0\r\n      this.linkedListHead = new LinkedListNode()\r\n      this.linkedListTail = new LinkedListNode()\r\n      this.linkedListHead.next = this.linkedListTail\r\n      this.linkedListTail.prev = this.linkedListHead\r\n    }\r\n  \r\n    get(key) {\r\n      let node = this.hash[key] || null\r\n      if (node === null) return -1\r\n      this.moveToHead(node)\r\n      return node.value\r\n    }\r\n  \r\n    put(key, value) {\r\n      let node = this.hash[key] || null\r\n      if (node === null) {\r\n        if (this.count === this.maxCount) {\r\n          this.rmLRUItem()\r\n        }\r\n        let newNode = new LinkedListNode(key, value)\r\n        this.hash[key] = newNode\r\n        console.log(this.hash)\r\n        this.addToHead(newNode)\r\n        this.count++\r\n      } else {\r\n        node.value = value\r\n        this.moveToHead(node)\r\n      }\r\n    }\r\n    // 将节点从原始位置删除 重新添加到头部\r\n    moveToHead(node) {\r\n      this.rmFromList(node)\r\n      this.addToHead(node)\r\n    }\r\n    // 将节点从原始位置删除\r\n    rmFromList(node) {\r\n      let temp1 = node.prev\r\n      let temp2 = node.next\r\n      temp1.next = temp2\r\n      temp2.prev = temp1\r\n    }\r\n    // 添加到头部\r\n    addToHead(node) {\r\n      node.prev = this.linkedListHead\r\n      node.next = this.linkedListHead.next\r\n      this.linkedListHead.next.prev = node\r\n      this.linkedListHead.next = node\r\n    }\r\n    // 删除缓存 计数减一\r\n    rmLRUItem() {\r\n      let tail = this.popTail()\r\n      delete this.hash[tail.key]\r\n      this.count--\r\n    }\r\n  \r\n    popTail() {\r\n      let tail = this.linkedListTail.prev\r\n      this.rmFromList(tail)\r\n      return tail\r\n    }\r\n  }\r\n\r\n  let obj = new LRUCache(30)\r\n  obj.put('5',6)\r\n  let param_1 = obj.get('5')\r\n\r\n  console.log(param_1)\r\n  obj.put('5',6)\r\n  console.log(obj.get('5'))\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CurrrryChen":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836821360","body":"**思路**\r\n利用js的BigInt累加\r\n\r\n**代码**\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    return (BigInt(num.join(''))+BigInt(k)).toString().split('').map(Number);\r\n};\r\n```\r\n\r\n**复杂度**\r\n时间复杂度:O(n)\r\n空间复杂度:O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839656205","body":"**思路**\r\n用数组模拟\r\n\r\n**代码**\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.val = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.val.length<this.maxSize){\r\n        this.val.push(x);\r\n    }else{\r\n        return;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.val.length){\r\n        return this.val.pop();\r\n    }else{\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    this.val = this.val.map((item,index) => {\r\n        if(index<k){\r\n            return item+val;\r\n        }\r\n        return item;\r\n    })\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n**复杂度**\r\n时间复杂度：increO(n) push,pop O(1)\r\n空间复杂度：O(n)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841779587","body":"**思路**\r\n先把链表首尾相连形成循环链表，再移动对应的步数后切断链表\r\n\r\n**代码**\r\n```js\r\nvar rotateRight = function (head, k) {\r\n    if (k === 0 || !head || !head.next) return head;\r\n    //获取list的长度和list的最后一个节点\r\n    let listLength = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        listLength++;\r\n    }\r\n\r\n    //将list首尾相连\r\n    cur.next = head;\r\n    //计算移动的步数\r\n    const step = listLength - (listLength % k);\r\n\r\n    if (step === listLength) {\r\n        return head;\r\n    }\r\n\r\n    while (step.next) {\r\n        cur = cur.next;\r\n        step--;\r\n    }\r\n\r\n    //步数移动完后，断开list\r\n    let res = cur.next;\r\n    cur.next = null;\r\n    return res;\r\n};\r\n```\r\n**复杂度**\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845188223","body":"**思路**\r\n遍历链表，同时存储到map中，判断当前节点是否已经出现在map中\r\n```js\r\nvar detectCycle = function(head) {\r\n    const map = new Map();\r\n    while(head!==null){\r\n        if(map.has(head)){\r\n            return head;\r\n        }else{\r\n            map.set(head);\r\n            head = head.next;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n```\r\n**复杂度分析**\r\n时间：O(n)\r\n空间：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846381190","body":"**思路**\r\n递归\r\n\r\n**代码**\r\n```js\r\nvar maxDepth = function(root) {\r\n    if(!root) return 0\r\n    return 1+Math.max(maxDepth(root.left),maxDepth(root.right));\r\n};\r\n```\r\n**复杂度**\r\n时间：O(n) n是树的node数\r\n空间：O(h) h是树的高度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"renziao":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836824996","body":"思路：leetcode官方题解的思路：数组和数字最后一位从后往前，对应的位相加，如果产生进位，数字k加1，这样就会在下一位中运 算了，最后如果数字k的长度大于数组的长度，那么就把数字k剩下的进行取余取整操作，加到目标数组中，最后数组反转得到结果\r\n\r\n代码：\r\n\r\npublic List addToArrayForm(int[] A, int K) {\r\n// 初始化参数\r\nList res = new ArrayList();\r\nint n = A.length;\r\n\r\n    // 1. 从后往前逐位相加\r\n    for(int i = n - 1;i >= 0;i--){\r\n        // 1.1 逐位相加\r\n        int sum = A[i] + K % 10;         // 每次重置sum\r\n        K /= 10;    \r\n        // 1.2 处理两位相加 进位的情况\r\n        if(sum >= 10){\r\n            K++;                        // 进位到K的末尾\r\n            sum -= 10;                  // 进位清掉\r\n        }\r\n        // 1.2 当前相加的结果 添加到结果集\r\n        res.add(sum);\r\n    }\r\n\r\n    // 2. K的数字长度大于数组的数字长度\r\n    for(;K > 0;K /= 10){                // 每次K左移一位\r\n        res.add(K % 10);                // 添加到结果集\r\n    }\r\n\r\n    // 3. 将结果集翻转即是所求答案\r\n    Collections.reverse(res);\r\n    return res;"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842396226","body":"思路：\r\n递归\r\n\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        // 已有的链表加一个头部 head node\r\n        ListNode resultHead = new ListNode();\r\n        resultHead.next = head;\r\n\r\n        // curNode 遍历链表时用\r\n        ListNode curNode = resultHead;\r\n\r\n        // 开始遍历链表\r\n        while(curNode != null && curNode.next != null && curNode.next.next != null) {\r\n            ListNode  f = curNode;\r\n            ListNode  s = curNode.next;\r\n            ListNode  t = s.next;\r\n\r\n            // 两两交换链表结点\r\n            f.next = t;\r\n            s.next = t.next;\r\n            t.next = s;\r\n\r\n            // 标杆位后移2位\r\n            curNode = curNode.next.next;\r\n        }\r\n        return resultHead.next;\r\n    }\r\n}\r\n时间：O(N)\r\n空间：O(1）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nbambi":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836826525","body":"思路\r\n- 遍历数组num，用k乘当前位的10的幂次，累加结果\r\n\r\n代码\r\n```\r\nvar addToArrayForm = function (num, k) {\r\n    let len = num.length - 1;\r\n    let result = 0;\r\n    for(let i=0; i<num.length; i++) {\r\n        result = result +num[i] * (Math.pow(10, len - i))\r\n    }\r\n    return result + k;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n- 时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837853699","body":"- 思路\r\n中心扩展法\r\n\r\n- 代码：JS\r\n```\r\n/**\r\n * 中心扩展法\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    let n = s.length;\r\n    let answer = Array(n).fill(0);\r\n\r\n    for (let i = 0; i < n; i++) {\r\n        // 刚好匹配 不处理\r\n        if (s[i] === c) continue;\r\n        // 定义向左向右两个指针, 初始化 最短距离=Infinity(因为数组默认初始值是0)\r\n        let l = i, r = i, shortest = Infinity;\r\n        // 向左找\r\n        while (l >= 0) {\r\n            if (s[--l] === c) {\r\n                shortest = Math.min(i - l, shortest); //如果left找到了先赋值\r\n            }\r\n        }\r\n        // 向右找\r\n        while (r <= n) {\r\n            if (s[++r] === c) {\r\n                shortest = Math.min(r - i, shortest); //如果left找到了, 会与之比较, 更小就会替换掉\r\n            }\r\n        }\r\n        answer[i] = shortest;\r\n    }\r\n    return answer;\r\n};\r\n```\r\n\r\n- 复杂度\r\n时间复杂度O(n2) 空间复杂度O(1)"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842161781","body":"### 思路\r\n- 1.递归\r\n- 2.迭代\r\n\r\n### JS代码：\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n\r\n/**\r\n * 方法1: 递归\r\n *  时间复杂度O(n) 空间复杂度O(n) n是链表的长度\r\n * \r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\n var swapPairs = function (head) {\r\n    if (head === null || head.next === null) {\r\n        return head;\r\n    }\r\n\r\n    // 1. 两两交换中的头结点\r\n    let newHead = head.next;\r\n\r\n    // 递归处理后续后面的链表(这行代码), 并把处理后链表的头结点指回来(下一行代码)\r\n    // 这个函数的作用就是两两进行交换, 返回交换后的头结点\r\n    head.next = swapPairs(newHead.next); \r\n\r\n    // 2. 两两交换中的尾结点, 递归处理, 将小链串成大链\r\n    newHead.next = head;\r\n\r\n    // 返回处理后的新的头结点\r\n    return newHead;\r\n};\r\n\r\n\r\n/**\r\n * 方法2: 迭代\r\n *  时间复杂度O(n) 空间复杂度O(1)\r\n * \r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    /**\r\n     * 涉及挪动指针的三段式套路:\r\n     *  1.创建虚拟节点 newHead 作为新链表的头结点\r\n     *  2.虚拟节点存储指向第一个节点的指针\r\n     *  ... 循环逻辑操作 ...\r\n     *  3.返回 newHead.next\r\n     */\r\n\r\n    // 创建虚拟节点\r\n    let newHead = new ListNode(0);\r\n    newHead.next = head;\r\n\r\n    let prev = newHead;\r\n    let cur;\r\n    let next;\r\n\r\n    while (\r\n        (cur = prev.next) !== null &&\r\n        (next = prev.next.next) !== null\r\n    ) {\r\n        // 0. 指针初始化\r\n        // cur = prev.next;\r\n        // next = cur.next;\r\n\r\n        // 1. 交换\r\n        cur.next = next.next;\r\n        next.next = cur;\r\n        // 注意: 交换后要把 前面链表的尾节点 与 交换后的头节点 连接起来\r\n        prev.next = next;\r\n\r\n        // 2. 移动指针\r\n        prev = cur;\r\n    }\r\n\r\n    return newHead.next;\r\n};\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AmuroPeng":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832176","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n\r\n\r\n示例 2：\r\n\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n\r\n\r\n示例 3：\r\n\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n\r\n\r\n示例 4：\r\n\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> ans = new ArrayList<Integer>();\r\n        for (int i = n - 1; i >=0; i--) {\r\n            int digit = num[i] + k % 10; // for each digit\r\n            k /= 10;\r\n            if (digit >= 10) {\r\n                digit -= 10;\r\n                k++;\r\n            }\r\n            ans.add(digit);\r\n        }\r\n        // if the length of k is more than num\r\n        while (k >= 10){\r\n            ans.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        if (k != 0) {\r\n            ans.add(k);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839711082","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int[] ans;\r\n    int cursor;\r\n\r\n    public CustomStack(int maxSize) {\r\n        ans = new int[maxSize];\r\n        cursor = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cursor == ans.length - 1) return;\r\n        cursor += 1;\r\n        ans[cursor] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cursor == -1) return -1;\r\n        cursor -= 1;\r\n        return ans[cursor + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int max_inc = Math.min(k, cursor + 1);\r\n        for (int i = 0; i < max_inc; i++) {\r\n            ans[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841206232","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Stack<Integer> in_stk, out_stk;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        in_stk = new Stack();\r\n        out_stk = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        in_stk.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (out_stk.isEmpty()) move();\r\n        return out_stk.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (out_stk.isEmpty()) move();\r\n        return out_stk.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return out_stk.isEmpty() && in_stk.isEmpty()?true:false;\r\n    }\r\n\r\n    public void move() {\r\n        while (!in_stk.isEmpty()) {\r\n            out_stk.push(in_stk.pop());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841836166","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 500] 内\r\n-100 <= Node.val <= 100\r\n0 <= k <= 2 * 109\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while (iter.next != null) {\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter.next = head;\r\n        while (add > 0) {\r\n            iter = iter.next;\r\n            add--;\r\n        }\r\n        ListNode ret = iter.next;\r\n        iter.next = null;\r\n        return ret;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842425433","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n\r\n \r\n\r\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    // key: save the pre and post link first, then do the changing stuff\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode zero = dummy;\r\n        ListNode one = new ListNode();\r\n        ListNode two = new ListNode();\r\n        while (zero.next != null && zero.next.next != null) {\r\n            // sign values\r\n            one = zero.next;\r\n            two = one.next;\r\n            // move\r\n            // 1. pre link\r\n            zero.next = two;\r\n            // 2. post link\r\n            one.next = two.next;\r\n            // 3. change positions of one and two\r\n            two.next = one;\r\n            // 4. update zero\r\n            zero = one;\r\n        }\r\n        return dummy.next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842799809","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return run(head, null);\r\n    }\r\n\r\n    public TreeNode run(ListNode left, ListNode right) {\r\n        // end\r\n        if (left == right) return null;\r\n        // find mid node\r\n        ListNode mid = getMid(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = run(left, mid);\r\n        root.right = run(mid.next, right); // should not compute mid twice\r\n        return root;\r\n    }\r\n\r\n    // find mid node\r\n    public ListNode getMid(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844233031","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\n如下面的两个链表：\r\n\r\n在节点 c1 开始相交。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Reference of the node with value = 8\r\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n\r\n\r\n \r\n\r\n示例 2：\r\n\r\n输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\n输出：Reference of the node with value = 2\r\n输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\r\n\r\n\r\n \r\n\r\n示例 3：\r\n\r\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\n输出：null\r\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\r\n解释：这两个链表不相交，因此返回 null。\r\n\r\n\r\n \r\n\r\n注意：\r\n\r\n如果两个链表没有交点，返回 null.\r\n在返回结果后，两个链表仍须保持原有的结构。\r\n可假定整个链表结构中没有循环。\r\n程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\n\r\npublic class Solution {\r\n\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        HashSet<ListNode> hashSet = new HashSet<>();\r\n\r\n        ListNode curNode = headA;\r\n        while (curNode != null) {\r\n            hashSet.add(curNode);\r\n            curNode = curNode.next;\r\n        }\r\n\r\n        curNode = headB;\r\n        while (curNode != null) {\r\n            if(hashSet.contains(curNode)){\r\n                return curNode;\r\n            }\r\n            curNode = curNode.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846377181","body":"\r\n## 题目地址(104. 二叉树的最大深度)\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n示例：\r\n给定二叉树 [3,9,20,null,null,15,7]，\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n返回它的最大深度 3 。\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\n\r\n// DFS\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left),maxDepth(root.right));\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(logn)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846487250","body":"\r\n## 题目地址(100. Same Tree)\r\n\r\nhttps://leetcode-cn.com/problems/same-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\nGiven the roots of two binary trees p and q, write a function to check if they are the same or not.\r\n\r\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: p = [1,2,3], q = [1,2,3]\r\nOutput: true\r\n\r\n\r\nExample 2:\r\n\r\nInput: p = [1,2], q = [1,null,2]\r\nOutput: false\r\n\r\n\r\nExample 3:\r\n\r\nInput: p = [1,2,1], q = [1,1,2]\r\nOutput: false\r\n\r\n\r\n \r\n\r\nConstraints:\r\n\r\nThe number of nodes in both trees is in the range [0, 100].\r\n-104 <= Node.val <= 104\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n- 递归\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        else if(p == null || q == null) return false;\r\n        else if(p.val != q.val) return false;\r\n        else return isSameTree(p.left,q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christ36":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836832193","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838755307","body":"public class mindistant {\r\n    public int[] addToArrayForm(String S, char C) {\r\n        int N = S.length();\r\n        int[] res = new int[N];\r\n        for(int i = 0; i <N; i++) {\r\n            if (S.charAt(i) == C) continue;\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S.charAt(left) == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S.charAt(right) == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n            res[i] = dist;\r\n        }\r\n        return res;\r\n    }\r\n}"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843640437","body":"import java.util.HashSet;\r\nimport java.util.Set;\r\n\r\npublic class Solution {\r\n\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> hashSet = new HashSet<>();\r\n\r\n        ListNode curNode = headA;\r\n        while (curNode != null) {\r\n            hashSet.add(curNode);\r\n            curNode = curNode.next;\r\n        }\r\n\r\n        curNode = headB;\r\n        while (curNode != null) {\r\n            if(hashSet.contains(curNode)){\r\n                return curNode;\r\n            }\r\n            curNode = curNode.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangyinghua":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836833635","body":"思路:\r\n\r\n* 从右往左 依次遍历 [十进一]\r\n\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const len= num.length;\r\n\r\n   //需要处理 两者长度不一，可能数组的个数小于k的个数\r\n    for (let i = len - 1; (i >= 0 || k > 0); (--i, k = parseInt(k / 10))) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n\r\n复杂度\r\n\r\n* 时间复杂度O(Max(n,k)) \r\n* 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838753017","body":"思路：\r\n从两个方向扫描，在相同位置进行比较。\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n var shortestToChar = function (s, c) {\r\n        let N = s.length;\r\n        let ans = new Array(N);\r\n        let prev=Number.MIN_SAFE_INTEGER/2;\r\n        for (let i = 0; i < N; ++i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev =Number.MAX_SAFE_INTEGER/2;\r\n        for (let i = N-1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n   };\r\n```\r\n复杂度分析\r\n  * 时间复杂度:O(N);\r\n  * 空间复杂度:O(N);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839814019","body":"* 方法一：\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize=maxSize;\r\n    this.customStack=[];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    const len=this.customStack.length;\r\n    if(len<this.maxSize){\r\n        this.customStack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    const result= this.customStack.pop();\r\n    return typeof result ==='undefined'?-1:result;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const len=this.customStack.length;  \r\n    for(let i=0;(i<Math.min(k,len));i++){\r\n        this.customStack[i]+=val;\r\n    }\r\n}\r\n```\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize=maxSize;\r\n    this.customStack=[];\r\n    this.top=-1;//栈顶指针\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if((this.top)!==(this.maxSize-1)){\r\n        this.top++;\r\n        this.customStack[this.top]=x;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.top===-1){\r\n        return -1;\r\n    }\r\n    this.top--;\r\n    return this.customStack[this.top+1];\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const s=Math.min(k,this.top+1);\r\n    for(let i=0;i<s;i++){\r\n        this.customStack[i]+=val;\r\n    }\r\n}\r\n```\r\n* 复杂度：\r\n时间复杂度 increment O(min(k,n))，其他方法O(1);\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594127","body":"\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [];        \r\n    let strStack = [];        \r\n    let num = 0;              \r\n    let result = '';         \r\n    for (const char of s) {   \r\n        if (isInteger(char)) { \r\n            num =num * 10 + Number(char); \r\n        } else if (char == '[') { \r\n            strStack.push(result);\r\n            result = '';          \r\n            numStack.push(num);   \r\n            num = 0;              \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop();\r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;       \r\n        }\r\n    }\r\n    return result;\r\n   \r\n};\r\n\r\nfunction isInteger(obj) {\r\n    return /^[0-9]$/.test(obj);\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841309134","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.inStack = []\r\n  this.outStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.inStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.outStack.length === 0) {\r\n    this.in2out()\r\n  }\r\n  return this.outStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.outStack.length === 0) {\r\n    this.in2out()\r\n  }\r\n  return this.outStack[this.outStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.inStack.length === 0 && this.outStack.length === 0\r\n};\r\n\r\n/**\r\n * move the all elements from inStack to outStack.\r\n * @return {void}\r\n */\r\nMyQueue.prototype.in2out = function() {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop())\r\n  }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667694","body":"\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = sum2 = 0; \r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n时间复杂度：\r\nO(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Gjts":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836834532","body":"算法流程\r\n\r\n    获取数组的长度\r\n    将 需要添加的targe赋值给sum\r\n    求出 num 和 k 之和 sum\r\n    逐位取 sum % 10，sum = sum // 10\r\n    反转，res[::-1]\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n)\r\n    空间复杂度：O(n)\r\n\r\n代码\r\n    \r\n    语言支持：c#\r\n    public IList<int> AddToArrayForm(int[] num, int k) {\r\n          int i = num.Length - 1;\r\n          int sum = k;\r\n          List<int> arr = new List<int>();\r\n          while(i >= 0 || sum > 0){\r\n              if(i >= 0){\r\n                  sum += num[i];\r\n              }\r\n              arr.Add(sum % 10);\r\n              sum /= 10;\r\n              i--;\r\n          }\r\n          int[] arr1 = arr.ToArray();\r\n          Array.Reverse(arr1);\r\n          return arr1;\r\n      }：\r\n  "},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838023165","body":"算法流程:\r\n\r\n    获取字符的长度\r\n    定义一个未知数int prev右移一位 int.MinValue>>1 int.MaxValue>>1 \r\n    左移、右移一位是为了定义一个边界值 0-最小值有问题 不会变成一个正整数\r\n    把字符串转换成数组char 判断和target相等 就取代那个未知数prev默认的位置\r\n    二分遍历查询数组，第一轮找到左边离target最近的数\r\n    ，第二轮找到右边离target最近的数，判断谁小把谁放到数组中\r\n\r\n复杂度分析\r\n\r\n    时间复杂度：O(n) 循环遍历数组的长度\r\n    空间复杂度：O(n) 创建了一个数组  复杂度分析不太懂 特别是空间复杂度\r\n\r\n语言支持：c#\r\n\r\n    public int[] ShortestToChar(string s, char c) {\r\n        int N = s.Length;\r\n        var isok = s.ToCharArray();\r\n        int[] ans = new int[N];\r\n        var prev = int.MinValue >> 1;\r\n        for (int i = 0; i < s.Length; i++)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = int.MaxValue >> 1;\r\n        for (int i = N - 1; i >= 0; --i)\r\n        {\r\n            if (isok[i] == c) prev = i;\r\n            ans[i] = Math.Min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843050432","body":"思路 快慢指针\r\n\r\n代码\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode left, ListNode right) {\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n\r\n    public ListNode getMedian(ListNode left, ListNode right) {\r\n        ListNode fast = left;\r\n        ListNode slow = left;\r\n        while (fast != right && fast.next != right) {\r\n            fast = fast.next;\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doubelejjyy":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836835885","body":"**思路:**\r\n1.从低位开始加\r\n2.可能k的长度大于数组的长度,所以可能for循环结束了但是k没加完,所以最后用while\r\n3.list.add的顺序是队列所以list一开始的顺序是答案从低位到高位的顺序 所以要逆序一下\r\n**代码**\r\n\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> list = new ArrayList<>();\r\n        int length = num.length;\r\n        int value;\r\n        for (int i = length-1; i >=0; i--) {\r\n            value = num[i]+k%10;\r\n            k/=10;\r\n            if(value>9){\r\n                value -=10;\r\n                k++;//进位\r\n            }\r\n            list.add(value);\r\n\r\n        }\r\n\r\n        while(k!=0)\r\n            list.add(k%10);\r\n            k/=10;\r\n        }\r\n\r\n        Collections.reverse(list);\r\n        return list;\r\n\r\n    }\r\n}\r\n```\r\n\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(n)**"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837883042","body":"**思路:**\r\n1.从左到右遍历只考虑每个字符和它左边的c的距离\r\n2.从右到左遍历只考虑每个字符和它右边的c的距离\r\n3.然后比较大小\r\n\r\n**代码**\r\nJava Code:\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        \r\n        int length = s.length();\r\n        int pre = Integer.MIN_VALUE / 2;//除2是为了防止 i-pre超过int的最大值\r\n        int[] answer = new int[length];\r\n        //1.先从左边往右找 计算每个字符和上一个c的距离是多少\r\n        for (int i = 0; i < length; i++) {\r\n\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            answer[i] = i-pre;\r\n        }\r\n\r\n        //从右边往左找 每次计算当前字符和上一个c的距离是多少\r\n        pre = Integer.MAX_VALUE / 2;// \r\n        for (int i = length-1; i >=0; i--) {\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n\r\n            if(answer[i]<pre - i){\r\n\r\n            }else{\r\n                answer[i] = pre - i;\r\n            }\r\n        }\r\n\r\n        return answer;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度O(n)**\r\n**空间复杂度O(1)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839482809","body":"**思路：**实际上就是用数组模拟栈\r\n\r\nincrement方法可以优化，如果直接解就是对最后的k个元素都加上value\r\n\r\n优化就是再定义一个和栈同样长度的add数组\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int maxSize;\r\n    int realSize = 0;//栈中值的数量\r\n    int[] add;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        add = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(realSize<maxSize){//栈还没满 还可以添加\r\n            stack[realSize++] = x;\r\n        }else{\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(realSize>0){//先判断stack中是否有元素\r\n            int temp = realSize-1;//需要pop出的元素的索引 \r\n            if(temp-1>=0 && add[temp]!=0){//不是最后一个往后移\r\n                add[temp-1] += add[temp];\r\n            }\r\n            int result = stack[--realSize]+add[temp];\r\n            add[temp] = 0;\r\n            return result;\r\n        }\r\n        return -1;\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n\r\n        int min = Math.min(k,realSize);\r\n        if(min>0){\r\n            add[min-1] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**时间复杂度O(1)**\r\n\r\n**空间复杂度O(n)**"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840642199","body":"思路：栈  和计算器那种题目类似\r\n```\r\nclass Solution {\r\n    char[] ch;\r\n    public String decodeString(String s) {\r\n        ch = s.toCharArray();\r\n        return dfs(0)[0];\r\n    }\r\n\r\n    public String[] dfs(int i){\r\n        StringBuilder res = new StringBuilder();\r\n        int num = 0;\r\n        while(i < ch.length){\r\n            if(ch[i] <= '9' && ch[i] >= '0'){\r\n                num = num * 10 + Integer.parseInt(\"\" + ch[i]);\r\n            }else if(ch[i] == '['){\r\n                String[] tmp = dfs(i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(num > 0){\r\n                    res.append(tmp[1]);\r\n                    num--;\r\n                }\r\n            }else if(ch[i] == ']'){\r\n                return new String[]{\"\" + i, res.toString()};\r\n            }else{\r\n                res.append(\"\" + ch[i]);\r\n            }\r\n            i++;\r\n        }\r\n        return new String[]{res.toString()};\r\n    }\r\n}\r\n```\r\n时间复杂读O(n)\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841203075","body":"### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n1.没有优化 \r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> inStack = new Stack<>();\r\n    private Stack<Integer> outStack = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(empty()){\r\n            return -1;\r\n        }\r\n\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n\r\n        int temp = outStack.pop();\r\n\r\n        while(!outStack.isEmpty()){\r\n            inStack.push(outStack.pop());\r\n        }\r\n\r\n        return temp;\r\n\r\n\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(empty()){\r\n            return -1;\r\n        }\r\n\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n\r\n        int temp = outStack.pop();\r\n        outStack.push(temp);\r\n\r\n        while(!outStack.isEmpty()){\r\n            inStack.push(outStack.pop());\r\n        }\r\n\r\n        return temp;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty();\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n2.优化\r\n\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inputStack.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n\r\n        return outputStack.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n                outputStack.push(inputStack.pop());\r\n            }\r\n        }\r\n\r\n        int temp = outputStack.pop();\r\n        outputStack.push(temp);\r\n        return temp;\r\n\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n**时间复杂度**  O(1)\r\n\r\n**空间复杂度** O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841792486","body":"### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n思路：先把链表变成环  然后改变链表的头节点 断开环即可\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null){\r\n            return null;\r\n        }\r\n        ListNode point = head;\r\n        int count = 1;\r\n\r\n        while(point.next!=null){\r\n            point = point.next;\r\n            count++;\r\n        }\r\n        //此时point已经为最后一个节点了  count为节点的数目\r\n        point.next = head;//成环\r\n\r\n        int step = k%count;//step就是要移动的距离 因为比如 5个节点 你移动4步和移动9步效果一样的\r\n        //但是这个step实际上是逆着走的步数  比如 所有节点往前3个 就是头节点在当前头节点往后3\r\n\r\n        if(step==0){\r\n            point.next = null;\r\n            return head;\r\n        }\r\n        \r\n        //所以真正的step  =  count -step 把往后又变成了往前\r\n        step = count - step;\r\n        step--;//因为我们要到前面一个节点把环断了\r\n        point = point.next;//又回到头节点\r\n        while(step>0){\r\n            point = point.next;\r\n            step--;\r\n        }\r\n        \r\n        ListNode newHead = point.next;\r\n        point.next = null;\r\n        return newHead;\r\n        \r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度** O(n)\r\n\r\n**空间复杂度** O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841935489","body":"### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n1.普通做法\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){ //只有一个节点或者空则直接返回\r\n            return head;\r\n        }\r\n       ListNode pre = new ListNode(0,head);\r\n       ListNode tempNode = null;\r\n       ListNode bak = pre;\r\n       while(pre.next !=null && pre.next.next != null){\r\n           tempNode = pre.next.next;\r\n           pre.next.next = pre.next.next.next;\r\n           tempNode.next = pre.next;\r\n           pre.next = tempNode;\r\n           pre = pre.next.next;\r\n       }\r\n       return bak.next;\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度** O(n)\r\n\r\n**空间复杂度** O(1)\r\n\r\n2.递归\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next == null){ //只有一个节点或者空则直接返回\r\n            return head;\r\n        }\r\n       \r\n       ListNode temp = head.next;\r\n       head.next = swapPairs(head.next.next);\r\n       temp.next = head;\r\n       return temp;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度**O(n)\r\n\r\n**空间复杂度**O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843271643","body":"因为有序 所以不用考虑 左旋右旋这些，递归找中间节点，然后两边分别为左右子树\r\n注意考虑临界点\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        // 快慢指针找到链表的中点，中点作为根结点，两边作为左右子树\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        // 快慢指针找中间结点\r\n        ListNode fast = head, slow = head, pre = null;\r\n        while(fast != null && fast.next != null){\r\n            fast =  fast.next.next;\r\n            pre = slow;\r\n            slow = slow.next;\r\n        }\r\n        // 分割出左链表，用于构造本结点的左子树\r\n        pre.next = null;\r\n        // 分割出右链表，用于构造本结点的右子树\r\n        ListNode rightList = slow.next;\r\n        // 用中间结点构造根结点\r\n        TreeNode root = new TreeNode(slow.val);\r\n        // 构造左子树\r\n        root.left = sortedListToBST(head);\r\n        // 构造右子树\r\n        root.right = sortedListToBST(rightList);\r\n        // 返回本结点所在子树\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843697836","body":"### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n1.暴力法\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n       if(headA==null || headB==null){\r\n           return null;\r\n       } \r\n       \r\n        while(headA!=null){\r\n             ListNode point = headB;\r\n             while(point!=null){\r\n                if(headA==point){\r\n                    return point;\r\n                }\r\n                point = point.next;\r\n             }\r\n\r\n             headA = headA.next;\r\n\r\n        }\r\n\r\n        return null;\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度** O(n^2)\r\n\r\n**空间复杂度** O(1)\r\n\r\n2.Set\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n        public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> set = new HashSet<>();\r\n\r\n        while(headA!=null){\r\n            set.add(headA);\r\n            headA = headA.next;\r\n        }\r\n\r\n        while(headB!=null){\r\n            if(!set.add(headB)){\r\n                return headB;\r\n            }\r\n            headB = headB.next;\r\n        }\r\n\r\n        return null;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度** O(n)\r\n\r\n**空间复杂度** O(n)\r\n\r\n3.重复对方链表走的路  所以总路程是一样的  要么是在交点相遇 要么是在 没有交点null相遇\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA==null || headB==null){\r\n            return null;\r\n        }\r\n\r\n        ListNode pointA = headA,pointB = headB;\r\n\r\n        while(pointA!=pointB){\r\n            pointA = pointA==null?headB:pointA.next;\r\n            pointB = pointB==null?headA:pointB.next;\r\n        }\r\n        \r\n        return pointA;\r\n\r\n\r\n    }\r\n}\r\n```\r\n\r\n**时间复杂度** O(m+n)\r\n\r\n**空间复杂度** O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844632226","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        //思路就是快慢指针 fast走两步  slow走一步  当相遇  说明有环   当fast null说明没有环\r\n        //当有环的时候slow再走a步 就到了 入环点   怎么判断a  实际上就是head ->  入环口的时候  就是a步\r\n\r\n        ListNode fastPoint = head;//快指针\r\n        ListNode slowPoint = head;//慢指针\r\n\r\n        while(fastPoint!=null&&fastPoint.next!=null){//如果指针能走到null  说明是没有环的\r\n            fastPoint = fastPoint.next.next;\r\n            slowPoint = slowPoint.next;\r\n            if(fastPoint==slowPoint){//当相遇了 说明有环 \r\n                fastPoint = head;\r\n                while(fastPoint!=slowPoint){\r\n                    fastPoint = fastPoint.next;\r\n                    slowPoint = slowPoint.next;\r\n                }\r\n                return fastPoint;\r\n            }\r\n        }\r\n\r\n        return null;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845977606","body":"### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n**思路：**\r\n\r\n最近最少使用缓存机制 也就是当缓存满的时候覆盖最久没有使用的内容\r\n\r\n这题使用双向链表 + 哈希表(存放key，以及链表的node)\r\n\r\n```java\r\nclass LRUCache {\r\n\r\n    private Map<Integer,DLinkedNode> myCache = new HashMap<>();//key  value是节点的地址\r\n    private int capacity;\r\n    private int curCount = 0;\r\n    private DLinkedNode head,tail;\r\n\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        //创建伪头部和伪尾部\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = myCache.get(key);\r\n        if(node == null){\r\n            return -1;\r\n        }else{//不仅要返回值还要把访问的这个节点放到头节点\r\n            node.prev.next = node.next;//把这个节点提出来 把前后两个关联起来\r\n            node.next.prev = node.prev;\r\n\r\n            head.next.prev = node; //node 和本来的第一个节点关联起来\r\n            node.next = head.next;\r\n\r\n            head.next = node;\r\n            node.prev = head;\r\n\r\n            return node.value;\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public void put(int key, int value) {\r\n\r\n        DLinkedNode node = myCache.get(key);\r\n\r\n        if(node==null){//说明要添加的这个节点目前没有，没有的话先判断是否满\r\n            if(capacity==curCount){\r\n                //1.创建新的节点并放到头部\r\n                DLinkedNode newNode = new DLinkedNode(key, value, head, head.next);\r\n                head.next.prev = newNode;\r\n                head.next = newNode;\r\n                myCache.put(key,newNode);\r\n                //2.把最后一个节点从map中remove\r\n                DLinkedNode lastNode = tail.prev;\r\n                myCache.remove(lastNode.key);//\r\n                //3.真正从双向链表中删除node\r\n                DLinkedNode newLast = lastNode.prev;\r\n\r\n                //可有可无\r\n                lastNode.prev = null;\r\n                lastNode.next =null;\r\n\r\n                newLast.next = tail;\r\n                tail.prev = newLast;\r\n\r\n\r\n            }else{//没满\r\n                curCount++;\r\n                DLinkedNode newNode = new DLinkedNode(key, value, head, head.next);\r\n\r\n                if(curCount==1){//第一个节点\r\n                    tail.prev = newNode;\r\n                    head.next = newNode;\r\n                }else{\r\n                    //1.创建新的节点放到头部\r\n                    head.next.prev = newNode;\r\n                    head.next = newNode;\r\n                    myCache.put(key,newNode);\r\n                }\r\n\r\n                myCache.put(key,newNode);\r\n\r\n            }\r\n\r\n        }else{//不等于null  已经存在了这个key 只需要修改value 然后放到头即可\r\n            node.value = value;\r\n\r\n            //1.断开当前node\r\n            node.prev.next = node.next;\r\n            node.next.prev = node.prev;\r\n\r\n            //2.放到头部\r\n            node.next = head.next;\r\n            head.next.prev = node;\r\n\r\n            node.prev = head;\r\n            head.next = node;\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n    class DLinkedNode{\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n\r\n        public DLinkedNode() {}\r\n\r\n        public DLinkedNode(int key, int value, DLinkedNode prev, DLinkedNode next) {\r\n            this.key = key;\r\n            this.value = value;\r\n            this.prev = prev;\r\n            this.next = next;\r\n        }\r\n\r\n\r\n    }\r\n\r\n}\r\n\r\n```\r\n\r\n**时间复杂度**：O(1)\r\n\r\n**空间复杂度**：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846422526","body":"### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\n1.递归 **==实际上也是DFS==**  \r\n\r\n**==DFS最简单的应用==**    dfs和栈相关  递归不就是栈吗\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        //最大深度 dfs\r\n        return dfs(root);\r\n\r\n    }\r\n\r\n    public int dfs(TreeNode root){\r\n\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n\r\n        return Math.max(dfs(root.left),dfs(root.right))+1;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**2.bfs**  bfs和队列相关\r\n\r\n```java\r\npublic int bfs(TreeNode root){\r\n        if(root==null){\r\n            return 0;\r\n        }\r\n\r\n        Deque<TreeNode> deque = new LinkedList<>();//创建一个队列\r\n        deque.addLast(root);\r\n        int level = 0;\r\n\r\n        while(!deque.isEmpty()){//非空就一直循环\r\n\r\n            //deque每一次里面都是每一层的数据 所以要都拿出来看看\r\n            int size = deque.size();\r\n\r\n            for (int i = 0; i < size; i++) {//把当前层的数据拿出来  然后把下一层的放进去\r\n                TreeNode treeNode = deque.removeFirst();\r\n                if(treeNode.left!=null){\r\n                    deque.addLast(treeNode.left);\r\n                }\r\n                if(treeNode.right!=null){\r\n                    deque.addLast(treeNode.right);\r\n                }\r\n\r\n            }\r\n            level++;\r\n\r\n\r\n        }\r\n\r\n        return level;\r\n\r\n    }\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyyangrun":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836844742","body":"```\r\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n    res = []\r\n    i, carry = len(A) - 1, 0\r\n    while i >= 0 or K != 0:\r\n        x = A[i] if i >= 0 else 0\r\n        y = K % 10 if K != 0 else 0\r\n        sum = x + y + carry\r\n        res.append(sum % 10)\r\n        carry = sum // 10\r\n        i -= 1\r\n        K //= 10\r\n    if carry != 0: res.append(carry)\r\n    return res[::-1]\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839890841","body":"\r\n    class CustomStack:\r\n\r\n        def __init__(self, maxSize: int):\r\n            self.stack=[]\r\n            self.maxsize=maxSize\r\n\r\n\r\n        def push(self, x: int) -> None:\r\n            if len(self.stack)< self.maxsize:\r\n                self.stack.append(x)\r\n\r\n        def pop(self) -> int:\r\n            if len(self.stack)>0:\r\n               p=self.stack.pop()\r\n                return p\r\n            else:\r\n                return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack)<k:\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]=self.stack[i]+val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]=self.stack[i]+val\r\n        return self.stack\r\n\r\n\r\n\r\n\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683087","body":"python3\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tipshal":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836845741","body":"我是码盲，刚开始学Python，先说一下思路吧：\r\n1.把一维数组转换成整数\r\n  s=0\r\n  for i in A\r\n    s=s*10+i\r\n2.整体进行加法运算\r\n  s=s+k\r\n3.将计算结果转成字符串，用列表推导式把每一位字符转换成整数\r\n  s=str(s)\r\n  return[int(x) for x in s]"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838738222","body":"囧迫的我还没搞好Python，先抄了一段Java，大概意思看明白了，就是通过两次遍历，找出c的位置，进行与当前每个字符的比对\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] dist = new int[length];\r\n        \r\n        // 从左向右遍历\r\n        int loc = 10000;\r\n        for(int i=0;i<length;i++){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.abs(i-loc);\r\n        }\r\n\r\n        // 从右向左遍历\r\n        for(int i=length-1;i>=0;i--){\r\n            if(s.charAt(i)==c) loc = i;\r\n            dist[i] = Math.min(dist[i],Math.abs(i-loc));\r\n        }\r\n\r\n        return dist;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840576685","body":"\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack=[] #空栈\r\n        flag = False #设置一个布尔型变量，初始值为假\r\n        for c in s[::-1]+\"/\": #返向循环\r\n            if c.isdigit(): #判断c是否为数字\r\n                flag = True #如果c为数字，flag变为真\r\n            if not c.isdigit() and flag:   #如果c不为数字（即字符）且flag为真\r\n                flag = False #flag为假           \r\n                temp = [] #临时空列表\r\n                while True: \r\n                    t = stack.pop() #出栈字符逐个赋值\r\n                    if t!=\"]\": #如果未遇到]\r\n                        temp.append(t)#将临时列表中的数堆栈\r\n                    else:\r\n                        break\r\n                temp = \"\".join(temp).split(\"[\")#将临时列表里的字符转成字符串，再以\"[\"分割\r\n                stack.append(int(temp[0])*temp[1]) #前面是数值，后面是字符\r\n            stack.append(c) #将结果压栈\r\n        stack.pop()\r\n        return \"\".join(stack[::-1])\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841331022","body":"class Queue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.instack = []\r\n        self.outstack = []\r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.instack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.outstack:\r\n            while self.instack:\r\n                self.outstack.append(self.instack.pop())\r\n        return self.outstack[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.outstack) + len(self.instack)==0"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845880104","body":"思路来自kofzhang\r\n使用一个OrderedDict存储。\r\n添加的时候检查有没有在字典中，如果在，挪到后面，更新值。如果不在，看是否满了，满了，就先pop最左边的，然后加进来。没满，直接加进来。\r\n查找的时候一样，先看是否存在，存在，挪到后面，更新值。不在，返回-1\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.size = capacity\r\n        self.cache = OrderedDict()\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        t = self.cache.get(key)\r\n        if t!=None:\r\n            self.cache.move_to_end(key,last=True)\r\n            return t        \r\n        return -1\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if self.cache.get(key)!=None:\r\n            self.cache[key]=value\r\n            self.cache.move_to_end(key,last=True)\r\n            return\r\n        if self.size==0:\r\n            self.cache.popitem(last=False)\r\n            self.size+=1\r\n        self.size-=1\r\n        self.cache[key]=value\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zsjlovelike":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836846214","body":"Class Solution{\r\nList<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\r\n            if (i >= 0) {\r\n                k += num[i];\r\n            }\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838335540","body":"class Solution { \r\n public  int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        //保证有prev参与的加减运算不会溢出。同时又能起到最小值的效果\r\n        //因为i>=0,不除以2会越界。防止从左向右遍历数组时i-pre越界。\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(res[i], prev - i);\r\n        }\r\n        return res;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839745214","body":"public class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        StringBuilder sb=new StringBuilder(\"[\");\r\n        for (int i = 0; i < stack.length; i++) {\r\n            sb.append(stack[i]+\",\");\r\n        }\r\n        sb.append(\"]\");\r\n        String res = sb.toString();\r\n        return res;\r\n    }\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840395899","body":"public class Solution {\r\n    private static int p;\r\n\r\n    public static void main(String[] args) {\r\n        String s = \"3[a2[c]]\";\r\n        System.out.println(decodeString(s));\r\n    }\r\n\r\n    public static String decodeString(String s) {\r\n        LinkedList<String> list = new LinkedList<>();\r\n        p = 0;\r\n\r\n        while (p < s.length()) {\r\n            char c = s.charAt(p);\r\n            if (Character.isDigit(c)) {\r\n                //获取一个数字进栈\r\n                String digits = getDigits(s);\r\n                list.addLast(digits);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                //获取一个字母进栈\r\n                list.addLast(String.valueOf(s.charAt(p++)));\r\n            } else {\r\n                ++p;\r\n                LinkedList<String> sub = new LinkedList<>();\r\n                while (!\"[\".equals(list.peekLast())) {\r\n                    sub.addLast(list.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                //左括号出栈\r\n                list.removeLast();\r\n                //此时栈顶为当前sub对应的字符串应该出现的次数\r\n                int n = Integer.parseInt(list.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(sub);\r\n                while (n-- > 0) {\r\n                    sb.append(o);\r\n                }\r\n                list.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(list);\r\n    }\r\n\r\n\r\n    public static String getDigits(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        while (Character.isDigit(s.charAt(p))) {\r\n            sb.append(s.charAt(p++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public static String getString(LinkedList<String> list) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String s : list) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841187642","body":"public class MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841653835","body":"public class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for(int num : arr) {\r\n            if(!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                stack.addLast(head);\r\n            }\r\n            else stack.addLast(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841830968","body":"public ListNode rotateRight(ListNode head, int k) {\r\n           if (head == null || head.next == null) {\r\n                return head;\r\n            }\r\n            //计算链表的长度，顺便得到链表的最后一个节点\r\n            ListNode cur = head;\r\n            int len = 1;\r\n            while (cur.next != null) {\r\n                len++;\r\n                cur = cur.next;\r\n            }\r\n            int index = len - (k % len) - 1;\r\n           \r\n            cur.next = head;\r\n            //来到重新组装链表的位置\r\n            for (int i = 0; i < index; i++) {\r\n                head = head.next;\r\n            }\r\n            //head的next节点便是新的头节点，head自身便是尾节点\r\n            ListNode newHead = head.next;\r\n            //断开头尾节点\r\n            head.next = null;\r\n            return newHead;\r\n        }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842281404","body":"public class Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null || head.next == null) {\r\n            return head;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = swapPairs(newHead.next);\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843148280","body":"public class Solution {\r\n    ListNode globalHead;\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        globalHead = head;\r\n        int length = getLength(head);\r\n        return buildTree(0, length - 1);\r\n    }\r\n\r\n    public int getLength(ListNode head) {\r\n        int ret = 0;\r\n        while (head != null) {\r\n            ++ret;\r\n            head = head.next;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    public TreeNode buildTree(int left, int right) {\r\n        if (left > right) {\r\n            return null;\r\n        }\r\n        int mid = (left + right + 1) / 2;\r\n        TreeNode root = new TreeNode();\r\n        root.left = buildTree(left, mid - 1);\r\n        root.val = globalHead.val;\r\n        globalHead = globalHead.next;\r\n        root.right = buildTree(mid + 1, right);\r\n        return root;\r\n    }\r\n\r\n}\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844759435","body":" public  ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) break;\r\n        }\r\n        fast = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845901980","body":" class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n     \r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n     \r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n           \r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            \r\n            cache.put(key, newNode);\r\n         \r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n               \r\n                DLinkedNode tail = removeTail();\r\n                \r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846364488","body":"class Solution {\r\n    public int maxDepth(TreeNode root) {\r\n          return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836860926","body":"class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838683020","body":"class Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int N =S.length();\r\n        int[] ans =new int[N];\r\n        int prev = Integer.MIN_VALUE/2;\r\n        for(int i=0;i<N;i++){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=i-prev; \r\n        }\r\n        prev=Integer.MAX_VALUE/2;\r\n        for(int i=N-1;i>=0;--i){\r\n            if(S.charAt(i)==C) prev=i;\r\n            ans[i]=Math.min(ans[i],prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836861924","body":"思路：\r\n1.list转换为int，计算加法，再把结果转化为list\r\n2.缺点运行速度太慢，空间一般\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        B = 0\r\n        for i in range(len(A) - 1, -1, -1):\r\n            B += A[i]*(10**(len(A) - i - 1))  \r\n        C = B + K\r\n        \r\n        if C == 0:\r\n            D = [0]\r\n        else:\r\n            D = []\r\n        \r\n        while C:\r\n            D.append(C%10)\r\n            C //=10\r\n        D.reverse()\r\n        return D"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838722787","body":"思路：\r\n两边分别寻找距离，然后对比。一开始不知道怎么处理没找到的情况，solution的方法很简洁，借鉴了一下\r\n\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            l = i   \r\n            while l >= 0:\r\n                if s[l] == c:\r\n                    break\r\n                else:\r\n                    l -= 1\r\n                 \r\n            r = i\r\n            while r < len(s):\r\n                if s[r] == c:\r\n                    break\r\n                else:\r\n                    r += 1\r\n                    \r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 10000\r\n            num = min(i-l, r-i)\r\n            ans.append(num)\r\n        return ans\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839870744","body":"### 思路 \r\n基本的list栈，push(append), pop(pop)，题目要求的increment单独写一下就好\r\n### 代码 Python3\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.cs = []\r\n        self.sz = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.cs) < self.sz: \r\n            self.cs.append(x)\r\n            \r\n    def pop(self) -> int:\r\n        if len(self.cs) == 0:\r\n            return -1\r\n        return self.cs.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.cs) <= k:\r\n            for i in range(len(self.cs)):\r\n                self.cs[i] += val\r\n        if len(self.cs) > k:\r\n            for i in range(k):\r\n                self.cs[i] += val\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840268397","body":"### 思路\r\n栈符号，读str然后写进stack里面，先找 ']' , 再回过来找 '[' \r\n有参考题解的思路\r\n\r\n### 代码 Python3\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for i in s:\r\n            if  i == ']':\r\n                les = ''\r\n                num = ''\r\n                while stack[-1].isalpha():\r\n                    les = stack.pop() + les\r\n                stack.pop()\r\n                while stack != [] and stack[-1].isnumeric():\r\n                    num = stack.pop() + num\r\n                stack.append(les * int(num))\r\n            else:\r\n                stack.append(i)\r\n        return \"\".join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841321427","body":"### 思路\r\n双栈模拟队列\r\nLeetCode有的case测试没通过，我去看看题解，在思考思考，先来打卡\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n            \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.s1 == []:\r\n            return None\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        pop = self.s2.pop()\r\n        if self.s2 == []:\r\n            return None\r\n        self.s1.append(self.s2.pop())\r\n        return pop\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.s1 == []:\r\n            return None\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        peek = self.s2[-1]\r\n        self.s1.append(self.s2.pop())\r\n        return peek\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.s1)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678163","body":"### 思路\r\n栈，前一项大于后一项就进行融合，融合后的最大值写入栈中，最后计算栈长度\r\n一开始不会，参考了题解的思路\r\n\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        s = []\r\n        for i in A:\r\n            if s and s[-1] > i:\r\n                num = s[-1]\r\n                while s and s[-1] > i:\r\n                    s.pop()\r\n                s.append(num)\r\n            else:\r\n                s.append(i)\r\n        return len(s)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841836450","body":"### 思路\r\n双指针\r\n不会链表的东西，学习了题解\r\n### 代码\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        p1 = p2 = head\r\n        c = 1\r\n        i = 0\r\n        while i < k:\r\n            if p2.next:\r\n                c += 1\r\n                p2 = p2.next\r\n            else:\r\n                k = k%c\r\n                i = -1\r\n            i +=1\r\n        while p2.next:\r\n            p2 = p2.next\r\n            p1 = p1.next\r\n        if p1.next: sav = p1.next\r\n        else: return head\r\n        p1.next = None\r\n        p2.next = head\r\n        return sav\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842438753","body":"### 思路\r\n想了很久还是不会，看了题解的迭代，跟着题解写的，先打卡，接着继续学习链表\r\n\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n    if not head or not head.next: \r\n        return head\r\n    ans = ListNode()\r\n    ans.next = head.next\r\n    pre = ans\r\n    while head and head.next:\r\n        next = head.next\r\n        n_next = next.next\r\n        next.next = head\r\n        pre.next = next\r\n        head.next = n_next\r\n        pre = head\r\n        head = n_next\r\n    return ans.next\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843292927","body":"### 思路\r\n链表不会，看了题解，学着写的\r\n### 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return head\r\n        slow = head\r\n        fast = head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n        node = TreeNode(slow.val)\r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843710769","body":"### 思路\r\n双指针\r\nAB同时开始，遍历完第一遍没找到，回到另一个链表的head。\r\n如果存在intersection，两遍之内肯定会找到\r\n如果不存在，给个count计数，两遍走完，直接跳出循环\r\n\r\n### 代码python3\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b, c = headA, headB, 0  #c = count\r\n        while a != b:\r\n            if a and a.next: \r\n                a = a.next\r\n            else:\r\n                a = headB\r\n                c += 1\r\n            if b and b.next:\r\n                b = b.next\r\n            else:\r\n                b = headA\r\n                c += 1\r\n            if c > 2: return\r\n        return a\r\n```\r\n\r\n### 复杂度\r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845244650","body":"### 思路\r\n这是一段关于a,b,c三指针的爱恨情仇故事。。。\r\nab分别为快慢指针，故事也是从他们开始说起\r\nab如果没相遇，说明链表没环，都没相遇就别提相爱了\r\nab相遇，说明有环，那么ab的爱也许有希望。\r\n但只可惜落花有意，流水无情。。。\r\nb对a不太感兴趣，b决定继续往前走，看能不能遇到更合适的比如c\r\n然而a却很痴情选择在原地等b，哎。。。\r\nb在环内跑一圈（再次遇见a说明跑了一圈），如果遇见了c，直接输出c\r\n如果b在环内跑一圈发现都没遇见c，那么c就会往下走一步，b再绕一圈，再看能不能遇见c\r\n一直这个循环。。。\r\nc每往下走一步，b就要在环内绕一圈(b不会是舔狗吧？这么辛苦)，直到bc相遇，相遇点就是环入口\r\n\r\nNote:\r\n不推荐这个思路，一是故事太虐心，a在等b，b却在找寻c。。。\r\n二是我试过了，能跑通但是运行速度太慢，我再想想其他的思路，拜拜\r\n\r\n\r\n\r\n### 代码Python3\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        a = b = c = head\r\n        while a and b and b.next:\r\n            a = a.next\r\n            b = b.next.next\r\n            if a == b: \r\n                if c == b: return c\r\n                while c != b:\r\n                    while b.next != a:\r\n                        b = b.next\r\n                        if c == b: return c\r\n                    b = b.next\r\n                    c = c.next\r\n                return c   \r\n        return None\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846058384","body":"### 思路\r\nhash，双链表\r\n不会写，看了别人的解法，跟着学的，还在继续学习中\r\n源代码地址： https://www.cnblogs.com/yiluolion/p/12960840.html\r\n\r\n```\r\nclass Node(object):\r\n    def __init__(self, key = 0, value = 0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n        \r\nclass doublelinkedlist(object):\r\n    def __init__(self):\r\n        self.head = Node(0,0)\r\n        self.tail = Node(0,0)\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.size = 0\r\n    \r\n    def add_to_head(self.node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n        self.size += 1\r\n    \r\n    def remove_node(self,node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        slef.size -=1\r\n        \r\n    def remove_from_tail(self):\r\n        if self.size == 0:\r\n            return None\r\n        node = self.tail.prev\r\n        self.remove_node(node)\r\n        return node\r\n    \r\n    def get_size(self):\r\n        return self.size\r\n    \r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashmap = {}\r\n        self.cache = doublelinkedlist()\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.hashmap:\r\n            return -1\r\n        value = self.hashmap[key].value\r\n        self.put(key.value)\r\n        return value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        node = Node(key.value)\r\n        if key in self.hashmap:\r\n            self.cache.remove_node(self.hashmap[key])\r\n            self.cache.add_to_head(node)\r\n            self.hashmap[key] = node\r\n        else:\r\n            if self.capacity == self.cache.get_size():\r\n                tail = self.cache.remove_from_tail()\r\n                self.hashmap.pop(tail.key)\r\n            self.cache.add_to_head(node)\r\n            self.hashmap[key] = node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846343691","body":"### 思路\r\n递归，深度\r\n### 代码py3\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0  \r\n        else:\r\n            left = self.maxDepth(root.left)\r\n            right = self.maxDepth(root.right)\r\n            return max(left,right) + 1\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846493859","body":"### 思路\r\n最基本的递归\r\n\r\n### 代码py3\r\n```\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if p == None and q == None: return True\r\n        if p == None and q != None: return False\r\n        if p != None and q == None: return False\r\n        if p.val != q.val: return False\r\n        return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right) \r\n```\r\n\r\n### 复杂度\r\n时间：O(n)，节点数\r\n空间：O(n)，树深度或高度\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jennny06":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836864849","body":"一开始用了一个一个加的方法，然后在用 divmod 做，但是发现这样的速度很慢。学习了一下评论里的码，发现python 其实一行code 就可以搞定：先把str 转成int， 然后加减，再转成str：\r\n`return map(int,str(int(''.join(map(str,num))) + k))`"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838731551","body":"### 思路\r\n先找到index，然后一个一个比较\r\n\r\n```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        ind = [i for i,e in enumerate(s) if e == c ]\r\n        ans = []\r\n        \r\n        for i in range(len(s)):\r\n            minn = 'inf'\r\n            for j in ind:\r\n                dist = abs(i-j)\r\n                if minn > dist:\r\n                    minn = dist\r\n            ans.append(minn)\r\n                \r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：`O(n^2)`"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839872173","body":"## Code in Python\r\n\r\n`class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.s = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.s) < self.maxSize:\r\n            self.s.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.s) == 0:\r\n            return -1\r\n        else:\r\n            ele = self.s.pop()\r\n            return ele\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        \r\n        if len(self.s) <= k:\r\n            self.s = [i+val for i in self.s]\r\n        else:\r\n            self.s = [i+val for i in self.s[0:k]] + self.s[k:]`\r\n\r\n## 复杂度\r\n- 时间：`O(n)`\r\n- 空间：`O(n)`\r\n\r\n## 其他\r\n没有看懂python的最快解，不知道这个 `self.inc` 到底是干嘛用的。先来打卡，让我再来研究一下"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840587215","body":"## Code in Python\r\n\r\n\r\n`class Solution(object):\r\n    def decodeString(self, s):        \r\n        out = ''\r\n        stack = []\r\n        num = ''\r\n        \r\n        for c in range(len(s)):\r\n            if s[c].isdigit():\r\n                num += s[c]\r\n            elif s[c] == '[':\r\n                stack.append((out, int(num)));\r\n                out,num = \"\", \"\"\r\n            elif s[c] == ']':\r\n                top = stack.pop()\r\n                out = top[0] + out * top[1]\r\n            else: \r\n                out += s[c]\r\n          \r\n        return out`\r\n\r\n## 复杂度\r\n- 时间: `O (n)`\r\n- 空间: `O(n)`\r\n\r\n## 思路\r\n先从头往后，遇到数字先存成string，然后遇到`[` 之后，把现在存在的output 和 数字存起来。注意要把output reset 成null，这样可以遇到后面的括号内的内容，先把里面括号的内容写出来，再加上现在有的。遇到`]`后，把最上面的output 和 数字取出，然后用output + 数字*最新的括号内的内容。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841251826","body":"## Code in Python\r\n\r\n`class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        \r\n        return self.s1.append(x);\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        if not self.s2:\r\n            while len(self.s1) != 0:\r\n                self.s2.append(self.s1.pop())\r\n        \r\n        return  self.s2.pop()\r\n        \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            return self.s1[0]\r\n        \r\n        return self.s2[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.s1)+len(self.s2) == 0:\r\n            return True\r\n        else:\r\n            return False`\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间:  O(n)\r\n\r\n##思路\r\n用一个list就可以写出来。用一个stack做input，用另一个stack做output"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683541","body":"##  Code in Python\r\n\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n     ans = 1\r\n        max_ = arr[0]\r\n        mins = [arr[-1]] * len(arr)\r\n        \r\n        for i in range(len(arr)-2,-1,-1):\r\n            mins[i] = min(mins[i+1],arr[i])\r\n            \r\n        for i in range(1,len(arr),1):\r\n            if max_ <= mins[i]:\r\n                ans+=1\r\n            max_ = max(max_, arr[i])\r\n\r\n```\r\n\r\n## 复杂度\r\n- 时间: O (n)\r\n- 空间: O (n)\r\n\r\n## 思路\r\n看了youtube上的解法。。"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842435352","body":"## Code in Python\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n\r\n        if not head or not head.next:\r\n            return head\r\n\r\n        \r\n        first = head\r\n        second = head.next\r\n        \r\n        first.next = self.swapPairs(second.next)\r\n        second.next = first\r\n        \r\n        return second\r\n```\r\n\r\n## 思路\r\n利用recursion，每两个node 之间进行转换，first --> second.next, second --> first"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844238163","body":"## Code in Python \r\n\r\n``` python \r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        \r\n        nodes_in_B = set()\r\n\r\n        while headB is not None:\r\n            nodes_in_B.add(headB)\r\n            headB = headB.next\r\n\r\n        while headA is not None:\r\n            if headA in nodes_in_B:\r\n                return headA\r\n            headA = headA.next\r\n            \r\n        return None\r\n```\r\n\r\n\r\n## 复杂度\r\n- 时间：O(n+m)\r\n- 空间：O(n)\r\n\r\n## 注意\r\n不是看value，是看指针指向的node "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845242845","body":"## Code in Python\r\n\r\n``` python\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        \r\n        if not head or not head.next: \r\n            return \r\n        \r\n        nodes = set()\r\n        \r\n        while head.next: \r\n            if head in nodes:\r\n                return head\r\n            else:\r\n                nodes.add(head)\r\n            head = head.next\r\n        \r\n```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O(n)\r\n\r\n## 记录\r\n\r\n`set ` 查找在不在是`O(1)`， `list` 是`O(n)`！ 所以不用return index的话，直接用`set`！"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846058581","body":"## Code in Python \r\n\r\n``` python \r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.dict = collections.OrderedDict()\r\n        self.capacity = capacity   \r\n        \r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        if key not in self.dict:\r\n            return -1\r\n        \r\n        val = self.dict.pop(key)\r\n        self.dict[key] = val\r\n        \r\n        return val        \r\n\r\n        \r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        \r\n        if key in self.dict:    \r\n            self.dict.pop(key)\r\n        else:\r\n            if len(self.dict) == self.capacity:\r\n                del self.dict[next(iter(self.dict))]   \r\n        self.dict[key] = value\r\n        \r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n\r\n## 思路\r\n通过`ordereddict` 把insert的顺序保留，第一个被用到的就是需要改的"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846337692","body":"## Code in Python\r\n\r\n``` python\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        if not root:\r\n            return 0\r\n        \r\n        left = self.maxDepth (root.left) + 1\r\n        \r\n        right = self.maxDepth(root.right) + 1\r\n        \r\n        return max(left,right)\r\n ```\r\n\r\n## 复杂度\r\n- 时间：O(n)\r\n- 空间：O()\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sun-unc":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866524","body":"var addToArrayForm = function (num, k) {\r\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\r\n};"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838373077","body":"    var shortestToChar = function(s, c) {\r\n      let arr = s.split('')\r\n      let answer = []\r\n      for(let i = 0; i < arr.length; i++) {\r\n        if(arr[i] == c) {\r\n          answer.push(0)\r\n          continue\r\n        }\r\n        let arr1 = arr.slice(0, i).reverse()\r\n        let arr2 = arr.slice(i+1, arr.length)\r\n        let leftIndex = arr1.indexOf(c)\r\n        let rightIndex = arr2.indexOf(c)\r\n        if (leftIndex === -1) {\r\n          answer.push(rightIndex + 1)\r\n        } else if(rightIndex === -1) {\r\n          answer.push(leftIndex + 1)\r\n        } else {\r\n          leftIndex <= rightIndex ? answer.push(leftIndex + 1) : answer.push(rightIndex + 1)\r\n        }\r\n      }\r\n      console.log(answer);\r\n      // return answer\r\n    };"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Rainjoy66":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836866671","body":"```\r\ndef addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for nu in num:\r\n            res.append(str(nu))\r\n        string = \"\".join(res)\r\n        ans = int(string) + k\r\n        anss = list(str(ans))\r\n        dd = []\r\n        for ansss in anss:\r\n            dd.append(int(ansss))\r\n        return dd\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838734678","body":"### 思路：\r\n正反遍历，然后取最小值\r\n### 代码\r\n```\r\ndef function(self, s, c):\r\n        res = []\r\n        t = len(s)\r\n        for i in s:\r\n            t=0 if i==c else t+1\r\n            res.append(t)\r\n        for idx,i in enumerate(s[::-1]):\r\n            t = 0 if i==c else t+1\r\n            res[-(idx+1)] = min(t,res[-(idx+1)])\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839883645","body":"### 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.delta = []\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.delta.append(0)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.len:\r\n            return -1\r\n        self.len -= 1\r\n        a = self.stack.pop()\r\n        d = self.delta.pop()\r\n        if self.len:\r\n            self.delta[-1] += d\r\n        return a + d\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.len:\r\n            return\r\n        if self.len < k:\r\n            self.delta[-1] += val\r\n        else:\r\n            self.delta[k - 1] += val\r\n```\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840619992","body":"### 代码\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841313007","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        #stack1是输入栈\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #stack2是输出栈\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.stack1 and not self.stack2\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841677672","body":"### 思路\r\n维护一个单调栈，因为最后需要的是一个单调递增的数组，所以每一块的最大值应该是单调递增的。对于新进来一个数据，如果大于栈顶的最大值，直接放入栈中，作为新的块；如果小于栈顶的最大值，向之前的合并，但需要保留上一个块中的最大值。\r\n### 代码\r\n```\r\ndef maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841835044","body":"### 思路\r\n模拟链表，先统计出链表的长度，然后算出向右移动几步，其实就是倒序n - k%n -1作为开头\r\n### 代码\r\n```\r\ndef rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n\r\n        old_tail = head\r\n        n = 1\r\n        while old_tail.next:\r\n            old_tail = old_tail.next\r\n            n += 1\r\n        old_tail.next =head\r\n        #倒序就是 n - k%n\r\n        # new_tail是n - k%n -1\r\n        new_tail = head\r\n        for i in range(n - k%n-1):\r\n            new_tail = new_tail.next #这里错了\r\n        new_head = new_tail.next \r\n        new_tail.next = None\r\n        return new_head\r\n```\r\n### 复杂度分析\r\n时间复杂度：O( N )\r\n空间复杂度：O( 1 )\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842408776","body":"### 思路\r\n使用递归\r\n### 代码\r\n```\r\ndef swapPairs(self, head: ListNode) -> ListNode:\r\n        if not (head and head.next):\r\n\t\treturn head\r\n\t# 假设链表是 1->2->3->4\r\n\t# 这句就先保存节点2\r\n\ttmp = head.next\r\n\t# 继续递归，处理节点3->4\r\n\t# 当递归结束返回后，就变成了4->3\r\n\t# 于是head节点就指向了4，变成1->4->3\r\n\thead.next = self.swapPairs(tmp.next)\r\n\t# 将2节点指向1\r\n\ttmp.next = head\r\n\treturn tmp\r\n\r\n```\r\n复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843289546","body":"### 思路\r\n利用快慢指针找到中点，以中点为根结点，递归构造左右子树\r\n### 代码\r\n```\r\ndef sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def findmid(head, tail):\r\n            slow = head\r\n            fast = head\r\n            while fast != tail and fast.next!= tail :\r\n                slow = slow.next\r\n                fast = fast.next.next\r\n            return slow\r\n        \r\n        def helper(head, tail):\r\n            if  head == tail: return \r\n            node = findmid(head, tail)\r\n            root = TreeNode(node.val)\r\n            root.left = helper(head, node)\r\n            root.right = helper(node.next, tail)\r\n            return root\r\n            \r\n        return helper(head, None)\r\n```\r\n### 复杂度\r\n时间复杂度：O( nlogn )\r\n空间复杂度：O( logn )"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844240130","body":"### 思路\r\n两个指针分别从两头开始走，一头走完接另一头，一直到两个指针相遇为止\r\n### 代码\r\n```\r\ndef getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        curA, curB = headA, headB\r\n        while curA != curB:\r\n            curA = curA.next if curA else headB\r\n            curB = curB.next if curB else headA\r\n        return curA \r\n```\r\n### 复杂度\r\n时间复杂度：O(a+b)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845244218","body":"### 思路\r\n总结关键点：\r\n1.第一次相遇，slow = nb\r\n2.a+nb = 入口点\r\n3.slow再走a = 入口 = head走到入口 = a\r\n4.由3得出，起始距离入口 = 第一次相遇位置 + a\r\n感觉就是数学公式推导+逻辑结合的一道题\r\n\r\n### 代码\r\n```\r\ndef detectCycle(self, head: ListNode) -> ListNode:\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next):\r\n                return None\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n```\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846016990","body":"### 代码\r\n```\r\nclass LRUCache(collections.OrderedDict):\r\n\r\n    def __init__(self, capacity: int):\r\n        super().__init__()\r\n        self.capacity = capacity\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self:\r\n            return -1\r\n        self.move_to_end(key)\r\n        return self[key]\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self:\r\n            self.move_to_end(key)\r\n        self[key] = value\r\n        if len(self) > self.capacity:\r\n            self.popitem(last=False)\r\n```\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846422858","body":"### 思路\r\n使用递归\r\n### 代码\r\n```\r\ndef maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        \r\n        left_height = self.maxDepth(root.left)\r\n        right_height = self.maxDepth(root.right)\r\n        return max(left_height, right_height) + 1\r\n```\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuo0314":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836867704","body":"#Logic: convert list to str, then to int; add 2 int to get sum; convert int to str; convert str to list\r\n#Code: Python\r\n\r\n```\r\ndef addToArrayForm(self, num,k):\r\n    num_str = \"\"\r\n    for i in num:\r\n        num_str += str(i)\r\n    num_sum = int(num_str)+k\r\n    num_lst = [int(i) for i in str(num_sum)]\r\n    return num_lst\r\n```\r\n\r\n#Complexity: Time: O(n), Space: O(n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838701859","body":"\"\"\"Logic: iterate through the str, if the character is c, put its position in str in a new list1. After for loop, list1 will\r\n      have all position in str that's c;\r\n      iterate through the str, if the character is c, put 0 in the return list; if not, calculate the absolute value between\r\n      this index and each index in list 1, find the min and put it in the return list\r\n\"\"\"\r\n#Code: Python\r\n```\r\ndef shortestToChar(s, c):\r\n    lst = []\r\n    res_lst=[]\r\n    for i in range(len(s)):\r\n        if s[i] == c:\r\n            lst.append(i)\r\n    for j in range(len(s)):\r\n        if s[j]==c:\r\n            res_lst.append(0)\r\n        else:\r\n            min_dis = len(s)\r\n            for i in lst:\r\n                if abs(i-j) < min_dis:\r\n                    min_dis = abs(i-j)\r\n            res_lst.append(min_dis)\r\n    return res_lst\r\n```\r\n#Complexity: Time: O(n^2), Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839421234","body":"#Logic: initialize an empty list and declare its max size.\r\n#Code: Python\r\n```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.maxSize> len(self.stack):\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self)-> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k:int, val:int) -> None:\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i] += val\r\n```\r\n#Complexity: Time: push() O(1), pop() O(1), increment() O(min(k,len(stack)))\r\n#space: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840298450","body":"#第一次做不太会，参考了题解算法默写了一遍\r\n#Logic: Use of stack; Iterate through string, if character is \"]\" iterate backwards， add character to result string\r\n#until finding \"[\"; Then continue iterating backwards to find numeric char until non-numeric, \r\n#and update result string by repeating itself corresponding times. Join all char in stack to a string and return it\r\n#Code: Python\r\n```\r\ndef decodeString(self, s:str) -> str:\r\n    stack = []\r\n    #res_str = \"\"\r\n    for c in s:\r\n        if c ==\"]\":\r\n            res_str = \"\"\r\n            res_cnt = \"\"\r\n            while stack and stack[-1]!=\"[\":\r\n                res_str = stack.pop() + res_str\r\n            stack.pop()\r\n            while stack and stack[-1].isnumeric():\r\n                res_cnt = stack.pop() + res_cnt\r\n            res_str=res_str*int(res_cnt)\r\n            stack.append(res_str)        \r\n        else:\r\n            stack.append(c)\r\n    return \"\".join(stack)\r\n```\r\n\r\n#Complexity: Time: O(N), N is length of result string\r\n#space: O(N), N is length of result string"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841325358","body":"#Logic: Use two stack\r\n#Code:Python\r\n```\r\nclass MyQueue(object):\r\n```\r\n\r\n    def __init__(self):\r\n        self.stack=[]\r\n        self.helper_stack = []\r\n\r\n\r\n    def push(self, x:int) -> None:\r\n        return self.stack.append()\r\n\r\n\r\n    def pop(self) -> int :\r\n        if not self.helper_stack:\r\n            while self.stack:\r\n                self.helper_stack.append(self.stack.pop())\r\n        self.helper_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.helper_stack:\r\n            return self.stack[0]\r\n        else:\r\n            self.helper_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack and not self.helper_stack\r\n```\r\n```\r\n#Complexity: Time: O(1), pop() O(N)\r\n#space: O(N), N is length of result string"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604407","body":"No clue. Checked solution and used monotonic stack.\r\n#Logic：max of previous block < min of next block.\r\n#Code: Python\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A:[int]) -> int:\r\n        stack = []\r\n        for a in A:\r\n            if stack and stack[-1]>a:\r\n                curr_max = stack[-1]\r\n                while stack and stack[-1]>a: stack.pop()\r\n                stack.append(curr_max)\r\n            else:\r\n                stack.append(a)\r\n        return len(stack)\r\n```\r\n#Complexity: Time: O(N)\r\n#space: O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841774976","body":"#Logic: Edge case: linkedlist is empty, length of Linkedlist =1, k%length=0, then return original linkedlist directly;\r\n#Otherwise, set last node's next to the head of llist, find (length-k-1)th node set its next as new head,\r\n#set this node's next to null\r\n#Code: Python\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return head\r\n        length_llist = 1\r\n        temp = head\r\n        while temp.next:\r\n            temp = temp.next\r\n            length_llist+=1\r\n        if not k%length_llist:\r\n            return head\r\n        else:\r\n            temp.next = head\r\n            temp2 = head\r\n            for i in range(length_llist-k%length_llist-1):\r\n                temp2 = temp2.next\r\n            new_head = temp2.next\r\n            temp2.next=None\r\n        return new_head\r\n```\r\n#Complexity: Time: O(N)\r\n#space: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842432077","body":"\"\"\"\r\nLogic: Base case: if head is none or only having one node, return head directly; Otherwise, using recursion to firstly set a new_head, secondly set current head's next to the new_head returned by next recursion, thirdly set new_head's next to current head. Finally return new_head.\r\nCode: Python\r\n\"\"\"\r\n```\r\nclass Solution(object):\r\n    def swapPairs(self, head:ListNode)->ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        new_head=head.next\r\n        head.next = self.swapPairs(new_head.next)\r\n        new_head.next=head\r\n        return new_head\r\n```\r\n\"\"\"\r\nComplexity: time is O(N), space is O(1)\r\n\"\"\""},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843290946","body":"\"\"\"\r\nNot very familiar with tree knowledge, checked solution to get my answer below.\r\nLogic: Using two pointer technique. First, set two pointers both start from head (left) of linkedlist, let fast pointer go right two nodes while slow pointer go for one node in each step, until fast pointer reach the last node or the end of the linkedlist. Second, slow pointer is at the middle node now, which will be set to the node of the tree. Third, use recursion to set node.left and node.right in the same way as first step, return node in each recursion.\r\nCode: Python\r\nComplexity: Time is O(nlogn), space is O(logn)\r\n\"\"\"\r\n```\r\nclass Solution(object):\r\n    def sortedListToBST(self, head : ListNode) -> TreeNode:\r\n        #if Linkedlist is empty or null, return it directly\r\n        if not head:\r\n            return head\r\n        #Otherwise set pre as a helper pointer to point to the last node of first half of linkedlist, set both slow and fast pointer start from head\r\n        pre, slow, fast = None, head, head\r\n        #Till fast or fast.next reach the end of the linkedlist\r\n        while fast and fast.next:\r\n            #move fast pointer right for two nodes, slow pointer for one node\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        #if there is more than 1 node in current part of linkedlist, break the linkedlist by pre\r\n        if pre:\r\n            pre.next = None\r\n        #set the node pointed by slow pointer as treenode\r\n        node = TreeNode(slow.val)\r\n        #if only one node left in current part, return this node directly\r\n        if slow == fast:\r\n            return node\r\n        #use recursion to set left node and right node \r\n        node.left = self.sortedListToBST(head)\r\n        node.right = self.sortedListToBST(slow.next)\r\n        return node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844214892","body":"\"\"\"\r\n:type head1, head1: ListNode\r\n:rtype: ListNode\r\n\r\nLogic: Using hashing. Traverse the first linkedlist and store each node in a hash table, then traverse the second linkedlist and find whether node address present in the hash table. If yes return the intersection node, else return none.\r\n\r\nCode:Python\r\nComplexity: time is O(M+N), M,N is length of list. Space is O(M).\r\n\"\"\"\r\n```\r\nclass Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        node_set = set()\r\n        while headA:\r\n            node_set.add(headA)\r\n            headA=headA.next\r\n        while headB:\r\n            if headB in node_set:\r\n                return headB\r\n            headB=headB.next\r\n        return None\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845203415","body":"\"\"\"\r\n:type head: ListNode\r\n:rtype: ListNode\r\nLogic:Use hash table. Traverse through each node of the linkedlist, if it's in node_set, meaning that it's a repeated node, which is the start of the cycle. If it's not in node_set, add it to node_set and go to next node. After traverse all nodes, if no node was returned, there is no cycle in the list, return None.\r\nCode:Python\r\nComplexity: time is O(N), N is length of list. Space is O(N).\r\n\"\"\"\r\n\r\n```\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        \r\n        node_set = set()\r\n        while head:\r\n            if head in node_set:\r\n                return head\r\n            else:\r\n                node_set.add(head)\r\n                head = head.next\r\n        return None\r\n```\r\n\r\n\"\"\"\r\nAlternative solution-\r\nLogic: Using two pointers. First, two pointers both start from head node, fast one moves for 2 nodes in each step, whereas slow one moves for 1 node. At the first time fast one and slow one meet, set a new pointer start from head and move for 1 node in each step. Next time when slow pointer and this new pointer meet, the meeting node is the start of the cycle. Return this node. Otherwise there is no cycle in the list, return None.\r\nCode:Python\r\nComplexity: time is O(N), N is length of list. Space is O(1).\r\n\"\"\"\r\n```\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        curr=None\r\n        while fast and fast.next:\r\n            fast=fast.next.next\r\n            slow = slow.next\r\n            if fast==slow:\r\n                curr = head\r\n                break\r\n        if not curr:\r\n            return None\r\n        while curr!=slow:\r\n            curr=curr.next\r\n            slow=slow.next\r\n        return curr\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846033435","body":"\"\"\"\r\nLogic: Learning the logic from pkuphy. Using OrderedDict to store, set the dictionary's capacity. If dict is full, pop the first pair, add new pair at the end. To get a value, check whether key is in dict, if not return -1, if in, return the value.\r\nCode:Python\r\nComplexity: time is O(1), space is O(N).\r\n\"\"\"\r\n\r\n```\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.capacity = capacity\r\n        self.cache = OrderedDict()\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        result = self.cache.get(key)\r\n        if result is not None:\r\n            self.cache.move_to_end(key)\r\n            return result\r\n        return -1\r\n\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key not in self.cache.keys() and len(self.cache)==self.capacity:\r\n            self.cache.popitem(last = False)\r\n        self.cache[key] = value\r\n        self.cache.move_to_end(key)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846423858","body":"\"\"\"\r\n:type root: TreeNode\r\n:rtype: int\r\nLogic: DFS,Recursion. Base condition: Treenode is NULL, return 0 as its height. Recursion implementation: height on current node(1) plus the max height of following left/right node\r\nCode:Python\r\nComplexity: time is O(N), N is number of nodes; space is O(H), H is height of the tree.\r\n\"\"\"\r\n```\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        if not root:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\n'''\r\nAlternative solution: BFS, use level order traversal to find height. Traverse level by level, whenever move down to a level, increment height by 1. At each level, count number of nodes and stop when current level has no node.\r\n'''\r\n```\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        if root is None:\r\n            return 0\r\n        q=[]\r\n        q.append(root)\r\n        heightCurr=0\r\n        while q:\r\n            heightCurr+=1\r\n            nodeCount=len(q)\r\n            while nodeCount>0:\r\n                node = q.pop(0)\r\n                nodeCount-=1\r\n                if node.left: q.append(node.left)\r\n                if node.right: q.append(node.right)\r\n        return heightCurr\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangjiahao106":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836868252","body":"## 思路\r\n\r\n遍历数组num，用k乘当前位的10的幂次，累加结果\r\n代码\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num = list(reversed(num))\r\n        for i in range(0, len(num)):\r\n            k += num[i]\r\n            num[i] = k %10\r\n            k = k // 10\r\n        \r\n        while k > 0:\r\n            num.append(k%10)\r\n            k  = k // 10\r\n        return list(reversed(num))\r\n```\r\n## 复杂度\r\n\r\n时间复杂度O(n) 空间复杂度O(1)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838740235","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = 0 \r\n        r = 0\r\n\r\n        res = [1<<31-1 for i in s] \r\n\r\n        while r < len(s):\r\n            if s[r] == c:\r\n               break\r\n            r += 1\r\n\r\n        for l in range(0, len(s)):\r\n            res[l] = r - l \r\n            if l ==r:\r\n                while r < len(s)-1:\r\n                    r += 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    break\r\n        r = len(s) - 1\r\n        while r >=0:\r\n            if s[r] == c:\r\n               break\r\n            r -= 1\r\n    \r\n        for l in range(len(s)-1, -1, -1):\r\n            res[l] = min(res[l],  l-r) \r\n            if l <= r:\r\n                while r > 0:\r\n                    r -= 1\r\n                    if s[r] == c:\r\n                        break\r\n                if s[r] != c:\r\n                    return res \r\n        return res \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839865783","body":"## 思路\r\n数组模拟栈\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.vals = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.vals) < self.maxSize:\r\n            self.vals.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.vals) == 0:\r\n            return -1\r\n        return self.vals.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k,len(self.vals))):\r\n            self.vals[i] += val\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656306","body":"## 思路\r\n使用栈处理括号\r\n## 代码\r\n``` python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        int_stack = []\r\n        stack = []\r\n        i = 0\r\n        while i < len(s):\r\n            if '0' <= s[i] <= '9':\r\n                l = i\r\n                while '0' <=  s[i] <= '9':\r\n                    i += 1\r\n                int_stack.append(int(s[l:i]))\r\n            if s[i] == ']':\r\n                tmp = \"\"\r\n                while True:\r\n                    c = stack.pop()\r\n                    if c == '[':\r\n                        break\r\n                    tmp = c + tmp\r\n                stack.append(tmp * int_stack.pop())\r\n            else:\r\n                stack.append(s[i])\r\n\r\n            i += 1\r\n\r\n        return \"\".join(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841319818","body":"# 思路\r\n 用两个栈 模拟一个队列\r\n\r\n## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.a.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.b) > 0:\r\n            return self.b.pop()\r\n        while len(self.a) > 0:\r\n            self.b.append(self.a.pop())\r\n        return self.b.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.b) > 0:\r\n            return self.b[-1]\r\n        else:\r\n            return self.a[0]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.a) == 0 and len(self.b) == 0\r\n\r\n\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842414774","body":"## 思路\r\n    使用递归简化代码\r\n## 代码\r\n``` python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if head == None or head.next == None:\r\n            return head\r\n\r\n        next = head.next\r\n        head.next = self.swapPairs(next.next)\r\n        next.next = head # 需要放在递归后面执行 否则会死循环\r\n\r\n        return next\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844185078","body":"## 思路 \r\n\r\n快慢指针\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b  = headA, headB\r\n        while a and b:\r\n            a = a.next\r\n            b = b.next\r\n\r\n        while a:\r\n            headA = headA.next\r\n            a = a.next\r\n        while b:\r\n            headB = headB.next\r\n            b = b.next\r\n        while headA:\r\n            if headA == headB:\r\n                return headA\r\n            headA, headB = headA.next, headB.next\r\n        return None\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844766196","body":"## 思路\r\n快慢指针\r\n链表长度= a + b \r\nf = 2*s\r\nf = s + n * b \r\nf = n*b \r\n入口 = a + n*b\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        while True:\r\n            if fast is None or fast.next is None:\r\n                return None\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n\r\n        slow = head\r\n        while fast != slow:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bmxbmx3":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836878093","body":"### 思路\r\n\r\n初步思路：\r\n1. 先排除异常情况\r\n2. 将数组变成对应数字，加上一个数后，将相加结果变回数组\r\n\r\n### 代码\r\n\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int] 待加数字的数组\r\n        :type k: int 所加的数字\r\n        :rtype: List[int] 加数字后的数组\r\n        \"\"\"\r\n\r\n        # 将num数组转换为对应的数字\r\n        sum = 0\r\n        length = len(num)\r\n        for i in range(len(num)):\r\n            sum += num[i]*10**(length-i-1)  # 逐位相加，比如[1,2]即1*10^1+2*10^0=12\r\n\r\n        sum += k  # 计算相加结果\r\n\r\n        # 将相加后的数字转换为对应的数组（从后往前逐位取数字）\r\n        result = []\r\n        while(sum):\r\n            result.append(sum % 10)\r\n            sum = sum//10  # 双斜杠（//）表示地板除，即先做除法（/），然后向下取整（floor）\r\n        result.reverse() # 结果数组倒序\r\n        return result\r\n\r\n\r\nnum = [9,9,9,9,9,9,9,9,9,9]\r\nk = 1\r\ns = Solution()\r\nresult = s.addToArrayForm(num, k)\r\nprint(result)\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838601737","body":"## 思路\r\n\r\n参考：\r\n- [821.字符的最短距离【4种解法、JS/Cpp/Py】](https://leetcode-cn.com/problems/shortest-distance-to-a-character/solution/821zi-fu-de-zui-duan-ju-chi-4chong-jie-fa-javascri/)\r\n\r\n思路1（中心扩展法）：\r\n1. 排除异常情况\r\n2. 从原字符串s中每个字符（中心位置i）出发，向两边同时扩展寻找字符c。最先寻找到的字符c，一定距离位置i上的字符最近\r\n思路2（以空间换时间）？\r\n思路3（双向遍历贪心法）？（时间复杂度最优）\r\n## 关键点\r\n\r\n- python数组初始化？（参考：https://www.pythontab.com/html/2020/pythonjichu_0102/1470.html）\r\n- python判断字符串自否为大小写字母？（参考：https://blog.csdn.net/nanhuaibeian/article/details/99472393）\r\n- 双向遍历贪心法？\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    \"\"\"\r\n    思路1\r\n    \"\"\"\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        length = len(s)\r\n\r\n        \"\"\"\r\n        排除异常\r\n        \"\"\"\r\n        # 数组长度异常\r\n        if(length < 1 or length > 10000):\r\n            print(\"数组s的长度应在1-10000之间！\")\r\n            return\r\n        # 小写字母异常\r\n        if(not (s.islower() and s.isalpha())):\r\n            print(\"数组s必须都是小写字母！\")\r\n            return\r\n        if(c not in s):\r\n            print(\"字符c不在数组s中！\")\r\n            return\r\n\r\n        result = [0]*length  # 初始化结果数组，存放数组s中每个字符到字符c的最近距离\r\n\r\n        for i in range(length):\r\n            # 如果遍历到字符c，则跳过（最近距离为0）\r\n            if s[i] == c:\r\n                continue\r\n\r\n            \"\"\"  \r\n            以当前位置i的字符为中心，向两边扩展寻找最近的字符c\r\n            \"\"\"\r\n            left = i  # 向左寻找，下标不断减小\r\n            right = i  # 向右寻找，下表不断增加\r\n            min_distance = 0  # 记录最近距离（到中心字符s[i]）\r\n            while(left >= 0 or right <= length-1):\r\n                # 向两边同时寻找，一旦找到字符c就停止寻找\r\n                if(s[left] == c):\r\n                    min_distance = i-left\r\n                    break\r\n                if(s[right] == c):\r\n                    min_distance = right-i\r\n                    break\r\n\r\n                \"\"\" \r\n                left（向左标志）左移，同理right（向右标志）右移\r\n                note:\r\n                left若为0，left-1变为-1,到下层循环时不满足外层循环条件left>=0,\r\n                但right却可能依然满足right<length的外层循环条件，这样导致下层循环依然可以执行，\r\n                但此时下层循环中left=-1，使得s[left]即s[-1]因找不到值而发生错误,\r\n                故在这里设置left>0的判断。\r\n                同理，为了保险起见，这里right<length-1。\r\n                \"\"\"\r\n                if(left > 0):\r\n                    left -= 1\r\n                if(right < length-1):\r\n                    right += 1\r\n\r\n            result[i] = min_distance  # 记录字符串s中，当前位置i的字符距字符c的最近距离\r\n\r\n        return result\r\n\r\n\r\ns = Solution()\r\nstr_s = \"1baab\"\r\nc = \"a\"\r\nresult = s.shortestToChar(str_s, c)\r\nprint(result)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$，n为S的长度，两层循环。\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839887431","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/solution/she-ji-yi-ge-zhi-chi-zeng-liang-cao-zuo-de-zhan-by/\r\n\r\n我们使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\r\n\r\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\r\n\r\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1−1。\r\n\r\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\r\n\r\n## 关键点\r\n\r\n-  对于栈前k个元素的增加操作\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int 栈的容量\r\n        \"\"\"\r\n\r\n        self.stack = [0]*maxSize  # 栈初始化\r\n        self.top = -1  # 栈顶指针\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n\r\n        # 防止溢出\r\n        length = len(self.stack)  # 获得栈的容量\r\n        if(self.top == length-1):\r\n            print(\"栈的容量已满，无法继续入栈元素！\")\r\n            return\r\n\r\n        # 入栈元素\r\n        self.top += 1\r\n        self.stack[self.top] = x\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        # 栈空不能出栈\r\n        if(self.pop == -1):\r\n            print(\"栈空无法继续出栈！\")\r\n            return -1\r\n\r\n        # 出栈元素\r\n        x = self.stack[self.top]\r\n        self.top -= 1\r\n        return x\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int \r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n\r\n        \"\"\"\r\n        \r\n        \"\"\"\r\n        # 栈顶指针self.top从0开始计数，所以self.top+1\r\n        min_incre_size = min(k, self.top+1)\r\n        for i in range(min_incre_size):\r\n            self.stack[i] += val\r\n\r\n\r\ns = CustomStack(3)\r\ns.push(1)\r\ns.push(2)\r\ns.pop()\r\ns.push(2)\r\ns.push(3)\r\ns.increment(5,100)\r\na=s.pop()\r\na=s.pop()\r\na=s.pop()\r\nprint(a,s.top)\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为O(1)，inc 操作的渐进时间复杂度为O(k)。\r\n- 空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为O(maxSize)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840644890","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\r\n1. 构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n- 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n- 当 c 为字母时，在 res 尾部添加 c；\r\n- 当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n2. 当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n- last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n- cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n返回字符串 res。\r\n\r\n## 关键点\r\n\r\n-  括号匹配\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度 O(N)O(N)，一次遍历s；\r\n- 空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如2[2[2[a]]]。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841330488","body":"## 思路\r\n\r\n将一个栈当作输入栈，用于压入 \\texttt{push}push 传入的数据；另一个栈当作输出栈，用于 \\texttt{pop}pop 和 \\texttt{peek}peek 操作。\r\n\r\n每次 \\texttt{pop}pop 或 \\texttt{peek}peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n## 关键点\r\n\r\n-  一个栈入队，另一个栈出队\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：push 和 empty 为 O(1)，pop 和 peek}为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\r\n\r\n- 空间复杂度：O(n)。其中 n是操作总数。对于有 n次 push 操作的情况，队列中会有 n个元素，故空间复杂度为 O(n)。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841682726","body":"## 思路\r\n\r\n贪心法则\r\n\r\n参考：https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/\r\n\r\n## 关键点\r\n\r\n-  每个块的最小值要大于前一个块中的最大值\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n复杂度分析：\r\n\r\n- 时间复杂度 O(N) ：遍历一遍 arrarr 为 O(N)，修正排序块最多遍历一遍 arr为 O(N)；\r\n- 空间复杂度 O(N)：极端情况下排序块数量等于数组长度，此时 stack占用线性大小额外空间。\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841822236","body":"## 思路\r\n参考：https://leetcode-cn.com/problems/rotate-list/\r\n\r\n将链表每个节点向右移动 kk 位置，相当于把链表的后面 k % len  个节点移到链表的最前面。（len 为 链表长度）\r\n\r\n所以本题的步骤：\r\n- 求链表长度；\r\n- 找出倒数第 k+1个节点；\r\n- 链表重整：将链表的倒数第 k+1个节点和倒数第 k个节点断开，并把后半部分拼接到链表的头部。\r\n\r\n## 关键点\r\n\r\n-  找出链表倒数第k+1个节点\r\n- 链表的断开与连接\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        if not head or not head.next: return head\r\n        # 求链表长度\r\n        _len = 0\r\n        cur = head\r\n        while cur:\r\n            _len += 1\r\n            cur = cur.next\r\n        # 对长度取模\r\n        k %= _len\r\n        if k == 0: return head\r\n        # 让 fast 先向后走 k 步\r\n        fast, slow = head, head\r\n        while k:\r\n            fast = fast.next\r\n            k -= 1\r\n        # 此时 slow 和 fast 之间的距离是 k；fast 指向第 k+1 个节点\r\n        # 当 fast.next 为空时，fast 指向链表最后一个节点，slow 指向倒数第 k + 1 个节点\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        # newHead 是倒数第 k 个节点，即新链表的头\r\n        newHead = slow.next\r\n        # 让倒数第 k + 1 个节点 和 倒数第 k 个节点断开\r\n        slow.next = None\r\n        # 让最后一个节点指向原始链表的头\r\n        fast.next = head\r\n        return newHead\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842308887","body":"## 思路\r\n\r\n先添加一个空头，再交换\r\n\r\n## 关键点\r\n\r\n-  链表后继结点的更改\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        thead = ListNode(-1)\r\n        thead.next = head\r\n        c = thead\r\n        while c.next and c.next.next:\r\n            a, b=c.next, c.next.next\r\n            c.next, a.next = b, b.next\r\n            b.next = a\r\n            c = c.next.next\r\n        return thead.next\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843383075","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/tu-jie-xiang-jiao-lian-biao-by-user7208t/\r\n\r\n如果两个链表相交，那么相交点之后的长度是相同的\r\n\r\n我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。\r\n为此，我们必须消除两个链表的长度差\r\n\r\n指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历\r\n如果 pA 到了末尾，则 pA = headB 继续遍历\r\n如果 pB 到了末尾，则 pB = headA 继续遍历\r\n比较长的链表指针指向较短链表head时，长度差就消除了\r\n如此，只需要将最短链表遍历两次即可找到位置\r\n\r\n## 关键点\r\n\r\n- 链表的遍历\r\n\r\n## 代码\r\n\r\n```java\r\n\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n    if (headA == null || headB == null) return null;\r\n    ListNode pA = headA, pB = headB;\r\n    while (pA != pB) {\r\n        pA = pA == null ? headB : pA.next;\r\n        pB = pB == null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845240933","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/\r\n\r\n这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等。\r\n\r\n## 关键点\r\n\r\n-  双指针法\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427324","body":"## 思路\r\n\r\n参考：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/solution/er-cha-shu-de-zui-da-shen-du-by-leetcode-solution/\r\n\r\n## 关键点\r\n\r\n-  深度优先遍历\r\n\r\n## 代码\r\n\r\n- 语言支持：Python\r\n\r\nPython Code:\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root):\r\n        if root is None: \r\n            return 0 \r\n        else: \r\n            left_height = self.maxDepth(root.left) \r\n            right_height = self.maxDepth(root.right) \r\n            return max(left_height, right_height) + 1 \r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(height)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DADAHUI":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882177","body":"\r\n## 题目地址(989. 数组形式的整数加法)\r\n\r\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\r\n\r\n## 题目描述\r\n```\r\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\r\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\r\n示例 1：\r\n输入：A = [1,2,0,0], K = 34\r\n输出：[1,2,3,4]\r\n解释：1200 + 34 = 1234\r\n示例 2：\r\n输入：A = [2,7,4], K = 181\r\n输出：[4,5,5]\r\n解释：274 + 181 = 455\r\n示例 3：\r\n输入：A = [2,1,5], K = 806\r\n输出：[1,0,2,1]\r\n解释：215 + 806 = 1021\r\n示例 4\r\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\r\n输出：[1,0,0,0,0,0,0,0,0,0,0]\r\n解释：9999999999 + 1 = 10000000000\r\n提示：\r\n1 <= A.length <= 10000\r\n0 <= A[i] <= 9\r\n0 <= K <= 10000\r\n如果 A.length > 1，那么 A[0] != 0\r\n`\r\n\r\n## 思路\r\nnum与k值逐位相加，大于9时进1，参与下一位运算\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) \r\n    {\r\n      vector <int> res;\r\n      for(int i=num.size()-1;i>=0;i--)\r\n      {\r\n          int sum=num[i]+k%10;\r\n          k/=10;\r\n          if(sum>9)\r\n          {\r\n              sum=sum%10;\r\n              k++;\r\n          }\r\n          res.push_back(sum);\r\n\r\n      }\r\n      for(;k>0;k/=10)\r\n      {\r\n          res.push_back(k%10);\r\n      }\r\n\r\n      reverse(res.begin(),res.end());\r\n      return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838588143","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 思路\r\n数组arr存储s中下标；s的每一个下标与每一个与和c相同的下标做差，取最小值 \r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n    vector <int> vec,answer;\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        if(s[i]==c) vec.push_back(i);\r\n    }\r\n    int arr[vec.size()];\r\n    \r\n    for(int i=0;i<s.size();i++)\r\n    {\r\n        for(int j=0;j<vec.size();j++)\r\n        {\r\n          arr[j]=abs(i-vec[j]);  \r\n        }\r\n        answer.push_back(*min_element(arr,arr+vec.size()));\r\n    }\r\n   return answer;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839870407","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 思路\r\nvector 实现栈。top记录栈顶；resize(n，elemen)分配内存空间（改变capacity），初始值element默认0，vector.size() 存储的元素（element）个数也变为n；\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector <int> s;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n    s.resize(maxSize);\r\n    top=-1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top!=s.size()-1)\r\n        { top++;\r\n          s[top]=x;\r\n          \r\n        }\r\n\r\n    }\r\n    \r\n    int pop() {\r\n        if(top==-1) return -1;\r\n        top--;\r\n        return s[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n         if(k>top+1) k=top+1;\r\n         for(int i=0;i<k;i++)\r\n         {\r\n             s[i]+=val;\r\n         }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(k)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841314180","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n\r\n## 思路\r\n栈1实现进入队列，栈1倒进栈2，栈顶为队列的开头\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack <int>stack1;\r\n    stack <int>stack2;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n    stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n     if(stack2.empty())\r\n     {\r\n         while(!stack1.empty())\r\n         {\r\n             stack2.push(stack1.top());\r\n             stack1.pop();\r\n         }\r\n     }\r\n     int ans=stack2.top();\r\n     stack2.pop();\r\n     return ans;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n     if(stack2.empty())\r\n     {\r\n         while(!stack1.empty())\r\n         {\r\n             stack2.push(stack1.top());\r\n             stack1.pop();\r\n         }\r\n     }\r\n     int ans=stack2.top();\r\n     \r\n     return ans;\r\n    \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n     if(stack1.empty()&&stack2.empty()) return true;//进栈及出栈都为空，队列为空\r\n     else return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841676832","body":"\r\n## 题目地址(768. 最多能完成排序的块 II)\r\n\r\nhttps://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/\r\n\r\n## 思路\r\n前一块的最大值要小于等于后一块的最小值，想到用单调栈解题\r\n当att[i]>=栈顶时，则将其压入栈；\r\narr[i]<栈顶时，先保存当前栈顶tmp作为块最大值，出栈，直到栈顶元素>=arr[i]，arr[i]与已出栈元素构成一个递增的块，其最小元素为arr[i]大于栈顶（上一块的最大值），最大值为tmp，再将tmp入栈；\r\n栈中保存的是区域最大值，元素个数即为可分的最多块。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> nums;\r\n    nums.push(arr[0]);\r\n    \r\n    for(int i=1;i<arr.size();++i)\r\n    {   \r\n        if(arr[i]>nums.top())\r\n        {\r\n            nums.push(arr[i]);\r\n        }\r\n        else \r\n        {   \r\n            int tmp=nums.top();\r\n            while(!nums.empty()&&arr[i]<nums.top())\r\n            {\r\n              nums.pop();\r\n            }\r\n            nums.push(tmp);\r\n        }\r\n    }\r\n    return nums.size();\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$   for循环\r\n- 空间复杂度：$O(n)$   \r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841823381","body":"\r\n## 题目地址(61. 旋转链表)\r\n\r\nhttps://leetcode-cn.com/problems/rotate-list/\r\n\r\n## 思路\r\n快慢指针\r\n先判断k=0，head为空，head->next为空的情况返回head\r\n获取链表长度n，当k为链表长度整数倍时，旋转后还是原链表\r\nk对n取余，快慢两个指针都从头指针开始，快指针先动，向右移动（k%n）次；然后快慢两个指针一起向右移动，知道快指针先到达链表尾部；此实慢指针->next为新的链表头，慢指针为新链表尾，快指针->next为原链表头；\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n    if (head == nullptr || head->next == nullptr || k == 0) {\r\n        return head;\r\n    }\r\n    int n = 0;\r\n    for (ListNode* node = head; node != nullptr; node = node->next) {\r\n        n++;\r\n    }\r\n\r\n    k %=n;\r\n    if (k == 0) {\r\n        return head;\r\n    }\r\n    ListNode *fast = head, *slow = head;\r\n    for (int i = 0; i < k; ++i) {\r\n        fast = fast->next;\r\n    } \r\n    while (fast->next != nullptr) {\r\n        fast = fast->next;\r\n        slow = slow->next;   \r\n    }        \r\n    fast->next = head; \r\n    head = slow->next; \r\n    slow->next = nullptr;\r\n    return head;\r\n}\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$ 遍历链表\r\n- 空间复杂度：$O(n)$ 链表空间\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842411696","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n\r\n## 思路\r\n建立虚拟节点，指向头指针；建立两个指针cur1,cur2，分别指向头节点及第二节点，*next；\r\n第一第二个节点反转，next保存了第三节点指针；将两个反转节点接入虚拟节点和next之间（穿针引线）；tmp=cur1,cur1=next,当cur1为空时break,cur2=cur1->next，迭代下去。\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n    if(head==nullptr||head->next==nullptr) return head;\r\n    ListNode *res= new ListNode(-1,head);\r\n    ListNode  *cur1=head,*cur2=head->next,*tmp=res,*next;\r\n    while(cur2)\r\n    {   \r\n        next = cur2->next;\r\n        tmp->next=cur2;\r\n        cur2->next=cur1;\r\n        cur1->next=next;\r\n        tmp=cur1;\r\n        cur1=next;\r\n        if(!cur1) break;\r\n        cur2=cur1->next;\r\n    }\r\n    \r\n    return res->next;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843242417","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 思路\r\n高度平衡二叉树的左右两个子叶的高度差不超过一，树的根节点则为链表的中间节点，链表长度为偶数时，中间两个节点之一\r\n快慢指针找到链表的中间节点：\r\n  1.slow->next,fast->next->next，注意循环结束条件（fast&&(fast->next)）；\r\n  2.记录前驱节点slow，将前驱节点与中间节点断开，中间节点左边是左子树的节点，右边为右子树节点；\r\n 3.递归\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n    if(head==nullptr) return nullptr;\r\n    if(head->next==nullptr) return new TreeNode(head->val);\r\n    ListNode *fast=head,*slow=head,*tmp;\r\n    while(fast&&(fast->next))\r\n    {  tmp=slow;\r\n       slow=slow->next;\r\n       fast=fast->next->next;\r\n    }\r\n    tmp->next=nullptr;\r\n    TreeNode *root=new TreeNode(slow->val);\r\n    root->left=sortedListToBST(head);\r\n    root->right=sortedListToBST(slow->next);\r\n    return root;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n/2logn)$ 每次递归都会有遍历找到中间节点\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844160040","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 思路\r\n双指针\r\n创建两个指针pA,pB，初始化为两个链表的头节点，两个指针同时向后移，当pA运动到链表尾部时，重新定位到链表B的头节点，pB运动到尾部时重新定位到链表A，当pA=pB时，则为相交节点\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    ListNode *curA=headA,*curB=headB;\r\n    while(curA!=curB)\r\n    {   \r\n        if(curA==NULL)\r\n        {\r\n            curA=headB;\r\n        }else\r\n        {\r\n            curA=curA->next;\r\n        }\r\n        if(curB==NULL)\r\n        {\r\n            curB=headA;\r\n        }else\r\n        {\r\n            curB=curB->next;\r\n        }\r\n    }\r\n    return curA;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845130726","body":"\r\n## 题目地址(142. 环形链表 II)\r\nhttps://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n## 思路\r\n双指针\r\n建立快慢两个指针，初始化为链表头节点，快指针一次走两步，慢指针一次走一步，两个指针同时走，当两个指针第一次相遇，快指针重新指向链表头节点，快、慢指针都一次走一步，两个一次走，第二次相遇时则为环链表的入口。\r\n## 代码\r\n- 语言支持：C++\r\nC++ Code:\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n    if(head==NULL||head->next==NULL) return NULL ; \r\n    ListNode *fast=head,*slow=head;\r\n    do\r\n    {\r\n        if(fast !=NULL&&fast->next!=NULL)\r\n        {\r\n         fast =fast->next ->next ;\r\n        }else fast=NULL ;\r\n        slow =slow->next ;\r\n     } while (fast!=slow);\r\n     if(fast==NULL) return NULL ;\r\n     fast=head;\r\n     while (fast!=slow)    \r\n     {\r\n         fast=fast->next ;\r\n         slow =slow->next;\r\n     } \r\n     return  fast;\r\n   }\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n哈希表 \r\n遍历链表，如果哈希表中没有相同值，则记录进哈希表，如果有则返回节点；\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n     unordered_map<ListNode *,bool>  mymap;\r\n     while(head!=NULL)\r\n     {\r\n         if(mymap[head]) return head;\r\n         else mymap[head]=true;\r\n         head=head->next;\r\n     }\r\n     return NULL;\r\n    }\r\n};\r\n```\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846059886","body":"\r\n## 题目地址(146. LRU 缓存机制)\r\n\r\nhttps://leetcode-cn.com/problems/lru-cache/\r\n## 思路\r\n-没什么思路。参考的官方题解\r\n-哈希表查询对应key值，时间复杂度O(1)，插入删除数据利用双链表，时间复杂度O(1)  \r\nhttps://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/\r\n-\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nstruct DualNode\r\n{\r\n    int key;\r\n    int val;\r\n    DualNode *pre;\r\n    DualNode *next;\r\n    DualNode():key(0),val(0),pre(nullptr),next(nullptr){}\r\n    DualNode(int x,int y):\r\n    key(x),val(y),pre(nullptr),next(nullptr){}\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    unordered_map<int,DualNode*> map;\r\n   //建立虚拟头尾节点\r\n    DualNode *head;\r\n    DualNode *tail;\r\n    int cap,size=0;\r\n\r\n    LRUCache(int capacity) {\r\n    cap=capacity;\r\n    head=new DualNode();\r\n    tail=new DualNode();\r\n    head->next=tail;\r\n    tail->pre=head;\r\n    }\r\n    \r\n    int get(int key) {\r\n    if(!map[key]) return -1;\r\n    //通过哈希表返回key对应的节点，移动到头部\r\n    DualNode *node=map[key];\r\n    movetohead(node);\r\n    return node->val;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n    if(map[key]) \r\n    {   //如果key已经存在，通过哈希表定位，修改value值，移动到头部\r\n        DualNode *node=map[key];\r\n        node->val=value;\r\n        movetohead(node);\r\n    }\r\n     else\r\n     {  //如果不存在，新建节点，存入哈希表,添加至双向链表头部\r\n         DualNode *node=new DualNode(key,value);\r\n         map[key]=node;\r\n         addtohead(node);\r\n         ++size;\r\n         if(size>cap)\r\n         {  //如果超出容量，删除双向链表中的尾部节点，删除哈希表中的对应项\r\n             DualNode *remove=removeTail();\r\n             map.erase(remove->key);\r\n             delete remove;\r\n             size--;\r\n         }\r\n     }\r\n    }    \r\n\r\n    //在虚拟头后插入新节点\r\n    void addtohead(DualNode *node)\r\n    {   //记录下原来头节点的下一节点，留下联系方式，再插入新的节点\r\n        DualNode *next=head->next;\r\n        head->next=node;\r\n        node->pre=head;\r\n        next->pre=node;\r\n        node->next=next;\r\n    }\r\n\r\n    //删除节点\r\n    void removeNode(DualNode *node)\r\n    {  \r\n        //记录下要删除节点的前后节点，删除节点就是把一前一后两个节点连接在一起\r\n        DualNode *pre=node->pre,*next=node->next;\r\n        pre->next=next;\r\n        next->pre=pre;\r\n    }\r\n   \r\n //将节点移动到虚拟头节点后\r\n    void movetohead(DualNode *node)\r\n    {\r\n        removeNode(node);\r\n        addtohead(node);\r\n    }\r\n    DualNode *removeTail() \r\n    {\r\n        DualNode *node=tail->pre;\r\n        removeNode(node);\r\n        return node;\r\n    }  \r\n};\r\n```\r\n**复杂度分析**\r\n令 n 为数组长度。\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846414391","body":"\r\n## 题目地址(104. 二叉树的最大深度)\r\n\r\nhttps://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\r\n\r\n## 思路\r\n树最大深度是其左右子树的最大深度+1，树的左右子树最大深度又可以以同样的方法得到\r\n深度优先搜索，在搜索到空节点时终止\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n    if(root==NULL) return 0;\r\n    return max(maxDepth(root->left),maxDepth(root->right))+1;\r\n    }\r\n};\r\n```\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxlevel=0;\r\n    int maxDepth(TreeNode* root) {\r\n     if(root==0) return 0;\r\n     dfs(root,1);\r\n     return maxlevel;\r\n    }\r\n    void dfs(TreeNode *root,int level)\r\n    {\r\n        if (root==0) return; //深度优先搜索终止条件，遇到空节点\r\n        if(maxlevel<level) maxlevel=level; //保存最大深度\r\n        dfs(root->left,level+1);\r\n        dfs(root->right,level+1); \r\n     }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：$O(n)$ 树的节点在递归中只遍历一次\r\n- 空间复杂度：$O(l)$ 树的深度\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836882253","body":"## 思路\r\n\r\n\r\n## 代码\r\nJavaScript\r\n\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let str = '';\r\n  for (let i = 0; i < num.length; i++) {\r\n    if (num[i] < 0 || num[i] > 9) {\r\n      str = '';\r\n      break;\r\n    } else {\r\n      str += num[i];\r\n    }\r\n  }\r\n  let sum = str / 1 + k;\r\n  const result = [];\r\n  let divisor;\r\n  for (let j = 0; j < (sum + '').length; j++) {\r\n    if (j == 0) {\r\n      divisor = 1;\r\n    } else {\r\n      divisor = 10 ** j;\r\n    }\r\n    result.unshift(parseInt((sum % 10 ** (j + 1)) / divisor));\r\n  }\r\n  return result;\r\n};\r\n\r\nconst arr = [1, 2, 0, 1];\r\nconst k = 220;\r\nconsole.log(addToArrayForm(arr, k));\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838736689","body":"## 思路\r\n\r\n## 代码\r\nvar shortestToChar = function (s, c) {\r\n  // 结果数组 res\r\n  var res = Array(s.length).fill(0);\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (s[i] === c) continue;\r\n\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (s[l] === c) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < s.length) {\r\n      if (s[r] === c) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839822900","body":"### 思路\r\n使用数组来模拟栈的push和pop\r\npop()返回堆顶元素\r\nincrement，当数组长度小于k时，所有元素+val, 当数组长度大于或等于k时，数组的前k个元素+val\r\n\r\n### 代码\r\nJavascript\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let stack = this.stack;\r\n    if ( stack.length > 0) {\r\n        return stack.pop();\r\n    }else {\r\n        return -1;\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const stackLen = this.stack.length;\r\n    let m = stackLen < k ? stackLen : k;\r\n    for(let i = 0; i < m; i++) {\r\n        this.stack[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840657882","body":"```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  console.log(s, s.length);\r\n  let stack = s.split(']');\r\n  let arr = [];\r\n  stack = stack.map(item => {\r\n    item = item.split('[');\r\n    console.log('item', item);\r\n    let str = ''\r\n    for(let i = 0; i < item[0]; i ++) {\r\n      str += item[1];\r\n    }\r\n    console.log('str', str)\r\n    arr.push(str)\r\n  });\r\n  return arr.join('');\r\n};\r\n\r\nconst a1 = decodeString('3[a]2[bc]');\r\n\r\nconsole.log('a1', a1);\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841312790","body":"### 思路\r\n使用数组模拟队列\r\n### 代码\r\n\r\nJavaScript\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.shift();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    if(this.stack.length == 0) {\r\n        return true\r\n    }else {\r\n        return false;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812055","body":"### 思路\r\n利用链表特性\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if (!head || !head.next) {\r\n        return head\r\n    }\r\n    let current = head, n = 0\r\n \r\n    while (++n && current.next) {\r\n        current = current.next\r\n    }\r\n    k = k % n\t\r\n\r\n    while (k--) {\r\n        current = head\r\n        while (current.next.next) {\r\n            current = current.next\r\n        }\r\n    \r\n        current.next.next = head \r\n        head = current.next \r\n        current.next = null \r\n    }\r\n\r\n    return head\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842282030","body":"### 思路\r\n链表的属性\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (head === null|| head.next === null) {\r\n        return head;\r\n    }\r\n    const nextHead = head.next;\r\n    head.next = swapPairs(nextHead.next);\r\n    nextHead.next = head;\r\n    return nextHead;\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843209002","body":"### 思路\r\n快慢指针\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nclass TreeNode {\r\n    constructor(val, left, right) {\r\n        this.val = (val === undefined ? 0 : val);\r\n        this.left = (left === undefined ? null : left);\r\n        this.right = (right === undefined ? null : right);\r\n    }\r\n}\r\n\r\nvar sortedListToBST = function(head) {\r\n    if (head == null) return null;\r\n    let slow = head;\r\n    let fast = head;\r\n    let preNode;\r\n\r\n    while (fast && fast.next) {\r\n        preNode = slow;        \r\n        slow = slow.next;      \r\n        fast = fast.next.next; \r\n    }\r\n    const root = new TreeNode(slow.val);   \r\n\r\n    if (preNode != null) {  \r\n        preNode.next = null;  \r\n        root.left = sortedListToBST(head);    \r\n    }\r\n    root.right = sortedListToBST(slow.next);\r\n    return root;\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(nlogn)\r\n空间复杂度O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844115275","body":"### 思路\r\n双指针\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA;\r\n    let pB = headB;\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next;\r\n        pB = pB === null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845241582","body":"### 思路\r\n双指针，指定一个慢指针，指定一个快指针，直到两个指针相遇，将快指针置为第一个节点，一次往后走一位，再次相遇的节点即为入环节点。\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    if(head === null || head.next === null) return null;\r\n\r\n    let slow = head.next;\r\n    let fast = head.next.next;\r\n\r\n    while(fast !== null && fast.next !== null) {\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n\r\n        if(slow === fast) {\r\n            fast = head;\r\n\r\n            while(slow !== fast) {\r\n                fast = fast.next;\r\n                slow = slow.next;\r\n            }\r\n\r\n            return fast\r\n        }\r\n    }\r\n\r\n    return null\r\n};\r\n```\r\n##复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846052937","body":"### 思路\r\n使用map来解答\r\n### 代码\r\nJavaScript\r\n```js\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.map.get(key)\r\n    if(value === undefined){\r\n        return -1;\r\n    }\r\n    this.map.delete(key);\r\n    this.map.set(key, value);\r\n    return value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.map.has(key)){\r\n        this.map.delete(key);\r\n    }\r\n    this.map.set(key,value);\r\n    if(this.map.size > this.capacity){\r\n        let keyIterator = this.map.keys();\r\n        this.map.delete(keyIterator.next().value);\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度O(1)\r\n空间复杂度O(n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427370","body":"### 思路\r\n递归，得到左子树的节点深度，右子树节点深度，比较得到最大子节点数加上根节点即为最大深度。\r\n### 代码\r\nJavaScript\r\n```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  if (root === null) return 0\r\n\r\n  const leftMaxDepth = maxDepth(root.left);\r\n  const rightMaxDepth = maxDepth(root.right);\r\n  \r\n  return 1 + Math.max(leftMaxDepth, rightMaxDepth);\r\n  \r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度O(n)\r\n空间复杂度O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836931206","body":"## 代码\r\n```\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let kArr: number[] = String(k).split('').map(v => parseInt(v, 10));\r\n    let kLength = kArr.length - 1;\r\n    let numLength = num.length - 1;\r\n    let flag: number = 0;\r\n    while(numLength >= 0 || kLength >= 0 || flag > 0) {\r\n        let kItem = kArr[kLength] || 0;\r\n        let numItem = num[numLength] || 0;\r\n        let sum = numItem + kItem + flag;\r\n        flag = 0;\r\n        if(sum >= 10) {\r\n            flag = 1;\r\n            sum -= 10;\r\n        }\r\n        if(numLength < 0) {\r\n            num.unshift(sum);\r\n        }else {            \r\n            num[numLength] = sum;\r\n        }\r\n        numLength--;\r\n        kLength--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n## 思路\r\n1. 把数据转换成数组相加\r\n2. 两个数组长度可能不一样长，如果长度不够需要在头部插入\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(m+n)，其中 m 是 num 数组长度，n 是 k的长度\r\n2. 空间复杂度 O(m+n)"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838374436","body":"## 思路\r\n找到匹配的字符，判断离上一个节点近还是下一个节点近。第一匹配到的位置之前和最后一个匹配到的位置之后需要单独处理。\r\n\r\n## 代码\r\n```\r\nfunction shortestToChar(s: string, c: string): number[] {\r\n    let result: number[] = [];\r\n    if (s.length === 0 || c.length === 0) {\r\n        return result;\r\n    }\r\n    let strArray = Array.from(s);\r\n    let indexs: number[] = [];\r\n    strArray.forEach((element, index) => {\r\n        if (element === c) {\r\n            indexs.push(index);\r\n        }\r\n    });\r\n    for (let i = 0; i <= indexs[0]; i++) {\r\n        result.push(indexs[0] - i);\r\n    }\r\n    for (let i = 0; i <= indexs.length - 2; i++) {\r\n        let start = indexs[i];\r\n        let end = indexs[i + 1];\r\n        for (let i = start + 1; i <= end; i++) {\r\n            let distance = Math.min(i - start, end - i);\r\n            result.push(distance);\r\n        }\r\n    }\r\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\r\n        result.push(i - indexs[indexs.length - 1]);\r\n    }\r\n    return result;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839861269","body":"## 思路\r\n1. 用数组模拟\r\n2. 保留栈长度以及最大容量\r\n\r\n## 代码\r\n```\r\nclass CustomStack {\r\n    stack: number[];\r\n    maxSize: number;\r\n    size: number;\r\n    constructor(maxSize: number) {\r\n        this.stack = [];\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n    }\r\n\r\n    push(x: number): void {\r\n        if (this.size >= this.maxSize) {\r\n            return;\r\n        }\r\n        this.size += 1;\r\n        this.stack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.size <= 0) {\r\n            return -1;\r\n        }\r\n        this.size -= 1;\r\n        return this.stack.pop();\r\n    }\r\n\r\n    increment(k: number, val: number): void {\r\n        let i = 0;\r\n        let size = this.size;\r\n        while (i < size && i < k) {\r\n            this.stack[i] += val;\r\n            i++;\r\n        }\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841114910","body":"## 思路\r\n栈是先进后出，队列是先进先出，两个栈模拟队列的话，就是一个出栈一个入栈，当出栈空的时候，把入栈里面的元素拿出来在压入出栈，这样刚好实现先进先出\r\n\r\n## 代码\r\n```\r\nclass MyQueue {\r\n    outStack: number[]\r\n    inStack: number[]\r\n    constructor() {\r\n        this.outStack = [];\r\n        this.inStack = [];\r\n    }\r\n\r\n    push(x: number): void {\r\n        this.inStack.push(x);\r\n    }\r\n\r\n    pop(): number {\r\n        if (this.outStack.length === 0) {\r\n            this.in2out();\r\n        }\r\n        return this.outStack.pop();\r\n    }\r\n\r\n    peek(): number {\r\n        if (this.outStack.length === 0) {\r\n            this.in2out();\r\n        }\r\n        return this.outStack[this.outStack.length - 1];\r\n    }\r\n\r\n    empty(): boolean {\r\n        return this.inStack.length === 0 && this.outStack.length === 0;\r\n    }\r\n\r\n    in2out(): void {\r\n        while (this.inStack.length > 0) {\r\n            this.outStack.push(this.inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(1)\r\n2. 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678744","body":"## 思路\r\n1. 最大逆序的子串必须分到一个块里面，其他块最大长度是剩余数组的长度\r\n2. 最大逆序子串和已排序的子串的和是相同的，如果和相同，长度加1\r\n\r\n## 代码\r\n```\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n    let count: number = 0;\r\n    let sorted = [...arr];\r\n    sorted.sort((a, b) => {\r\n        return a - b;\r\n    });\r\n    const length = arr.length;\r\n    let sum1: number = 0;\r\n    let sum2: number = 0;\r\n    for (let i = 0; i < length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n        if (sum1 === sum2) {\r\n            count++;\r\n        }\r\n    }\r\n    return count;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(NlogN)\r\n2. 空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762640","body":"## 思路\r\n1. 旋转其实是把倒数第 k 个以后的放到前面去\r\n2. 找到倒数第 k 个，然后把这部分节点放到前面去\r\n\r\n## 代码\r\n```\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n    if (head === null || head.next === null) {\r\n        return head;\r\n    }\r\n    let count: number = 1;\r\n    let p1 = head;\r\n    while (count <= k && p1.next !== null) {\r\n        p1 = p1.next;\r\n        count++;\r\n    }\r\n    // 长度小于等于 k\r\n    if (count <= k && p1.next === null) {\r\n        let rotate: number = count - k % count;\r\n        let i: number = 1;\r\n        let p2 = head;\r\n        while (i < rotate) {\r\n            p2 = p2.next;\r\n            i++;\r\n        }\r\n        p1.next = head;\r\n        head = p2.next;\r\n        p2.next = null;\r\n        return head;\r\n    }\r\n    let p2 = head;\r\n    while (p2.next && p1.next) {\r\n        p2 = p2.next;\r\n        p1 = p1.next;\r\n    }\r\n    p1.next = head;\r\n    head = p2.next;\r\n    p2.next = null;\r\n    return head;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(N)\r\n2. 空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842219897","body":"## 思路\r\n利用 3 个指针，记录前一个、当前、以及后一个节点，反转之后逐步后移\r\n## 代码\r\n```\r\nfunction swapPairs(head: ListNode | null): ListNode | null {\r\n    if (head === null || head.next === null) {\r\n        return head;\r\n    }\r\n    let cur: ListNode = head;\r\n    let prev: ListNode = new ListNode(0, null);;\r\n    let next: ListNode = cur.next;\r\n    head = prev;\r\n    while (cur && next) {\r\n        prev.next = next;\r\n        cur.next = next.next;\r\n        next.next = cur;\r\n        prev = cur;\r\n        cur = cur.next;\r\n        if (cur && cur.next) {\r\n            next = cur.next;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return head.next;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(n)\r\n2. 空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842944026","body":"## 思路\r\n1. 先把链表存在数组里面\r\n2. 递归的新建平衡二叉树\r\n\r\n## 代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * class TreeNode {\r\n *     val: number\r\n *     left: TreeNode | null\r\n *     right: TreeNode | null\r\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.left = (left===undefined ? null : left)\r\n *         this.right = (right===undefined ? null : right)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction sortedListToBST(head: ListNode | null): TreeNode | null {\r\n    if (head === null) {\r\n        return null;\r\n    }\r\n    let stack: TreeNode[] = [];\r\n    let p: ListNode = head;\r\n    while (p) {\r\n        let treeNode: TreeNode = new TreeNode(p.val);\r\n        stack.push(treeNode);\r\n        p = p.next;\r\n    }\r\n    const buildBST = (Nodes: TreeNode[], start: number, end: number): TreeNode => {\r\n        let rootIndex: number = Math.floor((start + end) / 2);\r\n        let root: TreeNode = Nodes[rootIndex];\r\n        if (start === end) {\r\n            return root;\r\n        }\r\n        if (rootIndex - 1 >= start) {\r\n            root.left = buildBST(Nodes, start, rootIndex - 1);\r\n        }\r\n        if (rootIndex + 1 <= end) {\r\n            root.right = buildBST(Nodes, rootIndex + 1, end);\r\n        }\r\n        return root;\r\n    };\r\n    let root: TreeNode = buildBST(stack, 0, stack.length - 1);\r\n    return root;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 O(n)\r\n2. 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843850618","body":"## 思路\r\n1. 用哈希表，挨着遍历2个遍历，判断是否命中，存在就是命中\r\n2. 使用双指针，如果有交叉，双指针把两个链表都走完，肯定会相遇\r\n## 代码\r\n```\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n    if (headA === null || headB === null) {\r\n        return null;\r\n    }\r\n    let pA: ListNode = headA;\r\n    let pB: ListNode = headB;\r\n    while (pA !== pB) {\r\n        if (pA === null) {\r\n            pA = headB;\r\n        } else {\r\n            pA = pA.next;\r\n        }\r\n        if (pB === null) {\r\n            pB = headA;\r\n        } else {\r\n            pB = pB.next;\r\n        }\r\n    }\r\n    return pA;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(m+n)\r\n2. 空间复杂度 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844907789","body":"## 思路\r\n用 set 保存 一下访问过的节点，如果发现被访问了，直接返回当前的节点\r\n## 代码\r\n```\r\nfunction detectCycle(head: ListNode | null): ListNode | null {\r\n    const visited = new Set();\r\n    while(head !== null) {\r\n        if(visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(n)\r\n2. 空间复杂度 O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846357667","body":"## 思路\r\n递归的求左子树和右子树的深度，然后 `+1` 即可\r\n## 代码\r\n```\r\nfunction maxDepth(root: TreeNode | null): number {\r\n    if (root === null) {\r\n        return 0;\r\n    }\r\n    let leftDepth: number = maxDepth(root.left);\r\n    let rightRight: number = maxDepth(root.right);\r\n    return Math.max(leftDepth, rightRight) + 1;\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(n)\r\n2. 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846431689","body":"## 思路\r\n1. 判断根节点是否相等，不相等直接返回\r\n2. 根节点相等，分别递归判断左子树和右子树\r\n## 代码\r\n```\r\nfunction isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    }\r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    if (p.val !== q.val) {\r\n        return false;\r\n    }\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n};\r\n```\r\n## 复杂度分析\r\n1. 时间复杂度 O(n)\r\n2. 空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lingquan02":[{"title":"989. 数组形式的整数加法","url":"https://github.com/leetcode-pp/91alg-4/issues/33#issuecomment-836966361","body":"### 思路\r\n- 位数相加，数组加完后，指针向前移动， 对于k加完后，去掉个位\r\n- 边界 数组len>=0 || k!=0\r\n复杂度：\r\nT= O(n)\r\nS =O(1)\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];// 存放结果\r\n    let len = num.length-1;\r\n    let carry = 0; // 存放进位\r\n\r\n    while(len>=0 || k!=0) {\r\n        const x = len >=0 ? num[len] : 0 // 取最后一位  （个位数）\r\n        const y = k!=0 ? k % 10 : 0; // 取个位数 取模\r\n\r\n        const sum = x+y+carry // 求和  \r\n        res.push(sum%10) // 将个位数放到结果集里\r\n        carry = Math.floor(sum/10) // 存放进位\r\n\r\n        len--;\r\n        k = Math.floor(k/10); // 每次运算完成去掉个位数\r\n    }\r\n\r\n    if(carry) res.push(carry)\r\n    return res.reverse()\r\n};\r\n\r\n```"},{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529295","body":"### 思路分析\r\n- T= O(n)\r\n- S = O(1)\r\n```javascript\r\n// 滑动窗口\r\nconst shortestToChar =(S,C) => {\r\n    let len =S.length;\r\n    let l = S[0] === C ? 0: len-1;\r\n    let r = S.indexOf(C,1); // 从index未1的位置开始找c\r\n    let res = Array(len);\r\n    for(let i=0;i<len;i++) {\r\n        res[i] =Math.min(Math.abs(i-r),Math.abs(l-i))\r\n        // 改变窗口\r\n        if(i===r) {\r\n            l =r; \r\n            r = S.indexOf(C,l+1);\r\n\r\n        }\r\n\r\n    }\r\n    return res\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839776411","body":"### 思路\r\n使用js数组 模拟栈\r\n```javascript\r\nclass CustomStack {\r\n    constructor(maxSize) {\r\n        this.stack = []\r\n        this.maxSize = maxSize\r\n    }\r\n\r\n    push(x) {\r\n        if(this.stack.length>= this.maxSize) return \r\n        this.stack.push(x)\r\n    }\r\n\r\n    pop() {\r\n        if(!this.stack.length) return -1\r\n        return this.stack.pop()\r\n    }\r\n\r\n    increment(k,val) {\r\n        let min = Math.min(k,this.stack.length)\r\n        for(let i=0;i<min;i++) {\r\n            this.stack[i]+=val\r\n        }\r\n    }\r\n}\r\n```"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842381247","body":"### 思路\r\n-  递归 两两交换链表节点\r\n 返回值时 新的head节点\r\n终止条件是 链表中没有节点 或只有一个节点\r\n### 复杂度分析\r\n- T = O(n)\r\n-  S =O(1)\r\n\r\n```javascript\r\nconst swapPairs = (head)=> {\r\n    if(head === null || head.next === null) \r\n        return head\r\n    \r\n        const  newHead = head.next \r\n        head.next = swapPairs(newHead.next)\r\n        newHead.next = head \r\n        return newHead\r\n}\r\n\r\n```\r\n\r\n\r\n- 迭代\r\n创建dummyhead节点  使 dummyheda.next = head \r\n并且使 temp表示点到达的节点\r\ntemp = dumyhead\r\n边界条件  temp.next !== null || temp.next.next !== null\r\n\r\n### 复杂度分析\r\n- T= O(n)\r\n- S = O(1)\r\n\r\n```javascript\r\nconst swapPairs = (head)=> {\r\n     const dummyHead = new ListNode(0)\r\n    dummyHead.next = head;\r\n    let temp = dummyHead \r\n    while (temp.next !== null && temp.next.next !== null) {\r\n        const node1 = temp.next\r\n        const node2 = temp.next.next \r\n        temp.next = node2\r\n        node1.next= node2.next \r\n        node2.next = node1 \r\n        temp = node1\r\n    } \r\n\r\n    return dummyHead.next\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843209883","body":"方法一：\r\n### 思路：\r\n将链表转换为数组 +递归\r\n取中间索引 作数树 的根 \r\n递归构建左右子树\r\n\r\n### 复杂度\r\n- T = O(n)\r\n- S = O(n)\r\n```javascript\r\nconst sortedListToBST =(head) => {\r\n    const arr = []\r\n    // 链表转为数组\r\n    while(head) {\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n\r\n    const buildBST = (start, end)=> {\r\n        if(start >end) return null  // 指针交错形成不了 子序列 返回null节点\r\n        const mid = (start+end) >>> 1 // 取中间索引 \r\n        const root = new TreeNode(arr[mid]) // 创建根节点\r\n        root.left = buildBST(start, mid-1) // 构建左子树、\r\n        root.right = buildBST(mid+1, end) // 递归构建右子树\r\n        return root // 返回当前子树\r\n\r\n    }\r\n    return buildBST(0,arr.length-1)\r\n}\r\n```\r\n方法二：\r\n### 思路\r\n分治+快慢指针+递归\r\n快慢指针 都指向头结点 分别依次走2步和一步 当快指针周到尾节点时 满指针刚刚好走到了链表的中间\r\n保存满指针的前置及节点\r\n### 复杂度\r\n- T = O(nlogn)\r\n- S = O(logn)\r\n\r\n```javascript\r\nconst sortedListToBST2 =(head) => {\r\n    if(head === null)  return null\r\n    let slow = head\r\n    let fast = head \r\n    let preSlow\r\n\r\n    while (fast && fast.next) {\r\n        preSlow = slow  // 保存当前slow\r\n        slow = slow.next \r\n        fast = fast.next.next \r\n    }\r\n\r\n    const root = new TreeNode(slow.val) // 根据slow指向的节点值 构建节点\r\n    if(preSlow !=null) {  // preSLow 有值  即是 slow左边有节点 需要构建左子树\r\n        preSlow.next = null  // 切断preSLow和 slow\r\n        root.left = sortedListToBST2(head) // 递归哦构建左子树\r\n\r\n    }\r\n\r\n    root.right =sortedListToBST2(slow.next) // 递归构建安右子树\r\n    return root\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844147654","body":"### 思路\r\n- 方法一：\r\n哈希表法\r\n遍历链表A 并将每个节点的地址存储在哈希表中 然后检查链表B中的每一个节点 bi是否在哈希表中，若在 bi就是相交节点\r\n- 复杂度：\r\nT = O(m+n)\r\nS = O(m) / O(n) 取决于 链表的长度\r\n\r\n```javascript\r\nconst getIntersectionNode =(headA, headB) => {\r\n    const set = new Set() \r\n    let curNode = headA \r\n    while (curNode !== null) {\r\n        set.add(curNode)\r\n        curNode = curNode.next\r\n    }\r\n\r\n    curNode = headB \r\n    while (curNode !== null) {\r\n        if(set.has(curNode)) {\r\n            return curNode\r\n        }\r\n        curNode = curNode.next\r\n    }\r\n\r\n    return null\r\n}\r\n```\r\n\r\n- 方法二：\r\n双指针法\r\n根据题意 如果两个链表相交，那么相交点之后的长度是相同的\r\n需要消除 2个链表的长度差\r\n指针pA 指向 A链表  指针pB指向B链表 依次向后遍历\r\n如果 pA 到了末尾  ，pA = headB 继续遍历\r\n如果pB 到了末尾， pB = headB 继续遍历\r\n比较长的链表指针指向较短链表head时，长度差就消除了\r\n如果两个链表存在相交，它们末尾的结点必然相同。因此当 pA/pB 到达链表结尾时，记录下链表 A/B 对应的元素。若最后元素不相同，则两个链表不相交\r\n\r\n- 复杂度：\r\nT = O(n+m)\r\nS = O(1)\r\n\r\n```javascript\r\nconst getIntersectionNode2 =(headA,headB) => {\r\n    let pA = headA\r\n    let pB = headB\r\n\r\n    while (pA!= pB) {\r\n        pA = pA !== null ? pA.next : headB;\r\n        pB = pB !== null ? pB.next : headA;\r\n    }\r\n\r\n    return A\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845229905","body":"### 快慢指针\r\n- 快慢指针相遇时 证明是有环的\r\nT= O(n)\r\nS =O(1)\r\n```\r\nconst detectCycle2 =(head) => {\r\n    let slow = head;\r\n    let fast = head;\r\n\r\n    while (fast != NULL && fast.next != NULL) {\r\n        slow = slow.next \r\n        if (fast.next !== null) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            return null;\r\n        }\r\n        if (fast === slow) {\r\n            let ptr = head;\r\n            while (ptr !== slow) {\r\n                ptr = ptr.next;\r\n                slow = slow.next;\r\n            }\r\n            return ptr;\r\n        }\r\n\r\n     }\r\n}\r\n```\r\n### 哈希表\r\n- 遍历链表 将节点存入hasn表 如果在哈希表中找到一经存在过的 证明有换\r\n- T=O(N)\r\n- S=O(n)\r\n```javascript\r\nvar detectCycle = function(head) {\r\n    const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"longlonglu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837017943","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        int[] answer = new int[length];\r\n        for (int i = 0; i < length; i++) {\r\n            if (s.charAt(i) == c) { answer[i] = 0; continue; }\r\n            int minDistance = Math.min(leftDistance(s, c, i), rightDistance(s, c, i));\r\n            answer[i] = minDistance;\r\n        }\r\n        return answer;\r\n    }\r\n    public int leftDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i >= 0; i--) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n    public int rightDistance(String s, char c, int index) {\r\n        int counter = 0;\r\n        for (int i = index; i < s.length(); i++) {\r\n            if (s.charAt(i) == c) { return counter; }\r\n            counter++;\r\n        }\r\n        return s.length() + 1;\r\n    }\r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840713732","body":"```java\r\nclass MyQueue {\r\n        /** Initialize your data structure here. */\r\n        Integer peek;\r\n        Stack<Integer> store;\r\n        public MyQueue() {\r\n            peek = null;\r\n            store = new Stack<>();\r\n        }\r\n        \r\n        /** Push element x to the back of queue. */\r\n        public void push(int x) {\r\n            if(store.isEmpty()) { peek = x; }\r\n            store.add(x);    \r\n        }\r\n        \r\n        /** Removes the element from in front of queue and returns that element. */\r\n       public int pop() {\r\n            if(store.isEmpty()) { return -1; }\r\n            Stack<Integer> temp = new Stack<>();\r\n            int size = store.size();\r\n            for(int i = 0; i < size; i++) {\r\n                temp.add(store.pop());\r\n            }\r\n            int returnValue = temp.pop();\r\n            if(!temp.isEmpty()) {\r\n                peek = temp.peek();\r\n            } else { return returnValue; }\r\n            size = temp.size();\r\n            for(int i = 0; i < size; i++) {\r\n                store.add(temp.pop());\r\n            }\r\n            return returnValue;\r\n        }\r\n        /** Get the front element. */\r\n        public int peek() {\r\n            if(peek == null) { return -1; }\r\n            return peek;     \r\n        }\r\n        \r\n        /** Returns whether the queue is empty. */\r\n        public boolean empty() {\r\n            return store.isEmpty();    \r\n        } \r\n    }   \r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841501072","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int len = arr.length;\r\n        int[] maxarr = new int[len+1];\r\n        int[] minarr = new int[len+1];\r\n        minarr[len] = Integer.MAX_VALUE;\r\n        for(int i=0; i<len; i++){\r\n            maxarr[i+1] = Math.max(arr[i], maxarr[i]);\r\n            minarr[len-i-1] = Math.min(arr[len-i-1], minarr[len-i]);\r\n        }\r\n        int cnt = 0;\r\n        for(int i=0; i<len; i++)\r\n            if(minarr[i+1]>=maxarr[i+1])\r\n                cnt++;\r\n        return cnt;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841738553","body":"```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) { return null; }\r\n        int length = 1;\r\n        ListNode temp = head;\r\n        while (temp.next != null) {  \r\n            length++;\r\n            temp = temp.next;\r\n        }\r\n        int moves = length - (k % length);\r\n        if (moves == length) { return head; }\r\n        temp.next = head;\r\n        temp = head;\r\n        for (int i = 1; i < moves; i++) {\r\n            temp = temp.next;\r\n        }\r\n        ListNode newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841883103","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null) { return null; }\r\n        ListNode current = head;\r\n        if (current.next == null) { return current; }\r\n        ListNode next = current.next;\r\n        ListNode dummy = next;\r\n        ListNode previous = next;\r\n        while (current.next != null) {\r\n            ListNode temp = next.next;\r\n            next.next = current;\r\n            current.next = temp;\r\n            previous = current;\r\n            current = temp;\r\n            if (current == null) { break; }\r\n            next = current.next;\r\n            previous.next = next;\r\n        }\r\n        previous.next = current;\r\n        return dummy;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842752747","body":"```java\r\n    public  ListNode findMiddleElement(ListNode head) {\r\n        ListNode previous = null;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            previous = slow;\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        if (previous != null) { previous.next = null; }\r\n        return slow;\r\n    }\r\n    \r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) { return null; }\r\n        ListNode mid = findMiddleElement(head);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        if (head == mid) { return root; }\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(mid.next);\r\n        return root;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843563730","body":"```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while(a!=b){\r\n            a = a == null? headB : a.next;\r\n            b = b == null? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844469449","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if (head == null) { return null; }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while (fast != null && fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if (slow == fast) { \r\n                while (head != slow) {\r\n                    slow = slow.next;\r\n                    head = head.next;\r\n                }\r\n                return head;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845525445","body":"```java\r\nclass Node{\r\n    int key,val;\r\n    Node prev,next;\r\n}\r\nclass LRUCache {\r\n    //DLL\r\n    Node head=new Node();\r\n    Node tail=new Node();\r\n    int capacity;\r\n\t//HashMap\r\n    HashMap<Integer,Node> map;\r\n        \r\n    public LRUCache(int capacity) {\r\n        head.next=tail;tail.prev=head;\r\n        this.capacity=capacity;\r\n        map=new HashMap(capacity);\r\n    }\r\n    \r\n    public int get(int key) {\r\n      //If not present in map, return -1\r\n        int result=-1;\r\n\t//Else,remove the node and bring it to the start of the list\r\n        if(map.containsKey(key)){\r\n            Node node=map.get(key);\r\n            result=node.val;\r\n            remove(node);\r\n            add(node);\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        Node node=map.get(key);\r\n\t\t//If already present, remove the node and bring it to the start of the list\r\n        if(node!=null){\r\n            remove(node);\r\n            node.val=value;\r\n            add(node);\r\n        }\r\n        else{\r\n\t\t//If reached full capacity ,remove last node\r\n            if(map.size()==capacity){\r\n                map.remove(tail.prev.key);\r\n                remove(tail.prev);\r\n            }\r\n\t\t//Else add it to the start of list\r\n            Node new_node=new Node();\r\n            new_node.key=key;new_node.val=value;            \r\n            map.put(key,new_node);\r\n            add(new_node);            \r\n        }\r\n    }\r\n\t//To add node to the start of the list\r\n    public void add(Node node){\r\n        Node next=head.next;\r\n        //Links between head and node\r\n        head.next=node;node.prev=head;\r\n        //Links between node and next\r\n        node.next=next;next.prev=node;\r\n    }\r\n\t//To remove a node from the list\r\n    public void remove(Node node){\r\n        Node prev=node.prev;\r\n        Node next=node.next;\r\n        //Links between prev and next node of current\r\n        prev.next=next;next.prev=prev;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846399546","body":"```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null) { return 0; }\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"911gt5":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837256654","body":"TC: O(n)\r\nSC: O(n)\r\n\r\n``` python\r\ndef shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        left = [float('inf')]*n\r\n        right = [float('inf')]*n\r\n        stack = collections.deque()\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                while stack:\r\n                    pre_i= stack.popleft()\r\n                    left[pre_i] = i - pre_i\r\n                left[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                while stack:\r\n                    post_i = stack.popleft()\r\n                    right[post_i] = post_i -i \r\n                right[i] = 0\r\n            else:\r\n                stack.append(i)\r\n        return [min(l,r) for l,r in zip(left, right)]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839229965","body":"TC: O(n)  \r\nSC: O(n)\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1 \r\n        \r\n        res = self.stack[-1]\r\n        self.stack.pop()\r\n        return res\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > k:\r\n            for i in range(k):\r\n                self.stack[i] += val \r\n        else:\r\n            self.stack = [j+val for j in self.stack]\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840115165","body":"TC: 指数级别\r\n```\r\ndef decodeString(self, s: str) -> str:\r\n        u = 0\r\n        def dfs(s):\r\n            nonlocal u\r\n            res = ''\r\n            while u < len(s) and s[u] != ']':\r\n\r\n                if s[u].isalpha():\r\n                    res += s[u]\r\n                    u += 1\r\n                elif s[u].isdigit():\r\n                    k = u\r\n                    while s[k].isdigit():\r\n                        k += 1\r\n\r\n                    x = int(s[u:k])\r\n                    u = k + 1\r\n                    y = dfs(s)\r\n                    u += 1 \r\n\r\n                    while x:\r\n                        res += y\r\n                        x -= 1\r\n            return res\r\n\r\n        return dfs(s)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840837027","body":"```python\r\ndef __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1, self.s2 = [], []\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        res = self.s2.pop()\r\n        while self.s2:\r\n            self.s1.append(self.s2.pop())\r\n        return res\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        return self.s1[0]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.s1) == 0\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841568116","body":"TC: O(n)\r\n```python\r\ndef maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for a in arr:\r\n            if not stack or a >= stack[-1]:\r\n                stack += a,\r\n            while len(stack) >= 2 and a < stack[-2]:\r\n                j = stack.pop()\r\n                stack[-1] = j\r\n        return len(stack)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841733331","body":"TC = SC = O(n)\r\n```python\r\ndef rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head: return head \r\n        size = self.cal_length(head)\r\n        k = k % size\r\n        if k == 0:\r\n            return head\r\n\r\n        node_k_prev = self.get_kth_node(head, size - k)\r\n        node_k = node_k_prev.next\r\n        tail = self.get_kth_node(head, size)\r\n        tail.next = head\r\n        node_k_prev.next = None\r\n\r\n        return node_k\r\n        \r\n        \r\n        \r\n    def cal_length(self, head):\r\n        n = 0\r\n        curr = head\r\n        while curr:\r\n            n += 1 \r\n            curr = curr.next\r\n        return n \r\n    \r\n    def get_kth_node(self, head, k):\r\n        curr = head \r\n        for i in range(1, k):\r\n            curr = curr.next \r\n        return curr\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841977648","body":"``` python\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        dummy =tail= ListNode(-1)\r\n        tail.next = head\r\n        while tail.next and tail.next.next:\r\n            a, b = tail.next, tail.next.next \r\n            tail.next = b\r\n            a.next = b.next \r\n            b.next = a \r\n            tail = a\r\n        return dummy.next\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842798227","body":"```python \r\ndef sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        curr, count = head, 0\r\n        while curr:\r\n            curr = curr.next\r\n            count += 1\r\n        def treeify(i: int, j: int) -> TreeNode:\r\n            if j < i: return None\r\n            mid, node = i + j >> 1, TreeNode()\r\n            node.left = treeify(i, mid - 1)\r\n            node.val, curr[0] = curr[0].val, curr[0].next\r\n            node.right = treeify(mid + 1, j)\r\n            return node\r\n        curr = [head]\r\n        return treeify(1, count)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843733341","body":"```python\r\ndef getIntersectionNode(self, headA, headB):\r\n        \"\"\"\r\n        :type head1, head1: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        p, q = headA, headB \r\n        while p!=q:\r\n            if p: \r\n                p = p.next \r\n            else:\r\n                p = headB \r\n                \r\n                \r\n                \r\n            if q:\r\n                q = q.next \r\n            else:\r\n                q = headA\r\n                \r\n        return p\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844543396","body":"```python\r\ndef detectCycle(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next:\r\n            return None\r\n\r\n        f = head\r\n        s = head\r\n        while f and f.next:\r\n            s = s.next\r\n            f = f.next.next\r\n            if s == f:\r\n                s = head\r\n                while s != f:\r\n                    s = s.next\r\n                    f = f.next\r\n                return s\r\n        return None\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845647871","body":"```python\r\ndef __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.values = OrderedDict()\r\n\r\n\r\ndef get(self, key: int) -> int:\r\n        if key in self.values:\r\n            self.values.move_to_end(key, True)\r\n            return self.values[key]\r\n        else:\r\n            return -1\r\n\r\ndef put(self, key: int, value: int) -> None:\r\n        if len(self.values) == self.capacity and key not in self.values:\r\n            self.values.popitem(False)\r\n        self.values[key] = value\r\n        self.values.move_to_end(key, True)\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846358404","body":"```python\r\ndef maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n    return 1 + max(map(self.maxDepth, (root.left, root.right))) if root else 0\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"prince805962788":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837860923","body":"### 思路\r\n双指针，从每个点出发，想左右搜寻，直到找到等于所给字符的点，然后分别算出距离，取其中最小的记录到数组中\r\n### 代码（js）\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    for(let i=0;i<s.length;i++){\r\n        let left = i\r\n        let right = i\r\n        while(left>=0){\r\n            if(s[left] === c) break\r\n            left--\r\n        }\r\n        while(right<s.length){\r\n            if(s[right] === c) break\r\n            right++\r\n        }\r\n        if(left === -1) left = -Infinity\r\n        if(right === s.length) right = Infinity\r\n        res[i] = Math.min(i-left, right-i)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839366048","body":"### JS\r\n思路：数组模拟栈\r\n````\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\nCustomStack.prototype.pop = function() {\r\n    if(this.stack.length === 0) return -1\r\n    let item = this.stack.pop()\r\n    return item\r\n};\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if(k>=this.stack.length){\r\n        for(let i=0;i<this.stack.length;i++){\r\n            this.stack[i] += val\r\n        }\r\n    }else {\r\n        for(let i=0;i<k;i++){\r\n            this.stack[i] += val\r\n        }\r\n    }\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840227944","body":"### 思路(JS)\r\n双指针，一个存数字，一个存当前字符串\r\n````\r\nvar decodeString = function(s) {\r\n    const numStack = []\r\n    const strStack = []\r\n    let num = 0\r\n    let res = ''\r\n    let index = 0\r\n    while(index<s.length){\r\n        if(s[index].match(/[0-9]/)){\r\n            num = num * 10 + Number(s[index])\r\n        }else if(s[index] === '['){\r\n            numStack.push(num)\r\n            strStack.push(res)\r\n            num = 0\r\n            res = ''\r\n        }else if(s[index] === ']'){\r\n            res = strStack.pop() + res.repeat(numStack.pop())\r\n        }else {\r\n            res = res + s[index]\r\n        }\r\n        index++\r\n    }\r\n    return res\r\n};\r\n````\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840942687","body":"### JS\r\n````\r\nclass MyQueue {\r\n    constructor () {\r\n        this.pushArr = [];\r\n        this.popArr = [];\r\n    }\r\n    push (element) {\r\n        this.pushArr.push(element);\r\n    }\r\n    pop () {\r\n        if (this.popArr.length === 0) {\r\n            while (this.pushArr.length > 0) {\r\n                this.popArr.push(this.pushArr.pop());\r\n            }\r\n        }\r\n        return this.popArr.pop();\r\n    }\r\n    peek () {\r\n        if (this.popArr.length === 0) {\r\n            while (this.pushArr.length > 0) {\r\n                this.popArr.push(this.pushArr.pop());\r\n            }\r\n        }\r\n        return this.popArr[this.popArr.length - 1];\r\n    }\r\n    empty () {\r\n        return !this.pushArr.length && !this.popArr.length;\r\n    }\r\n}\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841581463","body":"### JS思路\r\n每一个分块和排序后的数组中对应的分块数字是一样的，只是排序不同，所以每个分块的合排序前后也是一样的\r\n````\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0;\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = 0;\r\n            sum2 = 0;\r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812641","body":"### JS\r\n思路，先算出长度，如果移动的距离大于长度，那么移动的距离为长度减去移动长度与本身长度取余，然后把原来的链表变为循环链表，移动完后，再变回单链表\r\n````\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next || !k) return head;\r\n    let len = 1, cur = head;\r\n    while(cur.next){\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n    let move = len - k % len;\r\n    cur.next = head;\r\n    while(move){\r\n        cur = cur.next;\r\n        move--;\r\n    }\r\n    let dummy = cur.next;\r\n    cur.next = null;\r\n    return dummy;\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842223982","body":"### JS\r\n思路：先生成一个前置节点，指向头结点，然后循环找下一个节点和下下个节点，之间进行交换，然后每次向后移动2次\r\n````\r\nvar swapPairs = function(head) {\r\n    const dummy = new ListNode(0)\r\n    dummy.next = head\r\n    let current = dummy\r\n    while(current.next && current.next.next){\r\n        let first = current.next\r\n        let second = current.next.next\r\n        first.next = second.next\r\n        second.next = first\r\n        current.next = second\r\n        current = current.next.next\r\n    }\r\n    return dummy.next\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842763112","body":"### JS\r\n思路：先把链表遍历转为数组，二叉搜索树的中序遍历是有序的，刚好对应升序数组，每次取中间值作为中间节点\r\n````\r\nvar sortedListToBST = function(head) {\r\n    let arr = []\r\n    while(head){\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n    function buildAVL(low,high){\r\n        if (low > high) {\r\n            return null\r\n        }\r\n        // 取数组的中间值作为根结点值\r\n        const mid = Math.floor(low + (high - low) / 2)\r\n        // 创造当前树的根结点\r\n        const cur = new TreeNode(arr[mid])\r\n        // 构建左子树\r\n        cur.left = buildAVL(low, mid - 1)\r\n        // 构建右子树\r\n        cur.right = buildAVL(mid + 1, high)\r\n        // 返回当前树的根结点 \r\n        return cur\r\n    }\r\n    let node = buildAVL(0,arr.length-1)\r\n    return node\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843762697","body":"### JS\r\n````\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA\r\n    let b = headB\r\n    while(a !== b){\r\n        a = a === null ? headB : a.next\r\n        b = b === null ? headA : b.next\r\n    }\r\n    return a\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844613041","body":"### JS\r\n思路：遍历过的，赋值一个flag值，再次遍历到的时候，如果有flag值，就返回这个节点\r\n````\r\nvar detectCycle = function(head) {\r\n   while(head){\r\n       if(head.flag){\r\n           return head\r\n       }else {\r\n           head.flag = true\r\n           head = head.next\r\n       }\r\n   } \r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845601359","body":"### JS\r\n使用map记录每个值，当超出时候，map.keys取到遍历数组，用.next()取到第一个然后删除\r\n````\r\nvar LRUCache = function(capacity) {\r\n    this.maxSize = capacity;\r\n    this.map = new Map();\r\n};\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.map.get(key)\r\n    if(value === undefined){\r\n        return -1;\r\n    }\r\n    this.map.delete(key);\r\n    this.map.set(key, value);\r\n    return value;\r\n};\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.map.has(key)){\r\n        this.map.delete(key);\r\n    }\r\n    this.map.set(key,value);\r\n    if(this.map.size > this.maxSize){\r\n        let keyNext = this.map.keys();\r\n        this.map.delete(keyNext.next().value);\r\n    }\r\n};\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846326757","body":"### JS\r\n递归，取左右子数深度的最大值\r\n````\r\nvar maxDepth = function(root) {\r\n    let dfs = (root)=>{\r\n        if(!root) return 0\r\n        let left = dfs(root.left)\r\n        let right = dfs(root.right)\r\n        return Math.max(left,right) + 1\r\n    }\r\n    return dfs(root)\r\n};\r\n````"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-837931988","body":"# Approach\r\n- Left-to-right: count the distance on the right\r\n- Right-to-left: count the distance on the left\r\n- Take the minimum at each position\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        distance = 10001\r\n        n = len(s)\r\n        res = []\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res.append(distance)\r\n            distance += 1\r\n        \r\n        distance = 10001\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                distance = 0\r\n            res[i] = min(distance, res[i])\r\n            distance += 1\r\n        return res\r\n```\r\n\r\n# Complexity analysis\r\n- Time: O(n)\r\n- Space: O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839606507","body":"# Approach\r\n- Stack\r\n\r\n# Python Implementation\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stack:\r\n            x = self.stack.pop()\r\n        else:\r\n            x = -1\r\n        return x\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n# Complexity Analysis\r\n- Time O(1)\r\n- Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840661629","body":"# Approach\r\n- Handle continuous digits, `[`, `]`, and other chars.\r\n\r\n# Python Implementation\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        n = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                n = n * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([n, res])\r\n                n = 0\r\n                res = \"\"\r\n            elif c == ']':\r\n                cur_n, last_res = stack.pop()\r\n                res = last_res + cur_n * res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n# Time Complexity\r\n- Time O(n)\r\n- Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840677617","body":"# Approach\r\nUse two stacks to get a queue\r\n\r\n# Python Implementation\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.s1 and not self.s2\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n# Complexity Analysis\r\n- Time complexity: push O(1), peek/pop amortized O(1)\r\n- Space complexity O(n)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841815932","body":"# Approach\r\n- Two pointers\r\n\r\n# Code\r\n```\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return head\r\n        \r\n        fast = head\r\n        n = 0\r\n        while fast:\r\n            fast = fast.next\r\n            n += 1\r\n        k %= n\r\n\r\n        fast, slow = head, head\r\n        for _ in range(k):\r\n            fast = fast.next\r\n\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        \r\n        fast.next = head\r\n        head = slow.next\r\n        slow.next = None\r\n        return head\r\n```\r\n# Complexity Analysis\r\n- Time O(n)\r\n- Space O(1)"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846013269","body":"# 方法\r\n1. 使用哈希表和双向链表\r\n2. 哈希表 key=> node_value, value=> node\r\n\r\n\r\n# Code\r\n```python\r\nclass LinkedNode:\r\n    def __init__(self, key=None, val=None):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.cache = dict()\r\n        self.head = LinkedNode()\r\n        self.tail = LinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n        if key not in self.cache:\r\n            return -1\r\n        else:\r\n            node = self.cache[key]\r\n            self.move_to_head(node)\r\n            return node.val\r\n\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.cache:\r\n            node = self.cache[key]\r\n            node.val = value\r\n            self.move_to_head(node)\r\n        else:\r\n            node = LinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.add_to_head(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                rm_node = self.remove_tail()\r\n                self.cache.pop(rm_node.key)\r\n                self.size -= 1\r\n\r\n\r\n    def move_to_head(self, node):\r\n        self.remove_node(node)\r\n        self.add_to_head(node)\r\n\r\n    def remove_node(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n    \r\n    def add_to_head(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def remove_tail(self):\r\n        node = self.tail.prev\r\n        self.remove_node(node)\r\n        return node\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n\r\n# Complexity Analysis\r\n- Time O(1)\r\n- Space O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YanFaFa":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838156207","body":"\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @param String $c\r\n     * @return Integer[]\r\n     */\r\n    function shortestToChar($s, $c) {\r\n        $target = [];\r\n        $len = strlen($s);\r\n        $targetLen = 0;\r\n        for ($i=0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                array_push($target, $i);\r\n                $targetLen++;\r\n            }\r\n        }\r\n\r\n        for ($i = 0; $i<$len; $i++) {\r\n            if ($s[$i] == $c) {\r\n                $result[] = 0;\r\n            } else {\r\n                $num = $len;\r\n                for ($j = 0; $j<$targetLen;$j++) {\r\n                    $tmp = abs($target[$j] - $i);\r\n                    if ($tmp < $num) {\r\n                        $num = $tmp; \r\n                    } else {\r\n                        continue;\r\n                    }\r\n                }\r\n                $result[] = $num;\r\n            } \r\n        }\r\n        return $result;\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839383268","body":"just translate it?\r\n\r\nclass CustomStack {\r\n    /**\r\n     * @param Integer $maxSize\r\n     */\r\n    public $maxSize;\r\n\r\n    function __construct($maxSize) {\r\n        $this->maxSize = $maxSize;\r\n    }\r\n\r\n    /**\r\n     * @param Integer $x\r\n     * @return NULL\r\n     */\r\n    function push($x) {\r\n        if($this->curSize === $this->maxSize)\r\n            return -1;\r\n        $this->stack[] = $x;\r\n        $this->curSize++;\r\n    }\r\n\r\n    /**\r\n     * @return Integer\r\n     */\r\n    function pop() {\r\n        if(!$this->curSize)\r\n            return -1;\r\n        $this->curSize--;\r\n        return array_pop($this->stack);\r\n    }\r\n\r\n    /**\r\n     * @param Integer $k\r\n     * @param Integer $val\r\n     * @return NULL\r\n     */\r\n    function increment($k, $val) {\r\n        if($this->curSize < $k)\r\n            // for($i=0; $i<$this->curSize; $i++)\r\n            //     $this->stack[$i]+=$val;\r\n            foreach($this->stack as &$num)\r\n                $num+=$val;\r\n        else\r\n            for($i=0; $i<$k; $i++)\r\n                $this->stack[$i]+=$val;\r\n    }\r\n}\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840539820","body":"the function 'str_repeat' should not be used.Waiting for optimization\r\n\r\nclass Solution {\r\n\r\n    /**\r\n     * @param String $s\r\n     * @return String\r\n     */\r\n    function decodeString($s) {\r\n        $len_s = strlen($s);\r\n        $stack = new SplStack();\r\n        for ($i = 0; $i < $len_s; $i++) {\r\n            if ($s[$i] != ']') {\r\n                $stack->push($s[$i]);\r\n                continue;\r\n            }\r\n            $repeat_str = \"\";\r\n            while (!$stack->isEmpty() && $stack->top() != '[') {\r\n                $repeat_str = $stack->pop(). $repeat_str;\r\n            }\r\n            $stack->pop();\r\n            $repeat_times = \"\";\r\n            while (!$stack->isEmpty() && is_numeric($stack->top())) {\r\n                $repeat_times = $stack->pop(). $repeat_times;\r\n            }\r\n            $temp = str_repeat($repeat_str, $repeat_times);\r\n            $stack->push($temp);\r\n        }\r\n\r\n        $res = \"\";\r\n        while (!$stack->isEmpty()) {\r\n            $res = $stack->pop(). $res;\r\n        }\r\n\r\n        return $res;\r\n    }\r\n}"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842766224","body":"> # 109. 有序链表转换二叉搜索树\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n> \r\n> ## 前置知识\r\n> * 递归\r\n> * 二叉搜索树的任意一个节点点，当前节点的值必然大于所有左子树节点的值。同理,当前节点的值必然小于所有右子树节点的值\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n> \r\n> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n> \r\n> 示例:\r\n> \r\n> 给定的有序链表： [-10, -3, 0, 5, 9],\r\n> \r\n> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n> \r\n>     0\r\n>    / \\\r\n>  -3   9\r\n>  /   /\r\n> -10  5\r\n> ```\r\n### 思路\r\nDFS\r\n\r\n### 代码\r\nclass Solution {\r\n\r\n    /**\r\n     * @param ListNode $head\r\n     * @return TreeNode\r\n     */\r\n\r\n    function sortedListToBST($head) {\r\n        return $this->dfs($head, null);\r\n    }\r\n\r\n    private function dfs($head, $tail)\r\n    {\r\n        if ($head === $tail) return null;\r\n        $slow = $fast = $head;\r\n        while ($fast != $tail && $fast->next != $tail) {\r\n            $slow = $slow->next;\r\n            $fast = $fast->next->next;\r\n        }\r\n\r\n        $root = new TreeNode($slow->val);\r\n        $root->left = $this->dfs($head, $slow);\r\n        $root->right = $this->dfs($slow->next, $tail);\r\n        return $root;\r\n    }\r\n\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844070733","body":"> # 160. 相交链表\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n> \r\n> ## 前置知识\r\n> * 链表\r\n> * 双指针\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 编写一个程序，找到两个单链表相交的起始节点。\r\n> ```\r\n\r\n### 思路\r\n双指针，click click地跑\r\n\r\n### 代码\r\nclass Solution {\r\n    /**\r\n     * @param ListNode $headA\r\n     * @param ListNode $headB\r\n     * @return ListNode\r\n     */\r\n    function getIntersectionNode($headA, $headB) {\r\n        $A = $headA;\r\n        $B = $headB;\r\n        while ($A !== $B) {\r\n            $A = is_null($A) ? $headB : $A->next;\r\n            $B = is_null($B) ? $headA : $B->next;\r\n        }\r\n        \r\n        return $A;\r\n\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844629101","body":"> # 142. 环形链表 II\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/linked-list-cycle-ii/\r\n> \r\n> ## 前置知识\r\n> 暂无\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n> \r\n> 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\r\n> \r\n> 说明：不允许修改给定的链表。\r\n> \r\n> 进阶：\r\n> \r\n> 你是否可以使用 O(1) 空间解决此题？\r\n> ```\r\n\r\n### 思路\r\n快慢指针\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\n    /**\r\n     * @param ListNode $head\r\n     * @return ListNode\r\n     */\r\n    function detectCycle($head) {\r\n        $fast = $slow = $head;\r\n        while (true) {\r\n            if ($fast === null || $fast->next === null) return null;\r\n            $fast = $fast->next->next;\r\n            $slow = $slow->next;\r\n            if ($fast === $slow) break;\r\n        }\r\n\r\n        $fast = $head;\r\n        while ($fast !== $slow) {\r\n            $fast= $fast->next;\r\n            $slow = $slow->next;\r\n        }\r\n        return $fast;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RealDuxy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838328793","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n#### 思路：\r\n\r\n暴力等等方法很简答，我们尝试双指针方法。\r\n构建result数组，由左向右遍历一遍，记录右边离你最近的c字符的距离，遍历 i 时可以利用已经完成的 i-1的结果。\r\n\r\n遍历完毕后，我们由右向左遍历，相当于比较左边和右边最近的c字符的距离哪个更小，取最小的来替代result[i]\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = [math.inf] * len(s)\r\n        # 从左至右遍历一遍\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i > 0:\r\n                result[i] = result[i-1] + 1\r\n       \r\n        # 从右至左\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n            elif i < len(s)-1:\r\n                result[i] = min(result[i+1]+1, result[i])\r\n        return result\r\n```\r\n\r\n\r\n\r\n#### 复杂度分析:\r\n\r\n时间复杂度：\r\n\r\n两次遍历都是N次迭代，每次迭代都是常数操作，显然是O(N)\r\n\r\n空间复杂度:\r\n\r\n除了result外，没有构建额外的数组，均在result原地操作，故O(1)\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841211519","body":"## Day 5 [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n### 思路：\r\n\r\n利用两个栈和一个栈顶指针\r\n\r\n栈一用于存储队列元素，但是栈的存储顺序是与队列相反的，所以需要栈二来做一个逆序。\r\n\r\n输出和判断空时候直接按照栈一的正常操作即可。\r\n\r\n注意在pop的时候要注意更新栈顶\r\n\r\n### 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.第一个栈 = []\r\n        self.第二个栈 = []\r\n        self.栈顶 = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if not self.第一个栈:\r\n            self.第一个栈.append(x)\r\n            self.栈顶 = x\r\n        else:\r\n            while self.第一个栈:\r\n                self.第二个栈.append(self.第一个栈.pop())\r\n            self.第一个栈.append(x)\r\n            while self.第二个栈:\r\n                self.第一个栈.append(self.第二个栈.pop())\r\n        \r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        旧栈顶 = self.第一个栈.pop()\r\n        if self.第一个栈:\r\n            self.栈顶 = self.第一个栈[-1]\r\n        else:\r\n            self.栈顶 = -1\r\n        return 旧栈顶\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.栈顶\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.第一个栈\r\n\r\n```\r\n\r\n### 复杂度分析：\r\n\r\n时间：push操作，需要做两次栈之间的转移，复杂度为O（N），其余的操作明显为O（1）\r\n\r\n空间: 额外空间O（N）两个栈，一个指针"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645360","body":"### [768. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n#### 思路：\r\n\r\n定义好排序快，根据排序块确定遍历规则\r\n\r\n#### 代码 python\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for x in arr:\r\n            if stack and x < stack[-1]: # stack[-1]为所有排序块的最大head\r\n                # 记录下当前最大的排序块head\r\n                # x < head说明这个x使得之前的head都不在有效，因此成为了新的排序块右边界\r\n                # 现在需要为其确定包含x的最大head，因此就在stack里面找到最大的小于等于x的head\r\n                # 找到后再将head放回stack里面 \r\n                head = stack.pop()\r\n                while stack and x < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                # x隶属于最大head的排序块\r\n                stack.append(x)\r\n        return len(stack)\r\n```\r\n\r\n\r\n\r\n#### 复杂度：\r\n\r\n遍历n次，极端情况下，一次遍历需要将stack内全部的head弹出，但是stack总共弹出的次数也不会超过N次，因此时间复杂度O（N）。\r\n\r\n借助了栈的额外空间，最多存储arr所有元素，O（N）。"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaofaqian":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838329911","body":"## 思路\r\n双指针吧 从当前位置开始比对 然后往左偏移往比对往右偏移比对\r\n## 代码\r\n```\r\nSarr := []byte{}\r\n\tSP := []int{}\r\n\tfor _, v := range s {\r\n\t\tSarr = append(Sarr, byte(v))\r\n\t}\r\n\tfor i := 0; i < len(Sarr); i++ {\r\n\t\tstep := 0\r\n\r\n\t\tfor true {\r\n\t\t\tif i+step < len(Sarr) && Sarr[i+step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i-step >= 0 && Sarr[i-step] == c {\r\n\t\t\t\tSP = append(SP, step)\r\n\t\t\t\tstep = 1\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tstep++\r\n\t\t}\r\n\t}\r\n\treturn SP\r\n```\r\n## 复杂度\r\n- 时间复杂度 O(n2)\r\n- 空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839512591","body":"## 思路\r\n## 代码\r\n```type CustomStack struct {\r\n\tmaxSize  int\r\n\tstackLen int\r\n\tstack    []int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\treturn CustomStack{maxSize, 0, []int{}}\r\n}\r\n\r\nfunc (this *CustomStack) Push(x int) {\r\n\t//满了就不加了\r\n\tif this.maxSize == this.stackLen {\r\n\t\treturn\r\n\t}\r\n\t//添加一个元素并且栈长度加1\r\n\tthis.stack = append(this.stack, x)\r\n\tthis.stackLen++\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n\tif this.stackLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tpopValue := this.stack[this.stackLen-1]\r\n\tthis.stackLen--\r\n\tthis.stack = this.stack[:this.stackLen]\r\n\treturn popValue\r\n}\r\n\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tif k > this.stackLen {\r\n\t\tk = this.stackLen\r\n\t}\r\n\tfor i := 0; i < k; i++ {\r\n\t\tthis.stack[i] = this.stack[i] + val\r\n\t}\r\n}\r\n\r\n```\r\n## 复杂度\r\n- 时间复杂度 push/pop O(1) 元素加数 ）O(k)\r\n- 空间复杂度 O(maxSize)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841278444","body":"## 思路\r\n## 代码\r\n```\r\ntype MyQueue struct {\r\n\tqueueLen int\r\n\tqueue    []int\r\n}\r\n\r\n/** Initialize your data structure here. */\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{0, []int{}}\r\n}\r\n\r\n/** Push element x to the back of queue. */\r\nfunc (this *MyQueue) Push(x int) {\r\n\tthis.queue = append(this.queue, x)\r\n\tthis.queueLen++\r\n}\r\n\r\n/** Removes the element from in front of queue and returns that element. */\r\nfunc (this *MyQueue) Pop() int {\r\n\tif this.queueLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tval := this.queue[0]\r\n\tthis.queueLen--\r\n\tthis.queue = this.queue[1:]\r\n\treturn val\r\n}\r\n\r\n/** Get the front element. */\r\nfunc (this *MyQueue) Peek() int {\r\n\tif this.queueLen == 0 {\r\n\t\treturn -1\r\n\t}\r\n\treturn this.queue[0]\r\n}\r\n\r\n/** Returns whether the queue is empty. */\r\nfunc (this *MyQueue) Empty() bool {\r\n\tif this.queueLen == 0 {\r\n\t\treturn true\r\n\t}\r\n\treturn false\r\n}\r\n```\r\n## 复杂度\r\n- 时间复杂度 $O(1)$\r\n- 空间复杂度 $O(n)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838409646","body":"# 821.字符的最短距离\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n- [821.字符的最短距离](#821字符的最短距离)\r\n  - [题目描述](#题目描述)\r\n  - [解法 1：中心扩展法](#解法-1中心扩展法)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码 (JS/C++)](#代码-jsc)\r\n  - [解法 2：空间换时间](#解法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码 (JS/C++)](#代码-jsc-1)\r\n  - [解法 3：贪心](#解法-3贪心)\r\n    - [思路](#思路-2)\r\n    - [复杂度分析](#复杂度分析-2)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython)\r\n  - [解法 4：窗口](#解法-4窗口)\r\n    - [思路](#思路-3)\r\n    - [复杂度分析](#复杂度分析-3)\r\n    - [代码 (JS/C++/Python)](#代码-jscpython-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n\r\n示例 1:\r\n\r\n输入: S = \"loveleetcode\", C = 'e'\r\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n说明:\r\n\r\n字符串 S 的长度范围为 [1, 10000]。\r\nC 是一个单字符，且保证是字符串 S 里的字符。\r\nS 和 C 中的所有字母均为小写字母。\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 解法 1：中心扩展法\r\n\r\n### 思路\r\n\r\n这是最符合直觉的思路，对每个字符分别进行如下处理：\r\n\r\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\r\n- 只在一个方向找到的话，直接计算字符距离。\r\n- 两个方向都找到的话，取两个距离的最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_0.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(0);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 如果当前是目标字符，就什么都不用做\r\n    if (S[i] === C) continue;\r\n\r\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\r\n    let l = i,\r\n      r = i,\r\n      shortest = Infinity;\r\n\r\n    while (l >= 0) {\r\n      if (S[l] === C) {\r\n        shortest = Math.min(shortest, i - l);\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    while (r < S.length) {\r\n      if (S[r] === C) {\r\n        shortest = Math.min(shortest, r - i);\r\n        break;\r\n      }\r\n      r++;\r\n    }\r\n\r\n    res[i] = shortest;\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        vector<int> res(S.length());\r\n\r\n        for (int i = 0; i < S.length(); i++) {\r\n            if (S[i] == C) continue;\r\n\r\n            int left = i;\r\n            int right = i;\r\n            int dist = 0;\r\n\r\n            while (left >= 0 || right <= S.length() - 1) {\r\n                if (S[left] == C) {\r\n                    dist = i - left;\r\n                    break;\r\n                }\r\n                if (S[right] == C) {\r\n                    dist = right - i;\r\n                    break;\r\n                }\r\n\r\n                if (left > 0) left--;\r\n                if (right < S.length() - 1) right++;\r\n            }\r\n\r\n            res[i] = dist;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 2：空间换时间\r\n\r\n### 思路\r\n\r\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\r\n\r\n因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\r\n\r\n然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，$K <= N$。\r\n- 空间复杂度：$O(K)$，K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\r\n\r\n### 代码 (JS/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 记录 C 字符在 S 字符串中出现的所有下标\r\n  var cIndices = [];\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) cIndices.push(i);\r\n  }\r\n\r\n  // 结果数组 res\r\n  var res = Array(S.length).fill(Infinity);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 目标字符，距离是 0\r\n    if (S[i] === C) {\r\n      res[i] = 0;\r\n      continue;\r\n    }\r\n\r\n    // 非目标字符，到下标数组中找最近的下标\r\n    for (const cIndex of cIndices) {\r\n      const dist = Math.abs(cIndex - i);\r\n\r\n      // 小小剪枝一下\r\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\r\n      if (dist >= res[i]) break;\r\n\r\n      res[i] = dist;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> c_indices;\r\n        // Initialize a vector of size n with default value n.\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) c_indices.push_back(i);\r\n        }\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            for (int j = 0; j < c_indices.size(); j++) {\r\n                int dist = abs(c_indices[j] - i);\r\n                if (dist > res[i]) break;\r\n                res[i] = dist;\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n## 解法 3：贪心\r\n\r\n### 思路\r\n\r\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\r\n\r\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\r\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\r\n3. 然后同时遍历这两个数组，计算距离最小值。\r\n\r\n**优化 1**\r\n\r\n再多想一步，其实第二个数组并不需要。因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\r\n\r\n1. 字符左侧没有出现过 `C` 字符\r\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\r\n\r\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\r\n\r\n**优化 2**\r\n\r\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  // 第一次遍历：从左往右\r\n  // 找到出现在左侧的 C 字符的最后下标\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = i;\r\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\r\n  }\r\n\r\n  // 第二次遍历：从右往左\r\n  // 找出现在右侧的 C 字符的最后下标\r\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\r\n  }\r\n\r\n  // 计算距离\r\n  for (let i = 0; i < res.length; i++) {\r\n    res[i] = Math.abs(res[i] - i);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n**直接计算距离：**\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  var res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    if (S[i] === C) res[i] = 0;\r\n    // 记录距离：res[i - 1] + 1\r\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\r\n  }\r\n\r\n  for (let i = S.length - 1; i >= 0; i--) {\r\n    // 更新距离：res[i + 1] + 1\r\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n        vector<int> dist(n, n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            if (S[i] == C) dist[i] = 0;\r\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\r\n        }\r\n\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (dist[i] == n\r\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\r\n                    dist[i] = dist[i + 1] + 1;\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n```\r\n\r\n## 解法 4：窗口\r\n\r\n### 思路\r\n\r\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/821_1.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 是 S 的长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码 (JS/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string S, char C) {\r\n        int n = S.length();\r\n\r\n        int l = S[0] == C ? 0 : n;\r\n        int r = S.find(C, 1);\r\n\r\n        vector<int> dist(n);\r\n\r\n        for (int i = 0; i < n; i++) {\r\n            dist[i] = min(abs(i - l), abs(r - i));\r\n            if (i == r) {\r\n                l = r;\r\n                r = S.find(C, r + 1);\r\n            }\r\n        }\r\n\r\n        return dist;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        res = [0 for _ in range(n)]\r\n\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 1)\r\n\r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            if i == r:\r\n                l = r\r\n                r = s.find(c, l + 1)\r\n        return res\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841011668","body":"# 232.用栈实现队列\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n- [232.用栈实现队列](#232用栈实现队列)\r\n  - [题目描述](#题目描述)\r\n  - [方法 1](#方法-1)\r\n    - [思路](#思路)\r\n    - [复杂度](#复杂度)\r\n    - [代码](#代码)\r\n  - [方法 2](#方法-2)\r\n    - [思路](#思路-1)\r\n    - [复杂度](#复杂度-1)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n\r\n## 题目描述\r\n\r\n```\r\n使用栈实现队列的下列操作：\r\n\r\npush(x) -- 将一个元素放入队列的尾部。\r\npop() -- 从队列首部移除元素。\r\npeek() -- 返回队列首部的元素。\r\nempty() -- 返回队列是否为空。\r\n示例:\r\n\r\nMyQueue queue = new MyQueue();\r\n\r\nqueue.push(1);\r\nqueue.push(2);\r\nqueue.peek();  // 返回 1\r\nqueue.pop();   // 返回 1\r\nqueue.empty(); // 返回 false\r\n说明:\r\n\r\n你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\r\n\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/implement-queue-using-stacks\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 方法 1\r\n\r\n### 思路\r\n\r\n由于队列是 FIFI (先进先出)，而栈是 FILO (先进后出)。如果要用栈来模拟队列，则每次往模拟队列增加元素的时候，这个元素需要放在栈底，因为它是最后才会出列。\r\n\r\n方法之一是，每次需要往模拟队列尾端 `push` 一个新元素时：\r\n\r\n- 先把栈中的全部元素暂时取出\r\n- 将新元素入栈到栈底\r\n- 再将刚刚取出来元素重新入栈\r\n\r\n因此我们还需要一个辅助栈来存暂时取出来的元素。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：入列操作是 $O(n)$，每次入列时，除新增元素外，每个元素都需要分别出栈入栈 2 次 (从模拟队列的栈中弹出，压入辅助栈，再从辅助栈弹出，压入队列模拟栈)。压入、弹出操作的时间复杂度都是 $O(1)$，所以总的时间复杂度差不多是 $O(4n)$，忽略掉常数，最后得到 $O(n)$。出列操作是 $O(1)$。\r\n-   空间复杂度：$O(n)$，n 是队列的大小，需要一个大小为 n 的栈来模拟队列，还需要一个大小为 n 的辅助空间，但总的空间复杂度还是 $O(n)$。\r\n\r\n### 代码\r\n\r\nJavaScript Code\r\n\r\n```js\r\nclass MyQueue {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n\r\n    push(x) {\r\n        const helper = [];\r\n        while (!this.empty()) {\r\n            helper.push(this.stack.pop());\r\n        }\r\n        this.stack.push(x);\r\n        while (helper.length) {\r\n            this.stack.push(helper.pop());\r\n        }\r\n    }\r\n\r\n    peek() {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    empty() {\r\n        return this.stack.length === 0;\r\n    }\r\n}\r\n```\r\n\r\n## 方法 2\r\n\r\n### 思路\r\n\r\n方法 1 是在元素入列的时候，就考虑好了它出列的顺序，但我们还可以转换一下思路，在元素需要出列的时候再来考虑这个问题，这样的话：\r\n\r\n1. 入列时，直接 `push` 到栈中；\r\n2. 出列时，由于先入列的元素在栈底，需要先把其他元素弹出，依次压入辅助栈；\r\n3. 栈底元素弹出，出列；\r\n4. 刚才出栈的其他元素依次从辅助栈弹出，重新压入模拟栈。\r\n\r\n再仔细想想的话：\r\n\r\n-   第 2 步中，辅助栈中的元素出栈顺序刚好就是队列的出列顺序；\r\n-   所以到第 4 步的时候，我们根本没必要把元素再从辅助栈转移到模拟栈；\r\n-   下一次 `pop` 操作时，直接从辅助栈弹出元素就可以了；\r\n-   如果辅助栈中没有元素了，我们再重复第 2 步。\r\n\r\n这样的话，我们的队列元素其实是用了两个栈来储存，所以在判断队列是否为空的时候，两个栈都要考虑进去。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：入列是 $O(1)$，出列最差的情况就是每个元素都要从模拟栈中弹出，压入辅助栈，再从辅助栈中弹出，所以是 $O(n)$。\r\n-   空间复杂度：$O(n)$，n 为队列大小。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\nclass MyQueue {\r\n    constructor() {\r\n        this.stack = new MyStack();\r\n        this.helper = new MyStack();\r\n    }\r\n\r\n    push(x) {\r\n        this.stack.push(x);\r\n    }\r\n\r\n    peek() {\r\n        if (this.helper.empty()) {\r\n            while (!this.stack.empty()) {\r\n                this.helper.push(this.stack.pop());\r\n            }\r\n        }\r\n        return this.helper.peek();\r\n    }\r\n\r\n    pop() {\r\n        if (this.helper.empty()) {\r\n            while (!this.stack.empty()) {\r\n                this.helper.push(this.stack.pop());\r\n            }\r\n        }\r\n        return this.helper.pop();\r\n    }\r\n\r\n    empty() {\r\n        return this.stack.empty() && this.helper.empty();\r\n    }\r\n}\r\n\r\nclass MyStack {\r\n    constructor() {\r\n        this.stack = [];\r\n    }\r\n    push(x) {\r\n        this.stack.push(x);\r\n    }\r\n    pop() {\r\n        return this.stack.pop();\r\n    }\r\n    peek() {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n    empty() {\r\n        return this.stack.length === 0;\r\n    }\r\n}\r\n```\r\n\r\nC++ Code\r\n```cpp\r\n#include <stack>\r\nusing namespace std;\r\n\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> stack_in_;\r\n    stack<int> stack_out_;\r\n    void pour_to_stack_out_() {\r\n        while (!stack_in_.empty()) {\r\n            int top = stack_in_.top();\r\n            stack_in_.pop();\r\n            stack_out_.push(top);\r\n        }\r\n    };\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stack_in_.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (stack_out_.empty()) { \r\n            pour_to_stack_out_();\r\n        }\r\n        int top = stack_out_.top();\r\n        stack_out_.pop();\r\n        return top;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (stack_out_.empty()) { \r\n            pour_to_stack_out_();\r\n        }\r\n        return stack_out_.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stack_in_.empty() && stack_out_.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841804188","body":"## 方法1\r\n\r\n### 思路\r\n\r\n将链表闭环，从头部开始走 n-k 步，n 为链表长度，然后断开。\r\n\r\n### 代码\r\n\r\nC++ Code\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr \r\n            || head->next == nullptr \r\n            || k == 0) \r\n            return head;\r\n        \r\n        int n = 1;\r\n        ListNode* cur = head;\r\n        while (cur->next != nullptr) {\r\n            cur = cur->next;\r\n            n++;\r\n        }\r\n        cur->next = head;\r\n        k = n - k % n;\r\n        while (k--) {\r\n            cur = cur->next;\r\n        }\r\n        ListNode* new_head = cur-> next;\r\n        cur->next = nullptr;\r\n        return new_head;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841938273","body":"# 24. 两两交换链表中的节点\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n- [24. 两两交换链表中的节点](#24-两两交换链表中的节点)\r\n  - [题目描述](#题目描述)\r\n  - [方法 1: 迭代](#方法-1-迭代)\r\n    - [图解](#图解)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n  - [方法 2: 递归](#方法-2-递归)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码(JavaScript/C++)](#代码javascriptc-1)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n\r\n示例 1：\r\n\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/swap-nodes-in-pairs\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 方法 1: 迭代\r\n\r\n### 图解\r\n\r\n- 要注意指针改变的顺序，不然可能会丢失节点。\r\n- 用一个 dummy 节点来简化操作，不用额外考虑链表头部的情况。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/07.swap-nodes-in-pairs-02.png)\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$, N 为链表长度。\r\n- 空间复杂度：$O(1)$。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n  const dummy = new ListNode(null, head);\r\n  let prev = dummy;\r\n  let cur = prev.next;\r\n\r\n  while (cur && cur.next) {\r\n    // 按照上图，指针更换顺序是这样子的\r\n    // prev.next = cur.next\r\n    // cur.next = prev.next.next\r\n    // prev.next.next = cur\r\n\r\n    // 也可以先用一个指针把下一个节点存起来\r\n    const next = cur.next;\r\n    cur.next = next.next;\r\n    next.next = cur;\r\n    prev.next = next;\r\n\r\n    prev = cur;\r\n    cur = cur.next;\r\n  }\r\n  return dummy.next;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) return head;\r\n\r\n        ListNode* dummy = new ListNode(0, head);\r\n        ListNode* prev = dummy;\r\n        ListNode* cur = prev->next;\r\n\r\n        while (cur != nullptr && cur->next != nullptr) {\r\n            ListNode* next = cur->next;\r\n            cur->next = next->next;\r\n            next->next = cur;\r\n            prev->next = next;\r\n\r\n            prev = cur;\r\n            cur = cur->next;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```\r\n\r\n## 方法 2: 递归\r\n\r\n### 思路\r\n\r\n“将相邻的链表节点两两交换”，我们可以把链表两两分成若干组，在组内互换节点后再组合起来。\r\n\r\n先解决小问题，再把小问题的解组合起来，解决大问题。\r\n\r\n**小问题**\r\n\r\n只要关注当前递归要解决的问题就行，前后都可以当成是黑匣子。在当前递归中，我们只需要将两个节点互换。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/07.swap-nodes-in-pairs-00.png)\r\n\r\n**小问题之间的关系**\r\n\r\n- 下一个递归应该返回互换后的第一个节点\r\n- 当前递归应该返回互换后的第一个节点给上一个递归\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/07.swap-nodes-in-pairs-01.png)\r\n\r\n**递归出口**\r\n\r\n- 链表尾部 `head === null`\r\n- 链表最后只剩下一个元素 `head.next === null`\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$, N 为链表长度。\r\n- 空间复杂度：$O(N)$, N 为链表长度，递归栈的空间。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n  // 递归出口\r\n  if (!head || !head.next) return head;\r\n\r\n  // 先保存下一个节点，避免丢失\r\n  const next = head.next;\r\n\r\n  // 下一个递归会返回互换后的第一个节点\r\n  // head 是当前组互换后的第二个节点，head.next 指向下一组就好\r\n  head.next = swapPairs(next.next);\r\n\r\n  // 将当前组的两个节点互换\r\n  next.next = head;\r\n\r\n  // 返回互换后的第一个节点\r\n  return next;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) return head;\r\n\r\n        ListNode* first = head;\r\n        ListNode* second = first->next;\r\n\r\n        ListNode* head_of_next_group = swapPairs(second->next);\r\n\r\n        first->next = head_of_next_group;\r\n        second->next = first;\r\n\r\n        return second;\r\n    }\r\n};\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842751905","body":"# 109. 有序链表转换二叉搜索树\r\n\r\n- [109. 有序链表转换二叉搜索树](#109-有序链表转换二叉搜索树)\r\n  - [题目描述](#题目描述)\r\n  - [方法 1：递归](#方法-1递归)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [代码(JavaScript/C++/Python)](#代码javascriptcpython)\r\n  - [方法 2：空间换时间](#方法-2空间换时间)\r\n    - [思路](#思路-1)\r\n    - [复杂度分析](#复杂度分析-1)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 方法 1：递归\r\n\r\n### 思路\r\n\r\n- 先用快慢指针找到中间节点\r\n- 分治构建平衡二叉树\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(NlogN)$，N 为链表长度。\r\n- 空间复杂度：$O(logN)$，N 为链表长度。\r\n\r\n### 代码(JavaScript/C++/Python)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function (head, tail = null) {\r\n  if (!head || head === tail) return null;\r\n\r\n  let slow = head,\r\n    fast = head;\r\n  while (fast !== tail && fast.next !== tail) {\r\n    slow = slow.next;\r\n    fast = fast.next.next;\r\n  }\r\n\r\n  const root = new TreeNode(slow.val);\r\n  root.left = sortedListToBST(head, slow);\r\n  root.right = sortedListToBST(slow.next, tail);\r\n  return root;\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (head == nullptr) return nullptr;\r\n        return sortedListToBST(head, nullptr);\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\r\n        if (head == tail) return nullptr;\r\n\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n\r\n        while (fast != tail && fast->next != tail) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(slow->val);\r\n        root->left = sortedListToBST(head, slow);\r\n        root->right = sortedListToBST(slow->next, tail);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\nPython Code\r\n\r\n```py\r\n# Definition for singly-linked list.\r\n# class ListNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\n# Definition for a binary tree node.\r\n# class TreeNode(object):\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.left = None\r\n#         self.right = None\r\n\r\nclass Solution(object):\r\n    def sortedListToBST(self, head):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :rtype: TreeNode\r\n        \"\"\"\r\n        if not head: return None\r\n        prev, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        root = TreeNode(slow.val)\r\n        if slow == fast: return root\r\n\r\n        if prev: prev.next = None\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n\r\n## 方法 2：空间换时间\r\n\r\n### 思路\r\n\r\n由于寻找链表中点的时间复杂度是 $O(N)$，如果事先使用数组将链表的值存储起来，寻找中点就变成了 $O(1)$ 时间的操作，代价则是 $O(N)$ 的额外空间，问题转换成了**将有序数组转换成搜索二叉树**。\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：$O(N)$，N 为链表长度。\r\n- 空间复杂度：$O(N)$，N 为链表长度。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null;\r\n\r\n  const nodes = [];\r\n  while (head) {\r\n    nodes.push(head.val);\r\n    head = head.next;\r\n  }\r\n\r\n  return sortedArrayToBST(nodes, 0, nodes.length);\r\n\r\n  // ********************************************\r\n  function sortedArrayToBST(array, start, end) {\r\n    if (start >= end) return null;\r\n\r\n    const mid = (((end - start) >> 1) >> 0) + start;\r\n    const root = new TreeNode(array[mid]);\r\n    root.left = sortedArrayToBST(array, start, mid);\r\n    root.right = sortedArrayToBST(array, mid + 1, end);\r\n    return root;\r\n  }\r\n};\r\n```\r\n\r\nC++ Code\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<int> nodes;\r\n        while (head != nullptr) {\r\n            nodes.push_back(head->val);\r\n            head = head->next;\r\n        }\r\n        return sortedListToBST(nodes, 0, nodes.size());\r\n    }\r\n    TreeNode* sortedListToBST(vector<int>& nodes, int start, int end) {\r\n        if (start >= end) return nullptr;\r\n\r\n        int mid = (end - start) / 2 + start;\r\n        TreeNode* root = new TreeNode(nodes[mid]);\r\n        root->left = sortedListToBST(nodes, start, mid);\r\n        root->right = sortedListToBST(nodes, mid + 1, end);\r\n        return root;\r\n    }\r\n};\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843687389","body":"# 160.相交链表\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists\r\n\r\n- [160.相交链表](#160相交链表)\r\n  - [题目描述](#题目描述)\r\n  - [方法 1：暴力法](#方法-1暴力法)\r\n    - [思路](#思路)\r\n    - [复杂度](#复杂度)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n  - [方法 2：哈希表](#方法-2哈希表)\r\n    - [思路](#思路-1)\r\n    - [复杂度](#复杂度-1)\r\n    - [代码(JavaScript/C++)](#代码javascriptc-1)\r\n  - [方法 3：双指针](#方法-3双指针)\r\n    - [思路](#思路-2)\r\n    - [复杂度](#复杂度-2)\r\n    - [代码(JavaScript/C++)](#代码javascriptc-2)\r\n\r\n## 题目描述\r\n\r\n```\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists\r\n```\r\n\r\n## 方法 1：暴力法\r\n\r\n### 思路\r\n\r\n对于链表 A 的每个节点，都去链表 B 中遍历一遍找看看有没有相同的节点。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：$O(M * N)$, M, N 分别为两个链表的长度。\r\n-   空间复杂度：$O(1)$。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA;\r\n    while (pA) {\r\n        let pB = headB;\r\n\r\n        while (pB) {\r\n            if (pA === pB) return pA;\r\n            pB = pB.next;\r\n        }\r\n\r\n        pA = pA.next;\r\n    }\r\n};\r\n```\r\n\r\nC++ Code\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL) return NULL;\r\n\r\n        ListNode *pA = headA;\r\n\r\n        while (pA != NULL) {\r\n            ListNode *pB = headB;\r\n            while (pB != NULL) {\r\n                if (pA == pB) {\r\n                    return pA;\r\n                }\r\n                pB = pB->next;\r\n            }\r\n            pA = pA->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n## 方法 2：哈希表\r\n\r\n### 思路\r\n\r\n-   先遍历一遍链表 A，用哈希表把每个节点都记录下来(注意要存节点引用而不是节点值)。\r\n-   再去遍历链表 B，找到在哈希表中出现过的节点即为两个链表的交点。\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：$O(M + N)$, M, N 分别为两个链表的长度。\r\n-   空间复杂度：$O(N)$，N 为链表 A 的长度。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    const hashmap = new Map();\r\n\r\n    let pA = headA;\r\n    while (pA) {\r\n        hashmap.set(pA, 1);\r\n        pA = pA.next;\r\n    }\r\n\r\n    let pB = headB;\r\n    while (pB) {\r\n        if (hashmap.has(pB)) return pB;\r\n        pB = pB.next;\r\n    }\r\n};\r\n```\r\n\r\nC++ Code\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL) return NULL;\r\n\r\n        map<ListNode*, bool> seen;\r\n        while (headA) {\r\n            seen.insert(pair<ListNode*, bool>(headA, true));\r\n            headA = headA->next;\r\n        }\r\n        while (headB) {\r\n            if (seen.find(headB) != seen.end()) return headB;\r\n            headB = headB->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n## 方法 3：双指针\r\n\r\n### 思路\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/intersection_of_linked_lists.png)\r\n\r\n**如果链表有交点**\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/intersection_of_linked_lists_1.png)\r\n\r\n**如果链表没有交点**\r\n\r\n1. 两个链表长度一样，第一次遍历结束后 pA 和 pB 都是 null，结束遍历\r\n2. 两个链表长度不一样，两次遍历结束后 pA 和 pB 都是 null，结束遍历\r\n\r\n### 复杂度\r\n\r\n-   时间复杂度：$O(M + N)$, M, N 分别为两个链表的长度。\r\n-   空间复杂度：$O(1)$。\r\n\r\n### 代码(JavaScript/C++)\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA,\r\n        pB = headB;\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next;\r\n        pB = pB === null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```\r\n\r\nC++ Code\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if (headA == NULL || headB == NULL) return NULL;\r\n\r\n        ListNode* pA = headA;\r\n        ListNode* pB = headB;\r\n        while (pA != pB) {\r\n            pA = pA == NULL ? headB : pA->next;\r\n            pB = pB == NULL ? headA : pB->next;\r\n        }\r\n\r\n        return pA;\r\n    }\r\n};\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844745943","body":"C++ Code\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode *slow = head;\r\n        ListNode *fast = head;\r\n\r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (slow == fast) {\r\n                fast = head;\r\n                while (slow != fast) {\r\n                    slow = slow->next;\r\n                    fast = fast->next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n\r\n```cpp\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        set<ListNode*> seen;\r\n        ListNode *cur = head;\r\n        while (cur != NULL) {\r\n            if (seen.find(cur) != seen.end()) return cur;\r\n            seen.insert(cur);\r\n            cur = cur->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845593112","body":"# 146. LRU 缓存机制\r\n\r\nhttps://leetcode-cn.com/problems/lru-cache/\r\n\r\n- [146. LRU 缓存机制](#146-lru-缓存机制)\r\n  - [题目描述](#题目描述)\r\n  - [方法1: 哈希表+双向链表](#方法1-哈希表双向链表)\r\n    - [思路](#思路)\r\n    - [复杂度分析](#复杂度分析)\r\n    - [伪代码](#伪代码)\r\n    - [代码(JavaScript/C++)](#代码javascriptc)\r\n\r\n## 题目描述\r\n\r\n```\r\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。\r\n\r\n获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。\r\n写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\r\n\r\n进阶:\r\n\r\n你是否可以在 O(1) 时间复杂度内完成这两种操作？\r\n\r\n示例:\r\n\r\nLRUCache cache = new LRUCache( 2 /* 缓存容量 */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // 返回  1\r\ncache.put(3, 3);    // 该操作会使得关键字 2 作废\r\ncache.get(2);       // 返回 -1 (未找到)\r\ncache.put(4, 4);    // 该操作会使得关键字 1 作废\r\ncache.get(1);       // 返回 -1 (未找到)\r\ncache.get(3);       // 返回  3\r\ncache.get(4);       // 返回  4\r\n\r\n来源：力扣（LeetCode）\r\n链接：https://leetcode-cn.com/problems/lru-cache\r\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n```\r\n\r\n## 方法1: 哈希表+双向链表\r\n\r\n### 思路\r\n\r\n先来看个非计算机的例子理解下题意，假设我们有一个玩具摊位，可以向顾客展示小玩具。玩具很多，但摊位大小有限，不能一次性展示所有玩具，于是我们就把大部分的玩具都放在了仓库里。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_0.png)\r\n\r\n如果有顾客来询问某个玩具，我们就去仓库把那个玩具拿出来，摆在摊位上。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_1.png)\r\n\r\n因为摊位最上面的位置最显眼，所以我们总是把最新拿出来的玩具放在那。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_2.png)\r\n\r\n不过由于摊位大小有限，很快就摆满了，这时如果又来了顾客想看新玩具。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_3.png)\r\n\r\n我们只能把摊位最下面的玩具拿回仓库(因为最下面的位置相对没那么受欢迎)，然后其他玩具往下移，腾出最上面的位置来放新玩具。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_4.png)\r\n\r\n如果顾客想看的玩具就摆在摊位上，我们就可以把这个玩具直接移到摊位最上面的位置，其他的玩具就要往下挪挪位置了。还记得我们的规则吧，最近有人询问的玩具要摆在最上面显眼的位置。\r\n\r\n![](https://cdn.jsdelivr.net/gh/suukii/91-days-algorithm/assets/LRU_5.png)\r\n\r\n回到计算机问题上面来，玩具摊位代表的就是缓存空间，我们需要考虑的问题是使用哪种数据结构来表示玩具摊位。\r\n\r\n**选择1: 数组**\r\n\r\n如果选择数组，因为玩具在摊位上的位置会挪来挪去，时间复杂度是 $O(N)$，不符合题意。\r\n\r\n**选择2: 链表**\r\n\r\n- 如果选择链表，我们知道在已知位置上新增节点，或者移除一个已知节点的时间复杂度是 $O(1)$。不过，链表查找节点的时间复杂度是 $O(N)$，同样不符合题意，但这还有办法补救。\r\n- 在玩具摊位的例子中，我们手动移动玩具的时候，只需要看一眼就知道要找的玩具在哪个位置上，但计算机没那么聪明，因此还需要给它一个脑子(哈希表)来记录什么玩具在什么位置上，也就是要用一个哈希表来记录每个 key 对应的链表节点引用。这样查找链表节点的时间复杂度就降到了 $O(1)$，不过代价是空间复杂度增加到了 $O(N)$。\r\n- 另外，由于移除链表节点后还需要把该节点前后的两个节点连起来，因此我们需要的是双向链表而不是单向链表。\r\n\r\n### 复杂度分析\r\n\r\n-   时间复杂度：$O(1)$。\r\n-   空间复杂度：链表 $O(N)$，哈希表 $O(N)$，结果还是 $O(N)$，N 为容量大小。\r\n\r\n### 伪代码\r\n\r\n```\r\n// put\r\n\r\nif key 存在:\r\n    更新节点值\r\n    把节点移到链表头部\r\n\r\nelse:\r\n    if 缓存满了:\r\n        移除最后一个节点\r\n        删除它在哈希表中的映射\r\n\r\n    新建一个节点\r\n    把节点加到链表头部\r\n    在哈希表中增加映射\r\n\r\n\r\n// get\r\n\r\nif key 存在:\r\n    返回节点值\r\n    把节点移到链表头部\r\nelse:\r\n    返回 -1\r\n```\r\n\r\n### 代码(JavaScript/C++)\r\n\r\nJavaScript Code\r\n\r\n```js\r\nclass DoubleLinkedListNode {\r\n    constructor(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.prev = null;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    constructor(capacity) {\r\n        this.capacity = capacity;\r\n        // Mappings of key->node.\r\n        this.hashmap = {};\r\n        // Use two dummy nodes so that we don't have to deal with the head/tail seperately.\r\n        this.dummyHead = new DoubleLinkedListNode(null, null);\r\n        this.dummyTail = new DoubleLinkedListNode(null, null);\r\n        this.dummyHead.next = this.dummyTail;\r\n        this.dummyTail.prev = this.dummyHead;\r\n    }\r\n\r\n    _isFull() {\r\n        return Object.keys(this.hashmap).length === this.capacity;\r\n    }\r\n\r\n    _removeNode(node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        node.prev = null;\r\n        node.next = null;\r\n        return node;\r\n    }\r\n\r\n    _addToHead(node) {\r\n        const head = this.dummyHead.next;\r\n        node.next = head;\r\n        head.prev = node;\r\n        node.prev = this.dummyHead;\r\n        this.dummyHead.next = node;\r\n    }\r\n\r\n    get(key) {\r\n        if (key in this.hashmap) {\r\n            const node = this.hashmap[key];\r\n            this._addToHead(this._removeNode(node));\r\n            return node.value;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    put(key, value) {\r\n        if (key in this.hashmap) {\r\n            // If key exists, update the corresponding node and move it to the head.\r\n            const node = this.hashmap[key];\r\n            node.value = value;\r\n            this._addToHead(this._removeNode(node));\r\n        } else {\r\n            // If it's a new key.\r\n            if (this._isFull()) {\r\n                // If the cache is full, remove the tail node.\r\n                const node = this.dummyTail.prev;\r\n                delete this.hashmap[node.key];\r\n                this._removeNode(node);\r\n            }\r\n            // Create a new node and add it to the head.\r\n            const node = new DoubleLinkedListNode(key, value);\r\n            this.hashmap[key] = node;\r\n            this._addToHead(node);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\nC++ Code\r\n```cpp\r\nclass DLinkedListNode {\r\npublic:\r\n    int key;\r\n    int value;\r\n    DLinkedListNode *prev;\r\n    DLinkedListNode *next;\r\n    DLinkedListNode() : key(0), value(0), prev(NULL), next(NULL) {};\r\n    DLinkedListNode(int k, int val) : key(k), value(val), prev(NULL), next(NULL) {};\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) : capacity_(capacity) {\r\n        // 创建两个 dummy 节点来简化操作，这样就不用特殊对待头尾节点了\r\n        dummy_head_ = new DLinkedListNode();\r\n        dummy_tail_ = new DLinkedListNode();\r\n        dummy_head_->next = dummy_tail_;\r\n        dummy_tail_->prev = dummy_head_;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!key_exists_(key)) {\r\n            return -1;\r\n        }\r\n        // 1. 通过哈希表找到 key 对应的节点\r\n        // 2. 将节点移到链表头部\r\n        // 3. 返回节点值\r\n        DLinkedListNode *node = key_node_map_[key];\r\n        move_to_head_(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (key_exists_(key)) {\r\n            // key 存在的情况\r\n            DLinkedListNode *node = key_node_map_[key];\r\n            node->value = value;\r\n            move_to_head_(node);\r\n        } else {\r\n            // key 不存在的情况：\r\n            // 1. 如果缓存空间满了，先删除尾节点，再新建节点\r\n            // 2. 否则直接新建节点\r\n            if (is_full_()) {\r\n                DLinkedListNode *tail = dummy_tail_->prev;\r\n                remove_node_(tail);\r\n                key_node_map_.erase(tail->key);\r\n            }\r\n\r\n            DLinkedListNode *new_node = new DLinkedListNode(key, value);\r\n            add_to_head_(new_node);\r\n            key_node_map_[key] = new_node;\r\n        }\r\n    }\r\nprivate:\r\n    unordered_map<int, DLinkedListNode*> key_node_map_;\r\n    DLinkedListNode *dummy_head_;\r\n    DLinkedListNode *dummy_tail_;\r\n    int capacity_;\r\n\r\n    void move_to_head_(DLinkedListNode *node) {\r\n        remove_node_(node);\r\n        add_to_head_(node);\r\n    };\r\n\r\n    void add_to_head_(DLinkedListNode *node) {\r\n        DLinkedListNode *prev_head = dummy_head_->next;\r\n\r\n        dummy_head_->next = node;\r\n        node->prev = dummy_head_;\r\n\r\n        node->next = prev_head;\r\n        prev_head->prev = node;\r\n    };\r\n\r\n    void remove_node_(DLinkedListNode *node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n        node->prev = node->next = NULL;\r\n    };\r\n\r\n    bool key_exists_(int key) {\r\n        return key_node_map_.count(key) > 0;\r\n    };\r\n\r\n    bool is_full_() {\r\n        return key_node_map_.size() == capacity_;\r\n    };\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n\r\n更多题解可以访问：[https://github.com/suukii/91-days-algorithm](https://github.com/suukii/91-days-algorithm)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SWUFEzyf":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838418829","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        result = [0] * n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                result[i] = 0\r\n                continue\r\n            left = i-1\r\n            right = i + 1\r\n            while left >= 0 and s[left] != c:\r\n                left -= 1 \r\n            if left == -1:\r\n                left_distance = n\r\n            else:\r\n                left_distance = i - left\r\n            while right < n and s[right] != c:\r\n                right += 1\r\n            if right == n:\r\n                right_distance = n\r\n            else:\r\n                right_distance =  right - i\r\n            result[i] = min(left_distance, right_distance)\r\n        return result\r\n```\r\n复杂度分析\r\n时间复杂度：$O(N^2)$。\r\n空间复杂度：$O(N)$。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839596529","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.count = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.count < self.maxSize:\r\n            self.count += 1\r\n            self.stack.append(x)\r\n        else:\r\n            return \r\n\r\n    def pop(self) -> int:\r\n        if self.count == 0:\r\n            return -1\r\n        else:\r\n            self.count -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(self.count, k)):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842944033","body":"```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n        \r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        \r\n        root = TreeNode(slow.val)\r\n        pre.next = None\r\n\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n时间复杂度 O(n)\r\n空间复杂度 O(log n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shmilywh":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838419961","body":"\r\n## 题目分析\r\n\r\n- 字符串长度大于等于1\r\n- 均为小写字母\r\n- c至少出现一次\r\n\r\n## 思路\r\n\r\n 1. **【双指针】找c的位置，分情况讨论**\r\n\r\n    根据c出现的次数不同，计算相对位置的方式也略有出入，给定两个元素，一个是要计算相对位置的a，另一个是目标字符c，二者之间的位置我们可以分三种情况考虑\r\n\r\n    1) c只出现一次，且a在c的两侧\r\n\r\n    这时的相对距离，毋庸置疑应该等于 abs(index(a) - index(c))\r\n\r\n    2) c出现两次，且a在两个c的中间\r\n\r\n    这时的相对距离，应该计算a到两个c的距离然后取较小值\r\n\r\n    3) c出现三次或三次以上，我们可以拆分成上述两种情况来分别计算\r\n\r\n    代码：\r\n\r\n    定义两个指针，移动策略如下\r\n\r\n    - 一开始两指针均指向字符串头部\r\n    - 右指针向前移动，直到遇见一个c，这时满足情况1\r\n    - 更新左指针为右指针，右指针继续向右移动，直到再遇到c（满足情况2）或者走到字符串尾部（满足情况1）\r\n\r\n    几点注意：\r\n\r\n    1. 计算距离的时机应该在右指针更新的时候，右指针第二次之后，直到走到尾部，都按第2种情况计算，右指针第一次更新或者走到尾部，按照第1中情况判断\r\n    2. 要考虑右指针指向尾部以及尾部字符恰好是c的情况，所以条件判断应该有**优先级**\r\n\r\n    执行用时：**40 ms**, 在所有 Python3 提交中击败了**93.41%**的用户\r\n\r\n    内存消耗：**14.9 MB**, 在所有 Python3 提交中击败了**66.05%**的用户\r\n\r\n    ```python\r\n    class Solution:\r\n        def shortestToChar(self, s: str, c: str) -> List[int]:\r\n            # 定义变量 left记录上一个c的位置，如果存在的话\r\n            left = right_cnt = 0\r\n            answer = [0]*len(s)\r\n\r\n            # 循环，找c，计算距离\r\n            for right in range(len(s)):   # 右指针从0遍历到len(s)-1\r\n                if s[right] == c:   # 如果右指针指向的字符是c，那么计算一次距离\r\n                    if not right_cnt:   # 如果右指针第一次更新，说明在c的一侧\r\n                        answer[left:right+1] = [abs(right-i) for i in range(left, right+1)]\r\n                    else:   # 如果右指针不是第一次更新，说明在两个c中间\r\n                        answer[left:right+1] = [min(abs(right-i), abs(i-left)) for i in range(left, right+1)]\r\n                    # 更新左指针以及出现c的次数\r\n                    left = right\r\n                    right_cnt += 1\r\n                else:\r\n                    # 注意这个条件判断要在else里面，以排除最后一个元素是c的情况\r\n                    if right == len(s)-1:\r\n                        answer[left:right+1] = [abs(left-i) for i in range(left, right+1)]\r\n            return answer\r\n    ```\r\n\r\n    复杂度分析\r\n\r\n    令n为字符串长度：\r\n\r\n    时间复杂度：O(N)，这里外层循环，快指针遍历了n次，然后内层，每次遇到一个c，就处理一部分，总的遍历次数也是n，相当于是2n，所示时间复杂度是O(N)\r\n\r\n    空间复杂度：O(1)(不考虑返回占用的空间)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-838860047","body":"## 题目分析：\r\n\r\n- 入栈，有size限制\r\n- 出栈，空的话返回-1\r\n- inc，前k个元素都加上val\r\n\r\n## 思路\r\n\r\n辅助栈，空间换时间，额外定义一个栈，用来存储前k个元素的增量，只需要将第k个元素的值设为对应的增量即可，当出栈时再实时更新这个增量，起到增量向下传递的目的\r\n\r\n这样做的好处就是避免了对前k个元素进行的循环增量的操作，节省时间\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.size = maxSize\r\n        self.stk = []\r\n        self.inc = []   # 辅助栈，记录增量\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size > len(self.stk):\r\n            self.stk.append(x)\r\n            self.inc.append(0)   # 记得给辅助栈也压入元素，压0，不影响计算，还能避免判断长度\r\n\r\n    def pop(self) -> int:\r\n        if not self.stk: return -1\r\n        tmp = self.inc.pop()\r\n        res = self.stk.pop() + tmp\r\n        if self.inc: self.inc[-1] += tmp\r\n        return res\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # 这里需要处理一下，如果给定的 k 大于当前栈的高度，那么应该 id 应该是最后一个元素\r\n        idx = k-1 if k < len(self.stk)+1 else len(self.stk)-1\r\n        # 处理之后， 如果self.inc原本就是空栈，那么idx会是负数，所以再加一个判断，防止索引越界\r\n        if idx >= 0:\r\n            self.inc[idx] += val \r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n**复杂度分析：**\r\n\r\n假设操作次数为N\r\n\r\n时间复杂度：\r\n\r\n- 入栈：O(1)\r\n- 出栈：O(1)\r\n- 增量：O(1)，仅需计算对应位置增量\r\n\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-839928813","body":"[394\\. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- k一定是正整数\r\n- 字符串没有额外空格\r\n- 原始数据不包括数字\r\n\r\n### 思路：\r\n\r\n---\r\n\r\n### 1. 用栈实现括号匹配\r\n\r\n- 给定的字符串可以存储到一个栈中\r\n- 出栈入栈条件为：\r\n    - 如果非`]`，就入栈\r\n    - 如果是`]`，那么就循环出栈，直到找到一个匹配的`[`\r\n- 注意数字如果是两位数，需要处理，所以为了方便，我们先把数字解析出来，变成一个元素存储在栈中，这样每次匹配左右括号时，可以直接取左括号的上一位元素进行复制操作即可\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stk = []\r\n\r\n        for i in s:\r\n            try:    # 使用try，可以方便地对当前字符是否是数字进行判断\r\n                num = int(i)    # 这里的int(i)要单独占一行赋值语句\r\n                num = stk.pop()*10 + num if stk and isinstance(stk[-1], int) else num\r\n                stk.append(num)\r\n            except ValueError:\r\n                if i == ']':\r\n                    tmp = i\r\n                    while tmp[0] != '[':    # 循环pop，直到遇到了左括号\r\n                        tmp = stk.pop() + tmp\r\n                    stk.append(stk.pop()*tmp[1:-1])    # 解码后，重新压入栈\r\n                else:\r\n                    stk.append(i)\r\n        return ''.join(stk)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 只遍历了字符串一次，所以为线性复杂度\r\n\r\n空间复杂度：O(N) 使用了栈存储，所以为线性复杂度\r\n\r\n### 2. DFS\r\n\r\n递归写的不是很熟练，参考西法大佬的题解，将栈版本的代码改动成了递归\r\n\r\n详见代码注释\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(i):   # 每次递归，传入的参数是索引， 表示在字符串的位置\r\n            num, ans = 0, ''    # 记得每次递归都将变量重新初始化一下\r\n            while i < len(s):\r\n                try:    # 使用try，不过这里直接加上 num*10，处理多位数字的情况\r\n                    num = num*10 + int(s[i])\r\n                except ValueError:   # 在抛出的异常中，处理字符串\r\n                    if s[i] == '[':   # 左括号的话，进入递归\r\n                        i, tmp = dfs(i+1)   # 更新索引 i\r\n                        ans += num*tmp   # 将当前递归层的ans加上内层的返回结果\r\n                        num = 0\r\n                    elif s[i] == ']':   # 右括号直接返回\r\n                        return i, ans\r\n                    else:\r\n                        ans += s[i]\r\n                i += 1\r\n            return ans\r\n        return dfs(0)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为字符串长度\r\n\r\n时间复杂度：O(N) 递归其实更新了索引，所以还是只遍历了字符串一次，为线性复杂度\r\n\r\n空间复杂度：O(N) 极端情况下，递归调用栈的深度为N/2，比如`[[[[]]]]`，所以为线性复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840668982","body":"### [232\\. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\nDifficulty: **简单**\r\n\r\n### Solution\r\n\r\n### 辅助栈\r\n\r\npush与peek的操作不说，但是pop的操作，如果只定义一个栈的话，想要实现队列的先入先出特性，在pop时，需要先将所有元素拿出来，然后pop掉栈底的元素，再放进去，这样的时间复杂度是线性的，所以我们可以使用空间换取时间\r\n\r\n定义一个辅助栈，然后每次pop时都执行以下操作\r\n\r\n- 辅助栈是否为空，是的话将主栈中所有元素添加到辅助栈中，注意这个添加的过程的倒序的，相当于辅助栈的栈顶就是队列的队首\r\n- 如果辅助栈不为空，或者已经执行完了第一步，那么直接返回辅助栈的栈顶元素即可\r\n\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stk = []\r\n        self.aid = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stk.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.aid:\r\n            while self.stk:\r\n                self.aid.append(self.stk.pop())\r\n        return self.aid.pop()\r\n        \r\n    def peek(self) -> int:\r\n        if not self.aid: return self.stk[0]\r\n        else: return self.aid[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return True if not self.stk and not self.aid else False\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令队列元素为N个\r\n\r\n时间复杂度：均为O(1)\r\n\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841620049","body":"### [768\\. 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\nDifficulty: **困难**\r\n\r\n### Solution\r\n\r\n---\r\n\r\n### 题目分析\r\n\r\n- 题目大意是将，数组分块，分块排序后，连在一起可以组成所有元素的升序排列\r\n- 数组长度还好，不需要特殊处理\r\n- 言外之意就是，前一个块的所有元素，必须小于后一个块\r\n- 那么考虑两种极端情况，分别是数组完全升序和完全降序\r\n    - 完全升序时，数组中每个元素都小于后一个元素，所以每个元素都可以当成一个独立的块\r\n    - 完全降序时，数组中只能分成一个块\r\n\r\n### 思路：单调栈\r\n\r\n经过以上分析，可以通过单调栈来解决，设栈为`stk`，同时记录一下最大值`maxx`\r\n\r\n先向栈中存入第一个元素，避免不必要的判断\r\n\r\n遍历一次输入的数组：\r\n\r\n对每个元素依次做以下操作\r\n\r\n1. 判断是否入栈或出栈\r\n\r\n    入栈出栈的规则是：\r\n\r\n    - 如果当前元素大于或者等于`maxx`，入栈， 更新最大值`maxx`\r\n    - 如果当前元素小于栈顶元素，循环弹出栈顶元素，直到当前元素大于或等于栈顶元素，注意不用将当前元素入栈！！不过要再将`maxx`压入栈，因为刚刚pop时肯定把`maxx`弹出栈了\r\n\r\n最后返回栈的高度即可\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        maxx, stk = arr[0], [arr[0]]\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= maxx:\r\n                maxx = arr[i]\r\n                stk.append(arr[i])\r\n            else:\r\n                while stk and stk[-1] > arr[i]:\r\n                    stk.pop()\r\n                stk.append(maxx)\r\n        return len(stk)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为N\r\n\r\n时间复杂度：**O(N)** 因为只迭代了一次数组，所以为线性复杂度\r\n\r\n空间复杂度：**O(N)** 极端情况下，单调栈中会存N个数，所以为线性复杂度\r\n\r\n---\r\n\r\n### 思路：前缀和\r\n\r\n- 利用题中的先验条件：分块排序与直接排序，得到的结果一致\r\n- 因为对于每个块中的数据，我们可以不考虑他们的具体顺序以及大小，我们只需要关注他们的和就好，具体的方式就是\r\n\r\n    > 将前n个元素的和与直接排序后的前n个元素的和进行比较，如果相等，说明这n个元素可以被当成一个块\r\n\r\n- 为了进一步简化，我们可以通过前缀和的方式来比较，直接比较前缀和数组中相等元素的个数即可\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = 0\r\n        nums = sorted(arr, reverse=False)\r\n        for i in range(len(arr)):\r\n            nums[i] += nums[i-1] if i > 0 else 0\r\n            arr[i] += arr[i-1] if i > 0 else 0\r\n            cnt += 1 if arr[i] == nums[i] else 0\r\n        return cnt\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为**N**\r\n\r\n时间复杂度：**O(N)** 排序为O(NlogN)，迭代为O(N)\r\n\r\n空间复杂度：**O(N)** 新建排序数组的空间占用为O(N)\r\n\r\n---\r\n\r\n### 思路：双指针/滑动窗口\r\n\r\n大概想法就是，定义两个指针，两个指针之间维护一个滑动窗口\r\n\r\n根据方法二的思路，我们可以判断每个窗口与排序后数组中元素的和是否相等\r\n\r\n定义两个指针 `left`， `right`，表示滑窗的左右边界，以及块数 `cnt`\r\n\r\n双指针移动策略：\r\n\r\n1. 初始值为 `left`指向0\r\n2. 使用`right`，遍历数组元素，右指针的范围是`1 - len(arr)+1`，注意python中**左闭右开**\r\n\r\n    如果当前两个指针之间的元素和与排序数组中的元素和相等，更新`left`为`right`，否则继续移动`right`，使滑窗变大\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        left = cnt = 0\r\n        nums = sorted(arr, reverse=False)\r\n        for right in range(1, len(arr)+1):\r\n            if sum(nums[left:right]) == sum(arr[left:right]):\r\n                cnt, left = cnt+1, right\r\n        return cnt\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令数组长度为**N**\r\n\r\n时间复杂度：**O(N)** 排序为O(NlogN)，迭代为O(N)\r\n\r\n空间复杂度：**O(N)** 新建排序数组的空间占用为O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841696578","body":"### [61\\. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- 没说链表中元素一定不同\r\n- 链表节点数量可能为0！！！\r\n\r\n### 思路1：转换思维，倒数第k个节点，快慢指针\r\n\r\n第一个反应是计算[倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)，但是奈何凌晨脑袋有点晕，没想清楚，现在再来记录下思路\r\n\r\n首先注意k的取值，这里先让链表走一遍，得到长度`length`，将k对`length`求余\r\n\r\n然后维护快慢指针，先计算倒数第k个节点，这时链表被分为两部分\r\n\r\n1. 先记录前半部分尾节点的下一个节点的指针，存为tmp\r\n2. 前半部分的尾节点（也就是slow）指向空\r\n3. 后半部分的尾节点（也就是fast）指向头结点\r\n4. 返回tmp\r\n\r\n![示意图](https://raw.githubusercontent.com/shmilywh/PicturesForBlog/master/2021/05/16-21-59-51-2021-05-16-21-59-47-image.png)\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 链表为空或者只有一个节点，直接返回即可\r\n        if not head or not head.next or not k: return head\r\n\r\n        # 需要对K求余\r\n        tmp, length = head, 0\r\n        while tmp:\r\n            tmp = tmp.next\r\n            length += 1\r\n        k %= length\r\n\r\n        # k为0的话，说明不需要旋转\r\n        if not k: return head\r\n\r\n        # 快慢指针，开始时都指向头结点\r\n        slow, fast = head, head\r\n        # 快指针先走k步\r\n        for _ in range(k):\r\n            fast = fast.next\r\n        # 一起走，直到快指针到达尾节点\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        # 链表的断开与重连\r\n        tmp = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n\r\n        return tmp\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)\r\n\r\n---\r\n\r\n### 思路2：三次反转链表\r\n\r\n这个题的思路有点像[旋转数组](https://leetcode-cn.com/problems/rotate-array/)，其步骤如下\r\n\r\n1. 将整个数组反转\r\n2. 将前k个元素反转\r\n3. 将后面所有元素反转\r\n\r\n这时的数组就是**旋转k个位置**后的\r\n\r\n同样本题也可以如此操作\r\n\r\n---\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # 链表为空或者只有一个节点，直接返回即可\r\n        if not head or not head.next or not k: return head\r\n\r\n        # 根据steps的数量 反转链表\r\n        def reverseList(node: ListNode, steps: int) -> ListNode:\r\n            pre, cur = None, node\r\n            while steps > 0:\r\n                steps -= 1\r\n                nex = cur.next\r\n                cur.next = pre\r\n                pre = cur\r\n                cur = nex\r\n            return pre, cur\r\n\r\n        # 需要对K求余\r\n        tmp, length = head, 0\r\n        while tmp:\r\n            tmp = tmp.next\r\n            length += 1\r\n        k %= length\r\n\r\n        # k为0的话，说明不需要旋转\r\n        if not k: return head\r\n\r\n        # 先反转所有，再反转前k个，最后反转后面剩下的\r\n        rev, _ = reverseList(head, length)\r\n        preK, nex = reverseList(rev, k)\r\n        rev.next, _ = reverseList(nex, length-k)\r\n        return preK\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841995082","body":"### [24\\. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- 原地修改节点\r\n- 链表节点数量可能为0\r\n- 注意是两两交换\r\n\r\n### 思路\r\n\r\n两两交换，画图最清楚～\r\n\r\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/539c5f74-4e8a-4454-a063-43923e3bf42b/Untitled.png](https://raw.githubusercontent.com/shmilywh/PicturesForBlog/master/2021/05/17-13-21-42-2021-05-17-13-21-39-image.png)\r\n\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        # 特殊情况\r\n        if not head or not head.next: return head\r\n        \r\n        res = head.next   # 记录下第二个节点，这是要返回的\r\n        pre, cur = None, head\r\n        while cur and cur.next:   # 二者都成立才能进行下一轮的交换\r\n            nex = cur.next\r\n            tmp = nex.next\r\n            nex.next = cur\r\n            cur.next = tmp\r\n            if pre:   # 开始时pre是空，需要条件判断\r\n                pre.next = nex\r\n            \r\n            pre = cur\r\n            cur = tmp\r\n\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为链表长度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843291066","body":"### [109\\. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 思路1：链表转数组+递归\r\n\r\n遍历一次链表，转换成数组，然后就是数组如何构建二叉搜索树了\r\n\r\n具体可以参考 [108\\. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) \r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def makeTree(nums, start, end):\r\n            if start > end:\r\n                return None\r\n            mid = (start + end) // 2\r\n            cur = TreeNode(nums[mid])\r\n            cur.left = makeTree(nums, start, mid-1)\r\n            cur.right = makeTree(nums, mid+1, end)\r\n            return cur\r\n\r\n        L = []\r\n        while head:\r\n            L.append(head.val)\r\n            head = head.next\r\n        \r\n        return makeTree(L, 0, len(L)-1)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为链表长度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N) 包括额外数组空间O(N)以及递归调用栈的空间O(logN)\r\n\r\n### 思路2：快慢指针遍历链表+递归\r\n\r\n参考了西法的题解，使用快慢指针，快指针走两步，慢指针走一步，最后慢指针指向的就是链表中心，根据此原理，每次都找到链表中心，然后将链表分为三部分，使用递归构建二叉搜索树即可\r\n\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return None\r\n        if not head.next: return TreeNode(head.val)    # 如果只有一个节点了，那么直接返回\r\n        pre, slow, fast = None, head, head\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n        \r\n        if pre: pre.next = None    # 断开链表前半部分的尾节点，指向None\r\n        \r\n        cur = TreeNode(slow.val)\r\n        cur.left = self.sortedListToBST(head)\r\n        cur.right = self.sortedListToBST(slow.next)\r\n        return cur\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为链表长度\r\n\r\n时间复杂度：O(logN) 因为是二叉搜索树，且高度平衡，因此N个节点的操作次数是logN\r\n\r\n空间复杂度：O(logN) 递归调用栈的空间占用"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843336543","body":"### [160\\. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\nDifficulty: **简单**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- A和B两个链表长度可能不同\r\n- 但是A+B和B+A的长度是相同的\r\n\r\n### 思路：双指针\r\n\r\n我们可以遍历，使用两个指针，A结束之后遍历B，B结束之后遍历A，因为遍历A+B和遍历B+A一定是同时结束。 如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 如果A,B不相交的话两个指针就会同时到达A+B（B+A）的尾节点\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        ha, hb = headA, headB\r\n        while ha != hb:    # 两个指针一定会相遇，不是在相交节点就是在尾节点\r\n            ha = ha.next if ha else headB\r\n            hb = hb.next if hb else headA\r\n        return ha   # 这里返回 ha 或 hb 均可\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令A,B为两条链表长度\r\n\r\n时间复杂度：O(A+B) 最坏情况下，没有交点\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844603645","body":"### [142\\. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\nDifficulty: **中等**\r\n\r\n### Solution\r\n\r\n### 题目分析：\r\n\r\n判断链表是否有环是比较经典的问题\r\n\r\n本题给定要求，不允许修改链表，且尽量在O(1)空间内完成\r\n\r\n### 思路1：哈希表\r\n\r\n判断是否重复的问题，比较容易想到的就是通过哈希表来计数，注意这里计的不是链表的数据域，而是指针域，也就是节点的指针，当有重复节点时，说明有环，返回即可，否则返回空\r\n\r\n- 使用python中的计数器\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return None\r\n\r\n        cnt = Counter()\r\n        while head:\r\n            if cnt[head] > 1:\r\n                return head\r\n            cnt[head] += 1\r\n            head = head.next\r\n        \r\n        return None\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为链表长度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)\r\n\r\n### 思路2：快慢指针\r\n\r\n定义快慢指针来找环，就是哈希表的空间优化版，使用快慢指针来定位环的位置，然后再进行一次遍历，找到环的入口节点即可\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return None\r\n\r\n        # 快慢指针都指向头结点\r\n        slow = fast = head\r\n        while True:\r\n            # 当快指针无法继续时返回，说明不相交\r\n            if not fast or not fast.next: return None\r\n            # 更新快慢指针\r\n            slow, fast = slow.next, fast.next.next\r\n            # 如果指向同一节点，跳出循环，注意这不是相交节点\r\n            if slow == fast: break\r\n\r\n        # 将快指针重新指向头结点，再遍历一次\r\n        fast = head\r\n        while slow != fast:\r\n            slow, fast = slow.next, fast.next\r\n        return fast\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令N为链表长度\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846044073","body":"### [146\\. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\nDifficulty: 中等\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- 明确LRU机制的定义\r\n- 应该用字典来存储关键字和它对应的值，对应的查询操作，也就是`get`，时间复杂度是O(1)\r\n- 但是如何实现就近操作？\r\n\r\n    就近操作指的`get`之后，需要改变对应关键字的优先级\r\n\r\n    当然，`put`之后，对应关键字的优先级是最高的\r\n\r\n- 所以问题就变成了，get查询之后，如果改变哈希表中的关键字顺序？\r\n\r\n    可以使用额外的数据结构来存储字典中每个键的顺序，或者说优先级\r\n\r\n    分析一下，貌似符合的数据结构只有链表了，因为要涉及到\r\n\r\n    但是因为字典本身是无序的，所以我们还需要一个类似于队列的结构来记录访问的先后顺序，这个队列需要支持如下几种操作：\r\n\r\n    - 在末尾加入一项\r\n    - 去除最前端一项\r\n    - 将队列中某一项移到末尾\r\n\r\n### 思路：双向链表+哈希表\r\n\r\n> 如何确定可以再常数时间将元素从队列中间移动到末尾的数据结构，是关键\r\n\r\n1. ~~数组/队列，移动元素到末尾的时间复杂度是O(N)，不符合~~\r\n2. ~~单链表，删除当前元素的时间复杂度是O(1)，即`pre.next = cur.next`但是添加到末尾的时间复杂度是O(N)，因为要获取尾节点的指针，使`tail.next = cur`，正常需要遍历一次才可以获得~~\r\n\r\n使用双向链表，可以在常数时间内将任一元素移动到末尾\r\n\r\n因此我们使用哈希表+双向链表\r\n\r\n- 哈希表的Key为缓存的Key，Value为链表节点的指针\r\n- 链表中，要有前后节点的指针，并且其Key存储缓存的Key，Value存储缓存的Value\r\n\r\n```python\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846338276","body":"### [104\\. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\nDifficulty: **简单**\r\n\r\n### Solution\r\n\r\n### 题目分析\r\n\r\n- 二叉树的深度定义\r\n- 注意根节点为None时，树的深度是0\r\n\r\n### 思路1：DFS\r\n\r\n树的问题我们一般都可以使用递归来解决，本题求深度也可以抽象成递归的思想，注意找好递归的base case和递归参数即可\r\n\r\n- 递归函数传参：传递当前子树的根节点\r\n- base case：根节点为None时，树的深度是0，否则应该是其左子树深度+1与右子树深度+1的较大值\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return max(self.maxDepth(root.left)+1, self.maxDepth(root.right)+1)\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令树的节点个数为n，高度为h\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(h)\r\n\r\n### 思路3：BFS\r\n\r\n使用层序遍历也可以求得深度，每新遍历一层，深度加1，最后返回最大的深度值即可\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        \r\n        Q = collections.deque([(root, 1)])\r\n        depth = 1   # 根节点为空的情况已经被过滤掉了\r\n        while Q:\r\n            size = len(Q)\r\n            for _ in range(size):\r\n                cur, d = Q.popleft()\r\n                depth = d if d > depth else depth\r\n                if cur.left:\r\n                    Q.append((cur.left, d+1))\r\n                if cur.right:\r\n                    Q.append((cur.right, d+1))\r\n        return depth\r\n```\r\n\r\n### 复杂度分析\r\n\r\n令树的节点个数为n，高度为h\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(k) k是每层的节点个数"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LeahLuo0903":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838427280","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        \r\n        int n = s.size();\r\n        vector<int> ans(s.size(), -n);\r\n            \r\n        int prev = -n;  \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = i - prev; \r\n        }\r\n        \r\n        // 不需要从最后开始遍历\r\n        // 从最后一次该字母出现处往前遍历\r\n        for (int i = prev - 1; i >= 0; i--) {\r\n            if (s[i] == c) prev = i;\r\n            ans[i] = min(ans[i], prev - i); \r\n        } \r\n        return ans; \r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841668001","body":"### 思路\r\n1. 复制arr数组并对其排序\r\n2. 能成块的特点：和相同。比如[2，1，4，3，4]，排序后为[1，2，3，4，4]，2+1 = 1+2 -> 1，2能分出来\r\n3. 遍历数组，对比和即可\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> sortArr = arr; \r\n        sort(sortArr.begin(), sortArr.end());\r\n        \r\n        int ans = 0;\r\n        long sum1 = 0; \r\n        long sum2 = 0; \r\n        \r\n        for (int i = 0; i < arr.size(); i++) {\r\n            sum1 += arr[i];\r\n            sum2 += sortArr[i];\r\n            if (sum1 == sum2) ans++;\r\n        }\r\n        return ans; \r\n    }\r\n};\r\n```\r\n时间复杂度：O(n)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844118563","body":"用unordered_set先把其中一链表的node都存进去。复杂度比双指针高点，因为需要两次遍历和额外空间\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        \r\n        unordered_set<ListNode*> set; \r\n        \r\n        ListNode* p1 = headA;\r\n        ListNode* p2 = headB; \r\n        while (p1 != NULL) {\r\n            set.insert(p1); \r\n            p1 = p1->next; \r\n        }\r\n        while (p2 != NULL) {\r\n            auto n = set.find(p2);\r\n            if (n != set.end()) return p2; \r\n            p2 = p2->next; \r\n        }\r\n        return NULL; \r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"p76":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838435741","body":"> ### 思路\r\n> 1.将字符串转成数组。\r\n2.遍历字符串数组，获取字符c在字符串数组中的坐标，生成坐标数组。\r\n3.再次遍历，获取字符串中其他字符与字符c的最近距离。\r\n \r\n> ### 代码\r\n``` \r\nvar shortestToChar = function (s, c) {\r\n    let sArr = s.split('');\r\n    let itemIndex = [];\r\n    let answerArr = [];\r\n    for (let i = 0; i < sArr.length; i++) {\r\n        if (sArr[i] === c) {\r\n            itemIndex.push(i);\r\n        }\r\n    }\r\n    for (let n = 0; n < sArr.length; n++) {\r\n        if (sArr[n] === c) {\r\n            answerArr.push(0);\r\n        } else {\r\n            let idx = sArr.length;\r\n            for (let j = 0; j < itemIndex.length; j++) {\r\n                let countNum = Math.abs(n - itemIndex[j]);\r\n                if (idx > countNum) {\r\n                    idx = countNum;\r\n                }\r\n            }\r\n            answerArr.push(idx);\r\n        }\r\n    }\r\n    return answerArr;\r\n};\r\n```\r\n> ### 复杂度\r\n时间复杂度O(n);\r\n空间复杂度O(1);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839880360","body":">### 思路\r\n1.初始化top，将当前数值下标保存至top;\r\n2.初始化数组stack，长度为maxsize；\r\n3.执行push操作时，判断top是否大于maxsize-1,大于则不做操作，否则top++，然后将当前数据存入stack[top];\r\n4.执行pop操作时，判断top是否为-1，为-1时直接return -1，否则top--，return stack[top+1];\r\n5.执行increment操作时，直接遍历k,栈中下标小于k的数据加上val;\r\n\r\n>### 代码\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    stack = new Array(maxSize);\r\n    top = -1;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (top < stack.length - 1) {\r\n        top++;\r\n        stack[top] = x;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (top != -1) {\r\n        top--;\r\n        return stack[top + 1];\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    for (let i = 0; i < k; i++) {\r\n        if (stack[i]) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n    return stack;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\nlet stack = [];\r\nlet top;\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：初始化、pop、push为O(1)，increment为O(k);\r\n空间复杂度:O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840655306","body":">### 思路\r\n遍历s字符串，遇到数字时，将字符串转成数字保存至num变量。遇到字符时，将字符进行拼接保存至res变量，遇到‘[’时，res和num分别存入strStack、mulStack栈中，并且将res和num变量分别重置为‘’和[]，遇到']'时，将strStack的栈顶元素出栈，并且进行重复操作。\r\n\r\n>### 代码 \r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n   let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：\r\n空间复杂度：O(s.length)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812797","body":">### 思路\r\n1.计算链表的长度\r\n2.链表最后一位值的 nextnext 指向原链表首位数字，形成闭环\r\n3.创建一个变量，接收从 k 处截断后的链表，假设 k=2，我们就会从 3 这里处截断，然后 3的next 指向 null 即可，所以该变量的值是4−>5−>1−>2−>3−>null。\r\n\r\n>### 代码\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    if(!head || !head.next || !k) return head;\r\n    let len = 1, cur = head;\r\n    while(cur.next){\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n    let move = len - k % len;\r\n    cur.next = head;\r\n    while(move){\r\n        cur = cur.next;\r\n        move--;\r\n    }\r\n    let ans = cur.next;\r\n    cur.next = null;\r\n    return ans;\r\n};\r\n```\r\n\r\n>### 复杂度 \r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842436010","body":">### 思路\r\n使用递归，只关注本级遍历需要做的事情，每次遍历需要返回给上一级的数据为处理好的部分链表，因为是两两节点交换，所以本级遍历需要关注的就是三个节点，head、head.next、处理好好部分链表，本级需要处理的就是将head与head.next的位置进行交换。\r\n\r\n>### 代码\r\n```\r\nvar swapPairs = function (head) {\r\n    if (head === null || head.next === null) {\r\n        return head;\r\n    }\r\n    let next = head.next;\r\n    head.next = swapPairs(next.next);\r\n    next.next = head;\r\n\r\n    return next;\r\n};\r\n```\r\n>### 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843238904","body":">### 思路\r\n快慢指针：\r\n当快指针走到尾节点时，慢指针恰好走到链表中间，分而治之。因为需要断开链表，而单链表没有前驱动指针，所以需要保存慢节点的前一个节点，用来断开链表。\r\n\r\n\r\n>### 代码\r\n```\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(!head){\r\n        return head;\r\n    }\r\n    let slow = head;\r\n    let fast = head;\r\n    let preSlow;\r\n    while(fast && fast.next){\r\n        preSlow = slow;\r\n        slow = slow.next;\r\n        fast = fast.next.next;\r\n    }\r\n    let root = new TreeNode(slow.val);\r\n    if(preSlow){\r\n        preSlow.next = null;\r\n        root.left = sortedListToBST(head);\r\n    }\r\n    root.right = sortedListToBST(slow.next)\r\n    return root;\r\n};\r\n```\r\n\r\n>### 复杂度\r\n时间复杂度：\r\n空间复杂度：O(logn)递归栈的调用深度。"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846524526","body":">### 思路\r\n1.两个二叉树都不为空，那么首先判断它们的根节点的值是否相同。\r\n2.若不相同则两个二叉树一定不同。\r\n3.若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。\r\n这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。\r\n\r\n>### 代码\r\n```\r\nvar isSameTree = function (p, q) {\r\n    if (p === null && q === null) {\r\n        return true;\r\n    }\r\n    if (p === null || q === null) {\r\n        return false;\r\n    }\r\n    if (p.val !== q.val) {\r\n        return false;\r\n    }\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```\r\n\r\n>### 复杂度 \r\nm,n分别为两棵树的节点数。\r\n时间复杂度：O(min(m,n)) \r\n空间复杂度：O(min(m,n))"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Ben-Lee95":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838512853","body":"> # 821. 字符的最短距离\r\n> ## 入选理由\r\n> 暂无\r\n> \r\n> ## 题目地址\r\n> https://leetcode-cn.com/problems/shortest-distance-to-a-character\r\n> \r\n> ## 前置知识\r\n> * 数组的遍历(正向遍历和反向遍历)\r\n> \r\n> ## 题目描述\r\n> ```\r\n> 给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\r\n> \r\n> 示例 1:\r\n> \r\n> 输入: S = \"loveleetcode\", C = 'e'\r\n> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\r\n> 说明:\r\n> \r\n> - 字符串 S 的长度范围为 [1, 10000]。\r\n> - C 是一个单字符，且保证是字符串 S 里的字符。\r\n> - S 和 C 中的所有字母均为小写字母。\r\n> ```\r\n## 思路\r\n- 对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\r\n## 关键点\r\n\r\n-  从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\r\n从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\r\n这两个值取最小就是答案。\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int N = s.length();\r\n        int[] ans = new int[N];\r\n        int prev = -10000;\r\n        \r\n        //从左往右遍历数组\r\n        for(int i = 0; i < N; ++i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = 20000;\r\n        //从右往左遍历数组\r\n        for(int i = N-1; i >= 0; --i){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n^2)$\r\n- 空间复杂度：$O(1)$\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"RMsboy":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838529779","body":"**思路**\r\n维护一个数组获取c在s中的下标\r\n使用reduce方法对计算最近距离\r\n\r\n**代码**\r\n语言支持：JavaScript\r\nJavaScript Code:\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let resArr = new Array(s.length)\r\n    let temArr = []\r\n    // 包含c字符下标的数组\r\n    for(let i = 0; i < s.length; i++){\r\n        if(s[i] === c){\r\n            temArr.push(i)\r\n        }\r\n    }\r\n    // 使用reduce获取字符串与指定字符串的最短距离\r\n    for(let i = 0; i < s.length; i++){\r\n        resArr[i] = temArr.reduce((value, item) => {\r\n            return Math.min(value, Math.abs(item - i))\r\n        }, 10000)\r\n    }\r\n    return resArr\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nn为s的长度，m为c在s中的重复次数\r\n\r\n时间复杂度：O(mn) \r\n空间复杂度：O(mn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839737782","body":"**代码**\r\n\r\n    **语言支持：JavaScript**\r\n\r\n``` \r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = []\r\n    this.max = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.max) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.stack.length === 0) {\r\n        return -1\r\n    } else {\r\n        let a = this.stack.splice(this.stack.length - 1, 1)\r\n        return a\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    if (this.stack.length < k) {\r\n        let i = 0\r\n        while (i < this.stack.length) {\r\n            this.stack[i] += val\r\n            i++\r\n        }\r\n    } else {\r\n        let i = 0\r\n        while (i < k) {\r\n            this.stack[i] += val\r\n            i++\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n复杂度分析\r\n\r\n    push\r\n        时间复杂度：O(1)\r\n        空间复杂度：O(1)\r\n\r\n    pop\r\n        时间复杂度：O(1)\r\n        空间复杂度：O(1)\r\n\r\n    increment\r\n        时间复杂度：O(n)\r\n        空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646642","body":"// 时间不够，先抄一遍，再来仔细琢磨\r\n\r\n```/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] != ']'){\r\n      stack.push(s[i])\r\n    }else if(s[i] == ']'){\r\n      let temp = ''\r\n      while(stack[stack.length - 1] != '['){\r\n        temp = stack.pop() + temp;\r\n      }\r\n      stack.pop() //这一步一定是'['\r\n\r\n      let num = ''\r\n      while(stack[stack.length - 1] >= '0' && stack[stack.length - 1] <= '9'){\r\n        num = stack.pop() + num\r\n      }\r\n\r\n      temp = temp.repeat(parseInt(num))\r\n      stack.push(temp)\r\n    }\r\n  }\r\n  return stack.join('');\r\n};```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841321279","body":"**语言：js**\r\n```/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.queueLeft = []\r\n    this.queueRight = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.queueLeft.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.queueRight.length <= 0) {\r\n        while (this.queueLeft.length > 0) {\r\n            this.queueRight.push(this.queueLeft.pop())\r\n        }\r\n    }\r\n    return this.queueRight.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    if (this.queueRight.length <= 0) {\r\n        while (this.queueLeft.length > 0) {\r\n            this.queueRight.push(this.queueLeft.pop())\r\n        }\r\n    }\r\n    return this.queueRight[this.queueRight.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.queueLeft.length === 0 && this.queueRight.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841628856","body":"**语言：js**\r\n维护一个栈，存储每一块的最大值\r\n\r\n```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    // 定义一个栈\r\n    let res = []\r\n    let len = arr.length\r\n    for(let i = 0; i < len; i++){\r\n        // 当前项大于等于栈最后一个值 push\r\n        if(res.length <= 0 || arr[i] >= res[res.length - 1]){\r\n            res.push(arr[i])\r\n        } else {\r\n            // 当前值小于栈最后一个值，继续往栈前面找，找到小于当前值的数\r\n            let temp = res.pop()\r\n            while(arr[i] < res[res.length - 1]){\r\n                res.pop()\r\n            }\r\n            res.push(temp)\r\n        }\r\n    }\r\n    return res.length\r\n};\r\n```\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841829604","body":"不会做先抄一遍再说\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    // k为0时不需要移动，链表为空或者链表只有一个节点直接返回链表\r\n    if (k === 0 || !head || !head.next) return head;\r\n    // 【第一步】建立锚节点，记录链表的头结点\r\n    var dummy = new ListNode(0, head), cur = dummy;\r\n\r\n    // 【第二步】计算出链表的长度\r\n    let count = 0;\r\n    // 循环执行完之后，cur指向了链表的最后一个位置\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        count++;\r\n    }\r\n    // 如果链表的长度等于要移动的次数，直接返回链表\r\n    if (k === count) {\r\n        return head;\r\n    } else if (k > count) {\r\n        // 如果链表的长度小于要移动的位置数，直接对链表长度取模运算，\r\n        // 因为如果链表的长度小于需要要移动的次数，意味着我们的环形链表至少需要循环一周以上\r\n        k %= count;\r\n    }\r\n\r\n    // 将链表的最后一个位置，指向链表的第一个位置，形成一个环链表\r\n    cur.next = dummy.next;\r\n    // 将cur指向原链表的第一个位置\r\n    cur = cur.next;\r\n\r\n    // 【第三步】开始移动链表\r\n    for (let i = 0; i < count - k - 1; i++) {\r\n        cur = cur.next;\r\n    }\r\n\r\n    // 【第四步】移动完成，切断环形列表\r\n    // 执行为for循环到这里之后，已经到了我们要切断链表的位置，但是在切断链表之前，\r\n    // 将我们的锚点指向要切断链表的下一个位置，将其作为新链表的头结点\r\n    dummy.next = cur.next;\r\n    // 切断结点，这里一定不要忘记，否则就还是换链表\r\n    cur.next = null;\r\n    return dummy.next\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842387853","body":"**语言：js**\r\n\r\n思路：递归一直换，终止条件：节点数 <= 时\r\n\r\n```/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if(head === null || head.next === null){\r\n        return head\r\n    }\r\n    const newHead = head.next\r\n    head.next = swapPairs(newHead.next)\r\n    newHead.next = head\r\n    return newHead\r\n};```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843278308","body":"不会做，抄了一遍\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(head === null) return null\r\n    let slow = head\r\n    let fast = head\r\n    let slowPre\r\n    \r\n    while (fast && fast.next){\r\n        fast = fast.next.next\r\n        slowPre = slow\r\n        slow = slow.next\r\n    }\r\n    const root = new TreeNode(slow.val)\r\n    if(slowPre != null) {\r\n        // 构建左子树\r\n        slowPre.next = null\r\n        root.left = sortedListToBST(head)\r\n    }\r\n\r\n    root.right = sortedListToBST(slow.next)\r\n    return root\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844113644","body":"**语言：js**\r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    if(!headA || !headB) return null\r\n\r\n    let A = headA\r\n    let B = headB\r\n    while(A !== B){\r\n        A = A === null ? headB : A.next\r\n        B = B === null ? headA : B.next\r\n    }\r\n    return B\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845193567","body":"```var detectCycle = function (head) {\r\n  let slow = head;\r\n  let fast = head;\r\n  while (fast) {\r\n    if (fast.next == null) { // fast.next走出链表了，说明无环\r\n      return null;\r\n    }\r\n    slow = slow.next;        // 慢指针走一步\r\n    fast = fast.next.next;   // 慢指针走一步\r\n    if (slow == fast) {      // 首次相遇\r\n      fast = head;           // 让快指针回到头节点\r\n      while (true) {         // 开启循环，让快慢指针相遇\r\n        if (slow == fast) {  // 相遇，在入环处\r\n          return slow;\r\n        }\r\n        slow = slow.next;\r\n        fast = fast.next;    // 快慢指针都走一步\r\n      }\r\n    }\r\n  }\r\n  return null;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846039014","body":"```class ListNode {\r\n  constructor(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.next = null\r\n    this.prev = null\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity\r\n    this.hash = {}\r\n    this.count = 0\r\n    this.dummyHead = new ListNode()\r\n    this.dummyTail = new ListNode()\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyTail.prev = this.dummyHead\r\n  }\r\n\r\n  get(key) {\r\n    let node = this.hash[key]\r\n    if (node == null) return -1\r\n    this.moveToHead(node)\r\n    return node.value\r\n  }\r\n\r\n  put(key, value) {\r\n    let node = this.hash[key]\r\n    if (node == null) {\r\n      if (this.count == this.capacity) {\r\n        this.removeLRUItem()\r\n      }\r\n      let newNode = new ListNode(key, value)\r\n      this.hash[key] = newNode\r\n      this.addToHead(newNode)\r\n      this.count++\r\n    } else {\r\n      node.value = value\r\n      this.moveToHead(node)\r\n    }\r\n  }\r\n\r\n  moveToHead(node) {\r\n    this.removeFromList(node)\r\n    this.addToHead(node)\r\n  }\r\n  \r\n  removeFromList(node) {\r\n    let temp1 = node.prev\r\n    let temp2 = node.next\r\n    temp1.next = temp2\r\n    temp2.prev = temp1\r\n  }\r\n\r\n  addToHead(node) {\r\n    node.prev = this.dummyHead\r\n    node.next = this.dummyHead.next\r\n    this.dummyHead.next.prev = node\r\n    this.dummyHead.next = node\r\n  }\r\n\r\n  removeLRUItem() {\r\n    let tail = this.popTail()\r\n    delete this.hash[tail.key]\r\n    this.count--\r\n  }\r\n\r\n  popTail() {\r\n    let tail = this.dummyTail.prev\r\n    this.removeFromList(tail)\r\n    return tail\r\n  }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846354571","body":"原谅我很蠢，递归总是想着要一个累加的变量\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n\r\n    function calc(root, deep){\r\n        if(root === null) return deep\r\n        return Math.max(calc(root.left, deep + 1), calc(root.right, deep + 1))\r\n    }\r\n\r\n    return calc(root, 0)\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846502335","body":"这个好做\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n    if (p == null && q == null) return true;\r\n    if (p == null || q == null)  return false;\r\n    if (p.val != q.val) return false;\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiaoY0324":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838586771","body":"```js\r\n// 每个元素往两边扫描 取最小值\r\nvar shortestToChar = function(s, c) {\r\n  let stringArr = s.split('');\r\n  let res = [];\r\n  let startIdx = 0; // 起始扫描下标\r\n  \r\n  // 递归开始\r\n  findMinIdx(startIdx, stringArr, c, res);\r\n\r\n  // 结果返回\r\n  return res;\r\n};\r\n\r\nconsole.log(\"baaa\", \"b\");\r\nvar findMinIdx = function(startIdx, stringArr, c, res) {\r\n  // 递归终止条件\r\n  if (res.length == stringArr.length) return;\r\n\r\n  let total;\r\n\r\n  for (let i = startIdx; i < stringArr.length; i++) { // 往右扫\r\n    console.warn(`正向扫startIdx: ${ startIdx }`, `i: ${ i }`);\r\n    if (stringArr[i] == c) {\r\n      let curIdx = Math.abs(i - startIdx);\r\n      total = curIdx; // 移动差值\r\n      break;\r\n    }\r\n  }\r\n\r\n  for (let j = startIdx; j >= 0 ; j--) { // 往左扫 注意 j 为 0 也要扫 扫的是 0 位置的元素 比如 'baaa' 和 'b'，0 位置相等。\r\n    console.error(`反向扫startIdx: ${ startIdx }`, `j: ${ j }`);\r\n    if (stringArr[j] == c) {\r\n      console.error(j, '------------');\r\n      let curIdx = Math.abs(j - startIdx);\r\n      \r\n      if (total) {\r\n        total = total > curIdx ? curIdx : total; // 最小移动差值\r\n      } else { // 如果上一个往右扫没有满足条件，这里 total 就为 undefined，做下兼容。\r\n        total = curIdx;\r\n      }\r\n      \r\n      break;\r\n    }\r\n  }\r\n\r\n  res.push(total);\r\n  return findMinIdx(startIdx + 1, stringArr, c, res);\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839448979","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = new Array();\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  this.stack.length < this.maxSize && (this.stack.push(x));\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  let resNum = -1;\r\n\r\n  this.stack.length && (resNum = this.stack.pop());\r\n  return resNum;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let endIdx = Math.min(this.stack.length, k);\r\n\r\n  for (let i = 0; i < endIdx; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840540108","body":"```js\r\n/**\r\n * @desc 题解：https://algo91.herokuapp.com/solutionDetail?type=3&id=4&max_id=2 这道题没想出来\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\n// 最符合直觉的版本 利用栈\r\nvar decodeString = function(s) {\r\n  var stack = []; // 栈 字符串首部依次压入栈\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] == ']') {\r\n      let pop = stack.pop(); // 栈顶取出 并记录值 \r\n      let repeatStr = pop; // 要 repeat 的字符串                                \r\n      \r\n      // 栈顶不是 \"[\" 时，再出栈的说明是要 repeat 的字符串\r\n      while(pop !== '[') {\r\n        pop = stack.pop(); // 总会多一次 pop 也就是 pop 为 '['\r\n        pop !== '[' && (repeatStr = pop + repeatStr); // 要 repeat 的字符串 注意要 pop + repeatStr，不能 repeatStr + pop, 不然可能乱序\r\n      }\r\n                                          \r\n      // -------------  要 repeat 的字符串已经出栈, 开始处理要 repeat 的次数   ---------------\r\n      pop = stack.pop();\r\n      let repeatCount = pop; // 要 repeat 的次数\r\n      \r\n      // 栈顶是一个数字的时候\r\n      while(!isNaN(pop)) {\r\n        pop = stack.pop(); // 总会多 pop 一次, 后面要 push 回来\r\n        !isNaN(pop) && (repeatCount = pop + repeatCount); // 字符串形式的数字 直接拼接                                 \r\n      }\r\n      \r\n      pop && stack.push(pop); //  要 Push 回来\r\n      stack.push(repeatStr.repeat(repeatCount));\r\n    } else {\r\n       stack.push(s[i]);\r\n      console.log(stack);\r\n    }\r\n  }\r\n  \r\n  return stack.join('');\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841232428","body":"```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\n// 数组的pop 是从末尾删除一位  而队列的 pop，则是从开头删除一位，这道题主要处理这个差异。\r\nvar MyQueue = function() {\r\n  this.stack = []; \r\n  this.bkStack = []; // 辅助栈 用来倒序 pop\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {  \r\n  var result;\r\n  \r\n  // 倒序 取要 pop 的值\r\n  while (this.stack.length) {\r\n    this.bkStack.push(this.stack.pop());\r\n  }\r\n  \r\n  result =  this.bkStack.pop();\r\n  \r\n  // 再正序塞回 stack\r\n  while (this.bkStack.length) {\r\n    this.stack.push(this.bkStack.pop());\r\n  }\r\n  \r\n  return result;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  return this.stack[0];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666714","body":"```js\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n        let sortArr = [...arr].sort((a,b)=> a-b);\r\n        let sum1 = 0, sum2 = 0, count = 0;\r\n        for (let i = 0; i< arr.length; i++){\r\n            sum1+= arr[i];\r\n            sum2+= sortArr[i];\r\n            if (sum1==sum2){\r\n                count += 1;\r\n                sum1 = 0;\r\n                sum2 = 0;\r\n            }   \r\n        }       \r\n        return count   \r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841778754","body":"```js\r\n## 特别需要注意的点就是链表转动和链表尾部移动的区别 \r\n/**\r\n * @desc 看了官方题解，理解了下闭合成环的解题思路 \r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if (k == 0 || !head || !head.next) return head; \r\n  \r\n  // 计算链表长度 head 独占一个位置且存在 故长度从 1 开始\r\n  var linkedListLen = 1; \r\n  var cur = head;\r\n  \r\n  while(cur.next) {\r\n    cur = cur.next;\r\n    linkedListLen++;                \r\n  }\r\n  \r\n  var add = linkedListLen - k % linkedListLen; // 每移动一定周期 链表恢复原状 \r\n\r\n  if (!add) return head;\r\n  \r\n  // 闭合成环状\r\n  cur.next = head;\r\n  \r\n  \r\n  // 转动开始 注意 是转动 不是直接移动 区别在于 \r\n  // 12345 移动一次是 51234 而不是尾部挪到1的位置 最后截断得到23451\r\n  // 就是说 转动1次 = 尾部挪动4次 转动n次 = 尾部挪动 linkedListLen - n 次\r\n  // 所以上面的 add 需要改成 linkedListLen - 移动次数\r\n  while(add) {\r\n    cur = cur.next;\r\n    add--;\r\n  }\r\n  \r\n  // 移动完断开\r\n  head = cur.next;\r\n  cur.next = null;\r\n  \r\n  return head;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841923958","body":"```js\r\n/**\r\n * @ 二刷 递归\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n  if (!head || !head.next) return head;\r\n  var next = head.next; // 保存下第二个节点\r\n  \r\n  head.next = swapPairs(next.next); // 比如 [1, 2, 3, 4], 1 后面应该是 4， 而不是 3，如果是 3，后续不能改 prev，就乱了\r\n  next.next = head;\r\n  \r\n  // 这地方不能 return head, head 已经跑到第二位了，应该把交换后的链表头部 return 出来， 也就是 [2, 1, 4, 3] 代表2的这个位置\r\n  // return head;\r\n  // 这地方的next 代表 第一次声明的 head.next 交换后是链表头部 这是第一层函数作用域的 next 递归函数作用域中的只是赋值给 head.next\r\n  // 比如 4\r\n  return next; \r\n}\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843811311","body":"```js\r\n/**\r\n * 思路 \r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let curA = headA, curB = headB;\r\n  \r\n    // 理解成两个跑道，分别是 A + B 的长度 和 B + A 的长度，因为跑步速度相同，所以有两种情况\r\n    // 要么同时结束(null == null) 要么在公共跑道相遇(走到公共节点) \r\n    // 注意此刻用的是节点之间的对比是否相等 比的是内存地址\r\n    // 比如给定 8 为公共节点(同一个节点)  即便前面遇到节点值 1 跟 1 的对比 也是不等的 因为在不同跑道 没碰到面\r\n    while (curA !== curB) {\r\n      curA = curA ? curA.next : headB;\r\n      curB = curB ? curB.next : headA;\r\n    }\r\n  \r\n    return curA;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844670358","body":"```js\r\n/**\r\n * @desc 直接上哈希大法\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let cur = head;\r\n    let hashSet = new Set();\r\n  \r\n    // 收集节点，直到 hash 表中存在节点 说明成环\r\n    while(cur && !hashSet.has(cur)) {\r\n      hashSet.add(cur);\r\n      cur = cur.next;\r\n    }\r\n  \r\n    return cur;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845752116","body":"```js\r\n// 双向链表。 其好处在于删除和插入的时候，可以更快地找到前驱指针。如果用单链表的话， 那么时间复杂度最坏的情况是 O(n)O(n)。双向链表的本质就是空间换时间，因此如果题目对时间有要求，可以考虑使用双向链表，比如力扣的双向链表的本质就是空间换时间，因此如果题目对时间有要求，可以考虑使用双向链表，比如力扣的 146. LRU 缓存机制 。\r\n/**\r\n * @desc 查看官方题解，使用双向链表+哈希表来实现 并保存双向链表的 head 和 tail\r\n * @desc https://algo91.herokuapp.com/solutionDetail?type=3&id=12&max_id=2\r\n * @param {number} capacity\r\n */\r\n\r\n// 节点中要存有 key 和 val，为什么存 key 呢，因为删除末尾节点时，需要 hash 表中根据 key 也删除对应数据\r\nfunction ListNode (key, val) {\r\n  this.key = key;\r\n  this.val = val;\r\n  this.pre = this.next = null;\r\n};\r\n\r\nlet LRUCache = function(capacity) {\r\n  this.hashMap = {}; // 存储链表的节点的哈希表 用于 O(1) 查找\r\n  this.capacity = capacity; // 容量\r\n  this.size = 0; // 链表节点数，有了这个就不用遍历哈希表拿key的数组，保证 O(1) 的时间复杂度\r\n  this.head = new ListNode(); // 维护了一个虚拟头节点 用于随时访问真实的头节点\r\n  this.tail = new ListNode(); // 维护了一个虚拟尾节点\r\n  this.tail.pre = this.head;  // 注意尾节点的前驱指针指向首节点\r\n  this.head.next = this.tail;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  let node = this.hashMap[key];\r\n\r\n  if (!node) return - 1;\r\n  \r\n  // 从哈希表中取出 key 对应的链表节点，返回它的值，并把新操作的节点更新到头部，时间复杂度 O(1)\r\n  this.removeNode(node); // 链表中删除该节点\r\n  this.appendHead(node); // 重新插入该节点到头部\r\n\r\n  return node.val;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  // 链表节点存在hash表中 则更新值，并移动到链表头部(操作过)\r\n  if (this.hashMap[key]) {\r\n    this.hashMap[key].val = value;\r\n    \r\n    this.removeNode(this.hashMap[key]); // 链表中解开该节点\r\n    this.appendHead(this.hashMap[key]);  // 重新插入该节点\r\n    return;\r\n  }\r\n  \r\n  let node = new ListNode(key, value); // 要插入的节点\r\n  \r\n  // 链表节点不存在, 需要新增链表节点，需要判断是否超长度\r\n  if (this.size == this.capacity) {\r\n      // 删除链表末尾节点 并返回 key，用于删除 hash 对应节点，这也是链表节点存 key 的原因\r\n      let deleteKey = this.deleteTail();\r\n\r\n      delete this.hashMap[deleteKey];\r\n  } else {\r\n      this.size++;\r\n  }\r\n\r\n  this.appendHead(node);    // 更新链表\r\n  this.hashMap[key] = node; // 更新 hash 表\r\n  console.log(key, value, this.head);\r\n};\r\n\r\n// 头部插入元素\r\nLRUCache.prototype.appendHead = function(node) {\r\n  let oldFirstNode = this.head.next;\r\n  \r\n  this.head.next = node;\r\n  node.next = oldFirstNode;\r\n  node.pre = this.head;\r\n  oldFirstNode.pre = node;\r\n}\r\n\r\n// 删除某元素\r\nLRUCache.prototype.removeNode = function (node) {\r\n  let pre = node.pre, next = node.next;\r\n  \r\n  pre.next = next;\r\n  next.pre = pre;\r\n}\r\n\r\n// 删除链表尾部元素 返回 key\r\nLRUCache.prototype.deleteTail = function () {\r\n  let lastNode = this.tail.pre;\r\n\r\n  this.removeNode(lastNode);\r\n\r\n  return lastNode.key;\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846342444","body":"## 思路\r\n* 递归\r\n* 层序遍历 BFS\r\n\r\n## 递归解法\r\n```js\r\n这个问题不能想的太复杂，我们只需要知道函数接收一个root，返回的是当前节点的深度即可，其实只需要考虑一层递归 最顶层根节点的最大深度 = (顶层根节点的左子 和 顶层根节点的右子) 最大值，再加上一层到顶层根节点的深度即可\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n   if (root == null) return 0; // 如果当前节点不存在，当前节点的深度为0\r\n\r\n   return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n* 时间复杂度：$O(n)$，其中 $n$ 为二叉树节点的个数。每个节点在递归中只被遍历一次。\r\n* 空间复杂度：$O(height)$，其中 $height$ 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\r\n\r\n## BFS 解法\r\n```js\r\n/**\r\n * BFS 层序遍历\r\n * @desc 收集根节点 然后遍历根节点 并出列该根节点 入列它的左右有效子节点 \r\n * @desc 若一层遍历完事 队列还有节点 则说明有下一层 depthLen++\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  if (!root) return 0;\r\n  let queue = [root];\r\n  let depthLen = 0;\r\n\r\n  // while 大循环 如果有length 说明存在未遍历的层次 继续进循环 depthLen ++ \r\n  while (queue.length) {\r\n    let size = queue.length; // 不能直接去遍历 queue.length，因为 for 循环体对 queue 做了操作。\r\n\r\n    depthLen++;\r\n    // 循环遍历队列\r\n    for (let i = 0; i < size; i++) {\r\n      // 当前遍历的节点出栈\r\n      let cur = queue.shift();\r\n      \r\n      cur.left && queue.push(cur.left);\r\n      cur.right && queue.push(cur.right);\r\n    }\r\n  }\r\n\r\n  return depthLen;\r\n};\r\n```\r\nBFS时间复杂度\r\n时间复杂度：$O(n)$，其中 $n$ 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。\r\n空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 $O(n)$。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846495851","body":"[LC 100. Same Tree](https://leetcode-cn.com/problems/same-tree/submissions/)\r\n\r\n# DFS\r\n> 看到树，就想到递归，递归对比每个节点是否都相等(要同时不存在，要么值同时相等还得同时有左右子树)\r\n\r\n```js\r\nvar isSameTree = function (p, q) {\r\n  // 直接考虑最小单元就行了\r\n  // 如果根节点有一个不存在，就看另一个是否存在，如果也不存在，说明该根节点相等，return true 没毛病\r\n  // 如果另一个节点存在，直接说明该节点不等(也说明两树不能)，return false\r\n  if (!p || !q) {\r\n    return !p && !q;\r\n  }\r\n\r\n  // 如果根节点的值相同而且左右节点也完全相同 说明是同样结构的树\r\n  return (p.val == q.val &&\r\n    isSameTree(p.left, q.left) &&\r\n    isSameTree(p.right, q.right)\r\n  )\r\n}\r\n```\r\n* 时间复杂度 O(n), 每个节点值走一次\r\n* 空间复杂度 O(n), 执行栈的开销\r\n\r\n# BFS\r\n>  如果每层结构相同(包含不存在的节点) 说明树相同\r\n\r\n```js\r\nvvar isSameTree = function (p, q) {\r\n  let queueP = [p], queueQ = [q];\r\n\r\n  while(queueP.lenth || queueQ.length) {\r\n    if (queueP.length !== queueQ.length) return false;\r\n\r\n    let sizeP = queueP.length;\r\n\r\n    for (let i = 0; i < sizeP; i++) {\r\n      let curRootP = queueP.shift(), curRootQ = queueQ.shift();\r\n      console.log(curRootP, curRootQ);\r\n\r\n      // 一个节点为 null  另一个不为 null 返回 false\r\n      // 两个都为 null 判断是不是最后一个节点(最后一次循环) \r\n      if (!curRootP || !curRootQ) {\r\n        // 如果节点不等 也就是一个为 null 一个不为 null 直接返回 false\r\n        if (curRootP != curRootQ) return false;\r\n\r\n        // 说明接下来没有循环了 而且两节点都为 null\r\n        if (!queueP.lenth && !queueQ.length) {\r\n          return true;\r\n        } else {\r\n          // 接下来还有循环 比如 [1] [1, null, 2] 第二次循环虽然都为null 但是还有第三次循环\r\n          // 跳过当前循环\r\n          continue; \r\n        }\r\n      }\r\n\r\n      // 当前 root 节点不一致 返回 false\r\n      if (curRootP.val !== curRootQ.val) return false; \r\n\r\n      queueP.push(curRootP.left);\r\n      queueP.push(curRootP.right);\r\n      queueQ.push(curRootQ.left);\r\n      queueQ.push(curRootQ.right);\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n```\r\n* 时间复杂度 O(n), 每个节点值走一次\r\n* 空间复杂度 O(k), k 为最队列的元素个数 \r\n\r\n\r\n\r\n#  前序 + 中序 确定一棵树\r\n>  如何确定一棵树，答案就是前序 + 中序\r\n```js\r\nvar isSameTree = function (p, q) { \r\n  let preQueueP = preOrder(p, []),\r\n  preQueueQ = preOrder(q, []),\r\n  inQueueP = inOrder(p, []),\r\n  inQueueQ = inOrder(q, []);\r\n\r\n  console.log(preQueueP, preQueueQ, 'pre')\r\n  console.log(inQueueP, inQueueQ, 'in');\r\n  return String(preQueueP) == String(preQueueQ) && String(inQueueP) == String(inQueueQ);\r\n}\r\n\r\n// 前序 根左右\r\nvar preOrder = function(root, res) {\r\n  if (!root) {\r\n    res.push(null);\r\n\r\n    return res;\r\n  }\r\n\r\n  if (root) {\r\n    res.push(root.val);\r\n    preOrder(root.left, res);\r\n    preOrder(root.right, res);\r\n  }\r\n\r\n  return res;\r\n}\r\n\r\n// 中序 左根右\r\nvar inOrder = function(root, res) {\r\n  if (!root) {\r\n    res.push(null);\r\n\r\n    return res;\r\n  }\r\n\r\n  if (root) {\r\n    preOrder(root.left, res);\r\n    res.push(root.val); // 中间收集 叫中序\r\n    preOrder(root.right, res);\r\n  }\r\n\r\n  return res;\r\n}\r\n```\r\n* 时间复杂度：O(N)，其中 N 为树的节点数，准确的讲是 O(4N) 常数省略。\r\n* 空间复杂度：使用了中序遍历的结果数组，因此空间复杂度为 O(N)，其中 N 为树的节点数。\r\n\r\n\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"breadfruit":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838590094","body":"## 思路\r\n遍历当前数组，分别从两边开始寻找，知道两边分别找到指定字符，然后取最小值加入结果数组。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        for i in range(len(s)):\r\n            l = r =i\r\n            while l > -1:\r\n                if s[l] == c: break\r\n                l -= 1\r\n            while r < len(s):\r\n                if s[r] == c: break\r\n                r += 1\r\n            if l == -1: l = -10000\r\n            if r == len(s): r = 20000\r\n            ans.append(min(r-i,i-l))\r\n        return ans\r\n```\r\n## 复杂度\r\n- 时间复杂度：O(N^2)\r\n- 空间复杂度：O(1)\r\n题目的数据范围是 10000，所以 [-10000,20000]"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839238762","body":"## 思路\r\n1. 需要两个判断变量，一个是记录当前栈顶元素位置p，另一个是记录最大栈空间的位置q。\r\n2. push的时候判断当前栈顶元素位置p是否会大于最大栈空间的位置q\r\n3. pop判断当前栈中是否有元素\r\n4. increment判断k和当前栈顶元素位置p的大小\r\n## 代码\r\n语言支持:Python3\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.top = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top > len(self.stack):\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack: \r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, len(self.stack))\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n\r\n\r\n```\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack)-1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top > -1: \r\n            temp = self.stack[self.top]\r\n            self.top -= 1\r\n            return temp\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stack[i] += val\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840554020","body":"# 辅助栈\r\n## 思路\r\n首先理清楚，我们要判断的值有哪一些，什么时候进栈，什么时候出栈，栈里面存的是什么\r\n1. 我们首先要判断的参数有四种，分别是'[', ']', 数字，字母。\r\n2. 我们的值是'['的时候进栈，']'的时候出栈\r\n3. 用res 记录括号[]里面的字符串res \r\n4. 栈里面存两个变量一个是两个[ [ 做括号之间的字符串用来与当前res进行拼接，一个是记录当前res需要重复的次数\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# dfs\r\n## 思路\r\n我们要理清dfs的参数是什么，终止条件是什么，递归的工作是什么\r\n1. dfs的参数是当前字符串，开始循环的下标\r\n2. 终止条件是下标超标\r\n3. 递归的工作是从i+1往下继续搜索\r\n## 代码思想\r\n当 s[i] == ']' 时，返回当前括号内记录的 res 字符串与 ] 的索引 i （更新上层递归指针位置）；\r\n当 s[i] == '[' 时，开启新一层递归，记录此 [...] 内字符串 tmp 和递归后的最新索引 i，并执行 res + multi * tmp 拼接字符串。\r\n遍历完毕后返回 res。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        def dfs(s, i):\r\n            res, multi = \"\", 0\r\n            while i < len(s):\r\n                if '0' <= s[i] <= '9':\r\n                    multi = multi * 10 + int(s[i])\r\n                elif s[i] == '[':\r\n                    i, tmp = dfs(s, i + 1)\r\n                    res += multi * tmp\r\n                    multi = 0\r\n                elif s[i] == ']':\r\n                    return i, res\r\n                else:\r\n                    res += s[i]\r\n                i += 1\r\n            return res\r\n        return dfs(s,0)\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840890634","body":"## 辅助栈\r\n### 思路\r\n1. 利用一个辅助栈实现队列，栈是先进后出，而队列是先进先出，也就是对于栈来说实现队列无疑就是将最靠近栈底的元素提前pop处理，从栈底push元素，从数据结构来看是无法实现的，那么我们可以换一个思路，用一个辅助栈把你暂存，\r\n2. 对于pop暂存除栈底意外的元素，然后再把栈底pop出去，然后再把暂存在辅助栈的那些元素依次从辅助栈pop出去append到原来的栈中\r\n3. 对于push，依次暂存原来栈中所有元素，然后在辅助栈顶push题目要求的元素，然后依照栈操作，依次又从辅助栈pop，append到原来栈中。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stack:\r\n            self.help_stack.append(self.stack.pop())\r\n        self.help_stack.append(x)\r\n        while self.help_stack:\r\n            self.stack.append(self.help_stack.pop())\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stack.pop()\r\n        \r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stack)\r\n```\r\n\r\n## 双栈\r\n### 思路\r\n用两个栈实现队列，一个栈用来进行读操作(push)，一个栈用来写操作(pop,empty,peek)\r\n1. 栈a进行push操作\r\n2. 在进行pop，peek操作的时候，如果栈b有元素，直接pop，没有的话，在栈a有元素的时候，栈a进行pop添加到栈b再进行pop\r\n3. 当栈a，b为空的时候才是空的\r\n### 延伸阅读\r\n-   其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n-  当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.a = []\r\n        self.b = []\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.a.append(x)\r\n        \r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.b:\r\n            while self.a:\r\n                self.b.append(self.a.pop())\r\n        return self.b.pop()\r\n             \r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.b:\r\n            while self.a:\r\n                self.b.append(self.a.pop())\r\n        return self.b[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if not(self.a or self.b):\r\n            return True\r\n        return False\r\n```\r\n\r\n## 栈混洗\r\n### 思路\r\n栈混洗也是借助另外一个栈来完成\r\n- 将 pushed 队列中的每个数都 push 到栈中，同时检查这个数是不是 popped 序列中下一个要 pop 的值，如果是就把它 pop 出来。\r\n### 代码\r\n```\r\nclass Solution(object):\r\n    def validateStackSequences(self, pushed, popped):\r\n        j = 0\r\n        stack = []\r\n        for x in pushed:\r\n            stack.append(x)\r\n            while stack and j < len(popped) and stack[-1] == popped[j]:\r\n                stack.pop()\r\n                j += 1\r\n        return j == len(popped)\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841581858","body":"## 单调栈里面的分块融合\r\n也许你和我一样，一开始想着用单调栈\r\n  1. 比栈顶大的元素，分块\r\n  2. 和栈顶相等的元素，分块\r\n  3. 比栈顶小的元素，融合为块。\r\n\r\n\r\n但我在测试用例中[4,2,2,1,1]运用这个过不来，因为按照我上面那个思路，j结果是[4,2],[2,1],[1],但是结果是[4,2,2,1,1]\r\n这是为什么？其实因为我们只考虑到局部，就是只能判断当前栈顶的值比较，没错我们是在比较寻找最大值，但是这里是分块，你不能确保上一个分块的最大值和你当前块的比较，你比较的是当前块的最大值而已，好比[4,2]和[2,1]我们只能确保当前分块是递减的。\r\n那么就像力扣加加说的那样，我们来逆向思维，比较整体的每一块的最大值而不是当前块！遇到比当前栈顶小的就合并，被老大吃了，大家只能看到最大的那个。\r\n如何比较呢\r\n## 思路\r\n1. 遍历数组，遇到比当前小的元素直接添加到栈中等到遇到比当前栈顶元素大的元素时，保留当前栈顶元素(可以理解栈顶元素就是当前块的代表，也就是最大值)，把栈清空，再将当前块的代append上去(比他小的都和他融为一体了)，可以理解为块代表的比较，以此类推\r\n举个例子：\r\n[5,4,4,3,1,1]\r\n正确分区为[5,4,4,3,1,1],因为5作为一开始的栈顶，遍历完，5最为这块区域的老大，没有比他更大的了\r\n[2,1,3,4,4]\r\n正确分区为[2, 1], [3], [4], [4],其实栈中此时记录的是各区的老大,[2,3,4,4],因为[1,2]进行相融合并了\r\n## 代码\r\n语言：Python3\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, A: [int]) -> int:\r\n        stack = []\r\n        for i in A :\r\n            if stack and stack[-1] > i:\r\n                cur = stack[-1]\r\n                while stack and stack[-1] > i:\r\n                    stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(i)\r\n        return len(stack)\r\n```\r\n## 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841779351","body":"## 思路\r\n1. 链表与数组不同，无法直接获得长度，只能进行对链表进行一次遍历计算链表长度，然后k对链表长度取余，取保k在链表内移动。\r\n2. 利用快指针先比慢指针先走k步。\r\n3.  让快慢指针一起走，直到快指针的next为none，利用慢指针确定链表的尾指针，用新节点保存新链表的头指针，利用快指针来改变旧链表指向。\r\n## 代码\r\n语言支持：Python3\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head, k):\r\n        if not head or not head.next:\r\n            return None\r\n        fast,slow = head,head\r\n        #计算链表长度\r\n        count = 0\r\n        cur = head\r\n        while cur:\r\n            count += 1\r\n            cur = cur.next\r\n        if k == 0: return head\r\n        k = k % count\r\n        while k :\r\n            k -= 1\r\n            fast = fast.next\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        res = slow.next\r\n        slow.next = None\r\n        fast.next = head\r\n        return res\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：节点最多只遍历两遍，时间复杂度为O(n)\r\n空间复杂度：未使用额外的空间，空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841926382","body":"# 24. 两两交换链表中的节点\r\n## 递归\r\n### 思路\r\n1. 递归的参数是什么？\r\n将逆转后的尾节点.next \r\n2. 递归的任务是什么？怎么实现？\r\n定义一个临时节点使\r\n```\r\n临时节点 = head.next\r\n head.next = run(临时节点.next)\r\n 临时节点.next = head\r\n```\r\n3. 递归的返回值是什么？\r\n逆转后的链表头节点\r\n### 代码\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return head\r\n        newhead = head.next\r\n        head.next = self.swapPairs(newhead.next)\r\n        newhead.next = head\r\n        return newhead\r\n```\r\n## 迭代\r\n### 思路\r\n\r\n1. 创建哑结点 dummyHead，令 dummyHead.next = head。\r\n2. 令 temp 表示当前到达的节点，初始时 temp = dummyHead。\r\n3. 每次需要交换 temp 后面的两个节点。\r\n\r\n<img width=\"612\" alt=\"截屏2021-05-17 上午9 56 37\" src=\"https://user-images.githubusercontent.com/67834178/118422694-4c1b4e00-b6f6-11eb-93fb-152c772434f5.png\">\r\n\r\n### 代码\r\n语言支持Python3\r\n```\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummyHead = ListNode(0)\r\n        dummyHead.next = head\r\n        temp = dummyHead\r\n        while temp.next and temp.next.next:\r\n            node1 = temp.next\r\n            node2 = temp.next.next\r\n            temp.next = node2\r\n            node1.next = node2.next\r\n            node2.next = node1\r\n            temp = node1\r\n        return dummyHead.next\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842705699","body":"# 快慢指针\r\n## 思路\r\n找出链表中位数节点的方法多种多样，其中较为简单的一种是「快慢指针法」。初始时，快指针 fast 和慢指针 slow 均指向链表的左端点left。我们将快指针 fast 向右移动两次的同时，将慢指针 slow 向右移动一次，直到快指针到达边界（即快指针到达右端点或快指针的下一个节点是右端点）。此时，慢指针对应的元素就是中位数。\r\n在找出了中位数节点之后，我们将其作为当前根节点的元素，并递归地构造其左侧部分的链表对应的左子树，以及右侧部分的链表对应的右子树。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(left,right):\r\n            fast = slow = left\r\n            while fast != right and fast.next != right:\r\n                fast = fast.next.next\r\n                slow = slow.next\r\n            return slow\r\n        def buildTree(left,right):\r\n            if left == right:\r\n                return None\r\n            mid = getLength(left,right)\r\n            root = TreeNode(mid.val)\r\n            root.left = buildTree(left,mid)\r\n            root.right = buildTree(mid.next,right)\r\n            return root\r\n        return buildTree(head,None)\r\n```\r\n## 复杂度\r\n时间复杂度：O(nlogn)\r\n时间复杂度：O(logn)\r\n# 中序遍历\r\n## 思路\r\n设当前链表的左端点编号为 left，右端点编号为 right，包含关系为「双闭」，即 left 和right 均包含在链表中。链表节点的编号为 [0, n)[0,n)。中序遍历的顺序是「左子树 - 根节点 - 右子树」，那么在分治的过程中，我们不用急着找出链表的中位数节点，而是使用一个占位节点，等到中序遍历到该节点时，再填充它的值。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getLength(head):\r\n            count = 0\r\n            while head:\r\n                count += 1\r\n                head = head.next\r\n            return count\r\n        def buildTree(left,right):\r\n            if left > right :\r\n                return None\r\n            root = TreeNode()\r\n            mid = (left+right +1) // 2 \r\n            root.left = buildTree(left,mid-1)\r\n            nonlocal head\r\n            root.val = head.val\r\n            head = head.next\r\n            root.right = buildTree(mid+1,right)\r\n            return root\r\n\r\n        length = getLength(head)\r\n        return buildTree(0,length-1)\r\n```\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843617719","body":"# 相交链表\r\n对于相交链表普遍有两种解法，哈希和双指针\r\n## 双指针\r\n### 思路\r\n题目是两个链表某个节点开始后那部分是相同的，我们的目的是寻找那个首个公共的起点并获取两链表公共尾部。\r\n根据数学思想：\r\n考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，做如下操作：\r\n\r\n指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：\r\na + (b - c)\r\na+(b−c)\r\n\r\n指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：\r\nb + (a - c)\r\nb+(a−c)\r\n\r\n如下式所示，此时指针 A , B 重合，并有两种情况：\r\n\r\na + (b - c) = b + (a - c)\r\na+(b−c)=b+(a−c)\r\n\r\n若两链表 有 公共尾部 (即 c > 0c>0 ) ：指针 A , B 同时指向「第一个公共节点」node 。\r\n若两链表 无 公共尾部 (即 c = 0c=0 ) ：指针 A , B 同时指向 null\r\n### 代码\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A, B = headA, headB\r\n        while A != B:\r\n            A = A.next if A else headB\r\n            B = B.next if B else headA\r\n        return A\r\n\r\n```\r\n## 哈希\r\n### 思路\r\n遍历链表 A 并将每个结点的地址/引用存储在哈希表中。然后检查链表 B 中的每一个结点 bi\r\n是否在哈希表中。若在，则 bi为相交结点。\r\n### 代码\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        A = set()\r\n        cur1 = headA\r\n        cur2 = headB\r\n        while cur1:\r\n            A.add(cur1)\r\n            cur1 = cur1.next\r\n        while cur2:\r\n            if cur2 in A:\r\n                return cur2\r\n            cur2 = cur2.next\r\n        return None\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844595447","body":"# 环形链表\r\n## 快慢指针解决环形链表\r\n### 思路\r\n![142_fig1](https://user-images.githubusercontent.com/67834178/118901859-e5d93a00-b946-11eb-8af8-292764c3164b.png)\r\n1. 设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nc。\r\n2. 根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 22 倍。因此，我们有 \r\na+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)\r\n3. 有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。\r\n4. 因此，当发现 slow 与fast 相遇时，我们再额外使用一个指针ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。\r\n### 代码\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow = head,head\r\n        while True:\r\n            if not fast or not fast.next: return \r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                break\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n## 哈希\r\n### 思路\r\n我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。\r\n### 代码\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        dic = {}\r\n        while head:\r\n            if dic.get(head):\r\n                return head\r\n            dic[head] = 1\r\n            head = head.next\r\n        return head\r\n```\r\n### 复杂度\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845589863","body":"# 哈希+双向链表\r\n## 思路\r\n1. LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。\r\n双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。\r\n2. 哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。\r\n这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。\r\n3. 对于 get 操作，首先判断 key 是否存在：\r\n- 如果 key 不存在，则返回 -1；\r\n- 如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。\r\n4. 对于 put 操作，首先判断 key 是否存在：\r\n- 如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；\r\n- 如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。\r\n## 代码\r\n语言支持:Python3\r\n```\r\nclass DLinkNode:\r\n    def __init__ (self,key = 0,value = 0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkNode()\r\n        self.tail = DLinkNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n        \r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveTohead(node)\r\n        return node.value\r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkNode(key, value)\r\n            self.cache[key] = node\r\n            self.addTohead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveTohead(node)\r\n        \r\n        \r\n    def addTohead(self,node):\r\n        node.pre = self.head\r\n        node.next = self.head.next\r\n        self.head.next.pre = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self,node):\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n    def moveTohead(self,node):\r\n        self.removeNode(node)\r\n        self.addTohead(node)\r\n        \r\n    def removeTail(self):\r\n        node = self.tail.pre\r\n        self.removeNode(node)\r\n        return node\r\n        \r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：对于 put 和 get 都是 O(1)。\r\n空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846348550","body":"# DFS\r\n## 思路\r\n1. 深度搜索的终止条件是什么？遍历到深度为0的根结点\r\n2. 深度搜索的内容是什么？判断当前根节点是否有左右节点，取最大值\r\n3. 返回值什么？当前深度➕1\r\n4. 递归参数什么？新的根节点\r\n## 代码\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right)) + 1\r\n```\r\n# BFS\r\n## 思路\r\n我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        queue = [root]\r\n        ans = 0\r\n        while queue:\r\n            temp = []\r\n            for i in queue:\r\n                if (i.left): temp.append(i.left)\r\n                if (i.right): temp.append(i.right)\r\n            queue = temp\r\n            ans += 1\r\n        return ans\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846509633","body":"# DFS\r\n## 思路\r\n终止条件与返回值：\r\n1. 当两棵树的当前节点都为 null 时返回 true\r\n2. 当其中一个为 null 另一个不为 null 时返回 false\r\n3. 当两个都不为空但是值不相等时，返回 false\r\n## 代码\r\n```\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        elif p.val != q.val:\r\n            return False\r\n        else:\r\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n# BFS\r\n## 思路\r\n使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。\r\n比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同；\r\n1. 如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同；\r\n2. 如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。\r\n3. 如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。(用异或实现，两个数相同则为0，不相同为1)\r\n## 代码\r\n```\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not q and not p:\r\n            return True\r\n        if not q or not q:\r\n            return False\r\n        queue1 = collections.deque([p])\r\n        queue2 = collections.deque([q])\r\n        while queue1 and queue2:\r\n            node1 = queue1.popleft()\r\n            node2 = queue2.popleft()\r\n            if node1.val != node2.val:\r\n                return False\r\n            left1, right1 = node1.left, node1.right\r\n            left2, right2 = node2.left, node2.right\r\n            if (not left1) ^ (not left2):\r\n                return False\r\n            if (not right1) ^ (not right2):\r\n                return False\r\n            if left1:\r\n                queue1.append(left1)\r\n            if right1:\r\n                queue1.append(right1)\r\n            if left2:\r\n                queue2.append(left2)\r\n            if right2:\r\n                queue2.append(right2)\r\n        return not queue1 and not queue2\r\n```\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoluomo":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597001","body":"# 思路\r\n  正向和逆向分别遍历数组，计算和上一个目标字符的最短距离，保留两次遍历中较小的距离\r\n  实现时下面的边界条件，容易出现问题\r\n  let lastC = Number.MIN_SAFE_INTEGER;\r\n  lastC = Number.MAX_SAFE_INTEGER;\r\n# 代码\r\n\r\n```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    const number = new Array(s.length).fill(Number.MAX_SAFE_INTEGER);\r\n    const strs = s.split(\"\");\r\n    let lastC = Number.MIN_SAFE_INTEGER;\r\n    strs.forEach((item, index) => {\r\n        if(item === c){\r\n            number[index] = 0;\r\n            lastC = index;\r\n        }else{\r\n            number[index] = index - lastC;\r\n        }\r\n    })\r\n    lastC = Number.MAX_SAFE_INTEGER;\r\n    for(let i = strs.length - 1; i >= 0; i--){\r\n        if(strs[i] === c){\r\n            number[i] = 0;\r\n            lastC = i;\r\n        }else{\r\n            number[i] = Math.min(number[i], lastC - i);\r\n        }\r\n    }\r\n\r\n    return number;\r\n};\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844168419","body":"# 思路: 双指针\r\n代码\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  if (!headA || !headB) return null\r\n  let p1 = headA;\r\n  let p2 = headB;\r\n  while(p1 !== p2) {\r\n    p1 = p1 ? p1.next : headB;\r\n    p2 = p2 ? p2.next : headA;\r\n  }\r\n  return p1;\r\n}\r\n\r\n```\r\n\r\n复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiuhaoLi":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838597599","body":"## 思路\r\n\r\n使用双指针，分别指向匹配字符。从左向右扫描并更新距离，当发现新的匹配字符更新第二个指针时，进行回溯更新距离（与第一个指针间一半的字符需要更新）。\r\n\r\n要考虑到可能只有一个匹配字符（第二个指针为空）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Note: The returned array must be malloced, assume caller calls free().\r\n */\r\nint* shortestToChar(char * s, char c, int* returnSize){\r\n    size_t string_size = strlen(s);\r\n    *returnSize = string_size;\r\n    if (string_size == 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    int *distance = malloc(string_size * sizeof(int));\r\n    //error handling\r\n\r\n    long index_c_first = -1;\r\n    long index_c_second = -1;\r\n\r\n    for (long i = 0; i < string_size; ++i)\r\n    {\r\n        if (s[i] == c)\r\n        {\r\n            if (index_c_first == -1)\r\n            {\r\n                index_c_first = i;\r\n                for (long j = index_c_first; j >=0; --j)\r\n                {\r\n                    distance[j] = index_c_first-j;\r\n                }\r\n            }\r\n            else if (index_c_second == -1)\r\n            {\r\n                index_c_second = i;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                long tmp = index_c_second;\r\n                index_c_second = i;\r\n                index_c_first = tmp;\r\n                for (long j = index_c_second; j > (index_c_second+index_c_first)/2; --j)\r\n                {\r\n                    distance[j] = index_c_second-j;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            long index_c = index_c_second == -1 ? index_c_first : index_c_second;\r\n            if (index_c != -1)\r\n            {\r\n                distance[i] = i - index_c;\r\n            }\r\n        }\r\n    }\r\n\r\n    return distance;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839409800","body":"## 思路\r\n\r\n用数组模拟栈，维护最大长度和栈顶。\r\n\r\n关键点在于`inc`操作，如果每次都对`min(k, obj->top)`进行逐个操作，复杂度将为`O(n)`。注意到栈的结构和`inc`操作的相似性，我们可以用另一个栈保存（或者每个栈元素中保存）当前元素及下方元素应该加的数，`pop`操作时将这个数加上，并传递至下方元素。\r\n\r\n## 代码\r\n\r\n```c\r\ntypedef struct {\r\n    size_t maxSize;\r\n    long top;\r\n    int *stack;\r\n    int *add;\r\n} CustomStack;\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    if (maxSize < 0)\r\n    {\r\n        return NULL;\r\n    }\r\n\r\n    CustomStack * result = malloc(sizeof(CustomStack));\r\n    result->stack = malloc(maxSize * sizeof(result->stack[0]));\r\n    result->add = calloc(maxSize, sizeof(result->add[0]));\r\n    // error handing\r\n\r\n    result->top = 0;\r\n    result->maxSize = maxSize;\r\n\r\n    return result;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    long top = obj->top;\r\n    if (top >= obj->maxSize)\r\n    {\r\n        return;\r\n    }\r\n    obj->stack[top] = x;\r\n    ++obj->top;\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    long top = obj->top;\r\n    if (top <= 0)\r\n    {\r\n        return -1;\r\n    }\r\n\r\n    --obj->top;\r\n    int result = obj->stack[obj->top] + obj->add[obj->top];\r\n\r\n    if (obj->top > 0)\r\n    {\r\n        obj->add[obj->top - 1] += obj->add[obj->top];\r\n    }\r\n    obj->add[obj->top] = 0;\r\n\r\n    return result;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    long inc_top = k < obj->top ? k : obj->top;\r\n    if (inc_top <= 0)\r\n    {\r\n        return;\r\n    }\r\n\r\n    obj->add[inc_top - 1] += val;\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->stack);\r\n    free(obj->add);\r\n    free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：各项操作均为O(1)\r\n空间：O(maxSize)"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842390366","body":"## 思路\r\n\r\n由于每次都是交换两个元素，用两个指针`p1`，`p2`指向两个元素。`p2`肯定要指向`p1`，而`p1`分三种情况：\r\n\r\n1. `p3 = p2->next; p2->next = p1`。若`p3`为空，则转换完毕，`p1`是最后一个元素，`p1->next = NULL`。（偶数个）\r\n2. 若`p3->next`为空，则转换完毕，`p1`指向最后一个元素`p3`。（奇数个）\r\n3. 否则继续迭代，`p1->next = p3->next`，`p1 = p3`，`p2 = p3->next`。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     struct ListNode *next;\r\n * };\r\n */\r\n\r\n\r\nstruct ListNode* swapPairs(struct ListNode* head){\r\n    if (head == NULL || head->next == NULL)\r\n    {\r\n        return head;\r\n    }\r\n\r\n    struct ListNode *p1, *p2;\r\n    p1 = head;\r\n    p2 = head->next;\r\n    head = p2;\r\n    \r\n    while(true)\r\n    {\r\n        struct ListNode *p3 = p2->next;\r\n        p2->next = p1;\r\n        if (p3 == NULL)\r\n        {\r\n            p1->next = NULL;\r\n            break;\r\n        }\r\n\r\n        struct ListNode *p4 = p3->next;\r\n        if (p4 == NULL)\r\n        {\r\n            p1->next = p3;\r\n            break;\r\n        }\r\n\r\n        p1->next = p4;\r\n        p1 = p3;\r\n        p2 = p4;\r\n    }\r\n\r\n    return head;\r\n}\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846504904","body":"## 思路\r\n先深搜索（递归）判断两个树是否相同。首先判断根节点，如果相同（包括都为`NULL`），则返回`true`；如果有一个为NULL，返回`false`；否则判断val是否相同，如果不同返回`false`，如果相同返回左右子树判断的与（递归）。\r\n\r\n## 代码\r\n\r\n```c\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     struct TreeNode *left;\r\n *     struct TreeNode *right;\r\n * };\r\n */\r\n\r\n\r\nbool isSameTree(struct TreeNode* p, struct TreeNode* q){\r\n    if (p == q)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    if (p == NULL || q == NULL)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    if (p->val != q->val)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    bool left = isSameTree(p->left, q->left);\r\n    bool right = isSameTree(p->right, q->right);\r\n\r\n    return left && right;\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间：O(min(n, m))\r\n空间：O(min(n, m))"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zfaye":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838600080","body":"**思路**：[indexOf](int ch）[indexOf](int ch,  int fromIndex)获取前后两个指针，取小的绝对距离\r\n\r\n代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        //int[] index=new int[s.length()];\r\n        int cur=s.indexOf(c);int pre=cur;\r\n       // Iterator<Integer> it=index.iterator();\r\n        int[] ans=new int[s.length()];\r\n        for(int i=0;i<s.length();i++){\r\n            if(s.charAt(i)== c) {\r\n               ans[i]=0;\r\n               pre=i;\r\n               cur=s.indexOf(c,i+1);\r\n            }else{\r\n                ans[i]=Math.min(Math.abs(i-pre),Math.abs(cur-i));\r\n             }\r\n\r\n\r\n        }\r\n\r\n\r\n    return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)?"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839632151","body":"思路：使用数组实现栈。成员变量top指向栈顶，在push()中判断溢出，pop()中分别判断栈是否为空。使用循环进行累加。\r\n\r\n```Java\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int maxSize;\r\n    int top=-1;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        this.maxSize=maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top+1<maxSize){\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n            top--;\r\n            return  stack[top+1];\r\n\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num=Math.min(k, top+1);\r\n        for (int i = 0; i < num; i++) stack[i]+=val;\r\n    }\r\n  \r\n  \r\n}\r\n```\r\n\r\n时间复杂度：O(min(k,cnt))\r\n\r\n空间复杂度：O(maxsize)\r\n\r\n思路二：将增量的循环操作舍弃，减少时间复杂度；增加一个数组只在pop（）时做加法，牺牲空间。\r\n\r\n```\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int[] increment;\r\n    int maxSize;\r\n    int top = -1;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        increment=new int[maxSize+1];\r\n        this.maxSize=maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if(top+1<maxSize){\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if(top==-1){\r\n            return -1;\r\n        }else{\r\n\r\n\r\n            //top--;\r\n             stack[top]+=increment[top+1];\r\n             increment[top]+=increment[top+1];\r\n             increment[top+1]=0;\r\n             top--;\r\n             return stack[top+1];\r\n\r\n        }\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        //int num=Math.min(k, top+1);\r\n         increment[Math.min(k, top+1)]+=val;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度：O(maxsize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840356324","body":"思路：使用一个栈实现。在遇到右括号时出栈，使用栈的peek()方法，一直出栈，直到遇到左括号。将字符串和次数相乘后入栈。\r\n\r\n```\r\nclass Solution {\r\n\r\n    public String decodeString(String s) {\r\n\r\n        Stack<String> st= new Stack<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == ']') {\r\n                StringBuilder repeatStr = new StringBuilder();\r\n                while (!st.peek().equals(\"[\")) repeatStr.append(st.pop()) ;\r\n\r\n                st.pop();//删去“[”\r\n                StringBuilder scount = new StringBuilder();\r\n                while ((!st.isEmpty()) && (st.peek().charAt(0) >= '0' && st.peek().charAt(0) <= '9')) {\r\n                    scount.append(st.pop()) ;\r\n                }\r\n                scount=scount.reverse();\r\n                int count = Integer.parseInt(scount.toString());\r\n                StringBuilder res = new StringBuilder();;\r\n                for (int j = 0; j < count; j++) res.append(repeatStr) ;\r\n                st.push(res.toString());\r\n            } else {\r\n                String str = \"\" + s.charAt(i);\r\n                st.push(str);\r\n            }\r\n\r\n        }\r\n        StringBuilder ans=new StringBuilder();\r\n        while(!st.isEmpty()){\r\n            ans.append(st.pop());\r\n        }\r\n        ans.reverse();\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840978495","body":"思路：简单题，使用两个栈，在peek()和pop()的时候，把一个栈的内容倒到另一个栈。\r\n\r\n```\r\nclass MyQueue {\r\n\r\n  // int n;\r\n\r\n  Stack<Integer> tmp=new Stack<>();\r\n\r\n  Stack<Integer> st;\r\n\r\n  /** Initialize your data structure here. */\r\n\r\n  public MyQueue() {\r\n\r\n    st=new Stack<>();\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Push element x to the back of queue. */\r\n\r\n  public void push(int x) {\r\n\r\n   st.push(x);\r\n\r\n   //  n++;\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Removes the element from in front of queue and returns that element. */\r\n\r\n  public int pop() { \r\n\r\n     while(tmp.isEmpty()){\r\n\r\n       while(!st.isEmpty())\r\n\r\n      tmp.push(st.pop());\r\n     }\r\n\r\n   \r\n\r\n\r\n\r\n    return tmp.pop();\r\n\r\n\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Get the front element. */\r\n\r\n  public int peek() {\r\n\r\n    // Stack<Integer> tmp=new Stack<>()\r\n\r\n   while(tmp.isEmpty()){\r\n\r\n      while(!st.isEmpty())\r\n\r\n      tmp.push(st.pop());\r\n\r\n    }\r\n\r\n  \r\n\r\n    return tmp.peek();\r\n\r\n\r\n\r\n  }\r\n\r\n  \r\n\r\n  /** Returns whether the queue is empty. */\r\n\r\n  public boolean empty() {\r\n\r\n    return tmp.isEmpty()&&st.isEmpty();\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\n时间复杂度：pop()和peek()只需倒一次后，例如有n个元素，执行n次出栈和n次入栈。后面pop()和peek()都只有一次操作。将前者2n次的操作平均到后面，故均摊复杂度O(1).\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841632788","body":"一看到hard就放弃了，下次争取多想一会儿。\r\n\r\n思路：分块条件：左边最大值小于右边最小值。一看到这种左边右边的，好像都可以用两次遍历解决，分别从左到右，和从右到左。加上比较一共三次循环，效率不高，但是思路简单。\r\n\r\n```java\r\nclass Solution {\r\n\r\n  public int maxChunksToSorted(int[] arr) {\r\n\r\n​    int n=arr.length;\r\n\r\n​    int right_min[]=new int[n];\r\n\r\n​    int left_max[]=new int[n];\r\n\r\n\r\n\r\n​    for(int i=n-1;i>=0;i--){\r\n\r\n​      if(i==n-1) right_min[i]=arr[i];\r\n\r\n​      else\r\n\r\n​      right_min[i]=Math.min(right_min[i+1],arr[i]);\r\n\r\n​    }\r\n\r\n​    int chunks=1;\r\n\r\n​    for(int i=0;i<n-1;i++){\r\n\r\n​      if(i==0) left_max[i]=arr[i];\r\n\r\n​      else\r\n\r\n​      left_max[i]=Math.max(left_max[i-1],arr[i]);\r\n\r\n​      }\r\n\r\n\r\n\r\n​    \r\n\r\n​    for(int i=0;i<n-1;i++){\r\n\r\n​        if(left_max[i]<=right_min[i+1])\r\n\r\n​        chunks++;\r\n\r\n​    }\r\n\r\n​    return chunks;\r\n\r\n  }  \r\n\r\n}\r\n```\r\n\r\nTime：O(n)\r\n\r\nspace:O(n)\r\n\r\n单调栈：满足题意，遍历过程中比左边小的一定要融合；尽可能多分块，比较大的，入栈。需要注意的是块的融合过程（需要弹出已经入栈的元素），需要比较的，也就是说需要保存的是块的最大值，要重新入栈。栈在入栈过程是单调递增的，所以是栈顶值。\r\n\r\n```Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> st=new Stack<Integer>();\r\n        int max;\r\n       // st.push(arr[0]);\r\n        for(int num:arr){\r\n            if(!st.isEmpty()&&num<st.peek()){\r\n                  max=st.peek();\r\n                while(!st.isEmpty()&&num<st.peek())\r\n                 st.pop();//需要融合所以弹出，融完了再入一个最大值（下一步）\r\n\r\n                st.push(max);//栈顶始终为块的最大值\r\n            }//块融合\r\n\r\n\r\n            else st.push(num);//大于等于则为新块，入栈\r\n\r\n           // max=Math.\r\n\r\n        }\r\n        return st.size(); \r\n\r\n    }  \r\n   \r\n}\r\n```\r\n\r\nTime:O(n)\r\n\r\nSpace:O(n)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841783444","body":"思路：卡在循环链表这了。一开始想要逆转链表，方便找到要旋转到前面的元素，但其实链表内部的指向没有变动，转了的话还要再转一（两次）次。思路还是遍历链表得到长度，得到尾指针将其指向头指针形成循环链表，这样就可以找到要搬到前面的元素，断开和他们的链接。\r\n\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head==null||head.next==null||k==0){\r\n            return head;\r\n        }\r\n        ListNode cur=head;\r\n      //  ListNode pre=new ListNode(null,cur);\r\n        int length=1;\r\n       \r\n        while(cur.next!=null){\r\n             cur=cur.next;\r\n             length++;\r\n        }\r\n\r\n        int n=k%length;\r\n\r\n        if(n==0){\r\n            return head;\r\n        }else {\r\n           cur.next=head;\r\n        }\r\n        for(int i=0;i<length-n;i++){\r\n            cur=cur.next;\r\n        }\r\n        head=cur.next;\r\n        cur.next=null;\r\n        return head;\r\n\r\n    }\r\n}\r\n```\r\n\r\ntime:O(n)\r\n\r\nspace:O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843157626","body":"思路：递归，分而治之。终止条件：只剩一个节点，没有左右子树。每一步执行操作：求根节点（链表中点)（划分左右子树）创造一个树节点。返回值：根节点。\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head==null) return null;\r\n        if(head.next==null){\r\n             return new TreeNode(head.val);\r\n        }\r\n        \r\n           \r\n            ListNode tmp1=head;\r\n            ListNode tmp2=head;\r\n            ListNode pre=null;\r\n\r\n            int length=1;\r\n            int n;\r\n            while(tmp1.next!=null){\r\n                tmp1=tmp1.next;\r\n                length++;\r\n            }\r\n            n=length/2+1;\r\n            for(int i=1;i<n;i++){\r\n                if(i==n-1)  pre=tmp2;\r\n                tmp2=tmp2.next;\r\n            }\r\n            pre.next=null;\r\n            \r\n            \r\n            return new TreeNode(tmp2.val,sortedListToBST(head),sortedListToBST(tmp2.next));\r\n    }\r\n}\r\n```\r\n\r\nTime:  递归树深度logn×每一步操作数 O(nlogn)\r\n\r\nSpace:递归树深度logn×每一步变量空间 O(logn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843714347","body":"思路：双指针，详见讲义。循环的判断条件是指针相等退出，有交点找到交点退出；没交点，两个指针都完成两条链表的遍历，都等于Null,相等退出循环。\r\n\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headA==null||headB==null) return null;\r\n        ListNode curA=headA;\r\n        ListNode curB=headB;\r\n        //int flag=0;\r\n       while(curA!=curB){ \r\n            if(curA==null) {curA=headB;}\r\n            else {curA=curA.next;}\r\n\r\n            if(curB==null) curB=headA;\r\n             else curB=curB.next;\r\n          \r\n       }\r\n       return curA;\r\n    }\r\n}\r\n```\r\n\r\nTime：O(m+n)\r\n\r\nSpace：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844773004","body":"思路：哈希表 \r\n\r\nTime：O(n)  space:O(n)\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head==null) return null;\r\n        HashSet<ListNode> hashset=new HashSet<>();\r\n        while(head!=null){\r\n            hashset.add(head);\r\n            head=head.next;\r\n            if(hashset.contains(head))\r\n            return head;\r\n\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n思路：双指针，详见讲义。\r\nTime：O(n)  space:O(1)\r\n\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head==null||head.next==null) return null;\r\n        ListNode fast=head.next.next;\r\n        ListNode slow=head.next;\r\n        while(fast!=slow){\r\n            if(fast!=null && fast.next!=null)\r\n            fast=fast.next.next;\r\n            else\r\n            fast=null;\r\n            slow=slow.next;\r\n            if(fast==null||slow==null)\r\n            return null;\r\n            if(fast==slow){\r\n                fast=head;\r\n                break;\r\n            }\r\n\r\n        }\r\n        while(fast!=slow){\r\n            fast=fast.next;\r\n            slow=slow.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845997296","body":"思路：双向链表+哈希表。哈希表（无序）中储存（key,Node)，实现快速查找，增删。双向链表每个Node储存（key,value),储存key是为了方便删除哈希表中键对值，因为在双向链表删除最后一个元素时，没有key值得话就无法找到map中键值对删除。\r\n\r\n```java\r\nclass Node{\r\n    int key;\r\n    int value;\r\n    Node next,pre;\r\n    public Node(int key,int value){\r\n        this.key=key;\r\n        this.value=value;\r\n    }\r\n} \r\nclass DLinkedNode{\r\n    Node head;\r\n    Node tail;\r\n        \r\n    DLinkedNode(){\r\n         head=new Node(0,0);\r\n         tail=new Node(0,0); \r\n        head.next=tail;\r\n        tail.pre=head;\r\n    }\r\n\r\n    public void remove(Node node){\r\n        node.pre.next=node.next;\r\n        node.next.pre=node.pre;\r\n    }\r\n    public void addfirst(Node node){\r\n        head.next.pre=node;\r\n        node.next=head.next;\r\n        node.pre=head;\r\n         head.next=node;   \r\n\r\n    }\r\n    public Node removelast(){\r\n        Node last=tail.pre;\r\n        remove(last);\r\n        return last;\r\n\r\n    }\r\n    \r\n}\r\nclass LRUCache { \r\n    int capacity;\r\n    HashMap<Integer,Node> map;\r\n    DLinkedNode cache;\r\n \r\n    public LRUCache(int capacity) {\r\n        cache=new DLinkedNode();\r\n         map=new HashMap();\r\n        this.capacity=capacity;\r\n\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(!map.containsKey(key)) return -1;\r\n        else {\r\n           Node val= map.get(key);\r\n           put(key,val.value);\r\n          // cache.remove()\r\n           return val.value;\r\n        }\r\n\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        Node tmp=new Node(key,value);\r\n        if(map.containsKey(key)){//换值\r\n           cache.remove(map.get(key));\r\n           cache.addfirst(tmp);\r\n           map.put(key,tmp);\r\n        }else{\r\n            if(capacity==map.size()){\r\n                Node Lnode =cache.removelast();//先删除\r\n                cache.addfirst(tmp);\r\n                map.remove(Lnode.key);\r\n                map.put(key,tmp);\r\n            }else{\r\n                map.put(key,tmp);\r\n                cache.addfirst(tmp);\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n\r\nTime：O(1)\r\n\r\nSpace:O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846369967","body":"思路：二叉树求最大深度使用递归。\r\n\r\n终止条件：叶节点，返回1\r\n\r\n返回值： 本层的最大深度 =1+左右子树最大深度\r\n\r\n```java\r\nclass Solution {\r\n     int depth=0;\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null) return  0;\r\n      //  if(root.left==null && root.right==null) return 1;\r\n       \r\n        else {\r\n            depth=1+Math.max(maxDepth(root.left),maxDepth(root.right));\r\n            return depth;\r\n        }            \r\n\r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\n\r\n时间：O(n)每个点遍历一遍\r\n\r\n空间：O(h)高度，最坏情况O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846497587","body":"思路：使用递归实现。终止条件：有棵树节点为空；返回值：当前节点及左右子树是否相等的布尔值；每一步操作：比较节点值及左右子树是否相等。\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n            if(p==null && q==null) return  true;\r\n            else if(p==null && q!=null) return false;\r\n            else if(p!=null && q==null) return false;//else if(q==null||p==null)\r\n            else if(p.val==q.val){\r\n                if(isSameTree(p.left,q.left) && isSameTree(p.right,q.right))\r\n                return true;//return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n            }\r\n            return false;\r\n            \r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\n\r\n时间：对两颗二叉树同时进行深度优先搜索。O（min(m,n))\r\n\r\n空间：递归栈，深度优先搜索，最坏情况每个节点都调用递归函数。O（min(m,n))\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838615479","body":"```js\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let array = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        array[i] = s.length;\r\n    }\r\n    for (let i = 0; i < s.length; i++){\r\n        if ( s.substring(i, i+1) === c){\r\n            for (let j = 0; j < s.length; j++){\r\n                array[j] = Math.min(Math.abs(i - j),array[j])\r\n            }\r\n        }\r\n    }\r\n    return array;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839868593","body":"```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.list = [];\r\n    this.maxSize = maxSize\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.list.length < this.maxSize) {\r\n        this.list.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    let res = this.list.pop()\r\n    return res === undefined ? -1 : res\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n   this.list.forEach((item, index) => {\r\n       if (index < k) {\r\n           this.list[index] += val\r\n       }\r\n   }) \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840593759","body":"```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [], stringStack = [], num = 0, result = '';\r\n    for(let cur of s) {\r\n        if (\"0\" <= cur && cur <= \"9\") {\r\n            num = num * 10 + Number(cur)\r\n        } else if (cur === '[') {\r\n            stringStack.push(result);\r\n            numStack.push(num);\r\n            result = '';\r\n            num = 0;\r\n        } else if (cur === ']') {\r\n            let newNum = numStack.pop();\r\n            result = stringStack.pop() + result.repeat(newNum);\r\n        } else {\r\n            result = result + cur\r\n        }\r\n    }\r\n    return result\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680951","body":"```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    const sorted = arr.slice().sort((a, b) => a - b)\r\n    let sum = 0, count = 0, sumSorted = 0\r\n    arr.forEach((item, index) => {\r\n        sum = sum + item;\r\n        sumSorted = sumSorted + sorted[index];\r\n        if (sum === sumSorted) {\r\n            count ++\r\n            sum = sumSorted = 0\r\n        }\r\n    })\r\n    return count\r\n\r\n};\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843266146","body":"```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    const o = []\r\n    while(head) {\r\n        o.push(head.val)\r\n        head = head.next\r\n    } \r\n    function b(x) {\r\n        if (!x.length) return null\r\n        const mid = x.length >>> 1\r\n        const n = new TreeNode(x[mid])\r\n        n.left = b(x.slice(0, mid))\r\n        n.right = b(x.slice(mid + 1))\r\n        return n\r\n    }\r\n    return b(o)\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844210002","body":"```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA,\r\n        pB = headB;\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next;\r\n        pB = pB === null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846410839","body":"```js\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(root === null) {\r\n        return 0;\r\n    }\r\n    let left = maxDepth(root.left);\r\n    let right = maxDepth(root.right);\r\n    return Math.max(left, right) + 1\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"NealChristmas":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838633616","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n\r\n    const stackRight = []\r\n    const stackLeft = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        const char = s[i]\r\n        if (char === c) {\r\n            stackRight.unshift(i)\r\n        }\r\n    }\r\n    let i = 0\r\n    const res = []\r\n    while (i < s.length) {\r\n        let topRight = stackRight[stackRight.length - 1]\r\n        if (topRight !== undefined && i > topRight) {\r\n            stackLeft.push(stackRight.pop())\r\n        }\r\n        topRight = stackRight[stackRight.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackRight[stackRight.length - 1]\r\n        let topLeft = stackLeft[stackLeft.length - 1] === undefined ? Number.MAX_SAFE_INTEGER : stackLeft[stackLeft.length - 1]\r\n        const minDis = Math.min(Math.abs(i - topLeft), Math.abs(i - topRight))\r\n        i++\r\n        res.push(minDis)\r\n    }\r\n    return res\r\n};\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841824274","body":"```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    if (!head) {\r\n        return null\r\n    }\r\n    if (k === 0) {\r\n        return head\r\n    }\r\n    let size = 1\r\n    const ordHead = head\r\n    while (head.next) {\r\n        size++\r\n        head = head.next\r\n    }\r\n    const mod = k % size\r\n    if (mod === 0) {\r\n        return ordHead\r\n    }\r\n    let curr = ordHead\r\n    for (let i = 0; i < (size - mod - 1); i++) {\r\n        curr = curr.next\r\n    }\r\n    const next = curr.next\r\n    head.next = ordHead\r\n    curr.next = null\r\n    return next\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842251301","body":"```javascript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function (head) {\r\n    const preHead = new ListNode()\r\n    let prev = preHead\r\n    preHead.next = head\r\n    while (head && head.next) {\r\n        const swap1 = head\r\n        const swap2 = head.next\r\n        const nextOne = head.next.next\r\n        prev.next = swap2\r\n        swap2.next = swap1\r\n        swap1.next = nextOne\r\n        prev = swap1\r\n        head = nextOne\r\n    }\r\n    return preHead.next\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838653080","body":"- 暴力解法：遍历找出c字符的所有下标，然后找再次遍历找出最小值\r\n-class Solution {\r\npublic:\r\n    vector<int> s1;\r\n    vector<int> s2;\r\n   \r\n    vector<int> shortestToChar(string s, char c) {\r\n    for(int i=0;i<s.length();++i){\r\n        if(s[i] == c){\r\n            s1.push_back(i);\r\n        }\r\n    } \r\n    \r\n    for(int i=0;i<s.length();++i){\r\n        int len=s.length(),minlen=s.length();\r\n        for(int j=0;j<s1.size();++j){\r\n            len = abs(s1[j]-i);\r\n            minlen = min(len,minlen);\r\n        }\r\n        s2.push_back(minlen);\r\n\r\n    }\r\n    return s2;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840653187","body":"思路：用两个栈来解决\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> let;\r\n        stack<int> num;\r\n\r\n        string ans = \"\";\r\n        int cur = 0;\r\n\r\n        for(const char& c : s)\r\n        {\r\n            if(isdigit(c))\r\n                cur = cur*10 + c - '0';\r\n            else if(c == '[')\r\n            {\r\n                let.push(ans);\r\n                num.push(cur);\r\n                cur = 0;\r\n                ans = \"\";\r\n            }\r\n            else if(c == ']')\r\n            {\r\n                string str = ans;\r\n                for(int i = 0; i < num.top()-1; ++i)\r\n                    ans += str;\r\n                ans = let.top() + ans;\r\n                num.pop();\r\n                let.pop();\r\n            }\r\n            else\r\n                ans += c;\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841127783","body":"- 思路：用两个栈来实现队列，一个输入一个输出（先进后出+先进后出 = 先进先出）\r\n- 改进：pop（）和top（）操作都需要判断输出栈是否为空，如果输出栈为空，就把输入栈的数据转到输出栈。由于这样的操作需要两次，可以写成一个类的成员函数in2out，这样代码就只需要写一遍。\r\n- 代码：\r\n`class MyQueue {\r\n    stack<int> s_in;\r\n    stack<int> s_out;\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s_in.push(x);\r\n\r\n    }\r\n    \r\n    void in2out(){\r\n        while(!s_in.empty()){\r\n              s_out.push(s_in.top());\r\n              s_in.pop();\r\n          }\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n      if(s_out.empty()){\r\n          in2out();\r\n      }\r\n      int num_pop = s_out.top();\r\n      s_out.pop();\r\n      return num_pop;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n    if(s_out.empty()){\r\n          in2out();\r\n      }\r\n      int num_top = s_out.top();\r\n      return num_top;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s_in.empty()&&s_out.empty();\r\n     \r\n    }\r\n};`\r\n\r\n- 复杂度分析：\r\n- 时间复杂度：push（）和empty（）都是O（1），pop（）和top（）是O（n）\r\n- 空间复杂度：O（n）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841466401","body":"思路：用栈来存每个模块的最大值。栈有几个最大值，就说明有几个模块。\r\n\r\n代码：\r\n\r\nclass Solution {\r\nint max_num;\r\nstack stack1;\r\n\r\npublic:\r\nint maxChunksToSorted(vector& arr) {\r\nstack1.push(arr[0]); //把第一个元素在循环前插入栈中\r\nfor(int i=1;i<arr.size(); i++){\r\n\r\n   if(stack1.top()<=arr[i]){\r\n      stack1.push(arr[i]);\r\n      \r\n   }\r\n   if(stack1.top()>arr[i]){\r\n       max_num = stack1.top();\r\n       while(!stack1.empty()&&stack1.top()>arr[i]){//这个句子最开始写错了，没加上!stack.empty()&&，会stack已经空了却还在调用stack1.top()的情况出现\r\n           stack1.pop();\r\n       }\r\n       stack1.push(max_num);\r\n       \r\n   }\r\n}\r\nreturn stack1.size();\r\n}\r\n};\r\n\r\nTime: O(n)\r\nSpace: O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843284972","body":"思路：快慢指针找到中间值，作为根节点，然后左右建树（现阶段还不会建树，要在后面学会）\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        if (head == nullptr) return nullptr;\r\n        return sortedListToBST(head, nullptr);\r\n    }\r\n    TreeNode* sortedListToBST(ListNode* head, ListNode* tail) {\r\n        if (head == tail) return nullptr;\r\n\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n\r\n        while (fast != tail && fast->next != tail) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n        }\r\n\r\n        TreeNode* root = new TreeNode(slow->val);\r\n        root->left = sortedListToBST(head, slow);\r\n        root->right = sortedListToBST(slow->next, tail);\r\n        return root;\r\n    }\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844054276","body":"有两种思路：\r\n（1）双指针\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n    \r\n    ListNode *head1 = headA;\r\n    ListNode *head2 = headB;\r\n    if(head1 == NULL||head2 == NULL){\r\n        return NULL;\r\n    }\r\n    while(head1 != head2){\r\n        if(head1){\r\n            head1 = head1->next;\r\n        }\r\n        else{\r\n            head1 = headB;\r\n        }\r\n        if(head2){\r\n            head2 = head2->next;\r\n        }\r\n        else{\r\n            head2 = headA;\r\n        }\r\n    }\r\n    return head1;\r\n\r\n        \r\n    }\r\n};\r\n时间复杂度 : O(m+n)。\r\n空间复杂度 : O(1)\r\n（2）哈希表\r\nclass Solution{\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB){\r\n        unordered_set<ListNode*> s1;\r\n        ListNode *pa=headA;\r\n        ListNode *pb=headB;\r\n        if(pa == NULL||pb == NULL){\r\n           return NULL;\r\n        }\r\n        while(pa){\r\n            s1.insert(pa);\r\n            pa = pa->next;\r\n        }\r\n        while(pb){\r\n            /*方法一：用find（）,但要注意，find找到是返回迭代器，没找到就返回这个容器的结束迭代器\r\n            if(s1.find(pb)!=std::end(s1)){\r\n                return pb;\r\n            }\r\n            */\r\n            //方法二：用count（）,在 C++ 中，如果你想知道某个关键字是否被映射过，你可以直接用 count( ) 方法。\r\n            //使用count，返回的是被查找元素的个数。如果有，返回1；否则，返回0。注意，map中不存在相同元素(Tom,Mary)，所以返回值只能是1或0。\r\n            if(s1.count(pb)){\r\n                return pb;\r\n            }\r\n            pb = pb->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n时间复杂度 : O(m+n)\r\n空间复杂度 : O(m)或O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844822835","body":"方法1：哈希\r\n代码：\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n    unordered_set<ListNode*> s1;\r\n    ListNode *p = head;\r\n    while(p){\r\n        if(s1.count(p)==1){\r\n            return p;\r\n        }\r\n        else{\r\n            s1.insert(p);\r\n            p=p->next;\r\n            }\r\n        }\r\n       \r\n    return NULL;\r\n    }\r\n};\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）\r\n\r\n方法二：快慢指针\r\n\r\n代码：\r\nclass Solution{\r\npublic:\r\n    ListNode *detectCycle(ListNode *head){\r\n    ListNode *fast = head;\r\n    ListNode *slow = head;\r\n\r\n    if(head == NULL||head->next == NULL||head->next->next == NULL){\r\n        return NULL;\r\n    }\r\n    else{\r\n        slow = head->next;\r\n        fast = head->next->next;\r\n        while(slow!=fast){\r\n            if(fast == NULL||fast->next == NULL){ //这里已经包含所以情况了，slow == null的情况可以不写\r\n                return NULL;\r\n            }\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n\r\n        }\r\n        ListNode *p = head;\r\n        while(p!=slow){\r\n            p = p->next;\r\n            slow = slow->next;\r\n        }\r\n        return p;\r\n\r\n    }\r\n    }\r\n\r\n};\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（1）"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846044521","body":"学习了官方题解思路\r\n\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        // 使用伪头部和伪尾部节点\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache[key] = node;\r\n            // 添加至双向链表的头部\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode* removed = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.erase(removed->key);\r\n                // 防止内存泄漏\r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846160522","body":"DFS:\r\n代码：\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(root == nullptr) return 0;\r\n        return max(maxDepth(root->left),maxDepth(root->right))+1;\r\n    \r\n    }\r\n};\r\n时间复杂度：0(n)\r\n空间复杂度：0(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaoyuhai":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838666444","body":"/**\r\n* 找出左右两边距离最近的，再取其中最小的\r\n*/ \r\npublic int[] shortestToChar(String s, char c) {\r\n        int[] result = new int[s.length()];\r\n        int pre = -2000;\r\n        for(int i =0; i < s.length(); i++){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = i - pre;\r\n        }\r\n        pre = 2000;\r\n        for(int i = s.length() -1 ; i >=0; i--){\r\n            if(s.charAt(i)==c){\r\n                pre = i;\r\n            }\r\n            result[i] = Math.min(result[i],pre-i);\r\n        }\r\n        return result;\r\n    }"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839772089","body":"数组模拟栈,top记录栈顶元素位置\r\n\r\n    class CustomStack {\r\n        int top;\r\n        int[] stack;\r\n        public CustomStack(int maxSize) {\r\n           //初始化数组\r\n           stack = new int[maxSize];\r\n           top = -1;     \r\n        }\r\n        \r\n        public void push(int x) {\r\n            //如果数组中还没满，将数组下边向后移动一位并赋值\r\n            if(top!= stack.length-1){\r\n                ++top;\r\n                stack[top] = x;\r\n            }\r\n         \r\n        }\r\n        \r\n        public int pop() {\r\n            //如果数组元素不为空，返回顶部元素，top向前移动一位\r\n            if(top==-1){\r\n                return -1;\r\n            }\r\n            top--;\r\n            return stack[top+1];\r\n        }\r\n        \r\n        public void increment(int k, int val) {\r\n            //需要加的下标 为 k 和 top+1 长度中短的那个\r\n            int index = Math.min(k,top+1);\r\n            for(int i=0; i < index; i++){\r\n                stack[i] += val;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648761","body":"算法流程：\r\n\r\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\r\n\r\n当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\r\n\r\n当 c 为字母时，在 res 尾部添加 c；\r\n\r\n当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 00：\r\n\r\n记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\r\n\r\n记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\r\n\r\n进入到新 [ 后，res 和 multi 重新记录。\r\n\r\n当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\r\n\r\nlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\r\n\r\ncur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\r\n\r\n返回字符串 res。\r\n\r\n复杂度分析：\r\n\r\n时间复杂度 O(N)O(N)，一次遍历 s；\r\n\r\n空间复杂度 O(N)O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]\r\n\r\n代码\r\n\r\n    public String decodeString(String s) {\r\n            StringBuilder res = new StringBuilder();\r\n            int multi = 0;\r\n            LinkedList<Integer> stack_multi = new LinkedList<>();\r\n            LinkedList<String> stack_res = new LinkedList<>();\r\n            for (Character c : s.toCharArray()) {\r\n                if (c == '[') {\r\n                    stack_multi.addLast(multi);\r\n                    stack_res.addLast(res.toString());\r\n                    multi = 0;\r\n                    res = new StringBuilder();\r\n                    continue;\r\n                }\r\n                if (c == ']') {\r\n                    StringBuilder tmp = new StringBuilder();\r\n                    int cur_multi = stack_multi.removeLast();\r\n                    for (int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                    res = new StringBuilder(stack_res.removeLast() + tmp);\r\n                    continue;\r\n                }\r\n                if (Character.isDigit(c)) {\r\n                    multi = multi * 10 + Integer.parseInt(c + \"\");\r\n                    continue;\r\n                }\r\n                res.append(c);\r\n            }\r\n            return res.toString();\r\n    \r\n        }\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841298669","body":"思路\r\n\r\n将一个栈当作输入栈，用于压入传入的数据；另一个栈当作输出栈；若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\r\n\r\n代码\r\n\r\n    class MyQueue {\r\n    \r\n        /** Initialize your data structure here. */\r\n        Deque<Integer> inStack;\r\n        Deque<Integer> outStack;\r\n        public MyQueue() {\r\n            inStack = new LinkedList<Integer>();\r\n            outStack = new LinkedList<Integer>();\r\n        }\r\n        \r\n        /** Push element x to the back of queue. */\r\n        public void push(int x) {\r\n           inStack.push(x);\r\n        }\r\n        \r\n        /** Removes the element from in front of queue and returns that element. */\r\n        public int pop() {\r\n            if(outStack.isEmpty()){\r\n                initOutStack();\r\n            }\r\n            return outStack.pop();\r\n        }\r\n        \r\n        /** Get the front element. */\r\n        public int peek() {\r\n            if(outStack.isEmpty()){\r\n                initOutStack();\r\n            }\r\n            return outStack.peek();\r\n        }\r\n        \r\n        /** Returns whether the queue is empty. */\r\n        public boolean empty() {\r\n            return inStack.isEmpty() && outStack.isEmpty();\r\n        }\r\n        public void initOutStack(){\r\n            while(!inStack.isEmpty()){\r\n                outStack.push(inStack.pop());\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841677381","body":"\r\n\r\n遍历数组 arrarr 中的每个数字 numnum ；\r\n\r\n当栈 stackstack 不为空且数字 num<num<栈顶值 时： （代表此 numnum 会改变前面排序块分布）\r\n\r\n栈顶 pop() 出栈，并保存栈顶值为 headhead 。 （此情况下，新排序块最大值还为 headhead ，因此先暂存）\r\n\r\n当 stackstack 不为空且数字 num<num<栈顶值 时，循环栈顶 pop() 出栈。 （判断加入 numnum 需要合并的所有排序块，每 pop() 一个 headhead 代表合并一个块）\r\n\r\n将保存的栈顶值 headhead 重新 push() 入栈。 （将 headhead 重新加入，作为新排序块的最大值）\r\n\r\n当栈 stackstack 为空或数字 num>=num>=栈顶值 时： （代表此 numnum 不影响前面排序块分布）\r\n\r\n将 numnum 数字 push() 入栈。 （加入单个元素的新排序块 [num]）\r\n\r\n遍历完成后，栈中保存 所有排序块的对应最大值 headhead ，因此返回栈 stackstack 长度即可获得排序块数量。\r\n\r\n复杂度分析：\r\n\r\n时间复杂度 O(N)O(N) ：遍历一遍 arrarr 为 O(N)O(N)，修正排序块最多遍历一遍 arrarr 为 O(N)O(N)；\r\n\r\n空间复杂度 O(N)O(N) ：极端情况下排序块数量等于数组长度，此时 stackstack 占用线性大小额外空间。\r\n\r\n    class Solution {\r\n       public int maxChunksToSorted(int[] arr) {\r\n            LinkedList<Integer> stack = new LinkedList<Integer>();\r\n            for(int num : arr) {\r\n                if(!stack.isEmpty() && num < stack.getLast()) {\r\n                    int head = stack.removeLast();\r\n                    while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                    stack.addLast(head);\r\n                }\r\n                else stack.addLast(num);\r\n            }\r\n            return stack.size();\r\n        }\r\n    \r\n    }\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841828935","body":"思路\r\n\r\n代码\r\n\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n            if(head==null || k == 0){\r\n                return head;\r\n            }\r\n            ListNode cursor = head;\r\n            ListNode tail = null;//尾指针\r\n            int len = 1;\r\n            while(cursor.next != null){\r\n                cursor = cursor.next;\r\n                len++;\r\n            }\r\n            int loop = len - (k%len);//循环次数\r\n            tail = cursor;//尾指针\r\n            cursor.next = head;//改成循环链表\r\n            cursor = head;\r\n            for(int i = 0; i < loop; i++){\r\n                cursor=cursor.next;\r\n                tail = tail.next;\r\n            }\r\n            tail.next = null;\r\n            return cursor;\r\n    \r\n        }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842397022","body":"    class Solution {\r\n    \r\n        public ListNode swapPairs(ListNode head) {\r\n    \r\n            if(head == null || head.next == null){\r\n    \r\n                return head;\r\n    \r\n            }\r\n    \r\n            ListNode res = head.next; //找到交换节点的下一个\r\n    \r\n             ListNode temp = swapPairs(head.next.next);  //需要移动头部\r\n    \r\n            res.next = head; //交换\r\n    \r\n            head.next = temp; //头部移动到下一组\r\n    \r\n            \r\n    \r\n            return res;\r\n    \r\n        }\r\n    \r\n    }\r\n    \r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843272296","body":"     public TreeNode sortedListToBST(ListNode head) {\r\n            if(head == null) return null;\r\n            else if(head.next == null) return new TreeNode(head.val);\r\n            ListNode pre = head;\r\n            ListNode p = pre.next;\r\n            ListNode q = p.next;\r\n            //找到链表的中点p\r\n            while(q!=null && q.next!=null){\r\n                pre = pre.next;\r\n                p = pre.next;\r\n                q = q.next.next;\r\n            }\r\n            //将中点左边的链表分开\r\n            pre.next = null;\r\n            TreeNode root = new TreeNode(p.val);\r\n            root.left = sortedListToBST(head);\r\n            root.right = sortedListToBST(p.next);\r\n            return root;\r\n        }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844232085","body":"    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n               ListNode A = headA, B = headB;\r\n            while (A != B) {\r\n                A = A != null ? A.next : headB;\r\n                B = B != null ? B.next : headA;\r\n            }\r\n            return A;\r\n    \r\n    \r\n        }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845211592","body":"    public ListNode detectCycle(ListNode head) {\r\n            ListNode ln = head;\r\n            Set<ListNode> nodes = new HashSet();\r\n            while(ln != null){\r\n                if(nodes.contains(ln)){\r\n                    return ln;\r\n                }else{\r\n                    nodes.add(ln);\r\n                }\r\n                ln = ln.next;\r\n            }\r\n            return null;\r\n        }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846015326","body":"    class LRUCache {\r\n     int capacity;\r\n        LinkedHashMap<Integer, Integer> cache;\r\n    \r\n        public LRUCache(int capacity) {\r\n            this.capacity = capacity;\r\n            cache = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {\r\n                @Override\r\n                protected boolean removeEldestEntry(Map.Entry eldest) {\r\n                    return cache.size() > capacity;\r\n                }\r\n            };\r\n        }\r\n    \r\n        public int get(int key) {\r\n            return cache.getOrDefault(key, -1);\r\n        }\r\n    \r\n        public void put(int key, int value) {\r\n            cache.put(key, value);\r\n        }\r\n    }class LRUCache {\r\n     int capacity;\r\n        LinkedHashMap<Integer, Integer> cache;\r\n    \r\n        public LRUCache(int capacity) {\r\n            this.capacity = capacity;\r\n            cache = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {\r\n                @Override\r\n                protected boolean removeEldestEntry(Map.Entry eldest) {\r\n                    return cache.size() > capacity;\r\n                }\r\n            };\r\n        }\r\n    \r\n        public int get(int key) {\r\n            return cache.getOrDefault(key, -1);\r\n        }\r\n    \r\n        public void put(int key, int value) {\r\n            cache.put(key, value);\r\n        }\r\n    }\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846425860","body":"    class Solution {\r\n        public int maxDepth(TreeNode root) {\r\n            if(root == null){\r\n                return 0;\r\n            }\r\n            int leftHeight=maxDepth(root.left);\r\n            int rightheight = maxDepth(root.right);\r\n            return Math.max(leftHeight,rightheight)+1;\r\n        }\r\n    }\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayu0007":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838671847","body":"### 思路\r\n\r\n参考了参考答案的动态规划。\r\n双次遍历数组 \r\n- dp数组状态量：与上一个c的距离\r\n\r\n  左遍历\r\n    - 状态转移方程：```dp[i] = dp[i-1] + 1 ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n  右遍历\r\n    - 状态转移方程：```dp[i] = min(dp[i+1] + 1, dp[i]) ```\r\n    - 边界条件：```if s[i] == c: dp[i] = 0 ```\r\n\r\n### caveat\r\n不要忘记check index的范围\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        # traverse 2 times \r\n        # left to right: each element store distance to the nearest C met before (on the LEFT).\r\n        # right to left: each element store the distance to the nearest C on the RIGHT. \r\n        # compare the value of both. \r\n        # initialize array with inf\r\n        \"\"\"\r\n        # 参考答案的prev initialization有点难理解\r\n        result = []\r\n        prev = -float('inf')\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                prev = i \r\n            result[i] = i - prev \r\n\r\n        prev = float('inf')\r\n        for i in range(len(s)-1,0,-1):\r\n            if s[i] == c:\r\n                prev = i \r\n            result[i] = min(prev-i, result[i])\r\n        return result\r\n        \"\"\"\r\n        dp = [float('inf')]*len(s) # float('inf') is a number bigger than all others \r\n        \"\"\"\r\n        num = float('inf')\r\n        print(num > 1000) #True\r\n        print(num + 1 == num) #True \r\n        print(num-1) #inf\r\n        \"\"\"\r\n        for i, elem in enumerate(s):\r\n            if elem == c:\r\n                dp[i] = 0 \r\n            elif i > 0: #index range checking\r\n                dp[i] = dp[i-1] + 1\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0 \r\n            elif i < len(s)-1: #index range checking\r\n                dp[i] = min(dp[i+1] + 1, dp[i])\r\n                \r\n        return dp\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N 为数组`s`的长度，两次遍历\r\n- 空间复杂度：O(N), N 为数组`s`的长度，也是返回值\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839563314","body":"## 解题思路1\r\n\r\n用python的list实现stack，注意push/increment 确认没有满栈\r\n\r\n### Code\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n        \r\n    def pop(self) -> int:\r\n        return self.stack.pop() if len(self.stack) else -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] += val \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: increment - `O(k)` \\\r\n**Space Complexity**: a dynamic array of size `O(maxSize)` \r\n\r\n## 解题思路2 \r\n\r\n优化increment的时间复杂度\r\ncreate auxiliary list to store increment val for bottom k elements at position closest to top. \r\n\r\n### Code \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1 #record index of top element\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top < len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        last_index_to_add = min(k-1, self.top)\r\n        if last_index_to_add >= 0:\r\n            self.add[last_index_to_add] += val\r\n        \r\n    def pop(self) -> int:\r\n        if self.top == -1: return -1\r\n        \r\n        result = self.add[self.top] + self.stack[self.top]\r\n        \r\n        if self.top > 0:\r\n            self.add[self.top-1] += self.add[self.top]\r\n        self.add[self.top] = 0 \r\n        self.top -= 1\r\n\r\n        return result \r\n```\r\n### Complexity\r\n**Time Complexity**: init/push/pop/increment - `O(1)` \\\r\n**Space Complexity**: 2 dynamic array of size `O(maxSize)` "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840607195","body":"## 解题思路1\r\n\r\nNested square brackets need to be processed inside out to generate substrings, which aligns with stack's FILO character\r\n\r\n### Code\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 1. stack: push all characters and pop when encounter \"]\" to compute the augmented substring, then push the concatenated substring back onto stack \r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                repeatStr = ''\r\n                repeatMul = ''\r\n                while stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr # Caveat: need to concatenate character in reverse order \r\n                # pop off \"[\" \r\n                stack.pop()\r\n\r\n                while stack and stack[-1].isdigit(): # Caveat: stack is popped every iteration, need to terminate loop when stack is empty to ensure indexing is valid \r\n                    repeatMul = stack.pop() + repeatMul # Caveat: need to concatenate character in reverse order \r\n                stack.append(int(repeatMul)*repeatStr) \r\n            else: \r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\n\r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` if keeps pushing all elements into stack before enclosing bracket \r\n\r\n## 解题思路2 \r\n\r\nrecursion. (to-do)\r\n\r\n### Code \r\n```python\r\n\r\n```\r\n### Complexity\r\n**Time Complexity**: `O(N)` to traverse the string `s` \\\r\n**Space Complexity**: `O(N)` for max recursion depth "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841267005","body":"## 解题思路\r\nsince queue is FIFO, in reversing order as stack (FILO), we can use an auxiliary stack to reverse the sequence of element. \r\n- push is `O(N)`:  the main stack keep elements in queue's manner: the pushed element at the bottom\r\n- pop: `O(1)`\r\n- peek: `O(1)`\r\n- is.empty(): same as checking if s1 is empty\r\n\r\n### push and pop O(1)的思路\r\nseparate enque and deque. \r\n- push is `O(1)`. Since order is reversed, \r\n- for pop/peak, data need to be moved to s2. s2 is the queue's order, pop/peek is `O(1)`. Migrating elements only when output stack s2 is empty. \r\n- isempty: elements can be in either input stack or output stack if previous batch all dequed. so need to check whether both stacks are empty\r\n\r\n\r\n### Code\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n# O(1) amortized cost\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.input_stk = [] \r\n        self.output_stk = []  \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.input_stk.append(x) \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.output_stk: \r\n            while self.input_stk: \r\n                self.output_stk.append(self.input_stk.pop()) \r\n        return(self.output_stk.pop())\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.output_stk: \r\n            while self.input_stk: \r\n                self.output_stk.append(self.input_stk.pop()) \r\n        return(self.output_stk[-1]) \r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.input_stk) == 0 and len(self.output_stk) == 0 \r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()              \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(1)` for push, isempty, amortised `O(1)` for peek/pop to account for 1 time element pop/push onto output stack \\\r\n**Space Complexity**: `O(N)` for additional output stack\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645157","body":"## 解题思路\r\n每个chunk的最大元素要小于后面任何元素。\r\n构造辅助stack，存储每个chunk的最大元素，遇到新元素比之前chunk的最大元素小，需要将新元素并入最后的chunk，之前所有chunk最大元素大于新元素也需要并入最末chunk\r\n\r\n\r\n### Code\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        # keep valid chunks on stack, each element record largest elem of chunk. \r\n        # if new elem a encountered smaller than top elem, merge the new elem to the last chunk, \r\n        # but all previous chunks whose largest elem smaller than a must also merge with the last chunk.  \r\n        chunks = []\r\n        for elem in arr:\r\n            if not chunks or chunks[-1] < elem: \r\n                chunks.append(elem)\r\n            else:\r\n                last = chunks[-1]\r\n                while chunks and chunks[-1] > elem:\r\n                    chunks.pop()\r\n                chunks.append(last)\r\n        \r\n        return len(chunks)         \r\n```\r\n\r\n### Complexity\r\n**Time Complexity**: `O(N)` loop through the arr once \\\r\n**Space Complexity**: `O(N)` for auxiliary stack to store the max elem of each chunk\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841795624","body":"### 思路\r\n旋转k次相当于把倒数第（k% len(SLL)) 这个元素作为新head\r\n用快慢指针 快指针先移动k步 （如果k超过sll的长度 则记录sll的长度并reset k）\r\n接着同时移动块慢指针 当快指针到倒数第一个元素时 慢指针到倒数第1+k个元素\r\n\r\n慢指针的next即新head 快指针的next要连上当前head\r\n慢指针的next指向null\r\n \r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        # rotate k times = assign the k%len(SLL)-th last elem in SLL as the head. \r\n        if not head:    return head \r\n         \r\n        fast = slow = head \r\n        count = 1\r\n        i = 0\r\n        # advance fast pointer by k position, if k > len(SLL), reset k and loop over again \r\n        while i < k:\r\n            if fast.next:\r\n                i += 1 \r\n                fast = fast.next \r\n                count += 1 \r\n            else:\r\n                k %= count \r\n                i = 0 \r\n                fast = head \r\n\r\n        # if k == 0 then just return the head \r\n        if k == 0:\r\n            return head \r\n        else:\r\n            while fast.next:   \r\n                fast = fast.next  # tail\r\n                slow = slow.next # k+1 - th from right\r\n            \r\n            new_head = slow.next \r\n            slow.next = None \r\n            fast.next = head\r\n            return new_head \r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N为链表长度。如果k>len(SLL)则需要遍历链表两遍\r\n- 空间复杂度：O(1)，仅变量空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841846335","body":"### 思路\r\n**iterative approach** \\\r\n每两个nodes为一组 记录之前一个node prev，当前组的node进行link交换连接\r\n注意head变动 \r\n \r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head: return head \r\n        if not head.next: return head \r\n\r\n        first = head\r\n        prev = None\r\n        while first and first.next:\r\n            second = first.next \r\n            temp = second.next\r\n            second.next = first\r\n            first.next = temp \r\n                \r\n            if first == head: \r\n                new_head = second \r\n            if prev: \r\n                prev.next = second \r\n\r\n            prev = first\r\n            first = first.next \r\n        \r\n        return new_head \r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，N为链表长度。\r\n- 空间复杂度：O(1)，仅几个指针"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842890650","body":"### 思路\r\n1. Find middle elem of the linked list, assign to BST root node.\r\n2. construct left subtree with the first half of linked list and right subtree with the second half of linked list. (Recursion) \r\n \r\n \r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return head \r\n        if not head.next: return TreeNode(head.val)\r\n        # record the node before middle to break list into half\r\n        prev, slow, fast = None, head, head \r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next \r\n            prev = slow \r\n            slow = slow.next \r\n        \r\n        prev.next = None\r\n        bst = TreeNode(slow.val)\r\n        bst.left = self.sortedListToBST(head)\r\n        bst.right = self.sortedListToBST(slow.next)\r\n        return bst\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN)，each level of nodes is determined by loop over linked list once. logN levels. \r\n- 空间复杂度：O(logN)，the depth of recursive tree is logN. "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844007297","body":"### 思路\r\nTraverse both A and B from 2 heads until both reach the null pointer or join at a common node. \r\n \r\n \r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pt_a  = headA\r\n        pt_b  = headB\r\n\r\n        if pt_a is None or pt_b is None: return None \r\n\r\n        while pt_a != pt_b:  # if no intersection, both pointers will reach the end of a linked list and point to null \r\n            pt_a = pt_a.next if pt_a else headB\r\n            pt_b = pt_b.next if pt_b else headA\r\n        return pt_a \r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(m+n), traverse both linked list.  \r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844748625","body":"### 思路\r\n\r\n**Fast/slow pointer**: \\\r\nfast pointer moves 2 steps in each operation. \r\nslow pointer moves 1 step in each operation. \r\nif there is a loop in linked list, 2 pointers will meet within the loop. \r\n\r\nNow assume the pointer is x nodes from the beginning of cycle, \\\r\nthe distance between the head node and the start node of cycle is s. \\\r\nthe perimeter of loop is P nodes \\\r\n2(s + x) = s + n*P + x -> s = (n-1)P + (P - x) \r\n\r\nMove the fast pointer to head node and move both pointers 1 step a time, when fast pointer reach the beginning of loop, the slow pointer moves n-1 loops in the cycle and P - x steps and also reach the start node of cycle. \r\n\r\n\r\n### 代码\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n\r\n        slow = fast = head \r\n        while fast and fast.next: \r\n            slow = slow.next \r\n            fast = fast.next.next\r\n\r\n            if fast == slow:\r\n                break \r\n        \r\n        if fast is None or fast.next is None: return None \r\n        \r\n        fast = head \r\n        while fast != slow:\r\n            fast = fast.next \r\n            slow = slow.next \r\n        return fast \r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N): slow pointer traverse through the linked list 1 time\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845938626","body":"### 思路\r\n- put (key, value) in O(1) -> hashmap \r\n- maintain LRU sequence whenever put/get operation in O(1): Doubly Linked List \r\n\r\nget/put operation involves moving the operated node to the tail\r\n \r\n### 代码\r\n```python\r\nclass DDLNode:\r\n    def __init__(self, key=None, value=None):\r\n        self.key = key\r\n        self.value = value \r\n        self.prev = None \r\n        self.next = None \r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.map = dict()\r\n        self.head = DDLNode()\r\n        self.tail = DDLNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n\r\n    def appendTail(self, node):\r\n        node.prev = self.tail.prev\r\n        node.next = self.tail\r\n        self.tail.prev.next = node\r\n        self.tail.prev = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n        node.next = None \r\n        node.prev = None\r\n\r\n    def removeHead(self):\r\n        to_remove = self.head.next\r\n        self.removeNode(to_remove)\r\n        return to_remove\r\n\r\n    def get(self, key: int) -> int:\r\n    # lookup key from map, if not present return -1 \r\n    # else, move value to the tail of DLL and return value \r\n        if key in self.map:\r\n            node = self.map[key]\r\n            self.removeNode(node)\r\n            self.appendTail(node)\r\n\r\n            return node.value  \r\n        else: \r\n            return -1 \r\n        \r\n    def put(self, key: int, value: int) -> None:\r\n        # 1. if key in map, update and move node to the tail of DLL \r\n        if key in self.map:\r\n            node = self.map[key]\r\n            node.value = value\r\n            self.removeNode(node)\r\n            self.appendTail(node)\r\n\r\n        # 2. if key not in map, insert key to map and append val to tail        \r\n        # if capacity is full, pop the least recently used node from DLL and map\r\n        else: \r\n            # insert (key, value) to map  \r\n            self.map[key] = DDLNode(key, value)\r\n            node = self.map[key]\r\n            # insert node to the tail of DLL\r\n            self.appendTail(node)\r\n\r\n            if len(self.map) > self.capacity:\r\n                # remove the node after head \r\n                removed = self.removeHead()\r\n                self.map.pop(removed.key)\r\n\r\n\r\n\r\n# Your LRUCache object will be instantiated and called as such:\r\n# obj = LRUCache(capacity)\r\n# param_1 = obj.get(key)\r\n# obj.put(key,value)\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(1): on average if no hash collision\r\n- 空间复杂度：O(N): for both hashmap and doubly linked list. "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846358554","body":"### 思路1\r\nDFS using recursion \r\n\r\n### 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        left_depth = self.maxDepth(root.left)\r\n        right_depth = self.maxDepth(root.right)\r\n        return max(left_depth, right_depth) + 1\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N): N is the number of nodes in tree\r\n- 空间复杂度：O(height): recursive function use stack, stack space = recursive depth = height of tree.\r\n\r\n\r\n### 思路2\r\nLevel Traversal Tree. use a stack to maintain the current level of nodes.  \r\n\r\n### 代码\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        \r\n        queue = deque()\r\n        queue.appendleft(root)\r\n        depth = 0 \r\n\r\n        while queue:\r\n            no_nodes_level = len(queue)\r\n            for i in range(no_nodes_level):\r\n                node = queue.pop()\r\n                if node.left: \r\n                    queue.appendleft(node.left)\r\n                if node.right:\r\n                    queue.appendleft(node.right)\r\n            depth += 1 \r\n        return depth\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N): N is the number of nodes in tree\r\n- 空间复杂度：O(N): max no. of nodes on a level, upper bound by N.\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846524569","body":"### 思路1DFS\r\nRecursion: compare root, if same, compare left tree and right tree\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        # both empty\r\n        if not p and not q: return True\r\n        # only 1 empty\r\n        if not p or not q: return False \r\n        if p.val != q.val: return False \r\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N): compare all nodes\r\n- 空间复杂度：O(N): 空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数\r\n\r\n### 思路2BFS\r\n\r\n### 代码\r\n```python\r\nfrom collections import deque\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q: return True\r\n        if not p or not q: return False \r\n\r\n        queue1 = deque([p])\r\n        queue2 = deque([q])\r\n\r\n        while queue1 and queue2:\r\n            node1 = queue1.popleft()\r\n            node2 = queue2.popleft()\r\n            if node1.val != node2.val: return False \r\n\r\n            left1, right1 = node1.left, node1.right\r\n            left2, right2 = node2.left, node2.right\r\n\r\n            if ((not left1) ^ (not left2)) or ((not right1) ^ (not right2)): return False\r\n\r\n            if left1 and left2: \r\n                queue1.append(left1)\r\n                queue2.append(left2)                \r\n            if right1 and right2:\r\n                queue1.append(right1)\r\n                queue2.append(right2)\r\n                \r\n        return not queue1 and not queue2\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N): search through all nodes\r\n- 空间复杂度：O(N): the size of queue is the sum of nodes on a level, bound by N"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838700474","body":"### 思路分析\r\n1. 遍历两次字符串， 一次从左到右遍历，一次从右到左遍历\r\n2. 两次遍历分别记录s[i]对 c 的距离\r\n3. 两者比较, 保留较小值\r\n\r\n\r\n### 代码实现 JavaScript\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  const res = new Array(s.length).fill(Infinity)\r\n\r\n  for(let i = 0; i < s.length; i++){\r\n    if(s[i] === c) res[i] = 0;\r\n    else res[i] = i == 0 ? Infinity : res[i - 1] + 1\r\n  }\r\n\r\n  for(let i = s.length - 1; i >= 0; i--){\r\n    if(res[i] == Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1\r\n  }\r\n\r\n  return res;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$, N为字符串长度\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839846755","body":"### 思路\r\n  用数组模拟栈，用数组原生方法pop、push方法实现\r\n  \r\n### 代码\r\n\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length >= this.maxSize) {\r\n    return;\r\n  }\r\n  this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  return this.stack.length ? this.stack.pop() : -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const length = Math.min(k, this.stack.length);\r\n  for (let i = 0; i < length; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```\r\n### 复杂度\r\n- 时间复杂度 \r\n\r\n  push: O(1)\r\n\r\n  pop：O(1)\r\n  \r\n  increment：O(K) \r\n \r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840630345","body":"### 思路\r\n1. 将字符串从末尾开始遍历\r\n2. 遇到“]”入栈\r\n3. 拼接要出栈的字符串，遇到\"[\"出栈\r\n4. \"[\"后紧跟数据，累计最终的数字\r\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\r\n\r\n### 代码\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function(s) {\r\n    let stack = []; // 定义存储字符串的栈\r\n    let str = \"\"; // 定义最终返回的字符串\r\n    let num = \"\"; // 定义字符串重复的次数\r\n    const length = s.length;\r\n    for (let i = length - 1; i >= 0; i--) {\r\n      console.log(\"s[i]\", stack, i);\r\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\r\n        // 解析出连续的数字\r\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\r\n          num += s[i];\r\n          i--;\r\n          console.log(\"num\", num);\r\n        }\r\n        stack.push(\r\n          str.repeat(\r\n            Number(\r\n              num\r\n                .split(\"\")\r\n                .reverse()\r\n                .join(\"\")\r\n            )\r\n          )\r\n        ); // 拼接字符\r\n        str = \"\";\r\n        num = \"\"; //清空计数\r\n        i++;\r\n      } else if (s[i] === \"[\") {\r\n        // 遇到\"[\"时，将后续字符出栈\r\n        let curStr = stack.pop();\r\n        while (curStr !== \"]\") {\r\n          str += curStr;\r\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\r\n        }\r\n      } else {\r\n        // 将字符 或 \"]\"入栈\r\n        stack.push(s[i]);\r\n      }\r\n    }\r\n    return stack.reverse().join(\"\");\r\n  };\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：$O(N)$\r\n- 空间复杂度：$O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841296958","body":"\r\n### 思路\r\n    定义两个栈，\r\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\r\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\r\n\r\n\r\n### 代码实现\r\njavaScript\r\n```\r\nvar MyQueue = function() {\r\n    this.pushStack = [];\r\n    this.popStack = [];\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.pushStack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if(this.popStack.length === 0) {\r\n        while(this.pushStack.length > 0) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n    return this.popStack.pop();\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if(this.popStack.length === 0) {\r\n        while(this.pushStack.length > 0) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n    return this.popStack[this.popStack.length - 1];\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.popStack.length === 0 && this.pushStack.length === 0;\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(1)$\r\n- 空间复杂度 $O(N)$, N为队列元素个数\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841681803","body":"### 单调栈\r\n\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    let queue = [];\r\n    for (let i = 0; i < arr.length; i++){\r\n        if (queue.length === 0 || (queue[queue.length - 1] <= arr[i])){\r\n            queue.push(arr[i])\r\n        } else {\r\n            const value = queue.pop()\r\n            while (queue[queue.length - 1] > arr[i]){\r\n                queue.pop()\r\n            }\r\n            queue.push(value)\r\n        }\r\n    }\r\n    return queue.length\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(N)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841833770","body":"### 解题思路 \r\n快慢指针\r\n\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n  let length = 1, cur = head;\r\n \r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n \r\n  k = k % length;\r\n \r\n  if(k === 0) return head;\r\n \r\n  let fast = head, slow = head, count = k - 1;\r\n \r\n  while(count > 0){\r\n    fast = fast.next\r\n    count--\r\n  }\r\n\r\n  let pre = null;\r\n\r\n  while(fast.next){\r\n    pre = slow\r\n    fast = fast.next\r\n    slow = slow.next\r\n  }\r\n\r\n  pre.next = null;\r\n  fast.next = head;\r\n  return slow\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842162970","body":"[ 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n### 解题思路\r\n1. 设置虚拟节点，定义pre指针，指向当前虚拟节点\r\n2. 当pre.next以及pre.next.next指针均不为空时，开始交换\r\n3. 令cur指针指向pre.next；next指针指向pre.next.next\r\n4. 交换过程如下：\r\n- pre.next = next\r\n- cur.next = next.next\r\n- next.next = cur\r\n- pre = cur\r\n\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar swapPairs = function(head) {\r\n    let dummyNode = new ListNode(0);\r\n    dummyNode.next = head;\r\n    let pre = dummyNode;\r\n    while(pre.next && pre.next.next) {\r\n        const cur = pre.next;\r\n        const next = pre.next.next;\r\n        pre.next = next;\r\n        cur.next = next.next;\r\n        next.next = cur;\r\n        pre = cur;\r\n    }\r\n    return dummyNode.next;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$, N为链表中节点数目\r\n- 空间复杂度 $O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843275193","body":"### 解题思路\r\n    分治 \r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar sortedListToBST = function(head) {\r\n  if(!head) return null;\r\n  let length = 0;\r\n  let current = head;\r\n  while(current){\r\n    current = current.next\r\n    length++\r\n  }\r\n\r\n  var buildBST = function(start, end){\r\n    if(start > end) return null;\r\n\r\n    const mid = start + ((end - start)>> 1)\r\n    const leftSide = buildBST(start, mid - 1);\r\n\r\n    const root = new TreeNode(head.val)\r\n    head = head.next;\r\n    root.left = leftSide\r\n\r\n    root.right = buildBST(mid+1, end)\r\n    return root;\r\n  }\r\n\r\n  return buildBST(0, length - 1)\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(logN)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844202053","body":"### 解题思路\r\n    哈希法\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar getIntersectionNode = function(headA, headB) {\r\n   let hashMap = new Set();\r\n   while(headA) {\r\n       hashMap.add(headA);\r\n       headA = headA.next;\r\n   }\r\n   while(headB) {\r\n       if (hashMap.has(headB)) {\r\n           return headB;\r\n       }\r\n       headB = headB.next;\r\n   }\r\n   return null;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(N)$\r\n\r\n### 解题思路\r\n    双指针\r\n### 代码实现\r\njavaScript\r\n\r\n```\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let pointA = headA;\r\n    let pointB = headB;\r\n    while (pointA != pointB) {\r\n        pointA = pointA === null ? headB : pointA.next;\r\n        pointB = pointB === null ? headA : pointB.next;\r\n    }\r\n    return pointA;\r\n};\r\n\r\n```\r\n- 时间复杂度 $O(N)$\r\n- 空间复杂度 $O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844849886","body":"### 解题思路1\r\n> 哈希法\r\n\r\n### 代码实现\r\n> javaScript\r\n\r\n```\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let hashMap = new Set();\r\n    while(head) {\r\n       if(hashMap.has(head)) {\r\n           return head;\r\n       } else {\r\n           hashMap.add(head);\r\n       }\r\n       head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$ N为链表节点个数\r\n- 空间复杂度 $O(N)$ N为链表节点个数\r\n\r\n### 解题思路2\r\n> 快慢指针法\r\n\r\n### 代码实现\r\n> javaScript\r\n\r\n\r\n```\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    if(head === null || head.next === null) {\r\n        return null;\r\n    }\r\n    let fast = head;\r\n    let slow = head;\r\n    // 快慢指针未相遇时，快指针每次走两步，满指针每次走一步\r\n    do {\r\n        if(fast !== null && fast.next !== null) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            fast = null;\r\n        }\r\n        slow = slow.next;\r\n    } while(fast !== slow)\r\n    if (fast == null) return null;\r\n    // 首次相遇后，快指针指向头部，此后快指针每次走一步，慢指针每次走一步\r\n    fast = head;\r\n    while(fast !== slow) {\r\n        fast = fast.next;\r\n        slow = slow.next\r\n    }\r\n    return fast;\r\n};\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$ N为链表节点个数\r\n- 空间复杂度 $O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845739522","body":"### 解题思路\r\n    采用哈希表,保证get操作在O(1)时间复杂度内完成，\r\n    构建双向链表，保证put操作在O(1)时间复杂度内完成\r\n### 代码实现\r\n> javaScript\r\n\r\n```\r\nvar LinkedList = function(key, val) {\r\n    this.key = key;\r\n    this.val = val;\r\n    this.prev = null;\r\n    this.next = null;\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.size = 0;\r\n    this.cache = new Map();\r\n    // 构建虚拟节点\r\n    this.dummyHead = new LinkedList();\r\n    this.dummyTail = new LinkedList();\r\n    this.dummyHead.next = this.dummyTail;\r\n    this.dummyTail.prev = this.dummyHead;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    if (!this.cache.has(key)) {\r\n        return -1;\r\n    }\r\n    const node = this.cache.get(key);\r\n    // 将节点移动至链表头部\r\n    this.removeNode(node);\r\n    this.appendToHead(node);\r\n    return node.val;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    // 判断关键字key是否存在于缓存中\r\n    const node = this.cache.get(key);\r\n    if (node) {\r\n        // 更新关键字的值\r\n        node.val = value;\r\n        this.cache.set(key, node);\r\n        // 将关键字移动至链表头部\r\n        this.removeNode(node);\r\n        this.appendToHead(node);\r\n    } else {\r\n        // 当缓存容量达到上限时\r\n        if (this.size === this.capacity) {\r\n            // 删除最久未使用的\r\n            this.removeTailNode();\r\n        }\r\n        // 创建新节点\r\n        const newNode = new LinkedList(key, value);\r\n        this.cache.set(key, newNode)\r\n        this.appendToHead(newNode);\r\n        this.size ++;\r\n    }\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node) {\r\n    let preNode = node.prev;\r\n    let nextNode = node.next;\r\n    preNode.next = nextNode;\r\n    nextNode.prev = preNode;\r\n}\r\n\r\nLRUCache.prototype.appendToHead = function(node) {\r\n    let head = this.dummyHead.next;\r\n    this.dummyHead.next = node;\r\n    node.prev = this.dummyHead;\r\n    node.next = head;\r\n    head.prev = node;\r\n}\r\n\r\nLRUCache.prototype.removeTailNode = function() {\r\n    this.size --;\r\n    let tailNode = this.dummyTail.prev;\r\n    this.cache.delete(tailNode.key);\r\n    this.removeNode(tailNode);\r\n}\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：$O(1)$ \r\n- 空间复杂度：$O(capacity)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846418850","body":"### 解题思路\r\n> DFS\r\n\r\n### 代码实现\r\n> javaScript\r\n\r\n```\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root, depth = 0) {\r\n  if(!root) return depth;\r\n  return Math.max(maxDepth(root.left, depth + 1),maxDepth(root.right, depth + 1))\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n- 时间复杂度 $O(N)$ N为二叉树中节点的个数\r\n- 空间复杂度 $(K)$, k为二叉树的深度\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AutumnDeSea":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838712904","body":"\r\n## 题目地址(821. 字符的最短距离)\r\n\r\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\r\n\r\n## 题目描述\r\n\r\n```\r\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\r\n\r\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\r\n\r\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"loveleetcode\", c = \"e\"\r\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\r\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\r\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 3 。\r\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\r\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"aaab\", c = \"b\"\r\n输出：[3,2,1,0]\r\n\r\n\r\n \r\n\r\n提示：\r\n1 <= s.length <= 104\r\ns[i] 和 c 均为小写英文字母\r\n题目数据保证 c 在 s 中至少出现一次\r\n```\r\n\r\n## 前置知识\r\n\r\n- 数组和字符串的内存管理\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 数组的正向、反向遍历，是一道简单的左右指针的题目\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    // 字符串转数组的逻辑\r\n    // 数组的正向、反向遍历\r\n    sArr = s.split('')\r\n    const sLen = sArr.length\r\n    let arr = []\r\n    \r\n    for(var i = 0; i< sArr.length ; i++) {\r\n        var s = sArr[i]\r\n        var l = r = i\r\n          // 向左遍历\r\n        while(l > -1) {\r\n            if(sArr[l] == c) {\r\n                break\r\n            }\r\n            l--\r\n        }\r\n        // 像右遍历\r\n        while(r <  sLen) {\r\n            if(sArr[r] == c) {\r\n                break\r\n            }\r\n            r++\r\n        }\r\n        if(l === -1) {\r\n            l = -10000\r\n        }\r\n        if(r === sLen) {\r\n            r = 20000\r\n        }\r\n        var result = Math.min(r-i, i-l)\r\n        arr.push(result)\r\n    }\r\n    return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841327427","body":"\r\n## 题目地址(232. 用栈实现队列)\r\n\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n\r\n实现 MyQueue 类：\r\n\r\nvoid push(int x) 将元素 x 推到队列的末尾\r\nint pop() 从队列的开头移除并返回元素\r\nint peek() 返回队列开头的元素\r\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n\r\n \r\n\r\n说明：\r\n\r\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\r\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n进阶：\r\n\r\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\r\n[[], [1], [2], [], [], []]\r\n输出：\r\n[null, null, null, 1, 1, false]\r\n\r\n解释：\r\nMyQueue myQueue = new MyQueue();\r\nmyQueue.push(1); // queue is: [1]\r\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\r\nmyQueue.peek(); // return 1\r\nmyQueue.pop(); // return 1, queue is [2]\r\nmyQueue.empty(); // return false\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= x <= 9\r\n最多调用 100 次 push、pop、peek 和 empty\r\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  栈的结构是先进后出，和数组的push pop相似\r\n-  用栈模拟队列，就要实现先进先出，此时需要一个辅助的栈，每次push的时候进行数据移位\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\n// \r\nvar MyQueue = function() {\r\n    this.stack = []\r\n    this.helpstack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null\r\n    while(cur = this.stack.pop()) {\r\n        this.helpstack.push(cur)\r\n    }\r\n    this.stack.push(x)\r\n    while(cur = this.helpstack.pop()) {\r\n        this.stack.push(cur)\r\n    }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$，其中的n为栈中的元素，每次都需要循环一次\r\n- 空间复杂度：$O(n)$  使用了辅助栈，和原栈大小一致，所以为n\r\n\r\n\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842391376","body":"\r\n## 题目地址(24. 两两交换链表中的节点)\r\n\r\nhttps://leetcode-cn.com/problems/swap-nodes-in-pairs/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n\r\n\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 100] 内\r\n0 <= Node.val <= 100\r\n\r\n \r\n\r\n进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-   节点的两两交换\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    // 特殊情况，判断节点为空或者只有一个节点，返回相应节点\r\n    if(!head || !head.next) {\r\n        return head\r\n    }\r\n    let res = head.next\r\n    let now = head\r\n    // 创建一个新的链表\r\n    let preNode = new ListNode()\r\n    // preNode的下一个节点为头节点，第一个交换\r\n    preNode.next = head\r\n    // 遍历，直到null\r\n    while(now && now.next) {\r\n        // 记录下一个节点\r\n        let nextNode = now.next;\r\n        // 记录下下个节点\r\n        let nnNode = nextNode.next;\r\n        // 进行原链表的位置调换\r\n        now.next = nnNode;\r\n        nextNode.next = now;\r\n        // 新链表的节点拼接\r\n        preNode.next = nextNode;\r\n        preNode = now;\r\n        now = nnNode;\r\n    }\r\n    return res\r\n};\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843269576","body":"\r\n## 题目地址(109. 有序链表转换二叉搜索树)\r\n\r\nhttps://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n示例:\r\n\r\n给定的有序链表： [-10, -3, 0, 5, 9],\r\n\r\n一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：\r\n\r\n      0\r\n     / \\\r\n   -3   9\r\n   /   /\r\n -10  5\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n\r\n## 关键点\r\n\r\n-  平衡二叉树，就是要寻找链表的中点，通过快慢指针\r\n- 递归寻找重点和构建二叉树\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if(!head) {\r\n        return null\r\n    }\r\n    return dfs(head, null)\r\n};\r\nfunction dfs(head, tail) {\r\n    if(head === tail) {\r\n        return null\r\n    }\r\n    let fast = head\r\n    let slow = head\r\n    // 取到链表的的中间值\r\n    while((fast !=tail && fast.next != tail)) {\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n    let root = new TreeNode(slow.val)\r\n    root.left = dfs(head, slow)\r\n    root.right = dfs(slow.next, tail)\r\n    return root\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyaoyao":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838716666","body":"### 思路分析\r\n中心扩展，每遍历一个元素时候，便向两边扩展，取最小值即可\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n);\r\n        \r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                continue;\r\n            int l = i;\r\n            int r = i;\r\n            int len = 0;\r\n            \r\n            while (l >= 0 || r < n) {\r\n                if (s[l] == c) {\r\n                    len = i - l;\r\n                    break;\r\n                }\r\n                if (s[r] == c) {\r\n                    len = r - i;\r\n                    break;\r\n                }\r\n\r\n                if (l > 0) l--;\r\n                if (r < n) r++;\r\n            }\r\n            res[i] = len;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n## 复杂度\r\n+ 时间复杂度$O(N^2)$\r\n+ 空间复杂度$O(1)\r\n"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842220409","body":"## 思路\r\n根据题意可知，不停的交换相邻节点值，可以尝试递归解决该问题，\r\n**思考：交换什么时候结束？**  \r\n1. 头节点为空\r\n2. 头节点的下一个节点为空 \r\n## 关键点\r\n+ 要有一个新的链表头节点\r\n+ 要有一个过渡的节点，不断往后移\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        ListNode* new_head = head->next;\r\n        head->next = swapPairs(new_head->next);\r\n        new_head->next = head;\r\n        return new_head;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[null,{"title":"821. 字符的最短距离","url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-838739105","body":"### 思路\r\n\r\n1. 第一遍正序遍历，遇非e保留序号，遇e存储索引进pre变量，再遇e则更新其索引。返回当前非e数到左边e的距离\r\n2. 第二遍倒序遍历，同上，返回当前非e数到右边e的距离\r\n3. 两者比大小，返回最小值\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        pre = -10000\r\n        ans = []\r\n\r\n        for i in range(len(S)):\r\n            if S[i] == C: pre = i\r\n            ans.append(i - pre)\r\n        pre = 20000\r\n        for i in range(len(S) - 1, -1, -1):\r\n            if S[i] == C: pre = i\r\n            ans[i] = min(ans[i], pre - i)\r\n        return ans\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839716817","body":"### 思路\r\n\r\n给定一个变量来记录栈顶的位置，更新数据来模拟栈的操作，但因为实质是函数内的数组，所以可以实现对除了栈顶元素外的改动。（后续再优化）\r\n\r\n### 代码\r\n\r\n\r\n```py3\r\nclass CustomStack:\r\n# use array in function makes the each elenments in stack \"visable\"\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        # if stack size is smaller than maxSize, push in\r\n        # maxSize is not defined in this function, so use len of stack instead\r\n        if self.top < len(self.stk)-1:\r\n            self.stk[self.top+1] = x\r\n            self.top += 1\r\n\r\n    def pop(self) -> int:\r\n        # if stack is empty, return -1\r\n        # if stack is not empty, return the top value and delete it in the stack (no need)\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        # use the minimum value between k and self.stk length, then traverse\r\n        if k>-1:\r\n            for i in range(min(self.top+1,k)):\r\n                self.stk[i]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(min(k, maxSize)),\r\n- 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840631703","body":"### 思路\r\n\r\n1. 本题每层只包含三个信息：左括号前的字符串，左括号前的数字，左括号后的字符串\r\n2. 如果出现嵌套，则暂时存储前两个信息，以同样的方式对左括号后的内容嵌套进行分析\r\n3. 以右括号为标志进行嵌套层信息的弹出分解\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = [] # 暂存嵌套层外的前置信息\r\n        res = \"\" # 当前层的字符串\r\n        num = 0  \r\n        if len(s)>0:\r\n            for c in s:\r\n                if c.isdigit():\r\n                    num = 10*num + int(c)\r\n                elif c.isalpha():\r\n                    res += c\r\n                elif c == \"[\": # 遇到左括号就往栈里存入包含两个信息的元组（[前的字符串，[前的数字）\r\n                    stack.append((res,num))\r\n                    res, num = \"\", 0\r\n                else:\r\n                    # if c == \"]\"， 遇到右括号就开始弹出栈顶元组信息，组成当前层解码后的字符串\r\n                    top = stack.pop()\r\n                    res = top[0] + top[1]*res\r\n        return res\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(S)\r\n- 空间复杂度：O(S)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683734","body":"### 思路\r\n利用计数排序前后不变原理\r\n\r\n### 代码\r\n\r\n``` py3\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度\r\n时间复杂度： O(N^2)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841766639","body":"### 思路\r\n\r\n参照力扣官方题解，把原链表连接成一个环形链表，在n-1-(k mod n)处断开该链表即可。\r\n\r\n### 代码\r\n``` py3\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        \r\n        if k==0 or not head  or not head.next: return head\r\n\r\n        cur = head\r\n        n = 1\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n\r\n        # rotate k means cut down at the Kth position from the last\r\n        while (count := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while count:\r\n            cur = cur.next\r\n            count -= 1\r\n        \r\n        res = cur.next\r\n        cur.next = None\r\n\r\n        return res\r\n```\r\n\r\n### 复杂度\r\n时间复杂度： 首先遍历了链表一次，组成环形链表，然后根据K rotate，最多会rotate N-1次，因此为2N-1，复杂度为O(N)\r\n空间复杂度： 变量cur只需要存储链表当前节点和下一个节点的常数值，因此复杂度为O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842442379","body":"``` py3\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        n=0\r\n        pre = ListNode(0,None)\r\n        if not head or head.next == None: return head\r\n        second = head.next\r\n        while head.next:\r\n            n += 1 \r\n            if n%2:\r\n                pre = head\r\n                pre.next = head.next\r\n                head = head.next\r\n            else: # n is even\r\n                tmp = head.next\r\n                head.next = pre\r\n                pre.next = tmp\r\n                head = pre.next\r\n            \r\n        return second\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843176081","body":"### 思路\r\n快慢指针 + 递归\r\n\r\n###  代码\r\n```py3\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head: return head\r\n        pre, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            pre = slow\r\n            slow = slow.next\r\n     \r\n        if pre:\r\n            pre.next = None\r\n\r\n        Node = TreeNode(slow.val, None, None)\r\n\r\n        if slow == fast:\r\n            return Node\r\n\r\n        Node.left = self.sortedListToBST(head)\r\n        Node.right = self.sortedListToBST(slow.next)\r\n\r\n        return Node\r\n```\r\n\r\n### 复杂度\r\n时间：O(nlogn)\r\n空间：O(logn)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844194022","body":"### 思路\r\n普通方法是存储整个A链表，然后遍历另一个进行查询（哈希表）（注：是链表不是value）；\r\n但是这个空间复杂度是O(A)，要想在O(1)空间，要使用双指针。\r\n因为skipA + tail + skipB 总是等于skipB + tail + skipA\r\n其中，skipA+tail=A，skipB+tail=B，skipB<=B，因此skipA + tail + skipB<=A+B。最坏情况tail=0，A+B总是等于B+A）\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        \r\n        a = headA\r\n        b = headB\r\n\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n### 复杂度\r\n时间：最坏的情况下两者没有交点，O(A+B)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845240224","body":"### 思路\r\n还是快慢双指针，画图，搞清楚第一次相遇的数理逻辑，然后利用解题。\r\n本来觉得都相通了肯定不会错，结果第一个while条件写了while a!=b，十分注意！！！他们第一个值就是相等的T~T\r\n注意边界条件，题目第一句话就说了，一开始就应该写！\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        a = b = head\r\n\r\n        while True:\r\n            if not (a and a.next): return None\r\n            a = a.next.next\r\n            b = b.next\r\n            if a == b: break\r\n        \r\n        a = head\r\n\r\n        while a != b:\r\n            a = a.next\r\n            b = b.next\r\n\r\n        return a\r\n```\r\n\r\n### 复杂度：\r\n时间：O(N+pos)\r\n空间：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846032459","body":"### 思路\r\n完全不会，得多做几遍。。。。\r\n复杂应用要将其拆成几个小函数去实现。\r\n由双向链表结点组成的字典（即哈希表），为什么哈希表有的时候是字典有的时候是set？set只能存储值？本质差别是什么？\r\n只有双向链表才不需要在操作其中某个节点的时候去遍历，才能达到O(1)。（是不是因为这个原因使用的双向链表？）\r\n\r\n### 代码\r\n```py3\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n            \r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            node = DLinkedNode(key, value)\r\n            self.cache[key] = node\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                removed = self.removeTail()\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n\r\n    def addToHead(self, node):\r\n        node.prev = self.head # head <- node \r\n        node.next = self.head.next # node -> head.next\r\n        self.head.next.prev = node # node <- head.next\r\n        self.head.next = node # head -> node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next # node.prev -> node.next\r\n        node.next.prev = node.prev # node.prev <- node.next\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n```\r\n\r\n### 复杂度\r\n时间：因为都是节点的增删（链表）和字典关键词的调用（dict/哈希表）都是O1的操作，所以为O(1)\r\n空间：O(N)，N为capacity"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846415525","body":"### 思路\r\n递归\r\n\r\n### 代码\r\n```py3\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root: return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```\r\n\r\n### 复杂度\r\n时间：O(N) 每个节点都需要调用一次递归运算（N*O(1)）\r\n空间：O(maxdepth)，return的值会占用内存，因此其空间复杂度为树的深度"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Yueqi-19":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839848486","body":"时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int size;\r\n    int[] increment;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        increment = new int[maxSize + 1];\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size == stack.length){\r\n            return;\r\n        }\r\n        stack[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0){\r\n            return -1;\r\n        }\r\n        int res = stack[size - 1];\r\n        if(increment[size] != 0){\r\n            res += increment[size];\r\n            increment[size - 1] += increment[size];\r\n            increment[size] = 0;\r\n        }\r\n        size--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        increment[Math.min(k, size)] += val;\r\n    }\r\n}\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841310834","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1;\r\n    private Stack<Integer> s2;\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.empty()) {\r\n            while (!s1.empty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (s2.empty()) {\r\n            while (!s1.empty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n}\r\n```\r\n1）入队时-s1.push(x)；出队用 s1 s2\r\n2）出队时，如果s2为empty，把s1的数据全部倒入s2"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841680004","body":"java\r\n单调栈\r\n```java\r\npublic int maxChunksToSorted(int[] arr) {\r\n    int top = 0;\r\n    for(int a: arr) {\r\n        int max = a;\r\n        while(top > 0 && arr[top - 1] > a) {\r\n            max = Math.max(max, arr[--top]);\r\n        }\r\n        arr[top++] = max;\r\n    }\r\n    return top;\r\n}\r\n```\r\nTime complexity: O(n)\r\nSpace complexity: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841754932","body":"双指针法\r\n我们需要从末端开始找到第n个节点之前的节点。 此节点将是新列表的最后一个节点，而从末尾开始的第n个节点将是新列表中的新头。\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        int listSize = 0;\r\n        while(fast != null){\r\n            fast = fast.next;\r\n            listSize++;\r\n        }\r\n        fast = head;\r\n        int realRotation = k % listSize;\r\n        for (int i = 0; i < realRotation; i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        fast.next = head;\r\n        head = slow.next;\r\n        slow.next = null;\r\n        return head;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841865708","body":"Java \r\nRecursion Version\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null ||head.next==null)\r\n        return head;\r\n        ListNode temp=head;\r\n        while(temp!=null && temp.next!=null){\r\n            int k=temp.val;\r\n            temp.val=temp.next.val;\r\n            temp.next.val=k;\r\n            temp=temp.next.next;\r\n        }\r\n        return head;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842734735","body":"Java \r\n时间复杂度： O(n logn)\r\n空间复杂度：O(logn)\r\n用快慢指针方法找到中间节点作为根节点，左边部分作为左子树，右边部分作为右子树，递归处理\r\n思路一开始有点混乱，直到卡了三小时，最后求助男友给我理清思路才写出来 TAT\r\n```java\r\n//双指针 + 递归 + 归并排序简化版\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head==null){\r\n            return null;\r\n        } \r\n        return toBST(head,null);\r\n    }\r\n//快慢指针\r\n    public TreeNode toBST(ListNode head, ListNode tail){\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        if(head==tail) return null;\r\n        while(fast!=tail&&fast.next!=tail){\r\n        fast = fast.next.next;\r\n        slow = slow.next;\r\n        }\r\n//merge sort 简化版代码，有点相似\r\n        TreeNode treehead = new TreeNode(slow.val);\r\n        treehead.left = toBST(head,slow);\r\n        treehead.right = toBST(slow.next,tail);\r\n        return treehead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843544105","body":"时间复杂度 O(A + B)\r\n空间复杂度 O(1)\r\n简单题终于找回自信了hhhh\r\n```java\r\n//题目本质，快慢指针，看能否相遇就是交点。\r\n //短链表走到末尾后接着走长链表；长链表同样也是走到末尾再走短链表；直到两个交点相遇\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        //初始化\r\n        ListNode A = headA;\r\n        ListNode B = headB;\r\n        while (A != B) {\r\n            //A直到走到末尾，A.next便为null,便接着走下个HeadB;\r\n            A = A != null ? A.next : headB;\r\n            //B同理\r\n            B = B != null ? B.next : headA;\r\n        }\r\n        return A;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844608699","body":"```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null){\r\n            return null;\r\n        } \r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow== fast){\r\n                while(head != fast){\r\n                    fast = fast.next;\r\n                    head = head.next;\r\n                }\r\n                return head;\r\n            }\r\n        }\r\n        return null;      \r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)，其中 N 为链表长度在最差的情况。\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845567987","body":"```java\r\nclass LRUCache {\r\n//双链表节点类\r\n    class Node {\r\n        int key;\r\n        int value;\r\n        Node prev;\r\n        Node next;\r\n        Node() {\r\n\r\n        }\r\n        Node(int key, int value) {\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n    }\r\n\r\n    private Map<Integer, Node> cache;\r\n    private Node head;\r\n    private Node tail;\r\n    private int capacity;\r\n    private int size;\r\n\r\n    public LRUCache(int capacity) {\r\n        cache = new HashMap<>();\r\n        this.capacity = capacity;\r\n        head = new Node();\r\n        tail = new Node();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!cache.containsKey(key)) {\r\n            return -1;\r\n        }\r\n        Node node = cache.get(key);\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (cache.containsKey(key)) {\r\n            Node node = cache.get(key);\r\n            node.value = value;\r\n            moveToHead(node);\r\n        } else {\r\n            Node node = new Node(key, value);\r\n            cache.put(key, node);\r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n                node = removeTail();\r\n                cache.remove(node.key);\r\n                --size;\r\n            }\r\n        }\r\n    }\r\n\r\n    private void moveToHead(Node node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private void removeNode(Node node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void addToHead(Node node) {\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n        node.prev = head;\r\n    }\r\n\r\n    private Node removeTail() {\r\n        Node node = tail.prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846336936","body":"Java\r\n递归大法好\r\n时间复杂度: O(n)\r\n空间复杂度: O(h)\r\n\r\n```java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        int leftHeight = maxDepth(root.left);\r\n        int rightHeight = maxDepth(root.right);\r\n        int current = Math.max(leftHeight,rightHeight)+1;\r\n        return current;\r\n\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846474522","body":"Java\r\n递归版\r\n时间复杂度： O(N)\r\n空间复杂度： O(N)\r\n```java\r\n//recursion DFS\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) { \r\n        //停止条件\r\n        if (p == null && q == null){\r\n            return true;\r\n        } \r\n        if (p == null && q != null || p != null && q == null){\r\n            return false;\r\n        } \r\n        if (p.val != q.val){\r\n            return false;\r\n        } \r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n\r\n```\r\n迭代版,用Queue 简直太妙了\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) { \r\n        //BFS       \r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        queue.add(p);\r\n        queue.add(q);\r\n        while(!queue.isEmpty()){\r\n            TreeNode p1 = queue.poll();\r\n            TreeNode q1 = queue.poll();\r\n            if(p1 == null && q1 == null){\r\n                continue;\r\n            }else if(p1 == null || q1 == null || p1.val != q1.val){\r\n                return false;\r\n            }\r\n            queue.add(p1.left);\r\n            queue.add(q1.left);\r\n            queue.add(p1.right);\r\n            queue.add(q1.right);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yinfenglin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839166298","body":"Python\r\n\r\nclass Solution:\r\n\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_indices = [i for i, ltr in enumerate(s) if ltr == c]\r\n        \r\n        distances = []\r\n        for i in range(len(s)):\r\n            d_i = [abs(ci - i) for ci in char_indices]\r\n            distances.append(min(d_i))\r\n            \r\n        return distances"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841446671","body":"思路：\r\n如果max(arr[:j]) <= min(arr[j:]), 则在j位置之后分割。先遍历一遍生成min_arr, 第二次遍历生成分割。\r\n\r\nPython\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        def create_min_array(arr):\r\n            c_min = arr[-1]\r\n            min_arr = [c_min]\r\n            for i in range(2, len(arr)+1):\r\n                if arr[-i] < c_min:\r\n                    c_min = arr[-i]\r\n                min_arr.append(c_min)\r\n            return list(reversed(min_arr))\r\n        min_arr = create_min_array(arr)\r\n        \r\n        split_count = 0\r\n        e = 0\r\n        c_max = arr[0]\r\n        while e < len(arr):\r\n            if e+1 == len(arr):\r\n                split_count += 1\r\n            else:\r\n                if c_max < arr[e]:\r\n                    c_max = arr[e]\r\n                if c_max <= min_arr[(e+1)]:\r\n                    split_count += 1\r\n                    c_max = arr[e+1]\r\n            e += 1\r\n        return split_count\r\n```\r\nTime: O(n)\r\nSpace: O(n)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844165951","body":"Python\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        n1, n2 = headA, headB\r\n        while n1 != n2:\r\n            n1 = n1.next if n1 else headB\r\n            n2 = n2.next if n2 else headA\r\n        return n1\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MangoJuicy":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839433927","body":"## 思路\r\n因为是 fixed size stack，可以直接使用数组模拟。index 为指向 top 的指针。\r\n\r\n底部 k 个元素增量 val，可以 iterate bottom K items 来实现，复杂度为 O(n)。可以使用额外的存储inc，来记录要增加的位置。\r\npop 操作，stack top 元素 + 对应的 inc 增量。index - 1处的 增量变为 inc[index - 1] += inc[index]. pop 后，index 对应的增量归零。\r\n\r\n### 注意点\r\n\r\n- 边界，push 时 index 是否越界。\r\n- 边界，pop 时 是否存在 item。\r\n- 增量添加是否合理，空栈或者 k 非正数，无需添加操作。\r\n- 增量添加对应的index 计算，k 超过 stack 元素个数时，按 stack 实际数量操作。\r\n\r\n## 代码\r\n```java\r\n// push: regular push\r\n// pop: res = top + add[index]. If add[index] != 0, add[index - 1] += add[index]。 add[index] = 0\r\n// increment: add[min(k - 1, index)] = val \r\n\r\nclass CustomStack {\r\n    \r\n    private final int[] stack;\r\n    private final int[] add;\r\n    private int index;\r\n    private final int len;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        index = -1; // point to top\r\n        len = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < len - 1) {\r\n            index++;\r\n            stack[index] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index < 0) {\r\n            return -1;\r\n        }\r\n        \r\n        int res = stack[index] + add[index];\r\n        if (index > 0) {\r\n            add[index - 1] += add[index];\r\n        }\r\n        add[index] = 0;\r\n        index--;\r\n        return res;\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (k <= 0 || index < 0) {\r\n            return;\r\n        }\r\n        \r\n        add[Math.min(k - 1, index)] += val;\r\n    }\r\n}\r\n```\r\n空间复杂度：O(n)\r\n时间复杂度：O(1) for all operations."},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842812167","body":"## 思路\r\nBottom-up to rebuild the tree\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    \r\n    ListNode runner = null;\r\n\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        runner = head;\r\n        int size = this.size(head);\r\n        return dfs(0, size - 1);\r\n    }\r\n\r\n    private TreeNode dfs(int left, int right) {\r\n        if (left > right) {\r\n            return null;\r\n        }\r\n\r\n        int mid = left + (right - left) / 2;\r\n        TreeNode leftChild = dfs(left, mid - 1);\r\n        TreeNode root = new TreeNode(runner.val);\r\n        runner = runner.next;\r\n        TreeNode rightChild = dfs(mid + 1, right);\r\n\r\n        root.left = leftChild;\r\n        root.right = rightChild;\r\n\r\n        return root;\r\n    }\r\n\r\n    private int size(ListNode head) {\r\n        int size = 0;\r\n        while (head != null) {\r\n            size++;\r\n            head = head.next;\r\n        }\r\n\r\n        return size;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningali":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-839475296","body":"Time Complexity: O(N) \r\nSpace Complexity: O(N)\r\n\r\nJava\r\n\r\n    public int[] shortestToChar(String s, char c) {\r\n        int length = s.length();\r\n        char[] chars = s.toCharArray();\r\n        int[] res = new int[length];\r\n        \r\n        int left = -length;\r\n        for (int i = 0; i < length; i++) {\r\n            if (chars[i] == c) {\r\n                left = i;\r\n                res[i] = 0;\r\n            } else {\r\n                res[i] = i - left;\r\n            }\r\n        }\r\n        int right = 2 * length;\r\n        for (int i = length - 1; i >= 0; i--) {\r\n            if (chars[i] == c) {\r\n                right = i;\r\n            } else {\r\n                res[i] = Math.min(right - i, res[i]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chelseachen007":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839548839","body":"```javaScript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.stack.length < this.maxSize) this.stack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    return this.stack.pop() || -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    const min = Math.min(this.stack.length, k)\r\n    for (let i = 0; i < min; i++) {\r\n        this.stack[i] += val\r\n    }\r\n\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840232089","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n突出一个写的丑\r\n\r\n```JavaScript\r\nvar decodeString = function (s) {\r\n    let stack = []\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === \"]\") {\r\n            let pop = stack.pop()\r\n            let newStr = pop\r\n            while (pop !== '[') {\r\n                pop = stack.pop()\r\n                pop !== '[' && (newStr = pop + newStr)\r\n            }\r\n\r\n            pop = stack.pop()\r\n            let num = pop\r\n            while (!isNaN(pop)) {\r\n                pop = stack.pop()\r\n                !isNaN(pop) && (num = pop + num)\r\n            }\r\n            pop && stack.push(pop)\r\n            stack.push(newStr.repeat(num))\r\n        } else {\r\n            stack.push(s[i])\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840931430","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(1)\r\n\r\n空间复杂度: O(n)\r\n\r\n```JavaScript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function () {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.pushStack.push(x)\r\n};\r\nMyQueue.prototype._push2Pop = function (x) {\r\n    if (!this.popStack.length) {\r\n        while (this.pushStack.length) {\r\n            this.popStack.push(this.pushStack.pop())\r\n        }\r\n    }\r\n};\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    this._push2Pop()\r\n    return this.popStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    this._push2Pop()\r\n    return this.popStack[this.popStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return !(this.popStack.length || this.pushStack.length)\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841605789","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n单调栈解法：因为要找到做多的快，所以每一个递减区域都可以分成一个块，那么就可以转化成问题：找到第一个比他大的值，也就是单调栈解法。\r\n\r\n当每次找到第一个最大值，将前面的块只需要保存一个极值，这样只需要返回栈的长度即可\r\n\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        let curr = arr[i];\r\n        if (stack.length > 0 && stack[stack.length - 1] > curr) {\r\n            const peek = stack.pop()\r\n            while (stack && stack[stack.length - 1] > curr) stack.pop();\r\n            stack.push(peek);\r\n        } else {\r\n            stack.push(curr);\r\n        }\r\n    }\r\n    return stack.length;\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(nlogn) 排序的复杂度\r\n\r\n空间复杂度: O(n)\r\n\r\n滑动窗口解法：根据题意中 每个可排序块的总和应该是恒等的 所以将和相加，每一个和相等的实际就是一次切分块的点\r\n\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const newArr = [...arr]\r\n    const sortArr = newArr.sort((a, b) => a - b)\r\n    let count = 0, sum1 = 0, sum2 = 0\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i]\r\n        sum2 += sortArr[i]\r\n        if (sum1 == sum2) {\r\n            count++\r\n        }\r\n    }\r\n    return count\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841775358","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n```JavaScript\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function (head, k) {\r\n    if (!head || !head.next || !k) return head\r\n    let length = 1\r\n    let newHead = head\r\n    while (head.next) {\r\n        length++\r\n        head = head.next\r\n    }\r\n    head.next = newHead\r\n    let newlength = length - k % length\r\n    while (newlength) {\r\n        head = head.next\r\n        newlength--\r\n    }\r\n    const curr = head.next\r\n    head.next = null\r\n    return curr\r\n\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842074827","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n```JavaScript\r\nvar swapPairs = function (head) {\r\n    if (!head || !head.next) return head\r\n    const newList = new ListNode(null, head)\r\n\r\n    let prev = newList // null  1\r\n    let curr = prev.next // 1  3\r\n    while (curr && curr.next) {\r\n        const next = curr.next // 2  4\r\n        curr.next = next.next // 3 => 1  null => 4 \r\n        next.next = curr // 1 => 2 3 => null \r\n        prev.next = next // 2 => null  4 => 1\r\n\r\n        prev = curr // 1 =>  null\r\n        curr = curr.next // 2 => 1\r\n    }\r\n    return newList.next\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842755540","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n这道题没有要求左右节点的顺序，比直接前中后序还原好像简单点\r\n\r\n```JavaScript\r\nvar sortedListToBST = function (head) {\r\n    if (!head) return null\r\n    let slow = head\r\n    let fast = head\r\n    let prev = null\r\n    while (fast?.next) {\r\n        prev = slow\r\n        slow = slow.next\r\n        fast = fast.next.next\r\n    }\r\n    let root = new TreeNode(slow.val, null, null)\r\n    if (prev !== null) {\r\n        prev.next = null\r\n        root.left = sortedListToBST(head)\r\n    }\r\n    root.right = sortedListToBST(slow.next)\r\n    return root\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843703478","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(m+n) \r\n\r\n空间复杂度: O(1)\r\n\r\n```JavaScript\r\nvar getIntersectionNode = function (headA, headB) {\r\n    const currA = headA\r\n    const currB = headB\r\n    while (headA !== headB) {\r\n        headA = headA ? headA.next : currB\r\n        headB = headB ? headB.next : currA\r\n    }\r\n    return headA\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(n)  n 为长度max\r\n\r\n空间复杂度: O(n)\r\n\r\nMap结构存储节点 空间换时间\r\n\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n    let map = new Map()\r\n    while (headA) {\r\n        map.set(headA, 1)\r\n        headA = headA.next\r\n    }\r\n    while (headB) {\r\n        if (map.has(headB)) {\r\n            return headB\r\n        }\r\n        headB = headB.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844620923","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(n)\r\n\r\n链表问题首先使用Map记录结点，有环就会重复走一个结点\r\n\r\n```JavaScript\r\nvar detectCycle = function (head) {\r\n    let map = new Map()\r\n    while (head) {\r\n        if (map.has(head)) return head\r\n        map.set(head, 1)\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n快慢指针，快慢指针第一次相遇的时候，头结点和慢指针离入环点的距离相等\r\n\r\n```javascript\r\nvar detectCycle = function (head) {\r\n    let slow = head\r\n    let fast = head\r\n    while (fast) {\r\n        slow = slow.next\r\n        if (!fast.next) return null\r\n        fast = fast.next.next\r\n        if (fast !== slow) continue\r\n        let pre = head\r\n        while (pre !== slow) {\r\n            pre = pre.next\r\n            slow = slow.next\r\n        }\r\n        return slow\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845611385","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(1) 两个操作都是 01\r\n\r\n空间复杂度: O(N)\r\n\r\n写错一个变量赋值 debug一个小时\r\n\r\n```JavaScript\r\nclass DoubleLink {\r\n    constructor(key, val) {\r\n        this.value = val\r\n        this.key = key\r\n        this.prev = null\r\n        this.next = null\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.max = capacity\r\n    this.head = new DoubleLink(null, null)\r\n    this.tail = new DoubleLink(null, null)\r\n    this.head.next = this.tail\r\n    this.tail.prev = this.head\r\n    this.map = new Map()\r\n};\r\nLRUCache.prototype._toHead = function (link) {\r\n    this.head.next.prev = link\r\n    link.next = this.head.next\r\n    this.head.next = link\r\n    link.prev = this.head\r\n}\r\nLRUCache.prototype._remove = function (link) {\r\n    link.prev.next = link.next\r\n    link.next.prev = link.prev\r\n\r\n    link.prev = null\r\n    link.next = null\r\n    return link\r\n}\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    if (this.map.has(key)) {\r\n        const link = this.map.get(key)\r\n        this._toHead(this._remove(link))\r\n        return link.value\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    if (this.map.has(key)) {\r\n        const link = this.map.get(key)\r\n        link.value = value\r\n        this._toHead(this._remove(link))\r\n    } else {\r\n        if (this.map.size >= this.max) {\r\n            const prev = this.tail.prev\r\n            this._remove(prev)\r\n            this.map.delete(prev.key)\r\n        }\r\n        const link = new DoubleLink(key, value)\r\n        this._toHead(link)\r\n        this.map.set(key, link)\r\n\r\n    }\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846339410","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n前序遍历\r\n\r\n```JavaScript\r\nvar maxDepth = function (root, max = 0) {\r\n    if (!root) return max\r\n    return Math.max(maxDepth(root.left, max + 1),\r\n        maxDepth(root.right, max + 1))\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n) 每个节点进出一次\r\n\r\n空间复杂度: O(n) 一层最大值\r\n\r\n层序遍历\r\n\r\n```JavaScript\r\nvar maxDepth = function (root) {\r\n    if (!root) return 0\r\n    let queen = [root]\r\n    let result = 0\r\n\r\n    while (queen.length) {\r\n        const length = queen.length\r\n        console.log(length)\r\n        result += 1\r\n        for (let i = 0; i < length; i++) {\r\n            const curr = queen.shift()\r\n            if (curr.left) queen.push(curr.left)\r\n            if (curr.right) queen.push(curr.right)\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n## "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846492052","body":"### 解法一\r\n\r\n#### 时空复杂度\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(1)\r\n\r\n递归 把几种特殊情况判断下即可\r\n\r\n```JavaScript\r\nvar isSameTree = function (p, q) {\r\n    if (!q && !p) return true\r\n    if (!q || !p) {\r\n        return false\r\n    }\r\n    if (p.val === q.val) {\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n    }\r\n    return false\r\n};\r\n```\r\n\r\n### 解法二\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度: O(2n)\r\n\r\n层序遍历\r\n\r\n```JavaScript\r\nvar isSameTree = function (p, q) {\r\n    if (!q && !p) return true\r\n    if (!q || !p) return false\r\n\r\n    let PStack = [p]\r\n    let QStack = [q]\r\n    while (PStack.length || QStack.length) {\r\n        let pPop = PStack.pop()\r\n        let qPop = QStack.pop()\r\n        if (pPop.val !== qPop.val) return false\r\n        if (pPop.left && qPop.left) {\r\n            PStack.push(pPop.left)\r\n            QStack.push(qPop.left)\r\n        }\r\n        else if (!pPop.left && !qPop.left) { }\r\n        else if (!pPop.left || !qPop.left) return false\r\n\r\n        if (pPop.right && qPop.right) {\r\n            PStack.push(pPop.right)\r\n            QStack.push(qPop.right)\r\n        } else if (!pPop.right && !qPop.right) {\r\n\r\n        } else if (!pPop.right || !qPop.right) return false\r\n    }\r\n    return true\r\n};\r\n```\r\n\r\n## "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840161675","body":"**思路:**\r\n\r\n查找string S里的每个字符离给定字符C的index的最短距离，对于每个字符有以下三种情况：\r\n\r\n。如果等于C则距离=0\r\n。最近的C在其左边\r\n。最近的C在其右边\r\n\r\n。从左到右依次遍历字符串S，比较每个字符与字符C的最短距离并存放到返回数组res中\r\n。从右到左依次遍历字符串S，比较每个字符与字符C的最短距离并与之前存放在数组res中的距离取小值\r\n\r\n**复杂度分析:**\r\n\r\n时间复杂度: O(n), n为string S长度\r\n空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> res(n, INT_MAX);\r\n\r\n        int l;\r\n        // scan string S from left to right to get the distance of each character\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        // scan string S from right to lef to get the distance of each character, then choose the shortest one via comparing the distance values\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c)\r\n                l = i;\r\n            res[i] = min(res[i], abs(i - l));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844633110","body":"**思路**\r\n快慢指针法，一个指针slow走一步，一个指针fast走两步，如果两个指针相遇则表示有环存在。\r\n- 有环存在时，slow重新指向head, fast继续每次走一步，slow每次走一步，相遇时即为环开始的节点，返回该节点即可\r\n- 无环时，直接返回-1\r\n\r\n**复杂度**\r\n- 时间复杂度：O(K)，K为环中的节点数\r\n- 空间复杂度:O(1)\r\n\r\n**代码**\r\n```C++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if (!head || !head->next) return nullptr;\r\n\r\n        ListNode* slow = head;\r\n        ListNode* fast = head;\r\n\r\n        while (fast && fast->next) {\r\n            slow = slow->next;\r\n            fast = fast->next->next;\r\n            if (fast == slow)\r\n                break;\r\n        }\r\n\r\n        if (fast == slow) {\r\n            slow = head;\r\n\r\n            while (fast != slow) {\r\n                fast = fast->next;\r\n                slow = slow->next;\r\n            }\r\n\r\n            return slow;\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845593066","body":"**思路**\r\n使用双向链表和哈希表\r\n\r\n**复杂度分析**\r\n- 时间复杂度: O(1)\r\n- 空间复杂度: O(N)， N为capacity\r\n\r\n**代码**\r\n```C++\r\nclass LRUCache {\r\npublic:\r\n    struct DList {\r\n        int key;\r\n        int val;\r\n        DList* prev;\r\n        DList* next;\r\n        DList(int k, int v): key(k), val(v), prev(NULL), next(NULL) {};\r\n    };\r\n\r\n    LRUCache(int capacity) {\r\n        head = new DList(-1, -1);\r\n        tail = new DList(-2, -2);\r\n        head->next = tail;\r\n        tail->prev = head;\r\n        size = capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!mp.empty() && mp.count(key)) {\r\n            DList* node = mp[key];\r\n\r\n            if (mp.size() > 1) {\r\n                delnode(node);\r\n                add2tail(node);\r\n            }\r\n\r\n            return node->val;\r\n        }\r\n\r\n        return -1;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!mp.empty() && mp.count(key)) {\r\n            DList* node = mp[key];\r\n            node->val = value;\r\n            delnode(node);\r\n            add2tail(node);\r\n        } else {\r\n            DList* node = new DList(key, value);\r\n            if (mp.size() == size) {\r\n                int k = head->next->key;\r\n                delnode(head->next);\r\n                mp.erase(k);\r\n            }\r\n            add2tail(node);\r\n            mp[key] = node;\r\n        }\r\n    }\r\nprivate:\r\n    map<int, DList*> mp;\r\n    int size;\r\n    DList* head;\r\n    DList* tail;\r\n\r\n    void add2tail(DList* node) {\r\n        tail->prev->next = node;\r\n\r\n        node->prev = tail->prev;\r\n        node->next = tail;\r\n        tail->prev = node;\r\n    }\r\n\r\n    void delnode(DList* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846460200","body":"**思路**\r\n一、递归法\r\n- 比较根节点\r\n- 分别比较左、右子树\r\n二、迭代法\r\n利用辅助queue\r\n\r\n**复杂度分析**\r\n- 时间复杂度: O(min(M, N)), M, N为两棵树的节点数\r\n- 空间复杂度: O(min(logM, logN)\r\n\r\n**代码**\r\n```C++\r\n方法一、\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    bool isSameTree(TreeNode* p, TreeNode* q) {\r\n        if (!p && !q) return true;\r\n        if (!p || !q) return false;\r\n    \r\n        return ((p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right));\r\n    }\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peacejoylove86":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840252978","body":"import java.util.ArrayList;\r\n\r\npublic class Leetcode821 {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s == null)\r\n        {\r\n            return null;\r\n        }\r\n        char[] chars = s.toCharArray();\r\n        int[] output = new int[s.length()];\r\n        if (!s.contains(String.valueOf(c)))\r\n        {\r\n            return output;\r\n        }\r\n        ArrayList indexs = new ArrayList();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                indexs.add(i);\r\n        }\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (c == chars[i])\r\n                output[i] = 0;\r\n            else\r\n            {\r\n                int temp = Math.abs(i-((Integer) indexs.get(0)).intValue());\r\n                for (int j = 0; j < indexs.size(); j++) {\r\n                    int val = Math.abs(i-((Integer) indexs.get(j)).intValue());\r\n                    if (val < temp)\r\n                        temp = val;\r\n                }\r\n                output[i]=temp;\r\n            }\r\n        }\r\n        return output;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Leetcode821 lc = new Leetcode821();\r\n        String s = \"loveleetcode\";\r\n        char c = 'e';\r\n        //输出：[3,2,1,0,1,0,0,1,2,2,1,0]\r\n        int[] output = lc.shortestToChar(s,c);\r\n        for (int item:output\r\n             ) {\r\n            System.out.println(item);\r\n        }\r\n    }\r\n}"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840255070","body":"import java.util.ArrayList;\r\nimport java.util.Stack;\r\n\r\nclass Leetcode394 {\r\n    public static String decodeString(String s) {\r\n        Stack sk = new Stack();\r\n        char[] input = s.toCharArray();\r\n        StringBuffer output = new StringBuffer();\r\n        StringBuffer subStr = new StringBuffer();\r\n        StringBuffer number = new StringBuffer();\r\n        for (int i = 0; i <= input.length - 1; i++) {\r\n            String temp = String.valueOf(input[i]);\r\n            if (isNumeric(temp)) {\r\n                number.append(input[i]);\r\n                continue;\r\n            }\r\n            if ('[' == input[i]) {\r\n                sk.push(number.toString());\r\n                number.delete(0, number.length());\r\n                subStr.delete(0, subStr.length());\r\n                for (int j = 1; j <= input.length - i - 1; j++) {\r\n                    if (']' == input[i + j]) {\r\n                        i = i + j;\r\n                        break;\r\n                    } else if (isChar(String.valueOf(input[i + j]))) {\r\n                        subStr.append(input[i + j]);\r\n                    }\r\n\r\n                }\r\n            }\r\n\r\n            if (!sk.isEmpty()) {\r\n                int repeat = Integer.valueOf((String) sk.pop());\r\n                for (int j = 0; j <= repeat - 1; j++) {\r\n                    output.append(subStr);\r\n                }\r\n            }\r\n        }\r\n        return output.toString();\r\n    }\r\n\r\n    public final static boolean isNumeric(String s) {\r\n        if (s != null && !\"\".equals(s.trim()))\r\n            return s.matches(\"^[0-9]*\");\r\n        else\r\n            return false;\r\n    }\r\n\r\n    public final static boolean isChar(String s) {\r\n        char c = s.charAt(0);\r\n        if (((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        System.out.println(decodeString(\"10[a]2[bc]\"));\r\n    }\r\n}"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yolo-jane":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840236906","body":"使用正则：执行用时：88 ms (去刷刷讲义后，再来)\r\n```\r\n输入\r\n\"3[z]2[2[y]pq4[2[jk]e1[f]]]ef\"\r\n输出\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n预期结果\r\n\"zzzyypqjkjkefjkjkefjkjkefjkjkefyypqjkjkefjkjkefjkjkefjkjkefef\"\r\n\r\n```\r\n\r\n``` javascript\r\n/**\r\n * @param {string} str  \"3[a]2[bc]\"\r\n * @return {string} \"aaabcbc\"\r\n */\r\nvar decodeString = function (str) {\r\n  let result = ''\r\n  function replaceString(str) {\r\n    let res = str.replace(/(\\d+)(\\[(\\w+)\\])/g, (rs, $1, $2) => {\r\n      //  console.log(`rs=`+rs,`$1=`+$1,`$2=`+$2); rs=3[a] $1=3 $2=[a] rs=2[bc] $1=2 $2=[bc]\r\n      let res1 = []; for (let i = 0; i < $1; i++) {\r\n        let notNumber = $2.match(/\\w+/)[0];\r\n        if (notNumber) {\r\n          res1.push($2.match(/\\w+/))\r\n        }\r\n\r\n      }\r\n      return res1.join(\"\");\r\n\r\n    })\r\n\r\n\r\n    return res;\r\n  }\r\n\r\n  result = replaceString(str);\r\n  if (result.match(/(\\d+)(\\[(\\w+)\\])/g)) {\r\n    return decodeString(result);\r\n  } else {\r\n    return result;\r\n  }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZiyangZ":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839400425","body":"- A simple implementation using array\r\n- Time complexity: O(1) for push and pop. O(n) for increment and initialization. \r\n- Space complexity: O(1) for push, pop and increment. O(n) for initialization.\r\n``` Java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int index = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (index < array.length - 1) {\r\n            array[++index] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (index < 0) return index;\r\n        return array[index--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, index+1); i++) {\r\n            array[i] += val;\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840245423","body":"- Using the code from YouTuber AndroidBabies. \r\n- Her code is not perfect. Feels a little clumsy.\r\n- Definitely needs more review.\r\n``` Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Integer num = 0;\r\n        Stack<Object> stack = new Stack<>();\r\n        \r\n        for (char c: s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            } else if (c == '[') {\r\n                stack.push(num);\r\n                num = 0;\r\n            } else if (c == ']') {\r\n                String newstr = helper(stack);\r\n                Integer cnt = (Integer) stack.pop();\r\n                for (int i = 0; i < cnt; i++) {\r\n                    stack.push(newstr);\r\n                }\r\n            } else {\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n        return helper(stack);\r\n    }\r\n    \r\n    private String helper(Stack<Object> stack) {\r\n        Stack<String> tmp = new Stack<>();\r\n        while (!stack.isEmpty() && stack.peek() instanceof String) {\r\n            tmp.push((String) stack.pop());\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        while (!tmp.isEmpty()) {\r\n            sb.append(tmp.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923632","body":"``` Java\r\nclass MyQueue {\r\n    Stack<Integer> queue = new Stack<>();\r\n    Stack<Integer> help = new Stack<>();\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        queue.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        while(!queue.empty()) {\r\n            help.push(queue.pop());\r\n        }\r\n        int temp = help.pop();\r\n        while(!help.empty()) {\r\n            queue.push(help.pop());\r\n        }\r\n        return temp;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        while(!queue.empty()) {\r\n            help.push(queue.pop());\r\n        }\r\n        int temp = help.peek();\r\n        while(!help.empty()) {\r\n            queue.push(help.pop());\r\n        }\r\n        return temp;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return queue.empty();\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841664965","body":"- From Lee215...\r\n``` Java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        int res = 0, sum1 = 0, sum2 = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            sum1 += arr[i];\r\n            sum2 += sorted[i];\r\n            if (sum1 == sum2) res += 1;\r\n        }\r\n    return res;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841824635","body":"``` Java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null)\r\n\t\treturn head;\r\n\t\r\n        ListNode copyHead = head;\r\n\t\r\n        int len = 1;\r\n        while (copyHead.next != null) {\r\n            copyHead = copyHead.next;\r\n            len++;\r\n        }\r\n\t\r\n        copyHead.next = head;\r\n        \r\n        for (int i = len - k % len; i > 1; i--)\r\n            head = head.next;\r\n\r\n        copyHead = head.next;\r\n        head.next = null;\r\n\r\n        return copyHead;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841944066","body":"``` Java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n\r\n        if ((head == null) || (head.next == null)) {\r\n            return head;\r\n        }\r\n\r\n        ListNode firstNode = head;\r\n        ListNode secondNode = head.next;\r\n\r\n        firstNode.next  = swapPairs(secondNode.next);\r\n        secondNode.next = firstNode;\r\n\r\n        return secondNode;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842763281","body":"```Java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return helper(head, null);\r\n    }\r\n    \r\n    private TreeNode helper(ListNode start, ListNode end) {\r\n        if (start == end) return null;\r\n        ListNode fast = start;\r\n        ListNode slow = start;\r\n        while(fast != end && fast.next != end) {\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = helper(start, slow);\r\n        root.right = helper(slow.next, end);\r\n        return root;\r\n    }\r\n}\r\n```\r\n- The official LC solution explains why the time complexity is _O(N*logN)_\r\n<img width=\"640\" alt=\"Screen Shot 2021-05-17 at 9 48 49 PM\" src=\"https://user-images.githubusercontent.com/31392612/118578155-ac8fa700-b759-11eb-87a7-d9672b5e4698.png\">\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843532507","body":"- Using Hash Table. Time complexity O(N+M). Space complexity O(N).\r\n``` Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> nodeA = new HashSet<>();\r\n        ListNode curA = headA;\r\n        ListNode curB = headB;\r\n        \r\n        while (curA != null) {\r\n            nodeA.add(curA);\r\n            curA = curA.next;\r\n        }\r\n        \r\n        while (curB != null) {\r\n            if (nodeA.contains(curB)) {\r\n                break;\r\n            }\r\n            curB= curB.next;\r\n        }\r\n        \r\n        return curB;\r\n    }\r\n}\r\n```\r\n- Using two pointers. Time complexity O(N+M). Space complexity O(1).\r\n``` Java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode pointerA = headA;\r\n        ListNode pointerB = headB;\r\n        \r\n        while (pointerA != pointerB) {\r\n            pointerA = (pointerA == null)? headB:pointerA.next;\r\n            pointerB = (pointerB == null)? headA:pointerB.next;\r\n        }\r\n        \r\n        return pointerA;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844662534","body":"- Haven't figured out how Floyd's algorithm works.\r\n- For the hash table method, the time and space complexity are both O(N).\r\n``` Java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<>();\r\n        while (!set.contains(head)) {\r\n            if (head == null) break;\r\n            set.add(head);\r\n            head = head.next;\r\n        }\r\n        return head;\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845610508","body":"- Learned a new thing: LinkedHashMap\r\n``` Java\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846416524","body":"``` Java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846457214","body":"- Recursion\r\n``` Java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        if (p.val != q.val) return false;\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n}\r\n```\r\n- Iteration\r\n```java\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        queue.offer(p);\r\n        queue.offer(q);\r\n  \r\n        while (!queue.isEmpty()) {\r\n            TreeNode first = queue.poll();\r\n            TreeNode second = queue.poll();\r\n            if (first == null && second == null) continue;\r\n            if (first == null || second == null) return false;\r\n            if (first.val != second.val) return false;\r\n            queue.offer(first.left);\r\n            queue.offer(second.left);\r\n            queue.offer(first.right);\r\n            queue.offer(second.right);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Endeavor-Gcl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"QiYang03101994":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840253072","body":" 思路：参考最佳答案，用heap来控制迭代过程，遇到[，push，遇到], pop，通过使用heap来控制递归的开始和终止\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        multi = 0\r\n        res = ''\r\n        last_res= ''\r\n        final_res =''\r\n        stack = []\r\n\r\n        for i in range(len(s)):\r\n            c = s[i]\r\n            if ('0' <= c and c <= '9'):\r\n                multi = multi * 10 + int(c)\r\n            \r\n            elif (c == '['):\r\n                stack.append([res,multi])\r\n                # print(stack)\r\n                multi = 0\r\n                res =''\r\n            \r\n            elif (c == ']'):\r\n                [last_res,cur_multi] = stack.pop()\r\n                res = last_res + cur_multi * res\r\n                \r\n            else:\r\n                res += c\r\n\r\n\r\n        return res\r\n时空复杂度均为：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280306","body":"## 思路\r\n* 参考官方题解，用两个stack来替代一个deque\r\n## 代码\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.pop_stack = []\r\n        self.push_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while(self.pop_stack):\r\n            self.push_stack.append(self.pop_stack.pop())\r\n        \r\n        self.push_stack.append(x)\r\n\r\n        while(self.push_stack):\r\n            self.pop_stack.append(self.push_stack.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n\r\n        return self.pop_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.pop_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.pop_stack) == 0"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843675558","body":"参考官方题解双指针\r\n***\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        if (headA == None or headB == None):\r\n            return None\r\n        else:\r\n            pA = headA\r\n            pB = headB\r\n            while(pA !=  pB):\r\n                pA = pA.next if pA else headB\r\n                pB = pB.next if pB else headA\r\n            \r\n            return pA\r\n*** \r\ntime complexity: O(M+N)\r\nspace complexity:O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845618827","body":"思路:双向链表 + hash map\r\n***\r\nclass DlinkNode(object):\r\n    def __init__(self,key,val):\r\n        self.key = key\r\n        self.val = val\r\n        self.prev = None\r\n        self.next = None\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.cache = dict()\r\n        self.head = DlinkNode(0,0)\r\n        self.tail = DlinkNode(0,0)\r\n\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n    \r\n    def get(self, key: int) -> int:\r\n        if (not key in self.cache.keys()):\r\n            return -1\r\n        else:\r\n            self.moveHead(self.cache[key])\r\n            return self.cache[key].val \r\n\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if (key not in self.cache.keys()):\r\n            Node = DlinkNode(key,value)\r\n            self.addHead(Node)\r\n            self.cache[key] = Node\r\n\r\n        else:\r\n            self.cache[key].val = value\r\n            self.moveHead(self.cache[key])\r\n\r\n        if (len(self.cache.keys()) > self.capacity):\r\n            delNode = self.removeTail()\r\n            del self.cache[delNode.key]\r\n \r\n\r\n\r\n    def removeNode(self,Node):\r\n        Node.prev.next = Node.next\r\n        Node.next.prev = Node.prev\r\n\r\n    def addHead(self,Node):\r\n        Node.next = self.head.next\r\n        Node.prev = self.head\r\n\r\n        self.head.next = Node\r\n        Node.next.prev = Node\r\n    \r\n    def moveHead(self,Node):\r\n        self.removeNode(Node)\r\n        self.addHead(Node)\r\n\r\n    def removeTail(self):\r\n        retNode = self.tail.prev\r\n        self.tail.prev = self.tail.prev.prev\r\n        self.tail.prev.next = self.tail\r\n\r\n        return retNode\r\n        \r\n       \r\n        \r\n    def printNode(self,head):\r\n        count = 0\r\n        while(head.next!=None):\r\n            count += 1\r\n            print(count,head.key,head.val)\r\n            head = head.next\r\n\r\n***\r\n- 时间复杂度 o(1)\r\n- 空间复杂度o(N+1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840281532","body":"**思路：**\r\n利用栈的后进先出特性展开折叠的字符\r\n\r\n**代码：**\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        s = list(s)\r\n        stack = []\r\n        for k in s:\r\n            if k == ']':\r\n                cnt = ''\r\n                nr = ''\r\n                l = stack.pop()\r\n                while l != '[':\r\n                    nr = l + nr\r\n                    l = stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    cnt = stack.pop() + cnt\r\n                stack.append(nr * int(cnt)) \r\n            else:\r\n                stack.append(k)\r\n        return reduce(lambda x, y: x + y, stack)`\r\n```\r\n\r\n**复杂度分析：**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841307408","body":"今天的题简单鸭！但我写的还是麻烦了点~~冲\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.l1 = []\r\n        self.l2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.l1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.l2:\r\n            while self.l1:\r\n                self.l2.append(self.l1.pop())\r\n        return self.l2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.l2:\r\n            while self.l1:\r\n                self.l2.append(self.l1.pop())\r\n        return self.l2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return self.l1 == [] and self.l2 == []\r\n```\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841614833","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        l = len(arr)\r\n        cnt = 0\r\n        for i in range(l-1):\r\n            if max(arr[:i+1]) <= min(arr[i+1:]):\r\n                cnt += 1\r\n        return cnt + 1\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841757362","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if (not head) or (not head.next):\r\n            return head\r\n        cnt = 0\r\n        p = head\r\n        while p:\r\n            cnt += 1\r\n            p = p.next\r\n        k = k % cnt\r\n        if k == 0:\r\n            return head\r\n        p = head\r\n        for i in range(cnt-k-1):\r\n            p = p.next\r\n        mark_tail = p\r\n        p = p.next\r\n        mark_tail.next = None\r\n        new_head = p\r\n        while p.next != None:\r\n            p = p.next\r\n        p.next = head\r\n        return new_head\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844828193","body":"双指针法。思路mark\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        f = s = head\r\n        while f and f.next:\r\n            s = s.next\r\n            f = f.next.next\r\n            if f == s:\r\n                break\r\n        else:\r\n            return None\r\n        f = head\r\n        while f != s:\r\n            s = s.next\r\n            f = f.next\r\n        return f\r\n```\r\n复杂度分析\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/40#issuecomment-840343221","body":"## 821.字符的最短距离\r\n\r\n### 思路\r\n向左或者向右距离目标字符最近的距离，取最小值\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n  let len = s.length\r\n  let res = []\r\n  let prev = -10000\r\n  for (let i = 0; i < len; ++i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = i - prev\r\n  }\r\n  prev = 20000\r\n  for (let i = len - 1; i >= 0; --i) {\r\n    if (s.charAt(i) == c) prev = i\r\n    res[i] = Math.min(res[i], prev - i)\r\n  }\r\n  return res\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n^2)，其中 n 为数组的长度。\r\n* 空间复杂度：O(n)。\r\n* "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840526051","body":"## 394.字符串解码\r\n\r\n### 思路\r\n使用入栈出栈操作，将原字符串解码\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n  let res = '';\r\n  let multi = 0;\r\n  let stack_multi = [];\r\n  let stack_res = [];\r\n  for (let i = 0, len = s.length; i < len; i++) {\r\n    c = s.charAt(i)\r\n    if(c == '[') {\r\n      // 把数字和拼接的字母分别压入栈\r\n      stack_multi.push(multi)\r\n      stack_res.push(res)\r\n      multi = 0\r\n      res = ''\r\n    } else if(c == ']') {\r\n      let tmp = ''\r\n      // 数字出栈\r\n      let cur_multi = stack_multi.pop()\r\n      // 数字作为循环次数\r\n      for (let i = 0; i < cur_multi; i++) {\r\n        tmp += res\r\n      }\r\n      res = stack_res.pop() + tmp\r\n    } else if (c >= '0' && c <= '9') {\r\n      multi = multi * 10 + parseInt(c)\r\n    } else {\r\n      res += c\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)。\r\n* 空间复杂度：O(N)。\r\n* "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841195744","body":"## 232.用栈实现队列\r\n\r\n### 思路\r\n* 将一个栈当作输入栈，用于压入push传入的数据；\r\n* 另一个栈当作输出栈，用于pop 和 peek 操作。\r\n* 每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，\r\n* 这样输出栈，从栈顶往栈底的顺序，就是队列从队首往队尾的顺序。\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  // 输入栈\r\n  this.in_stack = []\r\n  // 输出栈\r\n  this.out_stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.in_stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if (this.out_stack.length == 0) {\r\n    this.in2out()\r\n  }\r\n  return this.out_stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if (this.out_stack.length == 0) {\r\n    this.in2out()\r\n  }\r\n  return this.out_stack[this.out_stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.in_stack.length == 0 && this.out_stack.length == 0\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n  while (this.in_stack.length > 0) {\r\n    this.out_stack.push(this.in_stack.pop())\r\n  }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(n)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678915","body":"## 768.最多能完成排序的块II\r\n\r\n### 思路\r\n判断是否是排序块，只需要用到该块的元素最大值 head。可以遍历一遍数组 arr ，动态判断到目前数字 num 为止，最多能分出多少排序块，并保存每个排序块的最大值 head 。每遍历到下个数字 num ，动态判断前面所有的排序块是否成立，并更新所有排序块。\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n  let stack = []\r\n  let num\r\n  for (let i = 0, len = arr.length; i < len; i++) {\r\n    num = arr[i]\r\n    if (stack.length > 0 && num < stack[stack.length - 1]) {\r\n      let head = stack.pop()\r\n      while(stack.length > 0 && num < stack[stack.length - 1]) {\r\n        stack.pop()\r\n      }\r\n      stack.push(head)\r\n    } else {\r\n      stack.push(num)\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(n)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841831892","body":"## 61.旋转链表\r\n\r\n### 思路\r\n快慢指针\r\n* 获取单链表的倒数第 k（尾节点）与倒数第 k+1 个节点\r\n* 将倒数第 k+1个节点的 next 指向 null\r\n* 将尾节点的 next 指向 head（拼起来）\r\n* 返回倒数第 k 个节点\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar rotateRight = function(head, k) {\r\n  if (!head || !head.next) return head\r\n  let count = 0, now = head\r\n  while(now) {\r\n    now = now.next\r\n    count++\r\n  }\r\n  k = k % count\r\n  let slow = (fast = head)\r\n  while(fast.next) {\r\n    if (k-- <= 0) {\r\n      slow = slow.next\r\n    }\r\n    fast = fast.next\r\n  }\r\n  fast.next = head\r\n  let res = slow.next\r\n  slow.next = null\r\n  return res\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(1)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842385288","body":"## 24.两两交换链表中的节点\r\n\r\n### 思路\r\n递归法处理，递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。\r\n如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar swapPairs = function(head) {\r\n  if (head == null || head.next == null) {\r\n    return head\r\n  }\r\n  let next = head.next\r\n  head.next = swapPairs(next.next)\r\n  next.next = head\r\n  return next\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。\r\n* 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843272037","body":"## 109.有序链表转换二叉搜索树\r\n\r\n### 思路\r\n* 先构建左子树，再构建根节点，再构建右子树。——遵循中序遍历。\r\n* 其实，BST 的中序遍历，打印的节点值正是这个有序链表的节点值顺序\r\n \r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar sortedListToBST = (head) => {\r\n  if (head == null) return null\r\n  let len = 0\r\n  let h = head\r\n  while(head) {\r\n    len++\r\n    head = head.next\r\n  }\r\n  const buildBST = (start, end) => {\r\n    if (start > end) return null\r\n    const mid = (start + end) >>> 1\r\n    const left = buildBST(start, mid - 1)\r\n    const root = new TreeNode(h.val)\r\n    h = h.next\r\n    root.left = left\r\n    root.right = buildBST(mid + 1, end)\r\n    return root\r\n  }\r\n  return buildBST(0, len - 1)\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(logn)。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844169671","body":"## 160.相交链表\r\n\r\n### 思路\r\n* 把a链表的元素遍历出来放一个集合里\r\n* 遍历b链表，判断是否在之前生成的集合里，存在的话就是要找的相交点，找不到就返回null表示不相交\r\n \r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n  let aSet = new Set()\r\n  pA = headA\r\n  pB = headB\r\n  while (pA) {\r\n    aSet.add(pA)\r\n    pA = pA.next\r\n  }\r\n  while (pB) {\r\n    if (aSet.has(pB)) {\r\n      return pB\r\n    } else {\r\n      pB = pB.next\r\n    }\r\n  }\r\n  return null\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。\r\n* 空间复杂度：O(n)。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845206326","body":"## 142.环形链表II\r\n\r\n### 思路\r\n* 遍历整个链表,同时将每个节点都插入哈希表。由于题目没有限定每个节点的值均不同，因此我们必须将节点的引用作为哈希表的键。\r\n* 如果当前节点在哈希表中不存在,继续遍历。如果存在,那么当前节点就是环的入口节点。\r\n \r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar detectCycle = function(head) {\r\n  let aSet = new Set()\r\n  while (head) {\r\n    if (aSet.has(head)) {\r\n      return head\r\n    } else {\r\n      aSet.add(head)\r\n    }\r\n    head = head.next\r\n  }\r\n  return null\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(n)。n为链表中总的节点数\r\n* 空间复杂度：O(n)。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846052277","body":"## 146.LRU缓存机制\r\n\r\n### 思路\r\n* 根据题目要求,存储的数据需要保证顺序关系(逻辑层面) ===> 使用数组,链表等保证顺序关系\r\n* 同时需要对数据进行频繁的增删, 时间复杂度 O(1) ==> 使用链表等\r\n* 对数据进行读取时, 时间复杂度 O(1) ===> 使用哈希表\r\n \r\n### 代码 JavaScript\r\n\r\n```javascript\r\nfunction ListNode(key, val) {\r\n  this.key = key\r\n  this.val = val\r\n  this.prev = this.next = null\r\n}\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  // 保存一个该数据结构的最大容量\r\n  this.capacity = capacity\r\n  this.size = 0\r\n  this.data = {}\r\n  // 生成一个双向链表,同时保存该链表的头结点与尾节点\r\n  this.head = new ListNode()\r\n  this.tail = new ListNode()\r\n  this.head.next = this.tail\r\n  this.tail.prev = this.head\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  // 哈希表中存在该关键字\r\n  if (this.data[key] !== undefined) {\r\n    // 根据哈希表获取该链表节点\r\n    let node = this.data[key]\r\n    // 将该节点放置于链表头部\r\n    this.removeNode(node)\r\n    this.appendHead(node)\r\n    // 返回链表节点的值\r\n    return node.val\r\n  } else {\r\n    return -1\r\n  }\r\n};\r\nLRUCache.prototype.removeNode = function(node) {\r\n  // 删除节点，把node的前一节点的next设为node的next\r\n  let prevNode = node.prev\r\n  let nextNode = node.next\r\n  prevNode.next = nextNode\r\n  nextNode.prev = prevNode\r\n}\r\nLRUCache.prototype.appendHead = function(node) {\r\n  // 插到头节点\r\n  let firstNode = this.head.next\r\n  // 原头节点的next指向node\r\n  this.head.next = node\r\n  // node.prev指向head\r\n  node.prev = this.head\r\n  // node指向原头节点的next\r\n  node.next = firstNode\r\n  // 原头节点的prev指向node\r\n  firstNode.prev = node\r\n}\r\nLRUCache.prototype.removeTail = function() {\r\n  // 删除尾节点\r\n  let prevTail = this.tail.prev\r\n  this.removeNode(prevTail)\r\n  return prevTail.key\r\n}\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node\r\n  if (this.data[key] !== undefined) {\r\n    // 根据哈希表获取该链表节点\r\n    node = this.data[key]\r\n    this.removeNode(node)\r\n    // 将该链表节点的值更新\r\n    node.val = value\r\n  } else {\r\n    // 新生成一个节点\r\n    node = new ListNode(key, value)\r\n    this.data[key] = node\r\n    if (this.capacity < this.size) {\r\n      this.size++\r\n    } else {\r\n      // 容量已满\r\n      // 删除链表尾部的节点\r\n      key = this.removeTail()\r\n      delete this.data[key]\r\n    }\r\n  }\r\n  // 将该节点放置于链表头部\r\n  this.appendHead(node)\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(1)。\r\n* 空间复杂度：O(n)。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846423104","body":"## 104.二叉树的最大深度\r\n\r\n### 思路\r\n* 左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为max(l,r)+1\r\n* 用递归的方法求出l,r\r\n\r\n### 代码 JavaScript\r\n\r\n```javascript\r\nvar maxDepth = function(root) {\r\n  if (!root) return 0\r\n  return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n* 时间复杂度：O(N)，其中 N 为节点数。\r\n* 空间复杂度：O(h),其中 h 为树的深度，最坏的情况 h 等于 N，其中 N 为节点数，此时树退化到链表。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JadeQi":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839516173","body":"\r\n## 题目地址(1381. 设计一个支持增量操作的栈)\r\n\r\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## 题目描述\r\n\r\n```\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 CustomStack ：\r\n\r\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n\r\n \r\n\r\n示例：\r\n\r\n输入：\r\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\r\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\r\n输出：\r\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\r\n解释：\r\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\r\ncustomStack.push(1);                          // 栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\r\ncustomStack.push(2);                          // 栈变为 [1, 2]\r\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\r\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\r\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\r\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\r\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\r\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\r\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\r\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\r\n\r\n\r\n \r\n\r\n提示：\r\n\r\n1 <= maxSize <= 1000\r\n1 <= x <= 1000\r\n1 <= k <= 1000\r\n0 <= val <= 100\r\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\r\n```\r\n\r\n## 前置知识\r\n\r\n-  栈\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    int maxSize;\r\n    int[] stack;\r\n    int index;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        index = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index == maxSize){\r\n            return;\r\n        }\r\n        stack[index++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index == 0){\r\n            return -1;\r\n        }\r\n        return stack[--index];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k,index);\r\n        for(int i = 0; i<k; i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n\r\n- 时间复杂度：push、pop：O(1)， increment：O(k)\r\n- 空间复杂度：O(maxSize)\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840315430","body":"## 思路\r\n- 获取字符/获取倍数.\r\n- 括号内嵌套括号，需要从内向外生成与拼接字符.\r\n\r\n```java\r\nclass Solution394 {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>();\r\n\r\n        // toCharArray: 字符串转换为字符数组\r\n        for (char c : s.toCharArray()) {\r\n            if (c != ']')\r\n                // 把所有的字母push到栈中，除了]\r\n                stack.push(c);\r\n            else {\r\n                // 取出[] 内的字符串\r\n                StringBuilder sb = new StringBuilder();\r\n                // isLetter: 用于判断指定字符是否为字母; 判断取出的顶部对象是否为字母\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    // 在第0位插入出栈的对象\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n\r\n                //[ ]内的字符串\r\n                String sub = sb.toString();\r\n                // 去除[\r\n                stack.pop();\r\n\r\n                // 获取倍数数字\r\n                sb = new StringBuilder();\r\n                // isDigit: 判断指定字符是否为数字;  判断取出的顶部对象是否为数字\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                // 倍数\r\n                int count = Integer.valueOf(sb.toString());\r\n\r\n                // 根据倍数把字母再push回去\r\n                while (count > 0) {\r\n                    for (char ch : sub.toCharArray()) {\r\n                        stack.push(ch);\r\n                    }\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n\r\n        // 把栈里面所有的字母取出来\r\n        StringBuilder retv = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            retv.insert(0, stack.pop());\r\n        }\r\n\r\n        return retv.toString();\r\n    }\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841156694","body":"- 今天走神严重，耐不下心来，看着官方答案写了一波\r\n```java\r\nclass MyQueue {\r\n\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(outStack.isEmpty()){\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    public void in2out(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841663033","body":"- hard还是hard，看着官方题写了下，有些还是不理解\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844218746","body":"- hash表法\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if(headB==null||headB==null){\r\n            return null;\r\n        }\r\n        ListNode tempA=headA;\r\n        ListNode tempB=headB;\r\n        HashSet<ListNode> set=new HashSet<>();\r\n        while(tempA!=null){\r\n            set.add(tempA);\r\n            tempA=tempA.next;\r\n        }\r\n\r\n        while(tempB!=null){\r\n            if(set.contains(tempB)){\r\n                return tempB;\r\n            }\r\n            tempB=tempB.next;\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Bochengwan":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840353737","body":"### 思路\r\n\r\n利用两个stack，一个stack存数字，一个stack存字母，遇到左括号时，把当前的数字入数字栈，当前的字母入字母栈，遇到右括号时，则出栈左括号前的数字，也就是数字栈的栈顶，此数字是当前字符的重复次数，并且与字母栈的栈顶拼接作为当前字符\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        bracket_stack = []\r\n        number_stack = []\r\n        c = ''\r\n        n = ''\r\n        for e in s:\r\n            \r\n            if e.isdigit():\r\n                n+=e\r\n            elif e == '[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n = ''\r\n                c = ''\r\n            elif e == ']':\r\n                \r\n                c = (bracket_stack.pop() + c*int(number_stack.pop()))\r\n            else:\r\n                c += e\r\n        return c\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841936694","body":"### 思路\r\n\r\n利用一个虚拟头结点，然后进行两两交换，直到不能交换为止。\r\n\r\n### 代码\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        \r\n        if not head or not head.next:\r\n            return head\r\n        dummy = ListNode(-1,head)\r\n        \r\n        prev = dummy\r\n        \r\n        while head and head.next:\r\n           \r\n            first, second = head, head.next\r\n            first.next = second.next\r\n            second.next = first\r\n            prev.next = second\r\n            prev = first\r\n            head = first.next\r\n            \r\n            \r\n        return dummy.next\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n（此处撰写代码）\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842850252","body":"### 思路\r\n通过找到链表的中点，把中点左边作为左子树，右边作为右子树，递归解决问题\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        if not head.next:\r\n            return TreeNode(head.val)\r\n        prev = None\r\n        slow = fast = head\r\n        while fast and fast.next:\r\n            prev = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        prev.next = None\r\n        \r\n        return TreeNode(slow.val,self.sortedListToBST(head),self.sortedListToBST(slow.next))\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NLOGN)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843363177","body":"### 思路\r\n和讲义里讲的一样，有两种方法，我这里使用hashset存储节点，遇到重复节点则是相交点\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        node_set = set()\r\n        \r\n        while headA:\r\n            node_set.add(headA)\r\n            headA = headA.next\r\n        while headB:\r\n            if headB in node_set:\r\n                \r\n                return headB\r\n            headB = headB.next\r\n        return None\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N+M)，其中 N，M为两个链表的长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844392893","body":"### 思路\r\n\r\n把traverse的node放入hashset里面，如果出现了重复的，则说明是环形链表的开始的节点。\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head:\r\n            return None\r\n        visited = set()\r\n        while head:\r\n            if head in visited:\r\n                return head\r\n            else:\r\n                visited.add(head)\r\n            head = head.next\r\n            \r\n        return None\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845548015","body":"### 思路\r\n双向链表\r\nget要为o(1)则可以使用hashtable记录pair。如果存在，则需要把此节点移到第一个。\r\nput首先看在不在hasttable里，如果存在，则和get一样更新节点，并移到第一个。如果不存在，则创建新的节点添加到第一个。并检查size,如果size超过了，则删除尾结点。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Node:\r\n    def __init__(self):\r\n        self.key = 0\r\n        self.value = 0\r\n        self.prev = None\r\n        self.next = None\r\n        \r\nclass LRUCache:\r\n    def _add_node(self,node):\r\n        node.next = self.head.next\r\n        node.prev = self.head\r\n        \r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    def _remove_node(self,node):\r\n        prev = node.prev\r\n        new = node.next\r\n        prev.next = new\r\n        new.prev = prev \r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity =capacity\r\n        self.size = 0 \r\n        self.head,self.tail = Node(),Node()\r\n        self.cache={}\r\n        self.head.next,self.tail.prev= self.tail,self.head\r\n        \r\n\r\n    def get(self, key: int) -> int:\r\n        node = self.cache.get(key,None)\r\n        if not node:\r\n            return -1\r\n        self._remove_node(node)\r\n        self._add_node(node)\r\n        return node.value\r\n        \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        curr = self.cache.get(key,None)\r\n        if not curr:\r\n            node = Node()\r\n            node.key = key\r\n            node.value = value\r\n            self.cache[key] = node\r\n            self._add_node(node)\r\n            self.size+=1\r\n        else:\r\n            curr.value = value\r\n            self._remove_node(curr)\r\n            self._add_node(curr)\r\n        \r\n        if self.size > self.capacity:\r\n            the_node  = self.tail.prev\r\n            self._remove_node(the_node)\r\n            \r\n            self.cache.pop(the_node.key)\r\n            self.size-=1\r\n        \r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846304950","body":"### 思路\r\n简单的DFS\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点个数。\r\n- 空间复杂度：O(LogN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846502246","body":"### 思路\r\n\r\n（此处撰写思路）\r\n\r\n### 代码\r\n递归，如果都为null，则为true，若有一个不为null或者val不等的话，则为false，如果都不为null,且值相等，则比较左孩子和有右孩子。\r\n```java（此处换成你的语言，比如js，py 等）\r\n（此处撰写代码）\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为节点数\r\n- 空间复杂度：O(1N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suikataro":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840354871","body":"### 代码\r\n```java\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return s;\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            if (Character.isDigit(s.charAt(idx))) {\r\n                //处理>10的整数\r\n                int count = 0;\r\n                while (Character.isDigit(s.charAt(idx))) {\r\n                    count = count * 10 + (s.charAt(idx) - '0');\r\n                    idx++;\r\n                }\r\n                countStack.push(count);\r\n            } else if (s.charAt(idx) == '[') {\r\n                resStack.push(res);\r\n                res = \"\";\r\n                idx++;\r\n            } else if (s.charAt(idx) == ']') {\r\n                StringBuilder temp = new StringBuilder(resStack.pop());\r\n                int time = countStack.pop();\r\n                for (int i = 0; i < time; i++) {\r\n                    temp.append(res);\r\n                }\r\n                res = temp.toString();\r\n                idx++;\r\n            } else {\r\n                //字母\r\n                res += s.charAt(idx++);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843759953","body":"### 思路分析\r\n各自从开头出发，到终点的时候交换到另一个链表的开头出发，直到两者相遇\r\n\r\n### 代码\r\n```Java\r\n    public ListNode getIntersectionNode2(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) return null;\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while (a != b) {\r\n            a = a == null ? headB : a.next;\r\n            b = b == null ? headA : b.next;\r\n        }\r\n        return a;\r\n    }\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846526125","body":"### 思路\r\n传入两个节点，树的问题一定要考虑节点是不是空\r\n1. 都不为空，比较值\r\n    1.1 这里只要处理不相等的情况即可，相等的情况下会一值递归到两个节点都为空\r\n2. 都为空，相等\r\n3. 只有一个为空，错误\r\n\r\n子节点分治比较\r\n### 代码\r\n```Java\r\n    public static boolean isSameTree(TreeNode p, TreeNode q) {\r\n\r\n        if (p == null && q == null) return true;\r\n        if (p == null || q == null) return false;\r\n        if (p.val != q.val) return false;\r\n\r\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n    }\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"YuetongYu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840365976","body":"思路： 正则判断解决。\r\n\r\n```js\r\nlet reg = /(\\d+)\\[([a-zA-Z]+)\\]/g;\r\n    while(s.indexOf('[')>0){\r\n        s = s.replace(reg,(_,...[num,str])=>{\r\n            let result = \"\";\r\n            for(let i=0;i<num-0;i++){\r\n                result += str;\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    return s;\r\n```\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840941830","body":"太简单了。。。不多解释\r\n\r\n```js\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !Boolean(this.stack.length)\r\n};\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842023256","body":"## 思路\r\n\r\n两种解法，递归 & 迭代。\r\n\r\n### 递归\r\n\r\n递归解法套用公式三步走：\r\n\r\n1. 单元执行返回什么：*返回两两交换后的节点。*\r\n2. 单元如何执行： *额外空间保存node2, node1 -> node2.next，node2 -> node1*。\r\n3. 终止条件：*不满足**存在当前节点&下一个节点***。\r\n\r\n```js\r\nfunction swapPairs(head) {\r\n  if (head || head.next) {\r\n    const nextNode = head.next;\r\n    head.next = swapPairs(nextNode.next);\r\n    nextNode.next = head;\r\n    return nextNode;\r\n  }\r\n  return head;\r\n}\r\n```\r\n\r\n### 迭代\r\n\r\n先创建一个`dummy`节点，然后用`temp`指针遍历链表，实现两两反转即可。\r\n\r\n```js\r\nfunction swapPairs(head) {\r\n  const dummy = new ListNode();\r\n  dummy.next = head;\r\n  let temp = dummy;\r\n  if (temp.next && temp.next.next) {\r\n    const node1 = temp.next;\r\n    const node2 = temp.next.next;\r\n    temp.next = node2;\r\n    node1.next = node2.next;\r\n    node2.next = node1;\r\n    temp = node1;\r\n  }\r\n  return dummy.next;\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842771429","body":"## 109. 有序链表转换二叉搜索树\r\n\r\n### 分治递归：\r\n\r\n因为是一个有序单链表，则可以先找到链表的中间节点。\r\n\r\n以中间节点形成“抓手”，“赋能”新二叉树，打通递归“闭环”，“沉淀”结果返回树，形成一套“组合拳”。\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  var getMid = function (left, right) {\r\n\t\tlet fast = slow = left;\r\n    while (fast !== right && fast.next !== right) {\r\n      fast = fast.next.next;\r\n      slow = slow.next;\r\n    }\r\n    return slow\r\n  }\r\n  var buildBST = function (left, right) {\r\n    const middleNode = getMid(left, right);\r\n    const root = new ListNode(middleNode.val);\r\n    root.left = buildBST(left, middleNode);\r\n    root.right = buildBST(middleNode.next, right);\r\n    return root\r\n  }\r\n  return buildBST(head, null);\r\n}\r\n```\r\n\r\n也可以将有序单链表转换为有序数组解决，参考108。\r\n\r\n### 中序遍历\r\n\r\n简化了链表中的求mid节点的过程，时间复杂度O(N)。\r\n\r\n```js\r\nvar sortedListToBST = function (head) {\r\n  if (!head) return null\r\n  let len = 0;\r\n\tlet h = head;\r\n  while(head) {\r\n    len ++;\r\n    head = head.next;\r\n  }\r\n  var buildBST = function (start, end) {\r\n\t  if (start > end) return null;\r\n    const mid = (start + end) >>> 1;\r\n    const left = buildBST(start, mid - 1);\r\n    const root = new ListNode(h.val);\r\n    root.left = left;\r\n\t\th = h.next;\r\n    root.right = buildBST(mid + 1, end);\r\n    return root\r\n  }\r\n  return buildBST(0, len - 1);\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843643719","body":"## 160. 相交链表\r\n\r\n### 思路\r\n\r\n暴力法就不说了，两种解法：*哈希表*和*双指针*。\r\n\r\n>  今天比较简单就直接上代码了\r\n\r\n### 哈希表\r\n\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  if (!headA || !headB) return null\r\n  const map = new Map();\r\n  let cur = headA;\r\n  // iterate a\r\n  while(cur) {\r\n    map.set(cur, 1);\r\n    cur = cur.next;\r\n  }\r\n  cur = headB;\r\n  while(cur) {\r\n    if (map.has(cur)) return cur\r\n    cur = cur.next;\r\n  }\r\n  return cur;\r\n}\r\n```\r\n\r\n### 双指针 - AKA指针都有对象了反思一下你自己？\r\n\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  if (!headA || !headB) return null\r\n  let p1 = headA;\r\n  let p2 = headB;\r\n  while(p1 !== p2) {\r\n    p1 = p1 ? p1.next : headB;\r\n    p2 = p2 ? p2.next : headA;\r\n  }\r\n  return p1;\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844608671","body":"## 142. 环形链表 II\r\n\r\n比较容易想到的是，用哈希表来解决。\r\n\r\n### HashSet\r\n\r\n```js\r\nvar detectCycle = function (head) {\r\n  const map = new Map();\r\n  while(head) {\r\n    if (map.has(head)) {\r\n      return head\r\n    }\r\n    head = head.next\r\n  }\r\n  return null\r\n}\r\n```\r\n\r\n这种解法简单直观易懂，但是借助了额外的内存结构，虽然速度会快一些，但算不得较优的解法。\r\n\r\n### 快慢指针\r\n\r\n我们设定一对快慢指针，当这个单链表存在环的时候，快慢指针一定是在环内相遇的。且利用数学上的证明可以得到，当**两指针相遇的时候，链表起点距离环入口点的距离，刚好为慢指针离环入口点的距离的整数倍**。也就意味着，我们此时再设定一个起点指针，与慢指针同步出发。当这两个指针相遇的时候，一定会相遇在环的入口点。\r\n\r\n```js\r\nvar detectCycle = function (head) {\r\n  if (!head) return null;\r\n  let fast = slow = head;\r\n  while(fast && fast.next) {\r\n    fast = fast.next.next;\r\n    slow = slow.next;\r\n    if (fast === slow) {\r\n      let cur = head;\r\n      while(cur !== slow) {\r\n        cur = cur.next;\r\n        slow = slow.next;\r\n      }\r\n      // cur 和 slow 一定会相遇\r\n      return cur\r\n    }\r\n  }\r\n  return null\r\n}\r\n```\r\n\r\n### 作弊法\r\n\r\n利用 JS 中 ListNode 是一个对象的特性，挂载一个新的属性。\r\n\r\n```js\r\nvar detectCycle = function (head) {\r\n  while(head) {\r\n    if (head.flag) return head;\r\n    head.flag = 1;\r\n    head = head.next;\r\n  }\r\n  return null;\r\n}\r\n```\r\n\r\n*但其实这种做法也挂载了N个属性，空间复杂度依然是O(N)*。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845620969","body":"## 146. LRU缓存机制\r\n\r\n### 思路：\r\n\r\n题目要求使用时间复杂度O(1)的方法解决。因为LRU的思路中，同时涉及到查找删除和插入。\r\n\r\n不难想到，双链表的删除插入的时间复杂度为O(1)，但查找复杂度为O(N)。因此，我们额外引入一个*哈希表*，作为查找的映射。这样，二者结合的时间复杂度可以降到O(1)。\r\n\r\n```js\r\nvar ListNode = function (key, value) {\r\n  this.key = key;\r\n  this.value = value;\r\n  this.prev = null;\r\n  this.next = null;\r\n}\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n  this.cache = {};\r\n  this.capacity = capacity;\r\n  this.count = 0;\r\n  this.dummyHead = new ListNode();\r\n  this.dummyTail = new ListNode();\r\n  this.dummyHead.next = this.dummyTail;\r\n  this.dummyTail.prev = this.dummyHead;\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  const node = this.cache(key);\r\n  if (node) {\r\n    this.moveToHead(node);\r\n    return node.value;\r\n  } else {\r\n    return -1\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  const node = this.cache[key];\r\n  if (node) {\r\n    // 已经存在这个节点，更新节点的值并移动到最前面；\r\n    node.value = value;\r\n    this.moveToHead(node);\r\n  } else {\r\n    // 没有这个节点\r\n    if (this.count === this.capacity) {\r\n      // 容量满了，移除链表最后的节点。\r\n      this.removeListTail();\r\n      this.count --;\r\n    }\r\n    const newNode = new ListNode(key, value); // 生成一个新的节点；\r\n    this.cache[key] = newNode;\r\n    this.moveToHead(newNode);\r\n    this.count++;\r\n  }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n/**\r\n * @param {node} 调用moveToHead的时候确保node节点是存在的\r\n */\r\nLRUCache.prototype.moveToHead = function (node) {\r\n  this.deleteNodeFromList(node); // 先从现有链表中删除\r\n  const firstNode = this.dummyHead.next;\r\n  node.next = firstNode;\r\n  node.prev = this.dummyHead;\r\n  firstNode.prev = node;\r\n  this.dummyHead.next = node;\r\n}\r\n\r\n/**\r\n * 删除某个链表中的某个节点\r\n * @param {node}\r\n */\r\nLRUCache.prototype.deleteNodeFromList = function (node) {\r\n//   if (node.prev === null && node.next === null) throw Error(\"Can not delete a individual node.\");\r\n  let prev = node.prev;\r\n  let next = node.next;\r\n  prev.next = next;\r\n  next.prev = prev;\r\n}\r\n\r\n/**\r\n * 删除链表中的最后一个节点\r\n */\r\nLRUCache.prototype.removeListTail = function () {\r\n  if (!this.count) throw Error(\"Can not execute this operation to a empty list.\");\r\n  const lastNode = this.dummyTail.prev;\r\n  lastNode.prev.next = this.dummyTail;\r\n  this.dummyTail.prev = lastNode.prev;\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846419220","body":"## 104. 二叉树的最大深度\r\n\r\n### DFS\r\n\r\n递归就完事儿了。\r\n\r\n```js\r\nvar maxDepth = function (root) {\r\n  if (!root) return 0\r\n  const left = root.left;\r\n  const right = root.right;\r\n  return Math.max(maxDepth(left), maxDepth(right)) + 1\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846494949","body":"## 100. 相同的树\r\n\r\n树类型的经典题目：\r\n\r\n### DFS\r\n\r\n```js\r\nvar isSameTree = function (p, q) {\r\n  if (!p && !q) return true\r\n  if (!p || !q) return false\r\n  if (p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n}\r\n```\r\n> BFS就不写了..."},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"CelesteXiong":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839827285","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else: return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        least = min(len(self.stack), k)\r\n        for i in range(least):\r\n            self.stack[i] += val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840503799","body":"#### 思路\r\n需要由内而外读取括号，因此使用栈先进后出的特性\r\n#### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 看题解做的\r\n        stack = []\r\n        multi = 0\r\n        ans = \"\"\r\n        res = \"\"\r\n        for c in s:\r\n            if '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, ans])\r\n                multi = 0\r\n                ans = \"\"\r\n            elif c == ']':\r\n                last = stack.pop()\r\n                last_multi = last[0]\r\n                last_ans = last[1]\r\n                ans = last_ans + last_multi * ans \r\n            else:\r\n                ans += c\r\n        return ans\r\n\r\n```\r\n#### 复杂度\r\n时间复杂度O(N)：需要遍历一遍`s`\r\n空间复杂度O(N)：最坏的情况下需要线性空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841330775","body":"### 思路\r\n1. 使用数组模拟栈，可以使用数组的push和pop操作实现栈的先进后出的特性。\r\n2. 使用两个数组模拟一个队列，一个栈用于存储push的内容，每次pop时，讲该栈的数据pop到第二个栈，再pop第二个栈的内容。\r\n\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1, self.s2 = [], []\r\n        \r\n\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if len(self.s1) or len(self.s2): \r\n            print (self.s1, self.s2)\r\n            return False\r\n        else: \r\n            print (self.s1, self.s2)\r\n            return True\r\n        \r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n### 复杂度分析\r\n假设数组长度为n。\r\n时间复杂度：push() 时间复杂度是 O(1)；peek()/pop() 均摊时间复杂度是 O(1)，单步操作的最坏时间复杂度是 O(N)O(N)。\r\n空间复杂度：空间复杂度是O(N)，因为两个栈和数组长度相同。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841658286","body":"## 思路\r\n借用栈先进后出的特性，按照自小而大的顺序，保留能排序的所有块中的最大值。如果当前数字超过栈顶，则存储栈顶，一直pop到当前比当前数字小的栈顶，再将保留的栈顶入栈，以栈中的个数作为能排序的块的个数。\r\n\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        head = None\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```\r\n## 复杂度\r\n时间复杂度：O(n), 遍历一边数组\r\n空间复杂度：O(n), 线性增长的空间"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846341559","body":"## 思路\r\n给定一个二叉树t，它的最大深度是左子树l和右子树r的最大深度中的较大值加一，针对左子树和右子树，同样进行递归处理。递归的终止条件是访问到空节点，此时返回深度0。\r\n## 代码\r\n```python\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        left = self.maxDepth(root.left)\r\n        right = self.maxDepth(root.right)\r\n        return max(left, right) + 1\r\n```\r\n## 复杂度\r\n时间复杂度：O(n)，每个节点在递归中被遍历一次\r\n空间复杂度：O(logn)，logn表示树的高度，递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flashyy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840507326","body":"- 思路：\r\n   需要由子问题组合得到原问题，把每一层需要叠加的字母(res)和叠加的次数(multi)记录下来，加到原字符串上，迭代字符串：\r\n1. 遇到数字的时候，将其转化为整数（multi）记录下来，用于后序计算\r\n2. 遇到字母的时候，将该字符串加入当前字符串后面\r\n3. 遇到左括号时候，将需要叠加的字母(res)和叠加的次数(multi)记录下来并放入栈中\r\n4.遇到右括号时候弹出字符串，将字符串组合起来  \r\n```\r\nvar decodeString = function(s) {\r\n     let res=\"\",multi=0,stack=[];\r\n     for(let char of s){\r\n         if(!isNaN(char)){\r\n             multi = multi*10+parseInt(char);\r\n         }\r\n         else if(char === \"[\"){\r\n             stack.push([multi,res]);\r\n             res = \"\";\r\n             multi = 0;\r\n         }\r\n         else if(char === \"]\"){\r\n             let [multi,str] = stack.pop();\r\n             res = str+res.repeat(multi);\r\n         }  \r\n         else{\r\n            res +=char;\r\n         }\r\n     }\r\n     return res;\r\n};\r\n```\r\n- 复杂度：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsj":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840571999","body":" var decodeString = function (s) {\r\n        const isNum = n=>n>='1'&&n<='9'\r\n        const size = s.length \r\n        let stack = []\r\n        for(let i=0;i<size;i++){\r\n            const item = s.charAt(i)\r\n            if(item === '['){\r\n                stack.push('')\r\n                continue\r\n            }\r\n            if(item === ']'){\r\n                let popItem = stack[stack.length - 1]\r\n                const numVal = stack[stack.length - 2]\r\n                const popNum = parseInt(numVal)\r\n                let str = ''\r\n                if(popItem.length){\r\n                    for(let n = 0;n<popNum;n++){\r\n                        str+=popItem\r\n                    }\r\n                }\r\n                if(stack.length){\r\n                    stack.pop()\r\n                    stack.pop()\r\n                    if(stack.length){\r\n                        stack[stack.length - 1] += str\r\n                    }else{\r\n                        stack.push(str)\r\n                    }\r\n                }\r\n                continue\r\n            }\r\n            if(isNum(item)){\r\n                if(isNum(stack[stack.length - 1])){\r\n                    stack[stack.length - 1] += item\r\n                    continue\r\n                }\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            if(!stack.length){\r\n                stack.push(item)\r\n                continue\r\n            }\r\n            stack[stack.length - 1] +=item\r\n        }\r\n        return stack.join('')\r\n    }\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843713874","body":"var getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA;\r\n    while (pA) {\r\n        let pB = headB;\r\n\r\n        while (pB) {\r\n            if (pA === pB) return pA;\r\n            pB = pB.next;\r\n        }\r\n\r\n        pA = pA.next;\r\n    }\r\n}\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jueran":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840575047","body":"思路：\r\n使用两个栈，一个栈存储数字，一个栈存字母；\r\n代码\r\n\r\n```\r\nclass Solution:\r\n    def decodeString(s:str)->str:\r\n        bracket_stack=[]\r\n        number_stack=[]\r\n        c=''\r\n        n=''\r\n        for e in s:\r\n            if e.isdigit():\r\n                n+=e\r\n            elif e=='[':\r\n                bracket_stack.append(c)\r\n                number_stack.append(n)\r\n                n=''\r\n                c=''\r\n            elif e==']':\r\n                c=(bracket_stack.pop()+c*int(number_stack.pop()))\r\n            else:\r\n                c+=e\r\n        return c\r\n```\r\n\r\n复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841258649","body":"思路\r\n使用两个数组模拟栈操作。\r\n1.在pop时候，需要先将所有元素拿出来放到辅助栈，然后pop栈顶的元素\r\n2.如果辅助栈不为空，直接返回pop辅助栈的栈顶元素即可。\r\n```\r\nclass MQueue:\r\n    def __init__(self) :\r\n        self.stack=[]\r\n        self.assit=[]\r\n\r\n    def push(self,x:int)->None:\r\n        self.stack.append(x)\r\n\r\n    def pop(self)->int:\r\n        if not self.assit:\r\n            while self.stack:\r\n                self.assit.append(self.stack.pop())\r\n        return self.assit.pop()\r\n\r\n    def peek(self)->int:\r\n        if not self.assit:return self.stack[0]\r\n        else: return self.assit[-1]\r\n\r\n    def empty(self)->bool:\r\n        return True if not self.stack and not self.assit else False\r\n```\r\n时间复杂度（pop/push/peek）：均为O(1)\r\n空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841666803","body":"思路\r\n使用一个辅助数组\r\n1.使用循环依次取值。\r\n2.只要左边的最大值小于值就可以多分一个模块，就把该值入数组，窗口往右滑动，继续对比\r\n3.如果左边的最大值大于值，则出栈辅助数组元素，直到找到比值大的。窗口往右滑动，继续对比\r\n4循环结束，返回辅助数组的大小。\r\n\r\npython：\r\n```\r\nclass ClassName:\r\n    def maxChunksToSorted(s:str)->str:\r\n        queue=[]\r\n        for i in range(len(s)):\r\n            if len(queue)==0 or queue[len(queue)-1]<=str[i]:\r\n                queue.push(str[i])\r\n            else:\r\n                temp=queue.pop()\r\n                while queue[len[queue]-1]>str[i]:\r\n                    queue.pop()\r\n                queue.push(temp)\r\n        return len(queue)\r\n```\r\n时间复杂度 O(n)\r\n控件复杂度 O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842380001","body":"思路\r\n\r\n创建一个头结点来辅助解题，再创建一个指针指向头结点（该指针是把链表连起来用的），然后按照1指向3、2指向1完成交换，指针也下移两位，一直循环，直到刚好交换完或者剩下一个结点时候结束循环，完成交换\r\n```\r\nclass ListNode:\r\n    def __init__(self,val=0,next=None):\r\n        self.val=val\r\n        self.next=next\r\n\r\nclass Solution:\r\n    def swipPairs(self,head:ListNode)->ListNode:\r\n        new_head=ListNode(-1,None)\r\n        cur=new_head\r\n        cur.next=head\r\n\r\n        while head and head.next:\r\n            cur.next=head.next\r\n\r\n            head.next=head.next.next\r\n            cur.next.next=head\r\n\r\n            cur=head\r\n            head=head.next\r\n\r\n        return new_head.next\r\n        \r\nif __name__ == '__main__':\r\n    a=ListNode(4,None)\r\n    b=ListNode(3,a)\r\n    c=ListNode(2,b)\r\n    d=ListNode(4,c)\r\n    result=Solution().swipPairs(d)\r\n    print(result.val)\r\n```\r\n时间复杂度 O(n)\r\n控件复杂度 O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843192948","body":"思路\r\n1.快慢指针\r\n2.递归\r\n```\r\nclass ListNode:\r\n    def __init__(self,val=0,next=None):\r\n        self.val=val\r\n        self.next=next\r\n\r\nclass TreeNode:\r\n    def __init__(self,val=0,left=None,right=None):\r\n        self.val=val\r\n        self.left=left\r\n        self.right=right\r\n\r\nclass Solution:\r\n    def sortedListToBSDT(self,head:ListNode)->TreeNode:\r\n        #base case 1:null node\r\n        if not head:\r\n            return\r\n        #base case 2:only one node\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n        else:\r\n            #slow and fast pointers\r\n            fast,slow=head.next.next,head\r\n\r\n            #find middle node\r\n            while fast and fast.next:\r\n                fast=fast.next.next\r\n                slow=slow.next\r\n            mid=slow.next\r\n\r\n            #cut off the middle node and the rest of the listNodes\r\n            slow.next=None\r\n\r\n            #the middle node as the root for the current tree\r\n            root=TreeNode(mid.val)\r\n\r\n            #left subtree recursion\r\n            root.left=self.sortedListToBSDT(head)\r\n\r\n            #right subtree recursion\r\n            root.right=self.sortedListToBSDT(mid.next)\r\n\r\n            return root \r\n\r\nif __name__ == '__main__':\r\n    a=ListNode(9,None)\r\n    b=ListNode(5,a)\r\n    c=ListNode(0,b)\r\n    d=ListNode(-3,c)\r\n    e=ListNode(-10,d)\r\n    result=Solution().sortedListToBSDT(e)\r\n    print(result.left.val)\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(logN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844139023","body":"思路\r\n1.如果A,B相交的话A和B有一段尾巴是相同的，所以两个遍历的指针一定会同时到达交点 \r\n2.如果A,B不相交的话两个指针就会同时到达A+B（B+A）的尾节点\r\n```\r\nclass ListNode:\r\n    def __init__(self,val=0,next=None):\r\n        self.val=val\r\n        self.next=next\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self,headA:ListNode,headB:ListNode):\r\n        ha,hb=headA,headB\r\n        while ha!=hb:\r\n            ha=ha.next if ha else headB\r\n            hb=hb.next if hb else headA\r\n        return ha\r\n\r\nif __name__ == '__main__':\r\n    e=ListNode(-10,None)\r\n    c=ListNode(0,e)\r\n    d=ListNode(-3,c)\r\n    b=ListNode(5,c)\r\n    a=ListNode(9,b)\r\n\r\n    result=Solution().getIntersectionNode(a,d)\r\n    print(result.val)\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845181364","body":"思路\r\n快慢指针\r\n```\r\nclass ListNode:\r\n    def __init__(self,val=0,next=None):\r\n        self.val=val\r\n        self.next=next\r\n\r\nclass Solutions:\r\n    def detectCycle(head:ListNode)->ListNode:\r\n        if not head:\r\n            return None\r\n        slow,fast=head,head\r\n        while not fast:\r\n            slow=slow.next\r\n            if not fast.next:\r\n                fast=fast.next.next\r\n            else:\r\n                return None\r\n            if(fast==slow):\r\n                ptr=head\r\n                while not ptr:\r\n                    ptr=ptr.next\r\n                    slow=slow.next\r\n                return ptr\r\n\r\n        return None\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Dark-volute":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840590769","body":"### 思路\r\n我们可以利用 stack 来实现这个操作，遍历这个字符串 s，判断每一个字符的类型：\r\n\r\n如果是字母 --> 添加到 stack 当中\r\n如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n如果是 [ --> 说明重复字符串开始 --> 将数字入栈 --> 并且将数字清零\r\n如果是 ] --> 说明重复字符串结束 --> 将重复字符串重复前一步储存的数字遍\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let strStack = []\r\n    let numStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i< s.length; i++) {\r\n        // 如果是次数\r\n        if (!isNaN(s[i])) {\r\n            // 处理二位及以上次数\r\n            num = num * 10 + +s[i]\r\n        } else if (s[i] === '[') {\r\n            numStack.push(num)\r\n            strStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']'){\r\n            let repeatTimes = numStack.pop() // 获取拷贝次数\r\n            str = strStack.pop() + str.repeat(repeatTimes) \r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。 空间复杂度：$O(N)$，其中 N 为解码后的 s 的长度。"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841808005","body":"### 思路\r\n获取单链表的倒数第N + 1 与倒数第N个节点\r\n将倒数第N + 1个节点的next指向null\r\n将链表尾节点的next指向head\r\n返回倒数第N个节点\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next) return head\r\n    let count = 0, now = head\r\n    while(now){\r\n        now = now.next\r\n        count++\r\n    }\r\n    k = k % count\r\n    let fast = head, slow = head;\r\n    while (fast.next) {\r\n        if (k-- <= 0) {\r\n            slow = slow.next\r\n        }\r\n        fast = fast.next\r\n    }\r\n    fast.next = head\r\n    let res = slow.next\r\n    slow.next = null\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(N)$ 空间复杂度：$O(1)$"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Peg-008":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840594683","body":"字符内所有类型分别为:[  ]  数字   字母四种   数字和字母分别用一个栈存储  用 [ ] 作为入栈 出栈的条件 \r\n\r\n``` java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || \"\".equals(s)){\r\n            return null;\r\n        }\r\n        //数字栈\r\n        Stack<Integer> numStack = new Stack<>();\r\n        //字母栈\r\n        Stack<String> strStack = new Stack<>();\r\n        char[] chars = s.toCharArray();\r\n        int num = 0;\r\n        for(char c : chars){\r\n            if(isNum(c + \"\")){\r\n                num = num * 10 + c - '0';\r\n            } else if(c == '['){\r\n                strStack.push(c + \"\");\r\n                numStack.push(num);\r\n                num = 0;\r\n            } else if(c == ']'){ \r\n                int number = numStack.pop(); \r\n               String str = \"\";\r\n                while(!strStack.peek().equals(\"[\")){\r\n                    str = strStack.pop() + str;\r\n                }\r\n                strStack.pop();\r\n                strStack.push(getMultiWord(str, number));\r\n            } else {\r\n                strStack.push(c + \"\");\r\n            }\r\n        }\r\n        String res = \"\";\r\n        while(! strStack.isEmpty()){\r\n            res = strStack.pop() + res;\r\n        }\r\n        return res;\r\n    }\r\n    public static boolean isNum(String str) {\r\n        String regex = \"^[0-9]+$\";\r\n        return str.matches(regex);\r\n    }\r\n\r\n    private static String getMultiWord(String s, int num){\r\n        StringBuilder sb = new StringBuilder();\r\n        for (int i = 0 ;i < num; i ++){\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843879020","body":"双指针\r\n\r\n```java\r\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n\r\n        if (headA == null || headB == null){\r\n              return null;\r\n        }\r\n\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n\r\n        while (pA != pB) {\r\n\r\n            pA = pA != null ? pA.next : headB;\r\n            pB = pB != null ? pB.next : headA;\r\n        }\r\n        return pA;\r\n    }\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zibinanhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840626495","body":"\r\n## 题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 题目描述\r\n\r\n```\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\r\n\r\n \r\n\r\n示例 1：\r\n\r\n输入：s = \"3[a]2[bc]\"\r\n输出：\"aaabcbc\"\r\n\r\n\r\n示例 2：\r\n\r\n输入：s = \"3[a2[c]]\"\r\n输出：\"accaccacc\"\r\n\r\n\r\n示例 3：\r\n\r\n输入：s = \"2[abc]3[cd]ef\"\r\n输出：\"abcabccdcdcdef\"\r\n\r\n\r\n示例 4：\r\n\r\n输入：s = \"abc3[cd]xyz\"\r\n输出：\"abccdcdcdxyz\"\r\n\r\n```\r\n\r\n## 前置知识\r\n\r\n- \r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n用一个栈来解决\r\n\r\n## 关键点\r\nwhile循环把[]里面的字符串读出来\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        int len = s.length();\r\n        if(len <= 0) {\r\n            return \"\";\r\n        }\r\n        Stack<String> stack = new Stack<>();\r\n        for(int i=0; i<len; i++){\r\n            char mid=s.charAt(i);\r\n            if(mid==']'){\r\n                StringBuilder tmp = new StringBuilder();\r\n                while(!stack.peek().equals(\"[\")){\r\n                    tmp.insert(0,stack.pop());\r\n                }\r\n                stack.pop();\r\n                StringBuilder num=new StringBuilder();\r\n                while(!stack.isEmpty() && (stack.peek().charAt(0) >= '0' \r\n                && stack.peek().charAt(0)<='9')){\r\n                    num.insert(0,stack.pop());\r\n                }\r\n                int number=Integer.parseInt(num.toString());\r\n                StringBuilder sb = new StringBuilder();\r\n                for(int j = 0; j < number; j++){\r\n                    sb.append(tmp);\r\n                }\r\n                stack.push(sb.toString());\r\n            }else{\r\n                StringBuilder sb = new StringBuilder();\r\n                sb.insert(0,mid);\r\n                stack.push(sb.toString());\r\n            }\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            res.insert(0,stack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844230491","body":"\r\n## 题目地址(160. 相交链表)\r\n\r\nhttps://leetcode-cn.com/problems/intersection-of-two-linked-lists/\r\n\r\n## 题目描述\r\n\r\n```\r\n编写一个程序，找到两个单链表相交的起始节点。\r\n\r\n\r\n## 公司\r\n\r\n- 暂无\r\n\r\n## 思路\r\n两个链表如果相交，那从相交到结尾的路程一定是相同的，但是单向链表不能从结尾开始遍历，所以\r\na + b = b + a\r\n每个链表遍历到链表尾部的时候，去遍历另一个链表，这样就可以保证两个链表是同时到达对方的尾部\r\n如果相交，就一定会在中间同时遍历到\r\n## 关键点\r\n\r\n- \r\n循环的中止条件为headA != headB\r\n内部可以用三元表达式来同步遍历，如果没有相交，最后两个链表都会遍历到Null,退出循环\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode tmpA = headA;\r\n        ListNode tmpB = headB;\r\n        while(headA != headB) {\r\n            headA = headA == null ? tmpB : headA.next;\r\n            headB = headB == null ? tmpA : headB.next;\r\n        }\r\n        return headA;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wu529778790":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840627651","body":"```\r\nvar decodeString = function(s) {\r\n    let mulStack = [], strStack = [], num = 0, res = ''\r\n    for (const c of s) {   \r\n        if (!isNaN(c)) {  \r\n            num = num * 10 + (c - '0')\r\n        } else if (c == '[') {  \r\n            strStack.push(res)\r\n            mulStack.push(num) \r\n            res = '' \r\n            num = 0\r\n        } else if (c == ']') {  \r\n            res = strStack.pop() + res.repeat(mulStack.pop())\r\n        } else {                   \r\n            res += c\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841291124","body":"```\r\nvar MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841660038","body":"想了30分钟总结不出规律，看楼上的评论……\r\n\r\n在数组任意位置i,如果[0...i]的最大值，比[i+1..len-1]的最小值要小，那么就可以算作一个“块”。否则的话，排序的时候从右侧必须要换到左侧来，根据题目要求就不能算作一个块。\r\n根据上述规律，对于数组的任意位置i，先计算[0...i]的最大值max，再计算[i+1...len-1]的最小值min，如果max[i] <= min[i+1]，就可以分出一个“块”。\r\n边界条件是任何数组至少会有一个块。\r\n```\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841825813","body":"```\r\n\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !head.next || !k) return head;\r\n    let len = 1, cur = head;\r\n    while(cur.next){\r\n        cur = cur.next;\r\n        len++;\r\n    }\r\n    let move = len - k % len;\r\n    cur.next = head;\r\n    while(move){\r\n        cur = cur.next;\r\n        move--;\r\n    }\r\n    let ans = cur.next;\r\n    cur.next = null;\r\n    return ans;\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842299079","body":"```\r\nconst swapPairs = (head) => {\r\n  const dummy = new ListNode(0);\r\n  dummy.next = head;\r\n  let prev = dummy;\r\n\r\n  while (head && head.next) {\r\n    const next = head.next; // 临时保存head.next，因为head.next待会要改变\r\n    head.next = next.next;\r\n    next.next = head;\r\n    prev.next = next;  \r\n\r\n    prev = head;      // 指针更新\r\n    head = head.next; // 指针更新\r\n  }\r\n  return dummy.next;\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843925314","body":"```\r\nvar getIntersectionNode = function (headA, headB) {\r\n    if (!headA || !headB) return null;\r\n\r\n    let pA = headA,\r\n        pB = headB;\r\n    while (pA !== pB) {\r\n        pA = pA === null ? headB : pA.next;\r\n        pB = pB === null ? headA : pB.next;\r\n    }\r\n    return pA;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845035793","body":"```\r\nvar detectCycle = function(head) {\r\n    const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845786041","body":"```\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function(capacity) {\r\n    this.capacity = capacity;\r\n    this.map = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n    let value = this.map.get(key)\r\n    if(value === undefined){\r\n        return -1;\r\n    }\r\n    this.map.delete(key);\r\n    this.map.set(key, value);\r\n    return value;\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n    if(this.map.has(key)){\r\n        this.map.delete(key);\r\n    }\r\n    this.map.set(key,value);\r\n    if(this.map.size > this.capacity){\r\n        let keyIterator = this.map.keys();\r\n        this.map.delete(keyIterator.next().value);\r\n    }\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"scarydemon2":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840634618","body":"## 递归\r\n```\r\n\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        res=\"\"\r\n        s=list(s)\r\n        index=0\r\n        stack=[]\r\n        current_num=0\r\n        while index<len(s):\r\n            if ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                num_start=index\r\n                index+=1\r\n                while ord(s[index])<=ord('9') and ord(s[index])>=ord('0'):\r\n                    index+=1\r\n                current_num=int(\"\".join(s[num_start:index]))\r\n                continue\r\n            elif s[index]=='[':\r\n                stack.append('[')\r\n                left=index+1\r\n                while stack!=[]:\r\n                    index += 1\r\n                    if s[index]=='[':\r\n                        stack.append('[')\r\n                        continue\r\n                    if s[index]==']':\r\n                        stack.pop(-1)\r\n                        right=index\r\n                        continue\r\n                tmp=self.decodeString(\"\".join(s[left:right]))\r\n                if current_num!=0:\r\n                    for i in range(current_num):\r\n                        res+=tmp\r\n                    current_num=0\r\n            elif s[index]==']':\r\n                index+=1\r\n                continue\r\n            else:\r\n                res+=s[index]\r\n                index+=1\r\n        return res\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841280030","body":"’‘’\r\n\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.s1=[]\r\n        self.s2=[]\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.s1.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.s2)!=0:\r\n            return self.s2.pop()\r\n        else:\r\n            while self.s1!=[]:\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2.pop()\r\n    def peek(self):\r\n        \"\"\"\r\n        Get the front element.\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        if len(self.s2) != 0:\r\n            return self.s2[-1]\r\n        else:\r\n            while self.s1 != []:\r\n                self.s2.append(self.s1.pop())\r\n            return self.s2[-1]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        :rtype: bool\r\n        \"\"\"\r\n        return self.s1==[] and self.s2==[]\r\n\r\n‘’‘"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841618612","body":"从右到左先遍历得到从右边到当前位置的最小值。记为r2l\r\n然后从左到右遍历，对于当前块，维护一个当前块的最大值，如果这个最大值比下个位置的r2l值小（或者等于），那么可以在该位置分块，时间空间都是On\r\n\r\n’‘’\r\n\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        res=0\r\n        if len(arr)==0:\r\n            return 0\r\n        r2l=[arr[-1]]\r\n        last_min=arr[-1]\r\n        for i in range(len(arr)-2,-1,-1):\r\n            if arr[i]<last_min:\r\n                r2l=[arr[i]]+r2l\r\n                last_min=arr[i]\r\n            else:\r\n                r2l=[last_min]+r2l\r\n        current_max=-float('inf')\r\n        for i in range(len(arr)-1):\r\n            if arr[i]>current_max:\r\n                current_max=arr[i]\r\n            if current_max <= r2l[i + 1]:\r\n                res += 1\r\n        return res+1\r\n\r\n‘’‘"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841757487","body":"先找到倒数底k个节点，然后摘下来，放到链表头部\r\n\r\n’‘’\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        if head==None or head.next==None:\r\n            return head\r\n        tmp_head=head\r\n        p=head\r\n        length=0\r\n        while p is not None:\r\n            length+=1\r\n            p=p.next\r\n        k=k%length\r\n        if k==0:\r\n            return head\r\n        for i in range(k):\r\n            tmp_head=tmp_head.next\r\n        p=head\r\n        while tmp_head.next!=None:\r\n            tmp_head=tmp_head.next\r\n            p=p.next\r\n        next_head=p.next\r\n        p.next=None\r\n        return_head=next_head\r\n        while next_head.next!=None:\r\n            next_head=next_head.next\r\n        next_head.next=head\r\n        return return_head\r\n‘’‘"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842378232","body":"就这样吧，实在搞不懂怎么插入代码。\r\nclass Solution(object):\r\n    def swapPairs(self, head):\r\n        pre_tail=None\r\n        if head==None or head.next==None:\r\n            return head\r\n        return_head=head.next\r\n        while head!=None and head.next!=None:\r\n            next_head=head.next.next\r\n            current_tail=head\r\n            current_head=head.next\r\n            if pre_tail!=None:\r\n                pre_tail.next=current_head\r\n            current_head.next=current_tail\r\n            current_tail.next=next_head\r\n            head=next_head\r\n            pre_tail=current_tail\r\n        return return_head"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843269728","body":"先构造一个歪脖树，然后通过递归旋转歪脖树，来达到目的，因为每次从中点旋转时间复杂度logN，但是由于每次要遍历链表找到中点时间复杂度就变成了NlogN，空间复杂度，O1\r\n‘’‘\r\nclass Solution(object):\r\n\r\n    def sortedListToBST(self, head):\r\n        if head == None:\r\n            return None\r\n        dummy_node = TreeNode(0)\r\n        p = dummy_node\r\n        while head != None:\r\n            p.left = TreeNode(head.val)\r\n            p = p.left\r\n            head = head.next\r\n        return self.rotate(dummy_node.left)\r\n\r\n    def rotate(self, root):\r\n        # 给定一个纯向左倾斜的树，返回平衡二叉树\r\n        # 每次找到歪脖树的中点或者中点前一个。然后旋转，再拼起来\r\n        length = 0\r\n        if root == None or (root.left == None and root.right == None):\r\n            return root\r\n        p = root\r\n        while p != None:\r\n            length += 1\r\n            p = p.left\r\n        if length==2:#特殊的返回情况\r\n            bigger=root.left\r\n            root.left=None\r\n            bigger.left=root\r\n            return bigger\r\n        mid = length // 2\r\n        mid_node = root\r\n        for i in range(mid - 1):\r\n            mid_node = mid_node.left\r\n        last = mid_node\r\n        mid_node = mid_node.left\r\n        last.left = None\r\n\r\n        mid_node.right = self.rotate(mid_node.left)\r\n        mid_node.left = self.rotate(root)\r\n        return mid_node’‘’"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844201980","body":"‘’‘class Solution(object):\r\n    def getIntersectionNode(self, headA, headB):\r\n        if not headA or not headB:\r\n            return None\r\n        h1,h2= headA, headB\r\n        l1,l2=0,0\r\n        while h1:\r\n            l1+=1\r\n            h1=h1.next\r\n        while h2:\r\n            l2+=1\r\n            h2=h2.next\r\n        if l1 < l2:\r\n            shorter,longer= headA, headB\r\n        else:\r\n            shorter,longer= headB, headA\r\n        for i in range(max(l1,l2)-min(l1,l2)):\r\n            longer=longer.next\r\n        while shorter and longer and shorter!=longer:\r\n            shorter=shorter.next\r\n            longer=longer.next\r\n        return shorter\r\n\r\n’‘’"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844667445","body":"'''\r\n先找到计算出环的长度l，然后让头结点开始走l步，记为tmp，然后让头和tmp同时出发，相遇点就是入口\r\nclass Solution(object):\r\n\r\n    def detectCycle(self, head):\r\n        if head==None or head.next==None:\r\n            return None\r\n        fast,slow=head.next,head\r\n        while slow!=None and fast!=None:\r\n            if slow==fast:\r\n                break\r\n            slow=slow.next\r\n            fast=fast.next\r\n            if fast!=None and fast.next!=None:\r\n                fast=fast.next\r\n            else:\r\n                return None\r\n        tmp=slow\r\n        length=1\r\n        slow=slow.next\r\n        while slow!=tmp:\r\n            length+=1\r\n            slow=slow.next\r\n        tmp=head\r\n        for i in range(length):\r\n            tmp=tmp.next\r\n        while head!=tmp:\r\n            head=head.next\r\n            tmp=tmp.next\r\n        return head\r\n'''"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845612632","body":"class ListNode():\r\n    def __init__(self, key=0, val=0):\r\n        self.pre = None\r\n        self.next = None\r\n        self.val = val\r\n        self.key = key\r\n\r\n\r\nclass LRUCache(object):\r\n\r\n    def __init__(self, capacity):\r\n        \"\"\"\r\n        :type capacity: int\r\n        \"\"\"\r\n        self.capacity = capacity\r\n        self.dic = {}\r\n        self.dummy_head = ListNode(0)\r\n        self.dummy_tail = ListNode(0)\r\n        self.dummy_head.next = self.dummy_tail\r\n        self.dummy_tail.pre = self.dummy_head\r\n\r\n    def move2head(self, node):\r\n        node.next = self.dummy_head.next\r\n        self.dummy_head.next.pre = node\r\n        self.dummy_head.next = node\r\n        node.pre = self.dummy_head\r\n\r\n    def remove(self, node):\r\n        node.next.pre = node.pre\r\n        node.pre.next = node.next\r\n        return node\r\n\r\n    def deltail(self):\r\n        return self.remove(self.dummy_tail.pre)\r\n\r\n    def get(self, key):\r\n        \"\"\"\r\n        :type key: int\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        if key in self.dic:\r\n            node = self.dic[key]\r\n            _ = self.remove(node)\r\n            self.move2head(node)\r\n            return self.dic[key].val\r\n        else:\r\n            return -1\r\n\r\n    def put(self, key, value):\r\n        \"\"\"\r\n        :type key: int\r\n        :type value: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if key in self.dic:\r\n            self.dic[key].val = value\r\n            _=self.remove(self.dic[key])\r\n            self.move2head(self.dic[key])\r\n        else:\r\n            if self.capacity == 0:\r\n                tail = self.deltail()\r\n                self.dic.pop(tail.key)\r\n                node = ListNode(key, value)\r\n                self.dic[key] = node\r\n                self.move2head(self.dic[key])\r\n            else:\r\n                self.capacity -= 1\r\n                self.dic[key] = ListNode(key, value)\r\n                self.move2head(self.dic[key])\r\n        return\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846348916","body":"题选的越来越糊弄事，希望选题认真一些\r\n'''class Solution(object):\r\n\r\n    def maxDepth(self, root):\r\n        if root==None:\r\n            return 0\r\n        left=self.maxDepth(root.left)\r\n        right=self.maxDepth(root.right)\r\n        return max(left,right)+1\r\n'''"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846493668","body":"‘’‘\r\nclass Solution(object):\r\n\r\n    def isSameTree(self, p, q):\r\n        def DFS(p,q):\r\n            if p==None and q==None:\r\n                return True\r\n            if p==None or q==None:\r\n                return False\r\n            return p.val==q.val and DFS(p.left,q.left) and DFS(p.right,q.right)\r\n        return DFS(p,q)\r\n‘’‘"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840643716","body":"### 思路\r\n自己写的只能通过部分用例，盖着复现官方题解，看到其他人解答觉得自己写的太屎了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    int ptr;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> letterStack = new LinkedList<String>();\r\n        LinkedList<Integer> numStack = new LinkedList<Integer>();\r\n        ptr = 0;\r\n        \r\n        while (ptr < s.length()) {\r\n            if (Character.isDigit(s.charAt(ptr))) {\r\n                numStack.addLast(Integer.parseInt(getNumber(s)));\r\n            } else if (Character.isLetter(s.charAt(ptr)) || '[' == s.charAt(ptr)) {\r\n                letterStack.addLast(String.valueOf(s.charAt(ptr++)));\r\n            } else {\r\n                ptr++;\r\n                int count = numStack.removeLast();\r\n                LinkedList<String> subStrList = new LinkedList<String>();\r\n\r\n                while (!\"[\".equals(letterStack.peekLast())) {\r\n                    subStrList.addFirst(letterStack.removeLast());\r\n                    \r\n                }  \r\n\r\n                letterStack.removeLast();\r\n                String subStr = getString(subStrList);\r\n                StringBuffer sb = new StringBuffer();\r\n                while (count > 0) {\r\n                    sb.append(subStr);\r\n                    count --;\r\n                }\r\n\r\n                letterStack.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(letterStack);\r\n    }\r\n    public String getNumber(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            sb.append(s.charAt(ptr++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n    public String getString(List<String> s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for (String str: s) {\r\n            sb.append(str);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841004299","body":"### 思路\r\n双栈蠢方法准备看一下O（1）\r\n\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    private Deque<Integer> inStack;\r\n    private Deque<Integer> outStack;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        inStack = new LinkedList<Integer>();\r\n        outStack = new LinkedList<Integer>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n        outStack.clear();\r\n        for(int i : inStack) {\r\n            outStack.push(i);\r\n        }\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int res = outStack.pop();\r\n        inStack.clear();\r\n        for(int i : outStack) {\r\n            inStack.push(i);\r\n        }\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        return outStack.peek(); \r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        if (outStack.isEmpty()) {\r\n            return true;\r\n        } \r\n        return false;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841624961","body":"### 思路\r\n\r\n学习官方题解，使用辅助栈，真是妙啊，自己太傻了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> stack = new LinkedList<Integer>();\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (stack.size() == 0 || arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else if (arr[i] < stack.peek()) {\r\n                int head = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(head);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841773633","body":"### 思路\r\n\r\n闭环处理法和快慢指针法，感觉快慢指针经常会用，自己还是没有很熟悉\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n//闭环\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) {return head;}\r\n        ListNode cur = head;\r\n        int len = 1;\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            len ++;\r\n        }\r\n        k = k % len;\r\n        cur.next = head;\r\n        //这步的len-k 找到倒数第k个节点 而我们要找到倒数k+1个节点断开连接\r\n        for (int i = 0; i < len - k - 1; i++) {\r\n            head = head.next;\r\n        }\r\n        ListNode newHead = head.next;\r\n        head.next = null;\r\n        return newHead;\r\n\r\n    }\r\n}\r\n// 快慢指针\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) {return head;}\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode lenCur = head;\r\n        int len = 0;\r\n        while (lenCur != null) {\r\n            lenCur = lenCur.next;\r\n            len ++;\r\n        }\r\n        k = k % len;\r\n        //if(k == 0) { return head;}\r\n        while (fast.next != null) {\r\n            if (k-- <= 0) {\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n\r\n        fast.next = head;\r\n        ListNode newHead = slow.next;\r\n        slow.next = null;\r\n        return newHead;\r\n    }\r\n}\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：均为O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841926715","body":"### 思路\r\n添加虚拟头节点，让后续操作一致。虚拟节点好用点赞。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if (head == null) {return head;}\r\n        ListNode newHead = new ListNode();\r\n        newHead.next = head;\r\n        ListNode cur = newHead;\r\n       //剩余单数节点和偶数节点的情况\r\n        while (cur.next != null && cur.next.next != null) {\r\n            ListNode temp = cur.next.next;\r\n            cur.next.next = temp.next;\r\n            temp.next = cur.next;\r\n            cur.next = temp;\r\n            cur = cur.next.next;\r\n        }\r\n        return newHead.next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842995010","body":"### 思路\r\n\r\n快慢指针分治\r\n快慢指针真的很长见识，从找倒数第k到找第一个公共节点和这个构造平衡树，不同步长控制。 看完直喊喵啊喵啊 \r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if (head == null) {\r\n            return null;\r\n        } else if (head.next == null) {\r\n            return new TreeNode(head.val);\r\n        }\r\n        ListNode end = head;\r\n        while (end.next != null) {\r\n            end = end.next;\r\n        }\r\n        return toBST(head, end);\r\n\r\n    }\r\n    public TreeNode toBST(ListNode start, ListNode end) {\r\n        if (start == end) {\r\n            return new TreeNode(start.val);\r\n        }\r\n        ListNode mid = findMid(start, end);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = toBST(start, mid);\r\n        root.right = toBST(mid.next, end);\r\n        return root;\r\n    }\r\n    public ListNode findMid(ListNode start, ListNode end) {\r\n        ListNode fast = null;\r\n        ListNode slow = start;\r\n        if (start.next != null && start.next.next != null) {\r\n            fast = start.next.next;\r\n        } else {\r\n            fast = start;\r\n        }\r\n        while (fast.next != null) {\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(？)，其中 N 为数组长度。\r\n- 空间复杂度：O(？)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843728728","body":"### 思路\r\n双指针赛高\r\n### 代码\r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A = headA;\r\n        ListNode B = headB;\r\n\r\n        while (A != B) {\r\n            A = (A == null? headB : A.next);\r\n            B = (B == null? headA : B.next);\r\n        }\r\n        \r\n        return A;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N + M)，其中 N 为A长度 M为B长度。\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844825790","body":"### 思路\r\n笨方法set与快方法快慢指针\r\n### 代码\r\n\r\n\r\n```java\r\n\r\n //费时费空间法\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        Set<ListNode> set = new HashSet<ListNode>();\r\n        ListNode cur = head;\r\n        while (cur != null && !set.contains(cur)) {\r\n            set.add(cur);\r\n            cur = cur.next;\r\n        }\r\n        return cur;\r\n    }\r\n}\r\n//快慢指针\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null) {return null;}\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n\r\n        while (fast != null) {\r\n            if (fast.next != null) {\r\n                fast = fast.next.next;\r\n            } else {\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n            if (fast == slow) {\r\n                fast = head;\r\n                while (fast != slow) {\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                return slow;\r\n            }\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 笨方法\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(N)\r\n- 快方法\r\n- 时间复杂度：O(N)，其中 N 为链表长度。\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845782783","body":"### 思路\r\n\r\n第一次没看题解的时候 使用Linkedlist在很多操作的那个用例超时，后面看了题解用map 加定义的双向链表，又是喵喵喵，用map存对应节点是没想到的。不过盖上自己写的时候感觉细节上不注意就难受，因为这题在lc上debug很麻烦找不到哪段出问题\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n class LRUCache {\r\n    class ListNode {\r\n        int key;\r\n        int val;\r\n        ListNode next;\r\n        ListNode prev;\r\n        public ListNode (){}\r\n        public ListNode (int key, int value) {\r\n            this.val = value;\r\n            this.key = key;\r\n        }\r\n    }\r\n\r\n    Map<Integer, ListNode> map;\r\n    ListNode head, tail;\r\n    int max;\r\n\r\n    public LRUCache(int capacity) {\r\n        max = capacity;\r\n        map = new HashMap<Integer, ListNode>();\r\n        head = new ListNode();\r\n        tail = new ListNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (map.containsKey(key)) {\r\n            moveToFirst(map.get(key));\r\n            return map.get(key).val;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if (map.containsKey(key)) {\r\n            map.get(key).val = value;\r\n            moveToFirst(map.get(key));\r\n        } else {\r\n            if ( max > map.size()) {\r\n                ListNode node = new ListNode(key, value);\r\n                addNode(node);\r\n            } else if (max <= map.size()){\r\n                ListNode node = new ListNode(key, value);\r\n                removeLastNode();\r\n                addNode(node);\r\n            }\r\n        }\r\n\r\n    }\r\n    public void moveToFirst(ListNode node) {\r\n        removeNode(node);\r\n        addNode(node);\r\n        \r\n    }\r\n    public void removeNode(ListNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        map.remove(node.key);\r\n    }\r\n    \r\n    public void addNode(ListNode node) {\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        node.prev = head;\r\n        head.next = node; \r\n        map.put(node.key, node);\r\n    }\r\n\r\n    public void removeLastNode() {\r\n        ListNode last = tail.prev;\r\n        removeNode(last);\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846323347","body":"### 思路\r\n\r\n递归3秒钟，先来打个卡，去写个迭代\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return findMax(root);\r\n\r\n    }\r\n    public int findMax(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int left = findMax(root.left) + 1;\r\n        int right = findMax(root.right) + 1;\r\n        return left > right ? left : right;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846487772","body":"### 思路\r\n\r\n1. 递归\r\n2. 层序遍历 （刚刚折腾半天能不能不用8条语句做判断弄半天，位运算实现了，要好好学一下）\r\n3. 前中树 待完成\r\n### 代码\r\n\r\n\r\n```java\r\n//递归\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        return isSame(p, q);\r\n    }\r\n    public boolean isSame(TreeNode p, TreeNode q) {\r\n        if ( p == null && q == null) {\r\n            return true;\r\n        } \r\n        if ( p != null && q != null && p.val == q.val) {\r\n            return (isSame(p.left, q.left) && isSame(p.right, q.right));\r\n        }\r\n        return false;\r\n    }\r\n}\r\n//层序\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        LinkedList<TreeNode> pList = new LinkedList<TreeNode>();\r\n        LinkedList<TreeNode> qList = new LinkedList<TreeNode>();\r\n        if ( p == null ^ q == null) {\r\n            return false;\r\n        } else if (p == null ^ q == null){\r\n            return true;\r\n        }\r\n\r\n        pList.add(p);\r\n        qList.add(q);\r\n        //层序的结构\r\n        while (!pList.isEmpty() && !qList.isEmpty() && q != null && p != null) {\r\n            int plen = pList.size();\r\n            int qlen = qList.size();\r\n            while (plen-- > 0) {\r\n                TreeNode qcur = pList.poll();\r\n                TreeNode pcur = qList.poll(); \r\n                if (qcur.val == pcur.val) {\r\n                    if(pcur.left == null ^ qcur.left == null) {return false;}\r\n                    if(pcur.right == null ^ qcur.right == null) {return false;}\r\n                    if(pcur.left != null) {pList.add(pcur.left);}\r\n                    if(pcur.right != null) {pList.add(pcur.right);}\r\n                    if(qcur.left != null) {qList.add(qcur.left);}\r\n                    if(qcur.right != null) {qList.add(qcur.right);}\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：相等的话就是O(N) \r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZZWHU":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840646477","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, multi, res = [], 0, ''\r\n        for c in s:\r\n            if c.isdigit():\r\n                multi = multi*10 + int(c)\r\n            elif c == '[':\r\n                stack.append([multi, res])\r\n                multi, res = 0, ''\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi*res\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n看了下大佬的代码\r\n\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841655229","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n        return len(stack)\r\n```"},null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846513587","body":"```python\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        elif not p or not q:\r\n            return False\r\n        else:\r\n            if p.val == q.val:\r\n                return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n            else:\r\n                return False\r\n```\r\n时间复杂度O(N)\r\n空间复杂度O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840648679","body":"## **91学算法DAY1**\r\n\r\n#### 思路：\r\n\r\n计算器问题，入栈出栈的时机从符号转为“[ ]”\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：单次for O(n)\r\n- 空间：O(n)\r\n\r\n```c++\r\n#include \"LeetCodeBasic.h\"\r\n#include \"LeetCodeStl.h\"\r\nusing namespace std;\r\n/*\r\n* \r\n*/\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<string> strs;\r\n        stack<int> Muti_operator;\r\n        string res = \"\";\r\n        \r\n        for (size_t i = 0; i < s.size(); i++)\r\n        {   \r\n            int num;\r\n            if (s[i] >= '0' && s[i] <= '9')\r\n            {   \r\n                {\r\n                    num = num * 10 + s[i] - '0';\r\n                }\r\n                //第一次做想到了连续数字问题，但是其实没必要特殊考虑\r\n                /*for (size_t j = 1; j + i < s.size(); j++)\r\n                {\r\n                    if (s[i + j] >= '0' && s[i + j] <= '9')\r\n                    {\r\n                        num = s[i] * 10 + s[i + j];\r\n                    }\r\n                    else {\r\n                        continue;\r\n                    }\r\n                }*/\r\n            }\r\n            else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if (s[i] == '[')\r\n            {   \r\n                Muti_operator.push(num);\r\n                num = 0;\r\n                strs.push(res);\r\n                res = \"\";\r\n            }\r\n            else if (s[i] == ']') {\r\n                int times = Muti_operator.top();\r\n                Muti_operator.pop();\r\n                for (size_t i = 0; i < times; i++)\r\n                {\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top();\r\n                strs.pop();\r\n            }  \r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841085056","body":"## **91学算法DAY2**\r\n\r\n#### 思路：\r\n两个栈模拟输入和输入\r\n\r\n对比小白时期的优化：\r\n\r\npush可以一直push到输入栈，不需要倒腾。\r\n\r\npop的时候其实只要是output的栈栈顶有元素其实就是需要pop的num。\r\n\r\n**只有out栈是空的时候，才需要左边倒腾到右边。**\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：O(1)\r\n- 空间：O(n)\r\n\r\n```c++\r\n\r\nusing namespace std;\r\nclass MyQueue {\r\npublic:\r\n    stack<int> output;\r\n    stack<int> input;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    /** Push element x to the back of queue. */\r\n   void push(int x) { \r\n            input.push(x);\r\n  \r\n    }\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop()\r\n    {\r\n        int num = 0;\r\n        if (output.empty())\r\n        {\r\n            while (!input.empty())\r\n            {\r\n                output.push(input.top());\r\n                input.pop();\r\n            }\r\n        }\r\n        if (!output.empty())\r\n        {\r\n            num = output.top();\r\n            output.pop();\r\n        }\r\n        return num;\r\n    }\r\n\r\n    /** Get the front element. */\r\n    int peek() {\r\n        int res;\r\n        if (output.empty())\r\n        {\r\n            while (!input.empty())\r\n            {\r\n                output.push(input.top());\r\n                input.pop();\r\n            }\r\n        }\r\n\r\n        if (!output.empty())\r\n        {\r\n            res = output.top();\r\n        }\r\n        return res;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (output.empty() && input.empty()) ? true : false;\r\n    }\r\n};\r\n\r\n```\r\n\r\n``"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683445","body":"## **91学算法DAY3**\r\n\r\n#### 思路：\r\n\r\n​        维护一个递增的单调栈，其中栈内的元素是每个块的最大值，这样最后栈的长度就是块的长度\r\n​        维护时的过程\r\n​         如果arr[i]比栈顶元素大，根据取最大值的题意，他就要被分到单调的一块\r\n​         如果arr[i]比栈顶元素小，那么就要依次弹出栈顶，直到找到可以找到他可以添加的块的位置，将前面弹出的这些块合并。\r\n​        /如果相等，说明当前块需要容纳arr[i]\r\n\r\n#### 复杂度分析：\r\n\r\n- 时间：O(1)\r\n- 空间：O(n)\r\n\r\n```c++\r\n\r\n#include <algorithm> \r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n\r\n        stack<int> res;\r\n        int len = arr.size();\r\n        int stackSize = res.size();\r\n        int max = arr[0];\r\n        res.push(max);\r\n        for (size_t i = 0; i < len; i++)\r\n        {\r\n            if (!res.empty())\r\n            {\r\n                if (arr[i] > res.top())\r\n                {\r\n                    res.push(arr[i]);\r\n                }\r\n                else\r\n                {   \r\n                    max = res.top();\r\n                    res.pop();\r\n                    while (!res.empty()) {\r\n                        if (arr[i] >= res.top()) { \r\n                            res.push(max);\r\n                            break;\r\n                        }\r\n                        res.pop();\r\n                    }\r\n                }\r\n            }\r\n            else\r\n            {\r\n                res.push(arr[i]);\r\n            }\r\n        }\r\n        return stackSize;\r\n    }\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841751580","body":"## **91学算法DAY3*4\r\n\r\n#### 思路：\r\n\r\n 先秒一个迭代。晚上回来写双指针和环\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n\r\n\r\n\r\n\r\n```c++\r\n\r\n\r\nclass Solution {\r\n    //思路\r\n    // 遍历k    \r\n    // 3 -> \r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (head == nullptr || head->next\r\n             == nullptr || k == 0) { return head; }\r\n        \r\n        ListNode* temp = head;\r\n        int len = 0;\r\n        \r\n        while (temp->next != nullptr)\r\n        {\r\n            temp = temp->next; //尾节点\r\n            len++;\r\n        }\r\n\r\n        k = k % len;\r\n        ListNode* newhead;\r\n        ListNode* newTail;\r\n        newhead = head;\r\n        newTail = head;\r\n        for (size_t i = 0; i < len - k; i++)\r\n        {\r\n            newhead = newhead->next;\r\n        }\r\n        for (size_t i = 0; i < len - k; i++)\r\n        {\r\n            newTail = newTail->next;\r\n        }\r\n        temp->next = head;\r\n        newTail->next = nullptr;\r\n        return newhead;\r\n    }\r\n};\r\n\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842389395","body":"## **91学算法DAY5\r\n\r\n#### 思路：\r\n\r\n 简单递归，需要注意的点是c++需要新建一个nextNode的指针，之前java没遇到过\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N) 栈的cost\r\n\r\n#### Code：\r\n\r\n```c++\r\n#include \"ListNode.cpp\"\r\n//\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n\t\tif (head == nullptr || head->next == nullptr)\r\n\t\t{\r\n\t\t\treturn head;\r\n\t\t}\r\n\t\t// 1 - 2\r\n\t\tListNode* nextNode = head->next;\r\n\t\tListNode* li = nextNode->next;\r\n\t\tnextNode->next = nullptr;\r\n\t\tnextNode->next = head;\r\n\t\thead->next = swapPairs(li);\r\n\t\treturn nextNode;\r\n    }\r\n};\r\n\r\nint main() {\r\n\r\n}\r\n\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843289477","body":"## **91学算法DAY6\r\n\r\n#### 思路：\r\n\r\n有序链表先转为数组，再递归处理变成BST。\r\n\r\n最初想到的，复杂度肯定很高，数组问题需要双指针的优化。\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N) \r\n\r\n#### Code：\r\n\r\n```c++\r\n#include\"ListNode.cpp\"\r\n#include\"TreeNode.cpp\"\r\n#include\"LeetCodeStl.h\"\r\n#include\"LeetCodeBasic.h\"\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n\t\tif (head== nullptr)\r\n\t\t{\r\n\t\t\treturn NULL;\r\n\t\t}\r\n\r\n\t\tif (head->next == NULL)\r\n\t\t{\r\n\t\t\tint a = head->val;\r\n\t\t\tTreeNode*root = new TreeNode(a);\r\n\t\t\treturn root;\r\n\t\t}\r\n\t\tvector<int> v;\r\n\t\twhile (head)\r\n\t\t{\r\n\t\t\tv.push_back(head->val);\r\n\t\t\thead = head->next;\r\n\t\t}\r\n\t\tTreeNode* root = NULL;\r\n\t\tbuild_tree(&root, v, 0, v.size() - 1);\r\n\t\treturn root;\r\n    }\r\n\tvoid build_tree(TreeNode** root, vector<int>& v, int start, int end)\r\n\t{\r\n\t\tif (start > end) return;\r\n\t\tint half = (start + end) / 2;\r\n\t\t*root = new TreeNode(v[half]);\r\n\t\tbuild_tree(&(*root)->left, v, start, half - 1);\r\n\t\tbuild_tree(&(*root)->right, v, half + 1, end);\r\n\t}\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844214703","body":"## **91学算法DAY7\r\n\r\n#### 思路：\r\n\r\n链表中的环\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n时间复杂度：O(N) \r\n\r\n空间复杂度：O(1) \r\n\r\n#### Code：\r\n\r\n```class Solution {\r\npublic:\r\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\r\n      \r\n        ListNode* shortHead = headA;\r\n        ListNode* longHead = headB;\r\n        if (shortHead == nullptr || longHead == nullptr)\r\n            {\r\n                return NULL;\r\n            }\r\n        while (shortHead != longHead)\r\n        {\r\n            if (shortHead == nullptr)\r\n            {\r\n                shortHead = headA;\r\n            } else {\r\n                  shortHead = shortHead->next;\r\n            }\r\n            if (longHead == nullptr)\r\n            {\r\n                longHead = headB;\r\n            }else {\r\n                  longHead = longHead->next;\r\n            }\r\n        }\r\n         return shortHead;\r\n    }\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845230927","body":"## **91学算法DAY几来着？\r\n\r\n#### 思路：\r\n\r\n链表中的环，老朋友了\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n时间复杂度：O(N) while\r\n\r\n空间复杂度：常数\r\n\r\n#### Code：\r\n\r\n```c++\r\n/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode(int x) : val(x), next(NULL) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        ListNode * slow = head;\r\n           ListNode *  fast = head;\r\n        \r\n        while (fast != nullptr) {\r\n            slow = slow->next;\r\n            \r\n            if (fast->next == nullptr) {\r\n                return nullptr;\r\n            }\r\n\r\n            fast = fast->next->next;\r\n            if (fast == slow) {\r\n                ListNode* p= head;\r\n                while (p != slow) {\r\n                    p = p->next;\r\n                    slow = slow->next;\r\n                }\r\n                return p;\r\n            }\r\n        }\r\n        return nullptr;\r\n    }\r\n};\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845834735","body":"啊啊出去玩忘交了，先上个车，回家马上补票！\r\n``` c++\r\nstruct DLinkedNode {\r\n    int key, value;\r\n    DLinkedNode* prev;\r\n    DLinkedNode* next;\r\n    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\r\n    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\r\n};\r\n\r\nclass LRUCache {\r\nprivate:\r\n    unordered_map<int, DLinkedNode*> cache;\r\n    DLinkedNode* head;\r\n    DLinkedNode* tail;\r\n    int size;\r\n    int capacity;\r\n\r\npublic:\r\n    LRUCache(int _capacity): capacity(_capacity), size(0) {\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head->next = tail;\r\n        tail->prev = head;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if (!cache.count(key)) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        DLinkedNode* node = cache[key];\r\n        moveToHead(node);\r\n        return node->value;\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if (!cache.count(key)) {\r\n         \r\n            DLinkedNode* node = new DLinkedNode(key, value);\r\n    \r\n            cache[key] = node;\r\n       \r\n            addToHead(node);\r\n            ++size;\r\n            if (size > capacity) {\r\n          \r\n                DLinkedNode* removed = removeTail();\r\n            \r\n                cache.erase(removed->key);\r\n             \r\n                delete removed;\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n        \r\n            DLinkedNode* node = cache[key];\r\n            node->value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    void addToHead(DLinkedNode* node) {\r\n        node->prev = head;\r\n        node->next = head->next;\r\n        head->next->prev = node;\r\n        head->next = node;\r\n    }\r\n    \r\n    void removeNode(DLinkedNode* node) {\r\n        node->prev->next = node->next;\r\n        node->next->prev = node->prev;\r\n    }\r\n\r\n    void moveToHead(DLinkedNode* node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    DLinkedNode* removeTail() {\r\n        DLinkedNode* node = tail->prev;\r\n        removeNode(node);\r\n        return node;\r\n    }\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846406581","body":"## **91学算法DAY几来着？\r\n\r\n#### 思路：\r\n\r\n简简单单dfs\r\n\r\n****\r\n\r\n#### 复杂度分析：\r\n\r\n时间复杂度：O(N) \r\n\r\n空间复杂度：栈深度\r\n\r\n#### Code：\r\n\r\n```c++\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\nclass Solution {\r\npublic:\r\n    int depth = 0;\r\n    int maxDepth(TreeNode* root) {\r\n        dfs(root,0);\r\n        return depth;\r\n    }\r\n    void dfs(TreeNode* root,int curdepth) {\r\n        if(root == nullptr) {\r\n            return;\r\n        }\r\n        curdepth++;\r\n        //每次递归都把该串当前的长度记下来\r\n        depth = max(depth,curdepth);\r\n        dfs(root->left,curdepth);\r\n        dfs(root->right,curdepth);\r\n    }\r\n};\r\n```\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jolins":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839884479","body":"### 思路\r\n通过vector进行栈的模拟，设计一个指针始终指向栈顶的位置，记录栈中存的元素\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int m_max_;\r\n    int m_top_ = 0;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize);\r\n        m_max_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (m_top_ >= m_max_) return;\r\n        stack[m_top_++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (m_top_ >= 1) {\r\n            return stack[--m_top_];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int min_val = min(k, m_top_);\r\n        for (int i = 0; i < min_val; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n### 注意事项\r\n需注意top++, ++top，及--top和top--可能造成的数组越界问题\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(max(maxSize, k)) (increment函数)\r\n- 空间复杂度：O(maxSize)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/47#issuecomment-840656961","body":"### 解题思路\r\n\r\n* 遇到数字保存数字到临时变量\r\n* 遇到字母保存字母到临时变量\r\n* 遇到左括号把数字和字母推到栈中\r\n* 遇到右括号对栈中的数字和字母出栈进行解析\r\n\r\n### 代码\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        string res = \"\";\r\n        int num = 0;\r\n\r\n        for (int i = 0; i < s.size(); i++) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                num = num * 10 + s[i] - '0';  //字符串转整数\r\n            } else if ((s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z')) {\r\n                res = res + s[i];\r\n            } else if('[' == s[i]) {\r\n                nums.push(num);\r\n                strs.push(res);\r\n                \r\n                //清空num和res\r\n                num = 0;\r\n                res = \"\";\r\n            } else if(']' == s[i]) {\r\n                for (int j = 0; j < nums.top(); j++) {\r\n                   //res += strs.top();\r\n                   strs.top() += res;\r\n                }\r\n\r\n                res = strs.top();\r\n\r\n                nums.pop();\r\n                strs.pop();\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n### 时间复杂度\r\n\r\n\r\n\r\n### 空间复杂度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841290432","body":"### Leetcode-232. 用栈实现队列\r\n### 思路\r\n使用两个栈，一个栈保存数据，另外一个栈当需要pop的时候保存第一个栈的数据，实现数据的翻转；\r\n### 代码\r\n\r\n- 语言：C++\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        if (stack_in.empty()) front = x; //记录stack_in最下面的元素，且只记录一次\r\n        stack_in.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    //队列的头就是最开始的元素，因此如果out里面有元素，从out里面直接pop即可；\r\n    int pop() {\r\n        int result;\r\n        if (stack_out.empty()) {\r\n            while (!stack_in.empty()) {\r\n                stack_out.push(stack_in.top());\r\n                stack_in.pop();\r\n            }\r\n        }\r\n        result = stack_out.top();\r\n        stack_out.pop();\r\n        return result;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (stack_out.empty()) return front;\r\n        return stack_out.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return stack_in.empty() && stack_out.empty();\r\n    }\r\n\r\nprivate:\r\n    int front;\r\n    stack<int> stack_in;\r\n    stack<int> stack_out;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n### 时间复杂度\r\nO(1)\r\n### 空间复杂度\r\nO(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841667623","body":"### 思路\r\n按照题意，将数据进行放到栈中，因为最后需要的是一个单调递增的数组，所以每一块的最大值应该是单调递增的。\r\n所以新进来一个数据\r\n\r\n- 如果大于栈顶的最大值，直接放入栈中，作为新的块\r\n- 如果小于栈顶的最大值，向之前的合并，但需要保留上一个块中的最大值\r\n\r\n### 代码实现 C++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            if (max_stack.empty()) {\r\n                max_stack.push(arr[i]);\r\n            } else {\r\n                if (arr[i] >= max_stack.top()) {\r\n                    max_stack.push(arr[i]);\r\n                } else {\r\n                    int temp = max_stack.top();\r\n                    while (!max_stack.empty() && arr[i] < max_stack.top()) {\r\n                        max_stack.pop();\r\n                    }\r\n                    max_stack.push(temp);\r\n                }\r\n            }\r\n        }\r\n        return max_stack.size();\r\n    }\r\n\r\nprivate:\r\n    std::stack<int> max_stack;\r\n};\r\n```\r\n\r\n### 时间复杂度\r\nO(N)\r\n### 空间复杂度\r\nO(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841835610","body":"### 思路\r\n\r\n1. 将链表闭合为环，利用循环操作来进行减少运算\r\n2. 将链表的尾节点指向链表的头节点\r\n3. 因为要循环减少运算，因此需要计算链表的长度，同时计算链表的尾节点\r\n4. 计算出最后需要截断的结点，设链表的长度为L，移动k，则截断的解点为k - （L%k）\r\n5. 链表截断后尾节点指向空指针，返回头节点\r\n\r\n### 代码 C++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if (k == 0 || head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n        int n = 1;\r\n        ListNode* iter = head;\r\n        while (iter->next != nullptr) {\r\n            iter = iter->next;\r\n            n++;\r\n        }\r\n        int add = n - k % n;\r\n        if (add == n) {\r\n            return head;\r\n        }\r\n        iter->next = head;\r\n        while (add--) {\r\n            iter = iter->next;\r\n        }\r\n        ListNode* ret = iter->next;\r\n        iter->next = nullptr;\r\n        return ret;\r\n    }\r\n};\r\n```\r\n\r\n### 时间复杂度\r\nO(N)\r\n\r\n### 空间复杂度\r\nO(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842422757","body":"### 思路-使用递归进行不断交换相邻链表的节点\r\n\r\n1. 递归的每一层做的都是将两个链表进行交换\r\n2. 递归的返回值是一个链表，且是去掉之前两个节点的链表，假设总的个数为n的话，返回的是n-1，因此循环的时候返回的是Head->next->next;\r\n3. 递归的终止条件是当head==nullptr或head->next==nullptr\r\n\r\n### 代码 C++\r\n```c++\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        if (head == nullptr || head->next == nullptr) {\r\n            return head;\r\n        }\r\n\r\n        ListNode* new_head = head->next;\r\n        head->next = swapPairs(new_head->next);\r\n        new_head->next = head;\r\n\r\n        return new_head;\r\n    }\r\n};\r\n```\r\n\r\n### 时间复杂度\r\nO(N)\r\n### 空间复杂度\r\nO(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839266522","body":"# 思路\r\n用数组和一个全局变量idx来模拟\r\nidx即当前栈顶元素的下标\r\npop就返回最后一个元素，并且idx--\r\npush就判断idx是否在定义的大小范围之内然后idx加1后再赋值\r\nincrement直接模拟一下过程即可\r\n\r\n# 代码：\r\nC++\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int idx;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize); // 定义栈的大小\r\n        idx = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(idx != stack.size() - 1) {\r\n            stack[++idx] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        return idx == -1 ? idx : stack[idx--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int limit = min(k, idx + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840923592","body":"# 思路\r\n用一个栈为主要栈，另外一个栈为辅助栈\r\n其中push操作直接放入主要栈中，然后需要取出top元素时，需要去将主要栈的元素全部放入辅助栈中，然后再依次返回，类似做了一个反转的操作，这样pop出来的就是队列顶的元素的。\r\n# 代码\r\nc++\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    stack<int> s1, s2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        while(s1.size() > 1) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int t = s1.top();\r\n        s1.pop();\r\n        while (s2.size()) {\r\n            s1.push(s2.top());\r\n             s2.pop();\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        while(s1.size() > 1) {\r\n            s2.push(s1.top());\r\n            s1.pop();\r\n        }\r\n        int t = s1.top();\r\n        while (s2.size()) {\r\n            s1.push(s2.top());\r\n             s2.pop();\r\n        }\r\n        return t;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return s1.empty();\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841645559","body":"\r\n# 代码\r\nc++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        auto b = arr;\r\n        sort(b.begin(), b.end());\r\n        unordered_map<int, int> map;\r\n        int res = 0;\r\n        for (int i = 0, s = 0; i < arr.size(); i ++) {\r\n            if (map[arr[i]] == 1) s --;\r\n            else if (map[arr[i]] == 0) s ++;\r\n            map[arr[i]] --;\r\n            if (map[b[i]] == -1) s --;\r\n            else if (map[b[i]] == 0) s ++;\r\n            map[b[i]] ++;\r\n            if (!s) res ++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841810241","body":"# 思路\r\n首先对k进行处理，先遍历一遍链表，得到链表的长度\r\n然后k 模上一个 链表的长度\r\n最后找到倒数第k个节点，将其插入到head前面\r\n\r\n# 代码\r\nc++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(!head) return head;\r\n        int len = 0;\r\n        for(auto p = head; p; p = p->next) len++;\r\n        k = k % len;\r\n        if(!k) return head;\r\n        auto p = head;\r\n        for(int i = 0; i < len - k - 1; i++) p = p->next; // 找到倒数第k个节点\r\n        auto tail = head;\r\n        while (tail->next) tail = tail->next; // 找到最后一个节点\r\n        tail->next = head;\r\n        head = p->next;\r\n        p->next = nullptr;\r\n        return head;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841901307","body":"# 思路\r\n\r\n模拟就完事了\r\n\r\n# 代码\r\nc++\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        ListNode* dummy = new ListNode(1);\r\n        dummy->next = head;\r\n        for (auto p = dummy; p->next && p->next->next;) {\r\n            auto p1 = p->next, p2 = p1->next;\r\n            p->next = p2;\r\n            p1->next = p2->next;\r\n            p2->next = p1;\r\n            p = p1;\r\n        }\r\n        return dummy->next;\r\n    }\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844133418","body":"# 代码\r\nc++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        auto p = headA, q = headB;\r\n        while (q != p) {\r\n            p = p ? p->next : headB;\r\n            q = q ? q->next : headA;\r\n        }\r\n        return q;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845148993","body":"# 代码\r\nc++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if (!head || !head->next) return NULL;\r\n        auto low = head, fast = head->next;\r\n        while (fast && fast->next) {\r\n            if (low == fast) {\r\n                low = head, fast = fast->next;\r\n                while (low != fast) {\r\n                    low = low->next;\r\n                    fast = fast->next;\r\n                }\r\n                return low;\r\n            }\r\n            low = low->next;\r\n            fast = fast->next->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846332823","body":"# 思路\r\n递归\r\n# 代码\r\nc++\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        if(!root) return 0;\r\n        int left = maxDepth(root->left);\r\n        int right = maxDepth(root->right);\r\n        return max(left, right) + 1;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839686367","body":"\r\n### 思路\r\n\r\n暴力法\r\n\r\n### 代码\r\n\r\n\r\nPython\r\n\r\n\r\n```\r\n Class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max = maxSize\r\n        self.ina = [] \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.ina)<self.max:\r\n            self.ina.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.ina:\r\n            return self.ina.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.ina))):\r\n            self.ina[i]+=val\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)\r\n\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841099531","body":"### 思路\r\n\r\n使用list表示两个栈stak_1,list_1，只能使用栈的相关方法，如append()，pop()，s[-1]，分别是栈顶追加元素,删除栈顶元素,取出栈顶元素.\r\n\r\n入队操作即追加元素，都在栈stak_1中操作；\r\n出队操作首先判断缓存栈,list_1是否有元素，有的话直接取出,list_1栈顶元素；若,list_1为空并且stak_1中有元素，将stak_1中元素全部转移到,list_1中，再取出,list_1栈顶元素，即可模拟队列出队操作；\r\n\r\n### 代码\r\n\r\n\r\n```\r\npython\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack_1 = []\r\n        self.list_1 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack_1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.list_1:\r\n            return self.list_1.pop()\r\n        else:\r\n            if self.stack_1:\r\n                while self.stack_1:\r\n                    self.list_1.append(self.stack_1.pop())\r\n                return self.list_1.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.list_1:\r\n            return self.list_1[-1]\r\n        else:\r\n            if self.stack_1:\r\n                while self.stack_1:\r\n                    self.list_1.append(self.stack_1.pop())\r\n                return self.list_1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if self.stack_1 or self.list_1:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n#### push\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n#### pop\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n#### peek\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n#### empty\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(1)\r\n"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844068234","body":"### 思路\r\n\r\n 双链表法\r\n\r\n### 代码\r\n\r\n\r\n```Python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        pA = headA\r\n        pB = headB\r\n        while(pA != pB):\r\n\r\n             if pA is None:\r\n                 pA = headB\r\n             else:\r\n                 pA = pA.next\r\n\r\n             if pB is None:\r\n                 pB = headA\r\n             else:\r\n                 pB = pB.next\r\n        return pA         \r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-enll":[null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/45#issuecomment-839755413","body":"### 思路\r\n数组模拟\r\n\r\n### 代码\r\nC++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stack;\r\n    int idx;\r\n    CustomStack(int maxSize) {\r\n        stack.resize(maxSize); // 定义栈的大小\r\n        idx = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(idx != stack.size() - 1) {\r\n            stack[++idx] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        return idx == -1 ? idx : stack[idx--];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int limit = min(k, idx + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n};"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841745832","body":"**复杂度分析**\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(1)\r\n\r\n**思路** **递归**\r\n\r\n`class Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        length = 1\r\n        lastNode = head\r\n        \r\n        while lastNode.next:\r\n            lastNode = lastNode.next\r\n            length += 1\r\n        \r\n        if k>=length: k=k%length\r\n\r\n        if k==0: return head\r\n\r\n        numBreak = length-k\r\n\r\n        breakNode = head\r\n        for i in range(numBreak-1):\r\n            breakNode = breakNode.next\r\n        nextListNode = breakNode.next\r\n        \r\n        lastNode.next = head\r\n        breakNode.next = None\r\n\r\n        return nextListNode`"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845981341","body":"`\r\n    class Node{\r\n        int key;\r\n        int val;\r\n        Node prev;\r\n        Node next;\r\n        public Node(int k, int v){\r\n            key = k;\r\n            val = v;\r\n        }\r\n    }\r\n    \r\n    Node head;\r\n    Node tail;\r\n    Map&lt;Integer, Node&gt; map;\r\n    int size;\r\n    int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n         head = new Node(0,0);\r\n         tail = new Node(0,0);\r\n        head.next = tail;\r\n        tail.prev = head;\r\n        map = new HashMap&lt;&gt;();\r\n        size = 0;\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(map.containsKey(key)){\r\n            Node cur = map.get(key);\r\n            remove(key);\r\n            addHead(key, cur.val);\r\n            return cur.val;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)){\r\n            remove(key);\r\n            addHead(key,value);\r\n        } else{\r\n            addHead(key, value);\r\n        }\r\n    }\r\n    \r\n    private void remove(int key){\r\n        Node cur = map.get(key);\r\n        Node prev = cur.prev;\r\n        Node next = cur.next;\r\n        prev.next = next;\r\n        next.prev = prev;\r\n        map.remove(key);\r\n        size--;\r\n        \r\n    }\r\n    \r\n    private void addHead(int key, int val){\r\n        Node node = new Node(key, val);\r\n        Node next = head.next;\r\n        head.next = node;\r\n        node.prev = head;\r\n        node.next = next;\r\n        next.prev = node;\r\n        map.put(key, node);\r\n        size++;\r\n        \r\n        if(size&gt;capacity){\r\n            Node preTail = tail.prev;\r\n            remove(preTail.key);\r\n        }\r\n    }\r\n    \r\n   \r\n}`\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841302467","body":"JavaScript Code:\r\n```\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n  this.pushStack = []\r\n  this.popStack = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.pushStack.push(x)\r\n};\r\n\r\n/**\r\n * 移栈\r\n */\r\nMyQueue.prototype.transfer = function() {\r\n  if(!this.popStack.length){\r\n    while(this.pushStack.length){\r\n      this.popStack.push(this.pushStack.pop())\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  this.transfer()\r\n  return this.popStack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  this.transfer()\r\n  return this.popStack[this.popStack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return !this.pushStack.length && !this.popStack.length\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\nTime Complexity：O(1)\r\nSpace Complexity：O(N)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841816905","body":"JavaScript Code:\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if(!head) return head\r\n  let size = 1\r\n  let cur = head\r\n  while(cur.next){\r\n    cur = cur.next\r\n    size++\r\n  }\r\n  cur.next = head\r\n  for(let i = 0; i < size - k % size - 1; i++){\r\n    head = head.next\r\n  }\r\n  cur = head.next\r\n  head.next = null\r\n  return cur\r\n};\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842414375","body":"JavaScript Code:\r\n\r\n---\r\nSolution 1: Recursion\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n  if(!head || !head.next) return head\r\n\r\n  let p = head.next\r\n  head.next = swapPairs(p.next)\r\n  p.next = head\r\n  return p\r\n};\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)\r\n\r\n---\r\nSolution 2: Iteration\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * \r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n  if(!head || !head.next) return head\r\n\r\n  let dummyHead = new ListNode(-1, head)\r\n  let p = dummyHead\r\n  while (head && head.next) {\r\n    let next = head.next\r\n    head.next = next.next\r\n    next.next = head\r\n    p.next = next\r\n\r\n    p = head\r\n    head = head.next\r\n  }\r\n\r\n  return dummyHead.next\r\n};\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845244009","body":"Ideas: Fast and slow pointer.\r\nJavaScript Code:\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\n// 快慢指针\r\nvar detectCycle = function(head) {\r\n    let start = head, slow = head, fast = head\r\n    while (fast && fast.next) {\r\n      slow = slow.next\r\n      fast = fast.next.next\r\n      if (fast === slow) {\r\n        // 通过数学推导可知: fast与slow的相遇时，从起点到入环点的距离，slow也走过相同的距离时必定也处于入环点\r\n        while (start && slow) {\r\n          if (start === slow) return start\r\n          start = start.next\r\n          slow = slow.next\r\n        }\r\n      }\r\n    }\r\n    return null\r\n};\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846347263","body":"JavaScript Code:\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n  if(root === null) return 0\r\n  return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1\r\n};\r\n```\r\nTime complexity: O(N)\r\nSpace complexity: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846530317","body":"JavaScript Code:\r\n```\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function(p, q) {\r\n  if(p === null && q === null) return true\r\n  if(p === null || q === null) return false\r\n  if(p.val !== q.val) return false\r\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dpgirl":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841076289","body":"## 思路\r\n用辅助栈来存储元素，当辅助栈不为空时，往主栈添加辅助栈的栈顶；当主栈不为空时，往辅助栈添加主栈的栈顶\r\n\r\n- 语言支持：JavaScript\r\n\r\n\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n    this.stack = [] // 主栈\r\n    this.helpStack = [] // 辅助栈\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    let cur = null\r\n    while(cur = this.stack.pop()) { // 主栈不为空的时候\r\n        console.log('help',this.helpStack, cur)\r\n        this.helpStack.push(cur)\r\n    }\r\n    this.helpStack.push(x) // push的时候，先往辅助栈添加元素\r\n    while(cur = this.helpStack.pop()) { // 辅助栈不为空时，往主栈添加辅助栈的栈顶\r\n        console.log('stack',this.stack, cur)\r\n        this.stack.push(cur)\r\n    }\r\n    console.log('结果', this.stack, this.helpStack)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length - 1]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n第二种：用数组的push和shift来模拟队列操作\r\n```javascript\r\n\r\n/**\r\n * Initialize your data structure here.\r\n */\r\nvar MyQueue = function() {\r\n   this.queue = []\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n   this.queue.push(x)\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift()\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0]\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length === 0\r\n};\r\n\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841833052","body":"\r\n## 思路\r\n快慢指针\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n  if(!head || !head.next || k === 0) return head;\r\n\r\n  let length = 1, cur = head;\r\n\r\n  //找出长度\r\n  while(cur.next){\r\n    cur = cur.next\r\n    length++\r\n  }\r\n\r\n  //找出真实的k的次数\r\n  k = k % length;\r\n\r\n  let fast = head, slow = head\r\n\r\n\r\n  //这时候的slow是newTail，这里Lucifer写的挺elegant Q_Q\r\n  while(fast.next){\r\n    if(k-- <=0) slow = slow.next\r\n    fast = fast.next\r\n  }\r\n\r\n  fast.next = head;\r\n  let newHead = slow.next\r\n\r\n  slow.next = null;\r\n  return newHead\r\n};\r\n\r\n\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842434085","body":"## 思路\r\n迭代：空指针preNode指向当前指针，preNode.next指向当前指针的next指向\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar swapPairs = function(head) {\r\n    if (!head || !head.next) return head;\r\n    let res = head.next;\r\n    let now = head;\r\n    let preNode = new ListNode();\r\n    preNode.next = head;\r\n    while (now && now.next) {\r\n        let nextNode = now.next;\r\n        now.next = nextNode.next;\r\n        nextNode.next = now;\r\n        preNode.next = nextNode;\r\n        preNode = now;\r\n        now = nextNode.next;\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843242436","body":"\r\n## 思路\r\n快慢指针\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function(head) {\r\n    if (!head) return null;\r\n    return run(head, null);\r\n};\r\n\r\nfunction run(head, tail) {\r\n    if (head === tail) return null;\r\n    let fast = head;\r\n    let slow = head;\r\n    while(fast != tail && fast.next != tail) {\r\n        fast = fast.next.next;\r\n        slow = slow.next\r\n    }\r\n    let root = new TreeNode(slow.val)\r\n    root.left = run(head, slow)\r\n    root.right = run(slow.next, tail)\r\n    return root\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845160233","body":"\r\n## 思路\r\n快慢指针，但是为什么第一次相遇时，快指针就得重新回到链表头部\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    if(head == null || head.next == null) return null\r\n    let fast = (slow = head)\r\n    do {\r\n        if(fast != null && fast.next != null) {\r\n            fast = fast.next.next; // 两圈\r\n        } else {\r\n            fast = null;\r\n        }\r\n        slow = slow.next\r\n    } while (fast != slow)\r\n\r\n    if(fast == null) return null;\r\n    fast = head;\r\n    while(fast != slow) {\r\n        fast = fast.next;\r\n        slow = slow.next;\r\n    }\r\n    return fast;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"physicshi":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841819024","body":"### 思路\r\n链表成环，要注意`k`和链表长度的比较：如果`k`小于链表长度就按着`k`；如果`k`是链表长度的整倍数就相当于没变；如果`k`不是链表长度的整倍数，就是取余数\r\n\r\n\r\n### 代码\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(!head || !k || !head.next) return head\r\n    let len=1,cur=head;\r\n    while(cur.next){\r\n        cur=cur.next;\r\n        len++\r\n    }\r\n    cur.next=head;\r\n    let move=len-k%len;\r\n    while(move){\r\n        cur=cur.next;\r\n        move--\r\n    }\r\n    let ans=cur.next;\r\n    cur.next=null;\r\n    return ans\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842440380","body":"### 思路\r\n要注意指针的指向，以及位置的暂存；并及时更新指针\r\n\r\n\r\n### 代码\r\n\r\n```js\r\nvar swapPairs = function (head) {\r\n    const dummy = new ListNode(0);\r\n    dummy.next = head;\r\n    let pre = dummy;\r\n    while (head && head.next) {\r\n        const next = head.next;\r\n        head.next = next.next;\r\n        next.next = head;\r\n        pre.next = next;\r\n\r\n        pre = head;\r\n        head = head.next;\r\n    }\r\n    return dummy.next\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(1)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846040106","body":"### 思路\r\n参考笨猪爆破组\r\n\r\n### 代码\r\n```js\r\nclass ListNode {\r\n  constructor(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.next = null\r\n    this.prev = null\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity\r\n    this.hash = {}\r\n    this.count = 0\r\n    this.dummyHead = new ListNode()\r\n    this.dummyTail = new ListNode()\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyTail.prev = this.dummyHead\r\n  }\r\n\r\n  get(key) {\r\n    let node = this.hash[key]\r\n    if (node == null) return -1\r\n    this.moveToHead(node)\r\n    return node.value\r\n  }\r\n\r\n  put(key, value) {\r\n    let node = this.hash[key]\r\n    if (node == null) {\r\n      if (this.count == this.capacity) {\r\n        this.removeLRUItem()\r\n      }\r\n      let newNode = new ListNode(key, value)\r\n      this.hash[key] = newNode\r\n      this.addToHead(newNode)\r\n      this.count++\r\n    } else {\r\n      node.value = value\r\n      this.moveToHead(node)\r\n    }\r\n  }\r\n\r\n  moveToHead(node) {\r\n    this.removeFromList(node)\r\n    this.addToHead(node)\r\n  }\r\n  \r\n  removeFromList(node) {\r\n    let temp1 = node.prev\r\n    let temp2 = node.next\r\n    temp1.next = temp2\r\n    temp2.prev = temp1\r\n  }\r\n\r\n  addToHead(node) {\r\n    node.prev = this.dummyHead\r\n    node.next = this.dummyHead.next\r\n    this.dummyHead.next.prev = node\r\n    this.dummyHead.next = node\r\n  }\r\n\r\n  removeLRUItem() {\r\n    let tail = this.popTail()\r\n    delete this.hash[tail.key]\r\n    this.count--\r\n  }\r\n\r\n  popTail() {\r\n    let tail = this.dummyTail.prev\r\n    this.removeFromList(tail)\r\n    return tail\r\n  }\r\n}\r\n```\r\n\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(1)\r\n+ 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846406033","body":"### 思路\r\n\r\n层序遍历\r\n\r\n### 代码\r\n```js\r\nif(!root)  return null\r\n    const queue=[root];\r\n    let depth=1;\r\n    while(queue.length){\r\n        const levelLength=queue.length;\r\n        for(let i=0;i<levelLength;i++){\r\n            const cur = queue.shift()\r\n            if(cur.left) queue.push(cur.left)\r\n            if(cur.right) queue.push(cur.right)\r\n        }\r\n       if(queue.length) depth++\r\n    }\r\n    return depth\r\n```\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(N)\r\n+ 空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JianXinyu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840980179","body":"## 思路\r\nqueue是FIFO, stack是LIFO. 用两个栈stack1, stack2。 queue push时就把新元素放入stack1。queue pop或者top的时候就把stack1全部的元素转移到stack2中，因为stack.pop是取出last-in, i.e., top元素，所以stack2会把last-in元素放入栈底，first-in元素放入栈顶，那么对stack2执行pop或top就能得到first-in的元素了。[参考](https://zxi.mytechroad.com/blog/stack/leetcode-232-implement-queue-using-stacks/)\r\n## 代码(C++)\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() { }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        stk1_.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if(stk2_.empty()) move();\r\n        int top = stk2_.top();\r\n        stk2_.pop();\r\n        return top;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if(stk2_.empty()) move();\r\n        return stk2_.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (stk1_.empty() && stk2_.empty());\r\n    }\r\nprivate:\r\n    stack<int> stk1_, stk2_;\r\n    void move(){\r\n        while(!stk1_.empty()){\r\n            stk2_.push(stk1_.top());\r\n            stk1_.pop();\r\n        }\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- Time complexity: \r\n    - worst case: push n个元素进queue，那么第一次调用pop或peek时，复杂度是O(n)\r\n    - best case: 之后再调用pop或peek，复杂度是O(1)\r\n    - average case: 执行>=n次的pop或peek，平均复杂度是O(1)\r\n - Space complexity: 两个stack加起来是n个元素，所以是O(n)  "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841594876","body":"## 思路\r\n题解。\r\n该方法借鉴了Counting Sort, Bucket Sort。\r\n计数数组count: 数组的索引表示值，数组的值表示其对应的出现次数。\r\n为了节省空间，虽然count的index是从0开始，但我们可以加上一个偏移量(arr中的最小值min)，\r\n这样count[0] = 1就表示1在arr中出现了1次。count的长度为max-min+1\r\n\r\n如果一个块能单独排序，那么它在arr中位置和排序后在sorted_arr的位置一样。\r\n\r\n所以对于arr中任意一个块B，其在sorted_arr中对应位置的块是B'，比较B和B'中元素在count中的值。\r\n\r\n- 如果都相等，说明它们其实是同一个块。B可以单独排序。比如B1和B1'\r\n- 如果不相等，那继续扩大块B的范围。比如B0和B0'\r\n\r\n> Crux:  如果两个数组的计数信息是一致的，那么两个数组排序后的结果也是一致的\r\n\r\n那么如何比较两个块对应的count内容呢？\r\n能单独排序的blocks必然是连续的，且它们在arr和sorted_arr中的位置相同，它们对应的count相同。\r\n故而可以先声明两个计数数组，从第一个元素开始遍历arr和sorted_arr，并更新两个计数数组。\r\n\r\n- 一旦两个计数数组相等了，说明我们又遇到了一个新的可排序块\r\n- 不相等就继续\r\n\r\n因此步骤如下：\r\n\r\n1. sort arr -> sorted_arr\r\n2. traverse arr\r\n3. if arr[:i+1]‘s corresponding count array == sorted_arr[:i+1]'s corresponding count array， \r\n   说明我们得到了一个新的可排序的块，ans++ \r\n\r\narr[:i+1] 指的是 arr 的切片，从索引 0 到 索引 i 的一个切片。\r\n\r\n但其实不需要两个计数数组，只需要一个计数数组count，arr增加count元素的值，sorted_arr则减少count元素的值。\r\n记录count中不为0的元素个数。如果是0，说明遇到了一个新的可排序块。\r\n## 代码\r\n```cpp\r\nint maxChunksToSorted(vector<int>& arr) {\r\n     vector<int> sorted_arr = arr;\r\n     sort(sorted_arr.begin(), sorted_arr.end());\r\n     int n = arr.size();\r\n     int min = sorted_arr[0], max = sorted_arr[n-1];\r\n     vector<int> count(max - min + 1, 0);\r\n     int non_zero_cnt = 0;\r\n     int ans = 0;\r\n     for(int i = 0; i < n; ++i){\r\n         int a = arr[i]-min, b = sorted_arr[i]-min;\r\n         \r\n         count[a]++;\r\n         if(count[a] == 0) \r\n             non_zero_cnt--;\r\n         else if(count[a] == 1) //注意一旦一个元素不为零，我们只用cnt++一次\r\n             non_zero_cnt++;\r\n         \r\n         count[b]--;\r\n         if(count[b] == 0)\r\n             non_zero_cnt--;\r\n         else if(count[b] == -1) //同上\r\n             non_zero_cnt++;\r\n         \r\n         if(non_zero_cnt == 0)\r\n             ans++;\r\n         \r\n     }\r\n     return ans;\r\n }   \r\n```\r\n## 复杂度分析\r\nT: 排序是决定因素 O(NlogN)，faster than 5.27%\r\nS: 减少了，但仍然是O(max-min+1)，less than 5.27%\r\n\r\n评价：\r\n这个方法还是很低效的。应该使用单调栈。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841745367","body":"## 思路\r\n首先观察规律：rotate就是把old tail and old head连起来，设置new tail, 再返回new head。题目Constraints中给的k可能远大于链表长度，不妨先遍历一遍链表，找出长度，再取模，避免无意义的遍历列表。\r\n注意链表为0，或者不旋转的corner case。\r\n## Code\r\n```cpp\r\nListNode* rotateRight(ListNode* head, int k) {\r\n\tif(!head || !k) return head;\r\n\tint len = 0;\r\n\tListNode *cur = head, *tail;\r\n\r\n\twhile(cur){\r\n\t\tlen++;\r\n\t\tif(!cur->next) tail = cur;\r\n\t\tcur = cur->next;\r\n\t}\r\n\r\n\tint rotate = k % len;\r\n\tif(!rotate) return head;\r\n\tcur = head;\r\n\tfor(int i = 1; i < len - rotate; ++i){\r\n\t\tcur = cur->next;\r\n\t}\r\n\r\n\ttail->next = head;\r\n\tListNode* newhead = cur->next;\r\n\tcur->next = nullptr;\r\n\r\n\treturn newhead;\r\n}\r\n```\r\n\r\n**复杂度分析**\r\nN为链表长度\r\nT: 遍历了两遍链表，O(N)\r\nS: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841867473","body":"## 思路\r\n用两个指针，将它俩逆转后再小心地和剩余节点连起来。\r\n![24  Swap Nodes in Pairs](https://user-images.githubusercontent.com/33800894/118410487-39f3ce00-b66a-11eb-8f32-54ac35e31d1e.png)\r\n\r\n## Code\r\n```cpp\r\nListNode* swapPairs(ListNode* head) {\r\n\tif(!head || !head->next) return head;\r\n\tListNode dummy(0);\r\n\tdummy.next = head;\r\n\tListNode *prev = &dummy;\r\n\tListNode *cur1 = head;\r\n\tListNode *ans = cur1->next;\r\n\t\r\n\twhile(cur1 && cur1->next){\r\n\t\tListNode *cur2 = cur1->next;\r\n\t\tListNode *next = cur2->next;\r\n\r\n\t\t// swap\r\n\t\tcur2->next = cur1;\r\n\t\tcur1->next = next;\r\n\t\tprev->next = cur2;\r\n\r\n\t\t// update\r\n\t\tprev = cur1;\r\n\t\tcur1 = next;  \r\n\t}\r\n\treturn ans;\r\n}\r\n```\r\n**Complexity Analysis**:\r\nT: O(N)\r\nS: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842803354","body":"## 思路\r\n1. 既然是height-balanced BST, 那必然要从中间均分，所以找中点\r\n2. 如何找中点？\r\n\t1. 遍历一遍，记录长度，取其一半，再遍历到中点\r\n\t2. 快慢指针，快指针移动两步，慢指针移动一步\r\n\t3. 由于需要新建TreeNode, 不需要ListNode, 把ListNode.val存到数组，用空间换时间，这样只需要遍历一遍就好了\r\n3. 将中点设为TreeNode \\*root\r\n4. 对左右两半递归\r\n5. 检查边界情况\r\n\r\n## Code\r\n### 快慢指针找中点: \r\n```cpp\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n\tif(!head) return nullptr;\r\n\treturn build(head, nullptr);\r\n}\r\nTreeNode* build(ListNode* head, ListNode* tail){\r\n\t// 为啥返回nullptr， 见下\r\n\tif(head == tail) return nullptr;\r\n\t// find middle ListNode using fast&slow pointers\r\n\tListNode *fast = head, *slow = head;\r\n\twhile(fast != tail && fast->next != tail){\r\n\t\tfast = fast->next->next;\r\n\t\tslow = slow->next;\r\n\t}\r\n\t// now slow pointer points to the middle node, use it as root\r\n\tTreeNode* root = new TreeNode(slow->val);\r\n\t// recursion\r\n\troot->left = build(head, slow);\r\n\troot->right = build(slow->next, tail);\r\n\treturn root;\r\n}\r\n```\r\n考虑临界情况head->next == tail时，此时slow=head, root->val=head->val。之后递归，在第一个递归中，head还是原来的head'，head=tail，那就不能再返回一次head'了，所以返回nullptr。考虑这个边界情况的时候，不要尝试放在树中考虑，不然会越想越糊涂；应该只是从递归函数返回值的角度。\r\n**Complexity Analysis**\r\nN为链表长度\r\nT: 由于有遍历+递归，所以是$O(NlogN)$\r\nS: $O(1)$\r\n\r\n#### Cache找中点\r\n```cpp\r\nTreeNode* sortedListToBST(ListNode* head) {\r\n\tif(!head) return nullptr;\r\n\t// cache\r\n\tvector<int> nodes;\r\n\twhile(head){\r\n\t\tnodes.push_back(head->val);\r\n\t\thead = head->next;\r\n\t}\r\n\tint n = nodes.size();\r\n\r\n\tfunction<TreeNode*(int, int)> build = [&](int b, int e)->TreeNode*{\r\n\t\tif(b == e) return nullptr;\r\n\t\tint mid = (b+e) / 2;\r\n\t\tTreeNode *root = new TreeNode(nodes[mid]);\r\n\t\troot->left = build(b, mid);\r\n\t\troot->right = build(mid+1, e);\r\n\t\treturn root;\r\n\t};\r\n\t// note: n, rather than n-1\r\n\treturn build(0, n);\r\n}\r\n```\r\n为什么是n而不是n-1呢？\r\n直觉上，对比快慢指针法，其中的tail其实是最后一个节点的next。\r\n另一方面，用了n-1的话，因为mid=(b+e)/2是向下取整，所以mid不会等于n-1，root->val就不会是nodes\\[n-1\\]；尽管mid+1可以等于n-1，但此时直接返回nullptr了，不会再设置root。\r\n\r\n**Complexity Analysis**\r\nT: $O(N)$\r\nS: $O(N)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843631672","body":"# Solution 1\r\n## 思路\r\n1. 先遍历链表A，\r\n2. 由于题目Constraints有$1 <= Node.val <= 10^5$, 将经过的节点值减去$10^5$，作为经过的标记\r\n3. 再遍历链表B，第一个节点值$\\leq 0$的，就是相交点\r\n4. 由于题目要求不能修改输入链表，我们再改回去，即链表A的节点值$+10^5$\r\n## Code\r\n```cpp\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n\tif(!headA || !headB) return nullptr;\r\n\tListNode *cur = headA;\r\n\twhile(cur){\r\n\t\tcur->val -= 1e5;\r\n\t\tcur = cur->next;\r\n\t}\r\n\r\n\tListNode *ans = headB;\r\n\twhile(ans && ans->val > 0){\r\n\t\tans = ans->next;\r\n\t}\r\n\r\n\tcur = headA;\r\n\twhile(cur){\r\n\t\tcur->val += 1e5;\r\n\t\tcur = cur->next;\r\n\t}\r\n\treturn ans;\r\n}\r\n```\r\n**Complexity Analysis:**\r\nT: $O(N)$\r\nS: $O(1)$\r\n\r\n# Solution 2\r\n## 思路\r\n该方法来自题解。\r\n-   先遍历 A 链表, 并将 A 中的所有节点存入哈希表。\r\n-   再遍历 B 链表,检查节点是否在哈希表中, 第一个存在的就是相交节点\r\n\r\n## Code\r\n```cpp\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n\tunordered_map<ListNode *, int> m;\r\n\twhile(headA){\r\n\t\tm[headA] = headA->val;\r\n\t\theadA = headA->next;\r\n\t}\r\n\r\n\twhile(headB){\r\n\t\tif(m.count(headB))\r\n\t\t\treturn headB;\r\n\t\theadB = headB->next;\r\n\t}\r\n\treturn nullptr;\r\n}\r\n```\r\n**Complexity Analysis:**\r\nT: $O(N)$\r\nS: $O(N)$\r\n\r\n# Solution 3\r\n## 思路\r\n该方法来自题解。\r\n例如使用 a, b 两个指针分别指向 A, B 这两条链表, 两个指针以相同的速度向后移动\r\n-   当 a 到达链表的尾部时,重定位到链表 B 的头结点\r\n-   当 b 到达链表的尾部时,重定位到链表 A 的头结点。\r\n-   a, b 指针相遇的点为相交的起始节点，否则没有相交点 \r\n## Code\r\n```cpp\r\nListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n\tif(!headA || !headB) return nullptr;\r\n\tListNode *curA = headA, *curB = headB;\r\n\twhile(curA != curB){\r\n\t\tcurA = curA ? curA->next : headB;\r\n\t\tcurB = curB ? curB->next : headA;\r\n\t}\r\n\treturn curA;\r\n}\r\n```\r\n\r\n为啥不是`curA = curA->next ? curA->next : headB;`?\r\n如果这样的话，那curA和curB就不会是nullptr。如此一来，如果两个链表不相交，那么就会`curA!=curB`永远成立，陷入死循环。实际上，使用nullptr相当于让两个链表必然相交，i.e., 相交的长度至少是1。这样就避免了讨论特殊情况。\r\n**Complexity Analysis:**\r\nT: $O(N)$\r\nS: $O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844583047","body":"## 思路\r\n- 定义一个 fast 指针,每次前进两步,一个 slow 指针,每次前进一步\r\n- 当两个指针相遇时:\r\n\t- 将 fast 指针指向链表头部,同时 fast 指针每次只前进一步\r\n\t- slow 指针继续前进,每次前进一步\r\n- 当两个指针再次相遇时,当前节点就是环的入口\r\n\r\n## Code\r\n```cpp\r\nListNode *detectCycle(ListNode *head) {\r\n\tif(!head || !head->next) return nullptr;\r\n\tListNode *fast = head, *slow = head;\r\n\tdo{\r\n\t\tif(fast && fast->next)\r\n\t\t\tfast = fast->next->next;\r\n\t\telse\r\n\t\t\tfast = nullptr;\r\n\t\tslow = slow->next;\r\n\t} while(fast != slow);\r\n\t// if fast and slow are null\r\n\tif(!fast) return nullptr;\r\n\tfast = head;\r\n\twhile(fast != slow){\r\n\t\tfast = fast->next;\r\n\t\tslow = slow->next;     \r\n\t}\r\n\treturn fast;\r\n}\r\n```\r\n在这里，do-while要比while好，不然还要在while前移动指针。\r\n**Complexity Analysis**\r\nT: $O(N)$\r\nS: $O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845345541","body":"## 思路\r\n来源于91题解。\r\n1.  确定需要使用的数据结构\r\n    1.  根据题目要求,存储的数据需要保证顺序关系(逻辑层面) ===> 使用数组,链表等保证循序关系\r\n    2.  同时需要对数据进行频繁的增删, 时间复杂度 O(1) ==> 使用链表等\r\n    3.  对数据进行读取时, 时间复杂度 O(1) ===> 使用哈希表\r\n        最终采取双向链表 + 哈希表\r\n        > 1.  双向链表按最后一次访问的时间的顺序进行排列, 链表头部为最近访问的节点\r\n        > 2.  哈希表,以关键字为键,以链表节点的地址为值  \r\n    \r\n2.  put 操作\r\n    通过哈希表, 查看传入的关键字对应的链表节点, 是否存在\r\n    1.  如果存在,\r\n        1.  将该链表节点的值更新\r\n        2.  将该该链表节点调整至链表头部\r\n    2.  如果不存在\r\n        1.  如果链表容量未满,\r\n            1.  新生成节点,\r\n            2.  将该节点位置调整至链表头部\r\n        2.  如果链表容量已满\r\n            1.  删除尾部节点\r\n            2.  新生成节点\r\n            3.  将该节点位置调整至链表头部\r\n        3.  将新生成的节点，按关键字为键，节点地址为值插入哈希表\r\n    \r\n3.  get 操作\r\n    通过哈希表, 查看传入的关键字对应的链表节点, 是否存在\r\n    1.  节点存在\r\n        1.  将该节点位置调整至链表头部\r\n        2.  返回该节点的值\r\n    2.  节点不存在, 返回 null\r\n\r\n## Code\r\n```cpp\r\n\r\nclass LRUCache {\r\n\r\npublic:\r\n    LRUCache(int capacity) {\r\n        capacity_ = capacity;\r\n    }\r\n\r\n    int get(int key) {\r\n        const auto itr = m_.find(key);\r\n\r\n        // key doesn't exist\r\n        if(itr == m_.end()) return -1;\r\n\r\n        // Move the key to the front of the cache\r\n        cache_.splice(cache_.begin(), cache_, itr->second);\r\n        return itr->second->second;\r\n\r\n    }\r\n\r\n    void put(int key, int value) {\r\n        const auto itr = m_.find(key);\r\n        // if key exists\r\n        if( itr != m_.end()){\r\n            // update value\r\n            itr->second->second = value;\r\n            // move the key to the front of the cache\r\n            cache_.splice(cache_.begin(), cache_, itr->second);\r\n            return;\r\n        }\r\n\r\n        // check capacity, remove the LRU entry\r\n        if(cache_.size() == capacity_){\r\n            const auto& node = cache_.back();\r\n            m_.erase(node.first);\r\n            cache_.pop_back();\r\n        }\r\n\r\n        // insert the entry to the front of the cache\r\n        cache_.emplace_front(key, value);\r\n        m_[key] = cache_.begin();\r\n    }\r\n\r\nprivate:\r\n    int capacity_;\r\n    list<pair<int, int>> cache_;\r\n    unordered_map<int, list<pair<int, int>>::iterator> m_;\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache* obj = new LRUCache(capacity);\r\n * int param_1 = obj->get(key);\r\n * obj->put(key,value);\r\n */\r\n```\r\n\r\n**Complexity Analysis**\r\nT: O(1)\r\nS: O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846333400","body":"## 思路\r\n声明一个全局变量记录当前遍历的最大深度depth；DFS遍历，记录当前深度d，如果大于depth，那么更新depth.\r\n## Code\r\n```cpp\r\nint maxDepth(TreeNode* root) {\r\n\tint depth = 0;\r\n\tfunction<void(TreeNode*, int)> dfs = [&](TreeNode* r, int d){\r\n\t\tif(!r) return;\r\n\t\tif(d > depth) depth = d;\r\n\t\tdfs(r->left, d+1);\r\n\t\tdfs(r->right, d+1);\r\n\t};\r\n\tdfs(root, 1);\r\n\treturn depth;\r\n}\r\n```\r\n**Complexity Analysis**\r\nT: O(N) N为节点数\r\nS: O(h) h为树的深度，worst case h = N"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"PeopleWhoListenToStories":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-840997718","body":"> cv第二天\r\n```js\r\n  var MyQueue = /** @class */ (function () {\r\n      function MyQueue() {\r\n          this.stack = [];\r\n      }\r\n      MyQueue.prototype.push = function (value) {\r\n          this.stack.push(1);\r\n      };\r\n      MyQueue.prototype.peek = function () {\r\n          return this.stack[0];\r\n      };\r\n      MyQueue.prototype.pop = function () {\r\n          this.stack.pop();\r\n      };\r\n      MyQueue.prototype.empty = function () {\r\n          return !this.stack.length;\r\n      };\r\n      return MyQueue;\r\n  }());\r\n  var obj = new MyQueue();\r\n  obj.push(0);\r\n  obj.push(1);\r\n  obj.pop();\r\n  console.log(obj.peek());\r\n  console.log(obj);\r\n```"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845205642","body":"function CircularList(head) {\r\n    let slow = head;\r\n    let fast = head;\r\n    while (fast) {\r\n        if (fast.next == null) { // fast.next走出链表了，说明无环\r\n            return null;\r\n        }\r\n        slow = slow.next;        // 慢指针走一步\r\n        fast = fast.next.next;   // 慢指针走一步\r\n        if (slow == fast) {      // 首次相遇\r\n            fast = head;           // 让快指针回到头节点\r\n            while (true) {         // 开启循环，让快慢指针相遇\r\n                if (slow == fast) {  // 相遇，在入环处\r\n                    return slow;\r\n                }\r\n                slow = slow.next;\r\n                fast = fast.next;    // 快慢指针都走一步\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zeningc":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841089348","body":"### 思路\r\n\r\n栈是一个后进先出的结构，队列是一个先进先出的结构。因此，出队操作时需要倒栈，将所有元素倒序加入另一个栈即可解决先进先出的问题\r\n\r\n### 代码\r\n\r\n\r\n```py\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return len(self.stack2)+len(self.stack1)==0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(2N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841135443","body":"## 思路\r\n第二次刷这题，顺利完成。利用两个栈操作。\r\n## 关键点\r\n从题解中看到这段，有丝丝明白为什么要用两个栈来实现一个队列，因为多线程可以分开同一个队列的读写操作。\r\n\r\n实际上现实中也有使用两个栈来实现队列的情况，那么为什么我们要用两个 stack 来实现一个 queue？\r\n\r\n其实使用两个栈来替代一个队列的实现是为了在多进程中分开对同一个队列对读写操作。一个栈是用来读的，另一个是用来写的。当且仅当读栈满时或者写栈为空时，读写操作才会发生冲突。\r\n\r\n当只有一个线程对栈进行读写操作的时候，总有一个栈是空的。在多线程应用中，如果我们只有一个队列，为了线程安全，我们在读或者写队列的时候都需要锁住整个队列。而在两个栈的实现中，只要写入栈不为空，那么push操作的锁就不会影响到pop。\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n        Stack<Integer> stack1 ;\r\n        Stack<Integer> stack2 ;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1 = new Stack();\r\n        stack2 = new Stack();\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        while(!stack1.isEmpty()){\r\n            stack2.push(stack1.pop());\r\n        }\r\n        stack2.push(x);\r\n        while(!stack2.isEmpty()){\r\n            stack1.push(stack2.pop());\r\n        }\r\n\r\n\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack1.isEmpty()){\r\n            return 0;\r\n        }\r\n        return stack1.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack1.isEmpty()){\r\n            return 0;\r\n        }\r\n        return stack1.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack1.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$//入队时间复杂度为O（n）,出队O（1），判断空O（1），队首O（1）；看题解均摊时间复杂度是O（1），后面有时间再看一下。\r\n- 空间复杂度：$O(n)$\r\n"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842065121","body":"## 思路\r\n由于头结点被修改，因此通过添加头部虚拟节点来进行操作。其中，个人比较纠结的是return NullHead.next和return head;最后明白在 first.next = node2;这一句中，head一直是1的地址（举例输入[1,2,3,4]），NullHead和first指向了2（也就是修改后的头结点），然后在first = node1;中，first是1的地址。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null){\r\n            return head;\r\n        }\r\n        if(head.next == null){\r\n            return head;\r\n        }\r\n        //how确定奇数节点与偶数节点，通过添加一个头节点，\r\n        ListNode NullHead=new ListNode(0);\r\n        NullHead.next=head;\r\n        ListNode first = NullHead;\r\n\r\n        while(first.next!=null && first.next.next!=null){\r\n            ListNode node1 = first.next;\r\n            ListNode node2  = first.next.next;\r\n\r\n            first.next = node2;\r\n            node1.next = node1.next.next;\r\n            node2.next = node1;\r\n\r\n            first = node1;\r\n\r\n        }\r\n        return NullHead.next;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843109689","body":"## 思路\r\n由于需要根据链表构建平衡二叉树，那么取链表的中点作为根，左右两边子链表作为左右子树，则可以达到平衡。递归的查找左边子链表再构建一棵树，持续下去。\r\n比较巧妙的是这里使用双指针，快指针每次走两步，慢指针一次走一步，当快指针遍历完成链表之后，慢指针刚好到链表中点。递归地获取每次子链表的中点。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        //\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        return run(head,null);\r\n    }\r\n\r\n    public TreeNode run(ListNode head,ListNode tail){\r\n        if(head == tail){\r\n            return null;\r\n        }\r\n        ListNode fast = head;\r\n        ListNode slow = head;\r\n        ListNode preSlow = head;\r\n        while(fast!=tail && fast.next!=tail){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        TreeNode root = new TreeNode(slow.val);\r\n        root.left = run(head,slow);\r\n        root.right = run(slow.next,tail);\r\n        return root;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(nlogn)$\r\n- 空间复杂度：$O(logn)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843730755","body":"\r\n## 思路\r\n1. 使用hash表，首先遍历链1，将每个节点存入hash中，然后遍历链2，如果该节点在hash中存在，则是相交节点。\r\n2. 设置两个指针从两个链表头开始，以相同的时间，相同的速度前进，指针1走短链，指针2走长链。当指针1短链到达终点时，则指针1置位到长链初始；同样当长链到达终点时，则指针2置位到短链初始。若两链有交点，则可两个指针从交点处以后会携手同行，即相遇。若两链没有交点，则在最后，同时到达空节点。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        HashMap<ListNode,Integer> map = new HashMap();\r\n        ListNode tempA = headA;\r\n        ListNode tempB = headB;\r\n        while(tempA!=null){\r\n            map.put(tempA,1);\r\n            tempA = tempA.next;\r\n        }\r\n        while(tempB!=null){\r\n            if(map.containsKey(tempB)){\r\n                return tempB;\r\n            }\r\n            tempB = tempB.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n+m)$\r\n- 空间复杂度：$O(n)$\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        //HashMap<ListNode,Integer> map = new HashMap();\r\n        ListNode tempA = headA;\r\n        ListNode tempB = headB;\r\n        while(tempA!=tempB){\r\n            tempA = tempA!=null?tempA.next:headB;\r\n            tempB = tempB!=null?tempB.next:headA;\r\n        }\r\n        return tempB;\r\n    }\r\n}\r\n\r\n\r\n```\r\n- 时间复杂度：$O(n+m+n+m)$//遍历链表两遍\r\n- 空间复杂度：$O(1)$"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845221861","body":"\r\n## 思路\r\n双指针法，首先判断输入链表是否为空，或者只有一个节点，这样是无法成环直接返回null。接着快指针一次走两步，慢指针一次走一步。当第一次相遇的时候，可以得到如下公式：\r\nfast：path+E+fastL\r\nslow: path+E+slowL\r\n由于fast等于2slow\r\n所以\r\n（fast-2slow）L = path+E\r\n则 path = L-E\r\n所以将fast置为head,每次走一步，slow在相遇的地方继续往前走，再次相遇的地方就是入口点。\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n\r\n        ListNode fast=head;\r\n        ListNode slow = head;\r\n\r\n        do{\r\n            if(fast==null || fast.next==null){\r\n                return null;\r\n            }\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }while(fast!=slow);\r\n        //如果不存在环\r\n        if(fast==null){\r\n            return null;\r\n        }\r\n        fast=head;\r\n        while(fast!=slow){\r\n            fast = fast.next;\r\n            slow = slow.next;\r\n        }\r\n        return fast;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n\r\n## hash法\r\n- 思路比较简单，都存一边进入哈希集合，如果当前节点已经存在，则说明该节点是环的入口。\r\n\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head ==null || k ==0 || head.next == null){\r\n            return head;\r\n        }\r\n        int n = 1;//节点数\r\n        ListNode iter = head;\r\n        while(iter.next!=null){\r\n\r\n            iter = iter.next;\r\n            n++;\r\n        }\r\n        ListNode oldtail = iter;\r\n        oldtail.next = head;\r\n        int tail = n-k%n;\r\n\r\n        while(tail-->0){\r\n            iter = iter.next;\r\n        }\r\n        ListNode res = iter.next;\r\n        iter.next = null;\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845808360","body":"## 思路\r\n1. 看题解，理解了为什么使用hash和双向链表\r\n2.  手动实现链表\r\n3.  get函数，首先判断hash中存在则返回value，不存在则添加，并且把该节点放到链的第一个节点。所以需要实现一个添加到链表第一个节点的函数addToHead()。\r\n4.  put函数, 首先判断，是否存在，如果存在则将value值修改即可（注意不是更新节点，这里坑了）。然后不存在，则添加，new一个链表节点，放到hash表中，size+1，并把该节点放到链表的第一个节点。添加之后，判断size是否大于容量，如果大于，则将链表最后一个删除。hash表中删除，size-1.\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass LRUCache {\r\n    //实现一个链表\r\n    class LinkedNode{\r\n        int key;\r\n        int value;\r\n        LinkedNode pre;\r\n        LinkedNode next;\r\n        public LinkedNode(){}\r\n        public LinkedNode(int key,int value){\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n    }\r\n\r\n    private int capacity;\r\n    private int size;\r\n    private LinkedNode head,tail;\r\n    private HashMap<Integer,LinkedNode> cache = new HashMap();\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size=0;\r\n        this.capacity = capacity;\r\n        head = new LinkedNode();\r\n        tail = new LinkedNode();\r\n        head.next = tail;\r\n        tail.pre = head;\r\n\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if(cache.containsKey(key)){\r\n            LinkedNode temp = cache.get(key);\r\n            //\r\n            moveToHead(temp);\r\n            return temp.value;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n\r\n        if(cache.containsKey(key)){\r\n            //LinkedNode node = new LinkedNode(key,value);\r\n            //cache.put(key,node);\r\n            LinkedNode temp = cache.get(key);\r\n            temp.value = value;\r\n            moveToHead(temp);\r\n        }else{\r\n            //没有包含，则添加\r\n            size = size+1;\r\n            LinkedNode newNode = new LinkedNode(key,value);\r\n            cache.put(key,newNode);\r\n            addToHead(newNode);\r\n            if(size>capacity){\r\n                //如果大于容量，则删除最后一个节点\r\n                LinkedNode last = tail.pre;\r\n                delLast(last);\r\n                cache.remove(last.key);\r\n                --size;\r\n            }\r\n        }\r\n\r\n    }\r\n    public void delLast(LinkedNode node){\r\n        node.pre.next = node.next;\r\n        node.next.pre = node.pre;\r\n    }\r\n    public void addToHead(LinkedNode node){\r\n        node.pre = head;\r\n        node.next = head.next;\r\n        head.next.pre = node;\r\n        head.next = node;\r\n    }\r\n    public void moveToHead(LinkedNode node){\r\n        //System.out.println(node.next==tail);\r\n        //System.out.println(node.value);\r\n        node.pre.next = node.next;\r\n        node.next.pre = node.pre;\r\n\r\n        node.pre = head;\r\n        node.next = head.next;\r\n        head.next.pre = node;\r\n        head.next = node;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n\r\n //调整到头部的函数\r\n //需要自己实现链表吗？\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846351620","body":"## 思路\r\n递归法和层次遍历。遇到树的题目，首先想想递归，慢慢领悟递归怎么用。\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        //bfs,层次遍历\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n \r\n        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(height)$//递归需要栈空间，树的高度就是栈的空间使用\r\n\r\n\r\n### dfs层次遍历\r\n- 思路\r\n> 这个比较明显可以用层次遍历，有多少层，高度即为多少；只是要注意的是，如何知道每一层的结束呢？因为队列只会保存当前层的节点个数，所以可以获取当前队列的size，然后size--，到0的时候，说明一层结束，层数加1.\r\n\r\n\r\n```java\r\n\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n\r\n */\r\n /*递归dfs遍历\r\n  if(root == null){\r\n            return 0;\r\n        }\r\n        return 1+Math.max(maxDepth(root.left),maxDepth(root.right));\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n       if(root == null){\r\n           return 0;\r\n       }\r\n       Queue<TreeNode> queue = new LinkedList<>();\r\n       TreeNode node;\r\n       int res = 0;\r\n       int size;\r\n       queue.offer(root);\r\n       while(!queue.isEmpty()){\r\n           size = queue.size();\r\n           \r\n           while(size-->0){\r\n               node = queue.poll();\r\n               if(node.left != null){\r\n                    queue.add(node.left);\r\n                }\r\n                if(node.right != null){\r\n                    queue.add(node.right);\r\n                }\r\n                \r\n           }\r\n           \r\n           res++;\r\n\r\n           \r\n       }\r\n       return res;\r\n     }\r\n\r\n}\r\n\r\n\r\n\r\n```\r\n时间复杂度O(n)\r\n空间复杂度O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"DANG-PingBo":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841185354","body":"#50 \r\n\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1, self.stack2 = [], []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self):\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self):\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n\r\n字节原题......"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841663916","body":"## 我只能说这个解法真是nb，叹为观止\r\n\r\n\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: \r\n                ans += 1\r\n\r\n        return ans\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度: O(n^2)\r\n- 空间复杂度: O(n)\r\n- (懒得优化了)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841827087","body":"## 双指针+余数处理\r\n## 编程语言: Python\r\n\r\n``` python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        if not head or not head.next: return head\r\n        len_list = 0\r\n        cur = head\r\n        while cur:\r\n            cur = cur.next\r\n            len_list += 1\r\n        k = k % len_list\r\n        if k == 0: return head\r\n\r\n        slow = fast = head\r\n        while k > 0:\r\n            fast = fast.next\r\n            k -= 1\r\n\r\n        while fast.next:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        newHead = slow.next\r\n        fast.next = head\r\n        slow.next = None\r\n        return newHead\r\n```\r\n复杂度分析\r\n\r\n- 时间复杂度：O（N）\r\n\r\n- 空间复杂度：O（1）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841202056","body":"### 代码\r\n\r\n- 支持语言：python\r\n\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk = []\r\n        self.help_stk = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        while self.stk:\r\n            self.help_stk.append(self.stk.pop())\r\n        self.help_stk.append(x)\r\n        while self.help_stk:\r\n            self.stk.append(self.help_stk.pop())\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        return self.stk.pop()\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        return self.stk[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not bool(self.stk)\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841823810","body":"看着题解，理解着写\r\n\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if head :\r\n            p1 = head\r\n            p2 = head \r\n            count = 1\r\n            i = 0 \r\n            while i<k :\r\n                if p2.next:\r\n                    count += 1 \r\n                    p2 = p2.next\r\n                else:\r\n                    k = k % count\r\n                    i = -1 \r\n                    p2 = head\r\n                i += 1\r\n\r\n            while p2.next:\r\n                p2 = p2.next\r\n                p1 = p1.next\r\n\r\n            if p1.next:\r\n                tmp = p1.next\r\n            else:\r\n                return head \r\n            p1.next = None\r\n            p2.next = head\r\n\r\n            return tmp\r\n```"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845101586","body":"### 思路\r\n参考题解快慢指针\r\n\r\n```\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        slow = fast = head\r\n        x = None\r\n\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            slow = slow.next\r\n            if fast == slow:\r\n                x = slow\r\n                break\r\n        if not x :\r\n            return None\r\n        fast = head\r\n        while fast != x:\r\n            fast = fast.next\r\n            x = x.next\r\n        return fast\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841225456","body":"/** use two stack to implement queue: outStack and inStack. Time complexity: o(1) for all methods. amortized for pop and peek method.\r\n*/\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    Stack<Integer> inStack;\r\n    Stack<Integer> outStack;\r\n    public MyQueue() {\r\n        inStack = new Stack<>();\r\n        outStack = new Stack<>();   \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n      inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(!outStack.isEmpty()) return outStack.pop();\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!outStack.isEmpty()) return outStack.peek();\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n}"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845153178","body":"/*Fast and slow pointer*/\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode  fast = head ,slow = head;\r\n        while(true){\r\n            if(fast == null || fast.next == null){\r\n                return null;\r\n            }else{\r\n                fast = fast.next.next;\r\n                slow = slow.next;\r\n                if(fast == slow){\r\n                    break;\r\n                }    \r\n            }\r\n        }\r\n            fast = head;\r\n            while(slow != fast){\r\n                slow = slow.next;\r\n                fast = fast.next;\r\n            }\r\n             return fast;\r\n    }\r\n}\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845657050","body":"```\r\nclass Node {\r\n        int key;\r\n        int value;\r\n        Node pre;\r\n        Node next;\r\n        \r\n        public Node (int key, int value){\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n    }\r\n\r\nclass DoubleList {\r\n    Node head;\r\n    Node tail;\r\n    int size;\r\n    \r\n    public DoubleList(int size){\r\n         this.size = size;\r\n        head = new Node(-1,-1);\r\n        tail = new Node(-1,-1);\r\n        head.next = tail;\r\n        tail.pre = head;\r\n       \r\n    }\r\n    \r\n    public void remove(Node node){\r\n        node.pre.next = node.next;\r\n        node.next.pre = node.pre;\r\n        size --;\r\n    }\r\n    \r\n    public void addFirst(Node node){\r\n        node.next = head.next;\r\n        node.pre = head;\r\n        head.next.pre = node;\r\n        head.next = node;\r\n        size ++;\r\n    }\r\n    \r\n    public Node removeLast(){\r\n        if (tail.pre == head){\r\n            return null;\r\n        }\r\n        Node node = tail.pre;\r\n        remove(node);\r\n        return node;\r\n    }\r\n    \r\n    public int getSize(){\r\n        return this.size;\r\n    }\r\n}\r\n\r\nclass LRUCache {\r\n    HashMap<Integer, Node> map;\r\n    DoubleList cache;\r\n    int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n        map = new HashMap<>();\r\n        cache = new DoubleList(0);\r\n    }\r\n    \r\n    public int get(int key) {\r\n        if (!map.containsKey(key)) return -1;\r\n        Node node = map.get(key);\r\n        int value = node.value;\r\n        put(key, value);\r\n        return value;    \r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)){\r\n            Node cur = map.get(key);\r\n            cache.remove(cur);\r\n            cur.value = value;\r\n            map.put(key,cur);\r\n            cache.addFirst(cur);\r\n            return;\r\n        }\r\n        if(cache.getSize() == capacity){\r\n            Node last = cache.removeLast();\r\n            map.remove(last.key);\r\n        }\r\n        Node nodeAdd = new Node(key, value);\r\n        map.put(key, nodeAdd);\r\n        cache.addFirst(nodeAdd);   \r\n    }\r\n}\r\n```\r\n\r\n- 时间复杂度：O(1)\r\n  - 空间复杂度：O(n)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846335420","body":"```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) return 0;\r\n        int left = maxDepth(root.left);\r\n        int right = maxDepth(root.right);\r\n        return Math.max(left,right) + 1;        \r\n    }\r\n}\r\n```\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(h)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"He1xin":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841236637","body":"__思路__\r\n用两个栈 tem，deque；push()只往deque里加；pop()和peek()借助tem得到deque底部元素，之后再将元素填往deque；empty()只判断deque是否为空就好。\r\n**代码（Java）**\r\n```java\r\nclass MyQueue {\r\n    private ArrayDeque<Integer> deque;\r\n    private ArrayDeque<Integer> tem;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        deque=new ArrayDeque<>();\r\n        tem=new ArrayDeque<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {        \r\n        deque.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        int size=deque.size();\r\n        for(int i=1;i<size;i++){\r\n            tem.push(deque.pop());\r\n        }\r\n        int ans=deque.pop();\r\n        for(int i=1;i<size;i++){\r\n            deque.push(tem.pop());\r\n        }\r\n        return ans;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        int size=deque.size();\r\n        for(int i=0;i<size;i++){\r\n            tem.push(deque.pop());\r\n        }\r\n        int ans=tem.peek();\r\n        for(int i=0;i<size;i++){\r\n            deque.push(tem.pop());\r\n        }\r\n        return ans;\r\n\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return deque.isEmpty();\r\n    }\r\n}\r\n```\r\n**时间复杂度**\r\npop()和peek()为O(n)。push()和empty()为O(1)。"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842334499","body":"**思路**\r\n递归法\r\n**代码（Java）**\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head==null || head.next==null){\r\n            return head;\r\n        }\r\n        ListNode hnext=head.next;\r\n        head.next=swapPairs(hnext.next);\r\n        hnext.next=head;\r\n        return hnext;\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n* Time O(n)\r\n* Space O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843107229","body":"**代码（Java）**\r\n```java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        return buildTree(head,null);\r\n    }\r\n    public TreeNode buildTree(ListNode left,ListNode right){\r\n        if (left == right) {\r\n            return null;\r\n        }\r\n        ListNode mid = getMedian(left, right);\r\n        TreeNode root = new TreeNode(mid.val);\r\n        root.left = buildTree(left, mid);\r\n        root.right = buildTree(mid.next, right);\r\n        return root;\r\n    }\r\n    public ListNode getMedian(ListNode left,ListNode right){\r\n        ListNode f=left;\r\n        ListNode s=left;\r\n        while(f != right && f.next != right){\r\n            f=f.next.next;\r\n            s=s.next;\r\n        }\r\n        return s;\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n* Time O(n logn )\r\n* Space O(log n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844237611","body":"**代码（java）**\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode A=headA;\r\n        ListNode B=headB;\r\n        int An=0,Bn=0;\r\n        while(An<2 && Bn<2){\r\n            if(A==B) return A;\r\n            if(A==null){\r\n                A=headB;\r\n                An++;\r\n            }else if(B==null){\r\n                B=headA;\r\n                Bn++;\r\n            }else{\r\n                A=A.next;\r\n                B=B.next;\r\n            }\r\n        }\r\n        return null; \r\n    }\r\n}\r\n```\r\n**复杂度**\r\n- Time:O(n)\r\n- Space:O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Moin-Jer":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841297330","body":"#### 思路：\r\n栈有先进后出的特点，队列有先进现出的特点，此题目主要考察如何让一个被压在底下的元素先取出来。\r\n因为需要取到的元素是被压在最底下的，那么想要取出最底下的元素就必须把它上面的元素想弹出，由于最先弹出的是最后进栈的，同时它也应该是最后出队列的元素，即相当与把现有的最前的元素放到最后，所以需要做的是把首尾的元素位置进行互换，如果是数组使用双指针即可简单解决位置互换问题，但是栈的这个数据结构限制了只能从一端进行读写操作，此时想要把元素进行互换，可以把原来的元素都拉出来，在重新圧入到一个新的栈中。\r\n#### 代码\r\n```\r\nclass MyQueue {\r\n\r\n    Deque<Integer> in, out;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        in = new LinkedList<>();\r\n        out = new LinkedList<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        in.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.add(in.poll());\r\n            }\r\n        }\r\n        return out.poll();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            while (!in.isEmpty()) {\r\n                out.add(in.poll());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n```\r\n#### 复杂度：\r\n时间复杂度：　Ｏ（１）\r\n空间复杂度：　Ｏ（Ｎ）　"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841826784","body":"##### 思路\r\n把链表看成环形链表，旋转即是将末尾的节点绕到前面，所以只要知道链表的长度， 以及旋转的个数，那么就可以从最后往前倒数，返回此时的节点即可，不过还需要将最后的节点链接到头节点。\r\n如果链表为空，或者旋转的个数小于等于0,直接返回即可。\r\n由于把链表看成环形链表，那么绕环旋转n圈链表不变，只需要计算出链表的长度，然后旋转 k % 链表长度 即可。\r\n旋转链表时，思路是定位到要返回的头节点的前一个节点，因为此时已经知道要旋转的个数，可以使用快慢指针，快指针先走k个节点，然后慢指针再从头节点出发，当快指针到达尾节点时，慢指针指向要返回的头节点的前一个节点，此时将快指针指向头节点，保留慢指针的下一节点，再将慢指针的下一节点置空，返回保留的那一个节点即可。\r\n##### 代码\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || k <= 0) {\r\n            return head;\r\n        }\r\n        int len = 0;\r\n        ListNode p = head;\r\n        while (p != null) {\r\n            len++;\r\n            p = p.next;\r\n        }\r\n        k = k % len;\r\n        if (k <= 0) {\r\n            return head;\r\n        }\r\n        p = head;\r\n        while (k > 0) {\r\n            p = p.next;\r\n            k--;\r\n        }\r\n        ListNode cur = head;\r\n        while (p != null && p.next != null) {\r\n            cur = cur.next;\r\n            p = p.next;\r\n        }\r\n        p.next = head;\r\n        p = cur.next;\r\n        cur.next = null;\r\n        return p;\r\n    }\r\n}\r\n```\r\n##### 复杂度分析\r\n时间复杂度：O（N）\r\n空间复杂度：O（1）"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844182922","body":"### 思路\r\n两个链表寻找相交的节点，一次遍历是无法定位到相交节点的，因为相交节点之前的节点数不同，不过相交节点后的节点，两个链表都需要依次遍历，所以如果能定位到相同的节点，那么该节点一定是相交节点最开始的那个。知道两个指针分别对两个链表进行遍历，最后一定会一起到达两条链表的尾节点，也即是到达相交的节点。\r\n### 代码\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        if (headA == null || headB == null) {\r\n            return null;\r\n        }\r\n        ListNode currA = headA, currB = headB;\r\n        while (currA != currB) {\r\n            currA = currA == null ? headB : currA.next;\r\n            currB = currB == null ? headA : currB.next;\r\n        }\r\n        return currA;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度： O（M +  N）\r\n空间复杂度：O（1）"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846369582","body":"#### 思路\r\n计算二叉树的最大深度，可分解为计算根节点左子节点的深度 以及 根节点右子节点的深度，此时根节点的深度即为左右子节点的最大深度加上根节点这一层\r\n#### 代码\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        }\r\n        int leftDepth = maxDepth(root.left);\r\n        int rightDepth = maxDepth(root.right);\r\n        return Math.max(leftDepth, rightDepth) + 1;\r\n    }\r\n}\r\n```\r\n#### 复杂度分析\r\n时间复杂度：O（N）\r\n空间复杂度：空间复杂度主要是递归调用栈，复杂度与二叉树的高度相关"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"LambertCao":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841307971","body":"以前做过这题\r\n```\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        //先把B中的元素倒回到A中去\r\n        while(!B.empty()){\r\n            A.push(B.top());\r\n            B.pop();\r\n        }\r\n        A.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        //将A中的内容移到B上去\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        if(B.empty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            int A = B.top();\r\n            B.pop();\r\n            return A;\r\n        }\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        //将A中的内容移到B上去\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        if(B.empty()){\r\n            return -1;\r\n        }\r\n        else{\r\n            return B.top();\r\n        }\r\n    }\r\n    \r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        while(!A.empty()){\r\n            B.push(A.top());\r\n            A.pop();\r\n        }\r\n        return B.empty();\r\n    }\r\npublic:\r\n    stack<int> A;\r\n    stack<int> B;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841617021","body":"今天这题，一直在想着如何用分治的思想去做，比如用到归并再统计逆序对，但是忽略了逆序对算分组数需要回溯，这样就太麻烦了，裂开，下次不能再看到困难题就往复杂的地方想了。\r\n此题解法用单调栈，计数优化值得借鉴\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> S;\r\n        for(int i = 0;i<arr.size();++i){\r\n            if(S.empty()){\r\n                S.push(arr[i]);\r\n            }\r\n            else{\r\n                if(arr[i]<S.top()){\r\n                    int maxvalue = INT16_MIN;\r\n                    while(!S.empty()&&S.top()>arr[i]){\r\n                        maxvalue = max(S.top(),maxvalue);\r\n                        S.pop();\r\n                    }\r\n                    S.push(maxvalue);\r\n                }\r\n                else{\r\n                    S.push(arr[i]);\r\n                }\r\n            }\r\n        }\r\n        return S.size();\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841760135","body":"这题应该用快慢指针做的，这样就只需要遍历一遍\r\n但我的步骤为：\r\n1.先封装成环，且统计size\r\n2.由于k可能比size大很多，取余\r\n3.那么遍历到size-k就是新头节点\r\n分析：我的理解是各有好处，用快慢指针的话，只需遍历一遍，但是k值不好再次取余统计\r\nT:O(N)\r\nS:O(1)\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(head==NULL){\r\n            return NULL;\r\n        }\r\n        //先把链表封装成环\r\n        ListNode* tail = head;\r\n        int size = 0;\r\n        while(tail->next!=NULL){\r\n            tail = tail->next;\r\n            ++size;\r\n        }\r\n        size++;\r\n        tail->next = head;\r\n\r\n        k = k%size;\r\n        \r\n        if(k==0){\r\n            tail->next = NULL;\r\n            return head;\r\n        }\r\n\r\n        ListNode* curr = head;\r\n        ListNode* pre = NULL; \r\n        for(int i =0 ;i<size-k;++i){\r\n            pre = curr;\r\n            curr = curr->next;\r\n        }\r\n        if(pre!=NULL){\r\n            pre->next = NULL;\r\n        }\r\n\r\n        return curr;\r\n    }\r\n};\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841918764","body":"递归\r\nT:O(N)\r\nS:O(1)\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode* swapPairs(ListNode* head) {\r\n        //递归\r\n        if(head == NULL||head->next == NULL){\r\n            return head;\r\n        }\r\n        ListNode* tempNode = swapPairs(head->next->next);\r\n        ListNode* newhead = head->next;\r\n        head->next = tempNode;\r\n        newhead->next = head;\r\n        return newhead;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843131618","body":"其实老师在本题介绍的计算时间复杂度的公式叫做master公式\r\n\r\n\r\n\r\nT:O(NlongN)\r\nS: O(N)\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        int right = 0;\r\n        ListNode* curr = head;\r\n        vector<int> numV;\r\n        while(curr!=NULL){\r\n            numV.push_back(curr->val);\r\n            curr = curr->next;\r\n            ++right;\r\n        }\r\n        TreeNode* root = func(0,right-1,numV);\r\n        return root;\r\n    }\r\n\r\n    TreeNode* func(int left ,int right,vector<int>& numV){\r\n        //范围建树\r\n        if(left>right){\r\n            return NULL;\r\n        }\r\n        int mid = (left+right)>>1;\r\n        TreeNode* root = new TreeNode(numV[mid]);\r\n        root->left = func(left,mid-1,numV);\r\n        root->right = func(mid+1,right,numV);\r\n        return root;\r\n    }\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843681158","body":"T:O(N)\r\nS:O(1)\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\r\n        if(headA==headB){\r\n            return headA;\r\n        }\r\n        \r\n        ListNode* uperpoint = headA;\r\n        ListNode* lowpoint = headB;\r\n        int status0 = 0;\r\n        int status1 = 0;\r\n        while(uperpoint!=NULL&&lowpoint!=NULL){\r\n            if(uperpoint->next==NULL&&status0==0){\r\n                uperpoint = headB;\r\n                status0 = 1;\r\n            }\r\n            if(lowpoint->next==NULL&&status1==0){\r\n                lowpoint = headA;\r\n                status1 = 1;\r\n            }\r\n            if(status0==1&&status1==1&&lowpoint==uperpoint){\r\n                return lowpoint;\r\n            }\r\n            uperpoint = uperpoint->next;\r\n            lowpoint = lowpoint->next;\r\n        }\r\n        return NULL;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845207051","body":"T:O(N)\r\nS:O(1)\r\n```\r\nclass Solution {\r\npublic:\r\n    ListNode *detectCycle(ListNode *head) {\r\n        if(head==NULL){\r\n            return NULL;\r\n        }\r\n        ListNode* low = head;\r\n        ListNode* fast = head;\r\n        \r\n        while(true){\r\n            if(low->next==NULL){\r\n                return NULL;\r\n            }\r\n            if(fast==NULL){\r\n                return NULL;\r\n            }\r\n            \r\n            low = low->next;\r\n            if(fast->next == NULL){\r\n                return NULL;\r\n            }\r\n            fast = fast->next->next;\r\n            if(low == fast){\r\n                break;\r\n            }\r\n        }\r\n        fast = head;\r\n        while(fast!=low){\r\n            fast = fast->next;\r\n            low = low->next;\r\n        }\r\n        return low;\r\n    }\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846030412","body":"map里面应该存内存地址的，切记\r\n自己解的时候存的值，每次都遍历了一下\r\n双向循环链表\r\n```\r\nclass ListNodeT{\r\npublic:\r\n    ListNodeT(int key){\r\n        this->key = key;\r\n    }\r\npublic:\r\n    int key;\r\n    ListNodeT* next = NULL;\r\n    ListNodeT* pre = NULL;\r\n};\r\n\r\nclass LRUCache {\r\npublic:\r\n    LRUCache(int capacity) {\r\n        this->capacity = capacity;\r\n    }\r\n    \r\n    int get(int key) {\r\n        if(M.find(key)==M.end()){\r\n            return -1;\r\n        }\r\n        //将链表中的值移前\r\n        put(key,M[key]);\r\n        return M[key];\r\n\r\n\r\n    }\r\n    \r\n    void put(int key, int value) {\r\n        if(M.find(key)!=M.end()){\r\n            M[key] = value;\r\n            if(head->key != key){\r\n                // ListNodeT* pre = head;\r\n                ListNodeT* curr = head->next;\r\n                while(curr!=head){\r\n                    if(curr->key == key){\r\n                        curr->pre->next = curr->next;\r\n                        curr->next->pre = curr->pre;\r\n                        delete curr;\r\n                        break;\r\n                    }\r\n                    curr = curr->next;\r\n                }\r\n                ListNodeT* temp = new ListNodeT(key);\r\n                temp->pre = head->pre;\r\n                head->pre->next = temp;\r\n                head->pre = temp;\r\n                temp->next = head;\r\n                head = temp;\r\n            }\r\n        }\r\n        else{\r\n            M[key] = value;\r\n            if(head!= NULL && index==capacity){\r\n                ListNodeT* temp = head->pre;\r\n                M.erase(temp->key);\r\n                temp->key = key;\r\n                head = temp;\r\n            }\r\n            else if(head!=NULL&&index<capacity){\r\n                ListNodeT* temp = new ListNodeT(key);\r\n                head->pre->next = temp;\r\n                temp->pre = head->pre;\r\n                temp->next = head;\r\n                head->pre = temp;\r\n                head = temp;\r\n                ++index;\r\n            }\r\n            else if(head == NULL){\r\n                head = new ListNodeT(key);\r\n                head->next = head;\r\n                head->pre = head;\r\n                ++index;\r\n            }\r\n        }\r\n\r\n    }\r\npublic:\r\n    int capacity;\r\n    int index = 0;\r\n    map<int,int> M;\r\n    ListNodeT* head = NULL;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846345277","body":"T:O(N)\r\nS:O(1)\r\n```\r\nclass Solution{\r\npublic:\r\n    int maxDepth(TreeNode* root){\r\n        if(root==NULL){\r\n            return 0;\r\n        }\r\n        int leftheight = maxDepth(root->left);\r\n        int rightheight = maxDepth(root->right);\r\n        return max(leftheight,rightheight)+1;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MellonGuan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/50#issuecomment-841332013","body":" ## 题目地址(232. 用栈实现队列)\r\n * https://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n \r\n ## 解题思路\r\n * 辅助栈设计 stack2\r\n * push(int x) 将元素 x 推到队列的末尾： stack1 保存队列首在栈底，队列尾部在栈顶；\r\n * pop() -- 从队列首部移除元素： stack2 保存队列首在栈顶，队列尾部在栈底；\r\n * int peek() 返回队列开头的元素：stack2 保存队列首在栈顶，队列尾部在栈底；\r\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false：stack1、stack2都为空时才为true；\r\n \r\n```cpp\r\n/*\r\n * 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\r\n * 实现 MyQueue 类：\r\n * void push(int x) 将元素 x 推到队列的末尾\r\n * int pop() 从队列的开头移除并返回元素\r\n * int peek() 返回队列开头的元素\r\n * boolean empty() 如果队列为空，返回 true ；否则，返回 false\r\n * 说明：\r\n * 你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size,\r\n * 和 is empty 操作是合法的。\r\n * 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n    来源：力扣（LeetCode）\r\n    链接：https://leetcode-cn.com/problems/implement-queue-using-stacks\r\n    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\r\n * 使用栈实现队列的下列操作：\r\n * push(x) -- 将一个元素放入队列的尾部。\r\n * pop() -- 从队列首部移除元素。\r\n * peek() -- 返回队列首部的元素。\r\n * empty() -- 返回队列是否为空。\r\n */\r\n\r\n#include <iostream>\r\n#include <stack>\r\n\r\nusing namespace std;\r\n\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st1;\r\n    stack<int> st2;\r\n    int temp = 0;\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue.\r\n     * @param x void push(int x)\r\n     * 将元素 x 推到队列的末尾 */\r\n    void push(int x) {\r\n        while (!st2.empty()){\r\n            temp = st2.top();\r\n            st2.pop();\r\n            st1.push(temp);\r\n        }\r\n        st1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element.\r\n     *\r\n     * @return int pop()\r\n     * 从队列的开头移除并返回元素\r\n     */\r\n    int pop() {\r\n        int popnum = 0;\r\n        while (!st1.empty()){\r\n            temp = st1.top();\r\n            st1.pop();\r\n            st2.push(temp);\r\n        }\r\n        popnum = st2.top();\r\n        st2.pop();\r\n        return popnum;\r\n    }\r\n\r\n    /** Get the front element.\r\n     *\r\n     * @return int peek()\r\n     * 返回队列开头的元素\r\n     */\r\n    int peek() {\r\n        int peeknum = 0;\r\n        while (!st1.empty()){\r\n            temp = st1.top();\r\n            st1.pop();\r\n            st2.push(temp);\r\n        }\r\n        peeknum = st2.top();\r\n        return peeknum;\r\n    }\r\n\r\n    /** Returns whether the queue is empty. \r\n     * \r\n     * @return boolean empty() \r\n     * 如果队列为空，返回 true ；\r\n     * 否则，返回 false\r\n     * */\r\n    bool empty() {\r\n        if (st1.empty() && st2.empty())\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n};\r\n\r\n```\r\n ## 时间复杂度\r\n * O(n)\r\n ## 空间复杂度\r\n * O(n)\r\n"},null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846514573","body":"思路\r\n1. DFS 递归\r\n2. 只有同时到最底层为空，且之前节点都相等才会return true。\r\n\r\n```cpp\r\nclass Solution {\r\n    //只有同时到最底层为空，且之前节点都相等（没有return false过），才会return true。\r\n    bool isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) {\r\n            return true;\r\n        } else if (p ==  null || q == null){\r\n            return false;\r\n        } else if (p.val != q.val){\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\n时间：O(min(m, n))\r\n空间：O(min(m, n))"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"SeventeenCui":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841577415","body":"### 思路\r\n两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int N = arr.size();\r\n        vector<int> lmax(N, INT_MIN);\r\n        vector<int> rmin(N, INT_MAX);\r\n        lmax[0] = arr[0];\r\n        rmin[N - 1] = arr[N - 1];\r\n        for (int i = 1; i < N; ++i) {\r\n            lmax[i] = max(lmax[i - 1], arr[i]);\r\n            rmin[N - 1 - i] = min(rmin[N - i], arr[N - 1 - i]);\r\n        }\r\n        int res = 1;\r\n        for (int i = 0; i < N - 1; ++i) {\r\n            res += lmax[i] <= rmin[i + 1];\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842931291","body":"### 思路\r\n先把链表中的节点保存到数组中，这样方便找中间节点。\r\n根据二叉搜索树的性质，建树的话，每次取中间节点作为根节点。这样可以构建成二叉搜索树。这样写出的代码可以AC。\r\n但是题目中要求的是二叉搜索”平衡“二叉树，不知道怎样在代码中处理”平衡“的问题。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        vector<int> nums;\r\n        for(auto t = head; t; t = t->next){\r\n            nums.push_back(t->val);\r\n        }\r\n        return makeTree(nums, 0, nums.size() - 1);\r\n    }\r\n    TreeNode* makeTree(vector<int>& nums, int left, int right){\r\n        if(left > right)\r\n            return NULL;\r\n        int mid = right + (left - right)/ 2;\r\n        TreeNode* root = new TreeNode(nums[mid]);\r\n        root->left = makeTree(nums, left, mid - 1);\r\n        root->right = makeTree(nums, mid + 1, right);\r\n        return root;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846397420","body":"### 思路\r\n采用迭代法。\r\n以二叉树层序遍历的框架为基础，加入深度就可以。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxDepth(TreeNode* root) {\r\n        int res = 0;\r\n        if(!root)\r\n            return res;\r\n        queue<TreeNode*> que;\r\n        que.push(root);\r\n        while(que.size()){\r\n            int size = que.size();\r\n            for(int i = 0; i < size; i ++){\r\n                auto node = que.front();\r\n                que.pop();\r\n                if(node->left)\r\n                    que.push(node->left);\r\n                if(node->right)\r\n                    que.push(node->right);\r\n            }\r\n            res ++;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"BUBBLEbubbleBUBBLEbubble":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841602759","body":"**思路**\r\n最主要的是当：1.用栈表示块。2.前块的最小值要永远要大于等于前一块的最大值。若不符合则要和前面一块合并。\r\n**步骤**\r\n一开始从左向右以单个数据作为一个块，向右移动，若不符合上面的思路就向左合并块。\r\n**代码**\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []  # 栈的长度即块数\r\n        for num in arr:\r\n            if stack and stack[-1] > num:\r\n                head = stack.pop()\r\n                while stack and num < stack[-1]:\r\n                    stack.pop()\r\n                pass\r\n                stack.append(head)\r\n            else:\r\n                stack.append(num)\r\n                pass\r\n            pass\r\n        pass \r\n        return len(stack)\r\n```\r\n**复杂度分析**\r\n时间：O(N)\r\n空间：O(N)\r\n"},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845571724","body":"java的LinkedHashMap\r\n\r\n`import java.util.LinkedHashMap;\r\nimport java.util.Map;\r\n\r\nclass LRUCache {\r\n\r\n    private LRU cache;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.cache = new LRU(capacity);\r\n    }\r\n\r\n    public int get(int key) {\r\n        if (cache.containsKey(key)) {\r\n            return cache.get(key);\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        cache.put(key, value);\r\n    }\r\n\r\n    class LRU extends LinkedHashMap<Integer, Integer> {\r\n        int capacity;\r\n\r\n        public LRU(int capacity) {\r\n            // 需要开启 ordering mode，此时若元素被访问（put、get）就会被移到链表尾\r\n            super(capacity, 0.75f, true);\r\n            this.capacity = capacity;\r\n        }\r\n\r\n        /**\r\n         * removeEldestE***y 方法会在插入元素之后调用，用以判断是否需要移除链表表头元素（最近最少访问元素）\r\n         */\r\n        @Override\r\n        protected boolean removeEldestE***y(Map.E***y<Integer, Integer> eldest) {\r\n            return this.size() > capacity;\r\n        }\r\n    }\r\n}`"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Tomtao626":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841604711","body":"# 思路：\r\n> + 记录每个块中的最大值，最大值的个数就是分块数\r\n\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: \r\n                    stack.pop()\r\n                stack.append(head)\r\n            else: \r\n                stack.append(num)\r\n        return len(stack)\r\n```\r\n\r\n# 复杂度分析：\r\n> + 时间复杂度：O(n)\r\n> + 空间复杂度：O(n）"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842394966","body":"## 思路\r\n> + 递归\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head :\r\n            return None\r\n        if not head.next:\r\n            return head\r\n        new_head = head.next\r\n        p = head.next.next\r\n        left = self.swapPairs(p)\r\n        head.next.next = head\r\n        head.next = left\r\n        return  new_head\r\n```\r\n## 复杂度\r\n> + 时间：O(N)\r\n> + 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843105135","body":"## 思路\r\n> + 快慢指针(主要是要找到链表的中间元素,再从中间，左右断开)+递归\r\n```python\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def rebuildTree(subhead):\r\n            if not subhead: return None\r\n            slow = subhead\r\n            fast = subhead\r\n            pre_next = ListNode(0)\r\n            p = pre_next\r\n            while fast and fast.next:\r\n                fast = fast.next.next\r\n                p.next = slow\r\n                p = p.next\r\n                slow = slow.next\r\n\r\n            root_val = slow.val\r\n            root = TreeNode(root_val)\r\n            p.next = None\r\n            root.left = rebuildTree(pre_next.next)\r\n            root.right = rebuildTree(slow.next)\r\n            return root\r\n        return rebuildTree(head)\r\n```\r\n## 复杂度分析\r\n> + 时间复杂度:O(logn)\r\n> + 空间复杂度: O(logn)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844964103","body":"## 思路\r\n> + 每次遍历完一个节点，将它的下一个节点指向初始节点，然后继续遍历\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        res = []\r\n        tmp = head\r\n        while tmp != None:\r\n            if tmp in res:\r\n                return tmp\r\n            else:\r\n                res.append(tmp)\r\n                tmp = tmp.next\r\n        return None\r\n```\r\n# 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JasonQiu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841632622","body":"A stack will hold the largest element in each chunk.\r\nScan from the beginning of the array:\r\n\r\n- If an element is equal to or greater than the largest element so far _i.e._ the last element of the stack (if applicable), it will be an individual chunk as well as the largest element of that chunk. Append it to the stack.\r\n- Otherwise, to make the element no smaller than (any element in) any other chunk, it should form a new chunk along with all the elements that fail to meet the requirement. During this process, the largest/representative element(s) will be popped from the stack. The chunks represented by the popped elements will no longer be individual chunks. The current element in the array or the (former) last element of the stack will be the smallest or the largest element of the new chunk. Append the last element back to the stack so that it represents the new chunk.\r\n\r\nThe length of the stack is the answer.\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        chunks = []\r\n        for a in arr:\r\n            if chunks and chunks[-1] > a:\r\n                last = chunks[-1]\r\n                while chunks and chunks[-1] > a:\r\n                    chunks.pop()\r\n                chunks.append(last)\r\n            else:\r\n                chunks.append(a)\r\n        return len(chunks)\r\n```\r\nRuntime: 68 ms, faster than 93.72% of Python3 online submissions for Max Chunks To Make Sorted II.\r\nMemory Usage: 14.7 MB, less than 44.35% of Python3 online submissions for Max Chunks To Make Sorted II."},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846421289","body":"```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root is None:\r\n            return 0\r\n        max_depth = 1\r\n        q = collections.deque([(root.left, 2), (root.right, 2)])\r\n        while len(q) > 0:\r\n            t = q.popleft()\r\n            if t[0] is not None:\r\n                max_depth = t[1]\r\n            else:\r\n                continue\r\n            for child in [t[0].left, t[0].right]:\r\n                if child is not None:\r\n                    q.append((child, t[1] + 1))  \r\n        return max_depth\r\n```\r\n\r\n```python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if root is None:\r\n            return 0\r\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dopufol":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841640842","body":"```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        n = len(arr)\r\n        stack = list()\r\n        stack.append(arr[0])\r\n        curMax = arr[0]\r\n        for i in range(1, n):\r\n            if arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            else:\r\n                curMax = stack[-1]\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(curMax)\r\n        return len(stack)\r\n```\r\n时间复杂度是O(N)，空间复杂度是O(1)。其中N是所有数组的长度。"},null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846343665","body":"```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root==null)\r\n            return 0;\r\n        return java.lang.Math.max(maxDepth(root.left),maxDepth(root.right))+1;\r\n    }\r\n}\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841648081","body":"**思路：单调栈**\r\n维持一个单调递增栈，存储每个块中的最大值，最终单调栈的长度就是可分块的大小。\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        // new一个栈对象\r\n        int ans = 0;\r\n        for(int num:arr){\r\n            if(!stack.isEmpty() && num < stack.peek()){\r\n                int tmp = stack.pop();\r\n                while(!stack.isEmpty() && num < stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(tmp);\r\n                // 遍历整个数组，当栈不空且栈顶元素大于当前比较元素则出栈，且更新成新的最大值，不增加栈的长度\r\n            }\r\n            else{\r\n                stack.push(num);\r\n                // 如果栈空或栈顶元素小于当前比较元素，则栈顶元素入栈，栈的长度加一\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n时间复杂度:O(N)\r\n空间复杂度:O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841788346","body":"**参考官方题解思路:闭合为环**\r\n记给定链表的长度为 n，到当向右移动的次数 k≥n 时，仅需要向右移动 k mod n 次即可。因为每 n 次移动都会让链表变为原状。这样新链表的最后一个节点为原链表的第 n  - (k mod n）节点。\r\n首先计算出链表的长度n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点，将当前闭合为环的链表断开，即可得到结果。\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // 1. 结果不出现变化的特殊情况\r\n        if(k == 0 || head == null || head.next == null){\r\n            return head;\r\n        }\r\n\r\n        // 2. 计算出原链表的长度为n\r\n        int n = 1;\r\n        ListNode iter = head;\r\n        while(iter.next != null){\r\n            iter = iter.next;\r\n            n++;                                // 此时n记录的是链表的末尾节点\r\n        }\r\n\r\n        // 3. 找到移动k位后新链表的最后一个节点\r\n        int add = n - k % n;                    // add 记录的是新链表的最后一个节点\r\n        if(add == n){                           // 如果k 刚好为n的整数倍数，新链表将于原链表相同\r\n            return head;                        // 直接返回原链表即可\r\n        }\r\n\r\n        // 4. 处理逻辑\r\n        iter.next = head;                       // 将当前链表闭合为环\r\n        while(add-- > 0){                       // 将iter指向新链表的最后一个节点位置\r\n            iter = iter.next;   \r\n        }\r\n        ListNode ret = iter.next;               // 此时 ret为移动k位后新链表的头\r\n        iter.next = null;                       // 将环断开\r\n        return ret;                             // 返回新链表\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842411083","body":"**思路：递归**\r\n设置一个虚拟头结点dummyHead\r\n设置需要交换的两个节点分别为node1 、node2，同时设置node2的下一个节点next\r\n在这一轮操作中将node2节点的next设置为node1节点，将node1节点的next设置为next节点，将dummyHead节点的next设置为node2，结束本轮操作。接下来的每轮操作都按照上述进行。\r\n```\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        ListNode dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n        //创建一个虚拟头结点并指向原链表头结点\r\n        ListNode p = dummyHead;\r\n        while (p.next != null && p.next.next != null){\r\n            ListNode node1 = p.next;\r\n            ListNode node2 = p.next.next;\r\n            ListNode next = node2.next;\r\n            //令 p 表示当前到达的节点，初始时 p = dummyHead。如果 p 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。设置需要交换的两个节点分别为node1、node2，同时设置node2的下一个节点next。\r\n            node2.next = node1;\r\n            node1.next = next;\r\n            p.next = node2;\r\n            p = node1;\r\n            //在这一轮操作中将node2节点的next设置为node1节点，将node1节点的next设置为next节点，将 p 节点的next设置为node2\r\n        }\r\n    return dummyHead.next;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(N),其中N是链表的节点数量，也就是长度。\r\n空间复杂度：O(1)\r\n此外还有迭代思路，还需要学习。"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843247625","body":"**思路**\r\n预备知识：\r\n二叉搜索树是根节点的左子树的值都小于根节点、右子树的值都大于根节点，高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。\r\n因此要找出链表元素的中位数作为根节点的值，为了递归操作，需要提取出左右子树对应的链表的头结点，因此要将链表从中间节点断开，左半部分对应当前根节点的左子树上的节点，注意要从中点（根节点）的前一个位置断开，右半部分对应当前根节点的右子树上的节点，注意要从中点（根节点）的后一个位置开始，也就是从中间节点断开\r\n使用快慢双指针可定位中间元素，定义一个快指针每步前进两个节点，一个慢指针每步前进一个节点; 当快指针到达尾部的时候，正好慢指针所到的点为中点.\r\n```\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        if(head.next == null) return new TreeNode(head.val);\r\n        //找到链表的中间节点作为平衡二叉搜索树的根节点\r\n        ListNode slow = head, fast = head, pre = null;\r\n        while(fast.next != null){\r\n            fast = fast.next.next != null? fast.next.next: fast.next;\r\n            pre = slow;\r\n            slow = slow.next;\r\n        }\r\n        //生成当前子树的根节点\r\n        TreeNode root = new TreeNode(slow.val);\r\n        //拆分左右链表\r\n        pre.next = null;\r\n        ListNode rhead = slow.next;\r\n        //递归先序遍历构建平衡二叉搜索树\r\n        root.left = sortedListToBST(head);\r\n        root.right = sortedListToBST(rhead);\r\n        return root;        \r\n    }\r\n}\r\n```\r\n时间复杂度：递归树的深度为 logn，每一层的基本操作数为 n，因此总的时间复杂度为O(nlogn)\r\n空间复杂度：O(logn)\r\n此外还有转成数组的思路\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844043650","body":"**思路**\r\n绝妙的双指针法\r\n设链表A的头结点到相交节点的距离为a，链表B的头结点到相交节点的距离为b，相交点到链表终点的距离为c。\r\n使用双指针，分别指向两个链表的头结点，并同时同步前进，若其中一个到达链表结尾，则移动到另一条链表的头结点继续前进。\r\n按此方法，两个指针均会在a+b+c次前进后同时到达相交节点。\r\n```\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while(a != b){\r\n            if (a == null){\r\n                a = headB;\r\n            }\r\n            else{\r\n                a = a.next;\r\n            }\r\n            //a指针为空时,a指针重定位到链表B的头结点,否则a指针向后移动一位\r\n            if (b == null){\r\n                b = headA;\r\n            }\r\n            else{\r\n                b = b.next;\r\n            //b指针为空时,b指针重定位到链表A的头结点,否则b指针向后移动一位\r\n            }\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```\r\n时间复杂度 : O(m+n) 最差情况下需遍历 a+b 个节点。\r\n空间复杂度 : O(1)\r\n**还有哈希表的解法，复制官方的学习**\r\n有 A, B 两条链表, 先遍历其中一个，比如 A 链表，并将 A 中的所有节点存入哈希表。\r\n接着遍历 B 链表，检查每个节点是否在哈希表中, 存在于哈希表中的那个节点就是 A 链表和 B 链表的相交节点\r\n```\r\npublic class Solution {\r\n\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> hashSet = new HashSet<>();\r\n\r\n        ListNode curNode = headA;\r\n        while (curNode != null) {\r\n            hashSet.add(curNode);\r\n            curNode = curNode.next;\r\n        }\r\n\r\n        curNode = headB;\r\n        while (curNode != null) {\r\n            if(hashSet.contains(curNode)){\r\n                return curNode;\r\n            }\r\n            curNode = curNode.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n时间复杂度 : O(m+n) \r\n空间复杂度 : O(m)或O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844769912","body":"**思路**\r\n    与昨天的相交链表思路相似，这类链表题目一般都是使用快慢指针法解决寻找距离尾部第K个节点、寻找环入口、寻找公共尾部入口等（这些可以之后集中刷）\r\n**算法流程：**\r\n双指针第一次相遇： 设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；\r\n    第一种结果： fast 指针走过链表末端，说明链表无环，直接返回 null；\r\n若有环，两指针一定会相遇。因为每走 1 轮，fast 与 slow 的间距 +1，fast 终会追上 slow；\r\n第二种结果： 当fast == slow时， 两指针在环中 第一次相遇 。下面分析此时fast 与 slow走过的 步数关系 ：\r\n设链表共有a+b个节点，其中 链表头部到链表入口有 a个节点（不计链表入口节点）， 链表环有 b 个节点；设两指针分别走了 f，s 步，则有：fast 走的步数是slow步数的 2 倍，即 f=2s；\r\nfast 比 slow多走了 n 个环的长度，即 f = s + nb f=s+nb；（ 解析： 双指针都走过 a 步，然后在环内绕圈直到重合，重合时 fast 比 slow 多走环的长度整数倍 ）；\r\n以上两式相减得：f=2nb，s = nb，即fast和slow 指针分别走了 2n，n 个环的周长 （n 是未知数，不同链表的情况不同）。\r\n目前情况分析：\r\n如果让指针从链表头部一直向前走并统计步数k，那么所有走到链表入口节点时的步数 是：k=a+nb（先走 a 步到入口节点，之后每绕 1 圈环（ b 步）都会再次到入口节点）。\r\n而目前，slow 指针走过的步数为 nb 步。因此，我们只要想办法让 slow 再走 a 步停下来，就可以到环的入口。\r\n但是我们不知道 a 的值，该怎么办？依然是使用双指针法。我们构建一个指针，此指针需要有以下性质：此指针和slow 一起向前走 a 步后，两者在入口节点重合。那么从哪里走到入口节点需要 a 步？答案是链表头部head。\r\n双指针第二次相遇：\r\nslow指针位置不变 ，将fast指针重新指向链表头部节点 ；slow和fast同时每轮向前走 1 步；\r\nTIPS：此时 f=0，s=nb ；\r\n当 fast 指针走到f = a 步时，slow 指针走到步s=a+nb，此时 两指针重合，并同时指向链表环入口 。\r\n返回slow指针指向的节点。\r\n```\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode fast = head, slow = head;\r\n        while (true) {\r\n            if (fast == null || fast.next == null) return null;\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n            if (fast == slow) break;\r\n        }\r\n        //第一轮相遇结束，快指针回到头节点，并且速度变为1\r\n        fast = head;\r\n        while (slow != fast) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n```\r\n复杂度分析：\r\n时间复杂度 O(N) ：第二次相遇中，慢指针须走步数a<a+b；第一次相遇中，慢指针须走步数 a + b - x < a + b，其中 x 为双指针重合点与环入口距离；因此总体为线性复杂度；\r\n空间复杂度 O(1) ：双指针使用常数大小的额外空间。\r\n\r\n**解法二 HashMap（暂时没了解哈希表 先复制的题解）**\r\n遍历链表，并且把遍历过的节点用 HashSet 存起来，如果遍历过程中又遇到了之前的节点，说明这个节点就是我们要找到入口点。如果到达了 null 就说明没有环。\r\n\r\n\r\n```\r\npublic ListNode detectCycle(ListNode head) {\r\n    HashSet<ListNode> set = new HashSet<>();\r\n    while (head != null) {\r\n        set.add(head);\r\n        head = head.next;\r\n        if (set.contains(head)) {\r\n            return head;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n```\r\n时间复杂度：O(N)，其中 N 为链表中节点的数目。恰好需要访问链表中的每一个节点。\r\n空间复杂度：O(N)，其中 N 为链表中节点的数目。需要将链表中的每个节点都保存在哈希表当中。\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845887905","body":"**补充知识：LRU （Least Recently Used）缓存机制**\r\n在缓存满的时候，删除缓存里最久未使用的数据，然后再放入新元素；数据的访问时间很重要，访问时间距离现在最近，就最不容易被删除。\r\n核心思想：在删除元素的时候，只看在缓存里的存在时间。\r\n另一种缓存删除机制是 LFU （Least Frequently Used，最不经常使用）缓存机制（第 460 题）LFU 缓存。算法的设计思想一致。\r\n**思路：哈希表+双向链表(纯粹是学习别人)**\r\n\r\n分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：查找快，插入快，删除快，有顺序之分。\r\n因为显然 cache 必须有顺序之分，以区分最近使用的和久未使用的数据；而且我们要在 cache 中查找键是否已存在；如果容量满了要删除最后一个数据；每次访问还要把数据插入到队头。\r\n那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表。\r\nLRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。\r\n**双向链表、哈希表，存什么？**\r\n链表结点：存 key 和 对应的数据值。\r\n哈希表的存在，就是为了快速访问到存储于双向链表的数据：\r\nkey：存双向链表中存的 key\r\nvalue：存链表结点的引用。\r\n\r\n```\r\npublic class LRUCache {\r\n    class DLinkedNode {\r\n        int key;\r\n        int value;\r\n        DLinkedNode prev;\r\n        DLinkedNode next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\r\n        //定义双向链表类\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size;\r\n    private int capacity;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        this.size = 0;\r\n        this.capacity = capacity;\r\n        // 使用伪头部和伪尾部节点标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n\r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            return -1;\r\n        }\r\n        // 如果 key 存在，先通过哈希表定位，再移到头部\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n\r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            // 如果 key 不存在，创建一个新的节点\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            // 添加进哈希表\r\n            cache.put(key, newNode);\r\n            // 添加至双向链表的头部\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > capacity) {\r\n                // 如果超出容量，删除双向链表的尾部节点\r\n                DLinkedNode tail = removeTail();\r\n                // 删除哈希表中对应的项\r\n                cache.remove(tail.key);\r\n                --size;\r\n            }\r\n        }\r\n        else {\r\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n\r\n    private void addToHead(DLinkedNode node) {\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n        //定义双向链表加至头部的方法\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node) {\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n        //定义双向链表移动节点的方法\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node) {\r\n        removeNode(node);\r\n        addToHead(node);\r\n        //定义双向链表移至头部的方法，即为前两种方法组合\r\n    }\r\n\r\n    private DLinkedNode removeTail() {\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n        //定义双向链表移除尾部节点的方法\r\n    }\r\n}\r\n\r\n\r\n```\r\n时间复杂度：对于 put 和 get 都是O(1)。\r\n\r\n空间复杂度：O(N)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846373291","body":"**思路一：递归**\r\n对于当前节点来说，它只需要知道其左子树和右子树的深度，然后取两者中的最大值加上一，就计算出了以其为根节点的二叉树的深度。\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        // 若当前节点为null 则返回0\r\n    }\r\n\r\n    // 计算当前节点左子树的深度\r\n    int leftDepth = maxDepth(root.left);\r\n    // 计算当前节点右子树的深度\r\n    int rightDepth = maxDepth(root.right);\r\n\r\n    // 计算以当前节点为根的树，其最大深度\r\n    return Math.max(leftDepth, rightDepth) + 1;\r\n\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)，其中N为二叉树节点的个数。每个节点在递归中只被遍历一次。\r\n空间复杂度：O(height)，其中 height 表示二叉树的高度。\r\n\r\n\r\n\r\n**思路二：层序遍历 也为广度优先搜索（DFS）**\r\n对二叉树进行层序遍历，每遍历一层，二叉树的深度加一，直到所有节点过一遍。这样就可以得到二叉树的最大深度。\r\n实现思路：将当前考察的节点放入队列，然后开始遍历队列中的元素；\r\n在取出队列中元素之前，先计算队列中元素个数，即当前这一层共有几个节点；\r\n然后，通过内层for循环将队列中的元素全部取出，每取出一个元素时，若其左子树或右子树不为空，则将其加入队列，等待下一次遍历。\r\n```\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if (root == null) {\r\n            return 0;\r\n        // 若当前节点为null 则返回0\r\n        }\r\n\r\n        int maxDepth = 0;\r\n\r\n        LinkedList<TreeNode> queue = new LinkedList<>();\r\n        queue.add(root);\r\n        // 将根节点放入队列\r\n\r\n        while (!queue.isEmpty()){\r\n            maxDepth += 1;\r\n            // 遍历队列中的元素，队列不为空，则最大深度加1\r\n\r\n            int cueLevelNum = queue.size();\r\n             // 计算当前这一层有多少个节点\r\n            for(int i = 0; i < cueLevelNum; i++ ){\r\n                // for循环是遍历当前这一层的所有节点\r\n                TreeNode curNode = queue.removeFirst();\r\n                 if (curNode.left != null) {\r\n                queue.add(curNode.left);\r\n                }\r\n                if (curNode.right != null) {\r\n                queue.add(curNode.right);\r\n            // 同时如果其左子树或右子树不为空，则将其加入队列,等待下一while循环\r\n                }\r\n            }\r\n        }\r\n        return maxDepth;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N), 其中N为二叉树的节点个数。\r\n空间复杂度：O(N), 此方法空间的消耗取决于队列存储的元素数量\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846525334","body":"**思路：延续昨天的递归**\r\n分成多种情况，分别有节点皆空、有一个空、值不相同，再利用递归思想分别判断左右节点。\r\n```\r\nclass Solution {\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n            if(p == null && q == null){\r\n                return true;\r\n            }\r\n            //节点都为空时相同\r\n            else if(p == null || q == null){\r\n                return false;\r\n            }\r\n            //只有一个为空必不相同\r\n            else if(p.val != q.val){\r\n                return false;\r\n            }\r\n            else{\r\n                return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n            }\r\n            //递归，继续判断结点的左右子节点\r\n    }\r\n}\r\n```\r\n时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\r\n空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\r\n\r\n此外仍对应有广度优先搜索（BFS）的放法，不过感觉这两天的题明显是递归更简洁。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunshineliu6":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841656231","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        LinkedList<Integer> stack = new LinkedList<Integer>();\r\n        for(int num : arr) {\r\n            if(!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\r\n                stack.addLast(head);\r\n            }\r\n            else stack.addLast(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O（N）\r\n空间复杂度O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jimengchao":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841664989","body":"没有思路，对照题解，所理解的 遍历arr， 如果 下一项比前一项数值大则分块， 将每一块的最大值保留，最后返回长度\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = [];\r\n    let head = 0;\r\n\r\n    for ( let i = 0; i < arr.length; i++ ){\r\n        if( stack.length && stack[stack.length - 1] > arr[i] ){\r\n            head = stack.pop();\r\n            while(stack.length && stack[stack.length - 1] > arr[i]){\r\n                stack.pop()\r\n            }\r\n            stack.push(head)\r\n        }else{\r\n            stack.push(arr[i])\r\n        }\r\n    }   \r\n    return stack.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841822058","body":"抄的题解， 有思路 但是不理解为什么 下面就可以 。 待补充\r\n```js\r\nvar rotateRight = function(head, k) {\r\n\r\n    // 求链表长度\r\n    var len = 0;\r\n    var now = head\r\n\r\n    while(now){\r\n        len += 1;\r\n        now = now.next\r\n    }\r\n\r\n\r\n    // 计算断开的 节点\r\n    k = k % len;\r\n\r\n    if(!k) return head;\r\n\r\n    // 这里开始往下就不是很理解了。\r\n    var slow = head;\r\n    var fast = head;\r\n    while(fast.next){\r\n        if(k-- <= 0){\r\n            slow = slow.next\r\n        }\r\n       fast = fast.next;\r\n    }\r\n    fast.next = head;\r\n    let res = slow.next;\r\n    slow.next = null;\r\n    return res\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842403846","body":"```js\r\nvar swapPairs = function(head) {\r\n    if( !head || !head.next) return head\r\n    let nextHead = head.next\r\n    head.next = swapPairs(nextHead.next)\r\n    nextHead.next = head\r\n    return nextHead\r\n};\r\n```"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844226206","body":"```JS\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function(headA, headB) {\r\n    const data = new Set()\r\n    // 遍历存储 headA 节点\r\n    while( headA ){\r\n        data.add(headA);\r\n        headA = headA.next\r\n    }\r\n    // 遍历 headB节点 \r\n    while(headB){\r\n        // 判断 data 内是否存在相交点\r\n        if( data.has(headB) ) {\r\n            return headB\r\n        }\r\n        headB = headB.next\r\n    }\r\n    return null\r\n};\r\n\r\n```"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846419721","body":"DFS\r\n``` js\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n    if(root === null) return 0\r\n    let left = maxDepth(root.left);\r\n    let right  = maxDepth(root.right);\r\n    return 1 + Math.max(left, right)\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846529902","body":"### 递归\r\n 判断 两颗树的节点 以及 值 是否相同\r\n```js\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n\r\n    if(!p && !q) return true;\r\n\r\n    if( !p || !q ) return false;\r\n\r\n    if(p.val !== q.val) return false;\r\n\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n  \r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"AnnabellHyx":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841678608","body":"### 方法：单调递增栈\r\n### 代码\r\n```\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n    let stack = []\r\n    for (let i = 0; i < arr.length; i ++) {\r\n        if (!stack.length || stack[stack.length - 1] <= arr[i]) {\r\n            stack.push(arr[i])\r\n        } else {\r\n            const temp = stack.pop()\r\n            while (stack[stack.length - 1] > arr[i]) {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841832322","body":"### 思路：闭合环算法\r\n先将给定的链表连接成环，然后将指定位置断开。\r\n断开位置为：最后一个节点为原链表的第 (n - 1) - (k / n) 个节点（从 0 开始计数）\r\n### 代码：javascript\r\n```\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if (k === 0 || !head || !head.next) {\r\n        return head;\r\n    }\r\n    // 计算链表长度\r\n    let n = 1;\r\n    let cur = head;\r\n    while (cur.next) {\r\n        cur = cur.next;\r\n        n++;\r\n    }\r\n    // k 为链表长度倍数时，链表不变\r\n    let index = n - k % n;\r\n    if (index === n) {\r\n        return head;\r\n    }\r\n    // 将链表首尾相连，找出最后一位节点\r\n    cur.next = head;\r\n    while (index) {\r\n        cur = cur.next;\r\n        index--;\r\n    }\r\n    // 链表从最后一个节点处断开\r\n    const newList = cur.next;\r\n    cur.next = null;\r\n\r\n    return newList;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842396626","body":"### 思路: \r\n1. 设置虚拟头结点 dummy，设置了 dummy 后，dummy.next 就能找到头结点。\r\n2. 开启 while 循环，一对结点的交换改变三个指针。\r\n3. 指针推进，交换下一对结点。\r\n4. 最后返回 dummy.next 。\r\n\r\n### 代码：javascript\r\n```javascript\r\nvar swapPairs = function(head) {\r\n    // 设置虚拟头结点 dummy\r\n    const dummy = new ListNode(0)\r\n    dummy.next = head\r\n    let prev = dummy;\r\n\r\n    while (head && head.next) {\r\n        // 两两交换\r\n        const next = head.next\r\n        head.next = next.next\r\n        next.next = head\r\n        prev.next = next\r\n\r\n        // 指针更新\r\n        prev = head\r\n        head = head.next\r\n    }\r\n\r\n    // 返回虚拟节点的 next 即可\r\n    return dummy.next\r\n};\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843258773","body":"### 思路:\r\n(参考官网优秀解析)\r\n1. 想象成一条绳，提起中点作为根节点，分出左右两部分，再提起各自的中点作为根节点……分治下去，这根绳就成了BST的模样。\r\n2. 将有序链表转成数组，去递归分治这个数组，构建二叉树，就成了 BST 的模样。\r\n\r\n### 代码 javascript\r\n```javascript\r\nvar sortedListToBST = function(head) {\r\n    // 将链表组合为一个数组\r\n    const arr = []\r\n    while (head) {\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n\r\n    // 创建一个生成 BST 递归函数\r\n    const buildBST = (start, end) => {\r\n        if (start > end) return null // 指针交错, 返回 null\r\n        const mid = (start + end) >>> 1 // 寻找中间节点\r\n        const tree = new TreeNode(arr[mid]) // 生成 treeNode\r\n        tree.left = buildBST(start, mid - 1) // 递归生成左节点\r\n        tree.right = buildBST(mid + 1, end) // 递归生成右节点\r\n        return tree\r\n    }\r\n\r\n    // 调用递归函数, 返回结果\r\n    return buildBST(0, arr.length - 1)\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843752279","body":"### 思路: 双指针\r\n1. 使用两个指针 pA、pB 从 A、B 两个链表头部开始遍历\r\n2. 当一个指针遍历到尾部时, 将它移到另一个链表的头部开始遍历\r\n\r\n### 代码: javascript\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    var pA = headA;\r\n    var pB = headB;\r\n    while(pA !== pB){\r\n        pB = pB? pB.next: headA;\r\n        pA = pA? pA.next: headB;\r\n    }\r\n    return pA;\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844655242","body":"### 思路: \r\n* 遍历链表中的每个节点，并将它记录下来；\r\n* 一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表实现\r\n### 代码: javascript\r\n```javascript\r\nvar detectCycle = function(head) {\r\n    const visited = new Set()\r\n\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head\r\n        }\r\n        visited.add(head)\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845915022","body":"### 思路(参考官网优秀作者)\r\n* 利用双向链表和哈希表来实现 O(1) 的数据快速查找\r\n* 添加 dummyHead 和 dummyTail 方便操作. \r\n### 代码: javascript\r\n```javascript\r\nclass ListNode {\r\n  constructor(key, value) {\r\n    this.key = key\r\n    this.value = value\r\n    this.next = null\r\n    this.prev = null\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.capacity = capacity\r\n    this.hash = new Map()\r\n    this.count = 0\r\n    this.dummyHead = new ListNode()\r\n    this.dummyTail = new ListNode()\r\n    this.dummyHead.next = this.dummyTail\r\n    this.dummyTail.prev = this.dummyHead\r\n  }\r\n\r\n  get(key) {\r\n    let node = this.hash[key]\r\n    if (node == null) return -1\r\n    this.moveToHead(node)\r\n    return node.value\r\n  }\r\n\r\n  put(key, value) {\r\n    let node = this.hash[key]\r\n    if (node == null) {\r\n      if (this.count == this.capacity) {\r\n        this.removeLRUItem()\r\n      }\r\n      let newNode = new ListNode(key, value)\r\n      this.hash[key] = newNode\r\n      this.addToHead(newNode)\r\n      this.count++\r\n    } else {\r\n      node.value = value\r\n      this.moveToHead(node)\r\n    }\r\n  }\r\n\r\n  moveToHead(node) {\r\n    this.removeFromList(node)\r\n    this.addToHead(node)\r\n  }\r\n  \r\n  removeFromList(node) {\r\n    let temp1 = node.prev\r\n    let temp2 = node.next\r\n    temp1.next = temp2\r\n    temp2.prev = temp1\r\n  }\r\n\r\n  addToHead(node) {\r\n    node.prev = this.dummyHead\r\n    node.next = this.dummyHead.next\r\n    this.dummyHead.next.prev = node\r\n    this.dummyHead.next = node\r\n  }\r\n\r\n  removeLRUItem() {\r\n    let tail = this.popTail()\r\n    delete this.hash[tail.key]\r\n    this.count--\r\n  }\r\n\r\n  popTail() {\r\n    let tail = this.dummyTail.prev\r\n    this.removeFromList(tail)\r\n    return tail\r\n  }\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846086206","body":"### 思路\r\n* 终止条件：当前节点为空\r\n* 利用递归方法：节点为空时说明高度为 0，所以返回 0；节点不为空时则分别求左右子树的高度的最大值，同时加1表示当前节点的高度，返回该数值。\r\n### 代码\r\n```javascript\r\nvar maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0;\r\n    } else {\r\n        // 递归左右子节点\r\n        const left = maxDepth(root.left);\r\n        const right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Lizhao-Liu":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841683542","body":"**思路**\r\n\r\n遍历数组，划分当前数字前的排序快，栈中保存每排序块的最大值，确保head大小从左往右递增 （如果当前数字很小需要添加循环合并前面的排序块），返回栈的大小为排序块个数\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        for(int curr: arr){\r\n            if(!stack.empty() && curr<stack.peek()){\r\n                int max = stack.pop();\r\n                while(!stack.empty() && curr<stack.peek()){\r\n                    stack.pop();\r\n                }\r\n                stack.push(max);\r\n            }else{\r\n                stack.push(curr);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n**复杂度**\r\n\r\n时间复杂度 O(N)\r\n\r\n空间复杂度 O(N)"},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843634198","body":"**思路**\r\n\r\n使用双指针，分别遍历两个链表，当一个指针到达链表尾部则指向另一个练表头结点。\r\n\r\n若两个练表相交，则两个指针必会在最后相遇。\r\n\r\n若两个链表不相交，则走完两个链表长度之和的距离，两个指针同时为null，返回null。\r\n\r\n**代码**\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        ListNode a = headA;\r\n        ListNode b = headB;\r\n        while(a != b){\r\n            a = (a==null)? headB:a.next;\r\n            b = (b==null)? headA:b.next;\r\n        }\r\n        return a;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：<code>O(m+n)</code>\r\n- 空间复杂度：<code>O(1)</code>"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelh93":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/51#issuecomment-841684182","body":"思路：\r\n用栈保存分割片段中的最大值，只要后序的数字比栈顶的数字大，则是有效的分块，否则，栈顶的分块需要与较小的数进行合并分块。\r\n[参考题解](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-ii-deng-jie-/)\r\n代码：\r\n```javascript\r\nfunction maxChunksSorted(arr){\r\n  let stack = [];\r\n  let length = arr.length;\r\n  let head = null;\r\n  for(let i = 0; i < length; i++){\r\n    const item = arr[i];\r\n    if(stack.length == 0 || stack[stack.length - 1] <= item){\r\n      stack.push(item);\r\n    }else{\r\n      head = stack.pop();\r\n      //弹出所有大于item的值\r\n      while(stack.length >  0 && stack[stack.length - 1] > item){\r\n        stack.pop();\r\n      }\r\n      stack.push(head); // 合并分块\r\n    }\r\n  }\r\n  return stack.length;\r\n}\r\n```\r\n时间复杂度 O(N);\r\n空间复杂度O(N);"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841798293","body":"## 思路：\r\n闭合链表\r\n参考官方题解  \r\n1. 找出链表长度，通过取模取得实际移动次数。\r\n## 代码\r\n```javascript\r\n function rotateRight(head, k){\r\n\r\n    if(k === 0 || !head || !head.next){\r\n      return head;\r\n    }\r\n    let n = 1; // 获取链表长度。\r\n    let cur = head;\r\n    while(cur.next){\r\n      cur = cur.next;\r\n      n++;\r\n    }\r\n    let add = n - k % n;\r\n    //此时链表相当于没动。\r\n    if(add === n){\r\n      return head;\r\n    }\r\n\r\n    cur.next = head;\r\n    while(add){\r\n      cur = cur.next;\r\n      add--;\r\n    }\r\n    const ret = cur.next;\r\n    cur.next = null;\r\n    return ret;\r\n}\r\n```\r\n## 复杂度\r\n时间复杂度： O(N)\r\n空间复杂度： O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842175297","body":"## 思路 -> 官方题解  \r\n\r\n1. 递归.\r\n前一个链表的next是后一个链表交换之后的新节点。\r\n### 代码\r\n```js\r\n    function swapPairs(head){\r\n        // 考虑边界\r\n        if(!head || !head.next){\r\n            return head;\r\n        }\r\n        // 记录新头节点。\r\n        let newHead = head.next;\r\n        // 交换之后的next等于下一次交换的新节点。\r\n        head.next = swapPairs(newHead.next);\r\n        // 进行交换\r\n        newHead.next = head;\r\n        return newHead;\r\n    }\r\n```\r\n时间复杂度: O(n)\r\n空间复杂度：O(n)\r\n\r\n2. 迭代  \r\n增加一个前置节点tmp，3个数完成交换。交换之后，改变tmp的位置。  \r\n终止条件`tmp.next = null`或者`tmp.next.next = null`。  \r\n\r\n### 代码\r\n\r\n```js\r\n    function swapPairs(head){\r\n        const dummyHead = new ListNode(0);\r\n        dummyHead.next = head;\r\n\r\n        let temp = dummyHead;\r\n        // 交换temp的后2个节点。\r\n        while(temp.next !== null && temp.next.next !== null){\r\n            const node1 = temp.next;\r\n            const node2 = temp.next.next;\r\n            node2.next = node1;\r\n            node1.next = node2.next;\r\n            temp = node1;\r\n        }\r\n        // 第一次交换之后，dummyHead.next => newHead;\r\n        return dummyHead.next;\r\n    }\r\n```\r\n### 复杂度分析\r\n时间复杂度： O(N)\r\n空间复杂度:  O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843289379","body":"## 109.有序链表转换二叉搜索树\r\n\r\n## 思路\r\n看官方题解。使用`快慢指针`，找到中间节点。有个疑问，如果链表长度是偶数，如何处理，是否一定正确？\r\n\r\n## 代码\r\n```javascript\r\n    function sortedListToBST(head){\r\n        // 考虑边界\r\n        if(head == null) return null;\r\n        //使用快慢指针找到中点\r\n        let slow = head;\r\n        let fast = head;\r\n        let preSlow; // 保存slow的前一个节点\r\n        while(fast && fast.next){\r\n            preSlow = slow; // 记录最新的slow的前一个。\r\n            slow = slow.next; // 慢指针移动一步\r\n            fast = fast.next.next; // 快指针移动2步\r\n        }\r\n        const root = new TreeNode(slow.val); // 根据中间节点，创建根节点\r\n        if(preSlow != null){\r\n            preSlow.next = null; \r\n            root.left = sortedListToBST(head); // 构建左子树。为何这里是head?\r\n        }\r\n        root.right = sortedListToBST(slow.next); // 递归构建右子树\r\n        return root;\r\n    }\r\n```\r\n## 复杂度分析\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(logn)\r\n> 实际上还是不太清楚怎么算出来的。\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844239791","body":"## 思路\r\n双指针\r\n## 代码\r\n```javascript\r\nvar getIntersectionNode = function(headA, headB) {\r\n    let a = headA, b = headB\r\n    while(a != b){\r\n      a = a ? a.next : headB\r\n      b = b ? b.next : headA\r\n    }\r\n    return a;\r\n};\r\n```\r\n## 复杂度分析\r\nT：O(m+n)\r\nS:  O(1)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846054770","body":"## 思路\r\n哈希map ＋ 双向链表。实现查找和插入都是O(1)的复杂度\r\n\r\n## 代码 （翻译python）\r\n```javascript\r\nclass DLinkedNode {\r\n  constructor(key = 0, value = 0) {\r\n    this.key = key;\r\n    this.value = value;\r\n    this.prev = null;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass LRUCache {\r\n  constructor(capacity) {\r\n    this.cache = new Map();\r\n    this.capacity = capacity;\r\n    this.head = new DLinkedNode();\r\n    this.tail = new DLinkedNode();\r\n    this.head.next = this.tail;\r\n    this.tail.prev = this.head;\r\n    this.size = 0;\r\n  }\r\n  get(key) {\r\n    if (!this.cache.has(key)) {\r\n      return -1;\r\n    }\r\n    let node = this.cache.get(key);\r\n    this.moveToHead(node);\r\n    return node.value;\r\n  }\r\n  put(key, value) {\r\n    if (!this.cache.has(key)) {\r\n      let node = new DLinkedNode(key, value);\r\n      this.cache.set(key, node);\r\n      this.addToHead(node);\r\n      this.size++;\r\n      if (this.size > this.capacity) {\r\n        let removed = this.removeTail();\r\n        this.cache.delete(removed.key);\r\n        this.size--;\r\n      }\r\n    } else {\r\n      const node = this.cache.get(key);\r\n      node.value = value;\r\n      this.moveToHead(node);\r\n    }\r\n  }\r\n  addToHead(node) {\r\n    node.prev = this.head;\r\n    node.next = this.head.next;\r\n    this.head.next.prev = node;\r\n    this.head.next = node;\r\n  }\r\n  removeNode(node) {\r\n    node.prev.next = node.next;\r\n    node.next.prev = node.prev;\r\n  }\r\n  moveToHead(node) {\r\n    this.removeNode(node);\r\n    this.addToHead(node);\r\n  }\r\n  removeTail() {\r\n    const node = this.tail.prev;\r\n    this.removeNode(node);\r\n    return node;\r\n  }\r\n}\r\n```\r\n## 复杂度分析\r\nT: O(1)\r\nS: O(capacity)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846427186","body":"## 思路\r\n深度优先遍历，左子树和右子树中的最大值就是tree的maxDepth。\r\n\r\n## 代码\r\n\r\n```javascript\r\n  function maxDepth(root){\r\n    if(root === null) return 0;\r\n    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; // 1 为 根节点这一层 。\r\n  }\r\n```\r\n## 复杂度分析\r\n时间复杂度: O(n); // 每个节点都要遍历一次\r\n空间复杂度: O(depth); // 树的深度就是消耗的内存空间。  "},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846515746","body":"## 思路\r\n相同树的特点：\r\n1. root.val 相等\r\n2. root.left 相等\r\n3. root.right 相等\r\n可以采用深度优先遍历 DFS\r\n\r\n## 代码\r\n```javascript\r\n  function isSameTree(p, q){\r\n    // 考虑边界\r\n    // 都不存在\r\n    if(!p && !q) return true;\r\n    // p、q其中一个不存在\r\n    if(!p || !q) return false;\r\n    if(p.val !== q.val) return false;\r\n    // 比较左右节点树\r\n    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n\r\n  }\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(Math.min(p,q))"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klaus0323":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841755209","body":"\r\nThis question is straightforward, but the details are hard to comply. \r\nDetail 1, it's possible that the length of the linked list is SMALLER than k given in the question. If length is too small and k is too big, there could be multiple rotations over and over.\r\nDetail 2, how to count through the Linked List?\r\n\r\nMethodology: ( TWO-Pass solution )\r\n1. Use a pointer for counting, traverse through the entire linkedlist, then when the pointer reach the position that pointer.next is None, record the length of the linked list\r\n2. Use two pointers, first/second. At the beginning, these two are initialized at head. then use k as the counter, move the second pointer k steps forward, record the second pointer (here, the ending location of the second pointer is the **END** of the reversed linked list)\r\n3. adjust the linked list, be careful about where is the end and where is the new start. the new head of the result should be the next position of the second pointer.\r\n4. Overall the thinking process of the questions is not very hard, but details are not that easy to comply.\r\n\r\n\r\nHere is the code in python 3\r\n\r\n\r\n`\r\n\r\n  class Solution:\r\n      def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n          \r\n          # base case: empty list just return is OK\r\n          if not head: return None\r\n          \r\n          # first, calculate the length of the linked list\r\n          pointer = head\r\n          count = 1\r\n          while pointer.next:\r\n              pointer = pointer.next\r\n              count += 1\r\n              \r\n          # here, the k could be longer than the length of the linkedlist\r\n          k = k % count \r\n          if k == 0: return head\r\n          \r\n          # move the second until there are distance of k\r\n          first, second = head, head\r\n          while k > 0:\r\n              second = second.next\r\n              k -= 1\r\n          \r\n          # simultaneously move the first and second to the end while maintaining the k distance\r\n          while second.next:\r\n              first = first.next\r\n              second = second.next\r\n          \r\n          # now first is the end, re-adjust the entire linkedlist\r\n          begin = first.next\r\n          first.next = None\r\n          second.next = head\r\n          return begin\r\n            `"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15209356689":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841762702","body":"**1思路**\r\n1链表空，返回空，确定链表长度count ；2向右移动K 等于向右移动K%count ，那么返回的节点等于，head向右移动count-K%count；3原始链表后面链接到起始节点，返回节点前一位断开。\r\n**2代码PYTHON**\r\n```python\r\nDefinition for singly-linked list.\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if not head:return\r\n        bangnode=ListNode()\r\n        bangnode.next=head\r\n        temp=head\r\n        a=bangnode\r\n        count=0\r\n        while temp:\r\n            count+=1\r\n            temp=temp.next\r\n            a=a.next\r\n        a.next=head\r\n        k=count-k%count\r\n        if k==0:\r\n            return head\r\n        index=1\r\n        key=head\r\n        while index<k:\r\n            key=key.next\r\n            index+=1\r\n        res=key.next\r\n        key.next=None\r\n        return res\r\n ```\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)  N是链表的长度\r\n- 空间复杂度：O(1)"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843676866","body":"**1思路**\r\n1找出2个链表的长度lena和lenb，和他们的长度差diff;\r\n2让更长先走diff步，再比较thelonger和theshorter什么时候相等\r\n\r\n**2代码PYTHON**\r\n``` python\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a,b=headA,headB\r\n        lena,lenb=0,0\r\n        while a:\r\n            a=a.next\r\n            lena+=1\r\n        while b:\r\n            b=b.next\r\n            lenb+=1\r\n        if lena>=lenb:\r\n            diff=lena-lenb\r\n            thelonger=headA\r\n            theshorter=headB\r\n        else:\r\n            diff=lenb-lena\r\n            thelonger=headB\r\n            theshorter=headA\r\n        count=0\r\n        while count<diff:\r\n            thelonger=thelonger.next\r\n            count+=1\r\n        while thelonger!=theshorter:\r\n            thelonger=thelonger.next\r\n            theshorter=theshorter.next\r\n        return thelonger\r\n```\r\n\r\n**3复杂度分析**\r\n\r\n- 时间复杂度：O(M+N)\r\n\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844590470","body":"**1思路**\r\n1有环的链表，用快慢指针，记住一个规律：设置一个快指针，一个慢指针，都一开始从链表head开始，快指针一次走两步，慢指针一次走1步，当它们第一次相遇的时候，将快指针重新指向head，然后和慢指针继续一次走一步，当他们再次相遇的时候，所指向的即为环的入口点\r\n\r\n**2代码PYTHON**\r\n``` python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        fast,slow=head,head\r\n        while True:\r\n            if not fast or not fast.next:\r\n                return None\r\n            fast=fast.next.next\r\n            slow=slow.next\r\n            if fast==slow:\r\n                break\r\n        fast=head\r\n        while fast!=slow:\r\n            fast=fast.next\r\n            slow=slow.next\r\n        return fast\r\n```\r\n\r\n**3复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845576370","body":"**1思路**\r\n1用1个MAXSIZE代表初始化的缓存带下，用一nums表示当前缓存池的缓存数量，用一个字典来记录关键字和关键字的数据，用一个stack来记录关键字，并根据数组的位置来表示关键字的最近使用情况（最近使用的放后面）\r\n2put的时候 先判断nums与MAXSIZE的关系，然后判断关键字时候再字典里面，然后进行相应的字典和数组的变化\r\n3get的时候 判断关键字是否在字典里面，并进行stack的变化，将相应的关键字在stack的存储位置放到数组最后。\r\n\r\n**2代码PYTHON**\r\n``` python\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.maxsize=capacity\r\n        self.nums=0\r\n        self.dict1={}\r\n        self.stack=[]\r\n    def get(self, key: int) -> int:\r\n        if key not in self.dict1:\r\n            return -1\r\n        else:\r\n            self.stack.remove(key)\r\n            self.stack.append(key)\r\n            return  self.dict1[key]\r\n    def put(self, key: int, value: int) -> None:\r\n        if self.nums<self.maxsize:\r\n            if key in self.dict1:\r\n                self.dict1[key]=value\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            else:\r\n                self.nums+=1\r\n                self.dict1[key]=value\r\n                self.stack.append(key)\r\n        else:\r\n            if key in self.dict1:\r\n                self.dict1[key]=value\r\n                self.stack.remove(key)\r\n                self.stack.append(key)\r\n            else:\r\n                self.dict1[key]=value\r\n                del self.dict1[self.stack[0]]\r\n                self.stack.pop(0)\r\n                self.stack.append(key)\r\n```\r\n\r\n**3复杂度分析**\r\n\r\n- 时间复杂度：put O(N)  主要是数组变化的时候需要,get O(N)   更新关键字的使用情况  也是数组的变化\r\n\r\n- 空间复杂度：O(N)  多用一个数组存储 和字典"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gjm12345":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841812982","body":"\r\n## 思路\r\n首先遍历一次链表获取尾部结点指针以及链表长度，然后移动位数k对链表长度做取余来得到需要移动的次数。对于移动操作，可以将尾部部分链表移动到头部，并把原来的头部作为尾部节点的下一个节点即可，返回移动的尾部部分的头节点作为head。该尾部部分是移动length-k后的节点的下一个节点作为头节点。\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @param {number} k\r\n * @return {ListNode}\r\n */\r\nvar rotateRight = function(head, k) {\r\n    if(k===0||head===null||head.next===null)\r\n        return head\r\n    let goNode = head, length = 1\r\n    while(goNode.next!==null){\r\n        length++\r\n        goNode = goNode.next\r\n    }\r\n    k = k%length\r\n\r\n    if(k===0)\r\n        return head\r\n    \r\n    let prenode = head\r\n    for(let i = 0;i<length-k-1;i++){\r\n        prenode = prenode.next\r\n    }\r\n    let node = prenode.next\r\n    prenode.next = null\r\n    goNode.next=head\r\n    return node\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nweass":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841820526","body":"## 思路\r\n\r\n### 快慢指针\r\n\r\n> 当k为链表长度的整数倍时，会旋转回到原位置，实际移动位置为k对链表长度取余，减少移动次数\r\n\r\n## 代码\r\n\r\n```java\r\n//快慢指针\r\nclass Solution {\r\n   public ListNode rotateRight(ListNode head, int k) {\r\n        //边界处理\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n       \r\n       ListNode fast = head;\r\n       ListNode slow = head;\r\n       \r\n       int len = 0;\r\n       while(len< k && fast != null){\r\n           len++;\r\n           fast = fast.next;\r\n       }\r\n       if(fast !=null){\r\n           k = k%len;\r\n           if(k == 0){\r\n               return head;\r\n           }\r\n           fast =head;\r\n           for(int i=0; i<k ; i++){\r\n               fast = fast.next;\r\n           }\r\n       }\r\n       while(fast.next != null){\r\n           fast = fast.next;\r\n           slow = slow.next;\r\n           \r\n           \r\n       }\r\n       //当快指针走到底时，此时慢指针的下一个节点就是新的头节点\r\n        ListNode newHead = slow.next;\r\n        //慢指针当前节点就是尾节点\r\n        slow.next = null;\r\n        //快指针的下一节点（就是原来链表的最后一个节点）链上原来的头节点即可\r\n        fast.next = head;\r\n        //最后返回新的头节点\r\n        return newHead;\r\n\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度：O(n)\r\n\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842367307","body":"## 思路\r\n\r\n每次两两交换链表节点操作相同，使用递归\r\n\r\n> 注意\r\n>\r\n> * 每奇数位链表节点与偶数位链表节点交换，\r\n\r\n## 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null || head.next ==null){\r\n            return head;\r\n        }\r\n        ListNode p = head.next;\r\n        head.next = swapPairs(p.next);\r\n        p.next = head;\r\n        return p;\r\n\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n\r\n时间复杂度： 递归深度* 运算次数 O(n)\r\n\r\n空间复杂度：没有使用额外的容器 O(1) "},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simplezhao":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841824700","body":"目前还有问题。。。\r\n```python\r\nclass Solution(object):\r\n    def rotateRight(self, head, k):\r\n        \"\"\"\r\n        :type head: ListNode\r\n        :type k: int\r\n        :rtype: ListNode\r\n        \"\"\"\r\n        print(head)\r\n        if head is None or head.next is None:\r\n            return head\r\n        if head.next.next is None:\r\n            if k % 2 == 1:\r\n                _head = head\r\n                head = head.next\r\n                head.next = _head\r\n                _head.next = None\r\n            return head\r\n        for t in range(k):\r\n            next = head.next\r\n            while next:\r\n                if next.next.next is None:\r\n                    print(next.next.val)\r\n                    _head = head\r\n                    # _next = head.next\r\n                    head = next.next\r\n                    head.next = _head\r\n                    next.next = None\r\n                    break\r\n                else:\r\n                    next = next.next\r\n\r\n        return head\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841830454","body":"### 思路\r\n1.根据k把链表分成前后两段，前面一段连接到后面一段的末尾\r\n2.k可以根据链表的长度取模处理\r\n\r\n### 代码\r\n\r\n```py \r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if head is None:\r\n            return head\r\n        sentinel = ListNode(val=0, next=head)\r\n        len = 0\r\n        tail = sentinel\r\n        while tail.next:\r\n            len += 1\r\n            tail = tail.next\r\n        k = k % len\r\n        if k == 0:\r\n            return head\r\n        p = sentinel\r\n        for i in range(0, len - k):\r\n            p = p.next\r\n        tail.next = head\r\n        head = p.next\r\n        p.next = None\r\n        return head\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N), N为链表长度 N. 先遍历了一遍获取长度(N), 找到新的head位置(N - K), N + (N - K) -> O(N)\r\n- 空间复杂度：O(1), 没占额外空间"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842380014","body":"### 思路\r\n\r\n<img width=\"482\" alt=\"iShot2021-05-17 22 36 49\" src=\"https://user-images.githubusercontent.com/20655328/118507116-84577680-b760-11eb-8af3-2e65c0e4987e.png\">\r\n\r\n### 代码\r\n\r\n```python3\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        sentinel = ListNode(val=-1,next=head)\r\n        p0 = sentinel\r\n        while True:\r\n            p1 = p0.next\r\n            if p1 is None:\r\n                break\r\n            p2 = p1.next\r\n            if p2 is None:\r\n                break\r\n            p3 = p2.next\r\n            \r\n            p0.next = p2\r\n            p1.next = p3\r\n            p2.next = p1\r\n            p0 = p1\r\n        return sentinel.next\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843250978","body":"### 思路\r\n本质是中序遍历结果构造BST, 树是平衡的所以root在中间, 左边元素是左子树, 右边元素是右子树, 递归求解.  \r\n利用快慢指针获取链表的中间元素, 原理很简单, 实现上费了点劲, 主要是指针移动操作和终止条件要想清楚.  \r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if head is None:\r\n            return None\r\n        leftTail, slow, fast = None, head, head\r\n        while fast and fast.next:\r\n            fast = fast.next.next\r\n            leftTail = slow\r\n            slow = slow.next\r\n        root = TreeNode(val=slow.val)\r\n        if leftTail is not None:\r\n            leftTail.next = None\r\n            root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(NlogN) \r\n- 空间复杂度：O(logN)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844210995","body":"### 思路\r\n讲义里的双指针  \r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n\r\n**时间复杂度**\r\n- 时间复杂度: O(m+n)\r\n- 空间复杂度: O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845165490","body":"### 思路\r\n讲义里写的, 自己证明下加深理解  \r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        slow, fast = head, head\r\n        while True:\r\n            if fast and fast.next:\r\n                fast = fast.next.next\r\n            else:\r\n                fast = None\r\n            slow = slow.next\r\n            if slow == fast:\r\n                break\r\n        if not fast:\r\n            return None\r\n        fast = head\r\n        while fast != slow:\r\n            fast = fast.next\r\n            slow = slow.next\r\n        return fast\r\n```\r\n\r\n***复杂度分析***\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(1)\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846022754","body":"### 思路\r\n1. 偷懒直接用python的dict做hash表\r\n2. 双链表的插入和删除操作\r\n3. 用哨兵简化链表操作\r\n\r\n### 代码\r\n```python3\r\nclass ListNode:\r\n    def __init__(self, key: int = 0, val: int = 0, next=None, prev=None):\r\n        self.key: int = key\r\n        self.val: int = val\r\n        self.next: ListNode = next\r\n        self.prev: ListNode = prev\r\n\r\n\r\nclass LRUCache:\r\n    def __init__(self, capacity: int):\r\n        self.__capacity: int = capacity\r\n        self.__dict: Dict = {}\r\n        self.__dummyHead: ListNode = ListNode()\r\n        self.__dummyTail: ListNode = ListNode()\r\n        self.__dummyHead.next = self.__dummyTail\r\n        self.__dummyTail.prev = self.__dummyHead\r\n\r\n    def get(self, key: int) -> int:\r\n        node: ListNode = self.__dict.get(key)\r\n        if not node:\r\n            return -1\r\n        self.__delete(node)\r\n        self.__insertFirst(node)\r\n        return node.val\r\n\r\n    def __delete(self, node: ListNode) -> None:\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def __insertFirst(self, node: ListNode) -> None:\r\n        node.prev = self.__dummyHead\r\n        node.next = self.__dummyHead.next\r\n        node.prev.next = node\r\n        node.next.prev = node\r\n\r\n    def __evict(self) -> None:\r\n        if len(self.__dict) <= self.__capacity:\r\n            return\r\n        last = self.__dummyTail.prev\r\n        self.__delete(last)\r\n        del self.__dict[last.key]\r\n\r\n    def put(self, key: int, val: int) -> None:\r\n        node: ListNode = self.__dict.get(key)\r\n        if node:\r\n            node.val = val\r\n            self.__delete(node)\r\n            self.__insertFirst(node)\r\n        else:\r\n            node = ListNode(key=key, val=val)\r\n            self.__dict[key] = node\r\n            self.__insertFirst(node)\r\n            self.__evict()\r\n```\r\n\r\n***复杂度分析***\r\n- put\r\n  - 时间复杂度: O(1)\r\n  - 空间复杂度: O(1)\r\n- get\r\n  - 时间复杂度: O(1)\r\n  - 空间复杂度: O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846335222","body":"### 思路\r\n递归\r\n\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        return 0 if not root else (max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1)\r\n```\r\n\r\n***复杂度分析***\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cengjingeng":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841832813","body":"### 思路\r\n首先求出链表的长度，然后把链表最后一位值的 next 指向原链表首位数字，形成闭环，最后创建一个变量，接收从 k 处截断后的链表，k+1赋值null\r\n### 代码\r\n```python3\r\nclass Solution:\r\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\r\n        if k == 0 or not head or not head.next:\r\n            return head\r\n        \r\n        n = 1\r\n        cur = head\r\n        while cur.next:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        if (add := n - k % n) == n:\r\n            return head\r\n        \r\n        cur.next = head\r\n        while add:\r\n            cur = cur.next\r\n            add -= 1\r\n        \r\n        ret = cur.next\r\n        cur.next = None\r\n        return ret\r\n```\r\n### 复杂度\r\n时间复杂度O(N)\r\n空间复杂度O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ThreeGold-yxh":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/52#issuecomment-841835557","body":"#### [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n### 题目\r\n\r\n[61. 旋转链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/rotate-list/)\r\n\r\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4,5], k = 2\r\n输出：[4,5,1,2,3]\r\n\r\n\r\n\r\n 示例2：\r\n\r\n输入：head = [0,1,2], k = 4\r\n输出：[2,0,1]\r\n\r\n\r\n提示：\r\n\r\n链表中节点的数目在范围 [0, 500] 内\r\n-100 <= Node.val <= 100\r\n0 <= k <= 2 * 109\r\n\r\n\r\n\r\n## 思路 ：多次反转链表\r\n\r\n总体思路是模仿旋转数组的思想，先将链表整体反转一次，然后将前k个元素反转一次，再将后面剩下的元素反转一次，即可实现链表的旋转。\r\n\r\n注意如果head为null，直接返回null\r\n\r\n如果(k = k % length) ==0 , 直接返回head，不做任何处理\r\n\r\n除上述两种情况外都要正常处理链表，首先将链表反转一次（反转方法为利用头插法反转），然后找到第k个元素和第k+1个元素，断链，然后再反别反转前半部分和后半部分，最后再把他们连起来即可。\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果给的空head，直接返回null\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        //先拿到链表长度\r\n        int length = getLength(head);\r\n        //更新一下k值\r\n        k = k % length;\r\n        //如果k为0.直接输出即可\r\n        if(k==0){\r\n            return head;\r\n        }\r\n        //先把链表反转一次\r\n        head = reverseLinkedList(head);\r\n        //拿到第k个元素和第k+1个元素的指针\r\n        ListNode kNode = head;\r\n        while(--k>0){\r\n            kNode = kNode.next;\r\n        }\r\n        ListNode kNextNode = kNode.next;\r\n        //断链 kNode.next = null;\r\n        kNode.next = null;\r\n        //分别把前k个元素和后面的元素反转\r\n        ListNode headTemp = reverseLinkedList(head);\r\n        //head此时指向前k个元素的尾巴\r\n        head.next = reverseLinkedList(kNextNode);\r\n        //更新head值\r\n        head = headTemp;\r\n        //返回head\r\n        return head;\r\n    }\r\n    //利用头插法反转链表方法\r\n    public ListNode reverseLinkedList(ListNode head){\r\n        ListNode s = head;\r\n        ListNode sNext = head;\r\n        ListNode p = null;\r\n        while(sNext!=null){\r\n            s = sNext;   //更新等待头插的结点\r\n            sNext = s.next;  //sNext后移，保存一下。避免断链\r\n            s.next = p;  //开始头插\r\n            p = s; //更新p结点，下一次等待头插的结点去头插p\r\n        }\r\n        //最后返回反转后的头结点\r\n        return p;\r\n    }\r\n\r\n    //计算链表长度\r\n    public int getLength(ListNode head){\r\n        ListNode p = head;\r\n        int length = 0;\r\n        while(p!=null){\r\n            length++;\r\n            p = p.next;\r\n        }\r\n        return length;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n### 复杂度\r\n\r\n时间复杂度 o(n)\r\n\r\n空间复杂度o(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841948016","body":"#### [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n## 题目\r\n\r\n[24. 两两交换链表中的节点 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\r\n\r\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\r\n\r\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\r\n\r\n示例 1：\r\n\r\n输入：head = [1,2,3,4]\r\n输出：[2,1,4,3]\r\n\r\n示例 2：\r\n\r\n输入：head = []\r\n输出：[]\r\n\r\n示例 3：\r\n\r\n输入：head = [1]\r\n输出：[1]\r\n\r\n\r\n\r\n## 思路一\r\n\r\n用奇数odd和偶数even两个指针来遍历，用一个nextOdd来保存下一个奇数位置结点，避免断链，交换完后连接链表结点的时候注意要分：后面还剩0个结点，还剩1个结点，还剩3个结点共三种情况来讨论\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n//用奇数odd和偶数even两个指针来遍历，用一个nextOdd来保存下一个奇数位置结点，避免断链\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n\r\n        if(head.next == null){\r\n            return head;\r\n        }\r\n\r\n        ListNode odd = null;\r\n        ListNode even = null;\r\n        ListNode nextOdd = head;\r\n        head = head.next;\r\n\r\n        while(nextOdd!=null && nextOdd.next != null){\r\n            //更新odd和even\r\n            odd = nextOdd;\r\n            even = odd.next;\r\n            //保存下一个odd结点，避免断链\r\n            nextOdd = even.next;\r\n            //操作结点   \r\n            even.next = odd;\r\n            //链接结点\r\n            if(nextOdd!=null){\r\n                //后面还有至少两个结点\r\n                if(nextOdd.next!=null){\r\n                    odd.next = nextOdd.next;\r\n                }\r\n                //后面只剩一个结点了\r\n                else{\r\n                    odd.next = nextOdd;\r\n                }\r\n            }\r\n            //后面没有结点了\r\n            else{\r\n                odd.next = null;\r\n            }\r\n\r\n        }\r\n\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$o(n)$\r\n\r\n空间复杂度：$o(1)$\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843233852","body":"#### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)\r\n\r\n\r\n\r\n## 题目\r\n\r\n给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。\r\n\r\n本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。\r\n\r\n![image-20210518170615775](C:\\Users\\ASUS\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210518170615775.png)\r\n\r\nGiven the head of a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.\r\n\r\nFor this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.\r\n\r\nExample 1:\r\n\r\nInput: head = [-10,-3,0,5,9]\r\nOutput: [0,-3,9,-10,null,5]\r\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\r\n\r\nExample 2:\r\n\r\nInput: head = []\r\nOutput: []\r\n\r\nExample 3:\r\n\r\nInput: head = [0]\r\nOutput: [0]\r\n\r\nExample 4:\r\n\r\nInput: head = [1,3]\r\nOutput: [3,1]\r\n\r\n\r\n\r\n## 思路一：有序链表转换成有序数组\r\n\r\n第一种方法，把有序链表转换成有序数组，然后我们认为这个数组的中间元素就是二叉搜索树的根，它的左边部分的中间元素是左分支树的根，它的右边部分的中间元素是右分支树的根，以此类推。\r\n\r\n利用分而治之的思想将建树缩小为局部的：找到根节点，连接其左分支树根节点，连接其右分支树根节点，找到中间元素的方法：mid = left + (right - left +1) / 2; \r\n\r\n递归退出条件：left>right时return null，因为叶子节点应该都存在left == right，它们再继续往下递归，不管是左子树还是右子树都会发生left>right，return null作为结束条件\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n//第一种方法，把有序链表转换成有序数组，然后我们认为这个数组的中间元素就是二叉搜索树的根，\r\n //它的左边部分的中间元素是左分支树的根，它的右边部分的中间元素是右分支树的根，以此类推\r\n //利用分而治之的思想将建树缩小为局部的：找到根节点，连接其左分支树根节点，连接其右分支树根节点\r\n //找到中间元素的方法：mid = left + (right - left +1) / 2;\r\n //递归退出条件：left>right时return null，因为叶子节点应该都存在left == right，它们再继续往下递归\r\n //不管是左子树还是右子树都会发生left>right，return null作为结束条件\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        //创建用来保存链表中元素的数组\r\n        List<Integer> list = new ArrayList<>();\r\n        //遍历链表，添加到数组中\r\n        for(ListNode element = head; element != null; element = element.next){\r\n            list.add(element.val);\r\n        }\r\n        return buildBST(0,list.size() - 1,list);\r\n    }\r\n\r\n    public TreeNode buildBST(int left, int right, List<Integer> list){\r\n        //先给出递归的出口\r\n        if(left>right){\r\n            return null;\r\n        }\r\n        //根据下标mid在list中拿到中间元素，并生成结点\r\n        int mid = left + (right - left + 1) / 2;\r\n        TreeNode root = new TreeNode(list.get(mid));\r\n        //连接左右子树\r\n        root.left = buildBST(left,mid-1,list);\r\n        root.right = buildBST(mid+1,right,list);\r\n        //最后才是返回root\r\n        return root;\r\n    }\r\n}\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844206103","body":"#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)\r\n\r\n## 题目\r\n\r\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\n输出：Reference of the node with value = 8\r\n输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\r\n\r\n\r\n\r\n## 思路一\r\n\r\n辅助set集合标记法\r\n\r\n​        先从一个头结点出发完整的遍历一次，把遍历到的结点都放进set中，再从另一个结点出发，又遍历一遍，如果set返回的是null那么说明当前元素已经被遍历过加进set中了，则这个元素就是两个链表相交的起始交点\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n//辅助set集合标记法\r\n //先从一个头结点出发完整的遍历一次，把遍历到的结点都放进set中，再从另一个结点出发，又遍历一遍，如果set返回的是null\r\n //那么说明当前元素已经被遍历过加进set中了，则这个元素就是两个链表相交的起始交点\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        //创建标记set集合\r\n        Set<ListNode> mySet = new HashSet<>();\r\n        //遍历headA，时间复杂度是o(n)\r\n        ListNode mid = headA;\r\n        while(mid!=null){\r\n            mySet.add(mid);\r\n            mid = mid.next;\r\n        }\r\n        //再去从headB开始遍历\r\n        mid = headB;\r\n        while(mid!=null){\r\n            //如果set返回false，说明有重复\r\n            if(!mySet.add(mid)){\r\n                return mid;\r\n            }\r\n            mid = mid.next;\r\n        }\r\n        //遍历完也没发现有重复元素，说明两链表不相交\r\n        //直接返回null即可。\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$o(n)\r\n\r\n分析：因为相当于把两个链表都遍历了一遍\r\n\r\n空间复杂度：$o(n)\r\n\r\n分析：因为创建了辅助set集合，所以辅助空间为n\r\n\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845087594","body":"#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)\r\n\r\n\r\n\r\n## 题目\r\n\r\n给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\r\n\r\n为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。\r\n\r\n说明：不允许修改给定的链表。\r\n\r\n进阶：\r\n\r\n你是否可以使用 O(1) 空间解决此题？\r\n\r\n\r\n\r\n## 思路一\r\n\r\n方法一：用快慢指针来解决\r\n\r\n假设环外元素有m个，环内元素有n个，设置一个慢指针slow和快指针fast指向头结点\r\n\r\n假设慢指针走了m步到达入环第一个结点node处后又走了x步才与快指针相遇\r\n\r\n注意，此时慢指针一定还没有在环内走一圈，这是因为假设最坏的情况\r\n\r\n在慢指针进入环时（指向node处），快指针刚好指向node的下一个结点\r\n\r\n这种最坏情况快指针需要追整整n - 1步才能追上慢指针（一回合追一格）\r\n\r\n注意环内有n个元素意味着一个指针走n步后回到它本身，也就是指向node的指针走n - 1步后来到链表的尾巴\r\n\r\n而即使最坏情况下快指针需要追n-1步，这时慢指针也没有走完第一圈\r\n\r\n那么我们的快指针走了多少步？首先走了m步来到node，然后假设在环内里走了k圈，一共k * n步\r\n\r\n最后走了x步与慢指针相遇，一共是m + k * n + x步\r\n\r\n我们可以得到 m + k * n + x = 2 * (m + x)\r\n\r\n解得：k * n = m + x ,即m = k * n - x\r\n\r\n一个指针走了m步，等于另一个指针走了k * n - x步，假设我们设这另一个指针就是快慢指针相遇的那个位置指针\r\n\r\n它同步往前走k * n - x步会到哪里？ 相当于走了k * n步回到原位置，然后倒着走了x步来到node结点位置！！！\r\n\r\n这此前假如有一个从头结点出发的指针与其同步走m步，他们就会在node相遇！！！\r\n\r\n注意如果链表不成环，fast会先一步走到null或者fast.next为null此时直接抛null即可\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n //方法一：用快慢指针来解决\r\n //假设环外元素有m个，环内元素有n个，设置一个慢指针slow和快指针fast指向头结点\r\n //假设慢指针走了m步到达入环第一个结点node处后又走了x步才与快指针相遇\r\n //注意，此时慢指针一定还没有在环内走一圈，这是因为假设最坏的情况\r\n //在慢指针进入环时（指向node处），快指针刚好指向node的下一个结点\r\n //这种最坏情况快指针需要追整整n - 1步才能追上慢指针（一回合追一格）\r\n //注意环内有n个元素意味着一个指针走n步后回到它本身，也就是指向node的指针走n - 1步后来到链表的尾巴\r\n //而即使快指针需要追n-1步，这时慢指针也没有走完第一圈\r\n //那么我们的快指针走了多少步？首先走了m步来到node，然后假设在环内里走了k圈，一共k * n步\r\n //最后走了x步与慢指针相遇，一共是m + k * n + x步\r\n //我们可以得到 m + k * n + x = 2 * (m + x)\r\n //解得：k * n = m + x ,即m = k * n - x\r\n //一个指针走了m步，等于另一个指针走了k * n - x步，假设我们设这另一个指针就是快慢指针相遇的那个位置指针\r\n //它同步往前走k * n - x步会到哪里？ 相当于走了k * n步回到原位置，然后倒着走了x步来到node结点位置！！！\r\n //这此前假如有一个从头结点出发的指针与其同步走m步，他们就会在node相遇！！！\r\n //注意如果链表不成环，fast会先一步走到null或者fast.next为null此时直接抛null即可\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null) return null;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        //注意不能这样写while(slow!=fast) 因为一开始它们就是相等的\r\n        while(true){\r\n            //如果链表根本不成环\r\n            if(fast==null||fast.next==null){\r\n                return null;\r\n            }\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow==fast)break;\r\n        }\r\n        //此时已经找到了相遇点\r\n        //新建一个从头开始遍历的指针\r\n        ListNode tempIndicator = head;\r\n        while(tempIndicator!=fast){\r\n            tempIndicator = tempIndicator.next;\r\n            fast = fast.next;\r\n        }\r\n        return tempIndicator;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度: $o(n)$\r\n\r\n分析：因为我一开始slow没有走完一个环，为o(n)，接下来tempIndicator走了m步就结束了，也是o(n)，最后o(n)+o(n)结果还是o(n)\r\n\r\n空间复杂度：o(1)\r\n\r\n分析：只创建了三个指针\r\n\r\n\r\n\r\n\r\n\r\n## 思路二\r\n\r\n方法二，用Set集合然后遍历一下，有加不进去set里的结点直接返回\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null){\r\n            return null;\r\n        }\r\n        Set<ListNode> set = new HashSet<>();\r\n        ListNode indicator = head;\r\n        //遍历，都添加到set中，如果有加不进去的，证明那个元素为重复的，就是我们需要的返回值\r\n        while(indicator!=null){\r\n            if(set.add(indicator)== false ){\r\n                return indicator;\r\n            }\r\n            indicator = indicator.next;\r\n        }\r\n        //都加的进去，没有重复的，直接null\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度 $o(n)$  \r\n\r\n分析：只遍历了一遍\r\n\r\n空间复杂度：$o(n)$  \r\n\r\n分析：构造了一个set集合，辅助空间为o(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846050895","body":"#### [146. LRU 缓存机制](https://leetcode-cn.com/problems/lru-cache/)\r\n\r\n## 题目\r\n\r\n运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。\r\n实现 LRUCache 类：\r\n\r\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存\r\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\r\nvoid put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。\r\n\r\n\r\n进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？\r\n\r\n\r\n\r\n## 思路一\r\n\r\n这题应该要用一个哈希表和一个双向链表组成哈希链表，哈希表负责根据key迅速拿到对应双向链表中的结点node，然后根据这个node在双向链表中操作结点，即可o(1)内完成操作\r\n\r\n我们利用java集合类里的LinkedHashMap来解决这个问题，这是已经创建好的哈希链表\r\n\r\n```java\r\n/**\r\n * //调用父类HashMap的构造方法。\r\n * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance\r\n * with the default initial capacity (16) and load factor (0.75).\r\n */\r\npublic LinkedHashMap() {\r\n    super();\r\n    accessOrder = false;\r\n}\r\n// 这里的 accessOrder 默认是为false，如果要按读取顺序排序需要将其设为 true\r\n// initialCapacity 代表 map 的 容量，loadFactor 代表加载因子 (默认即可)\r\npublic LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) {\r\n    super(initialCapacity, loadFactor);\r\n    this.accessOrder = accessOrder;\r\n}\r\n\r\n\r\n```\r\n\r\n*accessOrder*  为true，就会开启按读取顺序排序\r\n\r\n之后思路基本参照[源于 LinkedHashMap源码 - LRU 缓存机制 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/lru-cache/solution/yuan-yu-linkedhashmapyuan-ma-by-jeromememory/)\r\n\r\n重写removeEldestEntry方法，让它在size() > capacity后返回true激活afterNodeInsertion，也就是之前写好的LRU算法\r\n\r\n但是因为removeEldestEntry一直默认返回false所以处于关闭状态\r\n\r\n之后会进一步补充理解，今天时间太紧张，还有思路二，就是自己手写的哈希链表后面也会补上去\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\nclass LRUCache extends LinkedHashMap<Integer, Integer>{\r\n    private int capacity;\r\n    \r\n    public LRUCache(int capacity) {\r\n        super(capacity, 0.75F, true);\r\n        this.capacity = capacity;\r\n    }\r\n\r\n    public int get(int key) {\r\n        return super.getOrDefault(key, -1);\r\n    }\r\n\r\n    // 这个可不写\r\n    public void put(int key, int value) {\r\n        super.put(key, value);\r\n    }\r\n\r\n    @Override\r\n    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {\r\n        return size() > capacity; \r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度:$o(1)$\r\n\r\n空间复杂度:$o(n)$\r\n\r\n分析：维护了一个hash表和一个双向链表"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846407528","body":"#### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)\r\n\r\n## 题目\r\n\r\n给定一个二叉树，找出其最大深度。\r\n\r\n二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\r\n\r\n说明: 叶子节点是指没有子节点的节点。\r\n\r\n示例：\r\n给定二叉树 [3,9,20,null,null,15,7]，\r\n\r\n​    3\r\n\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n返回它的最大深度 3 。\r\n\r\n\r\n\r\n\r\n\r\n## 思路一\r\n\r\n用深度优先遍历，借助递归实现\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\n //递归方法的深度优先搜索解决二叉树深度问题\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        return maxDepthOfTree(root);\r\n    }\r\n\r\n    private int maxDepthOfTree(TreeNode root){\r\n        //给出出口\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n\r\n        //左右树深度\r\n        int leftDepth = maxDepthOfTree(root.left);\r\n        int rightDepth = maxDepthOfTree(root.right);\r\n\r\n        return leftDepth>=rightDepth?(leftDepth+1) : (rightDepth+1);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$o(n)$\r\n\r\n分析：因为它相当于把树中的每个结点都遍历了一遍\r\n\r\n空间复杂度：$o(n)$\r\n\r\n分析：因为递归所用的辅助栈规模为n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 思路二\r\n\r\n依靠辅助队列的广度优先搜索解决二叉树深度问题\r\n\r\n我们可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 \\textit{ans}ans 来维护拓展的次数，该二叉树的最大深度即为 ans\r\n\r\n那么怎么将队列里所有节点都拿出来拓展呢？我们可以维护一个变量size，它代表每一层结点的个数，只要size不为0\r\n\r\n就说明这一层没拓展完，就继续poll出一个结点来，把它的左右子结点offer进来，当size为0，说明这一层遍历完了，ans++即可。\r\n\r\n\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        //深度\r\n        int ans = 0;\r\n        //创建队列\r\n        Queue<TreeNode> queue = new LinkedList<>();\r\n        //把根结点装进来\r\n        queue.offer(root);\r\n        \r\n        //只要队列不彻底为空，就可以继续循环\r\n        while(!queue.isEmpty()){\r\n            //维护一个size，等于当前的queue.size(),也就是这一层的结点个数\r\n            int size = queue.size();\r\n            //只要这一层的结点还没有全部遍历完，循环就不会结束\r\n            while(size!=0){\r\n                //拿出一个结点\r\n                TreeNode node = queue.poll();\r\n                //遍历它，看它左右子结点存不存在，存在就拿进来，为遍历下一层做准备\r\n                if(node.left!=null){\r\n                    queue.offer(node.left);\r\n                }\r\n\r\n                if(node.right!=null){\r\n                    queue.offer(node.right);\r\n                }\r\n\r\n                //这一个结点遍历完了，咱们要把size--，也就是这一层少了一个结点\r\n                size --;\r\n            }\r\n            //这一层结点都遍历完了，咱们要把ans++\r\n            ans++;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：$o(n)$\r\n\r\n分析：因为它相当于把树中的每个结点都遍历了一遍\r\n\r\n空间复杂度：$o(n)$\r\n\r\n分析：因为所用的辅助队列占用大小为n的空间\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841913620","body":"## 思路\r\n\r\n递归\r\n\r\n## 代码(python)\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next: return head\r\n        new_head = head.next\r\n        head.next = self.swapPairs(new_head.next)\r\n        new_head.next = head\r\n        return new_head\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843086283","body":"## 思路\r\n\r\n找链表中间节点作为根节点，然后再找中点两边的子链表的中点，一直递归下去直到子链表为空\r\n\r\n## 代码(python)\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n# Definition for a binary tree node.\r\n# class TreeNode:\r\n#     def __init__(self, val=0, left=None, right=None):\r\n#         self.val = val\r\n#         self.left = left\r\n#         self.right = right\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        elif not head.next:\r\n            return TreeNode(head.val)\r\n\r\n        pre,slow,fast = None,head,head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n\r\n        root = TreeNode(slow.val)\r\n        pre.next = None\r\n\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(slow.next)\r\n        return root\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(logn)\r\n"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845019973","body":"## 思路\r\n\r\n双指针法\r\n\r\n## 代码(python)\r\n\r\n```python\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        # fast,slow = head,head\r\n        # while True：\r\n        #     if not (fast and fast.next):return\r\n        #     fast,slow = fast.next.next,slow.next\r\n        #     if fast == slow:break\r\n        # fast = head\r\n        # while fast != slow:\r\n        #     fast,slow = fast.next,slow.next\r\n        # return fast\r\n\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jz1433":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841915661","body":"### 思路\r\niterative\r\n\r\n### 代码\r\n``` python\r\nclass Solution:\r\n        \r\n    def swapPairs(self, head: ListNode) -> ListNode:\r\n        dummy = ListNode(next = head)\r\n        prev = dummy\r\n        \r\n        while head and head.next:\r\n            first = head\r\n            second = head.next\r\n            \r\n            first.next = second.next\r\n            second.next = first\r\n            \r\n            prev.next = second\r\n            \r\n            prev = first\r\n            head = first.next\r\n            \r\n        return dummy.next\r\n```\r\n\r\n### 复杂度\r\nTime: O(n)\r\nSpace: O(1)"},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846335355","body":"### 思路\r\nrecursion\r\n\r\n### 代码\r\n``` python\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        else:\r\n            return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1\r\n```\r\n### 复杂度\r\ntime: O(n)\r\nspace: O(tree height)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiQAQ":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-841933309","body":"```java\r\nclass Solution {\r\n    public ListNode swapPairs(ListNode head) {\r\n        for(ListNode node = head; node != null && node.next != null; node = node.next) {\r\n\r\n            //交换节点的值\r\n            int val = node.val;\r\n            int val2 = node.next.val;\r\n            //当前节点指向下个节点的下一个节点。\r\n            node.val = val2;\r\n            node.next.val = val;\r\n            //和for循环配合使用\r\n            node = node.next;\r\n        }\r\n        return head;\r\n    }\r\n\r\n}\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843018087","body":"### 思路\r\n快慢指针。找到中间点构建树节点\r\n\r\n### 代码\r\n````java\r\nclass Solution {\r\n    public TreeNode sortedListToBST(ListNode head) {\r\n        if(head == null) return null;\r\n        return buildTree(head, null);\r\n    }\r\n\r\n    public TreeNode buildTree(ListNode leftNode, ListNode rightNode) {\r\n        if(leftNode == rightNode) return null;\r\n        ListNode midNode = midNode(leftNode, rightNode);\r\n        TreeNode treeNode = new TreeNode(midNode.val);\r\n        treeNode.left = buildTree(leftNode, midNode);\r\n        treeNode.right = buildTree(midNode.next, rightNode);\r\n        return treeNode;\r\n    }\r\n\r\n    //找到中间点\r\n    public ListNode midNode(ListNode listNode, ListNode rightNode) {\r\n        //定义慢指针\r\n        ListNode mNode = listNode;\r\n        //定义快指针\r\n        ListNode quiteNode = listNode;\r\n        while (quiteNode != rightNode && quiteNode.next != rightNode) {\r\n            quiteNode = quiteNode.next.next;\r\n            mNode = mNode.next;\r\n        }\r\n        return mNode;\r\n\r\n    }\r\n\r\n}\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843731126","body":"###分析\r\n假设A长度为n，B为m。相交后长度为k。因为n + m = m + n。合并后如果有相交点他们的尾部长度也正好是k。所以找到k的位置返回。\r\n\r\n### 代码\r\n````java\r\npublic class Solution {\r\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n        //定义指针pA和指针pB\r\n        ListNode pA = headA;\r\n        ListNode pB = headB;\r\n        //遍历两个指针\r\n        while (pA != pB) {\r\n            //当A到了尾部指向B链表的头节点\r\n            if(pA == null) {\r\n                pA = headB;\r\n            }else {\r\n                pA = pA.next;\r\n            }\r\n            //当B到了尾部指向A链表的头节点\r\n            if(pB == null) {\r\n                pB = headA;\r\n            }else {\r\n                pB = pB.next;\r\n            }\r\n        }\r\n        return pA;\r\n\r\n    }\r\n}\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844648218","body":"### 思路\r\n利用快慢指针找到他们的相遇点。即n。根据推导得出环的长度*n(n>=0) + 常量c(c>=0) = 圈外路径m(m>=0)\r\n得出m到环起始点的距离走的步数 和常量c步数基本一致。如果m>c让n递增直至他们相等。\r\n\r\n### 代码\r\n````java\r\nclass Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        if(head == null || head.next == null || head.next.next == null) return null;\r\n        //定义慢指针\r\n        ListNode slow = head;\r\n        //定义快指针\r\n        ListNode fast = head;\r\n        while(fast != null) {\r\n            slow = slow.next;\r\n            fast = fast.next == null? null: fast.next.next;\r\n            if(fast == slow) {\r\n                //此时他们第一次相遇.有证明可得环外的长度等于n圈+相遇点到环起始点的距离。\r\n                //设一个节点从圈外起始点。\r\n                fast = head;\r\n                while (fast != slow) {\r\n                    //同时开始走相同的速度。\r\n                    fast = fast.next;\r\n                    slow = slow.next;\r\n                }\r\n                //相遇点即起始点\r\n                return fast;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845586660","body":"### 思路\r\n看大家都用自己定义的链表不争气的眼泪流下来了。我直接用util包的链表写了。为了省事。。。\r\n时间复杂度O(1）\r\n空间复杂度O(n)\r\n\r\n### 代码\r\n````java\r\nclass LRUCache {\r\n\r\n    //定义一个map存储\r\n    private Map<Integer, Integer> map = new HashMap<>();\r\n\r\n    int capacity = 0;\r\n\r\n    //优先级队列\r\n    LinkedList<Integer> list = new LinkedList<>();\r\n\r\n    public LRUCache(int capacity) {\r\n        this.capacity = capacity;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        Integer intValue = map.get(key);\r\n        //把此key作为最高优先级\r\n        setPriority(key);\r\n        return intValue == null? -1: intValue;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        if(map.containsKey(key)) {\r\n            //老元素处理\r\n            map.put(key, value);\r\n            //把key设置成最高优先级\r\n            setPriority(key);\r\n        }else {\r\n            //新元素处理\r\n            if(map.size() == capacity) {\r\n                //此时使用淘汰策略\r\n                //获取最低优先级的key淘汰\r\n                Integer intValue = list.removeLast();\r\n                map.remove(intValue);\r\n            }\r\n            //将其新元素添加\r\n            map.put(key, value);\r\n            //把key设置成最高优先级\r\n            list.addFirst(key);\r\n        }\r\n\r\n    }\r\n\r\n    //设置成最高优先级\r\n    public void setPriority(Integer intValue) {\r\n        if(intValue != null && list.contains(intValue)) {\r\n            list.remove(intValue);\r\n            list.addFirst(intValue);\r\n        }\r\n    }\r\n}\r\n\r\n````"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846342254","body":"### 思路\r\n递归寻找叶子结点\r\n\r\n### 代码\r\n````java\r\n\r\n    public int maxDepth(TreeNode root) {\r\n        int height = getHeight(root);\r\n        return height;\r\n    }\r\n\r\n    //返回当前节点树的高度\r\n    public int getHeight(TreeNode node) {\r\n        if(node == null) return 0;\r\n        return Math.max(node.left == null? 0: getHeight(node.left), node.right == null? 0 : getHeight(node.right)) + 1;\r\n    }\r\n\r\n````"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52HzEcho":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842041412","body":"思路：递归处理直到下一组不存在 也就是length<2;head.next获取第二个节点，将node1指向node2的指向，node2指向node1\r\n\r\n```\r\nvar swapPairs = function (head) {\r\n    if (head && head.next) {\r\n        let cur = head.next;\r\n        head.next = swapPairs(cur.next);\r\n        cur.next = head\r\n        return cur\r\n    } else {\r\n        return head\r\n    }\r\n};\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843050734","body":"### 思路：\r\n链表->数组->取数组中间值，向上取整->构建中间节点->递归\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val, next) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.next = (next===undefined ? null : next)\r\n * }\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {ListNode} head\r\n * @return {TreeNode}\r\n */\r\nvar sortedListToBST = function (head) {\r\n    let arr = []\r\n    while (head) {\r\n        arr.push(head.val)\r\n        head = head.next\r\n    }\r\n    return newTree(arr)\r\n};\r\n\r\nvar newTree = (arr) => {\r\n    if (arr.length <= 0) return null\r\n    var mid = Math.floor(arr.length / 2)\r\n    var left = arr.slice(0, mid)\r\n    var right = arr.slice(mid + 1)\r\n    var root = new TreeNode(arr[mid])\r\n    root.left = newTree(left)\r\n    root.right = newTree(right)\r\n    return root\r\n}\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843770244","body":"#### 思路：先将A链表节点插入一个可识别标识，循环B链表，如果有标识，节点相交\r\n\r\n```javascript\r\n\r\n\r\n/**\r\n * @param {ListNode} headA\r\n * @param {ListNode} headB\r\n * @return {ListNode}\r\n */\r\nvar getIntersectionNode = function (headA, headB) {\r\n    while (headA) {\r\n        headA.tag=true\r\n        headA=headA.next\r\n    }\r\n    while(headB){\r\n        if(headB.tag) return headB\r\n        headB=headB.next\r\n    }\r\n    return null\r\n};\r\n\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844697482","body":"#### 思路：循环链表给链表加上标识，判断节点有没有过标识，有则有环\r\n```\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function (head) {\r\n    while (head) {\r\n        if (head.tag == true) return head;\r\n        head.tag = true;\r\n        head = head.next;\r\n    }\r\n    return null \r\n};\r\n\r\n```\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846038751","body":"\r\n#### 思路：Map的有序性，如果元素存在，先delete再set, 元素便会置为最新使用，长度超出，删除第一个\r\n```javascript\r\n\r\n/**\r\n * @param {number} capacity\r\n */\r\nvar LRUCache = function (capacity) {\r\n    this.capacity = capacity;\r\n    this.mapCapacity = new Map();\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function (key) {\r\n    if (this.mapCapacity.has(key)) {\r\n        let item = this.mapCapacity.get(key)\r\n        this.mapCapacity.delete(key)\r\n        this.mapCapacity.set(key, item)\r\n        return item\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function (key, value) {\r\n    if (this.mapCapacity.has(key))\r\n        this.mapCapacity.delete(key)\r\n    if (this.mapCapacity.size >= this.capacity)\r\n        this.mapCapacity.delete(this.mapCapacity.keys().next().value)\r\n    this.mapCapacity.set(key, value)\r\n\r\n};\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * var obj = new LRUCache(capacity)\r\n * var param_1 = obj.get(key)\r\n * obj.put(key,value)\r\n */\r\n\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846415900","body":"\r\n#### 思路：递归---获得root左右节点最大深度，取最大值，加上root的那一层的深度\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\n//  前序排序 根左右\r\nvar maxDepth = function (root) {\r\n    if (!root) return 0\r\n    var left = maxDepth(root.left);\r\n    var right = maxDepth(root.right);\r\n    var max = Math.max(left, right)\r\n    return max + 1\r\n\r\n};\r\n\r\n```\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846433597","body":"\r\n### 思路：递归--判断根节点是否相等，再判断左子树与又子树节点\r\n\r\n```javascript\r\n\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} p\r\n * @param {TreeNode} q\r\n * @return {boolean}\r\n */\r\nvar isSameTree = function (p, q) {\r\n    if ((p == null && q == null) || (p && q && p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right))) {\r\n        return true\r\n    }\r\n    return false\r\n};\r\n\r\n```\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sichenguo":[null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/57#issuecomment-842249920","body":"### 思路： \r\n可以迭代链表，依次交换相邻的两个节点，直至结束\r\n\r\n### 实现\r\n```javascript\r\nvar swapPairs = function(head) {\r\n  if(!head || !head.next) return head\r\n  let next = head.next\r\n  const restList = swapPairs(next.next)\r\n  head.next = restList;\r\n  next.next = head\r\n  return next;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n空间复杂度：O(1)\r\n时间复杂度：O(n)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Panruihua":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842744702","body":"<h4>思路：（参考大佬题解）快慢指针 \r\n\r\n```java\r\nclass Solutioon{\r\n     public TreeNode sortedListToBST(ListNode head){\r\n              if(head == null) return null;\r\n              if(head == null) return new TreeNode(head.val);\r\n              ListNode slower = head,faster = head,pre = head;\r\n              while(faster != null && faster.next != null){\r\n                     faster = faster.next.next;\r\n                     slower = slower.next;\r\n                     pre = slower;\r\n}\r\n            ListNode right = slower.next;\r\n            pre.next = null;\r\n           TreeNode root = new TreeNode(slower.val);\r\n           root.left = sorterListToBST(head);\r\n           root .right = sorterListToBST(right);\r\n           return root;\r\n}\r\n}\r\n```\r\n<h4>时间复杂度：O(nlogn)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843747996","body":"<h6>我是菜狗，参考官方题解\r\n\r\n<h6>\r\n\r\n```java\r\n\r\npublic class Solution{\r\n       public ListNode getIntensectionNode(ListNode headA,ListNode headB){\r\n              Set<ListNode> hashSet = new HashSet<>();\r\n              ListNode pNode = headA;\r\n              while(pNode != null){\r\n                    hashSet.add(pNode);\r\n                    pNode = pNode.next;\r\n}\r\n             pNode = headB;\r\n             while(pNode != null){\r\n                   if(hash.Set.contains(pNode)){\r\n                        return pNode;\r\n}\r\n             pNode = pNode.next;\r\n}\r\n           return null;\r\n}\r\n}\r\n```\r\n\r\n<h6>时间复杂度：O(m+n); 空间复杂度：O(m)或者O(n)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844702256","body":"思路：快慢指针，第一趟：fast指针两步，slow指针一步，相遇时，fast从头开始；第二趟：fast指针一步，slow指针一步，再次相遇时，返回fast指针\r\n\r\n\r\n```java\r\n\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        List Node fast = head,slow = head;\r\n        while(true){\r\n              if(fast == null || fast.next == null)\r\n                   return null;\r\n               fast = fast.next.next;\r\n               slow = slow.next;\r\n               if(fast == slow)\r\n                    break;\r\n        }\r\n        fast = head;\r\n        while(slow != fast){\r\n              slow = slow.next;\r\n              fast = fast.next;\r\n        }\r\n        return fast;\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846495619","body":"**思路**\r\n深度优先搜索，都为空时，即相同；两个二叉树有且只有一个为空时，一定不相同；都不为空时，先判断根节点是否相同，若不相同肯定不相同；若相同，根据中序遍历，先看左子树是否相同，相同再看右子树，递归下去....\r\n```java\r\n\r\nclass Solution{\r\n    public boolean isSameTree(TreeNode p,TreeNode q){\r\n        if(p == null && q == null){       \r\n            return true;\r\n        }else if(p == null || q == null){\r\n               return false;\r\n        }else if( p.val != q.val){\r\n               return false;\r\n        }else{\r\n              return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\r\n        }\r\n    }\r\n}\r\n\r\n**复杂度分析**\r\n\r\n-时间复杂度 : O(min(m,n))\r\n\r\n-空间复杂度 : O(min(m,n))\r\n\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lujiaoa":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-842772353","body":"思路：利用快慢指针，找中间点\r\nconst sortedListToBST = (head) => {\r\n  if (head == null) return null;\r\n  let slow = head;\r\n  let fast = head;\r\n  let preSlow; // 保存slow的前一个节点\r\n\r\n  while (fast && fast.next) {\r\n    preSlow = slow;        // 保存当前slow\r\n    slow = slow.next;      // slow走一步\r\n    fast = fast.next.next; // fast走两步\r\n  }\r\n  const root = new TreeNode(slow.val);     // 根据slow指向的节点值，构建节点\r\n\r\n  if (preSlow != null) {   // 如果preSlow有值，即slow左边有节点，需要构建左子树\r\n    preSlow.next = null;   // 切断preSlow和中点slow\r\n    root.left = sortedListToBST(head);     // 递归构建左子树\r\n  }\r\n  root.right = sortedListToBST(slow.next); // 递归构建右子树\r\n  return root;\r\n};\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843951688","body":"var getIntersectionNode = function(headA, headB) {\r\n    if(headA===null || headB === null )return null;\r\n    let pA  = headA ;let pB = headB;\r\n    while(pA!==pB){\r\n        pA = pA ===null ? headB : pA.next; \r\n        pB = pB ===null ? headA : pB.next; \r\n    }\r\n    return pA\r\n};"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844619611","body":"思路：利用哈希表记录访问过得链表。再次遇到就是环。\r\nvar detectCycle = function(head) {\r\n     const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n复杂度分析：\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846394997","body":"`var maxDepth = function(root) {\r\n    if(!root) {\r\n        return 0;\r\n    } else {\r\n        const left = maxDepth(root.left);\r\n        const right = maxDepth(root.right);\r\n        return Math.max(left, right) + 1;\r\n    }\r\n};"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Epic-lu":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843137360","body":"### **思路**\r\n\r\n1. 找出链表中位数：快慢指针\r\n2. 分治\r\n### 代码\r\n`/**\r\n * Definition for singly-linked list.\r\n * struct ListNode {\r\n *     int val;\r\n *     ListNode *next;\r\n *     ListNode() : val(0), next(nullptr) {}\r\n *     ListNode(int x) : val(x), next(nullptr) {}\r\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\r\n * };\r\n */\r\n/**\r\n * Definition for a binary tree node.\r\n * struct TreeNode {\r\n *     int val;\r\n *     TreeNode *left;\r\n *     TreeNode *right;\r\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\r\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\r\n * };\r\n */\r\n\r\nclass Solution {\r\npublic:\r\n    TreeNode* sortedListToBST(ListNode* head) {\r\n        return buildTree(head, nullptr);\r\n    }\r\n    \r\n    ListNode* getMedian(ListNode* left, ListNode* right){\r\n        ListNode* fast = left;\r\n        ListNode* slow = left;\r\n        while(fast != right && fast -> next != right){\r\n            fast = fast -> next;\r\n            fast = fast -> next;\r\n            slow = slow -> next;\r\n        }\r\n        return slow;\r\n    }\r\n    \r\n    TreeNode* buildTree(ListNode* left, ListNode* right){\r\n        if(left == right){\r\n            return nullptr;\r\n        }\r\n        ListNode* mid = getMedian(left, right);\r\n        TreeNode* root = new TreeNode(mid -> val);\r\n        root -> letf = buildTree(left, mid);\r\n        root -> right = buildTree(mid -> next, right);\r\n        return root;\r\n    }\r\n};`\r\n\r\n执行结果：\r\n通过\r\n\r\n执行用时：\r\n40 ms\r\n\r\n内存消耗：\r\n30.2 MB\r\n\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhajiahe":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843189901","body":"## 思路\r\n快慢指针（找中心点） + 递归建树\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        if not head:\r\n            return None\r\n        pre = None\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            pre = slow\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n        mid = slow\r\n        if pre:\r\n            pre.next = None\r\n        root = TreeNode(mid.val)\r\n        if slow == fast:\r\n            return root\r\n        root.left = self.sortedListToBST(head)\r\n        root.right = self.sortedListToBST(mid.next)\r\n        return root\r\n        \r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(logN)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843677486","body":"## 思路\r\n两个链表，分别都走M+N的长度，如果有相交，一定在末尾，如果都为None，那就不相交\r\n## 代码\r\n```\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        a, b = headA, headB\r\n        while a != b:\r\n            a = a.next if a else headB\r\n            b = b.next if b else headA\r\n        return a\r\n```\r\n## 复杂度分析\r\n- 时间 O(M+N)\r\n- 空间 O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844612445","body":"```\r\n# 快慢指针，发现环\r\n# 相遇之后设置任意点为head，一起移动直到相交\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next:\r\n            return None\r\n        slow, fast = head, head\r\n        while fast and fast.next:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if slow == fast:\r\n                break\r\n        if not fast or not fast.next:\r\n            return None\r\n        slow = head\r\n        while slow != fast:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        return slow\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845587935","body":"## 思路\r\n- 双向链表 和 哈希表\r\n- 使用链表存储最近的缓存，如果get了，就将该缓存移到tail，如果超出了capacity，就从head移除缓存\r\n- 哈希表存储关键字key，实现快速查询\r\n## 代码\r\n```\r\nclass LinkNode():\r\n    def __init__(self, key=-1, value = -1, pre=None, next=None):\r\n        self.key = key\r\n        self.value = value\r\n        self.pre = pre\r\n        self.next = next\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.capacity = capacity\r\n        self.hashtable = {}\r\n        self.head = LinkNode()\r\n        self.tail = LinkNode()\r\n        self.head.next = self.tail\r\n        self.tail.pre = self.head\r\n        self.num = 0\r\n\r\n    def remove_head(self):\r\n        node = self.head.next\r\n        self.head.next = node.next\r\n        node.next.pre = self.head\r\n        self.hashtable.pop(node.key)\r\n\r\n    def add_key_to_tail(self, key, value):\r\n        node = LinkNode(key, value)\r\n        self.tail.pre.next = node\r\n        node.pre = self.tail.pre\r\n        self.tail.pre = node\r\n        node.next = self.tail\r\n        self.hashtable[node.key] = node\r\n\r\n    def move_node_to_tail(self, key):\r\n        node = self.hashtable[key]\r\n        node.pre.next = node.next\r\n        node.next.pre = node.pre\r\n\r\n        self.tail.pre.next = node\r\n        node.pre = self.tail.pre\r\n        self.tail.pre = node\r\n        node.next = self.tail\r\n\r\n\r\n    def get(self, key: int) -> int:\r\n        if self.num == 0 or key not in self.hashtable:\r\n            return -1\r\n        else:\r\n            self.move_node_to_tail(key)\r\n            return self.tail.pre.value\r\n            \r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key in self.hashtable:\r\n            self.move_node_to_tail(key)\r\n            self.hashtable[key].value = value\r\n        else:\r\n            if self.num < self.capacity:\r\n                # self.remove_head()\r\n                self.num += 1\r\n                self.add_key_to_tail(key, value)\r\n            else:\r\n                self.remove_head()\r\n                self.add_key_to_tail(key, value)\r\n\r\n```\r\n## 复杂度分析\r\n- 时间：两个操作都是O(1)\r\n- 空间：需要线性空间存储linknode ：所以是O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846326017","body":"## 思路\r\n二叉树的最大深度等于当前节点深度加上左右子树的最大深度，如果当前节点是空节点，那么当前深度为0，否则为1\r\n## 代码\r\n```\r\nclass Solution:\r\n    def maxDepth(self, root: TreeNode) -> int:\r\n        if not root:\r\n            return 0\r\n        def traverse(node):\r\n            if not node:\r\n                return 0\r\n            left = traverse(node.left)\r\n            right = traverse(node.right)\r\n            return max(left, right) + 1\r\n        return traverse(root)\r\n```\r\n## 复杂度分析\r\n- 时间：O(N)\r\n- 空间：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846481219","body":"## 思路\r\n- 递归，1.p和q都为空 = True，2. q 或 q有一个为空 = False 3. 当前值相等以及子节点也是same\r\n## 代码\r\n```\r\nclass Solution(object):\r\n    def isSameTree(self, p, q):\r\n        \"\"\"\r\n        :type p: TreeNode\r\n        :type q: TreeNode\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not q and not p:\r\n            return True\r\n        elif q and not p:\r\n            return False\r\n        elif p and not q:\r\n            return False\r\n        else:\r\n            return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right,q.right)\r\n```\r\n## 复杂度分析\r\n- 时间：O（N）\r\n- 空间：O（N）"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843216382","body":"### 思路\r\n快慢指针\r\n\r\n### 代码\r\n```js\r\nvar sortedListToBST = function(head) {\r\n    if(!head) return null;\r\n\r\n    let slow = head, fast = head, preSlow = null;\r\n\r\n    while(fast && fast.next){\r\n        preSlow = slow\r\n        fast = fast.next.next\r\n        slow = slow.next\r\n    }\r\n\r\n    const newRoot = new TreeNode(slow.val)\r\n\r\n    if(preSlow){\r\n        // 需要cut不然会影响mid的判断\r\n        preSlow.next = null;\r\n        // 从head开始，因为要选中点做parent\r\n        newRoot.left = sortedListToBST(head)\r\n    }\r\n    newRoot.right = sortedListToBST(slow.next)\r\n\r\n    return newRoot;\r\n\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(NlogN)\r\n空间复杂度：O(NlogN)"},null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845221797","body":"### 思路\r\n哈希表法\r\n\r\n### js代码\r\n```js\r\nvar detectCycle = function(head) {\r\n    const visited = new Set();\r\n    while (head !== null) {\r\n        if (visited.has(head)) {\r\n            return head;\r\n        }\r\n        visited.add(head);\r\n        head = head.next;\r\n    }\r\n    return null;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度O(N)\r\n空间复杂度O(N)\r\n\r\n\r\n\r\n\r\n\r\n### 思路\r\n快慢指针法\r\n\r\n### js代码\r\n```js\r\nvar detectCycle = function(head) {\r\n    if (head === null) {\r\n        return null;\r\n    }\r\n    let slow = head, fast = head;\r\n    while (fast !== null) {\r\n        slow = slow.next;\r\n        if (fast.next !== null) {\r\n            fast = fast.next.next;\r\n        } else {\r\n            return null;\r\n        }\r\n        if (fast === slow) {\r\n            let ptr = head;\r\n            while (ptr !== slow) {\r\n                ptr = ptr.next;\r\n                slow = slow.next;\r\n            }\r\n            return ptr;\r\n        }\r\n    }\r\n    return null;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度O(N)\r\n空间复杂度O(1)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846027939","body":"### 思路\r\n\r\n**哈希表-双向链表**\r\n双向链表：方便用来频繁增删节点\r\n哈希表：方便用来读取节点信息\r\n\r\n哈希表存储数据的形式：节点的key--节点的内存地址\r\n双向链表节点包含信息：key/value/prev指针/next指针\r\n\r\nput操作：\r\n1.如果哈希表内没有该节点obj[key] === undefined，将该节点信息存入哈希表\r\n  a.如果缓存已满，先删除链表最后一位，再删除哈希表内对应的节点信息，然后生成新结点，将新节点插入链表第一个节点的位置\r\n  b.如果缓存未满，生成新结点，将新节点插入链表第一个节点的位\r\n2.如果哈希表内有该节点\r\n  更新该结点的值，将该节点调整至链表第一个节点的位置\r\n\r\n\r\nget操作：\r\n1.如果哈希表内没有该节点，返回-1\r\n2.如果哈希表内有该节点，将该节点调整至链表第一个节点的位置，返回该结点的值\r\n\r\n\r\n### js代码\r\n\r\n```js\r\nfunction ListNode(key, val) {\r\n  this.key = key;\r\n  this.val = val;\r\n  this.pre = this.next = null;\r\n}\r\n\r\nvar LRUCache = function (capacity) {\r\n  this.capacity = capacity;\r\n  this.size = 0;\r\n  this.data = {};\r\n  this.head = new ListNode();\r\n  this.tail = new ListNode();\r\n  this.head.next = this.tail;\r\n  this.tail.pre = this.head;\r\n};\r\n\r\nfunction get(key) {\r\n  if (this.data[key] !== undefined) {\r\n    let node = this.data[key];\r\n    this.removeNode(node);\r\n    this.appendHead(node);\r\n    return node.val;\r\n  } else {\r\n    return -1;\r\n  }\r\n}\r\n\r\nfunction put(key, value) {\r\n  let node;\r\n  if (this.data[key] !== undefined) {\r\n    node = this.data[key];\r\n    this.removeNode(node);\r\n    node.val = value;\r\n  } else {\r\n    node = new ListNode(key, value);\r\n    this.data[key] = node;\r\n    if (this.size < this.capacity) {\r\n      this.size++;\r\n    } else {\r\n      key = this.removeTail();\r\n      delete this.data[key];\r\n    }\r\n  }\r\n  this.appendHead(node);\r\n}\r\n\r\nfunction removeNode(node) {\r\n  let preNode = node.pre,\r\n    nextNode = node.next;\r\n  preNode.next = nextNode;\r\n  nextNode.pre = preNode;\r\n}\r\n\r\nfunction appendHead(node) {\r\n  let firstNode = this.head.next;\r\n  this.head.next = node;\r\n  node.pre = this.head;\r\n  node.next = firstNode;\r\n  firstNode.pre = node;\r\n}\r\n\r\nfunction removeTail() {\r\n  let key = this.tail.pre.key;\r\n  this.removeNode(this.tail.pre);\r\n  return key;\r\n}\r\n```\r\n\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(1)\r\n空间复杂度O(n)n是缓存空间容量大小\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846386541","body":"### 思路\r\n\r\n递归\r\n\r\n\r\n### js代码\r\n\r\n```js\r\nconst maxDepth = (root) => {\r\n  if (root === null) return 0;\r\n  const leftMaxDepth = maxDepth(root.left);\r\n  const rightMaxDepth = maxDepth(root.right);\r\n  return 1 + Math.max(leftMaxDepth, rightMaxDepth);\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(height)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maggiexie00":[null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/58#issuecomment-843268150","body":"**思路**\r\n显然树的根结点应为链表的中位数，链表长度为偶数时，中间的二者取其一皆可满足要求。找到根节点后，自然链表被划分成左子树与右子树，接下来递归地不断寻找根结点，bst便构造完成。\r\n**代码**\r\n\r\nclass Solution:\r\n    def sortedListToBST(self, head: ListNode) -> TreeNode:\r\n        def getMedian(left,right):\r\n            fast=slow=left\r\n            while fast!=right and fast.next!=right:\r\n                fast=fast.next.next\r\n                slow=slow.next\r\n            return slow\r\n        def buildTree(left,right):\r\n            if left==right:\r\n                return None\r\n            mid=getMedian(left,right)\r\n            root=TreeNode(mid.val)\r\n            root.left=buildTree(left,mid)\r\n            root.right=buildTree(mid.next,right)\r\n            return root\r\n        return buildTree(head, None)\r\n**时间复杂度**\r\nO(nlogn)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Jackielj":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843744978","body":"**思路**\r\n\r\n- 循环的条件： 当两个指针指向的地址不一样的时候（也就是还没找到intersection）\r\n- trick: either 走完 A 或者 B 的时候， 就把指针指向另一个链表的头， 这样， 当遇到相交的节点的时候，  假设链表A在相交之前的长度为A， 链表B在相交之前的长度为B， 根据题目， 在相交之后的长度是相等的， 所以为C，这样， 走完A 需要 A + C， 同理， 走完B 需要 B + C， 这样的好处当我们走完A 或者 B， 切换成另一个链表的头的时候， 当我们遇到相交的节点的时候， 我们能保证 A + C + B 和 B + C + A， 所以， 反推，我们就可以找到相交的节点。\r\n\r\n**Java代码**\r\n\r\n`public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\r\n\r\n         Set<ListNode> set = new HashSet<>();\r\n        while (headA != null) {\r\n            set.add(headA);\r\n            headA = headA.next;\r\n        }\r\n        while (headB != null) {\r\n            if (set.contains(headB)) {\r\n                return headB;\r\n            } else {\r\n                headB = headB.next;\r\n            }\r\n        }\r\n        return null;\r\n    }`\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuhl06":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843905623","body":"思路\r\n设第一个公共节点为node，A链表节点数为a，B链表节点数为b，公共节点数为c\r\n则A链表第一个节点到node间有a - c个节点， B链表第一个节点到node之间有b - c个节点\r\n\r\n建立两个结点指针nodeA，nodeB分别指向headA，headB，使：\r\nnodeA先遍历完A链表再遍历B链表，当走到node时的总步数为a + (b - c)\r\nnodeB先遍历完B链表再遍历A链表，当走到node时的总步数为b + (a - c)\r\n此时nodeA与nodeB重合，即a + (b - c) = b + (a - c)\r\n\r\n若存在公共节点，此时nodeA，nodeB同时指向node\r\n若不存在公共节点， 此时nodeA，nodeB同时指向null\r\n此时返回nodeA即可\r\n\r\n**代码**\r\n\r\n```\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, x):\r\n#         self.val = x\r\n#         self.next = None\r\n\r\nclass Solution:\r\n    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:\r\n        nodeA, nodeB = headA, headB\r\n        while nodeA != nodeB:\r\n            nodeA = nodeA.next if nodeA else headB\r\n            nodeB = nodeB.next if nodeB else headA\r\n        return nodeA\r\n\r\n```\r\n\r\n**复杂度分析**\r\n时间复杂度：O(a + b)\r\n空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ChampionNeverTurnBack":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-843942080","body":"> 看过讲义之后，还是没能理解问什么双指针可以找到相交点。\r\n> 纸上得来终觉浅，绝知此事要躬行。 自己画了图，一步一步的模拟，才恍然大悟；\r\n>  **对于新手来说，画图十分重要**\r\n```js\r\nvar getIntersectionNode = function (headA, headB) {\r\n  let a = headA,\r\n    b = headB;\r\n  while (a != b) {\r\n    a = a === null ? headB : a.next;\r\n    b = b === null ? headA : b.next;\r\n  }\r\n  return a;\r\n};\r\n```\r\n复杂度\r\n设 链表A 有M 个节点，链表B有 N 个节点，最差的情况是，两个链表在尾结点相交，因此时间复杂度为O(M+N);\r\n没有使用额外的空间，因此 空间复杂度为 O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"FlorenceLLL":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844084139","body":"**思路**\r\n从A链表的头结点到相交节点距离为a，从B链表的头结点到相交节点距离为b，相交节点到链表结尾的距离为c\r\n两个指针分别指向A、B的头结点，同时滑动\r\n如果一个先到达链表结尾，则从另一个链表的头结点继续滑动\r\na+b+c次后可以同时到达相交节点 \r\n\r\n**代码**\r\n``` java\r\npublic class Solution {\r\n    public ListNode locateIntersectionNode(ListNode headA, ListNode headB) {\r\n        Set<ListNode> hashSet = new HashSet<>();\r\n        ListNode currentNode = headA;\r\n        while (currentNode != null) {\r\n            hashSet.add(currentNode);\r\n            currentNode = currentNode.next;\r\n        }\r\n\r\n        currentNode = headB;\r\n        while (currentNode != null) {\r\n            if(hashSet.contains(currentNode)){\r\n                return currentNode;\r\n            }\r\n            currentNode = currentNode.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syymo":[null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/59#issuecomment-844203445","body":"### 思路\r\n1.双指针\r\n\r\n### 代码\r\n```TypeScript\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     val: number\r\n *     next: ListNode | null\r\n *     constructor(val?: number, next?: ListNode | null) {\r\n *         this.val = (val===undefined ? 0 : val)\r\n *         this.next = (next===undefined ? null : next)\r\n *     }\r\n * }\r\n */\r\n\r\nfunction getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\r\n    if (!headA || !headB) return null\r\n    let pA = headA, pB = headB\r\n    while (pA != pB) {\r\n        pA = pA === null ? headB : pA.next\r\n        pB = pB === null ? headA : pB.next\r\n    }\r\n    return pA\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HaoOneBin":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844387776","body":"### Two Pointers\r\n\r\n**思路**：\r\nfast and slow pointers. 从head开始，每次快指针移动两个节点，慢指针一个。两者相遇后，增加一个新的指针temp, 从head开始，每次只移动一个节点，直到temp与slow相遇，相遇位置入环处。\r\n```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n       ListNode fast = head;\r\n       ListNode slow = head;\r\n       if (head == null){\r\n           return null;\r\n       }\r\n    \r\n       while(fast != null){\r\n           slow = slow.next;\r\n           if(fast.next != null){\r\n               fast = fast.next.next;\r\n           } else {\r\n               return null;\r\n           }\r\n           \r\n           if (slow == fast){\r\n               ListNode temp = head;\r\n               while(slow != temp){\r\n                   temp = temp.next;\r\n                   slow = slow.next;\r\n               }\r\n               return temp;\r\n           }\r\n       }\r\n       return null;       \r\n    }\r\n}\r\n```\r\n**复杂度分析**:\r\n时间: O(N) 访问N个节点\r\n空间: O(1) 只用了三个指针\r\n\r\n\r\n\r\n### 哈希表\r\n**思路**：\r\n遍历链表，哈希表存下。若为新节点，存到哈希表。若为已存在于哈希表的旧节点，则找到位置。\r\n```Java\r\n/**\r\n * Definition for singly-linked list.\r\n * class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode(int x) {\r\n *         val = x;\r\n *         next = null;\r\n *     }\r\n * }\r\n */\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n       ListNode pos = head;\r\n       Set<ListNode> visited = new HashSet<ListNode>();\r\n\r\n       while(pos != null){\r\n           if(visited.contains(pos)){\r\n               return pos;\r\n           } else {\r\n               visited.add(pos);\r\n               pos = pos.next;\r\n           }\r\n       }\r\n\r\n       return null;\r\n    }\r\n}\r\n```\r\n**复杂度分析**:\r\n时间: O(N) 访问N个节点\r\n空间: O(N) 用了一个哈希表存N个节点。\r\n\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-845425388","body":"### 思路\r\n哈希表 + 双向链表\r\n使用双向链表存储，头部为最新，尾部最旧。使用HashMap来缓存每个的位置。\r\n\r\n\r\n### 代码\r\n```Java\r\nclass LRUCache {\r\n    class DLinkedNode {\r\n        int key, value;\r\n        DLinkedNode prev, next;\r\n        public DLinkedNode() {}\r\n        public DLinkedNode(int _key, int _value) {\r\n            key = _key;\r\n            value = _value;\r\n        }\r\n    }\r\n\r\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\r\n    private int size, cap;\r\n    private DLinkedNode head, tail;\r\n\r\n    public LRUCache(int capacity) {\r\n        size = 0;\r\n        cap = capacity;\r\n        //add dummy head and dummyTail\r\n        head = new DLinkedNode();\r\n        tail = new DLinkedNode();\r\n        head.next = tail;\r\n        tail.prev = head;\r\n    }\r\n    \r\n    public int get(int key) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) return -1;\r\n        //if key exist, move it to head by using its location store in Hashmap\r\n        moveToHead(node);\r\n        return node.value;\r\n    }\r\n    \r\n    public void put(int key, int value) {\r\n        DLinkedNode node = cache.get(key);\r\n        if (node == null) {\r\n            //made a newNode if it does not exist\r\n            DLinkedNode newNode = new DLinkedNode(key, value);\r\n            cache.put(key, newNode);\r\n            addToHead(newNode);\r\n            ++size;\r\n            if (size > cap) {\r\n                DLinkedNode removedTail = removeTail();\r\n                cache.remove(removedTail.key);\r\n                --size;\r\n            }\r\n        } else {\r\n            node.value = value;\r\n            moveToHead(node);\r\n        }\r\n    }\r\n    \r\n    private void addToHead(DLinkedNode node){\r\n        node.prev = head;\r\n        node.next = head.next;\r\n        head.next.prev = node;\r\n        head.next = node;\r\n    }\r\n\r\n    private void removeNode(DLinkedNode node){\r\n        node.prev.next = node.next;\r\n        node.next.prev = node.prev;\r\n    }\r\n\r\n    private void moveToHead(DLinkedNode node){\r\n        removeNode(node);\r\n        addToHead(node);\r\n    }\r\n\r\n    private DLinkedNode removeTail(){\r\n        DLinkedNode res = tail.prev;\r\n        removeNode(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Your LRUCache object will be instantiated and called as such:\r\n * LRUCache obj = new LRUCache(capacity);\r\n * int param_1 = obj.get(key);\r\n * obj.put(key,value);\r\n */\r\n```\r\n###复杂度\r\n时间：O(1)\r\n空间: O(capacity)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846109124","body":"### 思路\r\n\r\n- 深度优先。\r\n- 二叉树最大深度为 max(左子树最大深度，右子树最大深度) + 1\r\n- 因为左子树/右子树 最大深度也是这样计算，所以使用递归。\r\n\r\n\r\n```Java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    public int maxDepth(TreeNode root) {\r\n        if(root == null){\r\n            return 0;\r\n        }\r\n        return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n\r\n- 时间: O(n) ,n为节点的数量\r\n- 空间: O(Height) height为树的高度"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846440304","body":"### 思路\r\nDFS 递归\r\n只有同时到最底层为空，且之前节点都相等（没有return false过），才会return true。\r\n\r\n```Java\r\n/**\r\n * Definition for a binary tree node.\r\n * public class TreeNode {\r\n *     int val;\r\n *     TreeNode left;\r\n *     TreeNode right;\r\n *     TreeNode() {}\r\n *     TreeNode(int val) { this.val = val; }\r\n *     TreeNode(int val, TreeNode left, TreeNode right) {\r\n *         this.val = val;\r\n *         this.left = left;\r\n *         this.right = right;\r\n *     }\r\n * }\r\n */\r\nclass Solution {\r\n    //只有同时到最底层为空，且之前节点都相等（没有return false过），才会return true。\r\n    public boolean isSameTree(TreeNode p, TreeNode q) {\r\n        if(p == null && q == null) {\r\n            return true;\r\n        } else if (p ==  null || q == null){\r\n            return false;\r\n        } else if (p.val != q.val){\r\n            return false;\r\n        } else {\r\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n        }\r\n    }\r\n}\r\n```\r\n时间：O(min(m, n))\r\n空间：O(min(m, n))"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"koihoo":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844677000","body":"\r\n\r\n## 思路\r\n双指针法\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\n\r\n\r\n```python\r\n\r\nclass Solution(object):\r\n    def detectCycle(self, head):\r\n        fast, slow = head, head\r\n        while True:\r\n            if not (fast and fast.next): return\r\n            fast, slow = fast.next.next, slow.next\r\n            if fast == slow: break\r\n        fast = head\r\n        while fast != slow:\r\n            fast, slow = fast.next, slow.next\r\n        return fast\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhengxinshuo":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-844860816","body":"### 思路\r\n\r\n用的哈希表的思路，利用 js 的Set()，每走一步，记录一次，当重复了，则返回\r\n\r\n### 代码\r\n\r\n``` javascript\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    let setObj = new Set() \r\n    while(head){\r\n        if(setObj.has(head)){\r\n            return head\r\n        }else{\r\n            setObj.add(head)\r\n            head = head.next\r\n        }\r\n    }\r\n    return null\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846006441","body":"``` javascript\r\n/**\r\n * @param {number} capacity\r\n */\r\nfunction ListNode(key, val) {\r\n    this.key = key\r\n    this.val = val\r\n    this.pre = null\r\n    this.next = null\r\n}\r\n\r\nvar LRUCache = function(capacity) {\r\n    this.size = 0\r\n    this.capacity = capacity\r\n    this.map = {}\r\n    this.head = new ListNode()\r\n    this.tail = new ListNode()\r\n    this.head.next = this.tail\r\n    this.tail.pre = this.head\r\n};\r\n\r\n/** \r\n * @param {number} key\r\n * @return {number}\r\n */\r\nLRUCache.prototype.get = function(key) {\r\n  if(this.map[key]!== undefined) {\r\n      let node = this.map[key]\r\n      this.removeNode(node)\r\n      this.appendHead(node)\r\n      return node.val\r\n  } else {\r\n      return -1\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} key \r\n * @param {number} value\r\n * @return {void}\r\n */\r\nLRUCache.prototype.put = function(key, value) {\r\n  let node;\r\n  if (this.map[key] !== undefined) {\r\n    node = this.map[key];\r\n    this.removeNode(node);\r\n    node.val = value;\r\n  } else {\r\n    node = new ListNode(key, value);\r\n    this.map[key] = node;\r\n    if (this.size < this.capacity) {\r\n      this.size++;\r\n    } else {\r\n      key = this.removeTail();\r\n      delete this.map[key];\r\n    }\r\n  }\r\n  this.appendHead(node);\r\n};\r\n\r\nLRUCache.prototype.removeNode = function(node){\r\n    let preNode = node.pre,\r\n    nextNode = node.next;\r\n    preNode.next = nextNode;\r\n    nextNode.pre = preNode;\r\n}\r\n\r\nLRUCache.prototype.appendHead  = function(node) {\r\n    let firstNode = this.head.next\r\n    this.head.next = node\r\n    node.pre = this.head\r\n    node.next = firstNode\r\n    firstNode.pre = node\r\n}\r\n\r\nLRUCache.prototype.removeTail = function() {\r\n    let key = this.tail.pre.key\r\n    let node = this.tail.pre\r\n    this.removeNode(node)\r\n    return key\r\n}\r\n```"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846412901","body":"``` javascript\r\n/**\r\n * Definition for a binary tree node.\r\n * function TreeNode(val, left, right) {\r\n *     this.val = (val===undefined ? 0 : val)\r\n *     this.left = (left===undefined ? null : left)\r\n *     this.right = (right===undefined ? null : right)\r\n * }\r\n */\r\n/**\r\n * @param {TreeNode} root\r\n * @return {number}\r\n */\r\nvar maxDepth = function(root) {\r\n\r\n    if(!root) return 0\r\n\r\n    return Math.max(maxDepth(root.right),maxDepth(root.left))+1\r\n    \r\n};\r\n```"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coke420":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845080859","body":"# 环形链表 II\r\n## 思路\r\n1.遍历链表中所有节点并记录\r\n2.发现有重复节点 说明有链表中存在环\r\n3. 哈希表\r\n```java\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode pos = head;\r\n        Set<ListNode> visited = new HashSet<ListNode>();\r\n        while (pos != null) {\r\n            if (visited.contains(pos)) {\r\n                return pos;\r\n            } else {\r\n                visited.add(pos);\r\n            }\r\n            pos = pos.next;\r\n        }\r\n        return null;\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\nn 为 链表 长度\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MASIJUN99":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845104083","body":"# 思路\r\n\r\n技巧题，记住套路，先用快慢指针，当他们重合后，让其中一个从头开始，再一步一步走，相遇点即入环点。\r\n\r\n# 代码\r\n\r\n```py\r\nclass Solution:\r\n    def detectCycle(self, head: ListNode) -> ListNode:\r\n        if not head or not head.next or not head.next.next:\r\n            return None\r\n        slow = head\r\n        fast = head\r\n        while True:\r\n            slow = slow.next\r\n            fast = fast.next.next\r\n            if not fast.next or not fast.next.next:\r\n                return None\r\n            if fast == slow:\r\n                break\r\n        cur = head\r\n        while cur != slow:\r\n            cur = cur.next\r\n            slow = slow.next\r\n        return cur\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度：$O(n)$\r\n\r\n空间复杂度：$O(1)$ 常数级，两个指针"},null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846430252","body":"# 思路\r\n\r\n递归+深度优先判断\r\n\r\n先判断是否都是空节点，在判断是不是有其中一个为空另一个不为空。\r\n\r\n# 代码\r\n\r\n```py\r\nclass Solution:\r\n    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:\r\n        if not p and not q:\r\n            return True\r\n        \r\n        if not p or not q:\r\n            return False\r\n\r\n        return p.val == q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\r\n```\r\n\r\n# 复杂度\r\n\r\n时间复杂度： $O(n)$ n为节点数\r\n\r\n空间复杂度： $O(2n)$ n为节点数"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/60#issuecomment-845230276","body":"### 思路\r\n\r\n遍历链表，如果有相同的节点表示有环出现，反之没有。用set保存\r\n\r\n### 代码\r\n\r\n\r\n```js\r\n/**\r\n * Definition for singly-linked list.\r\n * function ListNode(val) {\r\n *     this.val = val;\r\n *     this.next = null;\r\n * }\r\n */\r\n\r\n/**\r\n * @param {ListNode} head\r\n * @return {ListNode}\r\n */\r\nvar detectCycle = function(head) {\r\n    var res = new Set()\r\n    while(head != null) {\r\n        if (res.has(head)) {\r\n            return head\r\n        }\r\n        res.add(head)\r\n        head = head.next\r\n    }\r\n    return null\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n\r\n"},{"url":"https://github.com/leetcode-pp/91alg-4/issues/61#issuecomment-846058681","body":"### 思路\r\n\r\n实现本题的两种操作，需要用到一个哈希表和一个双向链表。\r\nPS: 是学习官方的题解\r\n\r\n### 代码\r\n\r\n```py\r\nclass DLinkedNode:\r\n    def __init__(self, key=0, value=0):\r\n        self.key = key\r\n        self.value = value\r\n        self.prev = None\r\n        self.next = None\r\n\r\n\r\nclass LRUCache:\r\n\r\n    def __init__(self, capacity: int):\r\n        self.cache = dict()\r\n        # 使用伪头部和伪尾部节点    \r\n        self.head = DLinkedNode()\r\n        self.tail = DLinkedNode()\r\n        self.head.next = self.tail\r\n        self.tail.prev = self.head\r\n        self.capacity = capacity\r\n        self.size = 0\r\n\r\n    def get(self, key: int) -> int:\r\n        if key not in self.cache:\r\n            return -1\r\n        # 如果 key 存在，先通过哈希表定位，再移到头部\r\n        node = self.cache[key]\r\n        self.moveToHead(node)\r\n        return node.value\r\n\r\n    def put(self, key: int, value: int) -> None:\r\n        if key not in self.cache:\r\n            # 如果 key 不存在，创建一个新的节点\r\n            node = DLinkedNode(key, value)\r\n            # 添加进哈希表\r\n            self.cache[key] = node\r\n            # 添加至双向链表的头部\r\n            self.addToHead(node)\r\n            self.size += 1\r\n            if self.size > self.capacity:\r\n                # 如果超出容量，删除双向链表的尾部节点\r\n                removed = self.removeTail()\r\n                # 删除哈希表中对应的项\r\n                self.cache.pop(removed.key)\r\n                self.size -= 1\r\n        else:\r\n            # 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\r\n            node = self.cache[key]\r\n            node.value = value\r\n            self.moveToHead(node)\r\n    \r\n    def addToHead(self, node):\r\n        node.prev = self.head\r\n        node.next = self.head.next\r\n        self.head.next.prev = node\r\n        self.head.next = node\r\n    \r\n    def removeNode(self, node):\r\n        node.prev.next = node.next\r\n        node.next.prev = node.prev\r\n\r\n    def moveToHead(self, node):\r\n        self.removeNode(node)\r\n        self.addToHead(node)\r\n\r\n    def removeTail(self):\r\n        node = self.tail.prev\r\n        self.removeNode(node)\r\n        return node\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: 对于`put`和`get`都是 O(1)。\r\n\r\n- 空间复杂度：O(capacity)，因为哈希表和双向链表最多存储 capacity+1 个元素。\r\n\r\n"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/62#issuecomment-846420826","body":"**思路：**\r\nDFS问题；树问题常常用递归方法，无子节点时返回，本层高度等于最大子节点高度+1。\r\n\r\n**代码：**\r\n```\r\nclass Solution(object):\r\n    def maxDepth(self, root):\r\n        \"\"\"\r\n        :type root: TreeNode\r\n        :rtype: int\r\n        \"\"\"\r\n        \r\n        if not root:\r\n            return 0\r\n        else:\r\n            return max(self.maxDepth(root.left),self.maxDepth(root.right))+1\r\n```\r\n**复杂度：**\r\n _时间复杂度_\r\n树递归： 每个节点操作数同，所以是节点数*操作数  **O(N)**\r\n_空间复杂度_\r\n最后一个子节点计算出是1，返回1，销毁存储空间……  **O(1)**"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MarsPen":[null,null,null,null,null,null,null,null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-4/issues/63#issuecomment-846438241","body":"## LeetCode 100\r\n\r\n- DFS\r\n- BFS\r\n\r\n### 思路 DFS\r\n\r\n### JavaScript 代码\r\n\r\n```\r\nconst isSameTree = function (p, q) {\r\n  if (p == null && q == null) {\r\n    return true;\r\n  }\r\n  if (p == null || q == null ) {\r\n    return false;\r\n  }\r\n\r\n  return p.val == q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(N) \r\n空间复杂度：O(N) \r\n\r\n### 思路 BFS\r\n\r\n### Javascript 代码\r\n\r\n```\r\nconst isSameTree = function (p, q)  {\r\n  const queue = [{ p, q }]\r\n  while (queue.length) {\r\n    const cur = queue.shift()\r\n    if (cur.p == null && cur.q == null) continue\r\n    if (cur.p == null || cur.q == null) return false\r\n    if (cur.p.val != cur.q.val) return false\r\n    queue.push({\r\n      p: cur.p.left,\r\n      q: cur.q.left\r\n    }, {\r\n      p: cur.p.right,\r\n      q: cur.q.right\r\n    })\r\n  }\r\n  return true;\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(N) \r\n空间复杂度：O(N)"},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}