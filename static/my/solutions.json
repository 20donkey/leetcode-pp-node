{"1":[],"2":[],"3":[],"4":[],"5":[],"6":[],"7":[],"8":[],"9":[],"10":[],"11":[],"12":[],"13":[],"14":[],"15":[],"16":[],"17":[],"18":[],"19":[],"20":[],"21":[],"22":[],"23":[],"24":[],"25":[],"26":[],"27":[],"28":[],"29":[],"30":[],"31":[],"32":[],"33":[],"34":[],"35":[],"36":[],"37":[],"38":[],"39":[],"40":[],"41":[],"42":[],"43":[],"44":[],"45":[],"46":[],"47":[],"48":[],"49":[],"50":[],"51":[],"52":[],"53":[],"54":[],"55":[],"56":[],"57":[],"58":[],"59":[],"60":[],"61":[],"62":[],"63":[],"64":[],"65":[],"66":[],"67":[],"68":[],"69":[],"70":[],"71":[],"72":[],"73":[],"74":[],"75":[],"76":[],"77":[],"78":[],"79":[],"80":[],"81":[],"82":[],"83":[],"84":[],"85":[],"86":[],"87":[],"88":[],"89":[],"90":[],"91":[],"954545647":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297935552","body":"### 思路\n\n套用加法模版\n\nwhile ( A 没完 || B 没完)\n    A 的当前位\n    B 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n\n### 代码\n\n```js\nvar addToArrayForm = function (num, k) {\n    let n = num.length;\n    let i = n - 1;\n    let sum = 0;\n    let carry = 0;\n    let res = [];\n    while (i >= 0 || k !== 0) {\n        let x = i >= 0 ? num[i] : 0;\n        let y = k !== 0 ? k % 10 : 0;\n        sum = x + y + carry;\n        res.push(sum % 10)\n        carry = Math.floor(sum / 10);\n        i--;\n        k = Math.floor(k / 10);\n    }\n    if(carry) res.push(carry)\n    return res.reverse();\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299476563","body":"### 思路\n\nMath.min(s[i]到其左侧最近字符c,s[i]到其右侧最近字符c)\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const n = s.length;\n  const ans = new Array(n).fill(0);\n\n  for (let i = 0, idx = -n; i < n; ++i) {\n      if (s[i] === c) {\n          idx = i;\n      }\n      ans[i] = i - idx;\n  }\n  console.log('ans ==>',ans)\n\n  for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n      if (s[i] == c) {\n          idx = i;\n      }\n      ans[i] = Math.min(ans[i], idx - i);\n  }\n  return ans;\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)，其中 n 为字符串长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301563740","body":"### 思路\n\n用数组维护一个栈\n\n### 代码\n\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n  this.arr = []\n  this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.arr.length < this.maxSize){\n    this.arr.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function(\n) {\n  if(this.arr.length === 0) return -1;\n  return this.arr.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const len = this.arr.length;\n  if(len < k){\n    this.arr = this.arr.map(item=> item+val)\n    return\n  }\n  for(let i= 0; i<k;i++){\n    this.arr[i] = this.arr[i]+val\n  }\n\n};\n```\n\n### 复杂度分析\n\n+ 时间复杂度：increment为 O(n)，其中 n 为最大长度。\n+ 空间复杂度：O(n)，其中 n 为最大长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302881831","body":"### 思路\n\n使用栈维护当前【】进出\n\n### 代码\n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n  let res = \"\"\n  let stack = [];\n  let multi = 0;\n  for(let  i = 0; i < s.length;i++){\n    const item = s[i];\n    const isNum = !isNaN(Number(item));\n    const isLBrackets = item === \"[\"\n    const isRBrackets = item === \"]\"\n    if(isNum){\n      multi = Number(`${multi}${item}`);\n    }else if(isLBrackets){\n      stack.push([multi,res])\n      res = \"\";\n      multi = 0\n    }else if(isRBrackets){\n      const stackItem = stack.pop();\n      res = stackItem[1] + res.repeat(stackItem[0])\n    }else{\n      res += item\n    }\n  }\n  return res\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为字符串长度。\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397247","body":"### 思路\n\n因为要求用栈的原生操作，但又需要能拿到栈头元素，因此需要多使用一个数组来模拟队列\n\n### 代码\n\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n  this.stack = [];\n  this.helpStack = [];\n};\n\n/**\n * Push element x to the back of queue.\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\n// 从队列首部移除元素\nMyQueue.prototype.pop = function () {\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\n// 返回队列首部的元素\nMyQueue.prototype.peek = function () {\n  const len = this.helpStack.length;\n  if (!this.helpStack.length) {\n    while (this.stack.length) {\n      this.helpStack.push(this.stack.pop());\n    }\n  }\n  return this.helpStack[len - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  if (this.stack.length || this.helpStack.length) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N) N 为栈中元素个数\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304700283","body":"### 思路\n\n借鉴单调栈思路 <https://lucifer.ren/blog/2020/11/03/monotone-stack/>\n\n### 代码\n\n```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const temp = [];\n  for (let i = 0; i < arr.length; i++) {\n    let a = arr[i];\n    if (temp.length > 0 && temp[temp.length - 1] > a) {\n      const cur = temp[temp.length - 1];  // 保存临时最大值\n      while (temp && temp[temp.length - 1] > a) temp.pop();\n      temp.push(cur);\n    } else {\n      temp.push(a);\n    }\n  }\n  return temp.length;\n};\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：O(n)，其中 n 为数组长度。\n+ 空间复杂度：O(n)，其中 n 为数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305003518","body":"### 思路\n\n寻找倒数第N位节点可以采用双指针\n\n### 代码\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function (head, k) {\n  if (!head || !head.next) return head;\n  let count = 0;\n  let start = head;\n  while (start) {\n    start = start.next;\n    count++\n  }\n  // 减少次数\n  k = k % count;\n  // 快指针先走\n  let fast = head;\n  let slow = head;\n  while (fast.next) {\n    if (k-- <= 0) {\n      slow = slow.next;\n    }\n    fast = fast.next;\n  }\n  fast.next = head;\n  let res = slow.next;\n  slow.next = null;\n  return res\n\n};\n```\n\n### 复杂度分析\n\n+ 空间复杂度 O(1)\n+ 时间复杂度 O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1541732340":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297933717","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n \n\n示例 1：\n\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：num = [2,7,4], k = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：num = [2,1,5], k = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n \n\n提示：\n\n1 <= num.length <= 104\n0 <= num[i] <= 9\nnum 不包含任何前导零，除了零本身\n1 <= k <= 104\n```\n\n\n## 思路\n1、遍历数组，逆序逐位相加(注意相加进位问题)\n2、考虑k的数字长度大于数组长度的问题\n3、逆序输出即可\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        int len = num.length;\n        //1、从后往前逐位相加\n        for (int i = len-1; i >=0 ; i--) {\n            //1.1逐位相加\n            int sum = num[i] + k%10;\n            k /=10;\n            //1.2相加进位\n            if (sum >= 10){\n                k++;\n                sum -=10;\n            }\n            result.add(sum);\n        }\n\n        //2、如果k的长度大于num的数组长度\n        for (;k>0;k /=10){\n            result.add(k %10);\n        }\n\n        //3、将结果反转输出即可\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299506664","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n## 思路\n\n正反遍历方式：\n     *      1、正遍历记录从左侧到字符c的距离\n     *      2、返遍历记录从右侧到字符c的距离\n     *      取两者的最小值\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int indexC1 = -n;\n        for (int i = 0; i < n ; ++i) {//正向遍历\n            if (s.charAt(i) == c){\n                indexC1 = i;\n            }\n            res[i] = i - indexC1;\n        }\n\n        int indexC2 = 2*n;//反向遍历初始值使用2n的目地是防止下面取最小值时出现错误数据\n        for (int i = n-1; i >=0 ; --i) {//反向遍历\n            if (s.charAt(i) == c){\n                indexC2 = i;\n            }\n            res[i] = Math.min(res[i],indexC2 - i);//取最小值\n        }\n        return res;\n\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301558840","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 思路\n使用数组模拟栈,用一个变量 top 记录当前栈顶的位置\n     *      1、对于push操作,首先判断当前元素的个数是否达到上限,如果没有达到上限,则把栈顶top后移一个位置 并添加元素\n     *      2、对于pop操作,首先判断栈是否为空,非空则返回栈顶top对应位置的元素,栈顶top向前移一个位置 否则返回-1\n     *      3、对于inc操作,对栈底的最多k个元素增加val\n\n## 关键点\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top;//记录栈顶的位置\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length -1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (stack.length > 0 && top >= 0){\n            --top;\n            return stack[top + 1];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k, top + 1);\n        for (int i = 0; i < min; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(1) inc操作的时间复杂为O(k)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303174000","body":"算法流程：\n1、构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n         1.1当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n         1.2当 c 为字母时，在 res 尾部添加 c；\n         1.3当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 \n              1.3.1记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n              1.3.2记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n              1.3.3进入到新 [ 后，res 和 multi 重新记录。\n          1.4当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n               1.4.1last_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n               1.4.2cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n2、返回字符串 res。\n\n代码：java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n复杂度分析：\n时间复杂度 \nO(N)\n空间复杂度 \nO(N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304540439","body":"思路:\n我们创建两个栈，分别为 out 和 in：\n        in 用作处理输入操作 push()，使用 in 时需确保 out 为空\n        out 用作处理输出操作 pop() 和 peek()，使用 out 时需确保 in 为空\n\n代码:java\n\nclass MyQueue {\n    Deque<Integer> out, in;\n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while (!out.isEmpty()) in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while (!in.isEmpty()) out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n\n复杂度分析:\n       时间复杂度：O(n)O(n)\n       空间复杂度：O(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304788782","body":"思路:\n根据栈的思想，我们在栈中维护每个块的最大值\n1、若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n2、若栈顶元素大于当前元素，则需要融合到上一个块中去，直到当前元素大于栈顶元素或者栈为空\n\n代码：java\npublic int maxChunksToSorted(int[] arr) {\nDeque<Integer> stack = new LinkedList<>();\n        for (int num : arr) {\n            //若当前栈为空或者栈顶元素小于等于当前元素，直接入栈\n            if (stack.isEmpty() || stack.peek() <= num) {\n                stack.push(num);\n            } else {\n                //融合块，保留当前块的最大元素\n                //比如之前有块[3]、[4],若num = 1，\n                //则融合为[3,4,1],因为排序1会排到前边去，当前块的最大值还是4\n                int max = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(max);\n            }\n        }\n        return stack.size();\n }\n\n复杂度分析:\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"michaelxi3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297828208","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  const ret = [];\n  \n  while(num.length || k) {\n    k += num.pop() || 0;\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  while(k) {\n    ret.unshift(k % 10);\n    k = Math.floor(k / 10);\n  }\n  \n  return ret;\n};\n\n// Time Complexity O(N)\n// Space Complexity O(N)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341352","body":"```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n  const ret = new Array(s.length);\n  \n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ret[i] = 0;\n    } else {\n      if (i === 0) {\n        ret[i] = 10001;\n      } else {\n        ret[i] = ret[i - 1] + 1;\n      }\n    }\n  }\n  \n  for (let j = s.length - 2; j >= 0; j--) {\n    ret[j] = Math.min(ret[j], ret[j + 1] + 1);\n  }\n  \n  return ret;\n};\n```\n- Time Complexity O(N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301505213","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.max = maxSize;\n  this.size = 0;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.size < this.max) {\n    this.stack.push(x);\n    this.size++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.size > 0) {\n    this.size--;\n    return this.stack.pop();\n  }\n  \n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.size) {\n      break;\n    }\n    this.stack[i] += val;\n  }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n- Time Complexity inc O(N) push,pop O(1)\n- Space Complexity O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304551283","body":"```js\n\nvar MyQueue = function() {\n  this.outStack = [];\n  this.inStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.inStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.outStack.length) {\n    while (this.inStack.length) {\n      this.outStack.push(this.inStack.pop());\n    }\n  }\n  \n  return this.outStack[this.outStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.outStack.length && !this.inStack.length;\n};\n\n/** \n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n- Time Complexity O( N)\n- Space Complexity O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801302","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = [arr[0]];\n  \n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i] >= stack[stack.length - 1]) {\n      stack.push(arr[i]);\n    }\n    \n    const topNum = stack.pop();\n    while (stack.length && stack[stack.length - 1] > arr[i]) {\n      stack.pop();\n    }\n    stack.push(topNum);\n  }\n  \n  return stack.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297940594","body":"### 将 `num` 转为数字\n\n#### 思路\n\n将 `num` 由列表转为数字，与 `k` 求和后再转为数组输出\n\n#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        t = 10\n        n = len(num)\n        res = 0\n        for i in range(n):\n            res += t ** i * num[n - i - 1]\n        res += k\n        \n        out = []\n        while res:\n            out.append(res % 10)\n            res = res // 10\n        return out[::-1]\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(n)$\n\n### 逐位相加\n\n#### 思路\n\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\n> * https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n\n#### 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        if len(num) < len(str(k)):\n            num = [0] * (len(str(k)) - len(num)) + num\n        n = max(len(str(k)), len(num)) - 1\n        while n >= 0 or k:\n            sums = num[n] + k % 10 + carry\n\n            basic = sums % 10\n            carry = sums // 10\n            res.insert(0, basic)\n\n            n -= 1\n            k //= 10\n        if carry:\n            res.insert(0, carry)\n            return res\n        else:\n            return res\n```\n\n#### 复杂度\n\n* 时间复杂度：$O(n)$\n* 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299391606","body":"### 代码\n\n```python\nclass Solution:\n    def shortestToChar (self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n + 1] * n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != -1:\n                res[i] = i - idx\n\n        idx = n\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx != n:\n                res[i] = min(idx - i, res[i])\n\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$ 。遍历 s 即可，\n* 空间复杂度： $O(n)$。和 s 等长的结果数组，","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301554047","body":"```python\nclass CustomStack:  \n    def __init__(self, maxSize: int):  \n        self.stack = []  \n        self.size = maxSize  \n  \n    def push(self, x: int) -> None:  \n        if len(self.stack) < self.size:  \n            self.stack.append(x)  \n  \n    def pop(self) -> int:  \n        return self.stack.pop() if len(self.stack) > 0 else -1  \n  \n    def increment(self, k: int, val: int) -> None:  \n        if len(self.stack) < k:  \n            self.stack = [i + val for i in self.stack]  \n        else:  \n            self.stack[:k] = [i + val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302833820","body":"### 思路\n\n将每个字符入栈 ，当遇到 `']'` 时出栈，直至遇到 `'['`，`'['` 前的所有数字出栈，即为 `k`，将出栈得到的括号内所有字符重复 `k` 次，入栈。\n\n### 代码\n\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\": # \"[\" 之后的字符为当前要处理的子串\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0 # 进位，因为数字取值为 [1, 300]，需要考虑 10 以上的重复情况\n                while stack and stack[-1].isdigit(): # \"[\" 之前的数字为当前子串要重复的次数\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c += 1\n                ch = ch * time\n                stack.append(ch) # 处理完的子串入栈\n            else:\n                stack. append (i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n\n### 复杂度\n\n* 时间复杂度：$O(n)$，需要遍历一遍字符\n* 空间复杂度：$O(n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304406391","body":"```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.inqueue = []\r\n        self.outqueue = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.inqueue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outqueue:\r\n            while self.inqueue:\r\n                self.outqueue.append(self.inqueue.pop())\r\n        return self.outqueue[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.inqueue and not self.outqueue:  # 两个栈均为空时\r\n            return True\r\n        else:\r\n            return False\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304816175","body":"\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        local_max = -1\r\n        for num in arr:\r\n            while stack and stack[-1] > num:\r\n                stack.pop()\r\n            if num >= local_max:\r\n                stack.append(num)\r\n            else:\r\n                stack.append(local_max)\r\n            local_max = stack[-1]  # 不放在 lm = stack.pop() 是为了防止 num>lm 时最大值记录错误\r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(N)$\r\n- 空间复杂度： $O(N)$\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304976331","body":"### 思路\r\n\r\n- 将 链表 首尾串联形成循环链表\r\n- 旋转 k 次后的尾结点位置为 $(len(link) - k) \\% len(link)$，从该位置断开，取该位置下个结点为头节点即可。\r\n\r\n### 代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        length = 1\r\n        cur = head\r\n\r\n        while cur.next:\r\n            cur = cur.next\r\n            length += 1\r\n\r\n        target = (length - k) % length\r\n        cur.next = head\r\n        for _ in range(target):\r\n            cur = cur.next\r\n\r\n        head = cur.next\r\n        cur.next = None\r\n\r\n        return head\r\n```\r\n\r\n### 复杂度\r\n\r\n- 时间复杂度： $O(n)$\r\n- 空间复杂度： $O(1)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298100069","body":"##### 989\n\n数组形式的整数加法\n\n```\n输入：num = [1,2,0,0], k = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n```\n\n从低位向高位计算，注意边界处理（既然用数组表示数了，肯定可能大数）。\n\n```\nclass Solution\n{\npublic:\n    vector<int> addToArrayForm(vector<int> &num, int k)\n    {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; i--)\n        {\n            int c = num[i] + k % 10;\n            k /= 10;\n            if (c >= 10)\n            {\n                k++; // 进位到k上\n                c -= 10;\n            }\n            res.push_back(c);\n        }\n        while (k)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n* O(N)\n* O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300711980","body":"#### 821\n\n字符的最短距离\n\n两次遍历。\n\n```\nclass Solution\n{\npublic:\n    vector<int> shortestToChar(string s, char c)\n    {\n        int i = 0, j = 0;\n        int n = s.size();\n        vector<int> res(n, 10007);\n        for (; j < n; j++)\n        {\n            if (s[j] == c)\n            {\n                int t = j - i;\n                for (; i <= j; i++)\n                {\n                    res[i] = min(res[i], t);\n                    t--;\n                }\n            }\n        }\n        i = n - 1, j = n - 1;\n        for (; i >= 0; i--)\n        {\n            if (s[i] == c)\n            {\n                int t = j - i;\n                for (; j >= i; j--)\n                {\n                    res[j] = min(res[j], t);\n                    t--;\n                }\n            }\n        }\n        for (int &a : res)\n        {\n            printf(\"%d \", a);\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301571798","body":"空间换时间，采用一个额外的数组increment来记录每次的increment操作。初始化为(maxSize, 0)，值如下。本质是到用时再计算。\nclass CustomStack\n{\npublic:\n    CustomStack(int _maxSize)\n        : maxSize(_maxSize)\n    {\n        stk.resize(_maxSize);\n        add.resize(_maxSize);\n        top = -1;\n    }\n\n    void push(int x)\n    {\n        if (top != maxSize - 1)\n        {\n            top++;\n            stk[top] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (top == -1)\n        {\n            return -1;\n        }\n        int res = stk[top] + add[top];\n        if (top != 0)\n        {\n            add[top - 1] += add[top];\n        }\n        add[top] = 0;\n        top--;\n        return res;\n    }\n\n    void increment(int k, int val)\n    {\n        int l = min(k - 1, top);\n        if (l >= 0)\n        {\n            add[l] += val;\n        }\n    }\n\nprivate:\n    vector<int> stk;\n    vector<int> add;\n    int maxSize = -1;\n    int top;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302878649","body":"字符串解码\n\n```\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n括号内嵌套括号，需要从内向外生成与拼接字符串，和栈先入后出的特性对应。\n\n```\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561577","body":"\n\n##### 232\n\n栈实现队列\n\n双栈模拟队列；而非栈+辅助栈模拟队列；**后者push总是O(N)**，pop简单为O(1)。但是在双栈模拟情况下，仍能保证pop为O(1)，进行一次O(N)“倾倒”操作后，后续取这些元素O(1)即可。\n\n```\nclass MyQueue\n{\npublic:\n    // stack in\n    stack<int> s1;\n    // stack out\n    stack<int> s2;\n    MyQueue()\n    {\n    }\n\n    void push(int x)\n    {\n        s1.push(x);\n    }\n\n    int pop()\n    {\n        if (s2.empty())\n        {\n            while (!s1.empty())\n            {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int res = s2.top();\n        s2.pop();\n        return res;\n    }\n\n    int peek()\n    {\n        int res = this->pop();\n        s2.push(res);\n        return res;\n    }\n\n    bool empty()\n    {\n        return s1.empty() && s2.empty();\n    }\n};\n```\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829697","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> st{};\n        for (auto & i: arr) {\n            if (st.empty() || i >= st.top()) {\n                st.emplace(i);\n            }else {\n                auto t = st.top();\n                st.pop();\n                while (!st.empty() && st.top() > i) {\n                    st.pop();\n                }\n                st.emplace(t);\n            }\n        }\n        return st.size();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304961272","body":"利用环找到新的头尾节点，因为内部关系没变，只修改\n\n* 尾节点指向头节点\n* 找到新的尾节点后\n  * 设置新头节点（新尾节点的下一个）\n  * 设置新尾节点（next置为nullptr）\n\n```\nclass Solution\n{\n    public:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // 原来的尾结点指向原来的头结点，形成环\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // 找到断开环的位置\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // 新的头结点指向断开环的位置\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n* Time O(N)\n* Space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297925085","body":"Keep adding the last digit of k to the last element of the array, then update k to k divided by ten plus the remainder of the last digit of k plus the last element of the array until the array is empty and k equals 0.\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        stack<int> tempS;\n        vector<int> res;\n        while(!num.empty())\n        {\n            int temp = k%10 + num.back();\n            tempS.push(temp % 10);\n            k  = k/10 + temp/10;\n            num.pop_back();\n        }\n        \n        while(k > 0)\n        {\n            tempS.push(k%10);\n            k /= 10;\n        }\n        \n        while(!tempS.empty())\n        {\n            res.push_back(tempS.top());\n            tempS.pop();\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299563969","body":"Traverse from left to right and set the value to the distance to char c. Traverse from right to left to update if a shorter length is found.\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.size();\n        vector<int> res;\n        int tempPos = INT_MAX;\n        \n        for(int i = 0; i < len; i++)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res.push_back(abs(i - tempPos));\n        }\n        \n        for(int i = len - 1; i >= 0; i--)\n        {\n            if(s[i] == c)\n                tempPos = i;\n            res[i] = min(res[i], abs(i - tempPos));\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301686760","body":"class CustomStack {\n\npublic:\n    int *s;\n    int size;\n    int index;\n    \n    CustomStack(int maxSize) {\n        s = (int*)malloc(sizeof(int) * (maxSize+1));\n        size = maxSize;\n        index = 0;\n    }\n    \n    void push(int x) {\n        if(index < size)\n        {\n            index++;\n            *(s + index) = x;\n        }\n    }\n    \n    int pop() {\n        if(index > 0)\n        {\n            int res = *(s+index);\n            index--;\n            return res;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 1; i <= k && i <= size; i++)\n            *(s+i) += val;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302894191","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> string_S;\n        stack<int> int_S;\n            \n        int index = 0;\n        string curRes = \"\";\n        while(index < s.size())\n        {\n            if(s[index] >= '0' && s[index] <= '9')\n            {\n                int count = 0;\n                while(s[index] >= '0' && s[index] <= '9')   \n                {\n                    count = 10 * count + (s[index] - '0');\n                    index++;\n                }\n                int_S.push(count);\n            }\n            \n            else if(s[index] == '[')\n            {\n                string_S.push(curRes);\n                curRes = \"\";\n                index++;\n            }\n            \n            else if(s[index] == ']')\n            {\n                string tempStr = string_S.top();\n                int repeatCount = int_S.top();\n                \n                string_S.pop();\n                int_S.pop();\n                    \n                while(repeatCount > 0)\n                {\n                    tempStr.append(curRes);\n                    repeatCount--;\n                }\n                \n                curRes = tempStr;\n                index++;\n            }\n            \n            else\n            {\n                curRes += s[index];\n                index++;\n            }\n        }\n        \n        return curRes;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304438835","body":"class MyQueue {\n    stack<int> pop_stack;\n    stack<int> push_stack;\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        push_stack.push(x);\n    }\n    \n    int pop() {\n        if(!pop_stack.empty())\n        {\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            int temp_top = pop_stack.top();\n            pop_stack.pop();\n            return temp_top;\n        }\n    }\n    \n    int peek() {\n        if(!pop_stack.empty())\n            return pop_stack.top();\n        else{\n            while(!push_stack.empty())\n            {\n                pop_stack.push(push_stack.top());\n                push_stack.pop();\n            }\n            return pop_stack.top();\n        }\n    }\n    \n    bool empty() {\n        return pop_stack.empty() && push_stack.empty();\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304651899","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> leftMax;\n        vector<int> rightMin;\n        int res = 1;\n        \n        leftMax.push_back(arr[0]);\n        for(int i = 1; i < arr.size(); i++)\n            leftMax.push_back(max(leftMax[i-1], arr[i]));\n        \n        rightMin.push_back(arr[arr.size() - 1]);\n        for(int i = arr.size() - 2; i >= 0; i--)\n            rightMin.insert(rightMin.begin(), 1, min(rightMin[rightMin.size()-(arr.size() - i - 1)], arr[i]));\n        \n        for(int i = 0; i < arr.size() - 1; i++)\n        {\n            if(leftMax[i] <= rightMin[i+1])\n                res++;\n        }\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298345996","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        strings = ''\n        for i in num:\n            strings += str(i)\n        res = int(strings) + k\n        output = []\n        for i in str(res):\n            output.append(int(i))\n        return output","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304703297","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for index in arr:\n            if stack and stack[-1] > index:\n                current = stack[-1]\n                while stack and stack[-1] > index:\n                    stack.pop()\n                stack.append(current)\n            else:\n                stack.append(index)\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298416612","body":"### 思路\n\n直接还原num数组的数字加和再放入list——>有数值太大的情况，不行\n\n既然还原数字存在问题那就不还原\n\n-   遍历数组，从后往前的从num中拿出数字 `idxNum = num[length - 1 - i]`，令`k += idxNum`\n\n-   在遍历数组时，不断地对 k 取 10 的余数，然后 add 到 list，但是需要分情况讨论\n\n    -   遍历结束前 k == 0\n\n        在遍历的过程中，不断地对 k 取 10 的余数添加到list，直到 k == 0\n\n    -   遍历结束前 k != 0\n\n        对于这种情况需要进行判断`if (i == length - 1 && k != 0)`，如果满足，就进入循环中，直到 k 为 0\n\n-   最后，使用Collections工具类，将list翻转返回\n\n### 代码\n\n```java\nclass Solution {\n    public ArrayList addToArrayForm(int[] num, int k) {\n        int idxNum, length = num.length;\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxNum = num[length - 1 - i];\n            k += idxNum;\n            if (k != 0) {\n                list.add(k % 10);\n                k = k / 10;\n            } else {\n                list.add(k);\n            }\n            if (i == length - 1 && k != 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N + max(0, K - N))，N为数组的长度，K为k对应数字的长度\n- 空间复杂度：O(N) (不确定)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300132201","body":"### 思路\n\n对数组进行正反两次遍历\n\n-   先正序遍历，尽可能地写入到 answer 数组中\n-   再反序遍历，对于 answer 不为0的位置进行比较更新，对于 answer 为 0 且不是 c 的位置重新赋值\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int currentCharIdx = -1, length = s.length();\n        int[] answer = new int[length];\n\n        // 正序遍历\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n                answer[i] = 0;\n            } else if (currentCharIdx < 0) {\n                answer[i] = 0;\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        // 反序遍历\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentCharIdx = i;\n            } else if (answer[i] != 0) {\n                answer[i] = Math.min(answer[i], Math.abs(i - currentCharIdx));\n            } else {\n                answer[i] = Math.abs(i - currentCharIdx);\n            }\n        }\n        return answer;\n    }\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302000318","body":"### 思路\n\n根据栈的定义，在类中定义一个数组用于存储元素，定义current指针指向栈顶，定义maxSize记录栈的容量\n\n### 代码\n\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int current, maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.current = -1;\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if (current + 1 < maxSize) {\n            current++;\n            stack[current] = x;\n        }\n    }\n\n    public int pop() {\n        if (current > -1) return stack[current--];\n        else return -1;\n    }\n\n    public void increment(int k, int val) {\n        if (current + 1 > k)\n            for (int i = 0; i < k; i++) stack[i] += val;\n        else\n            for (int i = 0; i <= current; i++) stack[i] += val;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：\n\n    - `CustomStack()`O(1)\n\n    - `push()`O(1)\n\n    - `pop()`O(1)\n\n    - `increment()`O(max(k, currentNums)) \n\n        >   `currentNums`是当前栈的大小\n\n- 空间复杂度：O(N) \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303514136","body":"### 思路\n\n最后写的脑袋晕晕沉沉，总算是ac了\n\n维护两个stack，一个是数字栈，一个是字符串栈，遍历给定的字符串`char c = s.charAt(i)`：\n\n-   c 是数字\n\n    题目中数字没有限定是个位数，因此需要保留并计算\n\n-   `c == '['`\n\n    此时记录数字完成，开始记录区间内的字符串，因此需要完成：\n\n    -   将记录的数字入栈，数字归零\n    -   将记录的字符串入栈，字符串内容清空\n\n-   c 是字母\n\n    将字母`append`到当前记录的字符串中\n\n-   `c == ']'`\n\n    此时，小区间的字符串记录完成，需要进行解码操作：\n\n    -   获取当前区间对应的重复次数num——数字栈出栈\n    -   获取上一次记录的字符串temp——字符串栈出栈（没有的话是`\"\"`）\n    -   将记录的当前小区间字符串在temp后面添加num次，保留temp\n\n直到遍历完成\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n\n        Stack<Integer> numStack = new Stack<>();\n        Stack<StringBuffer> stringStack = new Stack<>();\n\n        StringBuffer result = new StringBuffer();\n        int multi = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                multi = 10 * multi + c - '0';\n            } else if (c == '[') {\n                stringStack.push(result);\n                numStack.add(multi);\n                result = new StringBuffer();\n                multi = 0;\n            } else if (Character.isAlphabetic(c)) {\n                //记录当前小段的 string\n                result.append(c);\n            } else if (c == ']') {\n                // decode\n                StringBuffer temp = stringStack.pop();\n                multi = numStack.pop();\n                for (int j = 0; j < multi; j++) temp.append(result);\n                multi = 0;\n                result = temp;\n            }\n        }\n        return result.toString();\n    }\n}\n\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297919309","body":"## 思路\r\n\r\n\r\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        x = ''.join(map(str, num))\r\n        sum = int(x) + k\r\n        return list(map(int, str(sum)))\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299640797","body":"## 思路\r\n\r\n\r\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [n for i in range(n)]\r\n        dist = n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1 \r\n            ans[i] = dist\r\n        for j in range(n-1, -1, -1):\r\n            if s[j] == c:\r\n                dist = 0\r\n            else:\r\n                dist += 1\r\n            ans[j] = min(dist, ans[j])\r\n        return ans\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$，\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302069633","body":"## 思路\r\n\r\n\r\n用数组模拟栈操作\r\n\r\n## 代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop()\r\n            \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.size)):\r\n            self.stack[i] += val\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push：****$O(1)$， ****pop：****$O(1)$， ****increment：****$O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303062796","body":"## 思路\r\n\r\n---\r\n\r\n双栈，一个栈存放数字，一个栈存放字母\r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == \"]\":\r\n                tmpstr = \"\"\r\n                numstr = \"\"\r\n                while stack and stack[-1] != \"[\":\r\n                    char = stack.pop()\r\n                    tmpstr = char + tmpstr\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop()\r\n                    numstr = num + numstr\r\n                stack.append(int(numstr) * tmpstr)\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time:**** $O(N)$\r\n- **Space:** $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427028","body":"## 思路\r\n\r\n\r\n使用两个栈（先进后出）实现队列（先进先出），一个栈用来存储元素\r\n\r\n## 代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.stack1:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\n\r\n## 复杂度\r\n\r\n\r\n- ****Time: push:**** $O(N)$ ****pop:**** $O(1)$ ****peek:**** $O(1)$  ****empty:**** $O(1)$\r\n- **Space:** $O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304830763","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        cnt = Counter()\r\n        res = 0\r\n        for x, y in zip(arr, sorted(arr)):\r\n            cnt[x] += 1\r\n            if cnt[x] == 0:\r\n                del cnt[x]\r\n            cnt[y] -= 1\r\n            if cnt[y] == 0:\r\n                del cnt[y]\r\n            if len(cnt) == 0:\r\n                res += 1\r\n        return res\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304810452","body":"class Solution:\n    def maxChunksToSorted(self, A: [int]) -> int:\n        stack = []\n        for a in A:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a: stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382347","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        tmp = []\n        n = 0\n        for i in range(len(num)-1,-1,-1):\n            k, m = k//10, k%10\n            n, t = (num[i]+m+n)//10, (num[i]+m+n)%10\n            tmp.append(t)\n        k = k+n\n        while k!=0:\n            k,m = k//10,k%10\n            tmp.append(m)\n        return tmp[::-1]\n```\n### 复杂度分析\n- 时间复杂度：O（n）\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299439197","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        if s[0]==c:\n            beg = 0\n        else:\n            beg = len(s)\n        end = s.find(c,1)\n        res = []\n        for i in range(len(s)):\n            res.append(min(abs(i-beg),abs(i-end)))\n            if i == end:\n                beg = end\n                end = s.find(c,beg+1)\n        return res\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303088901","body":"### 思路\n使用栈，遍历字符串，将字符数字和‘【’入栈，直到碰到‘】’，开始出栈，将‘【’之前的字符出栈存在restr里面，然后将‘【’之后的数字出栈存在num中，然后将num倍的restr入栈，直到遍历结束\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)\n```\n### 复杂度分析\n- 时间复杂度：O（n） \n- 空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298145845","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1: # while a没完 or b没完\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304457480","body":"## **思路：两个栈倒腾**\n\n之前写过O(n)的，以下是O(1)的思路\n\nO(n)也是两个栈互相倒，但是复杂度较高。两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个**辅助的self.front变量，记录stackin最前面元素**。\n\npop的时候，rather than倒进去又倒出来，可以在stackout空的时候才倒，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶元素，否则，就是self.front\n\n### **代码**\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return \n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304787936","body":"用栈保存单调递增的片段的最大的值，中间小的不重要；所以可以用单调栈，如果碰到更小的就弹出来，直到小的能够放进去为止，该数字之前的片段才能保证排序之后递增，并且能和后面的连上。如果碰到更大的直接放进栈即可\n\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # 用单调栈存储一个块的最大值，单调栈是递增的\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # 碰到更小的值，就得把前面的一个个拿出来，知道形成新的块能够合并掉这个最小值\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val) # 要记录当前块的最大值并且放回去\n            else: # 碰到更大的值，可以无脑作为一个新的块\n                stack.append(n)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665583","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303685599","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304491666","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766445","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298752942","body":"# Thoughts:\r\n\r\nTake K as a carry, add it to the lowest digit, Update Carry K and keep going to higher digit.\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n        for (int i = num.length - 1; i >= 0; --i){\r\n            res.add(0, (num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n# Time Complexicity:\r\nO(N)\r\n\r\n# Space Complexicity:\r\nO(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753644","body":"## 思路\n从末尾开始遍历数组元素，与k相加，并维护k值，及进位，\n然后将末位的值加入集合\n遍历完毕数组后，若k仍然有值，将其各位加入数组\n最后返回\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        for(int i=len-1;i>=0;i--){\n            int t=num[i]+k;\n            //这样就不用反转\n            res.add(0,t%10);\n            k=t/10;\n        }\n      //遍历完毕数组后，若k仍然有值，将其各位加入数组\n     //即k位数比数组长度大的情况\n        while(k>0){\n            res.add(0,k%10);\n            k /=10;\n        }\n        return res;\n    }\n}\n```\nTime:O(n)\nSpace:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300799149","body":"##思路\n1、从当前元素开始，左、右分别寻找字符c\n2、若找到了则计算长度距离，若两个方向都找到，则并维护一个最小距离值\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n       int n = s.length();\n        int[] res = new int[n];\n        int index = -n;\n//正向查找\n        for (int i = 0; i < n ; ++i) {\n            if (s.charAt(i) == c){\n                index = i;\n            }\n            res[i] = i - index1;\n        }\n        int index2 = 2*n;\n//反向查找\n        for (int i = n-1; i >=0 ; --i) {\n            if (s.charAt(i) == c){\n                index2 = i;\n               }\n    //维护最小距离\n            res[i] = Math.min(res[i],index2 - i);\n        }\n        return res;\n    }\n}\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302327842","body":"## 思路\r\n使用数组模拟\r\n\r\n1. 定义一个数组和一个指针\r\n2. 初始化数组为定义的大小，并为指针赋值初始值\r\n3. 弹出方法\r\n   -若到达初始化值-1下标的元素——即最后一个元素就返回\r\n   -不然就先向右移动指针，指针+1先\r\n   -然后给指针指向下标赋值\r\n\r\n4. pop 弹出：直接返回指针指向元素，然后左移一位 -1\r\n    -若指针与初始值相同，则返回-1\r\n5. 指定元素 加上对应值\r\n   - 比较k 和 指针+1 哪个小，\r\n   - 遍历这个较小值的所有元素，\r\n   - 并每个元素加上要加的值val\r\n\r\n\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    int st[];\r\n    int p;\r\n    public CustomStack(int maxSize) {\r\n        st=new int[maxSize];\r\n        p=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //限制功能为初始化长度内使用\r\n        if(p==(st.length-1)){\r\n            return;\r\n        }\r\n        st[++p]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        //弹出全部时返回\r\n        if(p == -1){\r\n            return -1;\r\n        }\r\n\r\n        return st[p--];\r\n\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int l=Math.min(k,p+1);\r\n        for(int i=0;i<l;i++){\r\n            st[i]+=val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\nTime:O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303803971","body":"## 思路\r\n用列表模拟栈\r\n先入栈，碰到 】 再出栈\r\n先循环到[ 拼接字符\r\n碰到 【，出栈\r\n再拼接数字\r\n循环字符串 数字值 遍\r\n返回\r\n## 代码\r\n```python\r\n class Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        # 定义列表\r\n        stack=[]\r\n\r\n        # 遍历字符串\r\n        for c in s:\r\n            # 出栈\r\n            if c == ']':\r\n                strT= ''\r\n                count=''\r\n                # 没碰到 [ 不停止循环\r\n                while stack and stack[-1] !='[':\r\n                    # 栈顶，即列表末尾元素弹出并返回值\r\n                    strT =stack.pop() +strT \r\n                \r\n                # 弹出 [\r\n                stack.pop()\r\n                # 碰到非数字再跳出循环\r\n                while stack and stack[-1].isnumeric():\r\n                    count =stack.pop() +count;\r\n                stack.append(strT * int(count))\r\n             # 入栈\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度分析\r\nTime：O(N)\r\nSpace:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572910","body":"## 思路\r\n使用两个栈来辅助实现队列的功能\r\n\r\n## 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n         self.inStack = []\r\n         self.outStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n       # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 出栈队头元素\r\n        return self.outStack.pop()\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        # 移动到另外一个栈先\r\n        self.moveOut()\r\n        # 返回最后的元素\r\n        return self.outStack[-1]\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n    # 移动到另外一个栈\r\n    def moveOut(self):\r\n          if not self.outStack:\r\n           # 若不在out列表内就加入这个列表\r\n            while self.inStack:\r\n                 self.outStack.append(self.inStack.pop())\r\n\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n\r\n# # Your MyQueue object will be instantiated and called as such:\r\n# # obj = MyQueue()\r\n# # obj.push(x)\r\n# # param_2 = obj.pop()\r\n# # param_3 = obj.peek()\r\n# # param_4 = obj.empty()\r\n\r\n## 算法复杂度\r\nTIME：O(N)\r\nSPACE:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304832356","body":"## 思路\n单调栈\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        st = []\n        for a in arr:\n            if st and st[-1] > a:\n                cur = st[-1]\n                while st and st[-1] > a: st.pop()\n                st.append(cur)\n            else:\n                st.append(a)\n        return len(st)\n```\n## 复杂度分析\n\nTIME：O(N)\n\nSPACE：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298431856","body":"### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        a = 0\r\n        carry = k\r\n        for i in range(len(num)-1,-1,-1):\r\n            tem = num[i] + carry\r\n            print(tem)\r\n            if tem // 10 > 0 :\r\n                carry = tem // 10\r\n                num[i] = tem % 10\r\n                print(carry)\r\n            else:\r\n                num[i] = tem % 10\r\n                carry = 0\r\n                break\r\n        if carry < 10 and carry > 0:\r\n             return [carry] + num\r\n        else:\r\n            while(carry):\r\n                print(carry)\r\n                num = [carry % 10] + num\r\n                carry = carry // 10\r\n                print(num)\r\n        return num\r\n```\r\n### 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298538203","body":"## 思路\n\n> + 思路描述 \n\n## 代码\n\n```python\n# 代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp = temp + str(i)\n        return [int(i) for i in str(int(temp)+k)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300753664","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302258679","body":"class CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304714739","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\r\n        int res = 0;\r\n        int[] sortedArr = new int[arr.length];\r\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\r\n        Arrays.sort(sortedArr);\r\n        for (int i = 0; i < sortedArr.length; i++) {\r\n            int x = arr[i], y = sortedArr[i];\r\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\r\n            if (cnt.get(x) == 0) {\r\n                cnt.remove(x);\r\n            }\r\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\r\n            if (cnt.get(y) == 0) {\r\n                cnt.remove(y);\r\n            }\r\n            if (cnt.isEmpty()) {\r\n                res++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298745122","body":"思路\r\n遍历两个数组\r\n代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> kNum = new ArrayList<>();\r\n        while(k!=0) {\r\n            kNum.add(k%10);\r\n            k/=10;\r\n        }\r\n        List<Integer> arrayNum = new ArrayList<>();\r\n        for(int i = num.length-1; i >= 0; i--) {\r\n            arrayNum.add(num[i]);\r\n        }\r\n        int i = 0, add = 0, j = Math.min(kNum.size(), arrayNum.size());\r\n        List<Integer> ans = new ArrayList<>();\r\n        while(i < j) {\r\n            ans.add((kNum.get(i)+arrayNum.get(i)+ add)%10 );\r\n            add = (kNum.get(i)+arrayNum.get(i)+ add)/10;\r\n            i++;\r\n        }\r\n        if(j == kNum.size()) {\r\n            while (i<arrayNum.size()) {\r\n                ans.add((arrayNum.get(i)+add)%10);\r\n                add = (arrayNum.get(i)+add)/10;\r\n                i++;\r\n            }\r\n        } else {\r\n            while (i<kNum.size()) {\r\n                ans.add((kNum.get(i)+ add)%10 );\r\n                add = (kNum.get(i)+ add)/10;\r\n                i++;\r\n            }\r\n        }\r\n        if(add!=0) ans.add(add);\r\n        List<Integer> realAns = new ArrayList<>();\r\n        for(int n = ans.size()-1;n>=0; n--) {\r\n            realAns.add(ans.get(n));\r\n        }\r\n        return realAns;\r\n    }\r\n}\r\n```\r\n复杂度\r\nO(n)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568664","body":"```java\nimport java.util.Stack;\n\nclass MyQueue {\n    Stack<Integer> stack;\n    Stack<Integer> tempStack;\n\n    public MyQueue() {\n        this.stack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.isEmpty()) {\n            stack.push(x);\n        } else {\n          while(!stack.isEmpty()) {\n              tempStack.push(stack.pop());\n          }\n          stack.push(x);\n          while(!tempStack.empty()) {\n              stack.push(tempStack.pop());\n          }\n        }\n    }\n    \n    public int pop() {\n        return stack.pop();\n    }\n    \n    public int peek() {\n        return stack.peek();\n    }\n    \n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304824953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304848410","body":"```java\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || k == 0)\n            return head;\n        ListNode pointer = head;\n        int count = 0;\n        while(pointer.next != null) {\n            pointer = pointer.next;\n            count++;\n        }\n        pointer.next = head;\n        count++;\n        int times = k/count+1;\n        for(int i = 0; i < count - (k%count); i++) {\n            head = head.next;\n            pointer = pointer.next;\n        }\n        ListNode ans = head;\n        pointer.next = null;\n        return ans;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298531682","body":"### 代码优化：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n        k = Math.floor(k / 10) = 100 \r\n        k = k + 1 = 101\r\n        res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299438780","body":"### 代码优化：\r\n问题可以转换成，对 s 的每个下标 i，求\r\n\r\ns[i] 到其左侧最近的字符 c 的距离\r\ns[i] 到其右侧最近的字符 c 的距离\r\n这两者的最小值。\r\n\r\n代码实现时，在开始遍历的时候 idx 可能不存在，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    // 两次遍历\r\n    var len = s.length;\r\n    var ans = new Array(len).fill(0);\r\n    var idl = -len;\r\n    var idr = 2 * len;\r\n    for (let i = 0; i < len; i++) {\r\n        if (s[i] === c) {\r\n            idl = i;\r\n        }\r\n        ans[i] = i - idl;\r\n    }\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        if (s[i] === c) {\r\n            idr = i;\r\n        }\r\n        ans[i] = Math.min(ans[i], idr - i);\r\n    }\r\n    return ans;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1303543816","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度: push和pop为O（1），increment为O（min（k，top））\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303544379","body":"### 思路：\r\n遍历数组，\r\n1. 如果是'[',直接入栈\r\n2. 如果是'数字'，将连续数字字符识别出来，统一放入栈中\r\n3. 如果是']',进行处理\r\n-  ① 连续获取字符串，直到遇到”[“\r\n- ② 取出数字\r\n- ③ 计算出字符串后再入栈\r\n4. 如果是'普通字符'，正常入栈\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304811807","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304811620","body":"### 思路：\r\n单调栈（递增）\r\n- 当前值大于等于栈顶，可以成块\r\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\r\n\r\n### 代码\r\n```js\r\n// 获取栈顶元素\r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // 小于的时候，只保留栈顶用于成块\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= 可以独立成块\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298650820","body":"### 思路\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+912, 2+91, 1+9, 0+1。\r\n\r\n自我复述视频： https://www.bilibili.com/video/BV14W4y1771Z/\r\n\r\n### 代码\r\n```js\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    let i = num.length - 1 \r\n    let res = []\r\n\r\n    while(i>=0 || k>0){\r\n        if(i>=0){\r\n            k += num[i]\r\n            i --\r\n        }\r\n        res.push(k % 10)\r\n        k = parseInt(k /10)\r\n    }\r\n    return res.reverse()\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300481747","body":"**代码**\r\n```\r\nclass Solution:\r\n    def shortestToChar (self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        res = [n + 1] * n\r\n        idx = -1\r\n        for i in range(n):  # 左侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != -1:\r\n                res[i] = i - idx\r\n\r\n        idx = n\r\n        for i in range(n - 1, -1, -1):  # 右侧 c 位置\r\n            if s[i] == c:\r\n                idx = i\r\n            if idx != n:\r\n                res[i] = min(idx - i, res[i])\r\n\r\n        return res\r\n```\r\n**复杂度**\r\n时间复杂度：$O(n)$ 。遍历 s 即可，\r\n空间复杂度： 。和 s 等长的结果数组，","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303481781","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stk = []\n        for x in s:\n            if x==']':\n                restr = ''\n                num = ''\n                while stk and stk[-1]!='[':\n                    restr = stk.pop()+restr\n                stk.pop()\n                while stk and stk[-1].isnumeric():\n                    num = stk.pop()+num\n                stk.extend(restr*int(num))\n            else:\n                stk.append(x)\n        return ''.join(stk)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302315589","body":"```ts\r\nclass CustomStack {\r\n  maxSize: number\r\n  stack: number[]\r\n\r\n  constructor(maxSize: number) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n  }\r\n\r\n  push(x: number): void {\r\n    if (this.stack.length >= this.maxSize) return\r\n    this.stack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    if (this.stack.length === 0) return -1\r\n    return this.stack.pop()\r\n  }\r\n\r\n  increment(k: number, val: number): void {\r\n    for (let i = 0; i < k && i < this.stack.length; i++) this.stack[i] += val\r\n  }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298166132","body":"# LeetCode Link\n\n[Add to Array-Form of Integer - LeetCode](https://leetcode.com/problems/add-to-array-form-of-integer/description/)\n\n# Idea\n\nAdd from last of the array `num`.\n\nUse `linkedList.addFist()` method to collect the reversed result.\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        int i = n - 1;\n        LinkedList<Integer> lst = new LinkedList<>();\n        int carry = 0;\n        while (k != 0 || i >= 0 || carry != 0) {\n            int a = i >= 0 ? num[i] : 0;\n            int sum = a + k % 10 + carry;\n            lst.addFirst(sum % 10);\n\n            i--;\n            k /= 10;\n            carry = sum / 10;\n        }\n        return (List<Integer>) lst;\n    }\n}\n```\n\n# Complexity Analysis\n\n**Time Complexity**\n\n`O(N+L)`, where `N` is the length of `num`, `L` is number of digits of `k`.\n\n**Space Complexity**\n\n`O(1)` no extra space required.\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298358969","body":"```\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    swapArr(num)\r\n    kArr := convertToArray(k)\r\n    var res []int\r\n    var carry int\r\n    var bitSum int\r\n    for i, j := 0, 0; i < len(num) || j < len(kArr); {\r\n        if i >= len(num) {\r\n            bitSum = kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            j++\r\n        } else if j >= len(kArr) {\r\n            bitSum = num[i] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n        } else {\r\n            bitSum = num[i] + kArr[j] + carry\r\n            carry = bitSum / 10\r\n            res = append(res, bitSum % 10)\r\n            i++\r\n            j++\r\n        }\r\n    }\r\n    if carry > 0 {\r\n        res = append(res, carry)\r\n    }\r\n    swapArr(res)\r\n    return res\r\n}\r\n\r\nfunc swapArr(arr []int) {\r\n    for i, j := 0, len(arr) - 1; i < j; i, j = i+1, j-1 {\r\n        arr[i], arr[j] = arr[j], arr[i]\r\n    }\r\n}\r\n\r\nfunc convertToArray(k int) []int {\r\n    var res []int\r\n    for k > 0 {\r\n        mod := k % 10\r\n        k = k / 10\r\n        res = append(res, mod)\r\n    }\r\n    return res\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301587875","body":"```\r\ntype CustomStack struct {\r\n    arr []int\r\n    sp int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{ arr: make([]int, maxSize), sp: -1 }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.sp >= len(this.arr) - 1 {\r\n        return\r\n    }\r\n    this.sp += 1\r\n    this.arr[this.sp] = x\r\n}\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.sp < 0 {\r\n        return -1\r\n    }\r\n    res := this.arr[this.sp]\r\n    this.sp -= 1\r\n    return res\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    for i := 0; i <= this.sp && i < k; i++ {\r\n        this.arr[i] += val\r\n    }\r\n}\r\n```\r\nTime: O(k)\r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnvsd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yueza":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawyuan97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victorhuang99":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cusanity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay-xzj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiradaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyue-ma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298065318","body":"```java\n/*\nPlan: perform addition from backwards, edge case: k has more digits, carry\n\nTime: O(max(log_10(num), log_10(k))), number of digits\nSpace: O(max(log_10(num), log_10(k)))\n*/\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int curSum = 0, carry = 0;\n        LinkedList<Integer> sum = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            curSum = num[i] + k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        // if k has more digits\n        while (k > 0) {\n            curSum = k % 10 + carry;\n            k /= 10;\n            sum.addFirst(curSum % 10);\n            carry = curSum / 10;\n        }\n        if (carry == 1) {\n            sum.addFirst(1);\n        }\n        return sum;\n    }\n}\n```","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725572","body":"```java\n/*\nstore a representative in the stack for each chunk (max value in that chunk)\nIf the current num == prev max, add to stack\nIf current num > prev max, add to stack\nIf current num < prev max, pop until find the right chunk to merge:\ninsert 3, e.g. 1, 4, pop 4, insert 3\n\n[4,2,2,1,1]\n-> 1\n\nstack:bottom ---> increasing\nTime: O(arr.length)\nSpace: O(arr.length)\n\n\n\n*/\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            }\n            else {\n                int curmax = stack.peek();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(curmax); // merge num into the chunk represented by curmax\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"steven72574":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298605508","body":"### 思路 从数组最后一个元素开始加，用一个队列记录答案，用一个变量记录是否要进一位。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        Deque<Integer> res = new ArrayDeque<>();\n        int plusOne = 0;\n        for(int i = num.length - 1 ; i >= 0 ; i--){\n            int n = num[i] + k%10 + plusOne;\n            k = k/10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        //结束后，k可能还有剩余，或者还要进位\n        while(k != 0){\n            int n = k % 10 + plusOne;\n            k /= 10;\n            if(n >= 10){\n                plusOne = 1;\n            }else{\n                plusOne = 0;\n            }\n            res.addFirst(n%10);\n        }\n        if(plusOne == 1){\n            res.addFirst(1);\n        }\n        return new ArrayList<Integer>(res);\n\n    }\n}\n```\n### 复杂度  \n时间O(n),n是数组长度  \n空间O(n),记录答案所消耗的开销\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1298895541","body":"\n### Method 1:\n双指针，对于每一个元素，定义两个指针从自身背向出发，定义变量distance记录距离，当遇到字符c时，返回distance.\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        for(int i = 0 ; i < s.length() ;i++){\n            res[i] = getShortestChar(s , i , c);\n        }\n        return res;\n    }\n    //双指针\n    public int getShortestChar(String s , int i , char c){\n        if(s.charAt(i) - c == 0)return 0;\n        int left = i , right = i;\n        int distance = 0;\n        while(left >= 0 || right <= s.length() - 1 ){\n            \n            if(s.charAt(left) - c ==0 || s.charAt(right) - c == 0){\n                return distance;\n            }\n            if(left > 0){\n                left--;\n            }\n            if(right < s.length() - 1){\n                right++;\n            }\n            distance++;\n\n        }\n        return distance;\n\n    }\n}\n```\n### 复杂度\n时间O(n^2)  \n空间O(n)  \n### method 2:\n两遍遍历，同时记录到c的距离。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] res = new int[N];\n        int idx = -N;\n        for(int i = 0 ; i < N ; i++){\n            if(s.charAt(i) - c == 0){\n                idx = i;\n            }\n            res[i] = Math.abs(i - idx);\n        }\n        \n        for(int i = N - 1 ; i >= 0 ;i--){\n            if( s.charAt(i) - c ==0){\n                idx = i;\n            }\n            res[i] = Math.min(res[i] , Math.abs(i - idx));\n        }\n        return res;\n    }\n}\n```\n### 复杂度\nTime O(n)  \nSpace O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301009155","body":"### 思路：数组模拟栈，定义变量idx表示当前栈的容量。\n```java\nclass CustomStack {\n    int[] stack;\n    int idx;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        stack = new int[maxSize];\n        idx = -1;\n    }\n    \n    public void push(int x) {\n        \n        if(idx < maxSize - 1 && idx >= -1){\n            ++idx;\n            stack[idx] = x;\n        }\n    }\n    \n    public int pop() {\n        if(idx >= 0){\n            return stack[idx--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k , idx + 1);\n        for(int i = 0 ; i < min ; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度\npop() : time O(1), space O(1)  \npush() : time O(1),space O(1)  \nincrement(): time O(k),space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302697660","body":"### 思路：遍历字符串，当字符不是” ]“右括号时压入栈，遇到右括号时，栈弹出，在遇到 \" [ \"左括号前，把所有字符组成repeatString , 然后当还是数字时弹出，组成num，对repeatString 重复num次，再把新的字符串压入栈中。\n```java\nclass Solution {\n    public String decodeString(String s) {\n        int N = s.length();\n        Stack<String> stack = new Stack<>();\n        for(int i = 0 ; i < N ; i ++){\n            String repeatStr = \"\";\n            String num = \"\";\n            String newString = \"\";\n            String cur = s.substring(i , i + 1);\n            if(!cur.equals(\"]\") ){\n                stack.push(s.substring(i , i+1));\n            }else{\n                while(!stack.isEmpty() && !stack.peek().equals(\"[\")){\n                    repeatStr = stack.pop() + repeatStr;\n                }\n                stack.pop();// pop :[\n                while(!stack.isEmpty() && stack.peek().matches(\"[0-9]\")){\n                    num = stack.pop() + num;\n                }\n                for(int j = 0 ; j < Integer.valueOf(num) ; j++){\n                    newString += repeatStr;\n                }\n                //把新字符串压回栈中\n                for(int j = 0 ; j < newString.length() ; j++){\n                    stack.push(newString.substring(j , j + 1));\n                }\n            }\n            \n            \n        }\n        String res = \"\";\n        while(!stack.isEmpty()){\n            res = stack.pop() + res;\n        }\n        return res;\n    }\n}\n```\ntime O(n)  \nspace O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561045","body":"\n```java\nclass MyQueue {\n    Stack<Integer> in;\n    Stack<Integer> out;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    public int peek() {\n        if(out.isEmpty()){\n            while(!in.isEmpty()){\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        if(in.isEmpty() && out.isEmpty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304790996","body":"\n先抄个答案·\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();\n        int res = 0;\n        int[] sortedArr = new int[arr.length];\n        System.arraycopy(arr, 0, sortedArr, 0, arr.length);\n        Arrays.sort(sortedArr);\n        for (int i = 0; i < sortedArr.length; i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt.put(x, cnt.getOrDefault(x, 0) + 1);\n            if (cnt.get(x) == 0) {\n                cnt.remove(x);\n            }\n            cnt.put(y, cnt.getOrDefault(y, 0) - 1);\n            if (cnt.get(y) == 0) {\n                cnt.remove(y);\n            }\n            if (cnt.isEmpty()) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n\n```\ntime O(nlogn)\nspace O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowangcoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james0608":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaneyang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"azl397985856":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengfengfengwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bulingbulingbuling":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eden-ye":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingtrains":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"starorbiting":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mo-xiaoxiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"passengersa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shellylcooper":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testplm":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297848071","body":"python one line\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        return [int(i) for i in list(str(int(''.join(map(str,num)))+k))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299744757","body":"```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        dis = []\n        idx = s.index(c)\n        for i in range(len(s)):\n            if abs(idx-i)>abs(s.find(c,i)-i):\n                idx = s.index(c,i)\n            if s[i]!=c:\n                dis.append(abs(idx-i))\n            else:\n                dis.append(0)\n        return dis\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301701899","body":"```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxsize = maxSize\n        self.stack = []\n        self.inc = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n\n        return self.stack.pop()+self.inc.pop()\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        if self.inc:\n            self.inc[min(k, len(self.inc))-1] += val\n```\n- Time:O(n)\n- Space:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302812702","body":"```python\nclass Solution(object):\n    def decodeString(self, s):\n        # 两个栈，一个进数字，一个进字母，反括号出栈\n        stack = [];curNum=0;curString=''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n- Time: O(n)\n- Space: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304395500","body":"```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.in_stk = []\n        self.out_stk = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.in_stk.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        self.peek()\n        return self.out_stk.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.out_stk:\n            while self.in_stk:\n                self.out_stk.append(self.in_stk.pop())\n        return self.out_stk[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.in_stk and not self.out_stk\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304729549","body":"```python \nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack = []\n        count = 0\n        for i in arr:\n            if len(stack)==0 or stack[-1]<=i:\n                stack.append(i)\n            else:\n                ma = stack[-1]\n                # 如果遇到更大的值，则一直往前比较（每次比较都会删去栈顶一个元素）\n                while stack and stack[-1]>i:\n                    ma = max(ma,stack.pop())\n                stack.append(ma)\n        return len(stack)\n```\n- Time:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304941600","body":"```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        # 返回链表倒数第k个元素，当k大于链表长度时，返回倒数K/len的元素，然后最后一位拼接一下\n        # 先获取数组长度\n        if not head:\n            return None\n        lastElement = head\n        length = 1\n        while(lastElement.next):\n            lastElement = lastElement.next\n            length += 1\n        # 先拼成环\n        lastElement.next = head\n        # 找出倒数第k个元素，进行切割\n        k = k%length\n        p = head\n        for i in range(length - k - 1):\n            p = p.next\n\n        head2 = p.next\n        p.next=None\n        return head2\n```\n- Time:O(n)\n- Space:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tom-zhouch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skylarxu214":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taihui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huaxueguakele":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yang-chenyu104":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mlking15":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"-3":[],"cyonline":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546268","body":"### 思路: 用一个栈负责进入,然后将这个栈中的元素倒置放在另一个栈中,每次push取栈1,pop和peek取栈2的栈顶\n\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = []\n};\n\n\nMyQueue.prototype.push = function(x) {\n    console.info(x)\n    this.stack1.push(x)\n    \n};\n\nMyQueue.prototype.pop = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n};\n\n\nMyQueue.prototype.peek = function() {\n    if(this.stack2.length==0){\n        for(let i=0;i<this.stack1.length;i++){\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length-1] \n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack1.length ==0 && this.stack2.length == 0\n};\n\nvar obj = new MyQueue()\nobj.push(1)\nvar param_2 = obj.pop()\n\n### 复杂度分析:\n时间: pop,peek O(n), empty O(1)\n空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297621667","body":"**Thoughts**\n\nAdding k with the last digit of num, the mod result will be the digit of result, and carry-on can be calculated as well\n\n**Complexity**\n\nO(N)\n\n**Code**\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list  = new LinkedList<>();\n        int n = num.length;\n\n        // each time we add k with last digit of num, add the mod value to the list \n        for (int i = n - 1; i >= 0; i--) {\n            list.add(0, (num[i] + k) % 10);\n            // carry on value\n            k = (num[i] + k) / 10;\n        }\n        //for the rest of k\n        while (k > 0) {\n            list.add(0, k % 10);\n            k /= 10;\n        }\n        return list;\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299508660","body":"**Thoughts**\n\nSweep string s from left and right side, if we locate c, record the index, then compare the absolute value of i and index\n\n**Complexity**\n\nTime: O(n)\nSpace: O(1) no other space except the result\n\n**Code**\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n\n        for (int i = 0, idx = -len; i < len; i++) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = i - idx;\n        }\n        for (int i = len - 1, idx = 2 * len; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            res[i] = Math.min(idx - i, res[i]);\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302272872","body":"**Thoughts**\n\nJust simple manipulation \n\n**Time Complexity**\n\nTime: O(1)\nSpace: O(1)\n\n**Code**\n\n```java\n\nclass CustomStack {\n    int[] stack;\n    int top; // to record the index of top element\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303802706","body":"**Thoughts**\n\nUse Stack to push characters of s, stop when it hits ], and then gather the characters, read the multiplier, finally push all characters into the stack and pop out\n\n**Complexity**\n\nTime: O(N), N is the length of s\nSpace: O(N) the use of stack\n\n**Code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n            } else {\n                StringBuilder sb = new StringBuilder();\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                String sub = sb.toString();\n                stack.pop(); // remove [\n\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n                int count = Integer.valueOf(sb.toString());\n\n                while (count > 0) {\n                    for (char su: sub.toCharArray()) {\n                        stack.push(su);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304389055","body":"***Thoughts***\n\nUsing two stacks, one is to save input, another one is used to save data in reverse direction\n\n***Complexity***\n\nTime: O(1) no traversing\nSpace: O(N). use another stack\n\n***Code***\n```java\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n\n    public MyQueue() { \n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815563","body":"***Thoughts***\n\n1. If current number is greater the peek of stack, it can be an individual chunk\n2. If current number is less than the peek of stack, we remove the values greater than it\n\n**Complexity**\n\nTime: O(N)\nSpace: O(N)\n\n**Code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n\n        for (int num: arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(head);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297787339","body":"### 思路\r\n\r\n先得到整数num与k相加和的结果，然后从个位数开始每次往前一位取出加入list，在每一次取数位结果的同时将和的结果除以10，直至k的结果小于等于0停止加入list。比如 123 + 912，实现3+2, 2+1, 1+9。当对应位的加和结果超过10，我们将先将0加入list，再加入1，最后结果是1035。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n    for (int i = num.length - 1; i >= 0; i--) {\r\n            res.add((num[i] + k) % 10);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while(k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299341332","body":"### 思路\r\n两次遍历，第一次找到每个i左边最近的 c，第二次找到每个i右边最近的 c。\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        \r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = i - j;\r\n        }\r\n        \r\n        for(int i = n-1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) j = i;\r\n            if(j != -1) ans[i] = Math.min(ans[i], j - i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301328092","body":"### 思路\r\n新建一个数组来进行模拟栈的操作\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top = -1;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length - 1){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) return -1;\r\n        top--;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：increment的操作是O(n)，其他操作是O(1)。\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303048165","body":"## Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n## Time Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304413581","body":"## Thoughts\r\n- 使用两个栈，一个输入栈，一个输出栈\r\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\r\n- empty方法需要判断两个栈都为空\r\n\r\n## Code\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s2.isEmpty()) {\r\n          while(!s1.isEmpty()) s2.push(s1.pop());  \r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n## TC\r\nTime: O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304649141","body":"## Thoughts\r\n前缀和方法：\r\narr: [2,1,3,4,4]\r\ncopy:[1,2,3,4,4]\r\n## Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] copy = arr.clone();\r\n        Arrays.sort(copy);\r\n        int count = 0;\r\n        int sum1 = 0, sum2 = 0;\r\n        for(int i = 0; i < arr.length; i++) {\r\n            sum1 += arr[i];\r\n            sum2 += copy[i];\r\n            if(sum1 == sum2) {\r\n                count++;\r\n                sum1 = 0;\r\n                sum2 = 0;\r\n            }\r\n        }\r\n        return count;\r\n    }\r\n}\r\n```\r\n## TC\r\n- Time: O(nlogn)\r\n- Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304922454","body":"## Code\r\n```java\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null || k == 0) return head;\r\n        ListNode dummy = new ListNode(0);\r\n        dummy.next = head;\r\n        ListNode p = head;\r\n        int count = 1;\r\n        while(p.next != null) {\r\n            p = p.next;\r\n            count += 1;\r\n        }\r\n        if((k % count) == 0) return head;\r\n        ListNode slow = head, fast = head;\r\n        for(int i = 0; i < (k % count); i++){\r\n            fast = fast.next;\r\n        }\r\n        while(fast.next != null) {\r\n            slow = slow.next;\r\n            fast = fast.next;\r\n        }\r\n        ListNode node = slow.next;\r\n        slow.next = null;\r\n        fast.next = head;\r\n    return node;\r\n    }\r\n}\r\n/*\r\n[1,2,3,4,5]\r\n[4,5,1,2,3]\r\n*/\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jetery":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297858805","body":"### 思路\n&ensp;&ensp;&ensp;&ensp;模拟竖式的加法, 得到每个数组的最低位, 从最低位开始加\n### 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> a, b;\n        for (int i = num.size() - 1; i >= 0; i--) a.push_back(num[i]);\n        while (k != 0) {\n            b.push_back(k % 10);\n            k /= 10;\n        }\n        vector<int> temp;\n        int t = 0;\n        for (int i = 0; i < a.size() || i < b.size(); i++) {\n            if (i < a.size()) t += a[i];\n            if (i < b.size()) t += b[i];\n            temp.push_back(t % 10);\n            t /= 10;\n        }\n        if (t) temp.push_back(1);\n        vector<int> ans;\n        for (int i = temp.size() - 1; i >= 0; i--) ans.push_back(temp[i]);\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299666978","body":"### [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n### 思路 1 两次遍历\r\n\r\n* 第一次遍历记录满足条件字符下标 `k` : \r\n  - 1.  满足条件, 更新左边界 `k`\r\n  - 2.  不满足条件 , 直接填入 `k` (左边满足条件的下标 or 左边不存在满足的下标)  \r\n\r\n  此时 `k` 停留在最后一个满足条件的位置 (题目数据保证 `c` 在 `s` 中至少出现一次)\r\n\r\n* 第二次遍历时记录右边满足条件的下标 :\r\n  - 1. 满足条件, 更新右边界 `k`\r\n  - 2. 不满足条件, 填入 ___当前下标 `i` 和左边界的距离 `i - ans[i]`___  和  ___右边界 `k` 的距离 `i - k`___ 的最小值\r\n    - 当 `k` 被更新后, `i`继续向左移动 , 会造成 `i - k` 为负值, 所以需要加上绝对值\r\n    - 若使用 `k - i` , 当 `k` 没有停留在 `s.size() - 1` , 依旧有可能 `k - i < 0`, 故仍需要绝对值\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ans(n, -1);\r\n        int k = -n;\r\n        // get the left distance\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = k;\r\n        }\r\n        // get the right distance then compare with left distance \r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) k = i;\r\n            ans[i] = min(i - ans[i], abs(i - k));\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(2N) -> O(N)\r\n- 空间复杂度：O(N)\r\n\r\n-------\r\n\r\n### 思路 2 一次遍历\r\n\r\n* 对思路 1 的优化\r\n  - `l` 为左边界 , `r` 为右边界\r\n  - `i` 从头遍历数组 , `j` 从尾遍历数组\r\n  - 遇到满足条件的情况分别更新 `l` , `r` \r\n  - 若 `i >= l` 说明当前下标左边有符合条件的 `c` ; 同理 , `j <= r` 则右边有\r\n  - 取最小值min\r\n  - 由于 `i` , `j` 指针相遇后仍继续移动 , 可以做到不遗漏\r\n\r\n\r\n### 代码 (cpp)\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> ans(s.size(), INT_MAX);\r\n        int l = s.size(), r = -1, n = s.size();\r\n        for (int i = 0; i < s.size(); i++) {\r\n            int j = n - 1 - i;\r\n            if (s[i] == c) l = i;\r\n            if (s[j] == c) r = j;\r\n            if (i >= l) ans[i] = min(ans[i], i - l);\r\n            if (j <= r) ans[j] = min(ans[j], r - j);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301572039","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\n### 思路\n模拟题, 用 vector 模拟栈, `size` 表示当前栈大小  \n需要注意的是, `increment(int k, int val)` 的 `k` 可能超过 `size`\n### 代码 (cpp)\n```cpp\nclass CustomStack {\n\npublic:\n    int size = 0, max = 0;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (size < max) {\n            stack.push_back(x);\n            size++;\n        }\n    }\n    \n    int pop() {\n        if (size == 0) return -1;\n        size = size - 1;\n        int ret = stack[size];\n        stack.pop_back();\n        return ret;\n    }\n    \n    void increment(int k, int val) {\n        for (int i = 0; i < size && i < k; i++) {\n            stack[i] += val;\n        }\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302928618","body":"### [394. 字符串解码](https://leetcode.cn/problems/decode-string/)\n### 思路 1: 双栈\n* 使用 `num` 栈记录重复次数 ; `str` 栈记录要重复的字符 ; \n* `n` 为当前数字, `ans` 为解码后的字符\n  - 当 `c >= '0' && c <= '9'` 时 , 更新数字 `n`\n  - 当 `c == 'a' && c <= 'z'` 时, 更新 `ans`\n  - 当 `c == '['` 时, 为了保留当前信息, 处理`[`后信息, 故将 `num` 压入当前数字, `n` 置为 0 ; `str` 压入当前字符, `ans = \"\"`\n  - 当 `c == ']'` 时, `ans` 已经为最近的`[`和当前`]`内的字符, 得到重复次数 `t = num.top()`, \n  将当前字符按照 `t` 添加到外层字符 `str.top()` 后, 完成了部分解码, 更新 `ans`, 将栈内元素弹出\n  \n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> num;\n        int n = 0;\n        stack<string> str;\n        string ans = \"\";\n        for (char c : s) {\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                num.push(n);\n                n = 0;\n                str.push(ans);\n                ans = \"\";\n            } else if (c == ']') {\n                int t = num.top();\n                num.pop();\n                for (int i = 0; i < t; i++) {\n                    str.top() += ans;\n                }\n                ans = str.top();\n                str.pop();\n            } else {\n                ans += c;\n            }\n        }\n        return ans;\n    }\n\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n---\n\n### 思路 2: 栈 + 递归\n\n* 仅遇到`[`和`]`时和思路 1 不同  \n    - 当 `c == '['` 时, 递归处理后续字符, 得到返回值 `sub`, 按次数添加`sub`, `n`置为0\n    - 当 `c == ']'` 时, 说明此级别的 `'[]'`内字符已处理完\n\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    string helper(stack<char> &stack) {\n        int n = 0;\n        string ret = \"\";\n        while (!stack.empty()) {\n            char c = stack.top();\n            stack.pop();\n            if (c >= '0' && c <= '9') {\n                n = n * 10 + c - '0';\n            } else if (c == '[') {\n                string sub = helper(stack);\n                for (int i = 0; i < n; i++) {\n                    ret += sub;\n                }\n                n = 0;\n            } else if (c == ']'){\n                break;\n            } else {\n                ret += c;\n            }\n        }\n        return ret;\n    }\n    \n    string decodeString(string s) {\n        stack<char> stack;\n        for (int i = s.size() - 1; i >= 0; i--)\n            stack.push(s[i]);\n        string ret = helper(stack);\n        return ret;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304377408","body":"### [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/submissions/)\n### 思路\n使用两个栈模拟队列\n### 代码 (cpp)\n```cpp\nclass MyQueue {\npublic:\n    stack<int> input;\n    stack<int> output;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        input.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n            output.pop();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n            output.pop();\n        }\n        return ret;\n    }\n    \n    int peek() {\n        int ret = 0;\n        if (output.size() > 0) {\n            ret = output.top();\n        } else {\n            while (!input.empty()) {\n                output.push(input.top());\n                input.pop();\n            }\n            ret = output.top();\n        }\n        return ret;\n    }\n    \n    bool empty() {\n        return input.empty() && output.empty();\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734017","body":"### [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n### 思路\n先将原数组复制且排序得到`clone`, 比较`arr`和`clone`, 如果在`[0,i]`范围内, 出现的数字频率一致, 那么就有1种分法\n* 使用哈希表对`arr[i]`进行计数:   \n    - 处理`arr[i]`时, 对`map[arr[i]]`进行计数加一\n    - 处理`clone[i]`时, 对`map[clone[i]]`进行计数减一\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        // 已经排序的数组\n        vector<int> clone = arr;\n        sort(clone.begin(), clone.end());\n        \n        int ans = 0, window = 0;\n        // 使用哈希表进行计数\n        unordered_map<int, int> map;\n\n        for (int i = 0; i < arr.size(); i++) {\n            map[arr[i]]++;\n            if (map[arr[i]] == 0) window--;\n            else if (map[arr[i]] == 1) window++;\n\n            map[clone[i]]--;\n            if (map[clone[i]] == 0) window--;\n            else if (map[clone[i]] == -1) window++;\n\n            if (window == 0) ans++;\n        }\n\n        return ans;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(nlogn)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304996119","body":"### [61. 旋转链表](https://leetcode.cn/problems/rotate-list/)\n### 思路\n* 遍历两次\n  - 第一次遍历得到链表长度`size`并构成环形链表\n  - 第二次得到`size - k - 1`个结点, 在此处将链表断开即可\n### 代码 (cpp)\n```cpp\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (k == 0 || head == NULL || head->next == NULL) {\n            return head;\n        }\n        \n        int size = 1;\n        ListNode* cur = head;\n        while (cur->next != NULL) {\n            cur = cur->next;\n            size++;\n        }\n        cur->next = head;\n\n        k %= size;\n        for (int i = size - k - 1; i > 0; i--) {\n            head = head->next;\n        }\n\n        cur = head->next;\n        head->next = NULL;\n\n        return cur;\n    }\n};\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"klspta":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297896968","body":"### 思路\n第一眼感觉跟第二题很像，从最后一位开始加，记录进位状态，数组先结束，检查k是否有值；k结束，检查数组是否还有值；\n后来发现进位状态可以合并回 k，详见代码。\n\n### 代码\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<>();\n        for(int i = num.length - 1; i >= 0; i--){\n            int x = num[i] + k % 10;\n            ans.add(x % 10);\n            k /= 10;\n            k += x / 10;\n        }\n        for (; k > 0; k /= 10) {\n            ans.add(k % 10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299396343","body":"### 思路\r\n\r\n根据题意，两次遍历；第一次从左往右，找到每个位置左侧最近的；第二次从右往左，找到右侧最近的；\r\n\r\n### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] cs = s.toCharArray();\r\n        int[] ans = new int[cs.length];\r\n        Arrays.fill(ans, cs.length + 1);\r\n        int j = -1;\r\n        for(int i = 0; i < cs.length; i++){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = i - j;\r\n            }\r\n        }\r\n        j = -1;\r\n        for(int i = cs.length - 1; i >= 0; i--){\r\n            if(cs[i] == c){\r\n                j = i;\r\n            }\r\n            if(j != -1){\r\n                ans[i] = Math.min(ans[i], j - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n### 时空分析\r\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301801372","body":"### 思路\n直接模拟 \n\n### 代码\n\n```java\nclass CustomStack {\n    private int[] stack;\n    private int size;\n    private int cur;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = maxSize;\n        cur = -1;\n    }\n   \n    public void push(int x) {\n        if(cur + 1 == size){\n            return;\n        }\n        stack[++cur] = x;\n    }\n    \n    public int pop() {\n        if(cur < 0){\n            return -1;\n        }\n        return stack[cur--];\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i <= cur; i++){\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度\n时间复杂度：O(1) inc O(k)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303446549","body":"## 思路\n递归，返回内部字符串 和 计算到了哪个位置；每次遇到[ 就进入下层，遇到 ] 就发返回；\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        char[] str = s.toCharArray();\n        return process(str, 0).res;\n    }\n\n    private Info process(char[] str, int index){\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n        while(index < str.length){\n            char c = str[index];\n            if(c >= '0' && c <= '9'){\n                count = count * 10 + (c - '0');\n            }else if(c == '['){\n                Info info = process(str, index + 1);\n                while(count > 0){\n                    sb.append(info.res);\n                    count--;\n                }\n                index = info.index;\n            }else if(c == ']'){\n                return new Info(sb.toString(), index);\n            }else {\n                sb.append(c);\n            }\n            index++;\n        }\n        return new Info(sb.toString(), index);\n    }\n}\n\nclass Info{\n    String res;\n    Integer index;\n\n    Info(String res, Integer index){\n        this.res = res;\n        this.index = index;\n    }\n}\n\n```\n\n### 时空分析\nO(n), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304371003","body":"## 思路\n\n## 代码\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> data = new Stack<>();\n    private Stack<Integer> help = new Stack<>();\n    public MyQueue() {\n\n    }\n    public void push(int x) {\n        data.push(x);\n    }\n    \n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        return help.pop();\n    }\n    \n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        return help.peek();\n    }\n    \n    public boolean empty() {\n        pushToHelp();\n        return help.isEmpty();\n    }\n\n    private void pushToHelp(){\n        if(help.isEmpty()){\n            while(!data.isEmpty()){\n                help.push(data.pop());\n            }\n        }\n    }\n}\n```\n\n## 复杂度分析\nO(1), O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780145","body":"### 思路\n用栈保存所有段的最大值；\n逐个比较数组中每个数组，如果比当前栈顶元素小，那么肯定属于之前顶段，然后取栈顶和当前数的最大值再次放入栈；\n最后返回栈的长度即为分段的个数；\n\n### 代码\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for(int n : arr){\n            int t = n;\n            while(!stack.isEmpty() && stack.peek() > n){\n                t = Math.max(t, stack.pop());\n            }\n            stack.push(t);\n        }\n        return stack.size();\n    }\n}\n\n\n```\n\n### 时空分析\nO(n), O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bookyue":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297908504","body":"更喜欢这种一个循环的写法，虽然多了一个判断\n\n**Code**\n\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n\n        int i = num.length - 1;\n        while (k > 0 || i >= 0) {\n            if (i >= 0)\n                k += num[i];\n\n            ans.add(0, k % 10);\n            k /= 10;\n            i--;\n        }\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299444396","body":"**Code**\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n\n        int i = 0;\n        for (int t = 0; t < s.length(); t++) {\n            while (s.charAt(t) == c && i < t) {\n                ans[i] = t - i;\n                i++;\n            }\n        }\n\n        i = s.length() - 1;\n        for (int t = s.length() - 1; t >= 0; t--) {\n            while (s.charAt(t) == c && i > t) {\n                ans[i] = ans[i] == 0 ? i - t : Math.min(ans[i], i - t);\n                i--;\n            }\n        }\n\n        for (i = 0; i < s.length(); i++)\n            if (s.charAt(i) == c) ans[i] = 0;\n\n        return ans;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301777110","body":"**code**\n\n```java\nclass CustomStack {\n    private final int[] stack;\n    private int top;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top == stack.length - 1) return;\n        \n        stack[++top] = x;\n    }\n\n    public int pop() {\n        if (top == -1) return -1;\n        \n        return stack[top--];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i <= top && i < k; i++)\n            stack[i] += val;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302899706","body":"**code**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Character> deque = new ArrayDeque<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c != ']') deque.addFirst(c);\n            else {\n                StringBuilder sb = new StringBuilder();\n                while (!deque.isEmpty() && Character.isLetter(deque.getFirst()))\n                    sb.insert(0, deque.removeFirst());\n\n                String sub = sb.toString();\n                deque.removeFirst(); // remove '['\n\n               sb = new StringBuilder();\n               while (!deque.isEmpty() && Character.isDigit(deque.getFirst()))\n                   sb.insert(0, deque.removeFirst());\n\n               int count = Integer.parseInt(sb.toString());\n\n                for (char ch : sub.repeat(count).toCharArray())\n                    deque.addFirst(ch);\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!deque.isEmpty())\n            sb.append(deque.removeLast());\n\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304501376","body":"**code**\n\n```java\nclass MyQueue {\n    Deque<Integer> stackA;\n    Deque<Integer> stackB;\n\n    public MyQueue() {\n        stackA = new ArrayDeque<>();\n        stackB = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        stackA.push(x);\n    }\n\n    public int pop() {\n        transfer();\n        return stackB.pop();\n    }\n\n    public int peek() {\n        transfer();\n        return stackB.peek();\n    }\n\n    public boolean empty() {\n        return stackA.isEmpty() && stackB.isEmpty();\n    }\n    \n    private void transfer() {\n        if (!stackB.isEmpty()) return;\n        \n        while (!stackA.isEmpty())\n            stackB.push(stackA.pop());\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304707450","body":"**thought**\n\nSplit the array into blocks as many as possible and the largest number in the left block should be less than the largest number in the right one.\n\n---\n\n**code**\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int num : arr) {\n            int largest = num;\n            while (!stack.isEmpty() && stack.getFirst() > num)\n                largest = Math.max(largest, stack.removeFirst());\n            \n            stack.addFirst(largest);\n        }\n        \n        return stack.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jancerwu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297909848","body":"## 思路\n从最后一位开始模拟加法运算，低位数字在数组原地保存，超出数组长度的先存到一个栈里，最后先从栈里弹出高位，最后遍历数组得到低位\n\n## 代码\n``` Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] nums, int k) {\n        int n = nums.length;\n        int add = 0;\n        List<Integer> ans = new ArrayList<>();\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0 || k > 0; i--, k /= 10) {\n            int sum = (i >= 0 ? nums[i] : 0) + k % 10 + add;\n            int cur = sum % 10;\n            add = sum / 10;\n            if (i >= 0) nums[i] = cur;\n            else stack.push(cur);\n        }\n        if (add != 0) stack.push(add);\n        while (!stack.isEmpty()) ans.add(stack.poll());\n        for (int num : nums) ans.add(num);\n        return ans;\n    }\n} \n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299437009","body":"## 思路\n两次遍历：从头到尾扫描，标记前面最近的c的位置lc，用当前id减去lc作为答案；从尾到头扫描，标记后面最近的c的位置rc，用当前rc减去当前id，取第一次扫描和当前计算结果的最小值\n\n## 代码\n``` Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        int lc = -n;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) lc = i;\n            ans[i] = i - lc;\n        }\n        int rc = 2 * n;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) rc = i;\n            ans[i] = Math.min(ans[i], rc - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301743466","body":"## 思路 \n1. 基本思路：用数组模拟栈，栈底增量操作可以通过遍历实现\n2. 优化：用一个同样规模的数组保存从此位置到栈底的增量，当pop栈顶元素时，将此增量向栈底增量传递，不要忘记同时需要清零此位置的增量，类似差分数组的思想。\n\n## 代码\n```  Java\nclass CustomStack {\n    int[] stack;\n    int top = -1;\n    int[] topAdd;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        topAdd = new int[maxSize];\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top + 1 < maxSize) stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        if (top - 1 >= 0) topAdd[top-1] += topAdd[top];\n        int res = topAdd[top] + stack[top];\n        topAdd[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int pos = Math.min(k - 1, top);\n        if (pos == -1) return;\n        topAdd[pos] += val;\n    }\n}\n\n```\n\n## 复杂度\n* 时间复杂度：O(1)\n* 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303030423","body":"## 思路\n当遇到左括号时，需要用栈保存前面的解码结果，即用到一个字符串栈，同时需要保存前面的次数，即用到一个数量栈；遇到右括号时，数量栈顶为当前字符串的重复次数。\n\n## 代码\n``` Java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> cStack = new ArrayDeque<>();\n        Deque<Integer> numStack = new ArrayDeque<>();\n        int num = 0;\n        String ans = \"\";\n        for (char c : s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } \n            else if (Character.isLetter(c)) {\n                ans += c;\n            }\n            else if (c == '[') {\n                numStack.push(num);\n                num = 0;\n                cStack.push(ans);\n                ans = \"\";\n            }\n            else if (c == ']') {\n                int cnt = numStack.pop();\n                String str = cStack.pop();\n                for (int i = 1; i <= cnt; i++) {\n                    str += ans;\n                }\n                ans = str;\n            }\n        }\n        return ans;\n    }\n}\n\n```\n## 复杂度\n* 时间：O(n)\n* 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304392085","body":"## 思路\n一个栈模拟队列尾部，负责进入元素；一个栈模拟队列头部，负责出元素；头栈没有元素时，将尾栈的元素全部弹入头栈\n## 代码\n``` Java\nclass MyQueue {\n    Deque<Integer> tail;\n    Deque<Integer> head;\n\n    public MyQueue() {\n        tail = new ArrayDeque<>();\n        head = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        tail.push(x);\n    }\n    \n    public int pop() {\n        tailToHead();\n        return head.pop();\n    }\n    \n    public int peek() {\n        tailToHead();\n        return head.peek();\n    }\n\n    public void tailToHead() {\n        if (!head.isEmpty()) return; \n        while (!tail.isEmpty()) {\n            head.push(tail.pop());\n        }\n    }\n    \n    public boolean empty() {\n        return tail.isEmpty() && head.isEmpty();\n    }\n}\n```\n## 复杂度\n* 时间：O(1)\n* 空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"buer1121":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297912515","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        ###思路：类似于两数之和，将num和k从后面开始竖式相加，然后反转最后得到的数组即可\n\n        ###代码：\n        res=[]\n        n1=len(num)-1\n        carry=0\n        while n1>=0 or k !=0 or carry!=0:\n            x=num[n1] if n1>=0 else 0\n            y=k%10 if k!=0 else 0\n            \n            sum = x+y+carry\n            res.append(sum%10)\n            carry=int(sum/10)\n\n            n1-=1\n            k=int(k/10)\n\n        return res[::-1]\n\n        ###复杂度：时间复杂度O(n);空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299465487","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        ###思路，左右指针分别计算c的两侧的距离\n\n        ###代码\n        n=len(s)\n        res=[n+1]*n\n        idx=-1\n        for i in range(0,n,1):\n            if s[i]==c:\n                idx=i\n            if idx!=-1:\n                res[i]=i-idx\n        idx=n\n        for i in range(n-1,-1,-1):\n            if s[i]==c:\n                idx=i\n            if idx!=n:\n                res[i]=min(res[i],idx-i)\n\n        return res\n\n        ###复杂度：时间复杂度是O(N),遍历两次，空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301559873","body":"###用栈的思想\n###规定出长度\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[0]*maxSize\n        self.top=-1\n\n    def push(self, x: int) -> None:\n        if self.top!=len(self.stack)-1:\n            self.top+=1\n            self.stack[self.top]=(x)\n\n\n\n    def pop(self) -> int:\n        if self.top==-1:\n            return -1\n        self.top-=1\n        return self.stack[self.top+1]\n\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim=min(k,self.top+1)\n        for i in range(lim):\n            self.stack[i]+=val\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302870700","body":"        # ###思想：想法是栈，如果每次一个新的[，就入栈之前的字符串，当遇到]，便进行计算\n\n        ###代码：\n        stack=[]\n        res=\"\"\n        multi=0\n        for c in s:\n            if c==\"[\":\n                stack.append([multi,res])\n                multi,res=0,\"\"\n\n            elif c==\"]\":\n                cur_multi,last_res=stack.pop()\n                res=last_res+cur_multi*res\n            \n            elif '0'<=c<='9':\n                multi=multi*10+int(c)\n            \n            else:\n                res+=c\n            \n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304382862","body":"###思路：利用双栈，当队列出元素时，队列头后面的元素放进辅助栈里面\nclass MyQueue:\n\n    def __init__(self):\n        self.stack=[]\n        self.asstack=[]\n\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if not self.asstack:\n            while self.stack:\n                self.asstack.append(self.stack.pop())\n            return self.asstack.pop()\n        else:\n            return self.asstack.pop()\n\n    def peek(self) -> int:\n        ans=self.pop()\n        self.asstack.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n    \n        if not self.stack and not self.asstack:\n            return True\n        else:\n            return False","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304730315","body":"        ###单调栈\n        ###如果是非递增的，只能分成1块\n        ###如果是非递减的，可以分为n块，n为长度\n        ###因此用单调栈依次存储最大的\n\n        ###代码\n        stack=[]\n        for cur in arr:\n\n            if stack and stack[-1]>cur:\n                cmp=stack[-1]\n                while stack and stack[-1]>cur:\n                    stack.pop()\n                stack.append(cmp)\n            else:\n                stack.append(cur)\n        \n        return len(stack)\n\n        ###复杂度：时间复杂度O(N),空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ceramickitten":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297927660","body":"## 思路\n\n模拟\n\n## 代码\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        def getDigit(i):\n            if i < 0:\n                return 0\n            return num[i]\n        overflow = 0\n        i = len(num) - 1\n        res = []\n        while i >= 0 or k > 0 or overflow:\n            n = getDigit(i) + k % 10 + overflow\n            k //= 10\n            overflow = n // 10\n            i -= 1\n            res.append(n % 10)\n        res.reverse()\n        return res\n\n ```\n\n## 复杂度分析\n\nn = len(num), m = log10(k)\n\n- 时间: O(max(m, n))\n- 空间: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299550536","body":"## 思路\r\n\r\n正反遍历  \r\n以正向遍历为例, dp[i]表示s[i]距离上一个c的距离，如果s[i] == c 那么, dp[i] = 0, 否则 dp[i] = dp[i - 1] + 1  \r\n反向遍历同理, 由于dp[i]已经存储了正向遍历的结果, 在s[i] != c时还需要取下最小值  \r\n\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        dp = [float('inf')] * n\r\n\r\n        def getDp(i):\r\n            if i < 0 or i >= n:\r\n                return float('inf')\r\n            return dp[i]\r\n\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = getDp(i - 1) + 1\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                dp[i] = 0\r\n            else:\r\n                dp[i] = min(dp[i], getDp(i + 1) + 1)\r\n        return dp\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nn = len(s)\r\n\r\n时间: O(n)\r\n空间: O(1) 除了返回值\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gg925407590":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297956718","body":"思路\r\n在数组中从后往前遍历，一边遍历一边将k的个位数加进去并判断是否有进位，然后将k的个位数移除掉，循环往复。\r\n最后判断k或者进位是否有值，如有就进行相加并判断是否有进位，循环往复。没有则直接返回\r\n\r\n代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int index = num.size() - 1;\r\n        int agg = 0;\r\n        for (; index >= 0; index--) {\r\n            num[index] = num[index] + (k%10) + agg;\r\n            k = k / 10;\r\n            if (num[index] >= 10) {\r\n                agg = 1;\r\n                num[index] -= 10;\r\n            }else {\r\n                agg = 0;\r\n            }\r\n        }\r\n        if (agg == 0 && k == 0) {\r\n            return num;\r\n        }else {\r\n            while (k > 9 || agg > 0) {\r\n                auto sum = (k%10) + agg;\r\n                k = k / 10;\r\n                if (sum > 9) {\r\n                    sum = sum - 10;\r\n                    agg = 1;\r\n                }else {\r\n                    agg = 0;\r\n                }\r\n                num.insert(num.begin(), sum);    \r\n            }\r\n            if (k > 0) {\r\n                num.insert(num.begin(), k);\r\n            }\r\n            return num;\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：O(n)，其中 n 为数组长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299510329","body":"思路\n遍历每个值，分别寻找左边和右边最近的给定字符，再取最小值即可。\n\n代码\n```\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> result{};\n        const char* p = s.data();\n        auto max_index = s.length() - 1;\n        if (max_index == 0) {\n            result.push_back(0);\n            return result;\n        }\n        for (auto i = 0; i <= max_index; i++) {\n            if (p[i] == c) {\n                result.push_back(0);\n                continue;\n            }\n            for (auto j = i + 1; ; j++) {\n                if (j > max_index) {\n                    result.push_back(max_index + 1);\n                    break;\n                }\n                 if (p[j] == c) {\n                     result.push_back(j - i);\n                     break;\n                 }\n                 \n            }\n            for (auto z = i - 1; z >= 0; z --) {\n                if (p[z] == c && result.back() > (i - z)) {\n                    result.pop_back();\n                    result.push_back(i - z);\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n时间空间均为 O(N), O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301726919","body":"思路\r\n新建一个vector来进行模拟栈的操作；\r\n因为push进去的每个值不大于1000，可以利用多出来的位数进行存放increment的值，pop当前值时发现这个值携带increment的值，就向下传递下去，可以把increment操作优化到O1；\r\n\r\n代码\r\n```\r\nclass CustomStack {\r\npublic:\r\n    vector<int> base{} ;\r\n    int value_limit = 1000;\r\n    int flag = 0b10000000000;\r\n    int size_limit = 0;\r\n    int top = -1;\r\n    int mask = 0b1111111111;\r\n    CustomStack(int maxSize) {\r\n        size_limit = maxSize - 1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top >= size_limit) {\r\n            return;\r\n        }\r\n        top++;\r\n        base.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (top < 0) return -1;\r\n        int value = base.back();\r\n        base.pop_back();\r\n        top--;\r\n        if ((value & flag) == flag) {\r\n            int add_val = value >> 11;\r\n            value = (value & mask) + add_val;\r\n            if (top >= 0) {\r\n                if ((base[top] & flag) == flag) {\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }else {\r\n                    base[top] = base[top] | flag;\r\n                    base[top] = base[top] + (add_val << 11);\r\n                }\r\n            }\r\n        }\r\n\r\n        \r\n        return value;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int index = min(k - 1, top);\r\n        if (index < 0) return;\r\n        int top_value = base[index];\r\n        if (top_value & flag == 1) {\r\n            base[index] = top_value + (val << 11);\r\n        }else {\r\n            top_value = top_value | flag;\r\n            base[index] = top_value + (val << 11);\r\n        }\r\n        \r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */rement(int k, int val) {\r\n        for(int i = 0; i < (Math.min(k, stack.length)); i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：increment的操作是O(1)，其他操作是O(1)。\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303794752","body":"思路\n将每个字符压入栈，如果遇到']'时弹出栈中内容到temp中，直到遇到'['才结束；如果遇到的是数字，则用add栈记录下来，与遇到'['出现时进行处理即可。\n\n代码\n```\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<char> stack{};\n        vector<char> temp{};\n        vector<int> add{};\n        int sum = 0;\n        for (size_t i = 0; i < s.size(); i++) {\n            if (std::isdigit(s[i])) {\n                sum *= 10;\n                int n = s[i] - '0';\n                sum += n;\n                continue;\n            }else if (sum > 0) {\n                add.push_back(sum);\n                sum = 0;\n            }\n            \n            if (s[i] == ']') {\n                while(!stack.empty()) {\n                    auto c = stack.back();\n                    stack.pop_back();\n                    if (c != '[') {\n                        temp.push_back(c);\n                    }else {\n                        int times = add.back();\n                        for (size_t i = 0; i < times; i++) {\n                            stack.insert(stack.end(), temp.rbegin(), temp.rend());\n                        }\n                        add.pop_back();\n                        temp.clear();\n                        break;\n                    }\n                }\n            }else {\n                stack.push_back(s[i]);\n            }\n        }\n        string result{};\n        result.assign(stack.begin(), stack.end());\n        return result;\n    }\n};\n```\n复杂度\n时间复杂度：$O(n)$，需要遍历一遍字符\n空间复杂度：$O(3n)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304555068","body":"思路\r\n将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\npublic:\r\n    vector<int> s1{};\r\n    vector<int> s2{};\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        s1.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        int result = s2.back();\r\n        s2.pop_back();\r\n        return result;\r\n    }\r\n    \r\n    int peek() {\r\n        if (s2.empty()) {\r\n            while(!s1.empty()) {\r\n                int a = s1.back();\r\n                s1.pop_back();\r\n                s2.push_back(a);\r\n            }\r\n        }\r\n        return s2.back();\r\n    }\r\n    \r\n    bool empty() {\r\n        return s1.empty() && s2.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304793302","body":"用栈存放每一个分块的最大值，最后栈的数量即为分块的数量。\r\n当给出的数比最后一个块的最大值大，表示这个数可以自己当一个块；\r\n当给出的数比最后一个块的最大值小，表示这个数要融入它们；\r\n在上一条的基础上，如果这个数比倒数第二个块的最大值小，继续融合，直到遇到某个块的最大值比这个数小才停止。\r\n\r\n代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> st{};\r\n        for (auto & i: arr) {\r\n            if (st.empty() || i >= st.top()) {\r\n                st.emplace(i);\r\n            }else {\r\n                auto t = st.top();\r\n                st.pop();\r\n                while (!st.empty() && st.top() > i) {\r\n                    st.pop();\r\n                }\r\n                st.emplace(t);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n};\r\n```\r\n复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alyenor":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297965292","body":"```\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const reversed = num.reverse()\n    for(let i=0;i<reversed.length;i++){\n        const x = reversed[i]\n        k += x\n        reversed[i] = k % 10\n        k = (k/10) >> 0\n    }\n    while(k){\n        reversed.push(k%10)\n        k = (k/10) >> 0\n    }\n    return reversed.reverse()\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299502222","body":"function shortestToChar(s: string, c: string): number[] {\n    const n=s.length\n    let res=new Array(n).fill(Infinity)\n    for(let i=0,j=-1;i<n;i++){\n        if(s[i]===c) j=i\n        if(j !== -1) res[i] = i -j\n    }\n    for(let i=n-1,j=-1;i>=0;i--){\n        if(s[i] === c) j=i\n        if(j!=-1) res[i]=Math.min(res[i],j-i)\n    }\n    return res\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595767","body":"```\nclass CustomStack {\n  protected stack: number[] = []\n  protected max: number = Infinity\n\n  constructor(maxSize: number) {\n    this.max = maxSize\n  }\n\n  push(x: number): void {\n    if (this.stack.length === this.max) return\n    this.stack.push(x)\n  }\n\n  pop(): number {\n    if (this.stack.length === 0) return -1\n    return this.stack.pop()!\n  }\n\n  increment(k: number, val: number): void {\n    const n = this.stack.length\n    if (k > n) k = n\n    for (let i = 0; i < k; i++) {\n      this.stack[i] += val\n    }\n  }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302885382","body":"```\nfunction decodeString(s: string): string {\n  let res = ''\n  let count = 0\n  let stack: [string, number][] = []\n\n  const sArr = s.split('')\n  for (const c of sArr) {\n    if (c === '[') {\n      stack.push([res, count])\n      count = 0\n      res = ''\n    } else if (c === ']') {\n      const ans = stack.pop()!\n      const chars = ans[0]\n      const times = ans[1]\n      let temp = ''\n      for (let i = 0; i < times; i++) {\n        temp += res\n      }\n      res = chars + temp\n    } else if (c <= '9' && c >= '0') {\n      count = count * 10 + parseInt(c)\n    } else {\n      res += c\n    }\n  }\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304420330","body":"```\nclass MyQueue {\n    q: number[];\n  s: number[];\n  constructor() {\n    this.q = [];\n    this.s = [];\n  }\n\n  push(x: number): void {\n    this.q.push(x);\n  }\n\n  pop(): number {\n    while (this.q.length > 1) {\n      this.s.push(this.q.pop()!);\n    }\n    const res = this.q.pop();\n    while (this.s.length) {\n      this.q.push(this.s.pop()!);\n    }\n    return res!;\n  }\n\n  peek(): number {\n    return this.q[0];\n  }\n\n  empty(): boolean {\n    return this.q.length === 0;\n  }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304712804","body":"```\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack = []\n  for (const c of arr) {\n    let t = c\n    while (stack.length && stack[stack.length - 1] > c) {\n      t = Math.max(t, stack[stack.length - 1])\n      stack.pop()\n    }\n    stack.push(t)\n  }\n  return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304978809","body":"```\n/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\n\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    if(!head) return null\n    let h = head, length = 0\n    while(h){\n        length++\n        h=h.next\n    }\n    k = k % length\n    if(length === 1 || k===length || k === 0 ) return head \n    \n    let newH = head\n    let count = 0\n    while(count !== length - k){\n        newH=newH.next\n        count ++\n    }\n    let newTail = head\n    count = 0\n    while(count !== length-k-1){\n        newTail=newTail.next\n        count ++\n    }\n    if (newTail.next) newTail.next=null\n    \n    let h2 = newH\n    while(h2&&h2.next){\n        h2=h2.next\n    }\n    \n    h2.next=head\n    return newH\n    \n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297971841","body":"### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 解题思路\n模拟加法运算规则，从低位往高位每个数位依次运算。\\\n从数组中获取数位信息，直接`num[index]`\\\n从数字`k`中获得数位信息，每次进行`k % 10`\\\n运算时注意进位，每次将数位计算结果存入链表前端。\n\n### 代码（java）\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int carry = 0;\n        int n = num.length;\n        int index = n - 1; // record the index of array num that currently used in calculation\n        int dk = 0; // record the digit from k\n        int dn = 0; // record the digit from num\n\n        while (k > 0) {\n            dk = k % 10; // get the next digit from k\n            dn = 0;\n            if (index >= 0) {\n                dn = num[index--];\n            }\n            res.add(0, (carry + dk + dn) % 10); // insert the result digit to the front of the linked list\n            carry = (carry + dk + dn) / 10; // calculate carry digit\n            k /= 10; // move left to one digit\n        }\n        // when all the digits in k are used in calculation, while there are still digits in num that are not used\n        // continue to record the digits in num to res\n        while (index >= 0) {\n            res.add(0, (carry + num[index]) % 10);\n            carry = (carry + num[index]) / 10;\n            index--;\n        }\n        // if there is a carry not equal to 0, need to add one more digit for the carry\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为nums数组长度，字符串数组的长度为logk\n- 时间复杂度：O(max(n, logk)), 两个数组长度的最大值（最终循环次数）\n- 空间复杂度：O(max(n, logk)), 创建链表储存结果，链表长度为两个长度最大值","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299441621","body":"### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n### 解题思路\n字符串遍历问题\\\n遍历两次字符串：\\\n第一次正向遍历从左至右，计算每个字符和左边出现的特殊字符的最近距离；\\\n第二次反向遍历从右至左，计算每个字符和右边出现的特殊字符的最近距离，并把最短距离写入整数数组中。\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        Arrays.fill(res, n); // fill initial values, distance cannot be longer than n\n        // traverse from the left, calculate the distance between current letter and the nearest c on its left\n        int left = -1;\n        for (int i = 0; i < n; i++) {\n            char cur = s.charAt(i);\n            if (cur == c) {\n                res[i] = 0;\n                left = i;\n            } else {\n                if (left == -1) {\n                    continue;\n                } else {\n                    res[i] = i - left;\n                }\n            }\n        }\n        // traverse from the right, calculate the distance between current letter and the nearest c on its right\n        int right = n;\n        for (int j = n - 1; j >= 0; j--) {\n            char cur = s.charAt(j);\n            if (cur == c) {\n                res[j] = 0;\n                right = j;\n            } else {\n                if (right == n) {\n                    continue;\n                } else {\n                    res[j] = Math.min(res[j], right - j);\n                }\n            }\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n令n为字符串长度\n- 时间复杂度：O(n)，循环运行次数为2倍字符串长度\n- 空间复杂度：O(1)，没有额外开空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301694371","body":"### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n### 解题思路\n用数组来实现栈，设置变量`size`记录数组当前长度，用来快速判断栈是否已满，并且快速查找栈顶元素。\\\n用模拟实现`Increment`，更新数组中符合条件（下标在`0`到`min(k, size) - 1`)的所有元素\n\n### 代码（方法1）\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            return stack[--size];\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        // update the elements in the stack by incrementing val\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(k)\n- 空间复杂度：O(maxSize)\n\n### 代码（方法2）\n`Increment`操作时间复杂度高，可优化。没有必要在`Increment`操作中更新所有的元素。\\\n可以用另一个数组`inc`记录每次`Increment`操作时的增加值，增加值只记录到从栈底开始最后一个被增加的位置。因为出栈操作在栈顶，每次我们可以求出栈顶元素被增加的值，并且顺势更新出栈后下一个栈顶元素的增加值，这样时间复杂度就可以降到O(1)\n\n```java\nclass CustomStack {\n    int[] stack;  // record the elements in the stack\n    int[] inc;  // record the increment value\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        inc = new int[maxSize];\n        size = 0;\n    }\n\n    public void push(int x) {\n        if (size < stack.length) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) {\n            return -1;\n        } else {\n            size--;\n            int res = stack[size] + inc[size];\n            // calculate the increment value for the element on the top of the stack after pop\n            if (size > 0) {\n                inc[size - 1] += inc[size];\n            }\n            // reset the increment value, cannot put inside if condition\n            inc[size] = 0;\n            return res;\n        }\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, size);\n        if (k > 0) {\n            // record the increment value at the position k - 1, all the elements with index 0 to k - 1 were incremented\n            inc[k - 1] += val;\n        }\n    }\n}\n```\n\n### 复杂度分析\n- 时间复杂度：push和pop操作O(1)，increment操作O(1)\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303792321","body":"### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n### [官方题解](https://leetcode-cn.com/problems/decode-string/solution/zi-fu-chuan-jie-ma-by-leetcode-solution/)\n\n### 解题思路\n用栈来解决。重复的部分满足格式`k[encoded_string]`，先将除`]`外的字符入栈，遇到`]`说明重复的部分出现，先出栈字母，再出栈`[`，最后出栈数字。根据数字将重复部分重新入栈。最后出栈所有字符获得字符串即为结果。\n\n### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c: s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c); // push characters into stack if it is not ']'\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n\t\t\t\t// get the repeated characters\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                String sub = sb.toString();\n\t\t\t\t// pop '[' from stack\n                stack.pop();\n\n                sb = new StringBuilder();\n\t\t\t\t// get the repeated times\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    sb.insert(0, stack.pop());\n                }\n\n                int count = Integer.parseInt(sb.toString());\n\t\t\t\t// push the repeated characters back into stack\n                while (count > 0) {\n                    for (char element: sub.toCharArray()) {\n                        stack.push(element);\n                    }\n                    count--;\n                }\n            }\n        }\n\n        StringBuilder res = new StringBuilder();\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n令字符串长度为n\n- 时间复杂度：O(n)，需要遍历字符串\n- 空间复杂度：O(n)，创建栈储存字符","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304423074","body":"### 解题思路\n创建两个栈`in`和`out`分别储存input和output，`in`栈元素出栈然后入栈得到`out`栈，顺序相反，可以实现FIFO。当有元素入列时，push进`in`栈。当有元素出列时，先看`out`栈是否非空，如果为空将`in`栈中元素导入到`out`栈中，然后出列。\n\n### 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> in;\n    Stack<Integer> out;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if (out.isEmpty()) {\n            while(!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：push和empty为O(1)，pop和peek平均O(1)，最坏O(n)\n- 空间复杂度：O(n)，使用了两个栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304725202","body":"### 解题思路\n使用单调栈。令`currentMax`为对应排序块中最大元素，我们在栈中只存`currentMax`，则所存的`currentMax`单调递增。如果新元素小于前面块的`currentMax`，新元素需要和前面的块合并，我们需要更新栈中保留的`currentMax`。最后返回栈的长度即为最多块数。\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (!stack.isEmpty() && stack.peek() > arr[i]){\n                int currentMax = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                        stack.pop();\n                }\n                stack.push(currentMax);\n            }\n            else {\n                stack.push(arr[i]);\n            }    \n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n\n令n为数组长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305106769","body":"### 解题思路\n先将链表链接成环，之后再找到旋转之后的head，在head的前一个node和head之间断开\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        ListNode current = head;\n        ListNode previous = head;\n\n        if (head == null) return head;\n\n        int length = 1;\n\n        // find current tail and connect it to head\n        while (current.next != null) {\n            current = current.next;\n            length++;\n        }\n        current.next = head;\n\n        current = head;\n        // find the new head\n        for (int i = 0; i < length - k % length; i++) {\n            previous = current;\n            current = current.next;\n        }\n        // set the previous node as tail\n        previous.next = null;\n        return current;\n    }\n}\n```\n\n**复杂度分析**\n\n令n为链表长度\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297979089","body":"### 思路：\n从后往前遍历数组，与k的末位进行逐位相加，若和大于10，则进1(通过提前加到除以10的k上实现)，最后再将剩余的k加到答案上。\n\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> ans = new LinkedList<>(); // 每次在头部插入，用链表\n        int add = 0;\n        for (int i = num.length - 1; i >= 0; i--) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k += 1 ; // 完成了进1的操作\n                sum -= 10;\n            }\n            ans.addFirst(sum);\n        }\n        for (; k > 0; k /= 10) {\n            ans.addFirst(k % 10);\n        }\n        return ans;\n    }\n}\n```\n\n### 复杂度：\n- 时间复杂度：O(n)，遍历一遍数组\n- 空间复杂度：O(1)，除了答案的数组外没用额外空间","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301813145","body":"### 思路：\n用数组实现栈。top指示栈顶元素所在位置，初始值为-1。\n### 代码：\n```java\nclass CustomStack {\n    int max;\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        max = maxSize;\n        top = -1;\n        stack = new int[max];\n    }\n\n    public void push(int x) {\n        if (top < max - 1) {\n            stack[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top != -1) {\n            return stack[top--];\n        } else return -1;\n    }\n\n    public void increment(int k, int val) {\n        int increment = Math.min(k - 1, top);\n        for (int i = 0; i <= increment; i++) stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n### 复杂度：\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的时间复杂度为 O(1)，inc 操作的时间复杂度为 O(k)。\n- 空间复杂度：使用了一个辅助数组，O(maxSize）","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304388460","body":"### 思路：\n使用两个栈，一个进行入队操作，一个进行出队操作。\n### 代码：\n```java\nimport java.util.*;\n\nclass MyQueue {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stack1.addLast(x);\n    }\n\n    public int pop() {\n        if (stack2.size() != 0) return stack2.removeLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();\n        }\n        return -1;\n    }\n\n    public int peek() {\n        if (stack2.size() != 0) return stack2.getLast();\n        else if (stack1.size() != 0) {\n            return stack1.getFirst();\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return stack1.size() == 0 && stack2.size() == 0;\n    }\n}\n\n/*\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n### 复杂度：\n- 时间复杂度：push 和empty 为 O(1)，pop 和peek 为均摊O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304749708","body":"### 思路：\n右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量。\n### 代码：\n```java\nimport java.util.*;\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<>();\n        // 右边块的数字均大于或等于左边块的所有数字，如果新添加的数字小于原数组的最后一个块的最大值，则它必须融入最后一个块。\n        // 用单调增栈来存储每个排序块的最大值，这样栈的长度就是最终排序块的数量\n        for (int num : arr) {\n            if (!stack.isEmpty()&&num<stack.getLast()){\n            // 当前数小于栈顶数，说明会打乱前面已有的排序块\n                Integer head = stack.removeLast();\n                // 此时的出栈元素是新排序块的最大值，用head记录\n                while(!stack.isEmpty()&&num< stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n### 复杂度：\n- 时间复杂度：O(n)，其中 nn 是输入数组 arr 的长度。需要遍历一遍数组，入栈的操作最多为 n 次。\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dark-volute":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1297988060","body":"#### 思路\r\n以 [2,1,5], k = 806 为例。 末尾开始遍历 806 + 5 = 811， 811 % 10 = 1， 1 留在当前位， 将k 更新为 811 / 10 进入下一位，重复计算得到结果.\r\n#### code\r\n```js\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n    let res = []\r\n\r\n    for (let i = num.length -  1; i >= 0; i--) {\r\n        res.unshift((num[i] + k) % 10)\r\n\r\n        k = Math.floor((num[i] + k) / 10)\r\n    }\r\n\r\n    while (k > 0) {\r\n         res.unshift( k % 10)\r\n         k = Math.floor(k / 10)\r\n    }\r\n\r\n\r\n    return res\r\n};\r\n```\r\n#### 复杂度分析\r\n\r\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\r\n\r\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299768042","body":"#### 思路\n滑动窗口\n\n#### code\n```js\nvar shortestToChar = function(S, C) {\n    let l  = S[0] === C ? 0 : Infinity\n    let r = S.indexOf(C)\n    let res = []\n\n    for (let i = 0; i < S.length; i++) {\n        // 计算字符到当前窗口左右边界的最小距离\n        res[i] = Math.min(Math.abs(i - l), Math.abs(r - i))\n\n        // 遍历完了当前窗口后，将窗口右移\n        if (i === r) {\n            l = r\n            r = S.indexOf(C, l + 1)\n        }\n    }\n    return res\n};\n````\n\n#### 复杂度分析\n- 时间复杂度：O(n)，其中 n 为字符串长度。\n- 空间复杂度：O(n)，其中 n 为字符串长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301883798","body":"> ### 解题思路\r\n> 模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n> \r\n> ### 代码\r\n> \r\n> ```javascript\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>   this.stack = new Array();   // [empty, ...]\r\n>   this.maxSize = maxSize;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>   // 最大长度限制\r\n>   if(this.stack.length<this.maxSize){\r\n>     this.stack.push(x);\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>   // 栈顶为空的 =》 -1\r\n>   if(this.stack.length===0){\r\n>     return -1;\r\n>   }\r\n>   let val = this.stack.pop();\r\n>   return val;\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>   let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n>   for(let i=0;i<n;i++){\r\n>     this.stack[i] += val;\r\n>   }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n> \r\n> ### 复杂度\r\n> 时间: push/pop 都为O(1), increment需要O(k)\r\n> 空间: O(N) 一个栈的长度\r\n\r\n\r\n> @A-pricity\r\n> ```\r\n> /**\r\n>     利用数组来模拟栈\r\n>     注意：\r\n>         1.当栈元素个数等于 maxSize 时不允许继续入栈；\r\n>         2.当栈为空时，出栈操作返回 -1；\r\n>         3.当栈非空，出栈操作发返回栈顶值\r\n>         4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\r\n> \r\n>  */\r\n> /**\r\n>  * @param {number} maxSize\r\n>  */\r\n> var CustomStack = function(maxSize) {\r\n>     this.list = []\r\n>     this.maxSize = maxSize\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} x\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.push = function(x) {\r\n>     if(this.list.length < this.maxSize){\r\n>         this.list.push(x)\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * @return {number}\r\n>  */\r\n> CustomStack.prototype.pop = function() {\r\n>     const item = this.list.pop()\r\n>     return item === void 0 ? -1 : item\r\n> };\r\n> \r\n> /** \r\n>  * @param {number} k \r\n>  * @param {number} val\r\n>  * @return {void}\r\n>  */\r\n> CustomStack.prototype.increment = function(k, val) {\r\n>     for (let i = 0; i < k && i < this.list.length; i++) {\r\n>         this.list[i] += val\r\n>     }\r\n> };\r\n> \r\n> /**\r\n>  * Your CustomStack object will be instantiated and called as such:\r\n>  * var obj = new CustomStack(maxSize)\r\n>  * obj.push(x)\r\n>  * var param_2 = obj.pop()\r\n>  * obj.increment(k,val)\r\n>  */\r\n> ```\r\n\r\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304972654","body":"## 思路\n\n1. 获取单链表的倒数第N + 1 与倒数第N个节点\n2. 将倒数第N + 1个节点的next指向null\n3. 将链表尾节点的next指向head\n4. 返回倒数第N个节点\n\n```js\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    if(!head || !head.next) return head\n    let count = 0, now = head\n    while(now){\n        now = now.next\n        count++\n    }\n    k = k % count\n    let fast = head, slow = head;\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```\n\n## 复杂度分析\n\n时间复杂度：$O(N)$\n空间复杂度：$O(1)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronething":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298004206","body":"### 思路\n\n1、先转成数字再相加，遇到大数直接溢出了\n2、逐位相加\n\n### 代码\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int,0)\n    // 逐位相加\n    for i := len(num) - 1; i>=0; i--{\n        sum := num[i] + k % 10\n        k /= 10\n        if sum >= 10 {\n            k++ // 进位\n            sum -= 10 // 减掉 10\n        }\n        res = append(res, sum)\n    }\n    for k != 0 { // 如果有剩余的接着加\n        res = append(res, k % 10)\n        k /= 10\n    }\n\n    // reverse\n    for i:=0; i<len(res) /2; i++ {\n        res[i], res[len(res)-i-1] = res[len(res) - i -1], res[i]\n    }\n\n    return res\n}\n```\n\n### 复杂度分析\n\n- 时间复杂度: O(n)\n- 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1303783495","body":"### 思路\r\n\r\n遍历记录\r\n\r\n### 代码\r\n\r\n```go\r\n\r\nimport \"math\"\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tcslice := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\t// 记录 index\r\n\t\t\tcslice = append(cslice, i)\r\n\t\t}\r\n\t}\r\n\r\n\tvar getMin func(index int) int\r\n\tgetMin = func(index int) int {\r\n\t\tans := math.MaxInt64\r\n\t\tfor i := 0; i < len(cslice); i++ {\r\n\t\t\tans = getMinValue(getAbs(cslice[i], index), ans)\r\n\t\t}\r\n\r\n\t\treturn ans\r\n\t}\r\n\r\n\tres := make([]int, 0)\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tres = append(res, getMin(i))\r\n\t}\r\n\r\n\treturn res\r\n}\r\n\r\nfunc getMinValue(a, b int) int {\r\n\tif a > b {\r\n\t\treturn b\r\n\t}\r\n\treturn a\r\n}\r\n\r\nfunc getAbs(a, b int) int {\r\n\tif a-b > 0 {\r\n\t\treturn a - b\r\n\t}\r\n\treturn b - a\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302260513","body":"### 思路\n\n数组实现\n\n### 代码\n\n```go\n// 使用数组实现即可\n\ntype CustomStack struct {\n\tnums []int\n\tsize int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tnums: make([]int, 0),\n\t\tsize: maxSize,\n\t}\n}\n\nfunc (c *CustomStack) Push(x int) {\n\tif len(c.nums) >= c.size {\n\t\tlog.Println(\"size overflow\")\n\t\treturn\n\t}\n\n\tc.nums = append(c.nums, x)\n\treturn\n}\n\nfunc (c *CustomStack) Pop() int {\n\tif len(c.nums) <= 0 {\n\t\treturn -1\n\t}\n\tlength := len(c.nums)\n\tvalue := c.nums[length-1]\n\tc.nums = c.nums[:length-1]\n\treturn value\n}\n\nfunc (c *CustomStack) Increment(k int, val int) {\n\tif k > len(c.nums) {\n\t\tk = len(c.nums)\n\t}\n\tfor i := 0; i < k; i++ {\n\t\tc.nums[i] += val\n\t}\n\treturn\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n\n```\n\n\n### 复杂度分析\n\n- 时间复杂度：push: O(1), pop: O(1), inc: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303610428","body":"### 思路\r\n\r\n用栈实现\r\n\r\n### 代码\r\n\r\n```go\r\npackage issue9\r\n\r\nimport (\r\n\t\"strconv\"\r\n\t\"strings\"\r\n)\r\n\r\nfunc decodeString(s string) string {\r\n\tptr := 0\r\n\tvar stk []string\r\n\r\n\tvar getDigits func() string\r\n\tgetDigits = func() string {\r\n\t\t// 获取数字\r\n\t\tret := \"\"\r\n\t\tfor ; s[ptr] >= '0' && s[ptr] <= '9' && ptr < len(s); ptr++ {\r\n\t\t\tret += string(s[ptr])\r\n\t\t}\r\n\t\treturn ret\r\n\t}\r\n\r\n\tvar getString func(v []string) string\r\n\tgetString = func(v []string) string {\r\n\t\treturn strings.Join(v, \"\")\r\n\t}\r\n\r\n\tfor ptr < len(s) {\r\n\t\tcur := s[ptr]\r\n\t\tif cur >= '0' && cur <= '9' { // 获取数字\r\n\t\t\tdigits := getDigits()\r\n\t\t\tstk = append(stk, digits)\r\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n\t\t\tstk = append(stk, string(cur))\r\n\t\t\tptr++\r\n\t\t} else { // 右花括号\r\n\t\t\tvar sub []string\r\n\t\t\tfor stk[len(stk)-1] != \"[\" {\r\n\t\t\t\tsub = append(sub, stk[len(stk)-1])\r\n\t\t\t\tstk = stk[:len(stk)-1] // 出栈\r\n\t\t\t}\r\n\t\t\tstk = stk[:len(stk)-1] // 将 \"[\" pop 出栈\r\n\t\t\t// 逆序\r\n\t\t\tfor i := 0; i < len(sub)/2; i++ {\r\n\t\t\t\tsub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n\t\t\t}\r\n\t\t\trepTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n\t\t\tstk = stk[:len(stk)-1] // 将数字 pop 出栈\r\n\t\t\tt := strings.Repeat(getString(sub), repTime)\r\n\t\t\tstk = append(stk, t) // 重新入栈\r\n\t\t\tptr++\r\n\t\t}\r\n\t}\r\n\r\n\treturn getString(stk)\r\n}\r\n\r\n```\r\n\r\n### 复杂度分析\r\n\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmastella":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298039156","body":"思路\r\n1. 把array转成数字，然后加k，stackoverflow\r\n2. 从后往前加，用tenth表示进位。Edge case如果K的digit数比array大，剩下的要加入进去。Tenth又变成edgecase，如果K剩下的加进去还要在check一遍if tenth==1.\r\n3. 在变k的时候把进位加上去，即 k/10 + tenth\r\n\r\n代码\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result = new ArrayList<Integer>();\r\n        int tenth =0;\r\n        for(int i=num.length-1; i>=0; i--){\r\n            int curr = k%10 + num[i];\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n        while(k !=0){\r\n            int curr = k%10;\r\n            tenth =  curr/10;\r\n            k=k/10 + tenth;\r\n            result.add(0, curr %10);\r\n        }\r\n\r\n        return result; }\r\n```\r\n复杂度分析\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299363320","body":"思路\r\n1. 用一个list继续 index of c，然后用双指针。Time O(N), Space O(n)\r\n2. 左边遍历一边，右边便利一遍，取min\r\n3. 初试min只设置一个就好了，不用左右都设置，数字可以取10001，因为prompt说s.length最大是10^4\r\n\r\n代码\r\n```\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] answer = new int[s.length()];\r\n        int prev = 10001;\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            answer[i] = Math.abs(i- prev);\r\n            \r\n        }\r\n        prev = 10001;\r\n        //System.out.println(Arrays.toString(answer));\r\n        for(int i=s.length()-1; i>=0; i--){\r\n            if(s.charAt(i) == c){\r\n                prev = i;\r\n            }\r\n            //System.out.println(right);\r\n            answer[i] = Math.min(answer[i], Math.abs(i - prev));\r\n        }\r\n        return answer;\r\n    }\r\n```\r\n复杂度分析\r\n\r\n时间复杂度：O(N)， N  = 字符串的长度。\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302316149","body":"思路\r\n1. 最开始使用arraylist，后来发现array才是最简便的\r\n2. 用一个tail variable keep track stack size\r\n3. stack bottom是array的0，top是最后，别搞反了\r\n代码\r\n```\r\nclass CustomStack {\r\n    int tail;\r\n    int[] arr;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        tail =-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(tail >= arr.length-1){\r\n            return;\r\n        }\r\n        tail++;\r\n        arr[tail] = x;        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(tail<0){\r\n            return -1;\r\n        }\r\n        int val = arr[tail];\r\n        tail--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        //System.out.println(arr);\r\n        int threshold = Math.min(arr.length, k);\r\n\r\n        for(int i=0; i<threshold; i++){\r\n            arr[i]+=val;\r\n        }\r\n        //System.out.println(arr);\r\n    }\r\n}\r\n```\r\n复杂度分析\r\n时间：push 和pop是O(1)，inc是O(K)\r\n空间：O(N) N代表maxsize\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303000815","body":"思路\r\n1. 用了一种非常离谱非常麻烦的方法，一个栈记录数字，一个栈记录letter，遇到 \"]\"时pop出repeat string，再pop一个数字做repeat, 有很多edge case，比如如何check是数字，check两个栈的size\r\n2. java 好像对双引号or单引号很敏感，单引号的时候做character比较会有error\r\n代码\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        String str = \"\";\r\n        Stack<String> letter = new Stack<>();\r\n        Stack<Integer> nums = new Stack<>();\r\n        String num = \"\";\r\n        for(int i=0; i<s.length(); i++){\r\n            \r\n            \r\n            if(Character.isDigit(s.charAt(i))){\r\n                num= num + s.charAt(i);\r\n                System.out.println(\"[get num \" + num);\r\n            }else if(s.charAt(i) == '['){\r\n                if(num.length()>0){\r\n                    nums.push(Integer.parseInt(num));\r\n                    System.out.println(\"[[nums push \"+ Integer.parseInt(num));\r\n                    num = \"\";\r\n                }\r\n                \r\n                letter.push(\" \");\r\n            }else if(s.charAt(i) == ']'){\r\n                String sub = \"\";\r\n                while(letter.peek() != \" \"){\r\n                    sub = letter.pop() + sub;\r\n                }\r\n                letter.pop();\r\n                if(nums.size() >0){\r\n                    letter.push(sub.repeat(nums.pop()));\r\n                    System.out.println(\"repeat \"+ sub);\r\n                }else{\r\n                    letter.push(sub);\r\n                    System.out.println(\"purer push \"+ sub);\r\n                }\r\n                \r\n            }else{\r\n                letter.push(String.valueOf(s.charAt(i)));\r\n                System.out.println(\"final else\"+ s.charAt(i));\r\n            }\r\n        }\r\n        while(!letter.isEmpty()){\r\n            str=  letter.pop() + str;\r\n        }\r\n        return str;\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304422600","body":"思路\r\n1.用两个stack，一个是正常的stack用来加push的东西，一个是reverseStack，pop的顺序会和queue一样\r\n2.如果reverse stack里面有东西，优先peek or pop reverse stack里的东西。\r\n3.如果reverse stack里没有东西了，先把stack里面的element放进去，再peek or push\r\n\r\n代码\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> reverseStack;\r\n    public MyQueue() {\r\n        stack = new Stack<>();\r\n        reverseStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.pop();\r\n        }\r\n        while(stack.size() >1){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return stack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(!reverseStack.isEmpty()){\r\n            return reverseStack.peek();\r\n        }\r\n        while(!stack.isEmpty()){\r\n            reverseStack.push(stack.pop());\r\n        }\r\n        return reverseStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return reverseStack.isEmpty() && stack.isEmpty();\r\n    }\r\n}\r\n```\r\n复杂度\r\n时间： push O(1), pop和peek不确定，我感觉average也是O(1）？\r\n空间： O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831846","body":"思路\r\n1. sort array，如果他能单独分块，那么在这之前的element是和sorted一样\r\n\r\n代码\r\n```\r\n    public int maxChunksToSorted(int[] arr) {\r\n        // deep copy\r\n        int[] sorted = arr.clone();\r\n        Arrays.sort(sorted);\r\n        Map<Integer, Integer> map = new HashMap<>();\r\n        int result = 0;\r\n        int nonZero =0;\r\n        for(int i=0; i<arr.length; i++){\r\n            int x = arr[i];\r\n            int y = sorted[i];\r\n            \r\n            map.put(x, map.getOrDefault(x,0)+1);\r\n            if(map.get(x) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(x)==1){\r\n                nonZero++;\r\n            }\r\n            map.put(y, map.getOrDefault(y,0)-1);\r\n            if(map.get(y) ==0){\r\n                nonZero--;\r\n            }\r\n            if(map.get(y)==-1){\r\n                nonZero++;\r\n            }\r\n            \r\n            if(nonZero ==0){\r\n                result++;\r\n            }\r\n            \r\n        }\r\n        return result;\r\n    }\r\n```\r\n复杂度分析\r\nO（N）\r\nO（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"paopaohua":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298054211","body":"# 思路\n从后往前逐个相加\n# 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for(int i = n - 1;i >= 0;i--){\n            int a = num[i] + k % 10; // 得到k的个位\n            k /= 10; //去掉k的个位\n            if(a >= 10){\n                k++; // k的十位  + 1\n                a -= 10; // 进位之后a得-10\n            }\n            res.add(a);\n        }\n        for(;k > 0;k /= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300463292","body":"# 思路\n数组的两次遍历，s[i]到c左右两侧的最近距离 左-右\n# 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] arr = new int[n];\n        int index = -n;   // 给一个较大的值，用于辅助标记 c 的位置\n        for(int i = 0 ; i < n;i++){\n            if(s.charAt(i) == c) // s当前下标的数字== c\n                index = i;\n            arr[i] = Math.abs(i - index); // 数组中存的为 相对与index（-n）的位置\n        }\n        for(int i = n - 1; i >= 0;i--){\n            if(s.charAt(i) == c)\n                index = i;\n            arr[i] = Math.min(arr[i], Math.abs(i - index)); // 矫正位置信息\n        }\n        return arr;\n    }\n}\n```\n# 复杂度\n- 时间：o(n)  遍历字符串s\n- 空间：o(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302017173","body":"# 思路\n  让栈中元素可见：设置栈顶top\n# 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            stack[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        return stack[top--];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303750267","body":"# 思路\n字符串 + 栈\n# 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        // 遍历字符串（转char字符串）\n        for(char c : s.toCharArray()){\n            if(c != ']'){ // 没到最后就一直向栈中压\n                stack.push(c);\n            }else{\n                // 数组中的数已经全部进栈，取出字符串\n                StringBuilder sb = new  StringBuilder();\n                // 看栈中是不是字母\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0,stack.pop());\n                \n                String s1 = sb.toString();\n                stack.pop(); // 此时栈中就剩下一个‘[’,弹出\n\n                // 获取倍数\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                     sb.insert(0,stack.pop());\n                }\n                   \n\n               int count = Integer.valueOf(sb.toString());  // 倍数\n\n                // 将倍数 x 字符\n                while(count  > 0 ){\n                    for(char c1 : s1.toCharArray()){\n                        stack.push(c1);\n                    }\n                    count--;\n                    }\n                }\n        }\n        // 将栈中数据取出\n        StringBuilder res = new StringBuilder();\n        while(!stack.isEmpty())\n            res.insert(0,stack.pop());\n        return res.toString();\n    }\n}\n    \n```\n# 复杂度\n- 时间 o(n)\n- 空间 o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304561267","body":"#### 思路\n> 理解栈先进后出的特性\n#### 代码\n```java\nclass MyQueue {\n\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn = new Stack<>(); // 负责进栈\n        stackOut = new Stack<>(); // 负责出栈\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {    \n        dumpstackIn();\n        return stackOut.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        dumpstackIn();\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n\n    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中\n    private void dumpstackIn(){\n        if (!stackOut.isEmpty()) return; \n        while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n        }\n    }\n}\n\n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304825468","body":"#### 思路\n> 单调栈\n#### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr){\n            if(!stack.isEmpty() && num < stack.getLast()){\n                int cur = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()){\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            }else{\n                stack.addLast(num);\n            }\n        }\n        return stack.size();\n    }\n}  \n```\n#### 复杂度\n- 时间：o(n)\n- 空间：o(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dd2001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298075373","body":"> # 思路\n> 从后往前逐位将数字加在一起,若加法的结果大于等于 10，把进位的 1 加入到下一位的计算中.\n> # 代码\n> ```c++\n>class Solution {\n>public:\n>    vector<int> addToArrayForm(vector<int>& num, int k) {\n>       vector<int> res;\n>\n>      int n = num.size();\n>       for (int i = n - 1; i >= 0; --i) {\n>            int sum = num[i] + k % 10;\n>            k /= 10;\n>           if (sum >= 10) {\n>                k++;\n>               sum -= 10;\n>            }\n>           res.push_back(sum);\n>        }\n>        for (; k > 0; k /= 10) {\n>            res.push_back(k % 10);\n>       }\n>       reverse(res.begin(), res.end());\n>       return res;\n>      }\n>   }\n\n> ```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299513514","body":"\n> \n> ## 思路\n> 1、从当前下标出发，分别向左、右两个方向去寻找目标字符c  \n> 2、只在一个方向找到的话，直接计算字符距离  \n> 3、两个方向都找到的话，取两个距离的最小值  \n> \n> ## 代码\n> ```c++\n> \n>class Solution {  \n>public:    \n>    vector<int> shortestToChar(string S, char C) {  \n>        vector<int> res(S.length());  \n>\n>        for (int i = 0; i < S.length(); i++) {  \n>            if (S[i] == C) continue;  \n>\n>            int left = i;  \n>           int right = i;  \n>            int dist = 0;  \n>\n>            while (left >= 0 || right <= S.length() - 1) {  \n>                if (S[left] == C) {   \n>                  dist = i - left;    \n>                    break;  \n>                }  \n>                if (S[right] == C) {  \n>                    dist = right - i;  \n>                   break;  \n>                }  \n>\n>              if (left > 0) left--;  \n>                if (right < S.length() - 1) right++;  \n>            }  \n>\n>            res[i] = dist;  \n>        }  \n>\n>        return res;  \n>    }  \n>};  \n> \n> ```\n> \n> ## 复杂度分析\n> n*n，n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301691388","body":"> ### 思路\n> 用 vector 模拟栈，使用一个数组去保存数字  \n> push和pop都要注意为空的边缘情况，并且k大小可能超过size  \n> ### 代码 (cpp)\n>```cpp  \n>class CustomStack {  \n>public:  \n>    int max;  \n>    vector<int>stack;  \n>    CustomStack(int maxSize) {  \n>       max=maxSize;  \n>    }  \n>    \n>    void push(int x) {  \n>        if(stack.size()<max){  \n>            stack.push_back(x);  \n >           return ;  \n>        }\n>    }\n>    \n >   int pop() {  \n>        if(stack.empty()){  \n>            return -1;  \n>        }  \n>        int val=stack.back();  \n>        stack.pop_back();  \n>        return val;  \n>    }\n>    \n>    void increment(int k, int val) {  \n>        for(int i=0;i<k&&i<stack.size();i++){  \n>            stack[i]+=val;  \n>        }  \n>        return ;  \n>    }  \n>  };     \n>```  \n> **复杂度分析**  \n> - 时间复杂度：O(N)  \n> - 空间复杂度：O(N)  \n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303528403","body":"> ### 思路\n> \n>  利用一个数字栈与一个符号栈来处理，首先遍历整个字符串，如果当前的字符为数字，字母或者左括号，直接进栈，如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，取出栈顶的数字，根据字符串构造出新的字符串并进栈\n> ### 代码\n> \n> ```c++\n> class Solution {  \n>public:  \n>    string decodeString(string s) {     \n>        stack<int> st_num;   //数字栈  \n>        string symbol;    \n>        int num=0;   \n>        for(int i=0;i<s.size();i++)\n>        {\n>            if(s[i]>='0'&&s[i]<='9'){   \n>                num=s[i]-'0'+num*10;  \n>            }else if(s[i]=='['){      \n>                st_num.push(num);  \n >               num=0;  \n>                symbol+=s[i];  \n>            }else if(s[i]==']'){     \n>               int j=symbol.size()-1;  \n>                string tmp_string;  \n>                while(symbol[j]!='[')  \n>                {  \n>                    tmp_string+=symbol[j];  \n >                   symbol.pop_back();  \n>                    j--;  \n>                }  \n >               symbol.pop_back();  \n>                int tmp_num=st_num.top();  \n>                st_num.pop();  \n>                reverse(tmp_string.begin(),tmp_string.end());  \n>                for(int k=0;k<tmp_num;k++)  \n>                {  \n>                    symbol+=tmp_string;  \n>                }  \n>            }else{   \n>                symbol+=s[i];  \n>            }  \n>        }  \n>        return symbol;  \n>    }  \n> };   \n> ```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304518091","body":"> # 思路\n> \n> 将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek 操作。\n> \n> # 代码\n> ```C++\n>class MyQueue {  \n>public:  \n>    stack<int>stIn;  \n>    stack<int>stOut;  \n>    MyQueue() {  \n>\n>    }  \n>    \n>    void push(int x) {  \n>        stIn.push(x);  \n>    }  \n>    \n>    int pop() {  \n>      if(stOut.empty()){  \n>            while(!stIn.empty()){  \n>                stOut.push(stIn.top());  \n>               stIn.pop();  \n>            }  \n>        }  \n>        int result = stOut.top();  \n>        stOut.pop();  \n>        return result;  \n>    }  \n>    \n>    int peek() {  \n>        int res=this->pop();  \n>        stOut.push(res);  \n>        return res;  \n>\n>    }  \n>    \n>    bool empty() {  \n>       return  stOut.empty()&&stIn.empty();  \n>\n>    }  \n>};  \n> ```\n> # 复杂度分析\n> \n>- 时间复杂度：O(1)  \n>- 空间复杂度：O(n)   \n \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304734667","body":"> ### 思路\n> 使用单调栈。我们可以用一个栈来存储这些分块的最大值。最后得到的栈的大小，也就是最多能完成排序的块。\n> \n> ### 代码\n> \n> ```c++  \n>class Solution {  \n>public:  \n>    int maxChunksToSorted(vector<int>& arr) {  \n>        stack<int> stk;  \n>        for (int& v : arr) {  \n>            if (stk.empty() || stk.top() <= v)  \n>                stk.push(v);  \n>            else {  \n>                int mx = stk.top();  \n>              stk.pop();  \n>                while (!stk.empty() && stk.top() > v) stk.pop();  \n>                stk.push(mx);  \n>            }  \n>        }  \n>        return stk.size();  \n>    } \n> };   \n> ```\n> \n> **复杂度分析**\n> \n> - 时间复杂度：O(n)\n> - 空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayloveless":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298076219","body":"思路\r\n1.  num转成数字，与k相加，再转成数组，空间复杂度O（n），时间复杂度O（n）\r\n2.  k每次取最后一位数字，直接与num数组从后向前相加，注意进位，空间负责度减小到O（n）\r\n\r\n代码\r\n```javascript```\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let kleft = k;\r\n    let i = num.length-1;\r\n    while(kleft || i>=0) {\r\n        const lastNum = kleft%10;\r\n        if (i<0) {\r\n        // k位数较多，依次取出，加到数组头部\r\n            num.unshift(lastNum);\r\n            kleft = Math.floor(kleft/10);\r\n            continue;\r\n        }\r\n        // 数组位数更多时\r\n        num[i] += lastNum;\r\n        if (num[i] >= 10 ){         // 进位\r\n            num[i] = num[i]%10;\r\n            const up = 1;\r\n        //  数组位置不够\r\n            if (i == 0) {\r\n                num.unshift(up);\r\n                i++;// 长度变长了\r\n            } else {\r\n                num[i-1] += up;\r\n            }\r\n        }\r\n        kleft = Math.floor(kleft/10);\r\n        i--;\r\n    }\r\n    return num;\r\n};\r\n```\r\n\r\n复杂度：K的次数为常数级别\r\nTime: O（n）\r\nSpace:  O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300395771","body":"思路\r\n1.  暴力解法，遍历s每个字符，每次遍历，再遍历一次最近的c\r\n2. 用空间换时间，左右各遍历一次s，从左遍历时，当前存储左边最近一个c的index，右边同理。最后比较左右哪个小。\r\n\r\n\r\n代码\r\n\r\n```JavaScript\r\nvar shortestToChar = function(s, c) {\r\n    let leftIdex = -1;\r\n    const leftArr = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        if (s[i] === c) {\r\n            leftIdex = i;\r\n        } \r\n        leftArr[i] = leftIdex;\r\n    }\r\n    const rightArr = [];\r\n    let rightIndex = -1;\r\n    for(let i=s.length-1;i>=0;i--) {\r\n        if (s[i] === c) {\r\n            rightIndex = i;\r\n        } \r\n        rightArr[i] = rightIndex;\r\n    }\r\n    const res = [];\r\n    for(let i=0;i< s.length;i++) {\r\n        const left = Math.abs(leftArr[i] - i);\r\n        const right = Math.abs(rightArr[i] - i);\r\n        if (leftArr[i] === -1) {\r\n            res[i] = right;\r\n        } else if (rightArr[i] === -1) {\r\n            res[i] = left;\r\n        } else {\r\n            res[i] =  Math.min(left, right);\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n复杂度分析：三次存储是常数级别，省略\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n\r\np.s. 应该可以优化成只存一次，不用三次，第二次遍历的时候直接相加。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302054753","body":"### 思路\r\n1. 用数组模拟栈\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.total = 0;\r\n    this.maxSize = maxSize;\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length === this.maxSize) return this.stack;\r\n    return this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.pop() || -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(var i = 0; i<k; i++ ){\r\n        if(this.stack[i]) this.stack[i] += val;\r\n    }\r\n    return this.stack;\r\n};\r\n\r\n\r\n ```\r\n### 复杂度： \r\n时间复杂度：\r\npush：O(1)\r\npop：O(1)\r\nincrement：O(k)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303709487","body":"### 思路\r\n把字符压到栈里，遇到 ] 出栈到 [  组成字符，继续出栈到非数字，组成数字，拼接字符串，当作一个完整字符，压栈，继续遍历\r\n### 代码\r\n```javascript\r\nvar decodeString = function(s) {\r\n  const stack = [];\r\n  \r\n  for (let i = 0; i < s.length; i++) {\r\n    if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n        continue;\r\n    }\r\n    let temStr = '';\r\n    while (stack[stack.length - 1] !== '[') {\r\n         temStr = stack.pop() + temStr;\r\n    }\r\n\r\n    stack.pop();\r\n\r\n    let numStr = '';\r\n    while (stack.length && isNumber(stack[stack.length - 1])) {\r\n        numStr =  stack.pop() + numStr;\r\n    }\r\n    const res = temStr.repeat(Number(numStr));\r\n    stack.push(res);\r\n  }\r\n  return stack.join('')\r\n};\r\n\r\nconst isNumber = (chr) => {\r\n  const num = Number(chr);\r\n  return num >=0 && num <=9;\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(n),\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304564384","body":"### 思路\r\n1. 入队的时候，push到数字开头（用两个栈来回装元素），反过来的队列，这样pop和peek可以直接用出栈操作\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    const tempStack = [];\r\n    while(this.stack.length) {\r\n        tempStack.push(this.stack.pop());\r\n    }\r\n    tempStack.push(x);\r\n    while(tempStack.length) {\r\n        this.stack.push(tempStack.pop());\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.stack.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack[this.stack.length-1]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度\r\n时间 push O(N), pop/peak/empty O(1)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304732911","body":"### 思路\r\n因为需要按块生序，所以用单调栈。单调栈存块最大值，比最大值小，则变成一个块。\r\n块最多是每个值一个块。\r\n\r\n### 代码\r\n```javascript\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack = [arr[0]];\r\n    for(let i = 1;i < arr.length;i++) {\r\n        if (arr[i] - stack[stack.length-1] >= 0) {\r\n            stack.push(arr[i]);\r\n        }\r\n\r\n        const max = stack.pop();\r\n        while(stack.length && stack[stack.length-1] > arr[i]) {\r\n            stack.pop()\r\n        }\r\n        stack.push(max);\r\n    }\r\n\r\n    return stack.length;\r\n\r\n};\r\n```\r\n### 复杂度\r\n时间O(n)\r\n空间O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuexi001":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298085446","body":"## 思路\n\n- 将k对应位数加到num上，并对大于10的位数继续进位\n- 出现num.length<k.length情况，对num进行扩充相加，直到k=0\n\n## 代码\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        int flag = 0;\n        for(int i = 0; i < num.size() ; i++){\n            num[i] += (k % 10);\n            k /= 10;\n            if(num[i] >= 10){\n                num[i] -= 10;\n                if(i != (num.size()-1)){\n                    num[i+1]++;\n                }else{\n                    flag = 1;\n                    num.push_back(1);\n                    break;\n                }\n            }\n        }\n\n        while(k){\n            if(flag){\n                flag = 0;\n                num[num.size()-1] += (k % 10);\n                if(num[num.size()-1] >= 10){\n                    num[num.size()-1] -= 10;\n                    flag = 1;\n                    num.push_back(1);\n                }\n            }else{\n                num.push_back(k % 10);\n            }\n            k /= 10;\n        } \n        \n        reverse(num.begin(), num.end());\n        \n        return num;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299515911","body":"## 思路\n\n-  找出string中c出现的索引，存入book\n-  遍历s和book，计算所有可能的距离，将最小距离存入answer\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> answer(s.size(), 0), book;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] == c)\n                book.push_back(i);\n        }\n        for(int i = 0; i < s.size(); i++){\n            int min = 10000;\n            for(int j = 0; j < book.size(); j++){\n                int dis = abs(i - book[j]);\n                if(min > dis)\n                    min = dis;\n            }\n            answer[i] = min;\n        }\n        return answer;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301911303","body":"## 思路\n\n将栈看作数组，对数组进行增加、删除、遍历\n\n## 代码\n\nC++ Code:\n\n```c++\nclass CustomStack {\nprivate:\n    int maxSize;\n    vector<int>st;\n\npublic:\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;        \n    }\n    \n    void push(int x) {\n        if(st.size() < maxSize)\n            st.push_back(x);\n    }\n    \n    int pop() {\n        if(!st.empty()){\n            int tp = st[st.size()-1];\n            st.pop_back();\n            return tp;\n        }else\n            return -1;\n    }\n    \n    void increment(int k, int val) {\n        if (st.size() < k){\n            for(vector<int>::iterator it = st.begin(); it != st.end(); it++)\n                (*it) += val; \n        }else{\n            for(vector<int>::iterator it = st.begin(); it < (st.begin() + k); it++)\n                (*it) += val; \n        }\n    }\n};\n\n```\n\n**复杂度分析**\n\n- 时间复杂度：$O(k)$\n- 空间复杂度：$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303248570","body":"## 思路\n\n1. 使用栈st存储pair( ]前字母，]前数字 )\n2. 遍历s，如果是字母，存入nowStr；如果是数字，存入nowNum；如果是'['，将(nowStr, nowNum)入栈，并清空nowStr和nowNum；如果是']'，说明已经找到一个完整的子串可以用来表示总长度，此时nowStr存储的是[]里字符串，此时栈顶元素出栈，atoi(st.back().second.c_str())是nowStr出现次数，st.back().first是这个出现多次的字符串前的字符串，将展开后的子串存入nowStr即为当前已经展开一次的串。\n3. 遍历结束，返回结果nowStr\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        vector<pair<string, string>>st;\n        string nowStr, nowNum;\n        for(int i = 0; i < s.size(); i++){\n            if(s[i] >= 'a' && s[i] <= 'z'){\n                nowStr += s[i];\n            }else if(s[i] >= '0' && s[i] <= '9'){\n                nowNum += s[i];\n            }else if(s[i] == '['){\n                st.push_back(make_pair(nowStr, nowNum));\n                nowStr.clear();\n                nowNum.clear();\n            }else{\n                string tmp;\n                for(int j = 0; j < atoi(st.back().second.c_str()); j++)\n                    tmp += nowStr;\n                nowStr =  st.back().first + tmp;\n                st.pop_back();     \n            }\n        }\n        return nowStr;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304448576","body":"**思路**\n\n用两个栈st1, st2记录，st1记录队列push后正序，st2记录pop和peek时队列逆序用来找到队列首部元素，每次pop和peek后要将st1恢复到当前队列情况，st2清空\n\n**代码**\n\nC++ Code:\n\n```c++\nclass MyQueue {\nprivate:\n    stack<int> st1, st2; //st1正序 st2逆序\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {        \n        st1.push(x);       \n    }\n    \n    int pop() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        st2.pop();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    int peek() {\n        while(!st1.empty()){\n            st2.push(st1.top());\n            st1.pop();\n        }\n        int top = st2.top();\n        while(!st2.empty()){\n            st1.push(st2.top());\n            st2.pop();\n        }        \n        return top;\n    }\n    \n    bool empty() {\n        if(st1.empty())\n            return true;\n        return false;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为栈长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304782127","body":"## 思路\n\n1. 排序前每个子块和排序后中对应位置的子块中数的出现次数是一样的，用哈希表diff来记录排序前后对应子块出现频次的差值\n2. 遍历数组，当差值为0时，说明该数字在这个子块中出现频率相同，从哈希表中删除这个key，直到diff为空时，说明两个子块出现的数字是一样的，可以分块，res++\n3. 遍历结束，返回res\n\n## 代码\n\nC++ Code:\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int res;\n        unordered_map<int, int>diff;\n        vector<int>arr_sort = arr;\n        sort(arr_sort.begin(), arr_sort.end());\n        for(int i = 0; i < arr_sort.size(); i++){\n            int x = arr[i], y = arr_sort[i];\n            diff[x]++;\n            if(diff[x] == 0)\n                diff.erase(x);\n            diff[y]--;\n            if(diff[y] == 0)\n                diff.erase(y);\n            if(diff.empty())\n                res++;           \n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(nlogn)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nineis7":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298094032","body":"# Leetcode 989\r\n\r\n## 思路\r\n- 数组和k从LSB开始计算，直到其中数组和k有一个到头；计算携带carry进位，当计算超过10时取余，carry取1传给下次计算；\r\n- 计算出来的值通过vec的insert函数进行头插；\r\n- 当有一个到头时，对另一个数据继续进行上述处理，直到它也到头；\r\n- 单独处理最后到头的情况。\r\n\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res_vec;\r\n        int length = num.size();\r\n        int i(1);\r\n        int carry = 0;\r\n        //第一步，计算\r\n        while((k/10 || k%10) && i<=length){\r\n            int tmp = num[length-i] + k%10 + carry;\r\n            if(tmp/10) {tmp %= 10; carry = 1;}\r\n            else carry = 0;\r\n            \r\n            res_vec.insert(res_vec.begin(), tmp);\r\n            \r\n            ++i;\r\n            k /= 10;\r\n        }\r\n        \r\n        //第二步；对剩余元素处理\r\n        if(i<=length)\r\n            while(i<=length){\r\n                int tmp = num[length-i] + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                ++i;\r\n            }\r\n        else if(k/10 || k%10)\r\n            while(k/10 || k%10){\r\n                int tmp = k%10 + carry;\r\n                if(tmp/10) {tmp %= 10; carry = 1;}\r\n                else carry = 0;\r\n                \r\n                res_vec.insert(res_vec.begin(), tmp);\r\n                \r\n                k /= 10;\r\n            }\r\n        \r\n        \r\n        if(carry)\r\n            res_vec.insert(res_vec.begin(), 1);\r\n        \r\n        return res_vec;\r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299482657","body":"# Leetcode 821\r\n\r\n## 思路\r\n基于多中心点的病毒扩散模型：将给定字符所在位置作为中心点，以此扩散边界元素，保留最小值，遇到另一个中心立刻停止扩散。也即一维的图遍历过程。\r\n\r\n## 代码\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res_vec(s.length(),10000);\r\n        vector<int> vec_slf;\r\n        //记录该字符的位置\r\n        for(int i(0); i < s.length(); ++i){\r\n            if(s[i] == c) res_vec[i] = 0;\r\n            vec_slf.insert(vec_slf.end(), i);\r\n        }\r\n        \r\n        for(auto slf: vec_slf){\r\n            int i(slf-1);\r\n            while(i >= 0) {\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i+1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                i--;\r\n            }\r\n            i = slf+1;\r\n            while(i < res_vec.size()){\r\n                if(res_vec[i] == 0) break;\r\n                \r\n                int tmp = res_vec[i-1] + 1;\r\n                if(res_vec[i] > tmp) res_vec[i] = tmp;\r\n                else break;\r\n                \r\n                ++i;\r\n            }\r\n        }\r\n        \r\n        return res_vec;            \r\n    }\r\n};\r\n\r\n```\r\n\r\n## 复杂度分析\r\nn，n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301651250","body":"# 1381\r\n\r\n## 思路\r\n偷懒用vector实现，用arr配合index指示栈顶也可以做\r\n\r\n## 代码\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        _maxSize = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(_vec_stk.size() < _maxSize)\r\n            _vec_stk.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(!_vec_stk.size()) return -1;\r\n        else {\r\n            int tmp = _vec_stk[_vec_stk.size() -1];\r\n            _vec_stk.pop_back();\r\n            return tmp;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if(_vec_stk.size()){\r\n            int i(0);\r\n            for(auto &n: _vec_stk){\r\n                n += val;\r\n                i++;\r\n                if(i == k) break;\r\n            }\r\n        }\r\n    }\r\nprivate:\r\n    vector<int> _vec_stk;\r\n    int _maxSize;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303164435","body":"# 394 \r\n暂时没做出来，C++的string用得不是很习惯\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res_str;\r\n        string tmp_str;\r\n        stack <int> stk;\r\n        int i(0);\r\n        int n(0);\r\n        //int k(0), count(0);\r\n        while(i < s.length()){\r\n            if((s[i]-'0' >= 0) && (s[i]-'0' <= 9)) stk.push(s[i++]);\r\n            else if(s[i] == '[') {\r\n                stk.push(s[i++]);\r\n                n++;\r\n            }\r\n            else if(s[i] == ']') {\r\n                string tmp;\r\n                while(stk.top() != '['){\r\n                    //tmp \r\n                    string tmp3;\r\n                    tmp3 += stk.top();\r\n                    tmp.insert(0, tmp3);\r\n                    stk.pop();\r\n                }\r\n                tmp_str.insert(0, tmp);\r\n                //cout << tmp_str << endl;\r\n                stk.pop();\r\n                n--;\r\n                int k(0), count(0);\r\n                while(!stk.empty() && (stk.top()-'0' >= 0) && (stk.top()-'0' <= 9)){\r\n                    int tmpn = stk.top() -'0';\r\n                    k += tmpn*pow(10,count++);\r\n                    stk.pop();\r\n                }\r\n                string tmp2(tmp_str);\r\n                k--;\r\n                while(k){\r\n                    tmp_str += tmp2;\r\n                    k--;\r\n                }\r\n                if(!n) {\r\n                    res_str.append(tmp_str);\r\n                    tmp_str.clear();\r\n                }\r\n\r\n                ++i;\r\n            }\r\n            else {\r\n                if (stk.empty()) res_str += s[i++];\r\n                else stk.push(s[i++]);\r\n            }\r\n\r\n        }\r\n\r\n        return res_str;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298123259","body":"### 思路\n\n1. num list化成int\n2. 加上k\n3. 转为list\n\n### 代码\n\n```Python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # if num == [0] and k == 0: return [0] \n        # x = 0\n        # out = []\n        # for i in num:\n        #     x = x*10 + i \n        # x += k\n        # while x > 0:\n        #     out.append(x % 10)\n        #     x //= 10\n        # return out[::-1]\n        return [int(a) for a in str(int(''.join(map(str,num)))+k)]\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299628742","body":"### 思路\n\n1. 从左遍历记录与最近 c的距离\n2. 从右遍历，顺便用min取最短距离\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size(), pos = -n;\n        vector<int> res(n,n);\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; i--) {\n            if (s[i] == c) pos = i;\n            res[i] = min(res[i], pos - i);\n        }\n        return res;\n    }\n};\n```\n\n### 复杂度\n\nO(n) / O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302324672","body":"### 思路 \n\n...\n\n### 代码\n\n```C++\nclass CustomStack {\n    vector<int> stack;\n    int n;\npublic:\n    CustomStack(int maxSize) {\n        n = maxSize;\n    }\n    \n    void push(int x) {\n        if (stack.size() == n) return;\n        if (stack.size() < n) stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int x=stack.back();\n        stack.pop_back();\n        return x;\n    }\n    \n    void increment(int k, int val) {\n        int x=k;\n        if(stack.size()<k)\n            x=stack.size();\n        for(int i=0;i<x;i++) {\n            stack[i]+=val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303028763","body":"### 思路 \n\n用stack存储，四个cases\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        current_string = \"\"\n        k = 0\n\n        for char in s:\n            if char == \"[\":\n                # Just finished parsing this k, save current string and k for when we pop\n                stack.append((current_string, k))\n                # Reset current_string and k for this new frame\n                current_string = \"\"\n                k = 0\n            elif char == \"]\":\n                # We have completed this frame, get the last current_string and k from when the frame \n                # opened, which is the k we need to duplicate the current current_string by\n                last_string, last_k = stack.pop(-1)\n                current_string = last_string + last_k * current_string\n            elif char.isdigit():\n                k = k * 10 + int(char)\n            else:\n                current_string += char\n\n        return current_string\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304419378","body":"### 思路 \n\npop encoding\n\n### 代码\n\n```c++\nclass MyQueue {\n    public:\n        stack<int> s1, s2;\n        MyQueue() {        }\n\n        void push(int x) {\n            s1.push(x);\n//             // Move all elements from s1 to s2\n//             while (!s1.empty()) {\n//                 s2.push(s1.top());\n//                 s1.pop();       \n//             }           \n\n//             // Push the item to s1\n//             s1.push(x); \n\n//             // Push all elements in s2 back to s1\n//             while (!s2.empty()){\n//                 s1.push(s2.top());\n//                 s2.pop();       \n//             } \n        }\n\n        int pop() {\n            if (s1.empty() && s2.empty()) {\n                cout << \"empty queue\" << endl;\n                exit(0);                                                                  }\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();           \n                }                       \n            }\n            int temp = s2.top();\n            s2.pop();\n            return temp;\n            // // pop out the top element in s1\n            // if (s1.empty()) {\n            //     cout << \"error\" << endl;\n            //     exit(0);        \n            // }           \n            // int temp = s1.top();\n            // s1.pop();\n            // return temp;\n        }\n\n        int peek() {\n            if (s2.empty()) {\n                while (!s1.empty()) {\n                    s2.push(s1.top());\n                    s1.pop();\n                }\n            }\n            return s2.top();\n            // if (s1.empty()) {\n            //     cout << \"empty queue\" << endl;\n            //     exit(0);        \n            // }           \n            // return s1.top();\n        }\n\n        bool empty() {\n            return s1.empty() && s2.empty();\n            // return s1.empty();\n        }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304727109","body":"### 思路 \n\nusing stack to store the max item for potential blocks, return the length of the stack in the end\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n        for i,a in enumerate(arr):\n            maxi = a\n            while s and s[-1] > a:\n                maxi = max(maxi,s.pop())\n            s.append(maxi)\n        return len(s)\n```\n\n### 复杂度\n\nO(n) / O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305134751","body":"### 思路 \n\nCheck length -> the the # of rotation -> make as a loop -> traverse -> disconnect \n\n### 代码\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return None\n      \n      #check the length\n        lastNode, length = head, 1\n        while lastNode.next:\n            lastNode = lastNode.next\n            length += 1\n\n        # check the number of rotation\n        k = k % length\n\n      # setlast node point to the first node\n        lastNode.next = head\n\n      #traverse until (length - k) node\n        temp = head\n        for i in range(length - k - 1): temp = temp.next\n\n      #disconnect the first and last node\n        out = temp.next\n        temp.next = None\n\n        return out\n```\n\n### 复杂度\n\nO(n) / O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsw9818":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298148770","body":"### 思路\n\n对每一位分别加减，\n\n### 代码\n\n\n```python3\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        res=[]\n        i=len(num)-1\n        s=0\n        carry=0\n        while i>=0 or k!=0:\n            x=num[i] if i>=0 else 0\n            y=k % 10\n            s = x + y + carry\n            carry =s // 10\n            k //= 10\n\n            i -= 1\n            res.insert(0,s%10)\n        \n        if carry != 0:\n            res.insert(0,carry)\n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300301035","body":"### 思路\n\n从左到右，从右到左分别遍历，最后一起比较\n\n### 代码\n\n\n```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        tmp=-len(s)\n        index =0\n        dis_l=[0]*len(s)\n        dis_r=[0]*len(s)\n        dis=[0]*len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_l [i] = i-tmp\n\n        s=s[::-1]\n        tmp=-len(s)\n        for i, Char in enumerate(s):\n            if  Char == c:\n                tmp = i\n            dis_r [i] = i-tmp\n\n        dis_r=dis_r[::-1]\n        for i in range(len(s)):\n            dis[i]=min(abs(dis_l[i]),abs(dis_r[i]))\n        return dis    \n\n```\n\n**复杂度分析**\n- 时间复杂度：O(3N)，\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301583588","body":"### 思路\n>列表变栈\n### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.CustomStack = [0]*maxSize\n        self.top = -1 #栈顶为-1，表示栈空\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.CustomStack) - 1:#栈顶为总长度-1，表示栈满\n            self.top += 1\n            self.CustomStack[self.top] = x\n        \n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.CustomStack[self.top+1]\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range( min( (k) , self.top + 1 ) ):\n            self.CustomStack[i] += val\n\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302876960","body":"### 思路\n循环字符串s\n非 \"]\" 默认全部入栈\n遇到\"]\"时\n维护strs和repeat两个空字符串\n先while循环获取所有字符串，条件为stack[-1] != '[' (因为题目明确无异常场景，故此处无需判断栈是否为空)\nstrs = stack.pop() + strs\n执行一次stack.pop() 删掉“[”\n再次while循环，条件为栈存在且栈顶为数字类型的字符串（“3[a]”场景，必须判断栈不为空）\nrepeat = stack.pop() + repeat\n现在栈中压入int(repeat) * strs即可\n\n### 代码\n``` py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for i in s:\n            if i == ']':\n                strs=''\n                repeat=''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop()+repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n### 复杂度\n双O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304560480","body":"### 双栈模拟队列，每次push，pop都要把输入栈导入输出栈\n### 代码\n``` py\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819837","body":"### 代码\n``` py3\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305081132","body":"### 思路\n求长度，对于特殊的直接返回，取余求得实际旋转次数\n### 代码\n```py3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if k==0 or not head or not head.next:\n            return head\n        #求长度\n        n=1\n        cur = head\n        while cur.next:\n            cur=head.next\n            n+=1\n        \n        if (add := n - k % n) == n:\n            return head\n        \n        cur.next=head\n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next=None\n        return ret\n```\n### 复杂度\n空间O(1),时间O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaomingshixiaotang":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298225704","body":"### 思路\n\n1. 将 数字 k 加至所给数组的最后一位\n2. 将该位取余，得到该位本身的值 \n3. 给该位除以10，得到该位向前一位的进数\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n\n        for(int i = n - 1;i >= 0 || k > 0;i--)\n        {\n            if(i >= 0)\n            {\n                k+=num[i];\n            }\n            res.push_back(k % 10);\n            k/=10;\n        }\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(|k| or n)，其中 |k| 为数字k的位数。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299459461","body":"### 思路\n\n1. 遍历字符串s\n2. 在遍历字符串s的每个字符s[i]时，再一次对s进行遍历，在内层的每次遍历中判断该字符是否等于c并计算出该字符c与外层当前遍历的s[i]的距离\n3. 通过min变量维护每个字符s[i]到字符c的最小值\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> res;\n\n        for(int i = 0;i < s.size();i++)\n        {\n            int min = INT_MAX;\n\n            for(int j = 0;j < s.size();j++)\n            {\n                if((s[j] == c) && (abs(j - i) < min))\n                {\n                    min = abs(j - i);\n                }\n            }\n            res.push_back(min);\n        }\n\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n*n),n为字符串s的长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301729765","body":"### 思路\n\n1. 通过数组以及一个指向栈顶的指针来模拟栈\n2. 栈的增量操作：若k的值大于栈的容量，则进行栈的容量次循环；若k的值小于栈的容量，则进行k次循环\n\n### 代码\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        ownStack = new int[maxSize]();\n        this->maxSize = maxSize;\n        topPtr = -1;\n    }\n    \n    void push(int x) {\n        if(topPtr == this->maxSize - 1)\n        {\n            return;\n        }\n\n        ownStack[++topPtr] = x;\n    }\n    \n    int pop() {\n        if(topPtr == -1)\n        {\n            return -1;\n        }\n        \n        int tem = ownStack[topPtr--];\n        return tem;\n    }\n    \n    void increment(int k, int val) {\n        if(k < topPtr + 1)\n        {\n            for(int i = 0;i < k;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n        else\n        {\n            for(int i = 0;i < topPtr + 1;i++)\n            {\n                ownStack[i]+=val;\n            }\n        }\n    }\nprivate:\n    int* ownStack;\n    int maxSize;\n    int topPtr;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push和pop操作为O(1)，increment操作为O(k or n)（n为栈中元素的个数）\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303575583","body":"### 思路\n\n1. 采用分配律的思想\n2. 用一个栈保存数字，后出现的先使用；用一个栈保存高层级（外层）的字符串\n3. 当出现左括号时，说明应该保存这一层级的数字，以及上一层级的字符串（进行push操作）；当出现右括号时，说明应该获取当前层级的数字，用来作为循环条件（即进行乘法分配），获取上一层级的字符串与当前层级的字符串进行循环拼接，得到上一层级的字符串，（使用结束进行pop操作）\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        int num = 0;\n        stack<int> nums;\n        stack<string> lesserStrs;\n\n        int len = s.size();\n        for(int i = 0;i < len;i++)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + (s[i] - '0');\n            }\n            else if(s[i] >= 'a' && s[i] <= 'z')\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                lesserStrs.push(res);\n                res = \"\";\n                nums.push(num);\n                num = 0;\n            }\n            else if(s[i] == ']')\n            {\n                int n = nums.top();\n                nums.pop();\n                for(int i = 0;i < n;i++)\n                {\n                    lesserStrs.top() = lesserStrs.top() + res;   \n                }\n                res = lesserStrs.top();\n                lesserStrs.pop();\n            }\n        }\n\n        return res;\n    }\n};\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n),n为字符串长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304428361","body":"### 思路\n\n1. 用两个栈模拟一个队列\n2. push操作：用push栈，直接进行栈的push操作；pop操作：用pop栈，本质上是对push栈进行一个反转，即栈底变栈顶，然后进行pop栈的pop操作，满足了队列先进先出的要求\n\n### 代码\n\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        pushConti.push(x);\n    }\n    \n    int pop() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        popConti.pop();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n\n        return qTop;\n    }\n    \n    int peek() {\n        while(!pushConti.empty())\n        {\n            popConti.push(pushConti.top());\n            pushConti.pop();\n        }\n        int qTop = popConti.top();\n        while(!popConti.empty())\n        {\n            pushConti.push(popConti.top());\n            popConti.pop();\n        }\n        \n        return qTop;\n    }\n    \n    bool empty() {\n        if(pushConti.empty())\n        {\n            return true;\n        }\n        return false;\n    }\nprivate:\n    stack<int> pushConti;\n    stack<int> popConti;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n**复杂度分析**\n- 时间复杂度：push,empty:O(1), pop,peek:O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828585","body":"### 思路\n\n1. 由于数组升序和分块后升序的顺序是不会变的（也就是说我们一定是按顺序进行分块的，前面的还没有分块则后面的也不能分块）\n2. 采用哈希表对原数组和排序后的数组中的元素进行匹配，该元素同时出现在原数组和排序后的数组后，删除该元素，表示已匹配\n3. 只有当i前面的所有元素都匹配成功后，我们才可以进行一次分块\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> sorted = arr;//Sorted array\n        sort(sorted.begin(),sorted.end());\n\n        unordered_map<int,int> times;\n        int count = 0;\n        for(int i = 0;i < n;i++)\n        {\n            times[arr[i]]++;\n            times[sorted[i]]--;\n\n            if(times[arr[i]] == 0)\n            {\n                times.erase(arr[i]);\n            }\n\n            if(times[sorted[i]] == 0)\n            {\n                times.erase(sorted[i]);\n            }\n\n            if(times.empty())\n            {\n                count++;\n            }\n        }\n\n        return count;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305008995","body":"### 思路\n\n1. 首先排除边界情况，当list为空及realRotate为0时直接返回头节点\n2. 一般情况下，不管旋转几步，都要先将尾部节点和头部节点相连；之后，我们再找到旋转后的尾部节点，将尾部节点的下一个节点赋值给head后，再对其下一个节点置为空\n\n### 代码\n\n```c++\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        //Get size of list\n        ListNode* count = head;\n        int size = 0;\n        while(count != NULL)\n        {\n            count = count->next;\n            size++;\n        }\n\n        if(size == 0)\n        {\n            return head;\n        }\n        int realRotate = k % size;\n        if(realRotate == 0)\n        {\n            return head;\n        }\n\n        //Conect the last one with the first one\n        ListNode* last = head;\n        while(last->next != NULL)\n        {\n            last = last->next;\n        }\n        last->next = head;\n\n        //Find the last one after rotating\n        ListNode* lastAR = head;\n        size--;\n        for(int i = 0;i < size - realRotate;i++)\n        {\n            lastAR = lastAR->next;\n        }\n        head = lastAR->next;\n        lastAR->next = NULL;\n\n        return head;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)，遍历求list的大小\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snmyj":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298271102","body":"```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n=num.size();\r\n        vector<int> knum,res;\r\n        int bitsign=0;\r\n      \r\n        while(k>=1){\r\n        \r\n            knum.push_back(k-k/10*10);\r\n            k=k/10;\r\n        }\r\n        reverse(num.begin(),num.end());\r\n        int t=min(num.size(),knum.size());\r\n        for(int i=0;i<t;i++){\r\n            int bit=num[i]+knum[i]+bitsign;\r\n            \r\n            if(bit>=10){\r\n                res.push_back(bit-10);\r\n                bitsign=1;}\r\n\r\n            else \r\n            {res.push_back(bit);\r\n            bitsign=0;}\r\n        }\r\n        if(num.size()>knum.size()){\r\n            for(int i=knum.size();i<num.size();i++) res.push_back(num[i]);\r\n        }\r\n        else  for(int i=num.size();i<knum.size();i++) res.push_back(knum[i]);\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299919275","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n=s.length();\n        \n        vector<int> res;\n        for(int i=0;i<n;i++){\n           \n            if(s[i]==c) res.push_back(0);\n            else{\n                 for(int p=0,q=0;q<n-i||p<i;p++,q++){\n                     if(s[i+q]==c) {\n                         res.push_back(q);\n                         break;\n                         }\n                    if(s[i-p]==c){\n                        res.push_back(p);\n                        break;\n                    }\n\n                 }\n                \n                \n            }\n            \n        }\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301752515","body":"class CustomStack {\n    private List<Integer> stack=new ArrayList<>();\n    private int size;\n    \n\n    public CustomStack(int maxSize) {\n        size=maxSize;\n\n    }\n    \n    public void push(int x) {\n        if(stack.size()<size){\n        stack.add(x);}\n\n    }\n    \n    public int pop() {\n        return stack.isEmpty()?-1:stack.remove(stack.size()-1);\n\n    }\n    \n    public void increment(int k, int val) {\n        for(int i=0;i<k&&i<stack.size();i++){\n            stack.set(i,stack.get(i)+val);\n        }\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303098142","body":"```\r\nclass Solution:\r\n\r\n    def decodeString(self, s: str) -> str:\r\n\r\n        result = ''\r\n        string_stack = []\r\n        data = 0\r\n        for i in s:\r\n            if(i.isdigit()):\r\n                data = data*10 + int(i)\r\n\r\n            elif(i == '['):\r\n                string_stack.append([data, result])\r\n                result = ''\r\n                data = 0\r\n\r\n            elif(i.isalpha()):\r\n                result += i\r\n\r\n            elif(i == ']'):\r\n                result = string_stack[-1][1] + string_stack[-1][0] * result\r\n                string_stack.pop()\r\n        return result\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304412237","body":"```\r\npublic class MyQueue{\r\n   Stack<Integer> stack1;\r\n   Stack<Integer> stack2;\r\n```\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.pop();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.pop();\r\n        }\r\n    }\r\n\r\n    public int peek() {\r\n        if(!stack2.isEmpty()){\r\n            return stack2.peek();\r\n        }else{\r\n            while(!stack1.isEmpty()){\r\n                int topValue=stack1.pop();\r\n                stack2.push(topValue);\r\n            }\r\n            return stack2.peek();\r\n        }\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack1.isEmpty()&&stack2.isEmpty();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304660862","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        int n = arr.size();\r\n        vector<int> vmin(n+1, 1e8);\r\n        vector<int> vmax(n+1, 0);\r\n        for(int i=1;i<=n;i++) vmax[i] = fmax(vmax[i-1], arr[i-1]);\r\n        for(int i=n-1;i>=0;i--) vmin[i] = fmin(vmin[i+1], arr[i]);\r\n        int ans = 1;\r\n        for(int j=1;j<n;j++){\r\n            if(vmax[j] <= vmin[j]){\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304871633","body":"`\npublic:\n    ListNode* rotateRight(ListNode* head, int k) \n    {\n     if (head == NULL || k <= 0)\n\t\treturn head;\n\tListNode *end = NULL;\n\tListNode *index = head;\n\tListNode *cur = head;\n\tint len = 1;\n\twhile (cur->next != NULL)\n\t{\n\t\tlen++;\n\t\tcur = cur->next;\n\t}\n\tend = cur;\n\t//cout << len << endl;\n\n\tint rotateTimes =  k%len;\n\tif (rotateTimes == 0)\n\t\treturn head;\n\n\t//set ring\n\tend->next = head;\n\tint step = len  - rotateTimes;\n\twhile (step > 0)\n\t{\n\t\tstep--;\n\t\tindex = index->next;\n\t\tend = end->next;\n\t}\n\tend->next = NULL;\n\n\treturn index;\n    }\n};\n`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flipn9":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298276676","body":"```java\n/**\n    TC: O(max(N,logk)), N为数组的长度\n    SC: O(max(N,logk))\n*/\n\n// Method 2: 将 加数 k 整个 加入数组表示的数的最低位\n//           3 + 912 = 915, 5 留在当前这一位，将 910 / 10 = 91 以进位的形式加入下一位\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        for (int i = N - 1; i >= 0; i--){\n            int sum = num[i] + k;\n            res.add(0, sum % 10);\n            k = sum / 10;   // 更新 k 存进位 carry\n        }\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n\n// Method 1: 两个数拆解后 同时 从后往前逐位相加\nclass Solution1 {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int N = num.length;\n        \n        int i = N - 1;\n        int sum = 0, carry = 0;\n        while (i >= 0 || k > 0) {\n            int x = i >= 0 ? num[i] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        \n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299355292","body":"```java\n/**\n    思路:     对每一个 i 从中心扩散找最近的 C     O(n^2)\n        ==>  空间换时间, 存储所有 c 的位置       O(nk), 出现 k 次\n        ==>  Greedy, 只关心最近的 C ==> 正向遍历+反向遍历\n    ------------------------------------------------------------------\n    实现:\n        两个数组 left 和 right 分别记录每个字符左/右侧出现的最后一个 C 字符的下标\n        同时比遍历这两个数组, 计算距离最小值\n\n    优化:    \n        1. 只需要最近的 C, 所以看情况可以覆盖掉第一个数组的值\n            case 1. 字符的左侧没有出现过 C 字符\n            case 2. i - left > right - i\n        2. 直接记录 C 与当前字符的距离, 而不是 C 的下标, 还可以省去最后遍历计算距离的过程\n                \n    TC: O(N), SC: O(1)      1ms\n*/\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        dist[0] = s.charAt(0) == c ? 0 : N;\n        for (int i = 1; i < N; i++) {\n            dist[i] = s.charAt(i) == c ? 0 : dist[i - 1] + 1;\n        }\n        for (int i = N - 2; i >= 0; i--) {\n            dist[i] = Math.min(dist[i], dist[i + 1] + 1);  // 左侧距离 > 右侧距离, 未遇到 C 默认距离为 N\n        }\n        return dist;\n    }\n}\n\n/**\n    sliding window: 把 c 看成 s 的分割线\n    XXXX | XXXX | XXXXXX\n    \n    TC: O(N), SC: O(1)\n*/\nclass Solution1 {\n    public int[] shortestToChar(String s, char c) {\n        int N = s.length();\n        int[] dist = new int[N];\n        \n        int l = s.charAt(0) == c ? 0 : N;\n        int r = s.indexOf(c);\n        for (int i = 0; i < N; i++) {\n            dist[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n            if (i == r) {\n                l = r;\n                r = s.indexOf(c, l + 1);\n            }\n        }\n        return dist;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301193737","body":"```java\n/**\n    因为 stack 的 maxSize 限定 很直观能想到用 arr 解决\n    问题在于 如果让 increment 的 TC 能从 O(k) 降到 O(1)\n    \n    可以添加一个辅助数组 add, 单独储存每个元素的增量\n        1. increment: 将栈底 k 个元素+val, 则将 add[k - 1] += val\n        2. pop: 栈顶值 + add[top], 在次之后, add[top - 1] 累加 add[top]的增量\n                    也就是. add 的值在 pop 之后会向下传递, 自身则清零\n    \n    有点像差分数组的变种\n    这样所有操作 TC 都是 O(1)\n*/\n\nclass CustomStack {\n    int[] stack;\n    int[] add;\n    int top;\n    int size;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.add = new int[maxSize];\n        this.top = -1;\n        this.size = maxSize;\n    }\n    \n    public void push(int x) {\n        if (top < size - 1)\n            stack[++top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) return -1;\n        int res = add[top] + stack[top];\n        if (top != 0) add[top - 1] += add[top];\n        add[top] = 0;\n        top--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        // for (int i = 0; i < k && i <= top; i++) {\n        //     stack[i] += val;\n        // }\n        if (top == -1) return;\n        add[Math.min(k - 1, top)] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302804971","body":"```java\n/**\n    TC: O(n), SC: O(n)\n*/\n\n// Method 1: iterative\nclass Solution1 {\n    public String decodeString(String s) {\n        int multi = 0;\n        StringBuilder sb = new StringBuilder();\n        \n        Deque<Integer> multi_stack = new ArrayDeque<>();\n        Deque<String> chars_stack = new ArrayDeque<>();\n        \n        for (char c : s.toCharArray()) {\n            if (c >= '0' && c <= '9') {                 // 1. 倍数\n                multi = multi * 10 + (c - '0');\n            } else if (c >= 'a' && c <= 'z') {          // 2. 字符\n                sb.append(c);\n            } else if (c == '[') {                      // 3. 入栈\n                multi_stack.addLast(multi);             // 接下来[sb]要重复的次数\n                chars_stack.addLast(sb.toString());     // 之前的sb\n                multi = 0;                              // 重置临时变量\n                sb = new StringBuilder();\n            } else { // if (c == ']')                   // 4. 出栈\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = multi_stack.pollLast();\n                for (int i = 0; i < cur_multi; i++)\n                    tmp.append(sb);                     // sb * multi次\n                sb = new StringBuilder(chars_stack.pollLast() + tmp);   // 把之前的和这一次的连起来\n            }\n        }\n        return sb.toString();\n    }\n}\n\n// Method 2: recursive\n//      先解析数字 x, 解析到了左括号 [，递归向下解析后面的内容，遇到对应的右括号就返回 ]\n//      [] 解析结束后, 再继续 解析] 右边的内容\nclass Solution {\n    int i = 0;\n    public String decodeString(String s) {\n        int count = 0;\n        StringBuilder sb = new StringBuilder();\n        while (i < s.length()) {\n            char c = s.charAt(i);\n            i++;\n            if (Character.isLetter(c)) {\n                sb.append(c);\n            } else if (Character.isDigit(c)) {\n                count = count * 10 + (c - '0');\n            } else if (c == ']') {      \n                break;\n            } else if (c == '[') {\n                String repeat = decodeString(s);\n                while (count > 0) {\n                    sb.append(repeat);\n                    count--;\n                }\n            }\n        }\n        return sb.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304345014","body":"```java\n/**\n    双栈实现 Queue\n    \n    push时压入 input 栈\n    peek 或者 peek 时, 如果 output 栈为空, 那么把 input 栈 pop 出来到 output\n    \n    TC: push: O(1), pop/peek: amortized O(1)\n    SC: O(N)\n*/\nclass MyQueue {\n    Stack<Integer> input = new Stack<>();\n    Stack<Integer> output = new Stack<>();\n\n    public MyQueue() {\n    }\n    \n    public void push(int x) {\n        input.push(x);\n    }\n    \n    public int pop() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.pop();\n    }\n    \n    public int peek() {\n        if (output.empty()) {\n            while (!input.empty()) {\n                output.push(input.pop());\n            }\n        }\n        return output.peek();\n    }\n    \n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304648451","body":"```java\n/**\n    思路: 和 769 类似\n    块的最大值呈升序排列, 维护一个单调递增栈 保存每个块的最大值\n        如果当前栈为空 || 栈顶 比当前小, 将当前元素 push 进去\n        如果当前栈非空 && 栈顶比当前大, 栈顶应该是目前块的最大值, pop 出来, \n                                    把所有比当前大的元素也 pop 出来\n                                    再把真正的最大值 pop 回去\n    TC: O(N), SC: O(N)\n*/\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] stack = new int[arr.length];\n        int top = -1;\n        for (int i : arr) {\n            if (top != -1 && stack[top] > i) {\n                int max = stack[top--];\n                while (top != -1 && stack[top] > i)\n                    top--;\n                stack[++top] =  max;\n            } else {\n                stack[++top] = i;\n            }\n        }\n        return top + 1;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305036285","body":"```java\n/**\n    思路: 走 k 步, 由于 k 可能很大, 希望 k = k % N\n        1. 遍历, 计算链表长度N, 找到尾结点 tail\n        2. 断开两种方式\n            - 找到新的头结点, 连接旧头尾, 断开得到新的 head, 新的 tail 指向 null\n            - 先连成环, 再找到新的头尾, 断开\n            \n        (用 dummy head 的写法也很有趣)\n    TC: O(n) SC: O(1)\n*/\n\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        \n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode fast = dummy, slow = dummy;\n\n        int N = 0;\n        for (; fast.next != null; N++)\n            fast = fast.next;\n        for (int i = N - k % N; i > 0; i--) \n            slow = slow.next;\n\n        fast.next = dummy.next; \n        dummy.next = slow.next;\n        slow.next = null;\n    \n        return dummy.next;\n    }\n}\n\nclass Solution2 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        k %= N;\n        if (k == 0) return head;\n        tail.next = head;\n        for (int i = 0; i < N - k; i++) {\n            tail = tail.next;\n        }\n        ListNode newHead = tail.next;\n        tail.next = null;\n        return newHead;\n    }\n}\n\nclass Solution1 {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) return head;\n        // 1. 计算链表长度, 并找到 tail 节点\n        int N = 0;\n        ListNode tail = null;\n        for (ListNode ptr = head; ptr != null; ptr = ptr.next) {\n            tail = ptr;\n            N++;\n        }\n        // 2. 更新 k\n        k %= N;\n        if (k == 0) return head;\n        // 3. 因为头结点会是倒数 第k 个, 那么前面就有 N - k个节点, ptr 要移动 N - k - 1次\n        ListNode ptr = head;\n        for (int i = 0; i < N - k - 1; i++) {\n            ptr = ptr.next;\n        }\n        // 4. 先把 tail 指向原来的 head, 更新 head, 最后真正的 tail 也就是 ptr的 next 指向 null\n        tail.next = head;\n        head = ptr.next;\n        ptr.next = null;\n        return head;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wabw1":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298298900","body":"### 解题思路\r\n倒序遍历num逐个与k的数组倒序相加, 设置一个进位sgn=0, 如果有进位sgn=1, 相加的时候把sgn加上\\\r\nk => [num,num...]  少的那个在左边补齐足够的0\r\n❓ 想着是否可以只相加min(num1,num2)长度的，剩下的直接原封不动复制过来，但是99999-xxx 这种怎么办啊😿\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n  let num2 = [...k.toString()].map(c=> +c);\r\n\r\n  if(num2.length<num.length){\r\n    num2.unshift(...new Array(num.length-num2.length).fill(0));\r\n  } else{\r\n    num.unshift(...new Array(num2.length-num.length).fill(0));\r\n  }\r\n  let n = num.length;\r\n  let sum=0;\r\n  let sgn=0;\r\n  let res=[];\r\n  for(let i=0; i<n;i++){\r\n    sum = num[n-1-i]+num2[n-1-i]+sgn;\r\n    sgn = sum>=10 ? 1: 0;\r\n    res.unshift(sum%10);\r\n  }\r\n  // for结束判断最后一位是否需要再进位\r\n  if (sgn===1){\r\n    res.unshift(1);\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间空间都是O(N) ?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300671552","body":"### 解题思路\n1. 抽取出来所有目标字符c所在的索引的数组tar\n2. 每次只需要比较s中的每一位s[i]与它左右两个c的距离然后选最小; \n3. tar数组p指针和p-1控制当前s[i]最近的左右两个命中的目标点, p从1开始（0位置为dum离得非常远所以第一次命中肯定是p)，遍历s数组，当i命中了p对应的tar的值tar[p]也就是当前命中点在s里的索引，就res.push(0),然后右移p,没命中就res.push(min(i-左侧, 右侧-i))\n4. 考虑到只有一个目标的情况，所以索引数组tar左右两端加一个很远的坐标，like: -10000,10000\n\n### 代码\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n\n  let tar = [-10000];\n  for(let i=0; i<s.length; i++){\n    if(s[i]===c){\n      tar.push(i);\n    }\n  }\n  tar.push(10000);\n  let p = 1;\n  let res = [];\n  for(let i=0; i<s.length; i++){\n    if(i===tar[p]){\n      res.push(0);\n      p++;\n    } else{\n      res.push(Math.min(i-tar[p-1], tar[p]-i))\n    }\n  }\n  return res;\n};\n```\n### 复杂度\n**时间** : O(N) 两次遍历S\n**空间** : O(N) 为tar数组长度的额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301774652","body":"### 解题思路\r\n模拟，构造函数需要两个属性，一个数组stack一个maxSize；\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.stack = new Array();   // [empty, ...]\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  // 最大长度限制\r\n  if(this.stack.length<this.maxSize){\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  // 栈顶为空的 =》 -1\r\n  if(this.stack.length===0){\r\n    return -1;\r\n  }\r\n  let val = this.stack.pop();\r\n  return val;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let n = Math.min(k,this.stack.length);  //取交集，前n个元素+val\r\n  for(let i=0;i<n;i++){\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n\r\n### 复杂度\r\n时间: push/pop 都为O(1), increment需要O(k)\r\n空间: O(N) 一个栈的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303550516","body":"### 解题思路\r\n栈的使用\r\n1. 判断类型： 数字、字母、[、]\r\n  1. 数字 更新m 直接拼接\r\n  2. 字母，更新res, 直接拼接\r\n  3. [: 入栈  stack.push([res, +m])\r\n  4. ]: 出栈  res = pop出来的res +  当前res.repeat(pop出来的multi)\r\n\r\nJS的一些语法复习：\r\n1. 重复3次的str: \r\n  a. str.repeat(3)  ES6的语法\r\n  b. new Array(3).fill(str).join(\"\")\r\n  c. new Array(4).join(str)\r\n2. ASCII码:  0-9 : 48-57 ;  字母a-z: 97-122\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n\r\nvar decodeString = function(s) {\r\n  let m = \"\";\r\n  let stack = [];\r\n  let res = \"\";\r\n  for(let i=0;i<s.length;i++){\r\n    let asc = s[i].charCodeAt();\r\n    // 数字 更新m 直接拼接\r\n    if (asc>=48 && asc<=57){\r\n      m += s[i];  \r\n    } else if(asc>=97 && asc<=122){\r\n      // 字母 更新res\r\n      res += s[i];\r\n    } else if(s[i]==='['){\r\n      // 入栈[res,m] 置空这两个\r\n      stack.push([res,+m]);\r\n      res = '';\r\n      m = '';\r\n    } else if(s[i]===']'){\r\n      // 出栈\r\n      let [beforeRes,multi] = stack.pop();\r\n      res = beforeRes+ res.repeat(multi);\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```\r\n\r\n### 复杂度\r\n空间：O(N)\r\n时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304505032","body":"### 解题思路\r\n几个要注意的点\r\n1. 两个栈首先命名用stackIn和stackOut容易记\r\n2. push永远只往stackIn里\r\n3. pop时先判断stackOut是否为空，不为空直接pop(), 为空就：把stackIn的所有一股脑全部倒入stackOut里\r\n4. 判断empty时记得两个栈都要为空才行\r\n\r\n### JavaScript代码\r\n\r\n```javascript\r\nvar MyQueue = function() {\r\n  // 两个栈 sIn, sOut\r\n  this.sIn = [];   // push永远只压入到这里\r\n  this.sOut = [];   //不为空就pop()  为空就一次性倒完\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n  this.sIn.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.pop();\r\n  } \r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n  if(this.sOut.length!==0){\r\n    return this.sOut.slice(-1);\r\n  }\r\n  while(this.sIn.length!==0){\r\n    this.sOut.push(this.sIn.pop());\r\n  }\r\n  return this.sOut.slice(-1);\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n  return this.sIn.length===0 && this.sOut.length===0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n\r\n### 复杂度分析\r\n空间：O(N) 两个栈嘛\r\n时间：push和empty很好想就是O(1)； pop和peek思路一样（举个极端例子一连串的push后pop，这时候需要倒完N个到stackOut里，但是之后的push和pop全是一次操作解决，所以其实是O(2)吧，N个操作均摊O(N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829528","body":"### 解题思路\r\n1. left[i]: arr[0]-arr[i]最大值\r\n2. right[i]: arr[i]-arr[n-1]的最小值\r\n3. 遍历for(i=1; i<n; n++) 如果arr[i-1]<=arr[i] 就在arr[i]前切一刀\r\n\r\n### Js代码\r\n\r\n```javascript\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n  let l = new Array(arr.length).fill(arr[0]);\r\n  let r = new Array(arr.length).fill(arr[arr.length-1]);\r\n\r\n  let max = arr[0];\r\n  let min= arr[arr.length-1];\r\n  \r\n  for(let i=0; i<arr.length; i++){\r\n    max = Math.max(max, arr[i]);\r\n    l[i] = max;\r\n  }\r\n  for(let i=arr.length-1; i>=0; i--){\r\n    min = Math.min(min, arr[i]);\r\n    r[i] = min;\r\n  }\r\n  \r\n  let cnt = 0;\r\n  for(let j=1; j<arr.length; j++){\r\n    if(l[j-1] <= r[j]) cnt++;\r\n  }\r\n  return cnt+1;\r\n  \r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间：O(N)\r\n空间：两个额外的数组 O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqmmy":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298299088","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # a = ''\n        # for i in num:\n        #     a += str(i)\n        # b = int(a)+k\n        # res = []\n        # for i in str(b):\n        #     res.append(int(i))\n        # return res\n        \n        # return list(map(int,str(int(''.join(map(str,num))) + k)))\n\n        res = []\n        i, carry = len(num) - 1, 0\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            res.append(sum % 10)\n            carry = sum // 10\n\n            i -= 1\n            k //= 10\n        if carry != 0: res.append(carry)\n        return res[::-1]\n\n        \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299676710","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # numlist = []\n        # reslist = []\n        # for i in range(len(s)):\n        #     if s[i] == c:\n        #         numlist.append(i)\n        # for j in range(len(s)):\n        #     reslist.append(min([abs(i - j) for i in numlist]))\n        # return reslist\n\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301871371","body":"class CustomStack:\r\n\r\n\r\n\r\n\r\n\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0]*maxSize\r\n        self.top = -1\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top+1]\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-pricity":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298382708","body":"# 解题思路：\n# 把列表转化成字符串，然后强制转化成int\n# 再进行正常的两个数的加法\n# 最后把结果转化成字符串，然后转化成列表\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,A))) + K)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300427307","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), -inf\n        for i, ch in enumerate(s):\n            if ch == c:\n                last = i\n            ans[i] = min(ans[i], i - last)\n        last = inf\n        for i, ch in enumerate(s[::-1]):\n            # 因为两者都有 len(s) - 1 的偏移量，可以一起去掉，减少运算            \n            # if ch == c:\n            #     last = len(s) - 1 - i\n            # ans[-1 - i] = min(ans[-1 - i], last - len(s) + 1 + i)\n            if ch == c:\n                last = -i\n            ans[-1 - i] = min(ans[-1 - i], last + i)\n        return ans\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301761523","body":"```\n/**\n    利用数组来模拟栈\n    注意：\n        1.当栈元素个数等于 maxSize 时不允许继续入栈；\n        2.当栈为空时，出栈操作返回 -1；\n        3.当栈非空，出栈操作发返回栈顶值\n        4.增量操作时，当栈元素多于 k 个，将栈底的 k 个元素都加 val，栈元素少于 k 个时将所有元素都加上 val。\n\n */\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.maxSize){\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const item = this.list.pop()\n    return item === void 0 ? -1 : item\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < k && i < this.list.length; i++) {\n        this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303112859","body":"```\n/**\n    利用栈的思想解题\n      设置两个变量：1.res 最终结果字符串 2.num 用来计数当前字符需要重复多少次 \n      构造两个栈：1.字符栈 strStack，表示需要重复的字符 2.数字栈，需要重复的次数 \n      如果当前 str === 数字，推入数字栈 \n      如果当前 str === [,strStack、numStack 入栈，num，res 清 0 \n      如果当前 str === ],strStack、numStack 出栈，形成一次字符串 \n      其他情况 把字符加到 res 中\n */\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n    let numStack = [],strStack = [],res = '',num = 0;\n\n    for (let str of s) {\n        if (!isNaN(str)) {\n            num = num * 10 + parseInt(str);\n        } else if (str === '[') {\n            strStack.push(res);\n            numStack.push(num);\n            res = '';\n            num = 0;\n        } else if (str === ']') {\n            res = strStack.pop() + res.repeat(numStack.pop());\n        } else {\n            res += str;\n        }\n    }\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304500973","body":"两个栈解题，一个输入栈、一个输出栈\nvar MyQueue = function() {\n    this.stackIn = [];\n    this.stackOut = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length;\n    if(size){\n        return this.stackOut.pop();\n    }\n    while(this.stackIn.length){\n        this.stackOut.push(this.stackIn.pop());\n    }\n    return this.stackOut.pop();  \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackIn.length && !this.stackOut.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751374","body":"```\n滑动窗口\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    const sorted = [...arr];\n    sorted.sort((a,b) => a-b);\n    \n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n    \n    for (let i = 0; i < arr.length; i++){\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if(sum1 == sum2){\n            count++;\n            sum1 = sum2 = 0;\n        }\n    }\n    return count;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sclihuiming":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298389769","body":"## 思路\n取`num`与数字`k`的最大长度`maxLen`，构造`maxLen`大小的切片，然后从最后遍历数组，进行累加。 最后返回的时候，判断res[0]是否等于0，否则截取res[1:]\n\n## 代码\n\n```golang\nfunc addToArrayForm(num []int, k int) []int {\n\tkLen := 0\n\ttmpK := k\n\tfor tmpK > 0 {\n\t\ttmpK /= 10\n\t\tkLen++\n\t}\n\tnumLen := len(num)\n\tmaxLen := numLen\n\tif kLen > maxLen {\n\t\tmaxLen = kLen\n\t}\n\n\tres := make([]int, maxLen+1)\n\tfor index := numLen - 1; index >= 0; index-- {\n\t\tamount := num[index] + k%10\n\t\tk /= 10\n\t\tif amount >= 10 {\n\t\t\tk++\n\t\t\tamount -= 10\n\t\t}\n\t\tres[maxLen] = amount\n\t\tmaxLen--\n\t}\n\tfor k > 0 {\n\t\tres[maxLen] = k % 10\n\t\tk /= 10\n\t\tmaxLen--\n\t}\n\tif res[0] == 0 {\n\t\treturn res[1:]\n\t}\n\treturn res\n}\n```\n\n## 复杂度分析\n\n- 空间复杂度： O(n)\n\n- 时间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302330762","body":"```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n\trecord := []int{}\r\n\tfor index := 0; index < len(s); index++ {\r\n\t\tif s[index] == c {\r\n\t\t\trecord = append(record, index)\r\n\t\t}\r\n\t}\r\n\tpreIndex := 0\r\n\tlastIndex := 0\r\n\tans := make([]int, len(s))\r\n\tfor index, _ := range s {\r\n\t\tif lastIndex < len(record)-1 {\r\n\t\t\tif index > record[lastIndex] {\r\n\t\t\t\tpreIndex = lastIndex\r\n\t\t\t\tlastIndex++\r\n\t\t\t}\r\n\t\t}\r\n\t\tans[index] = min821(abs821(record[preIndex]-index), abs821(record[lastIndex]-index))\r\n\r\n\t}\r\n\r\n\treturn ans\r\n}\r\n\r\nfunc min821(a, b int) int {\r\n\tif a < b {\r\n\t\treturn a\r\n\t}\r\n\treturn b\r\n}\r\n\r\nfunc abs821(a int) int {\r\n\tif a < 0 {\r\n\t\treturn -a\r\n\t}\r\n\treturn a\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302290290","body":"## 思路\n数组模拟\n\n## 代码实现\n```golang\ntype CustomStack struct {\n    MaxSize int\n    elems []int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        MaxSize: maxSize,\n        elems: []int{},\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if len(this.elems) < this.MaxSize {\n        this.elems = append(this.elems, x)\n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if len(this.elems) == 0 {\n        return -1\n    }\n    res := this.elems[len(this.elems) - 1]\n    this.elems = this.elems[:len(this.elems) - 1]\n    return res\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    minLen := k\n    if len(this.elems) < k {\n        minLen = len(this.elems)\n    }\n    for index :=0; index < minLen; index++ {\n        this.elems[index] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n## 复杂度\n- 时间复杂度   push / pop O(1)  increment O(n)\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303603641","body":"## 思路\n模拟栈，并且插入一个 `#` 号键作为标识符\n\n## 代码\n```golang\nfunc decodeString1(s string) string {\n\tans := []rune{}\n\n\ti := true\n\tfor _, elem := range s {\n\t\tif elem >= '0' && elem <= '9' && i {\n\t\t\tans = append(ans, '#', elem)\n\t\t\ti = false\n\t\t} else if elem == '[' {\n\t\t\ti = true\n\t\t\tans = append(ans, elem)\n\t\t} else if elem == ']' {\n\t\t\ti = true\n\t\t\ttmpStr := \"\"\n\t\t\tamountStr := \"\"\n\t\t\tflag := false\n\t\t\tfor len(ans) > 0 {\n\t\t\t\tpopElem := ans[len(ans)-1]\n\t\t\t\tans = ans[:len(ans)-1]\n\t\t\t\tif popElem == '#' {\n\t\t\t\t\tbreak\n\t\t\t\t} else if popElem == '[' {\n\t\t\t\t\tflag = true\n\t\t\t\t} else if flag {\n\t\t\t\t\tamountStr = string(popElem) + amountStr\n\t\t\t\t} else {\n\t\t\t\t\ttmpStr = string(popElem) + tmpStr\n\t\t\t\t}\n\t\t\t}\n\t\t\tamount := 1\n\t\t\tif amountStr != \"\" {\n\t\t\t\tamount, _ = strconv.Atoi(amountStr)\n\t\t\t}\n\t\t\tstr := \"\"\n\t\t\tfor index := 0; index < amount; index++ {\n\t\t\t\tstr += tmpStr\n\t\t\t}\n\t\t\tans = append(ans, []rune(str)...)\n\n\t\t} else {\n\t\t\tans = append(ans, elem)\n\t\t}\n\t}\n\treturn string(ans)\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304572444","body":"```golang\ntype MyQueue struct {\n\tinStack  []int\n\toutStack []int\n}\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{}\n}\n\nfunc (this *MyQueue) Push(x int) {\n\tthis.inStack = append(this.inStack, x)\n}\n\nfunc (this *MyQueue) Pop() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\tx := this.outStack[len(this.outStack)-1]\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\n\treturn x\n}\n\nfunc (this *MyQueue) Peek() int {\n\tif len(this.outStack) == 0 {\n\t\tthis.in2Out()\n\t}\n\treturn this.outStack[len(this.outStack)-1]\n}\n\nfunc (this *MyQueue) Empty() bool {\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\n}\n\nfunc (this *MyQueue) in2Out() {\n\tfor len(this.inStack) > 0 {\n\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\n\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823193","body":"```golang\r\nfunc maxChunksToSorted(arr []int) int {\r\n\tsize := len(arr)\r\n\r\n\ttmpArr := make([]int, size)\r\n\tcopy(tmpArr, arr)\r\n\tsort.Sort(sort.IntSlice(tmpArr))\r\n\tnum := 0\r\n\tsum1, sum2 := 0, 0\r\n\tfor index, value := range arr {\r\n\t\tsum1 += tmpArr[index]\r\n\t\tsum2 += value\r\n\t\tif sum1 == sum2 {\r\n\t\t\tnum++\r\n\t\t}\r\n\t}\r\n\treturn num\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amazeding":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298393989","body":"## 思路\n- 将K和数组每一位相加，取余得出新数组每一位的数值，将相加的和作为进位。需要注意边界。\n## 代码\n```java\npublic class Solution {\n    public static List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList();\n        for(int i=num.length-1;i>=0;i--){\n            int sum = k + num[i];\n            result.add(sum%10);\n            k = sum/10;\n        }\n        if (k > 9) {\n            while(k > 9) {\n                int data = k%10;//取余\n                k = k/10;\n                result.add(data);\n            }\n            result.add(k);\n        }else if (k>0 && k<=9){\n            result.add(k);\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n## 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298396077","body":"### 思路\n\n将整个加数 K加入数组表示的数的最低位，余数保留，高位数进位再相加\n\n### 代码\n\n~~~java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间：O（n）\n\n空间：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300627485","body":"### 思路\n\n~~~bash\n前后遍历，取距离最小的\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302133635","body":"### 思路\n\n~~~bash\n用一个数组来模拟栈，push操作的话，没满就把栈顶后移，pop操作的话，非空就迁移\n~~~\n\n### 代码\n\n~~~java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度： pop，push  O(1)   inc O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303215840","body":"### 思路\n\n~~~bash\n利用栈的思想，数字、字母和中括号分开，数字、字母和左括号直接进，遇到右括号的时候出栈，然后一直到遇到左括号停止，反转一下就是我们的字母队列，再去栈里面找数字就是重复的次数，然后根据新的字符串再进栈，如此循环往复即可\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304502487","body":"### 思路\n\n~~~bash\n将一个栈当作输入栈，用于压入push 传入的数据；另一个栈当作输出栈，用于pop 和 peek 操作。\n~~~\n\n### 代码\n\n~~~java\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(1)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794291","body":"### 思路\n\n~~~bash\n对于已经分好块的数组，若块数大于 1，则可以得到以下结论：右边的块的所有数字均大于或等于左边的块的所有数字。\n有点儿没看懂，下去再看看。\n~~~\n\n### 代码\n\n~~~java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n~~~\n\n### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tzuikuo":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406485","body":"### 思路\r\n\r\nk和x不知道哪个位数多，先用map把两个数组存起来，然后对应位置相加，>=10就进位\r\n\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        map<int,int> nummap;\r\n        vector<int> revec;\r\n        int n=num.size(),flag=0;\r\n        reverse(num.begin(),num.end());\r\n        for(int i=0;i<n;i++){\r\n            nummap[i]=num[i];\r\n        }\r\n        int i=0;\r\n        while(k!=0){\r\n            nummap[i]+=k%10;\r\n            k=k/10;\r\n            i++;\r\n        }\r\n        for(auto it=nummap.begin();it!=nummap.end();it++){\r\n            if(it->second>=10&&it->first<nummap.size()-1){\r\n                it->second-=10;\r\n                it++;\r\n                it->second+=1;\r\n                it--;\r\n            }\r\n            if(it->second>=10&&it->first==nummap.size()-1){\r\n                it->second-=10;\r\n                flag++;\r\n            }\r\n            revec.push_back(it->second);\r\n        }\r\n        if(flag) revec.push_back(1);\r\n        reverse(revec.begin(),revec.end());\r\n        return revec;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299622674","body":"### 思路\r\n\r\n每个位置的字符，向前向后找离它最近的给定字符，一找到就跳出循环\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n=s.size();\r\n        vector<int> re;\r\n        for(int i=0;i<n;i++){\r\n            int left=i,right=i;\r\n            if(s[i]==c){\r\n                re.push_back(0);\r\n                continue;\r\n            }\r\n            left--;\r\n            right++;\r\n            while(true){\r\n                if(left<0&&right>n-1) break;\r\n                if(left>=0){\r\n                    if(s[left]==c){\r\n                        re.push_back(i-left);\r\n                        break;\r\n                    }\r\n                    left--;\r\n                } \r\n                if(right<=n-1){\r\n                    if(s[right]==c){\r\n                        re.push_back(right-i);\r\n                        break;\r\n                    }\r\n                    right++;\r\n                }\r\n            }\r\n        }\r\n        return re;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O($N^2$)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301961812","body":"### 思路\n\n用数组作为增量栈的数据结构，加一个cnt的变量，记录栈内当前的大小\n\n### 代码\n\n```C++\nclass CustomStack {\npublic:\n    vector<int> myvec;\n    int cnt=0;\n    CustomStack(int maxSize) {\n        for(int i=0;i<maxSize;i++) myvec.push_back(0);\n    }\n    \n    void push(int x) {\n        if(cnt<myvec.size()){\n            cnt++;\n            myvec[cnt-1]=x;\n        }\n    }\n    \n    int pop() {\n        if(cnt==0) return -1;\n        else{\n            int temp=myvec[cnt-1];\n            cnt--;\n            return temp;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(cnt<k) for(int i=0;i<cnt;i++) myvec[i]+=val;\n        else for(int i=0;i<k;i++) myvec[i]+=val;\n    }\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：增量操作O(N)，push，pop操作O(1)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303651417","body":"### 思路\n\n利用两个栈，一个存当前字符，一个存当前数量，遍历字符串，遇到字母，加入当前字符，遇到数字字符，当前数字*10加上当前数字字符，遇到‘[’，将当前字母和数字入栈，归0，遇到’]‘，将栈顶字母弹出，栈顶字母+栈顶数量*当前字符串=累计字符串；然后继续。\n\n### 代码\n\n\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n=s.size();\n        stack<string> stackstr;\n        stack<int> stacknum;\n        string curstr=\"\";\n        int curnum=0;\n        for(int i=0;i<n;i++){\n            if(s[i]>='0'&&s[i]<='9') curnum=curnum*10+(s[i]-'0');\n            if(s[i]>='a'&&s[i]<='z') curstr+=s[i];\n            if(s[i]=='['){\n                stackstr.push(curstr);\n                stacknum.push(curnum);\n                curstr=\"\";\n                curnum=0;\n            }\n            if(s[i]==']'){\n                string temp=curstr;\n                for(int i=0;i<stacknum.top()-1;i++) curstr+=temp;\n                curstr=stackstr.top()+curstr;\n                stackstr.pop();\n                stacknum.pop();\n            }\n        }\n        return curstr;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304427396","body":"### 思路\r\n\r\n队列：先进先出，栈：先进后出；两个栈模拟队列，要弹出队头的时候把一个栈里的腾空挪到另一栈，然后几句push的时候向第一个栈push；取队列头的时候检查第二个栈是否为空。\r\n\r\n### 代码\r\n\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    stack<int> mainstack,tempstack;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        mainstack.push(x);\r\n    }\r\n    \r\n    int pop(){\r\n        int temp;\r\n        if(!tempstack.empty()){\r\n            temp=tempstack.top();\r\n            tempstack.pop();\r\n        }\r\n        else{\r\n            while(!mainstack.empty()){\r\n                temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }\r\n            temp=tempstack.top();\r\n            tempstack.pop(); \r\n        }  \r\n        return temp;\r\n    }\r\n    \r\n    int peek() {\r\n        if(!tempstack.empty()) return tempstack.top();\r\n        else{\r\n            while(!mainstack.empty()){\r\n                int temp=mainstack.top();\r\n                mainstack.pop();\r\n                tempstack.push(temp);\r\n            }   \r\n            return tempstack.top();\r\n        }\r\n    }\r\n    \r\n    bool empty() {\r\n        if(mainstack.empty()&&tempstack.empty()) return true;\r\n        return false;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push O(1)，pop O(N) 其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ringo1597":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298406546","body":"### 代码(java)\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300208592","body":"### 代码\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Description: 821. 字符的最短距离\n * 两次遍历\n * @author: scott\n * @date: 2022年11月02日 19:45\n */\npublic class DayTwo821 {\n\n    public static void main(String[] args) {\n        String s = \"loveleetcode\";\n        //  测试结果\n        int[] es = shortestToChar(s, 'e');\n        System.out.println(Arrays.toString(es));\n    }\n\n\n    public static int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                idx = i;\n            }\n            ans[i] = Math.min(ans[i], idx - i);\n        }\n        return ans;\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301722550","body":"### 代码\n\n```java\npackage com.kami.leetcode.leetcodejiajia;\n\n/**\n * @Description: 数组模拟栈1381\n * @author: scott\n * @date: 2022年11月03日 13:46\n */\npublic class DayTHREETest1381 {\n\n    int [] stack;\n    int top;\n\n    public DayTHREETest1381(int maxSize){\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x){\n        if(top != stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n\n    public int pop(){\n        if(top == -1){\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n\n    public void increment(int k, int val){\n        int limit = Math.min(k, top + 1);\n        for(int i  = 0; i < limit; ++i){\n            stack[i] += val;\n        }\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brucezhang-utf-8":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298429697","body":"### 思路\nnum和k相加，从个位开始相加，同时记录一个进位变量，将数据放入list,反转即可\n\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //获取K的每一位数，直到K/10=0\n        ArrayList<Integer> res = new ArrayList<Integer>();\n        int i=num.length-1;\n        //记录一个进位变量\n        int carry=0;\n        while(i>=0 || k>0){\n            int a= i>=0?num[i]:0;\n            int sum = a +k%10+carry;\n            carry= sum/10;\n            i--;\n            k=k/10;\n            res.add(sum%10);\n        }\n        if(carry>0){\n            res.add(carry);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299678058","body":"## 思路\n1.遍历字符串，获取到字符 c 的位置，放入List中\n2.定义两个指针，last和next,刚开始last和next相等，当当前指针大于next指针时，将next指向下一个字符位置，last指向上一个字符位置，将当前指针与两个指针的差值最小作为结果集的元素\n\n## 代码\n```java\nclass Solution {\n        public int[] shortestToChar(String s, char c) {\n\n            ArrayList<Integer> es = new ArrayList<>();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    es.add(i);\n                }\n            }\n            int z=0;\n            int next = es.get(z);\n            int last= es.get(z);\n            int[] res = new int[s.length()];\n            for (int j = 0; j < s.length(); j++) {\n                if (j > next && es.size()> ++z) {\n                    last = next;\n                    next=es.get(z);\n                }\n                    res[j] = Math.min(Math.abs(j - next), Math.abs(j - last));\n            }\n            return res;\n        }\n    }\n```\n\n**复杂度分析**\n- 时间复杂度 O(N)\n- 空间复杂度 O(N^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301609830","body":"## 思路\n- 使用数组模拟栈\n- 栈的属性,栈的最大元素个数，栈顶值（用来判断栈中元素是否满了或空了）\n- increment方法：需要比较k值和栈中元素个数\n\n##\n```java\nclass CustomStack {\n        //栈的大小\n        private int maxSize;\n        //使用数组模拟栈\n        private int[] stack;\n        //top=-1\n        private int top = -1;\n\n        public CustomStack(int maxSize) {\n            this.maxSize = maxSize;\n            stack = new int[this.maxSize];\n        }\n\n        public void push(int x) {\n            if (top != stack.length - 1) {\n                stack[++top] = x;\n            }\n        }\n\n        public int pop() {\n            if (top != -1) {\n                return stack[top--];\n            } else {\n                return -1;\n            }\n\n        }\n\n        public void increment(int k, int val) {\n            int m = Math.min(k, top + 1);\n            for (int i = 0; i < m; i++) {\n                stack[i] = stack[i] + val;\n            }\n        }\n    }\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n**复杂度分析**\n- 时间复杂度\n- 空间复杂度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303692208","body":"## 思路\n- 声明两个栈，一个数字栈，一个字符串栈\n- 注意数字可能不是个位数，因此需要累加\n- 遇到[，表明数字结束，将数字加入栈中，同时将空字符串加入栈中，并将数字和字符串记录归0\n- 遇到],pop字符串和数字，按照数字个数组织字符串，并将新的字符串赋给buff\n\n## 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //声明一个栈，存放数字\n        Stack<Integer> stackNum = new Stack<>();\n        //声明一个栈，存放字符\n        Stack<StringBuffer> stackStr = new Stack<>();\n        //记录数字\n        int num=0;\n        StringBuffer buff = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            if(Character.isDigit(s.charAt(i))){\n                num=num*10+s.charAt(i)-'0';\n            }else if(s.charAt(i)=='['){\n                //先将数字入栈\n                stackNum.push(num);\n                //把字符存起来\n                stackStr.push(buff);\n                //数字归0\n                num=0;\n                buff=new StringBuffer();\n\n            }else if(s.charAt(i)==']'){\n                //取出数字栈顶元素\n                Integer pop = stackNum.pop();\n                //取出栈顶的字符栈\n                StringBuffer str = stackStr.pop();\n                for (int j = 0; j < pop; j++) {\n                    str.append(buff.toString());\n                }\n                buff=str;\n            }else{\n                buff.append(s.charAt(i));\n            }\n\n        }\n\n        return buff.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304397283","body":"## 思路\n- 使用两个栈，一个输入栈，一个输出栈\n- push时pop到输入栈；pop或peek时需要将数据从输入栈pop出,push到输出栈，然后再将数据pop或peek\n- empty方法需要判断两个栈都为空\n\n## 代码\n```java\nclass MyQueue {\n     //一个输入栈\n        private Stack inStack;\n     //一个输出栈\n     private Stack outStack;\n    public MyQueue() {\n        this.inStack=new Stack<Integer>();\n        this.outStack=new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        //push时，将数据push近输入栈\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        int res=0;\n        //如果输出栈为空，则可以将数据从输入栈中出栈，入栈到输出栈，再pop\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return Integer.parseInt(outStack.pop().toString());\n    }\n    \n    public int peek() {\n        if(outStack.empty()){\n            while(!inStack.empty()){\n                outStack.push(inStack.pop());\n            }\n        }\n\n          return  Integer.parseInt(outStack.peek().toString());\n\n    }\n    \n    public boolean empty() {\n        if(outStack.empty() && inStack.empty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(1)\n- 空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304819345","body":"## 思路\n- 考虑使用单调栈\n- 当栈为空或者后面的数字大于栈顶值时，需要将当前元素推入栈中；\n- 同时，当后面的元素小于栈顶元素时，需要和栈中所有的元素进行比较，以便判断当前元素是加入上一个块还是把比当前元素大的块都连在一起;\n- 最后，返回栈的大小\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if(stack.empty() || num>=stack.peek()){\n                //如果栈为空，或者当前元素大于等于栈顶元素，将当前元素入栈\n                stack.push(num);\n            }else{\n                //如果新加入的数字小于栈顶元素，则需要判断:是否比倒数第二个块的数字也小，\n                //如果小的话，需要将该块加入到一起，直到它大于以前块的最大值\n                Integer maxValue = stack.pop();\n                while(!stack.empty() && stack.peek()>num){\n                    stack.pop();\n                }\n                stack.push(maxValue);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度:O(N)\n- 空间复杂度:O(N),栈的长度最多为n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luanxing":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298455946","body":"```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n //一开始尝试转为数字逐位相加，没考虑越界问题，部分用例没有通过。参考了题解中的一个答案修改。\nvar addToArrayForm = function(num, k) {\n    const result = [];\n    let i = num.length - 1;\n    while(i>= 0 || k > 0){\n        if(i >= 0){\n            k += num[i];\n            i--;\n        }\n        result.push(k % 10);\n        k = parseInt(k / 10);\n    }\n   \n    return result.reverse();\n};\n//时间复杂度 O(n)\n//空间复杂度 O(1)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298543068","body":"### 思路 \n反向逐位相加\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<>();\n        int add = 0;\n        int sum = 0;\n        for (int i = num.length - 1; i >= 0; --i) {\n            sum = num[i] + k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        while (k > 0) {\n            sum = k % 10 + add;\n            add = sum / 10;\n            sum = sum % 10;\n            k = k / 10;\n            list.add(sum);\n        }\n        if (add > 0) {\n            list.add(add);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300684125","body":"### 思路 \n正向、反向遍历，取最小值\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] cs = s.toCharArray();\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, s.length());\n        int last = -s.length();\n        for (int i = 0; i < s.length(); ++i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], i - last);\n        }\n        last = 2 * s.length();\n        for (int i = s.length() - 1; i >= 0; --i) {\n            if (cs[i] == c) {\n                last = i;\n            }\n            ans[i] = Math.min(ans[i], last - i);\n        }\n        return ans;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组⻓度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihua1997":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298566621","body":"## 思路\n从右至左逐位计算，并将每一位的计算结果更新至新数组\n\n## 复杂度\n时间复杂度 O(max(数组长度，数字位数))\n\n## 解决方案\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        // 创建集合保存最后输出结果\n        List<Integer> res = new ArrayList<>();\n        // 遍历计算每一位的值及进位的值，i表示数组指针，sum表示和，carry表示进位\n        int i = num.length - 1, sum = 0, carry = 0;\n        // 循环条件：两个数有一个没计算完\n        while (i >= 0 || k != 0) {\n            // 数组取一个数字\n            int x = i >= 0 ? num[i]: 0;\n            // 整数取一位数字\n            int y = k != 0 ? k % 10 : 0;\n            // 计算两数和\n            sum = x + y + carry;\n            // 进位计算\n            carry = sum / 10;\n            // 整数砍掉个位\n            k = k / 10;\n            // 数组指针右移\n            i--;\n            // 当前位计算结束\n            res.add(0, sum % 10);\n        }\n        // 若有进位，添加至0索引位\n        if (carry != 0) {\n            res.add(0, carry);\n        }\n        return res;\n    }\n}\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302196513","body":"## 思路\n数组模拟栈，top模拟栈顶\n\n## 代码\n```java\nclass CustomStack {\n    private int[] stack;\n    private int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n\n    public void push(int x) {\n        if (top != stack.length - 1) {\n            top++;\n            stack[top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int popValue = stack[top];\n        --top;\n        return popValue;\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i <limit ; i++) {\n            stack[i] += val;\n\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303713221","body":"## 思路\n模拟栈\n\n## 代码\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304557568","body":"## 思路\n使用一个输入栈一个输出栈模拟队列\n\n## 复杂度分析\npush O(1)\npop O(n)\npeek O(n)\nempty O(1)\n\n## 代码\n```java\nclass MyQueue {\n    // 输入栈\n    private Stack<Integer> a;   // [1, 2, 3]\n    // 输出栈\n    private Stack<Integer> b;   // [3, 2, 1]\n\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n\n    public void push(int x) {\n        a.push(x);\n    }\n\n    public int pop() {\n        // a [1, 2, 3]   -> b [3, 2, 1] -> return b.pop() \n        // a [4] b [3, 2]\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n\n    public int peek() {\n        // 同上\n        if (b.isEmpty()) {\n            while (!a.isEmpty()) {\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n\n    public boolean empty() {\n        // a，b其一不为空即可\n        return a.isEmpty()&&b.isEmpty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304815953","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new ArrayDeque<Integer>();\n        for (int num : arr) {\n            if (stack.isEmpty() || num >= stack.peek()) {\n                stack.push(num);\n            } else {\n                int mx = stack.pop();\n                while (!stack.isEmpty() && stack.peek() > num) {\n                    stack.pop();\n                }\n                stack.push(mx);\n            }\n        }\n        return stack.size();\n    }\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cuizezhou":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298569137","body":"```\nvar addToArrayForm = function(num, k) {\n    //把k转为数组\n    let numK = [];\n    do{\n            numK.unshift(parseInt(k%10));\n            k /= 10;\n        }while(k>=1);\n    //数组k与数组num从右到左逐位相加\n    let res = [];\n    let sum = 0;\n    let i=num.length-1, j=numK.length-1;\n    for(; i>=0 && j>=0; i--,j--){\n        sum = num[i] + numK[j] + sum;\n        if(sum<10){\n            res.unshift(sum);\n            sum = 0;\n        }\n        else {\n            res.unshift(parseInt(sum%10));\n            sum = 1;\n        }\n    }\n    if(i>=0){\n        for(; i>=0 ; i--){\n            num[i] += sum;\n            if(num[i] <10){\n                res.unshift(num[i]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    else if(j>=0){\n        for(; j>=0 ; j--){\n            numK[j] += sum;\n            if(numK[j] <10){\n                res.unshift(numK[j]);\n                sum = 0;\n            }\n            else {\n                res.unshift(0);\n                sum = 1;\n            }\n        }\n    }\n    if(sum === 1) res.unshift(sum);\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300557981","body":"```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let length = s.length;\n    let res = new Array(length).fill(0);\n    for(let i=0,idx = -length;i<length; i++){\n        if(s[i] === c) idx = i;\n        res[i] = i - idx;\n    }\n    for(let j=length-1, idx = 2*length; j>=0; j-- ){\n        if(s[j] === c) idx = j;\n        res[j] = Math.min(res[j], idx-j);\n    }\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298573753","body":"\r\n### 思路\r\n\r\n本质是模拟加法的过程，用一个循环来实现，循环次数为Max(num1Len,num2Len),\r\n循环里面用下标去找到本次循环要相加的两个数，注意各用一个值标识数组的下标，要加防空，计算出当前位和进位，并更新下一次循环要用到的进位。循环结束后要判断是否需要进位\r\n\r\n#### 模板\r\n\r\n\r\n```JS\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      //根据下标找到,注意防空\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n     // 和 = A 的当前位 + B 的当前位 + 进位carry\r\n      const sum = x + y + carry\r\n      res.push(sum % 10) //当前位\r\n      carry = Math.floor(sum / 10) //进位\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  //判断还有进位吗,进位不为 0 ,加在目标值前面\r\n  if (carry) res.push(carry)\r\n```\r\n\r\n  \r\n### 代码\r\n\r\n```js\r\n var addToArrayForm = function(num1, num2) {\r\n  const res = [],num2Arr=[...num2.toString()].map((i)=>parseInt(i))\r\n  let i1 = num1.length - 1\r\n  let i2 = num2Arr.length - 1\r\n  let carry = 0\r\n  while (i1 >= 0 || i2 >= 0) {\r\n      const x = i1 >= 0 ? num1[i1] : 0\r\n      const y = i2 >= 0 ? num2Arr[i2] : 0\r\n\r\n      const sum = x + y + carry\r\n      res.push(sum % 10)\r\n      carry = Math.floor(sum / 10)\r\n\r\n      i1--\r\n      i2--\r\n  }\r\n  if (carry) res.push(carry)\r\n  return res.reverse()\r\n};\r\n```\r\n### 复杂度\r\n时间复杂度：O(Math.max(M+N)) 两个长度中的最大值 其实就是 O(N)\r\n\r\n空间复杂度：O(1) 只保存了常量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300653737","body":"##### 思路\n用变量prevC记录c的下标,初始值为无穷大,当s[i]=c时更新preC=i\n遍历字符串,将非c的字符串存入临时栈中,当遇到c时,依次计算栈中字符串到当前c以及prevC的最小距离,注意针对C非S最后一个字符串的情况,需要再清空下临时栈\n##### 代码\n```js\nvar shortestToChar = function (S, C) {\n  let arr = [],\n    prevC = -Infinity,\n    map = [];\n  //清空暂存栈\n  function clear(prev, next = Infinity) {\n    for (const targetIndex of map) {\n      const Index = Math.min(Math.abs(targetIndex - prev), Math.abs(targetIndex - next));\n      arr.push(Index);\n    }\n    map = [];\n  }\n  for (let index = 0; index < S.length; index++) {\n    const ele = S[index];\n    if (ele === C) {\n      clear(prevC, index);\n      arr.push(0);\n      prevC = index;\n    } else {\n      map.push(index);\n    }\n  }\n  if (map.length > 0) {\n    clear(prevC);\n  }\n  return arr;\n};\n```\n##### 复杂度\n时间复杂度：$O(N)$, N 为S数组长度。\n空间复杂度：$O(N)$, N 为S数组长度。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301521004","body":"#### 思路\r\n两种做法:\r\n- 常规遍历\r\n- 运用辅助栈,空间换时间，用一个 O(M)的 hashtable 来记录所有 increment 的操作，\r\n在要 pop 的时候把操作对弹出栈的值进行运算,并且要更新辅助栈\r\n\r\n#### 复杂度\r\n\r\n1. 常规遍历\r\n时间复杂度：O(N) \r\n空间复杂度：O(1)\r\n\r\n2.  辅助栈\r\n时间复杂度：O(1)\r\n空间复杂度：O(N)\r\n\r\n#### 代码\r\n\r\n```\r\nvar CustomStack = function (maxSize) {\r\n  this.list = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.list.length < this.maxSize) {\r\n      this.list.push(x)\r\n  }\r\n};\r\n\r\n1.\r\n/**\r\n* @return {number}\r\n*/\r\nCustomStack.prototype.pop = function () {\r\n  return this.list.length ? this.list.pop() : -1\r\n};\r\n\r\n/** \r\n* @param {number} k \r\n* @param {number} val\r\n* @return {void}\r\n*/\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let min = Math.min(k, this.list.length)\r\n  for (let index = 0; index < min; index++) {\r\n      this.list[index] += val\r\n  }\r\n};\r\n\r\n\r\n2.\r\nCustomStack.prototype.pop = function() {\r\n  if(this.stack.length < 1) return -1; //如果长度为0，返回-1\r\n  let curLastIndex = this.stack.length - 1; //现在即将要被pop出去的元素的index\r\n  let last = this.stack.pop(); //last = 被pop的\r\n  if(this.record.has(curLastIndex)){ //如果record有这个index的操作记录\r\n    let temp = this.record.get(curLastIndex) //让temp等于这个index的增加的总值\r\n    last += temp //加到last上去\r\n    //调整相关记录\r\n    this.record.set(curLastIndex - 1, (this.record.get(curLastIndex - 1) || 0 ) + temp )\r\n    //删除已经用过的记录\r\n    this.record.delete(curLastIndex)\r\n  }\r\n\r\n  return last;\r\n};\r\n\r\nCustomStack.prototype.increment = function(k, val) {\r\n  let index = k > this.stack.length - 1 ? this.stack.length - 1 : k - 1;\r\n  this.record.set(index, (this.record.get(index) || 0) + val)\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303300530","body":"### 思路\r\n循环 + 栈\r\n- 遇到字母块 (lz)、数字时，入栈；\r\n- 遇到 [ 时，入栈，用来标识当前进入一个模板解析了；\r\n- 遇到 ] 时，说明当前模板遍历完了，我们可以开始解析了。**开始出栈**，把出栈的字母块都拼接起来，等出栈到 [ 时，说明当前模板解析完成了。**继续出栈一个元素，这个元素就是当前模板要重复的次数**，**把\"字母块 * 次数\"后推入栈中**。之所以要推入栈中是因为模板是可以嵌套的，当前模板的外层可以还是一个模板，所以我们要把结果放回去，继续解析外层的模板。\r\n### 代码\r\n```\r\n\r\n/*\r\n * @lc app=leetcode.cn id=394 lang=javascript\r\n *\r\n * [394] 字符串解码\r\n */\r\n\r\n// @lc code=start\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\n var decodeString = function (s) {\r\n  const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n  const stack = [];\r\n  const peek = () => stack[stack.length - 1]; // p.s. 不正经栈\r\n\r\n  while (reg.lastIndex < s.length) {\r\n      let token = reg.exec(s)[0];\r\n      if (token !== ']') {\r\n          // 数字，字母，左括号通通入栈\r\n          stack.push(token);\r\n      } else {\r\n          // 遇到右括号就开始出栈\r\n          let str = '';\r\n          // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n          while (peek() !== '[') {\r\n              str = stack.pop() + str;\r\n          }\r\n          // 丢掉左括号\r\n          stack.pop();\r\n          // 左括号前面的一定是模式重复的次数\r\n          const num = +stack.pop();\r\n          // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n          stack.push(str.repeat(num));\r\n      }\r\n  }\r\n  return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：$O(S)$，S 是解析后字符串的长度。\r\n空间复杂度：$O(S)$，S 是解析后字符串的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304537012","body":"\n\n#### 思路\ninStack: 写栈，入队列时存储数据于此\n\noutStack：出栈，需要出队列时将inStack的数据依次出栈后入栈到此；出栈的尾部就是入栈的头部，因而出队列就是出栈的尾部，直接pop\n\n**注意:**: 栈2为空才能补充栈1的数据，否则会打乱当前的顺序。\n\n#### 复杂度\n时间复杂度：时间复杂度均摊为 O(1) push 和 empty 都是 1， pop 和 peek 均摊是 1，对于每个元素之多入栈和出栈两次\n时间复杂度：O(N)，其中 N 为 栈中元素个数，因为每次我们都要倒腾一 次。\n\n\n空间复杂度：O(N)，其中 N 为 栈中元素个数，多使用了一个辅助栈，这 个辅助栈的大小和原栈的大小一样。\n\n\n\n#### 代码\n```js\nvar MyQueue = function () {\n    this.inStack = [];\n    this.outStack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (this.outStack.length === 0) {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack[this.outStack.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\nreturn this.outStack.length===0 && this.inStack.length===0\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304806767","body":"### 768 最多能完成的排序块\r\n\r\n#### 思路\r\n\r\n后面块中的最小值一定大于前面块的最大值,这样才能保证分块有（即局部递减，整体递增）。因此直观上，我们又会觉得是不是”只要后面有较小值，那么前面大于它的都应该在一个块里面“，实际上的确如此。 因而这里，栈只需要保存该块中最大值就可以了。（将一个减序列压缩合并成最该序列的最大的值）\r\n\r\n#### 代码\r\n\r\n```js\r\n/**\r\n * @param {number[]} arr\r\n * @return {number}\r\n */\r\nvar maxChunksToSorted = function(arr) {\r\n\r\n  const stack=[];\r\n  for (const ele of arr) {\r\n    const cur=stack[stack.length-1]\r\n    if(stack.length>0 &&  cur>ele){\r\n      while(stack.length>0 && stack[stack.length-1] > ele){\r\n        stack.pop();\r\n      }\r\n      stack.push(cur)\r\n    }else{\r\n      stack.push(ele)\r\n    }\r\n  }\r\n  return stack.length\r\n};\r\n```\r\n\r\n\r\n\r\n#### 复杂度\r\n\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)，其中 N 为数组长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiandao043":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298583857","body":"## 思路\r\n大模拟，注意进位和数比数组大的情况，处理边界\r\n\r\n## 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n         int t = k % 10;\r\n         int f=0;\r\n         for(int i = num.size(); i > 0 && (k||f); i--){\r\n             t = k % 10;\r\n             k /= 10;\r\n             if(t+num[i-1]+f>=10){\r\n                 num[i-1]=(t+num[i-1]+f)%10;\r\n                 f=1;\r\n                 }\r\n                 else{\r\n                     num[i-1]=t+num[i-1]+f;\r\n                     f=0;\r\n                     }\r\n            }\r\n            // 对数字较长情况\r\n            if(k){               \r\n                while(k){\r\n                    num.emplace(num.begin(), (k%10+f)%10);\r\n                    if((k%10+f)>=10)f=1;\r\n                    else f=0;\r\n                    k/=10;\r\n                }\r\n            }\r\n            // 对首位进位情况\r\n            if(f){\r\n                 num.emplace(num.begin(), f);\r\n            }       \r\n        return num;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n+ 时间为O(n）\r\n+ 空间为O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299885137","body":"### 思路\n\n记录出现的下标，对字符串的字符进行处理，相同为0，不同跟两头比，注意左右边界。\n\n### 代码\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        for(int i=0;i<s.length();i++){\n            if(c==s[i]){\n                ans.push_back(i);\n            }\n        }\n        vector<int> ansl;\n        int p=0,l=-1;\n        for(int i=0;i<s.length();i++){\n            if(p<ans.size() && i==ans[p]){\n                ansl.push_back(0);\n                l=p;\n                p++;                \n            }else if(p<ans.size() && l!=-1){                     \n                ansl.push_back(min(abs(i-ans[p]),abs(i-ans[l])));\n            }else if(p<ans.size() && l==-1){            \n                ansl.push_back(ans[p]-i);\n            }else if(p>=ans.size()){               \n                ansl.push_back(i-ans[l]);\n            }\n        }\n        return ansl;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301646705","body":"### 思路1\n模拟，应该用数组维护top，偷懒用的了vector\n\n### 代码1\n```c++\nclass CustomStack {\npublic:\n    vector <int> a;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);}\n\n    }\n    \n    int pop() {       \n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        return t;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k && i<a.size();i++){\n            a[i]+=val;\n        }\n    }\n};\n```\n\n### 复杂度\n+ Time O(N)\n+ Space O(N)\n\n### 思路2\n维护一个add数组，因为只有pop的时候需要最终值，inc的时候记录增加值的位置，+=val，注意pop时这个值会影响到后面记得传递一位。\n使用top效率会更高，偷懒用了back()。\n\n### 代码2\n```c++\nclass CustomStack {\npublic:\n    vector <int> a, add;\n    int max;\n    CustomStack(int maxSize) {\n        max=maxSize;\n        //add.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if(a.size()>=max){}\n        else{\n        a.push_back(x);\n        add.push_back(0);\n        }\n    }\n    \n    int pop() {\n        if(a.empty())return -1;\n        int t=a.back();\n        a.pop_back();\n        t+=add.back();\n        int acc=add.back(); \n        add.pop_back();       \n        if(add.empty()){}\n        else{\n            add.back()+=acc;\n        }        \n        return t;\n    }\n    \n    void increment(int k, int val) {\n        int lim=k<a.size()?k:a.size();\n        if(lim>0){\n            if(k<a.size()){\n                add[k-1]+=val;\n            }else{\n                add.back()+=val;\n            }\n        } \n    }\n};\n```\n### 复杂度\n+ Time O(1)\n+ Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303772828","body":"### 思路\r\n模拟，第一次想错了，用一个栈装数一个栈装字母，结果处理不了嵌套后两个右半括号之间有字母的情况，一直企图缝缝补补，发现得记录数字和字母是否在同一级，企图每个栈里面加pair 的 int 修补。\r\n后看了题解，其实将数字和字母装进同一格即可，理论上pair修补也行，但不是正道。\r\n递归也可以做（编译原理）题解版本。\r\n### 代码 (误）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string ans;\r\n        int l=0,r=0;\r\n        int ls=0,rs=0;\r\n        vector<pair<int,int>> num;\r\n        vector<pair<int,string>> str;\r\n        int endnum=-1;\r\n        int cnt=0;\r\n        int flag=-1; // -1初始，1 num，2 alpha,[ 3,] 4\r\n        for(int i=0;i<s.length();i++){\r\n            if(num.empty()&&isalpha(s[i])){\r\n                ans+=s[i];\r\n            }\r\n            if(isdigit(s[i])){\r\n                if(flag!=1){\r\n                    if(flag==2){                        \r\n                        rs=i;\r\n                        pair <int,string> pi;\r\n                        pi.first=cnt;\r\n                        pi.second=s.substr(ls,rs-ls);                        \r\n                        str.push_back(pi);\r\n                    }\r\n                    l=i;\r\n                    // cout<<l<<endl;\r\n                    flag=1;\r\n                }      \r\n            }else if(isalpha(s[i])){\r\n                if(flag!=2){                    \r\n                    ls=i;\r\n                    flag=2;\r\n                }\r\n            }else if(s[i]=='['){\r\n                r=i;\r\n                int ss=stoi(s.substr(l,r-l)); \r\n                pair<int,int> pp;\r\n                pp.first=cnt;\r\n                pp.second=ss;               \r\n                num.push_back(pp);\r\n                cnt++;                \r\n                ls=i+1;\r\n                flag=3;\r\n            }else if(s[i]==']'){ \r\n                cnt--;               \r\n                endnum=i;      \r\n                rs=i;\r\n                pair <int,int> ti;                \r\n                ti=num.back(); \r\n                int time=ti.second;              \r\n                num.pop_back();                    \r\n                if(!num.empty()){\r\n                    if(flag==4){                        \r\n                        string aa;\r\n                        string sstr=str.back().second;\r\n                        // str.pop_back();\r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=sstr;\r\n                        }\r\n                        string te=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        cout<<te+aa<<endl;\r\n                        \r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                        ls=i+1;\r\n                    }else{\r\n                         \r\n                        string ss=s.substr(ls,rs-ls);                        \r\n                        string aa;\r\n                        // str.pop_back();\r\n                        \r\n                        for(int j=0;j<time;j++){                    \r\n                            aa+=ss;\r\n                        }\r\n                        // cout<<aa<<endl;\r\n                        string te=str.back().second;\r\n                        int ttt=str.back().first;\r\n                        str.pop_back();\r\n                        pair <int,string> ppp;\r\n                        ppp.first=ttt;\r\n                        ppp.second=te+aa;\r\n                        str.push_back(ppp);\r\n                    }\r\n                }\r\n                else{\r\n                    cout<<\"!!!!\"<<i<<endl;                   \r\n                    if(flag==4){\r\n                        string acc=str.back().second;\r\n                        int tt=str.back().first;\r\n                        str.pop_back();\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=acc;\r\n                        }\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                    }else{                                                                \r\n                        string ss=s.substr(ls,rs-ls);\r\n                        cout<<ss<<endl;\r\n                        cout<<cnt<<endl;\r\n                        string str1;\r\n                        for(int j=0;j<time;j++){                    \r\n                            str1+=ss;\r\n                        }\r\n                        \r\n                        string str2;\r\n                        if(!str.empty()){\r\n                            str2=str.back().second;\r\n                            int ttt=str.back().first;\r\n                            str.pop_back();\r\n                        }               \r\n                            // str.push_back(str2+ss);\r\n                        str1=str2+str1;\r\n                        pair <int,string> ppp;\r\n                        ppp.first=cnt;\r\n                        ppp.second=str1;\r\n                        str.push_back(ppp);\r\n                        cout<<str1<<endl;                                            \r\n                    }                   \r\n                }\r\n                flag=4;       \r\n            }\r\n        }\r\n        // for(int i=0;i<num.size();i++){\r\n        //     cout<<num[i]<<endl;\r\n        // }\r\n        // for(int i=0;i<str.size();i++){\r\n        //     cout<<str[i]<<endl;\r\n        // }\r\n        ans=str.back().second;\r\n        if(endnum+1 < s.length()){\r\n            string endstr=s.substr(endnum+1,s.length()-endnum);\r\n            // cout<<endstr<<endl;\r\n            ans+=endstr;\r\n        }        \r\n        return ans;\r\n    }\r\n};\r\n```\r\n### 代码\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        int ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                int i;\r\n                for(i=ptr;i<s.size()&&isdigit(s[i]);i++){}\r\n                string digits = s.substr(ptr,i);\r\n                ptr=i;\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n\r\n```\r\n\r\n### 代码（递归）\r\n``` c++\r\nclass Solution {\r\npublic:\r\n    string src; \r\n    size_t ptr;\r\n\r\n    int getDigits() {\r\n        int ret = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            ret = ret * 10 + src[ptr++] - '0';\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString() {\r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            // String -> EPS\r\n            return \"\";\r\n        }\r\n\r\n        char cur = src[ptr]; int repTime = 1;\r\n        string ret;\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits [ String ] String\r\n            // 解析 Digits\r\n            repTime = getDigits(); \r\n            // 过滤左括号\r\n            ++ptr;\r\n            // 解析 String\r\n            string str = getString(); \r\n            // 过滤右括号\r\n            ++ptr;\r\n            // 构造字符串\r\n            while (repTime--) ret += str; \r\n        } else if (isalpha(cur)) {\r\n            // String -> Char String\r\n            // 解析 Char\r\n            ret = string(1, src[ptr++]);\r\n        }\r\n        \r\n        return ret + getString();\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n};\r\n```\r\n### 复杂度\r\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466309","body":"### 代码\n``` c++\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    vector<int> ans,vc;\n    int f;\n    MyQueue() {\n        f=-1;\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        if(vc.empty())f=x;\n        vc.push_back(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        int t;  \n        if(ans.empty()){\n            while(!vc.empty()){\n                t=vc.back();\n                ans.push_back(t);\n                vc.pop_back();\n                printf(\"%d\\n\",t);\n            }\n        }      \n        \n        t=ans.back();               \n        ans.pop_back();//printf(\"!!!\\n\"); \n        if(!ans.empty())f=ans.back();\n        return t;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        return f;\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return vc.empty()&&ans.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304751977","body":"### 思路 1\n计数，本来想开数组桶排序，有点大，就map，只要这一节和排好序的一节拥有同样元素的同样个数，既可作为一块。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int ans=0;\n        vector<int> s(arr);\n        map<int,int> m;\n        sort(s.begin(),s.end());\n\n        for(int i=0;i<arr.size();i++){\n            m[arr[i]]++;\n            m[s[i]]--;\n            if(m[arr[i]]==0){\n                m.erase(arr[i]);\n            }\n            if(m[s[i]]==0){\n                m.erase(s[i]);\n            }\n            if(m.size()==0){\n                ans++;\n            }\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度\n+ 时间 O(nlogn)\n+ 空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"restlessbreeze":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298592412","body":"### 思路\r\n\r\n先判断结果数组的长度，之后将k与num逆序按位相加取余后放到结果数组。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        if (k == 0)\r\n            return num;\r\n\r\n        string kstr = to_string(k);\r\n        int len = max(num.size(), kstr.size());\r\n        vector<int> result(len+1,0);\r\n\r\n        int a, b;\r\n\r\n        for(int i = num.size() - 1; i >= 0; i--)\r\n        {\r\n            a = num[i];\r\n            k += a;\r\n            b = k % 10;\r\n            result[len--] = b;\r\n            k /= 10;\r\n        }\r\n        if (k)\r\n        {\r\n            while (k > 9)\r\n            {\r\n                b = k % 10;\r\n                result[len--] = b;\r\n                k /= 10;\r\n            }\r\n            result[len--] = k;\r\n        }\r\n        if(!result[0]) result.erase(result.begin());\r\n        return result;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300551765","body":"### 思路\r\n\r\n先遍历一次字符串，将所有字符出现位置的下标放到一个新数组；之后再便利一次数组，找到每个字符与数组所有出现位置的距离的最小值。\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> c_position;\r\n        vector<int> res(n, n);\r\n\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n                c_position.push_back(i);\r\n        } \r\n        int dist;\r\n        for (int i = 0; i < n; i++)\r\n        {\r\n            if (s[i] == c)\r\n            {\r\n                res[i] = 0;\r\n                continue;\r\n            }\r\n            for (int j = 0; j < c_position.size(); j++)\r\n            {\r\n                dist = abs(i - c_position[j]);\r\n                if (dist > res[i]) break;\r\n                else res[i] = dist;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N*K)，其中 K 为字符出现的次数。\r\n- 空间复杂度：O(K)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302216723","body":"### 思路\r\n\r\n使用数组存放栈中的元素。\r\n\r\n### 代码\r\n\r\n\r\n```\r\ntypedef struct SNode CustomStack;\r\nstruct SNode {\r\n    int *data;\r\n    int top;\r\n    int maxsize;\r\n};\r\n\r\n\r\nCustomStack* customStackCreate(int maxSize) {\r\n    CustomStack *Stack = (CustomStack *)malloc(sizeof(CustomStack));\r\n    Stack->data = (int *)malloc(maxSize * sizeof(int));\r\n    Stack->maxsize = maxSize;\r\n    Stack->top = -1;\r\n    return Stack;\r\n}\r\n\r\nvoid customStackPush(CustomStack* obj, int x) {\r\n    if(obj->top < obj->maxsize - 1)\r\n        obj->data[++obj->top] = x;\r\n}\r\n\r\nint customStackPop(CustomStack* obj) {\r\n    if(obj->top > -1)\r\n        return obj->data[obj->top--];\r\n    else\r\n        return -1;\r\n}\r\n\r\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\r\n    if (obj->top <= k - 1)\r\n    {\r\n        for(int i = 0; i <= obj->top; i++)\r\n            obj->data[i] += val;\r\n    }\r\n    else\r\n    {\r\n        for (int i = 0; i < k; i++)\r\n            obj->data[i] += val;;\r\n    }\r\n}\r\n\r\nvoid customStackFree(CustomStack* obj) {\r\n    free(obj->data);\r\n    free(obj);\r\n}\r\n\r\n/**\r\n * Your CustomStack struct will be instantiated and called as such:\r\n * CustomStack* obj = customStackCreate(maxSize);\r\n * customStackPush(obj, x);\r\n \r\n * int param_2 = customStackPop(obj);\r\n \r\n * customStackIncrement(obj, k, val);\r\n \r\n * customStackFree(obj);\r\n*/\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push 和 pop 的时间复杂度为 O(1)， increment 的时间复杂度为 O(min(k, cnt))。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303645062","body":"### 思路\r\n\r\n通过栈实现。\r\n\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack <int> nums;\r\n        stack <string> strs;\r\n        int num = 0;\r\n        int len = s.size();\r\n        for(int i = 0; i < len; ++ i)\r\n        {\r\n            if(s[i] >= '0' && s[i] <= '9')\r\n            {\r\n                num = num * 10 + s[i] - '0';\r\n            }\r\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                res = res + s[i];\r\n            }\r\n            else if(s[i] == '[')\r\n            {\r\n                nums.push(num);\r\n                num = 0;\r\n                strs.push(res); \r\n                res = \"\";\r\n            }\r\n            else\r\n            {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j)\r\n                    strs.top() += res;\r\n                res = strs.top(); \r\n                strs.pop();\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304766593","body":"### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int> nums;\r\n        int maxNum = 0;\r\n        for (int i = 0; i < arr.size(); i++) {\r\n            if (nums.empty() || nums.top() <= arr[i]) {\r\n                nums.push(arr[i]);\r\n            } else {\r\n                maxNum = nums.top();\r\n                nums.pop();\r\n                while (!nums.empty() && nums.top() > arr[i]) {\r\n                    nums.pop();\r\n                }\r\n                nums.push(maxNum);\r\n            }\r\n        }\r\n        return nums.size();\r\n    }\r\n};\r\n\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruikiwi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298597962","body":"## Intuition\nsimilar to add two numbers\n\n## Code\n\n```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        for (int i = num.size() - 1; i >= 0 && k > 0; i--) {\n                    num[i] += k;\n                    k = num[i] / 10;\n                    num[i] %= 10;\n                }\n        while (k) {\n            num.insert(num.begin(), k % 10);\n            k /= 10;\n        }\n\n        return num; \n    }\n};\n```\n\n## Complexity\n- Time: O(N) N = max(len(k), len(num))\n- Space: O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303730976","body":"### Idea\nStack\n\n### Code\n\n\n```\n\nclass Solution(object):\n    def decodeString(self, s):\n        stack = []; curNum = 0; curString = ''\n        for c in s:\n            if c == '[':\n                stack.append(curString)\n                stack.append(curNum)\n                curString = ''\n                curNum = 0\n            elif c == ']':\n                num = stack.pop()\n                prevString = stack.pop()\n                curString = prevString + num*curString\n            elif c.isdigit():\n                curNum = curNum*10 + int(c)\n            else:\n                curString += c\n        return curString\n```\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huiminren":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600475","body":"python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        return str(int(''.join(map(str,A)))+K)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1301983242","body":"### 题目\r\n[LC821 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n\r\n### 思路一\r\n    1. 遍历一次把所有c的index找出来存成一个list\r\n    2. s中的每一个与c_list 求绝对值，取最小\r\n\r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        c_ls = []\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                c_ls.append(i)\r\n\r\n        ans = []\r\n        for i, val in enumerate(s):\r\n            tmp = []\r\n            for j in c_ls:\r\n                tmp.append(abs(j-i))\r\n            ans.append(min(tmp))\r\n\r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(N2)\r\n    空间复杂度 O(n)\r\n    \r\n### 思路二\r\n    1. 绝对值 --> 双指针，左右遍历\r\n    2. 大小比较时先设定inf\r\n    3. 左右遍历时记得顺序\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = []\r\n        tar = float('-inf')\r\n        for i, val in enumerate(s):\r\n            if val == c:\r\n                tar = i\r\n            left.append(i - tar)\r\n        \r\n        right = []\r\n        tar = float('inf')\r\n        for i in range(len(s)-1,-1,-1):\r\n            if s[i] == c:\r\n                tar = i\r\n            right.append(min(tar - i, left[i]))\r\n\r\n        return right[::-1]\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301982795","body":"### 题目\r\n[LC1381设计栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n### 思路\r\n按要求操作\r\n\r\n### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.stack[-1]\r\n            del self.stack[-1]\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > len(self.stack):\r\n            for i in range(len(self.stack)):\r\n                self.stack[i]+=val\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 push O(1), pop O(1), increment O(min(maxSize,k))\r\n    空间复杂度 O(maxSize)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304398312","body":"### 题目\r\n[LC394 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### 思路一\r\n    括号匹配\r\n    入栈，遇到右括号出栈，记录str，左侧加value，直到遇到左括号\r\n    重复数字n次，入栈\r\n    所有数据出栈合并\r\n    ------------\r\n    错误点，数字不仅是10以内的数\r\n    \r\n### 代码一\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] == ']':\r\n                tmp = ''\r\n                while stack[-1] != '[':\r\n                    tmp = stack[-1] + tmp\r\n                    stack.pop()\r\n\r\n                stack.pop() # 去掉 [\r\n                # 获取数字\r\n                repeat,e = 0,0\r\n                while len(stack)>0 and stack[-1].isdigit():\r\n                    repeat += int(stack[-1]) * (10**e)\r\n                    e += 1\r\n                    stack.pop() # 去掉数字\r\n                stack.append(repeat*tmp)\r\n            else:\r\n                stack.append(s[i])\r\n\r\n        ans = ''\r\n        for v in stack:\r\n            ans += v\r\n        \r\n        return ans\r\n```\r\n\r\n### 复杂度一\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)\r\n\r\n\r\n### 思路二\r\n    逆波兰式，字母一个栈，数字一个栈\r\n    巧妙点：上一个str和下一个要重复次数的数字，存成一个数组\r\n\r\n### 代码二\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        num = 0\r\n        string = ''\r\n        stack = []\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num*10 + int(i)                                \r\n            elif i == '[':\r\n                stack.append((string, num))\r\n                string = ''\r\n                num = 0\r\n            elif i == ']':\r\n                pre, k = stack.pop()\r\n                string = pre + k * string\r\n            elif i.isalpha():\r\n                string += i\r\n        return string\r\n\r\n```\r\n\r\n### 复杂度二\r\n    时间复杂度 O(S)\r\n    空间复杂度 O(S)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304398515","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304809014","body":"### 题目\r\n[LC768 最多能完成排序的块 II](https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n### 思路\r\n    当前数值比后面的都大就不能分块\r\n    栈中留下排序块的最大值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n\r\n        stack = []\r\n        for i in range(len(arr)):\r\n            if stack and arr[i]<stack[-1]:\r\n                head = stack.pop() # 最后一位是最大值\r\n                while stack and arr[i]<stack[-1]: # 为了跟前面的值对比，排序\r\n                    stack.pop()\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n    时间复杂度 O(n)\r\n    空间复杂度 O(n)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saitochen":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298600531","body":"### 思路\r\n先使用`join`方法把数组拍平成字符串，接着转成BigInt进行计算，再转成字符串，使用`split`方法转成数组\r\n\r\n### 代码\r\n\r\n```javascript\r\nvar addToArrayForm = function(num, k) {\r\n    const string = num.join('')\r\n    const sum = String(BigInt(string) + BigInt(k))\r\n    return sum.split('')\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：O(N)\r\n* 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300665137","body":"### 思路\r\n借鉴的官方的答案，自己确实没有思考出来。核心的思路是正反两个方向遍历，将目标点c的位置设置为0；由于在遇到c之前，idx是不存在的。因此官方使用-n（正向遍历）和2n（反向遍历）的初始值。其目的是保证在遇到第一个c之前result[i]足够大，这样在逆向操作时（逆向操作时的result[i]肯定会经过c，因此此时的result[i]是真正的值，所以会通过Math.min筛选出来）。如果还不理解的话，debug一下就清楚了\r\n\r\n### 代码\r\n\r\n```javascript\r\nconst shortestToChar = (strs, c) => {\r\n  let len = strs.length\r\n  const result = new Array(len).fill(0)\r\n  for(let i = 0, idx = -len; i < strs.length; i++) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n    result[i] = i - idx\r\n  }\r\n\r\n  for (let i = len - 1, idx = 2 * len; i >= 0; i--) {\r\n    if (strs[i] === c) {\r\n      idx = i\r\n    }\r\n\r\n    result[i] = Math.min(result[i], idx - i)\r\n  }\r\n\r\n\r\n  return result\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302303781","body":"### 思路\r\njs写很容易，没啥可说的\r\n\r\n### 代码\r\n```javascript\r\nvar CustomStack = function(maxSize) {\r\n    this.len = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.len) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) return this.stack.pop()\r\n    return -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if (this.stack.length < k) {\r\n        sum(this.stack, val)\r\n    } else {\r\n        let len = this.stack.length\r\n        let start = this.stack.slice(0, k)\r\n        let end = this.stack.slice(k, len)\r\n        sum(start, val)\r\n        this.stack = [...start, ...end]\r\n    }\r\n};\r\n\r\nconst sum = (list, val) => {\r\n    for(let i = 0; i < list.length; i++) {\r\n        list[i] = list[i] + val\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间：O(N)\r\n空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wtdcai":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298606440","body":"#### 代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        out = []\n        i = len(num)-1\n        while i >= 0 or k!=0:\n            x = num[i] if i>=0 else 0\n            y = k%10 if k!=0 else 0\n\n            _sum = x+y+carry\n            carry = _sum//10\n            out.append(_sum%10)\n\n            i -=1\n            k = k//10\n        if carry!=0: \n            out.append(1)\n        return out[::-1]\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300599069","body":"#### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        out = [0]*n\n        indx = -n\n        for i,x in enumerate(s):\n            if x==c:\n                indx = i\n            out[i] = i-indx\n        indx = 2*n\n        for j in range(n-1,-1,-1):\n            if s[j]==c:\n                indx = j\n            out[j] = min(indx-j,out[j])\n\n        return out\n```\n#### 复杂度分析\nO(n)  \nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302177151","body":"#### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize-1\n        self.cur = -1\n        self.stack = [-1]*maxSize\n\n    def push(self, x: int) -> None:\n        if  self.cur< self.maxsize:\n            self.cur +=1\n            self.stack[self.cur] = x\n\n    def pop(self) -> int:\n        if self.cur == -1:\n            return -1\n        else:\n            self.cur -= 1\n            return self.stack[self.cur+1]\n\n    def increment(self, k: int, val: int) -> None:\n        minl = min(k,self.cur+1)\n        for i in range(minl):\n            self.stack[i] += val\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n#### 复杂度分析\nO(k)  \nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303605792","body":"#### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, cstr, num = [], \"\", 0\n        for i in s:\n            if \"0\" <= i <= \"9\":\n                num = num*10 + int(i)\n            elif i == \"[\":\n                stack.append((cstr,num))\n                cstr, num = \"\", 0\n            elif i == ']':\n                _cstr,_num = stack.pop()\n                cstr = _cstr + cstr * _num\n            else:\n                cstr += i \n        return cstr\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304378754","body":"#### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout =[]\n\n    def push(self, x: int) -> None:\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stackout:\n            return self.stackout.pop()\n        else:\n            for i in range(len(self.stackin)):\n                self.stackout.append(self.stackin.pop())\n            return self.stackout.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stackout.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stackin or self.stackout)\n```\n#### 复杂度分析\nO(1)  \nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304821843","body":"#### 代码\n``` python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)\n```\n#### 复杂度分析\nO(n)  \nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"albert556":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298616728","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int size = num.size();\n\n        for(int i = size -1;  i >= 0 || k > 0; i--){\n            if(i>=0){\n                k = num[i] + k;\n            }\n            res.push_back(k % 10);\n            k = k / 10;\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300499931","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> index;\n        vector<int> answer(s.length(), s.length());\n        for(int i = 0; i < s.length(); i++){\n            if(c == s[i] ){\n                index.push_back(i);\n            }\n        }\n        for(int i = 0; i < s.length(); i++){\n            for(int j = 0; j < index.size(); j++){\n                int r = abs(i-index[j]);\n                if (r < answer[i]){\n                    answer[i] = r;\n                }\n            }\n        }\n        return answer;\n    }\n};\n时间复杂度：O(m * k)\n空间复杂度：O(m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302284663","body":"class CustomStack {\npublic:\n    int size;\n    int top;\n    vector<int> stack;\n\n    CustomStack(int maxSize) {\n        size = maxSize;\n        stack = vector<int>(maxSize);\n        top = -1;\n    }\n\n    void push(int x) {\n        if(top < size-1){\n            top++;\n            stack[top]=x;\n        }\n        return;\n    }\n\n    int pop() {\n        if(top < 0){\n            return -1;\n        }\n        top--;\n        return stack[top+1];\n    }\n\n    void increment(int k, int val) {\n        for(int i = 0; i < k && i <= top; i++){\n            stack[i] += val;\n        }\n        return;\n    }\n};\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303784300","body":"class Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304384000","body":"class MyQueue {\npublic:\n  vector<int> stdIn;\n  vector<int> stdOut;\n\n  MyQueue() {\n    stdIn = vector<int>();\n    stdIn = vector<int>();\n  }\n\n  void push(int x) {\n    stdIn.push_back(x);\n    if (stdOut.empty()) {\n      auto size = stdIn.size();\n      for (int i = 0; i < size; i++) {\n        stdOut.push_back(stdIn.back());\n        stdIn.pop_back();\n      }\n    }\n  }\n\n  int pop() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    auto res = stdOut.back();\n    stdOut.pop_back();\n    return res;\n  }\n\n  int peek() {\n    if (stdOut.empty()) {\n      if (stdIn.empty()) {\n        throw \"\";\n      } else {\n        auto size = stdIn.size();\n        for (int i = 0; i < size; i++) {\n          stdOut.push_back(stdIn.back());\n          stdIn.pop_back();\n        }\n      }\n    }\n    return stdOut.back();\n  }\n\n  bool empty() {\n    if (stdOut.empty() && stdIn.empty()) {\n      return true;\n    }\n    return false;\n  }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304736581","body":"原数组和有序数组从一端开始遍历，元素出现的频次相同即可分为一组\nclass Solution {\npublic:\n  int maxChunksToSorted(vector<int> &arr) {\n    unordered_map<int, int> cnt;\n    int res = 0;\n    vector<int> sortedArr = arr;\n    sort(sortedArr.begin(), sortedArr.end());\n    for (int i = 0; i < sortedArr.size(); i++) {\n      int x = arr[i], y = sortedArr[i];\n      cnt[x]++;\n      if (cnt[x] == 0) {\n        cnt.erase(x);\n      }\n      cnt[y]--;\n      if (cnt[y] == 0) {\n        cnt.erase(y);\n      }\n      if (cnt.size() == 0) {\n        res++;\n      }\n    }\n    return res;\n  }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wuxiaoshawn":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298627092","body":"### 思路\nK+num（个位加个位，十位加十位）\n个位 除 1 取余10，十位 除10 取余 10，百位 除 100 取余10 \n取余数的反转结果集\n[9,9,9,9,9,9,9,9,9,9] 1,报错，超过了int最大值，要么换long，要么换个思路，取余k，而不是给数组内的值\n\n### 代码\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, long k){\n        int numSize = num.length;\n        //[1,8,9,2]  k = 34  1926\n        ArrayList<Integer> rst = new ArrayList<>();\n        for(int i = numSize - 1 ;i >= 0; --i){\n            //36, 90+36 = 126,126 + 800 = 926,926 + 1000 = 1926\n            k += num[i] * Math.pow(10,numSize - i -1);\n            // 36, 12, 9,1\n            int j = (int) (k / Math.pow(10,numSize - i -1));\n            // 6,2,9,1\n            rst.add(j % 10);\n        }\n        //如果K比数组大，还要继续取余\n//        for (int i = )\n        k /= Math.pow(10,numSize);\n        for (;k>0;k/=10){\n            rst.add((int)(k % 10));\n        }\n        Collections.reverse(rst);\n        return rst;\n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(N)，N为数组的长度，思考：1. N是否可以为K的长度，2. 列表不需要反转\n- 空间复杂度：O(N)，N为集合的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zrtch":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298659136","body":"```\nvar addToArrayForm = function(num, k) {\n    //使用 BigInt是确保当数组足够长的时候，防止整形的精度丢失\n    return (BigInt(num.join('')) + BigInt(k)).toString().split('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299694150","body":"```javascript\nvar shortestToChar = function(s, c) {\n    let res = [], arr = []\n    // 拿到所有c的索引值\n    for(let i = 0; i < s.length; i++){\n        if(s[i] == c) arr.push(i)\n    }\n    // 利用双循环比较绝对距离\n    for(let i = 0; i < s.length; i++){\n        let min = +Infinity\n        for(let j = 0; j < arr.length; j++){\n            min = Math.min(Math.abs(i - arr[j]), min)\n        }\n        res.push(min)\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302201160","body":"```javascript\n/**\n * @param {number} maxSize\n */\nfunction ListNode(val){\n    this.val=val;\n    this.next=null;\n}\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.head=null;\n    this.length=0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.length===this.maxSize) return;\n    let node=new ListNode(x);\n    let linkList=this.head;\n    node.next=linkList;\n    this.head=node;\n    this.length++;\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.length===0) return -1;\n    let linkList=this.head.next;\n    let popVal=this.head.val;\n    this.head=linkList;\n    this.length--;\n    return popVal;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<0) return;\n    let start=this.length-k;\n    let currentNode=this.head;\n    if(start>0){\n        for(let i=0;i<start;++i){\n            currentNode=currentNode.next;\n        }\n    }\n    while(currentNode){\n        currentNode.val+=val;\n        currentNode=currentNode.next;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303743513","body":"```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let r = ''\n    var a = function(t) {\n        const firstClose = t.indexOf(']')\n        if ( firstClose == -1 ) r = t \n        if ( firstClose != -1 ) {\n        const rangeLastOpen =  t.substring(0, firstClose).lastIndexOf('[')\n        var reg = /(\\d+)$/g\n        var z = reg.exec(t.substring(0, rangeLastOpen))\n        if (z) {\n        const zNum = z[0]\n        const changeChars = t.substring(rangeLastOpen + 1, firstClose)\n        const num = parseInt(zNum)\n        let beforechange = ''\n        for(let a = 0; a < num ; a ++) {\n            beforechange += changeChars\n        }\n        const result = t.substring(0, rangeLastOpen - zNum.length) + beforechange + t.substring(firstClose + 1)\n        if (result.indexOf(']') != -1) a(result)\n        if (result.indexOf(']') === -1) r = result\n        }\n        }\n    }\n    a(s)\n    return r;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304554634","body":"```javascript\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop())\n        }\n    }\n    let tmp = this.outStack.pop()\n    this.outStack.push(tmp)\n    return tmp\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.inStack.length && !this.outStack.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304794630","body":"```javascript\nvar maxChunksToSorted = function(arr) {\n    let help = []\n    help[arr.length] = Number.MAX_SAFE_INTEGER\n    for (let i = arr.length - 1; i >= 0; i--) {\n        help[i] = Math.min(arr[i],help[i + 1])\n    }\n    let cnt = 0,mx = -1\n    arr.forEach((val,i) => {\n        mx = Math.max(mx,val)\n        if(mx <= help[i + 1]) cnt++\n    })\n    return cnt\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzhu096":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298679459","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.push_back(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300415798","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n);\n        int k = -n;\n        \n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) k = i;\n            ans[i] =i-k;\n            ;\n    \n        }\n    \n    \n        \n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] == c) k = i;\n            ans[i] = min(ans[i], abs(i - k));\n        }\n        return ans;\n    }\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303523803","body":"class Solution {\npublic:\n    string src; \n    size_t ptr;\n\n    int getDigits() {\n        int ret = 0;\n        while (ptr < src.size() && isdigit(src[ptr])) {\n            ret = ret * 10 + src[ptr++] - '0';\n        }\n        return ret;\n    }\n\n    string getString() {\n        if (ptr == src.size() || src[ptr] == ']') {\n            // String -> EPS\n            return \"\";\n        }\n\n        char cur = src[ptr]; int repTime = 1;\n        string ret;\n\n        if (isdigit(cur)) {\n            // String -> Digits [ String ] String\n            // 解析 Digits\n            repTime = getDigits(); \n            // 过滤左括号\n            ++ptr;\n            // 解析 String\n            string str = getString(); \n            // 过滤右括号\n            ++ptr;\n            // 构造字符串\n            while (repTime--) ret += str; \n        } else if (isalpha(cur)) {\n            // String -> Char String\n            // 解析 Char\n            ret = string(1, src[ptr++]);\n        }\n        \n        return ret + getString();\n    }\n\n    string decodeString(string s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304565205","body":"class MyQueue {\npublic:\n    MyQueue() {\n       \n    }\n     stack<int> A; //用来入队\n     stack<int> B; //用来出队\n    \n    void push(int x) {\n        A.push(x);\n    }\n    \n    int pop() {\n        \n        if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        //B栈不空，直接出栈，表示出队\n        int top = B.top();\n        B.pop();\n        return top;\n    }\n    \n    int peek() {\n         if(B.empty())\n        {\n            while(!A.empty())\n            {\n                B.push(A.top());\n                A.pop();\n            }            \n        }\n        return B.top();\n    }\n    \n    bool empty() {\n        return A.empty() && B.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304801035","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i=0; i<arr.size(); i++){\n\n            if(!stack.empty()&&stack.top()>arr[i]){\n\n                int cur = stack.top();\n            \n            \n                while(!stack.empty()&&stack.top()>arr[i]){\n\n                    stack.pop();\n                }\n                stack.push(cur);\n                }\n            else{\n                stack.push(arr[i]);\n            }\n\n        }\n        return stack.size();\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whoam-challenge":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298682601","body":"#思路\n对于数组A从右到左遍历，整数K也是从右到左遍历，逐位相加，注意需要两个辅助元素，1个记录进位的数，1个记录非进位数\n\n#代码\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        result = []\n        n, carry = len(num) - 1, 0\n        while n >= 0 or k != 0:\n            x = num[n] if n >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            result.append(sum % 10)\n            carry = sum // 10\n\n            n -= 1\n            k //= 10\n        if carry != 0: result.append(carry)\n        return result[::-1]\n\n#复杂度分析\n-时间复杂度 O(N)   【N是数组数组A与K的长度取最大值】\n-空间复杂度 O(N)      \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299663114","body":"#思路\n两次遍历，1）从左到右遍历，找到s中每个字符到其左侧最近的c的距离 2）从右到左遍历，找到s中每个字符到其右侧最近的c的距离\n#代码\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        answer = [0 if s[i]== c else None for i in range(n)]\n        #left\n        idx = -n\n        for i in range(n):\n            if s[i] == c:\n                idx = i \n            answer[i] = abs(i-idx)\n        #right\n        idx = 2*n\n        for i in range(n-1,-1,-1):\n            if s[i] == c:\n                idx = i\n            answer[i] = min(answer[i], idx - i)\n\n        return answer\n\n\n#复杂度分析\n-时间复杂度 O(N)  N是字符串s的长度\n-空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301830289","body":"# 思路\n用数组模拟栈，用top变量来记录栈顶位置。\n\n# 代码\n```python\nclass CustomStack:\n    def __init__(self, maxSize):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x):\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n    \n    def pop(self):\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stack[self.top + 1]\n    \n    def increment(self, k, val):\n        inc_num = min(k, self.top + 1)\n        for i in range(inc_num):\n            self.stack[i] += val\n```\n\n# 复杂度分析\n## 时间复杂度： \npush, pop, 初始化 都是O(1), increment是O(k)\n## 空间复杂度：\nO(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302477429","body":"# 思路：\n利用栈 后入先出的思想\n\n# 代码：\n````python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n        for item in s:\n            if item == '[':\n                stack.append([res, multi])\n                res = \"\"\n                multi = 0\n            elif item == ']':\n                last_res, cur_multi = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <=item <= '9':\n                multi = multi * 10 + int(item)\n            else:\n                 res += item\n        return res\n```\n\n# 复杂度分析\n   -时间复杂度 O(n) n是数组s的长度\n   -空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304539420","body":"232. 用栈实现队列\n#  思路\n栈：后入先出但是队列却是 先入先出，因此要实现队列，需要用两个栈，输入栈 和输出栈。\n把元素push到输入栈之后，输入的顺序会颠倒。因此，需要从输入栈pop，然后push到输出栈，这样顺序就是输入的顺序了，也就是实现了队列。\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        return self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n\n    def empty(self) -> bool:\n        print(self.stack2)\n        print(self.stack1)\n        print(not self.stack2)\n        print(not self.stack1)\n        return not self.stack2 and not self.stack1\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n# 复杂度分析\n-时间复杂度 push和empty 是O(1)  pop and peek 是O(N)\n-空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823907","body":"# 思路\n用一个栈来储存每一个分组的最大值\n\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for a in arr:\n            if len(stack) == 0 or a >= stack[-1]:\n                stack.append(a)\n            else:\n                mx = stack.pop()\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(mx)\n        return len(stack)\n```\n# 复杂度分析\n-时间复杂度 O(n) 因为是遍历，所以时间复杂度是O(n) n是数组长度\n\n-空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298687572","body":"//一开始想复杂了，想着要把array转成数字然后做加法然后再将数字转成array，直到case 9999999999 超过int 范围之后发现这么做不好\r\n\r\n代码：\r\n```\r\n public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int n = num.length;\r\n        List<Integer> list = new ArrayList<Integer>();\r\n        int i = n - 1,sum = 0,carry = 0,remainder = 0;\r\n        while ( (i >= 0)|| k != 0 )\r\n        {\r\n            int origin = i >= 0 ? num[i] : 0;\r\n            remainder = k != 0 ? k % 10 : 0;\r\n            \r\n            sum = origin + remainder + carry;\r\n            carry = sum / 10;\r\n            k = k / 10;\r\n            i--;\r\n            list.add(0,sum%10);\r\n        }\r\n        if(carry!=0)\r\n            list.add(0,carry);\r\n        \r\n        return list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299972946","body":"思路：双指针\r\n代码：\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        Arrays.fill(ans, n);\r\n        int last = -n;\r\n        for(int i = 0; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                for(int j = i; j >= Math.max(0, (i + last - 1) / 2); j--)\r\n                    ans[j] = Math.min(ans[j], i - j);\r\n                last = i;\r\n            } else\r\n                ans[i] = Math.min(ans[i], i - last);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302253415","body":"```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        top--;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303551874","body":"\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n    private String[] dfs(String s, int i) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        while(i < s.length()) {\r\n            if(s.charAt(i) >= '0' && s.charAt(i) <= '9') \r\n                multi = multi * 10 + Integer.parseInt(String.valueOf(s.charAt(i))); \r\n            else if(s.charAt(i) == '[') {\r\n                String[] tmp = dfs(s, i + 1);\r\n                i = Integer.parseInt(tmp[0]);\r\n                while(multi > 0) {\r\n                    res.append(tmp[1]);\r\n                    multi--;\r\n                }\r\n            }\r\n            else if(s.charAt(i) == ']') \r\n                return new String[] { String.valueOf(i), res.toString() };\r\n            else \r\n                res.append(String.valueOf(s.charAt(i)));\r\n            i++;\r\n        }\r\n        return new String[] { res.toString() };\r\n    } \r\n}\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304701683","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        long res = 0, sum1 = 0, sum2 = 0;\r\n        vector<int> expect = arr;\r\n        sort(expect.begin(), expect.end());\r\n        for (int i = 0; i < arr.size(); ++i) {\r\n            sum1 += arr[i];\r\n            sum2 += expect[i];\r\n            if (sum1 == sum2) ++res;\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"syh-coder":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298691583","body":"采用逐位相加，大于10进1\n\nint* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n    int *res = malloc(sizeof(int)* fmax(10,numSize+1));\n    *returnSize = 0;\n    for(int i = numSize -1; i>=0;--i)\n    {\n        int sum = num[i]+k%10;\n        k /= 10;\n        if(sum>=10)\n        {\n            k++;\n            sum -= 10;\n        }\n        res[(*returnSize)++] = sum;\n    }\n    for(;k>0;k /= 10)\n    {\n        res[(*returnSize)++] = k % 10;\n    }\n    for(int i =0;i<(*returnSize)/2;i++)\n    {\n        int tmp = res[i];\n        res[i] = res[(*returnSize)-1-i];\n        res[(*returnSize)-1-i] = tmp;\n    }\n    return res;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaaller":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298710908","body":"var addToArrayForm = function (A, K) {\r\n    const res = []\r\n    let i = A.length - 1;\r\n    while (i >= 0 || K > 0) {\r\n        if (i >= 0) {\r\n            // A[i]有值时，加入\r\n            K += A[i];\r\n            i--;\r\n        }\r\n        // 使用push，然后reverse反转，比unshift稍快\r\n        res.push(K % 10);\r\n        K = parseInt(K / 10);\r\n    }\r\n    return res.reverse();\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300700229","body":"var shortestToChar = function(S, C) {\r\n let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kyrie96521":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298713019","body":"**思路** \r\n一开始想的是大数相加，最后需要按位相加，并考虑到进位情况，\r\n细节点：num长度比k长，或者k的长度比num长度长\r\n```js\r\nvar addToArrayForm = function (num, k) {\r\n  let res = [];\r\n  for (let i = num.length - 1; i >= 0; i--) {\r\n    // 每次都取k的最低位\r\n    let sum = num[i] + (k % 10);\r\n    // 取完一位最低位之后就除10，保证下次取的最低位是倒数第2位\r\n    k = Math.floor(k / 10);\r\n    if (sum >= 10) {\r\n      // 有进位，进位放到k中，这样不仅仅少了一个变量，后面的逻辑也更简化\r\n      k++;\r\n      sum -= 10;\r\n    }\r\n    res.unshift(sum);\r\n  }\r\n  // num中所有数字都加完了之后，如果k中还有剩余再把k的加上\r\n  while (k > 0) {\r\n    res.unshift(k % 10);\r\n    k = Math.floor(k / 10);\r\n  }\r\n  return res;\r\n};\r\n```\r\nO(n)O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300430884","body":"```js\r\n// from xiaoranzi\r\n// n为S的length，m为C在S中的数量\r\n// 时间复杂度：O(nm)O(nm)\r\n// 空间复杂度：O(nm)O(nm)\r\nvar shortestToChar = function (S, C) {\r\n    const res = Array(S.length)\r\n    const indexArr = []\r\n    const maxVal = Infinity;\r\n    // 得到所有的c的坐标位置 存入indexArr\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    // 更新每个位置距离 每个indx坐标的位置\r\n    // 初始值为无穷大，不断更新res[i]元素的值\r\n    for (let i = 0; i < S.length; i++) {\r\n        res[i] = indexArr.reduce((tmp, item) => {\r\n            return Math.min(tmp, Math.abs(i - item))\r\n        }, maxVal)\r\n    }\r\n    return res\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302296378","body":"```js\r\nvar CustomStack = function(maxSize) {\r\n    this.arr = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if( this.arr.length < this.maxSize ) this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if( this.arr.length == 0 ) return -1\r\n    return ( (this.arr).splice(this.arr.length - 1 , 1) )[0]\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    if( this.arr.length < k ){\r\n        for( let i = 0 ; i < this.arr.length ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }else{\r\n        for( let i = 0 ; i < k ; i++ ){\r\n            (this.arr)[i] = (this.arr)[i] + val\r\n        }\r\n    }\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cavecrypto":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298724244","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\".join(list(map(str, num)))\n        return [int(i) for i in str(int(s) + k)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300621317","body":"### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strs = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                strs.append(i)\n        \n        res = []\n        for i, ch in enumerate(s):\n            mini = float('inf')\n            for j in strs:\n                mini = min(mini, abs(i-j))\n            res.append(mini)\n            \n        return res\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304562922","body":"### 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 =[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            for i in range(len(self.stack1)):\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        out = self.pop()\n        self.stack2.append(out)\n        return out\n\n\n    def empty(self) -> bool:\n        return not (self.stack1 or self.stack2)\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304829993","body":"### 思路\n单调栈，维护每个块的最大值\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for num in arr:\n            if not stack or stack[-1] <= num:\n                stack.append(num)\n            else:\n                pivot = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(pivot)\n        return len(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cxgbro":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298727843","body":"```JavaScript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erjian96":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298739620","body":"思路：k从num最后一位开始加，每次除10判断是否进位，再加上对应位置，检查是否进位。\nclass Solution:\n  def addToArrayForm(self,num:List[int],k:int)->List[int]:\n     result=[]\n    for i in range(Len(num)):\n       r=num[len(num)-1-i]+k\n       num[len(num)-1-i]=r%10\n       k=int(r/10)\n      if k==0:\n    break\n  if k!=0;\n  num.insert(0,k)\nreturn num\n时间复杂度是O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300581799","body":"思路：先找到字母的位置，求出所有可能的距离，最后找最小值。\nclass Solution:\n  def shortestToChar(self, s:str, c:str)->List[int]:\n    result=[]\n    c_position=[]\n    for i in range(len(s)):\n      if s[i]==c:\n          c_position.append(i)\n    for i in c_position:\n      for j in range(len(s)):\n        dis=abj(j-i)\n        result.append(dis)\n    result = np.array(result)\n    result = result.reshape(-1,len(s))\n    result1 = np.min(result,axis=0)\n    result = result1.tolist()\n    return result\n复杂度时间O(N)\n    ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302307949","body":"思路：数组写栈 class CustomStack: def__init__(self, maxSize:int): self.stack=[] self.max = maxSize def push(self,x:int)->None: if len(self.stack)<self.max: self.stack.append(x) def pop(self): if len(self.stack)>0: return self.stack.pop() def increment(self,k,val): for i in range(min(k,len(self.stack)): self.stack[i]= self.stack[i]+val\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304831114","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298744285","body":"````c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300709010","body":"````c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302299180","body":"````c++\nclass CustomStack {\n    maxSize:number;\n    cnt:number;\n    stack: Array<number>;\n    incrementInfos: Array<number>;\n\n    constructor(maxSize: number) {\n      this.maxSize = maxSize;\n      this.cnt = -1;\n      this.incrementInfos = new Array(maxSize).fill(0);\n      this.stack = [];\n    }\n\n    push(x: number): void {\n      if (this.cnt < this.maxSize -1) {\n        this.cnt++;\n        this.stack.push(x);\n      }\n    }\n\n    pop(): number {\n      if (this.cnt === -1) return -1;\n      const inc = this.incrementInfos[this.cnt];\n\n      if (inc) {\n        this.incrementInfos[this.cnt] = 0;\n        this.incrementInfos[this.cnt -1] += inc;\n      }\n      this.cnt--;\n      return this.stack.pop() + inc;\n    }\n\n    increment(k: number, val: number): void {\n      let i = k;\n      if (this.cnt < i) i = this.cnt + 1;\n      if (i > 0 ) this.incrementInfos[i - 1] += val;\n    }\n}\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303795708","body":"````c++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n````","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828940","body":"````c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        unordered_map<int, int> cnt;\n        int res = 0;\n        vector<int> sortedArr = arr;\n        sort(sortedArr.begin(), sortedArr.end());\n        for (int i = 0; i < sortedArr.size(); i++) {\n            int x = arr[i], y = sortedArr[i];\n            cnt[x]++;\n            if (cnt[x] == 0) {\n                cnt.erase(x);\n            }\n            cnt[y]--;\n            if (cnt[y] == 0) {\n                cnt.erase(y);\n            }\n            if (cnt.size() == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298751076","body":"思路：把k变成数组\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k:\n                num.insert(0,0)\n                i = 0\n        return num\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300737466","body":"```\n解题思路:双指针\n在遍历的时候记录上一次遇到c的位置，每次先更新距离为到上次遇到c的距离，直到遇到了另一个c。 \n将这个c和上一个c的中点，到这个c之间的点，更新为更近的新的c到它们的距离。\n同时上一个c变成了这个c。\n\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans, last = [inf] * len(s), None\n        for i, ch in enumerate(s):\n            if ch == c:\n                if last is not None:\n                    for j in range(i, (i - 1 + last) // 2 - 1, -1):\n                        ans[j] = min(ans[j], i - j)\n                else:\n                    for j in range(i, -1, -1):\n                        ans[j] = min(ans[j], i - j)\n                last = i\n            elif last is not None:\n                ans[i] = min(ans[i], i - last)\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302300598","body":"```\n使用数组模拟栈，用一个变量 top 记录当前栈顶的位置。\n对于 push ，只要当前元素的个数是没达到上限，就把 top 后移一个位置并添加一个元素。\n对于 pop ，只要当前栈非空，则返回栈顶元素，并将top前移\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n\n\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304828655","body":"```\n单调栈\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n        return len(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298753812","body":"`func addToArrayForm(num []int, k int) []int {\r\n    n := len(num)\r\n    pre,sum:=0,0\r\n    out := []int{}\r\n    for i:=n-1;i>=0||k>0||pre>0;i--{\r\n        if i >= 0{\r\n            sum = num[i]+k%10+pre\r\n        }else{\r\n            sum =k%10 + pre\r\n        }\r\n        pre = sum/10\r\n        k /= 10\r\n        out = append(out,sum%10)\r\n    }\r\n    reverse(out)\r\n    return out\r\n}\r\nfunc reverse(out []int) []int{\r\n    for i:=0;i<len(out)/2;i++{\r\n        out[i],out[len(out)-1-i] = out[len(out)-1-i] , out[i]\r\n    }\r\n    return out\r\n}`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300758564","body":"*代码\r\n\r\n```python \r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302310783","body":"## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            self.size -= 1\r\n            return self.stack.pop(-1)\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        m = min(self.size, k)\r\n        for i in range(m):\r\n            self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303793836","body":"## 代码\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1303910219","body":"## 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304780087","body":"## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1299362003","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num[-1] += k\r\n        for i in range(len(num)-1, -1, -1):\r\n            carry, num[i] = divmod(num[i], 10)\r\n            if i:\r\n                num[i-1] += carry\r\n        if carry:\r\n            num = [int(i) for i in str(carry)] + num\r\n        return num\r\n```\r\ntime O(N) space O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299379101","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        lr = [float('inf')] * len(s)\r\n        rl = [float('inf')] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                lr[i] = 0\r\n            else:\r\n                if i-1 >= 0:\r\n                    lr[i] = lr[i-1] + 1\r\n                else:\r\n                    lr[i] = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                rl[i] = 0\r\n            else:\r\n                if i+1 < len(s):\r\n                    rl[i] = rl[i+1] + 1\r\n                else:\r\n                    rl[i] = float('inf')\r\n        for i in range(len(s)):\r\n            lr[i] = min(lr[i], rl[i])\r\n        return lr\r\n```\r\ntime O(N) space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301125936","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.index = []\r\n        self.curSize = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.curSize < self.maxSize:\r\n            self.stack.append(x)\r\n            self.index.append(0)\r\n            self.curSize += 1\r\n        \r\n    def pop(self) -> int:\r\n        if self.curSize == 0:\r\n            return -1\r\n        else:\r\n            self.curSize -= 1\r\n            inc = self.index.pop()\r\n            if self.curSize > 0:\r\n                self.index[-1] += inc\r\n            return self.stack.pop() + inc\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        s = min(self.curSize, k)\r\n        if s != 0:\r\n            self.index[s-1] += val\r\n```\r\ntime O(1), space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302775657","body":"```\r\nfrom collections import deque\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        k = \"\"\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] in \"0123456789\":\r\n                k += s[i]\r\n            else:\r\n                if k != \"\":\r\n                    n = int(k[::-1])\r\n                    temp = []\r\n                    # pop until ] or end\r\n                    while stack:\r\n                        c = stack.popleft()\r\n                        if c == \"]\":\r\n                            break\r\n                        else:\r\n                            if c != \"[\":\r\n                                temp.append(c)\r\n                    # repeate k time\r\n                    for _ in range(n):\r\n                        # push back\r\n                        for c in temp[::-1]:\r\n                            stack.appendleft(c)\r\n                    # clear k\r\n                    k = \"\"\r\n                stack.appendleft(s[i])\r\n        if k != \"\":\r\n            # repeate\r\n            n = int(k[::-1])\r\n            temp = []\r\n            # pop until ] or end\r\n            while stack:\r\n                c = stack.popleft()\r\n                if c == \"]\":\r\n                    break\r\n                else:\r\n                    if c != \"[\":\r\n                        temp.append(c) \r\n            # repeate k time\r\n            for _ in range(n):\r\n                # push back\r\n                for c in temp[::-1]:\r\n                    stack.appendleft(c)\r\n        return \"\".join(stack)\r\n```\r\ntime O(len(string)) space O(len(string)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304387929","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.push_stack.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        self.peek()\r\n        return self.pop_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        if self.pop_stack or self.push_stack:\r\n            return False\r\n        else:\r\n            return True\r\n```\r\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304744134","body":"```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for val in arr:\r\n            if stack:\r\n                max_val = stack[-1]\r\n                if val < max_val:\r\n                    while stack and val < stack[-1]:\r\n                        stack.pop()\r\n                    stack.append(max_val)\r\n                else:\r\n                    stack.append(val)\r\n            else:\r\n                stack.append(val)\r\n        return len(stack)\r\n```\r\ntimeO(N),  space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bwspsu":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299479938","body":"## Thought: \nSweep from left side, compute the distance.\nThen sweep from right side, compute distance again.\nCompare the results from left and right, and output the min. \n\n## Code:\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # initialization \n        N = len(s)\n        left,right,res = [None] * N, [None] * N, [None] * N\n\n        ind = float('inf')\n        # sweep from left\n        for ii in range(N):\n            if s[ii] == c:\n                ind = ii\n            left[ii] = abs(ind - ii) \n        # sweep from right\n        ind = float('inf')\n        for ii in range(N-1,-1,-1):\n            if s[ii] == c:\n                ind = ii\n            right[ii] = abs(ind - ii)             \n        \n        # take the min of left and right \n        for ii in range(N):\n            res[ii] = min(left[ii],right[ii])\n        \n        return res\n\n```\n\n## Complexity: \nTime complexity: O(n)\n\nSpace complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301595367","body":"## Thought \n\nUse list to work for a stack.\nUse append method for push and pop method for pop.\n## Code \n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n        else:\n            print(\"Max size has been reached!\")            \n\n\n    def pop(self) -> int:\n        if len(self.stack) >=1:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val      \n```\n## Complexity: \n\nTime complexity: O(n)\n\nSpace complexity: O(n)\n\n","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305044968","body":"## Thought:\n1. Find length of linked list n\n2. Linked list will be rotated k%n times\n3. Jump to the pivot:\n           make tne next node new head\n           link the pivot to None\n           link tail to old head\n## Code \n```python3\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        # get the length of the list\n        length = 1\n        tail = head\n        while tail.next:\n            tail = tail.next\n            length += 1\n    \n        k = k % length\n        # no change in this case\n        if k == 0:\n            return head\n        \n        cur = head\n        for i in range(length-k-1):\n            cur = cur.next\n        \n        \n        new_head = cur.next\n        cur.next = None\n        tail.next = head\n        \n        return new_head\n```\n\n## Complexity:\n\nTO: O(n)\n\nSO: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arinzz":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299539108","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mdge":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299576804","body":"var shortestToChar = function(s, c) {\r\n    let num = [],res = []\r\n    for(let i=0;i<s.length;i++){\r\n        if(s[i] === c){\r\n            num.push(i)\r\n        }\r\n    }\r\n    for(let i=0;i<s.length;i++){\r\n        let min = Infinity\r\n        for(let j=0;j<num.length;j++){\r\n            min = Math.min(Math.abs(i-num[j]),min)\r\n        }\r\n        res.push(min)\r\n    }\r\n    return res\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301955903","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.arr = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.arr.length < this.maxSize){\n        this.arr.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.arr.length?this.arr.pop():-1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length)\n    for(let i=0;i<min;i++){\n        this.arr[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304452988","body":"var MyQueue = function() {\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.arr.push(x)\n    return this.arr\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.arr.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.arr[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.arr.length?false:true\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304757577","body":"var maxChunksToSorted = function(arr) {\n    let arr1 = [...arr]\n    let arr2 = arr.sort((a,b)=>a-b)\n    let sum1 = sum2 = sum = 0\n    for(let i=0;i<arr1.length;i++){\n        sum1 += arr1[i]\n        sum2 += arr2[i]\n        if(sum1 === sum2){\n            ++sum\n        }\n    }\n    return sum\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305000850","body":"var rotateRight = function(head, k) {\n    if(!head)return null\n    let newhead = head,ln = 1\n    while(newhead.next){\n        newhead = newhead.next\n        ++ln\n    }\n    let move = ln - k%ln\n    newhead.next = head\n    while(move){\n        newhead = newhead.next\n        --move\n    }\n    let cur = newhead.next\n    newhead.next = null\n    return cur\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"allenfeng666":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299631296","body":"# 思路\r\n用空间换时间,先遍历记录index到 distance set,然后遍历一般根据distance set求最短距离\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        char_set = set()\r\n        res = [-1] * len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                char_set.add(i)\r\n        for j in range(len(s)):\r\n            lowest = float('inf')\r\n            for index in char_set:\r\n                if lowest > abs(index - j):\r\n                    lowest = abs(index - j)\r\n            res[j] = lowest\r\n        return res\r\n```\r\n\r\n\r\n# 复杂度\r\n时间复杂度: O(N) * O(M) , M取决于c出现的次数\r\n空间复杂度: O(M), M取决于c出现的次数\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304550486","body":"```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        \r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yin02":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1299691427","body":"### 思路\n先将字符串中C表示的字符的位置记录下来，然后计算字符串中每一个字符与所有字符C的距离，并求出最小距离\n\n\n\n### 代码\n\n```py\n\n\n\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        loc=[]\n        dis=[]        \n        for i in range(0,len(S)):\n            if S[i]==C:\n                loc.append(i)#记录e在列表中的位置\n        for i in range(0,len(S)):\n            t=[]\n            for j in loc:\n                t.append(abs(i-j))#计算每一个字符和所有C的距离\n            dis.append(min(t))#将最小距离添加到结果数组中\n        return dis\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，\n- 空间复杂度：O(N)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303067731","body":"### 思路\n如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n如果当前的字符为字母或者左括号，直接进栈\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（这个次数和字符串构造出新的字符串并进栈\n\n### 代码\n\n\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n\n\n\n```\n\n**复杂度分析**\n时间复杂度 O(N)，递归会更新索引，因此实际上还是一次遍历 s；\n空间复杂度 O(N)，极端情况下递归深度将会达到线性级别。\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elsa-zhang":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300584266","body":"class Solution(object):\n    def shortestToChar(self, s, c):\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304546499","body":"#  用栈实现队列-python \n## 思路\n添加数据用stack1 append， pop/peek数据时stack1pop到stack2, stack2再pop出来\n```bash\nclass MyQueue():\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n         \n    def push(self, x):\n        self.stack1.append(x)\n    \n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n        \n    def peek(self):\n        val = self.pop()\n        self.stack2.append(val)\n        return val\n        \n    def empty(self):\n        if not self.stack1 and not self.stack2:\n            return True\n        else:\n            return False\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304758987","body":"##768. 最多能完成排序的块 II-python\n\n解法1：排序\n```bash\n\nfrom collections import defaultdict\n\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        count_a = defaultdict(int)\n        count_b = defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n解法2：递增\n```bash\nclass Solution(object):\n    \n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack:\n                if stack[-1] > a:\n                    cur = stack[-1]\n                    while stack and stack[-1] > a:\n                        stack.pop()\n                    stack.append(cur)   \n            else:\n                stack.append(a)\n        return len(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asur4s":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300675274","body":"## 解题思路\r\n\r\n最初思路：先找到第一个 c，并把前面的距离填充好，后面再继续找 c，最后按左右对称来填充。\r\n看了题解：前后两趟遍历（Orz）\r\n\r\n## 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n        vector<int> ans(n);\r\n        int index;\r\n\r\n        index = -2*n; // 保证足够小，i - index 得到一个足够大的数。\r\n        for (int i = 0; i < n; i++) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = i - index;\r\n        }\r\n\r\n        index = 2*n;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s[i] == c) {\r\n                index = i;\r\n            }\r\n            ans[i] = min(ans[i], index - i);\r\n        }\r\n        return ans;\r\n    }\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复制度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302251142","body":"## 思路\n使用 vector 存放\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int top, max;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if (top == max - 1) {\n            return;\n        }else{\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int limit = min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：pop O(0), push O(1), inc O(k)\n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303618337","body":"## 思路\n用栈实现类似计算器的操作\n\n## 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top(); \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304466540","body":"# 思路\r\n\r\n两个栈之间移动元素\r\n\r\n# 代码\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            int x = inStack.top();\r\n            outStack.push(x);\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n    \r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n    \r\n    int peek() {\r\n        if(outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n# 复杂度分析\r\n\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304990179","body":"# 思路\r\n基本思路：\r\n找到关键的 3 个点（断开部分的两个点 p1、p2、尾部节点 p3），利用穿针引线法连接。\r\n\r\n大致步骤：\r\n- 判断边界条件：当 K 为 0，链表长度为 0、1  时不需要旋转。\r\n- 求解移动长度：k = k % len。在这确定尾部节点，设置为 p3。\r\n- 设置快慢指针：让快指针先走 k 步。在这确定断开的两个点，设置为 p1 和 p2。\r\n- 将各个点相连，返回 p2。\r\n\r\n# 算法\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    ListNode* rotateRight(ListNode* head, int k) {\r\n        if(k == 0 || head == nullptr || head->next == nullptr){\r\n            return head;\r\n        }\r\n        int len = 1;\r\n        ListNode *cur = head;\r\n        while(cur->next != nullptr){\r\n            len+=1;\r\n            cur = cur->next;\r\n        }\r\n        k = k % len;\r\n        if(k == 0){\r\n            return head;\r\n        }\r\n\r\n        ListNode *p1, *p2, *p3, *slow, *fast;\r\n        p3 = cur;\r\n\r\n        slow = head;\r\n        fast = head;\r\n        while(k-- > 0){\r\n            fast = fast->next;\r\n        }\r\n\r\n        while(fast->next != nullptr){\r\n            slow = slow->next;\r\n            fast = fast->next;\r\n        }\r\n        p1 = slow;\r\n        p2 = slow->next;\r\n\r\n        p3->next = head;\r\n        p1->next = nullptr;\r\n\r\n        return p2;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlesugarman":[null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1300705109","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int leng = s.length();\r\n        int[] ans = new int[leng];\r\n        for (int i=0, flag=-leng; i<leng; ++i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = i - flag;\r\n        }\r\n        for (int i=leng-1, flag=2*leng; i>=0; --i) {\r\n            if (s.charAt(i)==c) {\r\n                flag = i;\r\n            }\r\n            ans[i] = Math.min(ans[i], flag-i);\r\n        }\r\n        return ans;\r\n    }\r\n\r\n}","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304547233","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> sIn;\r\n    Deque<Integer> sOut;\r\n\r\n    public MyQueue() {\r\n        sIn = new ArrayDeque<Integer>();\r\n        sOut = new ArrayDeque<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        sIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (sOut.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return sOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (sIn.isEmpty() && sOut.isEmpty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!sIn.isEmpty()) {\r\n            int x = sIn.pop();\r\n            sOut.push(x);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304705799","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Deque<Integer> numbers = new ArrayDeque<>();\r\n        for (int i=0; i<arr.length; i++) {\r\n            if (numbers.isEmpty() || numbers.peek() <= arr[i]) {\r\n                numbers.push(arr[i]);\r\n            } else {\r\n                int val = numbers.pop();\r\n                while (!numbers.isEmpty() && numbers.peek() > arr[i]) {\r\n                    numbers.pop();\r\n                }\r\n                numbers.push(val);\r\n            }\r\n        }\r\n        return numbers.size();\r\n    }\r\n}\r\n```\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)\r\n其中 N 为数组长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhihaowan":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1298865077","body":"# 思路 \r\n- List 的长度和 k的长度谁大谁小\r\n- 逐位相加 (Two Number Add)\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int p1 = num.length - 1;\r\n        int sum = 0;\r\n        int carry = 0;\r\n        int a = 0;\r\n        int b = 0;\r\n\r\n        while(p1 >= 0 || k != 0){\r\n            a = p1 >= 0 ? num[p1] : 0;\r\n            b = k != 0 ? (k % 10) : 0;\r\n                \r\n            sum = a + b + carry;\r\n            carry = sum / 10;\r\n            k /= 10;\r\n            \r\n            p1--;\r\n            res.add(0, sum % 10);\r\n        }\r\n\r\n        if(carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n\r\n// Time Complexity: O(n) \r\n// Space Complexity: O(n)\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"apockira":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301181920","body":"class CustomStack {\r\n    \r\n    private int[] arr;\r\n    private int   curr = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (curr+1 < arr.length) {\r\n            arr[++curr] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return curr < 0 ? curr : arr[curr--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < Math.min(k, curr+1); i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guowei0223":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1301632698","body":"class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n \n        \n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n        \n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n        \n        \n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, len(self.stack))):\n            self.stack[i] += val","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304682841","body":"/**\r\n    思路: 维护一个单调递增的stack\r\n    TC: O(N), SC: O(N)\r\n*/\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n          stack = []\r\n          for num in arr:\r\n              if not stack or num >= stack[-1]:\r\n                  stack.append(num)\r\n              else:\r\n                  pop_num = stack.pop()\r\n                  while stack and stack[-1] > num:\r\n                      stack.pop()\r\n                  stack.append(pop_num)\r\n          return len(stack)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuqianyang":[null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302262952","body":"```java\r\npublic class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top =-1;\r\n    }\r\n    public void Push(int x) {\r\n        if(top!=stack.Length-1)\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    public int Pop() {\r\n        if(top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    public void Increment(int k, int val) {\r\n        int limit = Math.Min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i)\r\n        {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n学习一下","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302840545","body":"```java\r\nclass Solution {\r\n    int ptr;\r\n\r\n    public String decodeString(String s) {\r\n        LinkedList<String> stk = new LinkedList<String>();\r\n        ptr = 0;\r\n\r\n        while (ptr < s.length()) {\r\n            char cur = s.charAt(ptr);\r\n            if (Character.isDigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                String digits = getDigits(s);\r\n                stk.addLast(digits);\r\n            } else if (Character.isLetter(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \r\n            } else {\r\n                ++ptr;\r\n                LinkedList<String> sub = new LinkedList<String>();\r\n                while (!\"[\".equals(stk.peekLast())) {\r\n                    sub.addLast(stk.removeLast());\r\n                }\r\n                Collections.reverse(sub);\r\n                // 左括号出栈\r\n                stk.removeLast();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = Integer.parseInt(stk.removeLast());\r\n                StringBuffer t = new StringBuffer();\r\n                String o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime-- > 0) {\r\n                    t.append(o);\r\n                }\r\n                // 将构造好的字符串入栈\r\n                stk.addLast(t.toString());\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer ret = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(ptr))) {\r\n            ret.append(s.charAt(ptr++));\r\n        }\r\n        return ret.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> v) {\r\n        StringBuffer ret = new StringBuffer();\r\n        for (String s : v) {\r\n            ret.append(s);\r\n        }\r\n        return ret.toString();\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304548436","body":"```java\r\nclass MyQueue {\r\n    Deque<Integer> inStack;\r\n    Deque<Integer> outStack;\r\n\r\n    public MyQueue() {\r\n        inStack = new ArrayDeque<Integer>();\r\n        outStack = new ArrayDeque<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (outStack.isEmpty()) {\r\n            in2out();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n\r\n    private void in2out() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304817122","body":"```java\r\npublic class Solution {\r\n\r\n     public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0;\r\n        int nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i];\r\n            int y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) {\r\n                nonzero--;\r\n            }\r\n            if (count.get(x) == 1) {\r\n                nonzero++;\r\n            }\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) {\r\n                nonzero++;\r\n            }\r\n            if (count.get(y) == 0) {\r\n                nonzero--;\r\n            }\r\n\r\n            if (nonzero == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sj941127":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302322956","body":"```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function(num, k) {\r\n    const n = num.length;\r\n    let carry = 0;\r\n    let res = 0;\r\n    let i = n-1;\r\n    let arr = [];\r\n    while(i>=0 || k!=0) {\r\n        const a = i>=0 ? num[i] : 0\r\n        const b = k!=0 ? k%10 : 0;\r\n        res = a+b+carry;\r\n        arr.push(res%10)\r\n        carry = Math.floor(res/10) \r\n\r\n        i--;\r\n        k=Math.floor(k/10);\r\n    }\r\n\r\n\r\n    if(carry) {\r\n        arr.push(carry)\r\n    }\r\n    arr.reverse()\r\n    return arr\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302326047","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let n = s.length;\r\n    let resArr = new Array(n).fill(0);\r\n    for(let i=0, cIndex=-n; i<n; i++){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = i-cIndex;\r\n    }\r\n\r\n    for(let i=n-1, cIndex=2*n; i>=0; i--){\r\n        if(s[i] === c) {\r\n            cIndex = i;\r\n        }\r\n        resArr[i] = Math.min( resArr[i], cIndex - i);\r\n    }\r\n  \r\n    return resArr\r\n};\r\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302485327","body":"'''\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = ''\r\n        stack = []\r\n        cur_num = 0\r\n        \r\n        for i in range(len(s)):\r\n            if s[i].isdigit():\r\n                cur_num = cur_num*10 + int(s[i])\r\n            elif s[i] == '[':\r\n                stack.append((ans,cur_num))\r\n                ans = ''\r\n                cur_num = 0\r\n                \r\n            elif s[i] == ']':\r\n                cur_str, n = stack.pop()\r\n                ans = cur_str + ans *n\r\n            else:\r\n                ans += s[i]\r\n        return ans\r\n'''\r\nO(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304641977","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        #chunk in previous chunk should small than nums in following chunk\n        lowest_right = [-1 for i in range(len(arr))] #each pos store the lowest value on right side\n        maxnum = float('inf')\n        #update to each pos store the lowest value on right side\n        for i in range(len(arr)-1,-1,-1):\n            lowest_right[i] = maxnum\n            maxnum = min(arr[i],maxnum)\n        \n        ans = 0\n        i = 0\n        largest_left = -1\n        while i < len(arr):\n            largest_left = max(arr[i],largest_left)\n            if arr[i]<= lowest_right[i] and largest_left<= lowest_right[i]:\n                ans += 1\n                i += 1\n            else:\n                i+=1\n\n        return ans","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yongxi-zhou":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1302868479","body":"## 思路\n\n如果不是']'，就把当前字符放入 stack 中，否则就把从 stack pop 出 string 和 repeat time，最后再把结果放在栈里面\n\n## 代码\n\n```py\n    class Solution:\n        def decodeString(self, s: str) -> str:\n            stack = []\n            for char in s:\n                if char != \"]\":\n                    stack.append(char)\n                else:\n                    temp = \"\"\n                    count = \"\"\n                    while len(stack) != 0 and stack[-1] != \"[\":\n                        temp = stack.pop() + temp\n                    stack.pop()\n                    while len(stack) != 0 and stack[-1].isdigit():\n                        count = stack.pop() + count\n                    stack.append(temp * int(count))\n            return  \"\".join(stack)\n```\n\n## 复杂度\n\ntime O(N)<br/>\nspace O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darwintk":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1303797717","body":"## 思路\n使用递归的方法，每遇到一个“[”就递归一次，“]”return\n## 代码\n```\nclass Solution(object):\n    def decodeString(self, s):\n        def dfs(s, i):\n            res, multi = \"\", 0\n            while i < len(s):\n                # 获取乘数\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])\n                # 左括号则递归获取字符串\n                elif s[i] == '[':\n                    i, tmp = dfs(s, i + 1)\n                    res += multi * tmp\n                    multi = 0\n                # 右括号则返回需要拼接的字符串\n                elif s[i] == ']':\n                    return i, res\n                # 字母则直接接到后面\n                else:\n                    res += s[i]\n                i += 1\n            return res\n        return dfs(s,0)\n```\n## 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)\nn为字符串长度","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304820805","body":"## 思路\n使用单调栈的方法，一边遍历，一边找出最多的块数。\n局部来看，若分成两块后合并后能排序成功，则前一块的最大值应小于或等于后一块的最小值，即`max(arr1)<=min(arr2)`;\n由此，用一个栈去记录每一块的最大值，当前值大于上一个块的最大值时，将当前值作为一个单独的块，并记入stack中；\n当前值小于上一个块最大值时，将此时stack中的最大值（最后一个值 ）pop出数组存于head中，然后回溯stack，直至stack的最大值小于等于当前值。\n## 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        stack=[]\n        for num in arr:\n            if stack and stack[-1]>num:\n                head = stack.pop()\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(head)\n            else:    \n                stack.append(num)\n        return len(stack)\n```\n## 复杂度\n时间复杂度$O(N)$\n空间复杂度$O(N)$\nN为字符串长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"h-steven":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302841924","body":"- Iterate through the num reversely, and stop the loop when k is zero. \r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = []\r\n        remainder = 0\r\n        i = len(num) - 1\r\n        while k > 0:\r\n            digit = num[i] if i >= 0 else 0\r\n            remainder = (digit + k) % 10\r\n            sum.append(remainder)\r\n            k = int((digit + k)/10)\r\n            i -= 1\r\n        return num[:i+1] + sum[::-1] if i+1 > 0 else sum[::-1]\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302862574","body":"- Method 1: two pointers\r\n``` python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [0] * len(s)\r\n        for i in range(len(s)):\r\n            left = i\r\n            right =min((i + 1), (len(s) - 1))\r\n            while True:\r\n                if s[left] == c or s[right] == c or (left == 0 and right == len(s) - 1):\r\n                    break\r\n                left = max(left - 1, 0)\r\n                right = min((right + 1), (len(s) - 1))\r\n                \r\n            print(left, right)\r\n                \r\n            if s[left] == c:\r\n                ans[i] = i - left\r\n            elif s[right] == c:\r\n                ans[i] = right - i\r\n            else:\r\n                ans[i] = 0\r\n            \r\n        return ans\r\n```\r\n\r\n- Method 2: Go through the whole list from left2right and right2left\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = []\r\n        left2right = self.findShortestFromLeft(s, c)\r\n        right2left = self.findShortestFromLeft(s[::-1], c)\r\n        for l, r in zip(left2right, right2left[::-1]):\r\n            ans += [min(l, r)]\r\n        return ans\r\n    \r\n    def findShortestFromLeft(self, s, c):\r\n        shortest = [0] * len(s)\r\n        buffer = len(s)\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                buffer = 0\r\n            else:\r\n                buffer += 1\r\n            shortest[i] = buffer\r\n        return shortest\r\n```\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1302870473","body":"- Use python list to emulate a stack\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack += [x]\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            ans = self.stack[-1]\r\n            self.stack.pop(-1)\r\n            return ans\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        pointer = 0\r\n        while pointer < k and pointer < len(self.stack):\r\n            self.stack[pointer] += val\r\n            pointer += 1\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/11#issuecomment-1304662127","body":"- Stack\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        ans = []\r\n        stack = []\r\n        for i in range(len(s)):\r\n            stack.append(s[i])\r\n            if s[i] == ']':\r\n                j = len(stack) - 1\r\n                while j > 0:\r\n                    if stack[j] == '[':\r\n                        k = j - 1\r\n                        while k >= 0 and ('0' <= stack[k] <= '9'):\r\n                            k -= 1\r\n                        temp = stack[j + 1:-1] * int(\"\".join(stack[k + 1: j]))\r\n                        stack = stack[: k + 1] + temp\r\n                        break\r\n                    j -= 1\r\n        return \"\".join(stack)\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304702423","body":"- Two stacks\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        return not (bool(self.stack1) or bool(self.stack2))\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304704402","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        s1, s2 = 0, 0\r\n        ans = 0\r\n        for i,j in zip(arr, sorted(arr)):\r\n            s1 += i\r\n            s2 += j\r\n            ans += s1 == s2\r\n        return ans\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mischaqi":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1302905333","body":"### Idea:\r\nschool math, 逐位加然后进位\r\n\r\n### Complexity: \r\nTime: O(max(N, log k))\r\nSpace: O(1)\r\n\r\n### Code:\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num)-1, -1, -1):\r\n            if k == 0 : break\r\n            k, num[i] = divmod(num[i] +k,10)\r\n        while k > 0:\r\n            k, a = divmod(k, 10)\r\n            num = [a] + num   \r\n        return num   \r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1302952263","body":"### Idea: \r\n顺序/逆序遍历，记下距离；在出现第一个char之前的距离计算都不作数\r\n\r\n### Complexity: \r\nTime: O(N)\r\nSpace: O(N)\r\n\r\n```\r\nfrom typing import List\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        shortest_distance = []\r\n        lens = len(s)\r\n\r\n        if lens == 1:\r\n            return [0]\r\n        \r\n        k = 10001\r\n        for i in range(0, lens):\r\n            if s[i] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            shortest_distance.append(k)\r\n\r\n        k = 10001\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c: \r\n                k = 0\r\n            else:\r\n                if k != -1: k += 1\r\n            if k < shortest_distance[j]:\r\n                shortest_distance[j]=k\r\n\r\n        return shortest_distance\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/8#issuecomment-1304738280","body":"### Idea:\r\nReplace Time by Space, 等pop的时候再处理单个元素，先把应该进行的操作用另一个数组存下\r\n\r\n### Complexity: \r\nTime: all-O(1) \r\nSpace: O(cnt/N), N是操作数\r\n\r\n### Code:\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = []\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.stk.append(x)\r\n            self.incrementals.append(0)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1 \r\n        self.cnt -= 1\r\n        if self.cnt >= 1: \r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stk.pop() + self.incrementals.pop()\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals: \r\n            self.incrementals[min(k, self.cnt)-1] += val\r\n```","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/12#issuecomment-1304568728","body":"### Complexity \r\nTime: push O(N), pop/peak/empty O(1)\r\nSpace: O(N)\r\n\r\n### Code \r\n\r\n```\r\nclass MyQueue(object):\r\n    def __init__(self):\r\n        self.in_stk = []\r\n        self.out_stk = []\r\n\r\n    def push(self, x):\r\n        self.in_stk.append(x)\r\n\r\n    def pop(self):\r\n        self.peek()\r\n        return self.out_stk.pop()\r\n\r\n    def peek(self):\r\n        if not self.out_stk:\r\n            while self.in_stk:\r\n                self.out_stk.append(self.in_stk.pop())\r\n        return self.out_stk[-1]\r\n\r\n    def empty(self):\r\n        return not self.in_stk and not self.out_stk\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wurongronga":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304643562","body":"Algorithm\r\n1. add k to the end of the array\r\n2. iterate through array elements,  update carry and add carry to the element ahead\r\n3. after the iteration, if there is still carry, add separate digit ( divmod() or list( map( int,str(carry) ) ) ) to the head of array \r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        A[-1] = A[-1] + k\r\n        \r\n        for i in range(len(A)-1,-1,-1):\r\n            carry, A[i] = divmod(A[i],10)\r\n            if i != 0:\r\n                A[i-1] = A[i-1] + carry\r\n        while carry:\r\n            carry, a = divmod(carry, 10)\r\n            A = [a] + A\r\n\r\n            ## or\r\n\r\n       # if carry:\r\n            # carry = list(map(int, str(carry)))\r\n            # A = carry + A\r\n\r\n        return A\r\n```\r\n\r\ntime: O(M+N)  M -> length of input A, N ->  length of str(carry)\r\nspace: O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/7#issuecomment-1304656554","body":"Algorithm\r\n1. loop through string from left and record the distance to the left nearest c\r\n2. loop through string from right and update the distance to the right nearest c\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = [0]*len(s)\r\n        \r\n        for p in range(len(s)):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = p - prev\r\n        \r\n        prev = float('inf')\r\n        for p in range(len(s)-1,-1,-1):\r\n            if s[p] == c:\r\n                prev = p\r\n            ans[p] = min(ans[p],prev - p)\r\n            \r\n        return ans\r\n```\r\ntime: O(N) N is the length of input string, scan through the string twice\r\nspace: O(N) the size of ans","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miduoliu":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304679567","body":"### Thought:\r\nTake k as carry, add k to the last digit of num array, update k and add to the higher digit of num array.\r\n\r\n### Code\r\n```\r\npublic List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ret = new ArrayList<>();\r\n        int curNum = 0;\r\n        for (int i = num.length - 1; i >= 0; i--) {\r\n            curNum = (num[i] + k) % 10;\r\n            ret.add(0, curNum);\r\n            k = (num[i] + k) / 10;\r\n        }\r\n        while (k != 0) {\r\n            ret.add(0, k % 10);\r\n            k /= 10;\r\n        }\r\n        return ret;\r\n    }\r\n```\r\nTime Complexity: O(N)\r\nSpace Complexity: O(1)","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304929603","body":"```\npublic ListNode rotateRight(ListNode head, int k) {\n        if (head == null) return null;\n        if (head.next == null) return head;\n        int sz = 1;\n        ListNode oldTail = head;\n\n        //Calculate the size of linkedlist\n        while (oldTail.next != null) {\n            oldTail = oldTail.next;\n            sz++;\n        }\n\n        //Connect the oldtail and head\n        oldTail.next = head;\n\n        //Update k circumvent the repeat procedure\n        k %= sz;\n\n        //Find the newtail after k's operation.\n        ListNode newTail = head;\n        for (int i = 0; i < sz - k - 1; i++) {\n            newTail = newTail.next;\n        }\n\n        //The newhead is next to the newtail\n        ListNode newHead = newTail.next;\n\n        //Break the loop\n        newTail.next = null;\n\n        return newHead;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyshenzhengkang":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/13#issuecomment-1304823818","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num<stack[-1]:\n                head = stack.pop()\n                while stack and num<stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(num)\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y4h2":[{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/6#issuecomment-1304848673","body":"```py\r\nclass Solution:\r\n    def addToArrayForm(self, nums: List[int], k: int) -> List[int]:\r\n        n = len(nums)\r\n        num = 0\r\n        for i in range(n):\r\n            num = num * 10 + nums[i]\r\n            \r\n            \r\n        num += k\r\n        result = []\r\n        while num > 0:\r\n            result.append(num % 10)\r\n            num //= 10\r\n            \r\n            \r\n        return result[::-1]\r\n```","onTime":false},null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304844838","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return \r\n        dummyHead = ListNode(next=head)\r\n\r\n        n = self.getLength(head)\r\n        k = k % n\r\n        \r\n        # get the right side head\r\n        cur = dummyHead\r\n        for i in range(n - k):\r\n            cur = cur.next\r\n            \r\n        newHead = cur.next\r\n        cur.next = None\r\n        \r\n        \r\n        # keep the oldHead\r\n        oldHead = head\r\n        \r\n        \r\n        # connect the oldHead to the tail of prev right side\r\n        dummyHead.next = newHead\r\n        cur = dummyHead\r\n        while cur.next:\r\n            cur = cur.next\r\n        \r\n        cur.next= oldHead\r\n        \r\n        return dummyHead.next\r\n        \r\n        \r\n    def getLength(self, head: Optional[ListNode]) -> int:\r\n        result = 0\r\n        dummyHead = ListNode(next=head)\r\n        cur = dummyHead\r\n        while cur.next:\r\n            result += 1\r\n            cur = cur.next\r\n        \r\n        return result\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yoco323":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1304924255","body":"```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(k == 0 || head == null || head.next == null) return head;\n        // count the number of list\n        ListNode countNode = head; \n        int count;\n        for( count = 1; countNode.next != null; count++){\n            countNode = countNode.next;\n        }\n        // make a circle \n        countNode.next = head;\n        ListNode tail = countNode;\n        ListNode prev = head;\n        for(int i = 0; i < count - k%count; i++ ){\n            tail = tail.next;\n        }\n        prev = tail.next;\n        tail.next = null;\n        return prev;\n\n    \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-9-daily-check/issues/14#issuecomment-1305034426","body":"```\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        //如果是空和只有一个元素链表就直接返回\r\n        if(head == null || head.next == null){\r\n            return head;\r\n        }\r\n        int len = 1, index;\r\n        ListNode temp = head,newHead;\r\n        //计算链表长度\r\n        while(temp.next != null){\r\n            len++;\r\n            temp = temp.next;\r\n        }\r\n    \r\n    //将列表设为循环链表\r\n        temp.next = head;\r\n        k %= len;\r\n        index = len - k;\r\n        //找到要断开循环链表的结点 记录链表新的头节点\r\n        while (index-- > 0) {\r\n            temp = temp.next;\r\n        }\r\n        newHead = temp.next;\r\n        temp.next = null;\r\n        return newHead;\r\n\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}