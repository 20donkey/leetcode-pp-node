{"michaelxi3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184635948","body":"# Idea\r\nArray Iteration，从后往前进位\r\n# Code\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        \r\n        while (index >= 0 || k!=0) {\r\n            \r\n            if (index >= 0) {\r\n                k = num[index] + k;\r\n                index--;\r\n            }\r\n            // k != 0 时都要继续loop！因为有进位的 special case！\r\n            res.addFirst(k % 10);\r\n            k = k / 10;\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185699268","body":"# Idea\r\n> Two Pass, Array Manipulation\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] dist = new int[n];\r\n        // Step_1: Initialization\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) continue;\r\n            dist[i] = Integer.MAX_VALUE;\r\n        }\r\n        // First Pass: Left to Right\r\n        for (int i = 0; i < n-1; i++) {\r\n            if (dist[i] == Integer.MAX_VALUE) continue;\r\n            else dist[i + 1] = Math.min(dist[i+1], dist[i] + 1);\r\n        }\r\n        // Second Pass: Right to Left\r\n        for (int i = n-1; i > 0; i--) {\r\n            dist[i-1] = Math.min(dist[i-1], dist[i] + 1);\r\n        }\r\n        return dist; \r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186251631","body":"# Idea\r\n> Implement as an Array and keep track of maxSize and curSize\r\n# Code\r\n```java\r\nclass CustomStack {\r\n\r\n    private int[] arr;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.arr = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (this.curSize >= this.maxSize) {\r\n            return;\r\n        } else {\r\n            arr[curSize] = x;\r\n            curSize++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (this.curSize <= 0) {\r\n            return -1;\r\n        } else {\r\n            curSize--;\r\n            return arr[curSize];\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (curSize > 0) {\r\n            for (int i = 0; i < k && i < this.curSize; i++) {\r\n                arr[i] = arr[i] + val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186559715","body":"# Idea\r\n> Manipulation of Stack\r\n# Code\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Character> stack = new Stack<>(); // Using stack to decode\r\n\r\n        for (int i=0; i < s.length(); i++) {\r\n            char cur = s.charAt(i);\r\n    \r\n            if (cur == ']') {\r\n                StringBuilder sb = new StringBuilder();\r\n\r\n                // Pop out all characters until '['\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String subString = sb.toString();\r\n                stack.pop(); // Pop out '['\r\n\r\n                // Pop out all numbers as frequency\r\n                sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String Freq = sb.toString();\r\n\r\n                // Replicate substring based on frequency\r\n                int count = Integer.valueOf(Freq);\r\n                while (count > 0) {\r\n                    count--;\r\n                    for (char j : subString.toCharArray()) {\r\n                        stack.push(j);\r\n                    }\r\n                }\r\n            } else {\r\n                stack.push(cur);\r\n            }\r\n        }\r\n\r\n        // Retrieve answer from stack\r\n        StringBuilder ans = new StringBuilder();\r\n        while (!stack.isEmpty()) {\r\n            ans.insert(0, stack.pop());\r\n        }\r\n        return ans.toString();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188398549","body":"# Idea\r\n> Input and Output Stack\r\n# Code\r\n```java\r\nclass MyQueue {\r\n    \r\n    Stack<Integer> input;\r\n    Stack<Integer> output;\r\n    \r\n    public MyQueue() {\r\n        this.input = new Stack<>();\r\n        this.output = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        this.input.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!this.output.empty()) {\r\n            return this.output.pop();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!this.output.empty()) {\r\n            return this.output.peek();\r\n        } else {\r\n            while (!this.input.empty()) {\r\n                this.output.push(this.input.pop());\r\n            }\r\n            return this.output.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if (this.input.empty() && this.output.empty()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460545","body":"# Idea\r\n> 利用两个结论解决问题\r\n- 结论_1: Decreasing portion of array cannot be partitioned.\r\n- 结论_2: Non-Decreasing portion of array can be partitioned.\r\n# Code\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        // Maintain a non-decreasing monotonic stack\r\n        for (int i=0; i < arr.length; i++) {\r\n            // 1. 出现递减的trend，需要进行融合\r\n            if (!stack.isEmpty() && arr[i] < stack.peek()) {\r\n                // 我们需要将融合后的区块的最大值重新放回栈\r\n                int localMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                } \r\n                stack.push(localMax);\r\n            // 2. 递增trend直接push到stack中就好\r\n            } else {\r\n                stack.push(arr[i]);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(N)\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190558685","body":"# Idea\r\n> 因为题目中的 ListNode 只有 next pointer，所以我们最好先把 list 连接成一个 cycle，并在每次 rotate 后都更新 pointers 的位置。难点在于：pointer 向 next 方向所需移动的步数为 length - k % length，因为考虑到 k (rotate 数量) 大于 List Length 的情况。最后再将 cycle break 一下变成 list 返回 head 即可。\r\n# Code\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        // NULL head situation\r\n        if (head == null) {\r\n            return head;\r\n        }\r\n        \r\n        // Make a cycle\r\n        int length = 1;\r\n        ListNode end = new ListNode();\r\n        end = head;\r\n        while (end.next != null) {\r\n            end = end.next;\r\n            length++;\r\n        }\r\n        end.next = head;\r\n        \r\n        // Move k steps\r\n        for (int i = length - k % length; i >= 1; i--) {\r\n            head = head.next;\r\n            end = end.next;\r\n        }\r\n\t\t\t\t\r\n\t// Break the cycle\r\n        end.next = null;\r\n        \r\n        return head;\r\n    }\r\n}\r\n```\r\n# Complexity\r\n- Time: O(n)\r\n- Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darknightwriter":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184674932","body":"## 思路\n注意 k 、num数组、以及进位问题即可。\n- Java：数组遍历\n- Python： 字符串偷懒\n\n## 解题\nJava:\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> arr = new LinkedList<>();\n        int index = num.length - 1;\n        int plus = 0;\n        while (k > 0 || plus != 0 || index > -1) {\n            int mod = k % 10 + plus;\n            k /= 10;\n            if (index > -1) {\n                mod += num[index--];\n            }\n            arr.addFirst(mod % 10);\n            plus = mod / 10;\n        }\n        return arr;\n    }\n}\n```\nPython:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = reduce(lambda x, y: x * 10 + y, num) + k\n        return [0] if n == 0 else [int(i) for i in str(n)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186080","body":"## 思路\n1. 遍历查询所有s中等于c的下标并保存\n2. 二次遍历并对比该字符到两端的最短距离\n\n## 代码\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ret = new int[s.length()];\n        ArrayList<Integer> index = new ArrayList<>();\n        index.add(-s.length() - 1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        index.add(s.length() * 2);\n        int point = 1;\n        for (int i = 0; i < s.length(); i++) {\n            ret[i] = Math.min(i - index.get(point - 1),index.get(point) - i);\n            if (i == index.get(point)){\n                point++;\n            }\n        }\n        return ret;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(N)\n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522499","body":"## 思路\n使用数组模拟栈操作\n\n## 解题\n```Java\nclass CustomStack {\n    int[] stack;\n    int[] nums;\n    int p = -1;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        nums = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (p < stack.length - 1) {\n            stack[++p] = x;\n        }\n    }\n\n    public int pop() {\n        if (p >= 0) {\n            int val = stack[p];\n            int num = nums[p];\n            nums[p--] = 0;\n            if (p >= 0) {\n                nums[p] += num;\n            }\n            return val + num;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        if ( p >= 0){\n            k = Math.min(k - 1, p);\n            nums[k] += val;\n        }\n    }\n}\n```\n## 复杂度\n时间复杂度: O(1)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186565468","body":"## 思路\n使用栈的压入弹出，根据右括号作为弹栈的触发。\n\n## 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n## 复杂度\n- 时间复杂度： O(N)\n- 空间复杂度： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188936014","body":"## 思路\n使用两个栈，来实现队列的操作\n## 代码\n```python\nclass MyQueue:\n    def __init__(self):\n        self.stack1, self.stack2 = [], []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return len(self.stack1) + len(self.stack2) == 0\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382731","body":"## 思路\n基础栈操作\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for i in arr:\n            if stack and i < stack[-1]:\n                head = stack[-1]\n                while stack and i < stack[-1]:\n                    stack.pop()\n                stack.append(head)\n            else:\n                stack.append(i)\n        return len(stack)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"findlayzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184759423","body":"**智商不够，硬解来凑**\n\n----------------------\n\n> 思路：把整数转成数组，同时创建一个长度+1的备用数组防止溢出，各位分别做十进制加法，不溢出则截断数组返回答案。\n\n------------\n\n*代码*\n\n```java\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\n\n/**\n * @author boyu\n */\npublic class Solution {\n    static int[] addArrAndInt(int[] nums,int k){\n        ArrayList<Integer> al = new ArrayList<>();\n        do{\n            al.add(k % 10);\n        }while ((k /= 10) > 0);\n        Collections.reverse(al);\n        int[] arr = new int[al.size()];\n        for (int i = 0; i < al.size(); i ++) {\n            arr[i] = al.get(i);\n\n        }\n        return addTwoArr(nums, arr);\n    }\n    static int[] addTwoArr(int[] arr1, int[] arr2){\n        int tag = 0;\n        int t;\n        int ptr1 = arr1.length;\n        int ptr2 = arr2.length;\n        int[] res = new int[Math.max(ptr1, ptr2) + 1];\n        Arrays.fill(res, 0);\n        for (int i = res.length - 1; i >= 0 ; i --) {\n            if(ptr1 < 1 && ptr2 < 1) {\n                res[i] = tag;\n                break;\n            }else if(ptr1 < 1){\n                t = arr2[-- ptr2] ;\n            }else if(ptr2 < 1){\n                t = arr1[-- ptr1] ;\n            }else {\n                t = arr1[-- ptr1] + arr2[-- ptr2];\n            }\n            res[i] = (t + tag) % 10;\n            if (t + tag >= 10){\n                tag = 1;\n            }else {\n                tag = 0;\n            }\n        }\n        if ( res[0] != 1 ){\n            return Arrays.copyOfRange(res, 1, res.length);\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int[] arr= {9, 9, 9};\n        int k = 1;\n        System.out.println(\"{9, 9, 9} + 1 = \" + Arrays.toString(Solution.addArrAndInt(arr, k)));\n    }\n}\n```\n\n--------------\n\n***萌新刚接触算法没思路求大佬们轻喷，后续会努力学习大佬解法，献丑了。***\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185723846","body":"> 思路：对每一个点进行左右遍历，取最小值。\r\n\r\n------------\r\n\r\n代码\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] ans = new int[len];\r\n        Arrays.fill(ans, Integer.MAX_VALUE);\r\n        int t;\r\n        for (int i = 0; i < len; i++) {\r\n            t = i; //扫左边\r\n            while (t >= 0){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(i - t));\r\n                }\r\n                t --;\r\n            }\r\n            t = i; //扫右边\r\n            while (t < len){\r\n                if (s.charAt(t) == c){\r\n                    ans[i] = Math.min(ans[i], Math.abs(t - i));\r\n                }\r\n                t ++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186482276","body":"> 思路：基础栈操作，使用数组作为栈结构\n\n------------\n\n*代码*\n\n```java\nclass CustomStack {\n\n    int[] myStack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        this.myStack = new int[maxSize];\n        this.top = -1;\n    }\n    \n    public void push(int x) {\n        if (this.top < myStack.length - 1){\n            this.top ++;\n            this.myStack[this.top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (this.top <= -1){\n            return -1;\n        }\n        return this.myStack[this.top --];\n    }\n    \n    public void increment(int k, int val) {\n        if (this.top <= k - 1){\n            for (int i = 0; i < this.myStack.length; i++) {\n                this.myStack[i] += val;\n            }\n        }else {\n            for (int i = 0; i < k; i++) {\n                this.myStack[i] += val;\n            }\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187136118","body":"\n> 思路：利用栈进行括号匹配。\n\n------------\n\n*代码*\n\n```java\nclass Solution {\n    int p;\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        p = 0;\n\n        while (p < s.length()){\n            char c = s.charAt(p);\n            if (Character.isDigit(c)){\n                StringBuilder sb = new StringBuilder();\n                while (Character.isDigit(s.charAt(p))){\n                    sb.append(s.charAt(p ++));\n                }\n                stk.addLast(sb.toString());\n            }else if (Character.isLetter(c) || c == '['){\n                stk.addLast(String.valueOf(s.charAt(p ++)));\n            }else{\n                ++ p;\n                LinkedList<String> su = new LinkedList<String>();\n                while (! \"[\".equals(stk.peekLast())){\n                    su.add(stk.removeLast());\n                }\n                Collections.reverse(su);\n                stk.removeLast();\n                int time = Integer.parseInt(stk.removeLast());\n                StringBuilder t = new StringBuilder();\n                String o = getString(su);\n                while (time -- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n        return getString(stk);\n\n    }\n    public String getString(LinkedList<String> v) {\n        StringBuilder ret = new StringBuilder();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```\n\n--------------\n\nday4\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189016953","body":"\n----------------------\n\n> 思路：利用辅助空间完成两个栈之间内容的交换，一个栈发生变化时同时改变另一个栈。\n\n------------\n\n*代码*\n\n```java\nclass MyQueue {\n    Stack<Integer> stackHead;\n    Stack<Integer> stackTail;\n    List<Integer> tmp;\n    \n    public MyQueue() {\n        this.stackHead = new Stack<>();\n        this.stackTail = new Stack<>();\n        this.tmp = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        this.stackTail.push(x);\n        exchangeStackContents(this.stackTail, this.stackHead);\n    }\n    public int pop() {\n        int x = stackHead.pop();\n        exchangeStackContents(this.stackHead, this.stackTail);\n        return x;\n    }\n    public void exchangeStackContents(Stack<Integer> stackA, Stack<Integer> stackB){\n        this.tmp.clear();\n        stackB.clear();\n        while (!stackA.empty()){\n            this.tmp.add(stackA.pop());\n        }\n        for (int i = 0; i < this.tmp.size(); i++) {\n            stackA.push(this.tmp.get(this.tmp.size() - i -1));\n            stackB.push(this.tmp.get(i));\n        }\n    }\n    \n    public int peek() {\n        return this.stackHead.peek();\n    }\n    \n    public boolean empty() {\n        return this.stackHead.empty();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190395437","body":"\n> 思路：利用单调栈的性质。\n\n------------\n\n*代码*\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0, nonzero = 0;\n\n        int[] t = arr.clone();\n        Arrays.sort(t);\n\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i], y = t[i];\n\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) nonzero--;\n            if (count.get(x) == 1) nonzero++;\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == -1) nonzero++;\n            if (count.get(y) == 0) nonzero--;\n\n            if (nonzero == 0) ans++;\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184788930","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        s = \"\"\n        for i in num:\n            s += str(i)\n            \n        answer = int(s) + k\n        \n        return  \"\".join(str(answer))\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186315034","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = deque()\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) == self.maxSize:\n            return\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        stack2 = deque()\n        if k < len(self.stack):\n            for i in range(len(self.stack) - k):\n                stack2.append(self.stack.pop())\n        while self.stack:\n            stack2.append(self.stack.pop() + val)\n        while stack2:\n            self.stack.append(stack2.pop())\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186584817","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = deque()\n        count = 0\n        string = ''\n        \n        for char in s:\n            if char.isdigit():\n                count = count * 10 + int(char)\n            elif char == '[':\n                stack.append(string)\n                stack.append(count)\n                count = 0\n                string = ''\n            elif char == ']':\n                last_count = stack.pop()\n                last_string = stack.pop()\n                \n                string = last_string + last_count * string\n            else:\n                string += char\n        \n        return string\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187778722","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = deque()\n        self.stack2 = deque()\n\n    # O(1)\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    # O(N)\n    def pop(self) -> int:\n        while len(self.stack1) > 1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack1.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        \n        return res\n    \n    # O(N)\n    def peek(self) -> int:\n        res = -1\n        while self.stack1:\n            if len(self.stack1) == 1:\n                res = self.stack1[0]\n            self.stack2.append(self.stack1.pop())\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n    \n    # O(1)\n    def empty(self) -> bool:\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189441929","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        res = []\n        \n        for i, n in enumerate(arr):\n            maxn = n\n            while res and res[-1] > n:\n                maxn = max(maxn, res.pop())\n            res.append(maxn)\n        \n        return len(res)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190757842","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        count = 0\n        curr = head\n        tail = None\n        while curr:\n            if not curr.next: tail = curr\n            curr = curr.next\n            count += 1\n                \n        k = k % count\n        \n        if k == 0: return head\n        \n        curr = head\n        for i in range(k):\n            curr = curr.next\n        \n        curr2 = head\n        while curr.next:\n            curr = curr.next\n            curr2 = curr2.next\n        dummy = curr2.next\n        curr2.next = None\n        tail.next = head\n        \n        return dummy\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lbc546":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184790165","body":"## Add Entire K to the first column to the right and carry over ```addend // 10``` to the next (left) column\n## Python Solution\n```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        index = len(num) - 1\n        add = k\n        result = []\n        \n        # Iterate from right end of the array\n        while index >= 0 or add > 0:\n             # Whenever not at the end of the array, add the digit\n             if index >= 0:\n                add += num[index]\n            add, mod = divmod(add, 10)\n            result.insert(0, mod)\n            index -= 1\n        return result\n```\n## Complexity\nTime: O(n)   Space: O(n) where n is the length of the array num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185890807","body":"## Two Pass\n## Python solution\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        prev = float('-inf')\n        ans = []\n        # left\n        for i in range(len(s)):\n            if s[i] == c:\n                prev = i\n            ans.append(i - prev)\n        # right\n        prev = float('inf')\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n        return ans\n```\n## Complexity\nTime: O(n)\nSpace: O(n) where n is the length of array s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186247118","body":"## OOD with python list\n## Python solution\n```\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n\n        self.maxSize = maxSize\n        self.data = []\n        \n\n    def push(self, x):\n\n        if len(self.data) < self.maxSize:\n            self.data.append(x)\n        else:\n            pass\n        \n\n    def pop(self):\n\n        if len(self.data) == 0:\n            return -1\n        else:\n            return self.data.pop()\n        \n\n    def increment(self, k, val):\n\n        for i in range(min(len(self.data), k)):\n            self.data[i] += val\n    \n```\n## Complexity\n```push()``` O(1)\n```pop()``` O(1)\n```increment``` O(min(n, k))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186738383","body":"## Use stack to complete the decode within each pairs of bracket, pushing the decoded string in the brackets to the stack again.\n## Python solution\n```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        ans = \"\"\n        \n        for c in s:\n            # Not closing brackets, push into stack\n            if c != ']':\n                stack.append(c)\n            else:\n                # Otherwise, first get the characters within the brackets\n                r = \"\"\n                while stack and stack[-1] != '[':\n                    # reverse the order\n                    r = stack.pop() + r\n\n                # pop the opening bracket out\n                stack.pop()\n                \n                # get the number of times to repeat\n                n = \"\"\n                while stack and stack[-1].isnumeric():\n                    f = stack.pop()\n                    # reverse order\n                    n = f + n\n                \n                # push the cleaned and decoded string into the stack\n                stack.append(r * int(n))\n        for c in stack:\n            ans += c\n        \n        return ans\n```\n## Complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187711286","body":"## Use two stacks to handle push\n## Python solution\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n\n    def push(self, x):\n        while self.s1:\n            self.s2.append(self.s1.pop())\n        self.s1.append(x)\n        while self.s2:\n            self.s1.append(self.s2.pop())\n            \n    def pop(self):\n        return self.s1.pop()\n\n    def peek(self):\n        return self.s1[-1]\n\n    def empty(self):\n        return not self.s1\n```\n## Complexity\nPush O(n) others O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189454716","body":"## Current min greater than previous high, add to stack\r\n## Python sol\r\n```\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        stack = []\r\n        \r\n        stack.append((arr[0], arr[0]))\r\n        \r\n        for i in range(1, len(arr)):\r\n            low, high = arr[i], arr[i]\r\n            while stack and stack[-1][1] > low:\r\n                prev_low, prev_high = stack.pop()\r\n                low, high = min(prev_low, low), max(prev_high, high)\r\n            stack.append((low, high))\r\n        return len(stack)\r\n```\r\n## Complexity\r\nO(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190938089","body":"## Idea\nCount total nodes and make a cycle\nUse to mod to determine the break point in the middle\n## Python Solution\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n        n = 1\n        dummy = head\n        while dummy.next:\n            n += 1\n            dummy = dummy.next\n        \n        dummy.next = head\n        \n        current = head\n        for i in range(n-k % n-1):\n            current = current.next\n        \n        new = current.next\n        current.next = None\n        return new\n```\n## Complexity\nSpace: O(1)\nTime: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zch-bit":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184793730","body":"## Go Solution\r\nAdd the last digit of k to the last element in `num` as `sum`, then drop the last digit of k(k=k/10); eventually, check if k is equal to zero, if not, convert it to a new array and attach the num to the end.\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...) \r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}\r\n```\r\n\r\n## Complexity: \r\nTIme: O(n)\r\nSpace: O(n) where m is the max between the length of num and k.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121758","body":"## Day 2\r\n\r\n1. first loop: Save position of char c\r\n2. second loop: Compute the min distance between char c and other chars\r\n\r\nTime: O(n), space: O(n)\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tvar pos []int\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tpos = append(pos, i)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", pos)\r\n\r\n\tres := []int{}\r\n\tfor i, ch := range s {\r\n\t\tif byte(ch) == c {\r\n\t\t\tres = append(res, 0)\r\n\t\t} else {\r\n\t\t\tmin := math.MaxInt16\r\n\t\t\tfor _, j := range pos {\r\n\t\t\t\tif min > abs(j-i) {\r\n\t\t\t\t\tmin = abs(j - i)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tres = append(res, min)\r\n\t\t}\r\n\t}\r\n\tfmt.Printf(\"%v\", res)\r\n\treturn res\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433869","body":"## Day 3\r\n\r\n\r\n```go\r\ntype CustomStack struct {\r\n\tstack   []int\r\n\tmaxSize int\r\n\ttop     int\r\n}\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n\tcustomStack := CustomStack{}\r\n\tcustomStack.stack = make([]int, maxSize)\r\n\tcustomStack.maxSize = maxSize\r\n\tcustomStack.top = -1\r\n\r\n\treturn customStack\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Push(x int) {\r\n\tif this.top+1 < this.maxSize {\r\n\t\tthis.top++\r\n\t\tthis.stack[this.top] = x\r\n\t}\r\n}\r\n\r\n// Time: O(1)\r\nfunc (this *CustomStack) Pop() int {\r\n\tif this.top < 0 {\r\n\t\treturn -1\r\n\t}\r\n\tx := this.stack[this.top]\r\n\tthis.top--\r\n\treturn x\r\n}\r\n\r\n// Time: O(n)\r\nfunc (this *CustomStack) Increment(k int, val int) {\r\n\tincrements := this.top + 1 // default value\r\n\tif increments > k {\r\n\t\tincrements = k\r\n\t}\r\n\r\n\tfor i := 0; i < increments; i++ {\r\n\t\tthis.stack[i] += val\r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186892128","body":"## Day 4\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n\tstr, _ := expand([]byte(s), 0)\r\n\treturn string(str)\r\n}\r\n\r\nfunc expand(s []byte, i int) ([]byte, int) {\r\n\tvar expanded []byte\r\n\tvar digits []byte\r\n\tfor i < len(s) && s[i] != ']' {\r\n\t\tc := s[i]\r\n\t\tif c >= 'a' && c <= 'z' {\r\n\t\t\texpanded = append(expanded, c)\r\n\t\t} else if c >= '0' && c <= '9' {\r\n\t\t\tdigits = append(digits, c)\r\n\t\t} else if c == '[' {\r\n\t\t\tnested, idx := expand(s, i+1)\r\n\t\t\tnumTimes, _ := strconv.Atoi(string(digits))\r\n\t\t\tdigits = digits[:0]\r\n\t\t\tfor numTimes > 0 {\r\n\t\t\t\texpanded = append(expanded, nested...)\r\n\t\t\t\tnumTimes--\r\n\t\t\t}\r\n\t\t\ti = idx\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\treturn expanded, i\r\n}\r\n```\r\nComplexity: Time: O(n), Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188529736","body":"## Day 5\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    /** Initialize your data structure here. */\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    int front;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        if(s1.isEmpty()) {\r\n            front = x;\r\n        }\r\n    \r\n        s1.add(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        \r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(!s2.isEmpty()) {\r\n            return s2.peek();\r\n        }\r\n        \r\n        return front;\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s2.isEmpty() && s1.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190154617","body":"```go \r\nfunc maxChunksToSorted(arr []int) int {\r\n\tchunks := 0\r\n\tsortedArray := make([]int, len(arr))\r\n\tcopy(sortedArray, arr)\r\n\tsort.Ints(sortedArray)\r\n\tdiffer := make(map[int]int)\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tdiffer[sortedArray[i]]++\r\n\t\tdiffer[arr[i]]--\r\n\t\tif differ[sortedArray[i]] == 0 {\r\n\t\t\tdelete(differ, sortedArray[i])\r\n\t\t}\r\n\t\tif differ[arr[i]] == 0 {\r\n\t\t\tdelete(differ, arr[i])\r\n\t\t}\r\n\t\tif len(differ) == 0 {\r\n\t\t\tchunks++\r\n\t\t}\r\n\t}\r\n\treturn chunks\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091790","body":"## Day 07\r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    length := 0\r\n    tail := head\r\n    cur := head\r\n    for tail != nil && tail.Next != nil {\r\n        length++\r\n        tail = tail.Next\r\n    }\r\n    length++\r\n    \r\n    // 1,2,3,4,5->null => 1,2,3, 4(curr),5,1,2,3 ->null\r\n    for i := 0; i < length - (k % length); i++ {\r\n        if tail != nil {\r\n            tail.Next = &ListNode{ Val: cur.Val, }\r\n            tail = tail.Next\r\n            cur = cur.Next\r\n        }\r\n    }\r\n    \r\n    return cur\r\n}\r\n```\r\n\r\nTime: O(n), Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frankelzeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184838625","body":"## Idea\r\nKeep in mind that string is just a list of char, then there is no need to do decimal manipulation but can simply use six-stage conversion: \r\n1. convert int list to char list\r\n2. join char list into singe word\r\n3. convert the single word to int\r\n4. add int with k\r\n5. convert the sum to string\r\n6. map string to int list\r\n## Python Code\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(\"\".join(map(str, num)))\r\n        re = num_int + k\r\n        return list(map(int, str(re)))\r\n```\r\n## Complexity\r\nSpace: O(N)\r\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222897","body":"## Idea\nUse to pointers to track the distance\n## Python Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        strlen = len(s)\n        re = [-1 for _ in range(strlen)]\n        idx_li = []\n        for i in range(strlen):\n            if s[i] == c:\n                re[i] = 0\n                idx_li.append(i)\n        le = 0\n        ri = 0\n        for i in range(len(idx_li) + 1):\n            if i == 0:\n                re[:idx_li[0]] = [x for x in range(idx_li[0],0,-1)]\n            elif i == len(idx_li):\n                ran = len(re[idx_li[len(idx_li) - 1]:])\n                re[idx_li[len(idx_li) - 1]:] = [x for x in range(ran)]\n            else:\n                curr = 0\n                le = idx_li[i - 1]\n                ri = idx_li[i]\n                while le <= ri:\n                    re[le] = re[ri] = curr\n                    le += 1\n                    ri -= 1\n                    curr += 1\n        return re\n```\n## Complexity\nSpace: O(N)\nTime: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186538783","body":"## Idea\nUse second stack to track the increment of elements\n## Python Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.size = maxSize\n        self.stk = []\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stk) < self.size:\n            self.stk.append(x)\n            self.inc.append(0)\n    def pop(self) -> int:\n        if not self.stk:\n            return -1\n        if len(self.inc) > 1:\n            self.inc[-2] += self.inc[-1]\n        return self.inc.pop() + self.stk.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            idx = min(len(self.inc), k) - 1\n            self.inc[idx] += val\n```\n## Complexity\nO(1) in time and space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186765529","body":"## Idea\nUse a single stack to track the input\n## Python Code\n```python\nimport collections\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stk = collections.deque()\n        for idx,c in enumerate(s):\n            if c == ']':\n                curr = stk.pop()\n                temp = \"\"\n                while curr.isalpha():\n                    temp = curr + temp\n                    curr = stk.pop()\n                temp_num = \"\"\n                if curr == '[':\n                    curr = stk.pop()\n                # print(\"curr=\",curr)\n                while curr.isdigit():\n                    temp_num = curr + temp_num\n                    if stk and stk[-1].isdigit():\n                        curr = stk.pop()\n                    else:\n                        curr = \"\"\n                num = int(temp_num)\n                for _ in range(num):\n                    for t in temp:\n                        stk.append(t)\n            else:\n                stk.append(c)\n            # print(stk)\n        return \"\".join(list(stk))\n```\n## Complexity\nTime: O(max(k) * n)\nSpace: O(max(k) * n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189216168","body":"## Idea\nstraight forward\n## Python Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n\n    def push(self, x: int) -> None:\n        while self.stk1:\n            self.stk2.append(self.stk1.pop())\n        self.stk1.append(x)\n        while self.stk2:\n            self.stk1.append(self.stk2.pop())\n        return\n\n    def pop(self) -> int:\n        return self.stk1.pop()\n\n    def peek(self) -> int:\n        return self.stk1[-1]\n\n    def empty(self) -> bool:\n        return not self.stk1\n```\n## Complexity\nSpace: O(N) for all \nTime: O(N) for push, O(1) for pop, O(1) for peek","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190301483","body":"## Idea\nUse monotonic stack to track the largest number in each partition\n## Python Code\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            la = num\n            while stack and stack[-1] > num:\n                la = max(la, stack.pop())\n            stack.append(la)\n        return len(stack)\n```\n## Complexity\nSpace O(N)\nTime O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhaodev":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184887447","body":"**Swift Solution**\r\n\r\n思路：\r\nK作为位数累加然后进位\r\n代码：\r\n```\r\n\r\n    func addToArrayForm(_ num: [Int], _ k: Int) -> [Int] {\r\n        if num.isEmpty { return [] }\r\n        \r\n        var k = k, ans = [Int](), i =  num.count - 1, carry = 0\r\n        while i >= 0 || k > 0 {\r\n            var sum = (i >= 0 ? num[i] : 0) + (k > 0 ? k % 10 : 0) + carry\r\n            ans.append(sum % 10)\r\n            carry = sum / 10\r\n            i -= 1\r\n            k /= 10 \r\n        }\r\n        \r\n        if carry > 0 {\r\n            ans.append(carry)\r\n        }\r\n        \r\n        return Array(ans.reversed())\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O（n）\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185867186","body":"思路:\r\n两次遍历： 从左往右，从右往左；用数组分别记录距离C的值，然后取两者之间的最小值\r\n代码:\r\n\r\n```\r\n func shortestToChar(_ s: String, _ c: Character) -> [Int] {\r\n        let arr = Array(s)\r\n        let n = arr.count\r\n        var res = Array(repeating: 0, count:n)\r\n        var prev = Int.min/2\r\n        for (i, char) in arr.enumerated() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = i - prev\r\n        }\r\n        \r\n        prev = Int.max/2\r\n        \r\n        for (i, char) in arr.enumerated().reversed() {\r\n            if char == c {\r\n                prev = i\r\n            }\r\n            res[i] = min(res[i], prev - i)\r\n        }\r\n        \r\n        return res\r\n    }\r\n```\r\n\r\n复杂度：\r\n时间复杂度： O(n) n是s的长度\r\n空间复杂度: O(n) 其实可以为O（1)，但是Swift里把String转换为Array性能更高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186418704","body":"思路：\r\n用数组模拟一个栈的Push(add), Pop(remove),然后只修改k个元素的值(inc)\r\n代码:\r\n```\r\nclass CustomStack {\r\n\r\n    let maxSize: Int\r\n    var items: [Int]\r\n    \r\n    init(_ maxSize: Int) {\r\n        self.maxSize = maxSize\r\n        self.items = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        guard items.count < maxSize else { return }\r\n        items.append(x)\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        if items.isEmpty { return -1 }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func increment(_ k: Int, _ val: Int) {\r\n        let maxCount = min(k, items.count)\r\n        for i in 0..<maxCount {\r\n            items[i] += val\r\n        }\r\n    }\r\n}\r\n```\r\n复杂度:\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186793893","body":"思路: Stack\r\n代码：\r\n```\r\nfunc decodeString(_ s: String) -> String {\r\n\tvar stack = [String]()\r\n\r\n\tfor char in s {\r\n\t\tif char != \"]\" {\r\n\t\t\tstack.append(String(char))\r\n\t\t} else {\r\n\t\t\tvar decoded = \"\"\r\n\r\n\t\t\twhile stack.last! != \"[\" {\r\n\t\t\t\tdecoded = stack.popLast()! + decoded\r\n\t\t\t}\r\n\t\t\tstack.popLast()\r\n\r\n\t\t\tvar k = 0\r\n\t\t\tvar offset = 1\r\n\t\t\twhile !stack.isEmpty, let digit = Int(stack.last!) {\r\n\t\t\t\tstack.popLast()\r\n\t\t\t\tk += offset * digit\r\n\t\t\t\toffset *= 10\r\n\t\t\t}\r\n\r\n\t\t\tstack.append(String(repeating: decoded, count: k))\r\n\t\t}\r\n\t}\r\n\r\n\treturn stack.joined()\r\n}\r\n```\r\n复杂度:\r\nTime: O(K * N), Space: O(K * N) where K is the product of all \"k\"s and N is the number of encoded characters","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188335642","body":"思路： 两个栈Input， Output； Output用来存放最终提供给外部的数据，pop, empty, peek;  Input用于接收Output的数据以及push新元素，最终再把Input里的数据全部push入Output\r\n代码:\r\n```\r\nclass MyQueue {\r\n\r\n    var input: [Int] //用户临时存放和转移元素\r\n    var output:[Int] //对外提供信息，pop， peek, empty\r\n    \r\n    init() {\r\n        input = [Int]()\r\n        output = [Int]()\r\n    }\r\n    \r\n    func push(_ x: Int) {\r\n        // 查看output里有没有元素，有，就全部push到input\r\n        // input 新增元素x\r\n        // 全部再放回ouput\r\n        while let e = output.popLast() {\r\n            input.append(e)\r\n        }\r\n        input.append(x) // 加入新元素，此时x在input的栈顶\r\n        \r\n        //放回output\r\n        while let e = input.popLast() {\r\n            output.append(e)\r\n        }\r\n    }\r\n    \r\n    func pop() -> Int {\r\n        // 直接操作output\r\n        guard let last = output.popLast() else {\r\n            return -1\r\n        }\r\n        return last\r\n    }\r\n    \r\n    func peek() -> Int {\r\n        // output的最后一个元素就是栈顶元素\r\n        if self.empty() { return -1 }\r\n        return output.last!\r\n    }\r\n    \r\n    func empty() -> Bool {\r\n        return output.isEmpty\r\n    }\r\n}\r\n```\r\n复杂度：\r\n时间复杂度： O（n）\r\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189659902","body":"思路：单调栈\r\n代码：\r\n```\r\nstruct Stack<T> {\r\n    var items = [T]()\r\n    \r\n    mutating func push(_ element: T) {\r\n        items.append(element)\r\n    }\r\n    \r\n    mutating func pop() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.popLast()!\r\n    }\r\n    \r\n    func top() -> T? {\r\n        guard self.isEmpty == false else { return nil }\r\n        return items.last\r\n    }\r\n    \r\n    var count: Int {\r\n        return items.count\r\n    }\r\n    \r\n    var isEmpty: Bool {\r\n        return items.isEmpty\r\n    }\r\n}\r\n\r\nclass Solution {\r\n    func maxChunksToSorted(_ arr: [Int]) -> Int {\r\n        if arr.isEmpty { return 0 }\r\n        var stack = Stack<Int>()\r\n        stack.push(arr[0])\r\n        print(stack)\r\n        \r\n        for i in 1..<arr.count {\r\n            if arr[i] >= stack.top()! {\r\n                stack.push(arr[i])\r\n                continue\r\n            }\r\n            let temp = stack.top()\r\n            while !stack.isEmpty && arr[i] < stack.top()! {\r\n                stack.pop()\r\n            }\r\n            stack.push(temp!)\r\n        }\r\n        return stack.count\r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\n时间： O(n)\r\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191055659","body":"思路：官方题解的思路，快慢指针+ 求倒数第k个节点\r\n代码:\r\n```\r\nclass Solution {\r\n    func rotateRight(_ head: ListNode?, _ k: Int) -> ListNode? {\r\n        if head == nil { return nil }\r\n        var cur: ListNode? = head\r\n        var count = 0\r\n        while cur != nil {\r\n            count += 1\r\n            cur = cur?.next\r\n        }\r\n        var k = k % count\r\n        print(\"k is \\(k) and count is \\(count)\")\r\n        var slow: ListNode? = head\r\n        var fast: ListNode? = head\r\n        \r\n        while fast?.next != nil {\r\n            k -= 1\r\n            if k < 0 {\r\n                slow = slow?.next\r\n            }\r\n            fast = fast?.next\r\n        }\r\n        \r\n        fast?.next = head\r\n        let res: ListNode? = slow?.next\r\n        slow?.next = nil\r\n        \r\n        return res\r\n    }\r\n}\r\n```\r\n复杂度:\r\n时间: O(n)\r\n空间: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeymoso":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184914351","body":"```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        idx = len(num) - 1\r\n        while k > 0 and idx >= 0:\r\n            if num[idx] + k % 10 < 10:\r\n                num[idx] = num[idx] + k % 10\r\n                k //= 10\r\n            else:\r\n                num[idx] = (num[idx] + k % 10) % 10\r\n                k //= 10\r\n                k += 1\r\n            idx -= 1\r\n        while k:\r\n            if idx < 0:\r\n                num = [k % 10] + num\r\n                k //= 10\r\n            else:\r\n                if num[idx] + k % 10 < 10:\r\n                    num[idx] += k % 10\r\n                    k //= 10\r\n                else:\r\n                    num[idx] = 0\r\n                    k //= 10\r\n                    k += 1\r\n                idx -= 1\r\n            \r\n\r\n        return num\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186447070","body":"```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.cur_size = 0\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cur_size == self.max_size:\r\n            return\r\n        self.stack.append(x)\r\n        self.cur_size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cur_size == 0:\r\n            return -1\r\n        self.cur_size -= 1\r\n        return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(k, self.cur_size)):\r\n            self.stack[i] += val\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O()n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186607379","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack = []\r\n\r\n        for c in s:\r\n            if c == ']':\r\n                cur_str = ''\r\n                cur_count = ''\r\n                # get repeat string\r\n                while stack and stack[-1] != '[':\r\n                    cur_str = stack.pop() + cur_str\r\n                # pop '['\r\n                stack.pop()\r\n                # get repeat count\r\n                while stack and stack[-1].isnumeric():\r\n                    cur_count = stack.pop() + cur_count\r\n                # push back to the stack\r\n                stack.append(int(cur_count) * cur_str)\r\n            \r\n            else:\r\n                stack.append(c)\r\n\r\n        return ''.join(stack)\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188297075","body":"Two stacks to implement a queue. \r\n\r\n```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.pop_stack:\r\n            self.push_stack.append(self.pop_stack.pop())\r\n\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        while self.push_stack:\r\n            self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.pop_stack) + len(self.push_stack) == 0\r\n\r\n```\r\n\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189680587","body":"monostack\r\n\r\n```python3\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        monostack = []\r\n\r\n        # max(current chunk) <= min(next chunk) \r\n\r\n        for n in arr:\r\n            if not monostack or monostack[-1] <= n:\r\n                # new chunk\r\n                monostack.append(n)\r\n            else:\r\n                maxx = monostack.pop()\r\n                while monostack and monostack[-1] > n:\r\n                    monostack.pop()\r\n                monostack.append(maxx)\r\n\r\n        return len(monostack)\r\n```\r\n\r\nTime: O(N)\r\nSpace: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1184950463","body":"```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        for (int i = num.length-1; i >= 0; i--) {\r\n            int curr = k%10 + num[i];\r\n            k /= 10;\r\n            \r\n            if (curr >= 10) {\r\n                k += 1;\r\n            }\r\n            \r\n            res.add(0, curr%10); \r\n        }\r\n        \r\n        while (k > 0) {\r\n            res.add(0, k%10);\r\n            k /= 10;\r\n        }\r\n        \r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n* Time: O(n)\r\n* Space: O(n)\r\n* Where n is Max(num.length, k.length)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185869150","body":"左右遍历\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len];\r\n        int curr = len;\r\n        \r\n        for (int i = 0; i < len; i++) {\r\n            if (s.charAt(i) == c) {\r\n                res[i] = 0;\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(len, Math.abs(i-curr));\r\n            }\r\n        }\r\n        \r\n        for (int i = len-1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                curr = i;\r\n            } else {\r\n                res[i] = Math.min(res[i], Math.abs(curr-i));\r\n            }\r\n            \r\n        }\r\n               \r\n        return res;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186755547","body":"判断几种可能性，对不同可能性进行单独判断\r\n```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        \r\n        Stack<String> sbStack = new Stack<>();\r\n        Stack<Integer> digitStack = new Stack<>();\r\n        int idx = 0;\r\n        while (idx < s.length()) {\r\n            char c = s.charAt(idx);\r\n            if (Character.isDigit(c)) {\r\n                int freq = 0;\r\n                while(Character.isDigit(s.charAt(idx))) {\r\n                    freq = freq * 10 + s.charAt(idx) - '0';\r\n                    idx++;\r\n                }\r\n                \r\n                digitStack.push(freq);\r\n            } else if (c == '[') {\r\n                sbStack.push(res.toString());\r\n                res = new StringBuilder();\r\n                idx++;\r\n            } else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                tmp.append(sbStack.pop());\r\n                \r\n                int freq = digitStack.pop();\r\n                \r\n                for (int j = 0; j < freq; j++) {\r\n                    tmp.append(res.toString());\r\n                }\r\n                \r\n                res = tmp;\r\n                idx++;\r\n            } else {\r\n                res.append(c);\r\n                idx++;\r\n            }\r\n        }\r\n                      \r\n        return res.toString();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187947131","body":"2个stack，一进一出思路\r\n```\r\nclass MyQueue {\r\n    private Stack<Integer> inStack = new Stack<>(); \r\n    private Stack<Integer> outStack = new Stack<>();\r\n\r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (empty()) return -1;\r\n        \r\n        if (outStack.isEmpty()) {\r\n            move();\r\n        }\r\n        \r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.isEmpty() && outStack.isEmpty();\r\n    }\r\n    \r\n    public void move() {\r\n        while (!inStack.isEmpty()) {\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189780663","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int res = 0;\r\n        \r\n        Deque<Integer> deque = new ArrayDeque<>();\r\n        \r\n        for (int num: arr) {\r\n            int largest = num;\r\n            while (!deque.isEmpty() && num < deque.peekFirst()) {\r\n                largest = Math.max(largest, deque.pollFirst());\r\n            }\r\n            \r\n            deque.offerFirst(largest);\r\n        }\r\n        \r\n        return deque.size();\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190592750","body":"先对k进行简化，使k <= list.length\r\n其次进行rotation\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return null;\r\n        \r\n        int count = 1;\r\n        ListNode tail = head;\r\n        \r\n        while (tail.next != null) {\r\n            count++;\r\n            tail = tail.next;\r\n        }\r\n        \r\n        k %= count;\r\n        if (k == 0) return head;\r\n        \r\n        k = count - k;\r\n        \r\n        ListNode dummy = new ListNode();\r\n        dummy.next = head;\r\n        ListNode curr = dummy;\r\n        \r\n        for (int i = 0; i < k; i++) {\r\n            curr = curr.next;\r\n        }\r\n        \r\n        tail.next = dummy.next;\r\n        dummy.next = curr.next;\r\n        curr.next = null;\r\n        \r\n        \r\n        return dummy.next;\r\n    }\r\n}\r\n```\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185032289","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        num = num[::-1]\r\n        while k:\r\n            mod = k % 10\r\n            k = k//10\r\n            if i < len(num):\r\n                num[i] += mod\r\n            else:\r\n                num.append(mod)\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n\r\n                num[i] -= 10\r\n            i+=1\r\n        while i < len(num):\r\n            if num[i] >= 10:\r\n                if i+1 < len(num):\r\n                    num[i+1] += 1\r\n                else:\r\n                    num.append(1)\r\n                num[i] -= 10\r\n                i+=1\r\n            else:\r\n                break\r\n        return num[::-1]\r\n```\r\n一位一位地加并且进位 ripple adder\r\n\r\nTime O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188563652","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [99999999999] * len(s)\r\n        left_c = -99999999999\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                ans[i] = 0\r\n                left_c = i\r\n            ans[i] = min(ans[i], i-left_c)\r\n        \r\n        left_c = 99999999999\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                left_c = i\r\n            \r\n            ans[i] = min(ans[i], left_c-i)\r\n        \r\n\r\n        return ans\r\n```\r\n\r\n正着倒着各parse一次~~\r\n时空 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1188593761","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0]*maxSize\r\n        self.add = [0]*maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < len(self.stack):\r\n            self.stack[self.size] = x\r\n            self.size += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size > 0:\r\n            ret = self.stack[self.size - 1] + self.add[self.size -1]\r\n            if self.size > 1:\r\n                # if there's more than 1 element \r\n                # propogate\r\n                self.add[self.size - 2] += self.add[self.size - 1]\r\n\r\n\r\n            # must reset because it may incorrectly propogate some add number\r\n            self.add[self.size - 1] = 0\r\n            self.stack[self.size - 1] = 0\r\n            \r\n\r\n            self.size -= 1\r\n\r\n            return ret\r\n\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.size)\r\n        if lim > 0:\r\n            self.add[lim-1] += val\r\n\r\n```\r\n这道题一定要做下increment 为O(1)的followup，去年抖音考过这个followup\r\n\r\n时间O(1)\r\n空间 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188596859","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = \"\"\r\n        string = \"\"\r\n        for i,v in enumerate(s):\r\n            if \"a\" <= v <= \"z\":\r\n                string += v\r\n            elif \"0\" <= v <= \"9\":\r\n                num += v\r\n            elif v == \"[\":\r\n                stack.append((int(num),string))\r\n                string = \"\"\r\n                num = \"\"\r\n            elif v == \"]\":\r\n                prevNum, prevStr = stack.pop()\r\n                string = prevStr + prevNum*string\r\n            \r\n        \r\n        return string\r\n```\r\n这道题太经典了，用stack\r\n时空O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188603854","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n        self.front = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.pushStack:\r\n            self.front = x\r\n        self.pushStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        else:\r\n            while self.pushStack:\r\n                self.popStack.append(self.pushStack.pop())\r\n            self.front = None\r\n            return self.popStack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        else:\r\n            return self.front\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if not self.pushStack and not self.popStack:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n# Thought\r\n1. Assign a `self.front` when `self.pushStack` is empty when pushing, so that `peek` is always O(1)\r\n\t\tWhether the existing elements are in self.pushStack or self.popStack, `peek()` is always O(1)\r\n2. For each element, it will only be appended and popped from the two stack twice. Amortized O(1)\r\n\r\n# Time\r\n时间 O(1)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189523970","body":"# non-strictly increasing stack\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for v in arr:\r\n            if not stack:\r\n                stack.append(v)\r\n            else:\r\n                if v >= stack[-1]:\r\n                    stack.append(v)\r\n                else:\r\n                    top = stack.pop()\r\n                    while stack and stack[-1] > v:\r\n                        stack.pop()\r\n                    \r\n                    stack.append(top)\r\n        \r\n        return len(stack)\r\n```\r\n\r\n这道题超级经典，第一次想stack方法很复杂，其实理解后就明白他的玄机不难。重点在于：\r\n1. 每一个chunk我们用chunk中最大的数表示\r\n2. 维护一个 non-strictgly increasing stack，表示可排序的array\r\n3. 每当新进来的数是大于等于栈顶，即可以直接进入排序后array\r\n4. 如果小于栈顶，持续pop 栈顶直到栈顶小于等于新进来的数，这表明chunk需要融合的过程\r\n\r\n时间 O(n)\r\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190790492","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return None\r\n        cur = head\r\n        n = 0\r\n        while cur:\r\n            cur = cur.next\r\n            n += 1\r\n        \r\n        k %= n\r\n\r\n        if k == 0:\r\n            return head\r\n\r\n        steps = n - k\r\n        \r\n        cur = head\r\n        prev = None\r\n        for _ in range(steps):\r\n            prev = cur\r\n            cur = cur.next\r\n\r\n        end = cur\r\n        while end and end.next:\r\n            end = end.next\r\n        \r\n        if prev:\r\n            prev.next = None\r\n\r\n        end.next = head\r\n\r\n        return cur\r\n        \r\n```\r\n这道题不难，但是有几个edge case 需要注意\r\n1. k > 链表长度时，取余\r\n2. 链表为空\r\n3. k == 链表长度\r\n\r\n时间 O(n)\r\n空间 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shiyishuoshuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185034114","body":"explanation:\r\ntake K as a carry and use k to extract the lowest digit with K % 10 and update k with k /10 as the next higher digit\r\ncorner case is once the loop ended, if k is still > 0 need to put 1 on the leftmost digit\r\n\r\ncode\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        \r\n        for(int j = len - 1; j>=0 || k > 0; j--){\r\n            ans.add(0, (j>=0 ? num[j] + k : k) % 10);\r\n            k = (j>=0 ? num[j] + k : k) / 10;\r\n        }\r\n\r\n        return ans;\r\n\r\n    }\r\n}\r\n```\r\n\r\nTime: O(n) since iterate array once\r\nSpace: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186163128","body":"Explanation:\r\nloop through the array twice first from left to right and keep update pos for char c and calculate the potential distance between each character and matching c\r\nthen loop through the same from right to left and then the result should be taking the min of current distance and previous min distance looping from left to right\r\n\r\ncode:\r\n'''\r\npublic int[] shortestToChar(String s, char c) {\r\n        \r\n        int len = s.length(), pos = -2*len ;\r\n        int[] result = new int[len];\r\n        \r\n        // from left to right\r\n        for(int i = 0; i< len; i++){\r\n            if(s.charAt(i) == c) {\r\n                pos = i;\r\n            }\r\n            result[i] = i - pos;\r\n        }\r\n        \r\n        // from right to left\r\n        pos = 2 * len;\r\n        for(int j = len - 1; j>=0; j--){\r\n            if(s.charAt(j) == c){\r\n                pos = j;\r\n            }\r\n            result[j] = Math.min(result[j], pos - j);\r\n        }\r\n        \r\n        return result;\r\n        \r\n    }\r\n'''\r\n\r\nTime: O(n) loop through twice so will be O(2n) but will be treated as O(n)\r\nSpace: O(n) result array with n length\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186575830","body":"Explanation:\r\nUse an array to represent the stack. Push will add a new integer to the array. Pop removes the last element in the array and increment will add value to the first k elements of the array.\r\n\r\ncode:\r\n```\r\nclass CustomStack {\r\n    \r\n    private int maxSize;\r\n    private List<Integer> stack;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize; \r\n        this.stack = new ArrayList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        int size = this.stack.size();\r\n        if(size >= maxSize) return;\r\n        this.stack.add(size, x);        \r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.stack.isEmpty()) return -1;\r\n        int lastVal = stack.get(this.stack.size() - 1);\r\n        this.stack.remove(this.stack.size() - 1);\r\n        return lastVal;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int increment_size = k<=stack.size() ? k : this.stack.size();\r\n        for(int i = 0; i < increment_size; i++){\r\n            stack.set(i, stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nTime: for push and pop which is going to be O(1), for increment is O(k) \r\nSpace: O(n) - as we used an array for backing up ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186690012","body":"code:\r\n```\r\npublic String decodeString(String s) {\r\n        int n = s.length();\r\n        Deque<Character> stack = new LinkedList<>();\r\n        char[] ss = s.toCharArray();\r\n        for (char c : ss) {\r\n            if (c != ']') {\r\n                stack.push(c);\r\n            } else {\r\n                StringBuilder sb = new StringBuilder();\r\n                while (!stack.isEmpty() && Character.isLetter(stack.peek())) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                stack.pop(); // skip :[\r\n                int num = 0;\r\n                int base = 1;\r\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\r\n                    num  += (stack.pop() - '0') * base;\r\n                    base *= 10;\r\n                }\r\n                String str = sb.toString();\r\n                 String temp = \"\";\r\n                while (num !=0){\r\n                    temp += str;\r\n                    num--;\r\n                }\r\n                for (Character t : temp.toCharArray()){\r\n                    stack.push(t);\r\n                }\r\n            }\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        for (char c : stack) {\r\n            sb.insert(0, c);\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188951908","body":"code:\r\n```\r\nclass MyQueue {\r\n    \r\n    Deque<Integer> stack1;\r\n    Deque<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new ArrayDeque<>();\r\n        stack2 = new ArrayDeque<>();\r\n        \r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n        \r\n    }\r\n    \r\n    public int pop() {\r\n        int result = this.peek();\r\n        stack2.poll();\r\n        return result;\r\n        \r\n    }\r\n    \r\n    public int peek() {\r\n        //什么时候stack2 empty 才从stack1 里面不断的push 新的data 进来\r\n        if(stack2.isEmpty()){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.poll());      \r\n            }\r\n        }\r\n        return stack2.peek();       \r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\ntime: peek and pop worst case O(n)\r\nspace: use two additional stack with O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189709208","body":"code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int n = arr.length;\r\n        int[] maxOfLeft = new int[n];\r\n        int[] minOfRight = new int[n];\r\n\r\n        maxOfLeft[0] = arr[0];\r\n        for (int i = 1; i < n; i++) {\r\n            maxOfLeft[i] = Math.max(maxOfLeft[i-1], arr[i]);\r\n        }\r\n\r\n        minOfRight[n - 1] = arr[n - 1];\r\n        for (int i = n - 2; i >= 0; i--) {\r\n            minOfRight[i] = Math.min(minOfRight[i + 1], arr[i]);\r\n        }\r\n\r\n        int res = 0;\r\n        for (int i = 0; i < n - 1; i++) {\r\n            if (maxOfLeft[i] <= minOfRight[i + 1]) res++;\r\n        }\r\n\r\n        return res + 1;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351570","body":"code \r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n        while(now != null){\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        k = k % count;\r\n        ListNode slow = head, fast = head;\r\n        while(fast.next != null){\r\n            if(k-- <= 0){\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\ntime: O(n)\r\nspace:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aouos":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185043729","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const len = num.length;\n  const stack = [];\n\n  for (let i = len - 1; i >= 0 || k > 0; i--) {\n    k = k + (num[i] || 0);\n    stack.push(k % 10);\n    k = Math.floor(k / 10);\n  }\n\n  return stack.reverse();\n};\n```\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186120127","body":"## 思路\n左右两次遍历\n\n## 代码\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n  const len = s.length;\n  const ans = new Array(len).fill(10001);\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] === c) {\n      ans[i] = 0;\n    } else {\n      if (i === 0) {\n        continue;\n      }\n      ans[i] = ans[i - 1] + 1;\n    }\n  }\n\n  for (let j = len - 1; j >= 0; j--) {\n    if (j + 1 !== len) {\n      ans[j] = Math.min(ans[j], ans[j + 1] + 1);\n    }\n  }\n\n  return ans;\n};\n```\n\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186465815","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.max = maxSize;\n  this.stack = [];\n  this.top = 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.top < this.max) {\n    this.stack.push(x);\n    this.top++;\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  if (this.top > 0) {\n    this.top--;\n    return this.stack.pop();\n  }\n\n  return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  const min = Math.min(k, this.top);\n  for (let i = 0; i < min; i++) {\n    this.stack[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606409","body":"```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  const numStack = [];\n  const strStack = [];\n  const len = s.length;\n  let num = 0;\n  let str = '';\n\n  for (let i = 0; i < len; i++) {\n    if (s[i] >= 0 && s[i] < 10) {\n      num = num * 10 + parseInt(s[i]);\n    } else if (s[i] === '[') {\n      numStack.push(num);\n      strStack.push(str);\n      num = 0;\n      str = '';\n    } else if (s[i] === ']') {\n      const times = numStack.pop();\n      str = strStack.pop() + str.repeat(times);\n    } else {\n      str += s[i];\n    }\n  }\n\n  return str;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138547","body":"```js\nvar MyQueue = function () {\n  this.orderStack = [];\n  this.rOrderStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.orderStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.rOrderStack.length) {\n    while (this.orderStack.length) {\n      this.rOrderStack.push(this.orderStack.pop());\n    }\n  }\n  return this.rOrderStack[this.rOrderStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.orderStack.length && !this.rOrderStack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190359101","body":"```js\n/**\n * @param {number[]} arr\n * @return {number}\n */\n var maxChunksToSorted = function (arr) {\n  const len = arr.length;\n  const stack = [];\n\n  for (let i = 0; i < len; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i]);\n    } else {\n      const temp = stack.pop();\n      while (stack.length && stack[stack.length - 1] > arr[i]) {\n        stack.pop();\n      }\n      stack.push(temp);\n    }\n  }\n\n  return stack.length;\n};\n\n// 时间复杂度 O(N)\n// 空间复杂度 O(N)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185062953","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        import math\r\n        n = max(len(num), int(math.log10(k))+1) + 1\r\n        result = [0] * n\r\n        num = [0] * (n - len(num)) + num\r\n        \r\n        carry = 0\r\n        for i in range(n - 1, -1, -1):\r\n            result[i] = num[i] + k % 10 + carry\r\n            carry = result[i] // 10\r\n            result[i] = result[i] % 10\r\n            k = k // 10\r\n            \r\n        if result[0] == 0:\r\n            return result[1:]\r\n        else:\r\n            return result\r\n```\r\n\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185734047","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        left = [float('inf')] * len(s)\n        right = [float(\"inf\")] * len(s)\n        \n        index_left = []\n        index_right = []\n        \n        for idx, ch in enumerate(s):\n            if ch == c:\n                index_left.append(idx)\n                index_right.append(idx)\n        \n        for i in range(len(s)-1, -1, -1):\n            if not index_left:\n                break\n            d = i - index_left[-1]\n            left[i] = d\n            if d == 0:\n                index_left.pop()\n        \n        for i in range(len(s)):\n            if not index_right:\n                break\n            d = index_right[0] - i\n            right[i] = d\n            if d == 0:\n                index_right = index_right[1:]\n                \n        result = []\n        for i in range(len(s)):\n            result.append(min(left[i],right[i]))\n        return result\n```\n时间复杂度：O(n)\n空间复杂度：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186255230","body":"# Increase every number for the increment operation\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1) for pop and push, O(n) for increment\n空间复杂度：O(1)\n\n# Increase at pop\n```python\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val\n```\n时间复杂度：O(1)\n空间复杂度：O(len(s))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186767291","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                num = ''\n                cur_s = ''\n                while stack[-1] != '[':\n                    cur_s = stack.pop() + cur_s\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * cur_s)\n            else:\n                stack.append(c)\n        return ''.join(stack)\n                \n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187977739","body":"```python\nclass MyQueue:\n    def __init__(self):\n        self.main_s = []\n        self.alt_s = []\n\n    def push(self, x: int) -> None:\n        self.main_s.append(x)\n\n    def pop(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s.pop()\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def peek(self) -> int:\n        while len(self.main_s) != 1:\n            self.alt_s.append(self.main_s.pop())\n        result = self.main_s[-1]\n        while self.alt_s:\n            self.main_s.append(self.alt_s.pop())\n        return result\n\n    def empty(self) -> bool:\n        return bool(self.main_s)\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189810329","body":"```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        s = []\n\n        for num in arr:\n            if s and s[-1] > num:\n                cur = s[-1]\n                while s and s[-1] > num:\n                    s.pop()\n                s.append(cur)\n            else:\n                s.append(num)\n        return len(s)\n```\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937521","body":"```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next:\n            return head\n        \n        n = 0\n        current = head\n        while current.next:\n            n += 1\n            current = current.next\n        \n        tail = current\n        n = n + 1\n        \n        if k%n == 0:\n            return head\n        \n        k = n - k % n - 1\n                \n        new_tail = head\n        for _ in range(k):\n            new_tail = new_tail.next\n        \n        new_head = new_tail.next\n        new_tail.next = None\n        tail.next = head\n        \n        return new_head\n```\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wengzhouyunfan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185063354","body":"\n```java\n  // key point : A > 0  add digit by digit\n  // input : int A[], int k     return: int []\n  // A.length <= 10000     T: O(n) < n^2\n  // brute force : \n  //   1) get last digit from k and cur A[i]; \n  //   2) add to array, renew carry and digit; \n  //   3) check carry, return array;\n\t  public int[] addInteger(int[]A, int K){\n\t    LinkedList<Integer> list = new LinkedList<Integer>();\n\t    int curA = A.length - 1;\n\t    int curK = K;\n\t    int carry = 0;\n\t    while(curA >= 0 || curK != 0){\n\t      int sum = curA < 0 ? carry + curK%10 : carry + A[curA] + curK%10;\n\t      int digit = sum % 10;\n\t      carry = sum / 10;\n\t      list.add(digit);  // add to end O(1) \n\t      curK/=10;\n\t      curA--;\n\t    }\n\t    if(carry != 0) list.addFirst(1); // add to head O(1)\n\t    return list.stream().mapToInt(x -> x).toArray(); // can't directly turn into primitive type O(n)\n\t  }\n```\nT: O(n)\nS: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185992291","body":"```java\n// S > 0   shortest dist   DP \n// input : char S[], char C   return int[]\n// A.length <= 10000   O(n) < n^2\n// brute force : \n//\t 1) find every s[i] == target, fill to left and right with dist until reach next target;  \n//\t 2) while finish filling, stop and find next target; \n//\t 3) finish filling and return res;\n//\n// improve:\n//   1) traverse from left to right, get left shortest dist from every target\n//   2) traverse from right to left, get right shortest dist from every target \n//   3) compare left and right and return res;\n\t  public int[] shortestToChar(char[]S, char C){\n\t\t  if(S.length == 1) return new int[] {0};\n\t\t  int[] res = new int[S.length];\n\t\t  Arrays.fill(res, S.length);\n\t\t  for(int i = 0, c = -1; i < S.length; i++){\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = i - c;\n\t\t\t  }\n\t\t  }\n\t\t  for(int i = S.length -1, c = -1; i >= 0; i--) {\n\t\t\t  if(S[i] == C) {\n\t\t\t\t  c = i;\n\t\t\t  }\n\t\t\t  if(c != -1) {\n\t\t\t\t  res[i] = Math.min(c - i, res[i]);\n\t\t\t  }\n\t\t  }\n\t\t  return res;\n\t  }\n```\nT:O(n)\nS:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186550641","body":"```java\n// use array to stimulate stack\n// every method must <= O(n^2)\nclass CustomStack {\n\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top < stack.length - 1) stack[++top] = x;\n    }\n    \n    public int pop() {  \n        return  top <= -1 ? -1 : stack[top --];\n    }\n    \n    public void increment(int k, int val) {\n        int len = Math.min(k, stack.length);\n        for (int i = 0; i < len; i++) {\n            stack[i] += val;\n        }      \n    }\n}\n```\nT:\npush(): O(1)\npop(): O(1)\nincrement(): O(n)\nS: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187576674","body":"\n```java\n    // key point : stack  decode string\n    public String decodeString(String s) {\n        String res = \"\";\n        String repeat = \"\";\n        Deque<String> stack = new ArrayDeque<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack.push(res.toString());\n                res = \"\";\n                stack.push(repeat);\n                repeat = \"\";\n            }\n            else if(c == ']') {\n                String tmp = \"\";\n                int cur_rpeat = Integer.parseInt(stack.pop());\n                for(int i = 0; i < cur_rpeat; i++) tmp += res;\n                res = stack.pop() + tmp;\n            }\n            else if(c >= '0' && c <= '9') repeat += c ;\n            else res += c;\n        }\n        return res.toString();\n    }\n```\nT:O(n)\nS:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188415329","body":"```java\n\n// design data structure\n// input integer 1 - 9    S <= O(n^4)\nclass MyQueue{\n    Stack<Integer> out, in;\n    public MyQueue() {\n        in = new Stack<>();\n        out = new Stack<>();\n    }\n    \n    public void push(int x) {\n        in.push(x); // O(1)\n    }\n    \n    public int pop() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        } // O(n)\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) out.push(in.pop());\n        }//O(n)\n        return out.peek();\n    }\n    \n    public boolean empty() {//O(1)\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n// T: push: O(1), peek: O(n), pop: O(n), empty: O(1) \n// Amortized T: push: O(1), peek: O(1), pop: O(1), empty: O(1) \n// S: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461632","body":"find chunck  =>   check sum\n```java\n    public int maxChunksToSorted(int[] arr) {\n        int curMax = arr[0];\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                curMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.isEmpty()){\n                    if (arr[i]>=stack.peek()){\n                        stack.push(curMax);\n                        break;\n                    }\n                    stack.pop();\n                }\n                if (stack.isEmpty()){\n                    stack.push(curMax);\n                }\n            }\n        }\n        return stack.size();\n    }\n//T:O(n) S:O(n)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whisht":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185072053","body":"1. 将 num 转为 数字\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        t = 10\r\n        n = len(num)\r\n        res = 0\r\n        for i in range(n):\r\n            res += t**i*num[n-i-1]\r\n        res += k\r\n        print(res)\r\n        out = []\r\n        while res:\r\n            out.append(res%10)\r\n            res = res//10\r\n        return out[::-1]\r\n```\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(N)$\r\n\r\n2. 逐位相加\r\n>  ![image](https://user-images.githubusercontent.com/16497652/179130663-29ae5da6-b53c-4569-bd7c-327bf30c97e6.png)\r\n> [https://leetcode.cn/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/](url)\r\n\r\n``` python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        carry = 0\r\n        res = []\r\n        if len(num)<len(str(k)):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = max(len(str(k)),len(num))-1\r\n        while n>=0 or k:\r\n            sums = num[n]+k%10+carry\r\n\r\n            basic = sums%10\r\n            carry = sums//10\r\n            res.insert(0,basic)\r\n\r\n            n -= 1\r\n            k//=10\r\n        if carry:\r\n            res.insert(0,carry)\r\n            return res\r\n        else:\r\n            return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098194","body":"* 从左到右正序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到左侧字符 `c` 的距离\n* 从右到左逆序遍历一次字符串 `s`，记录字符串 `s` 中每个字符到右侧字符 `c` 的距离\n需要考虑的是最开始没有出现 `c` 时，`c` 的位置该如何处理，要保证使用该位置计算后的距离不会影响最终的结果。\n* 初始化 `s` 中各字符的距离为无穷大（ s 长度）\n* 正序遍历记未出现`c`的位置为 `-1`\n* 逆序遍历记未出现`c`的位置为 `n`\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n        \n```\n## 复杂度\n* 时间复杂度：遍历`s`即可，$O(N)$\n* 空间复杂度： 和`s`等长的结果数组，$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186423067","body":"``` python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack)>0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack)<k:\n            self.stack = [i+val for i in self.stack]\n        else:\n            self.stack[:k] = [i+val for i in self.stack[:k]]\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186677475","body":"### 思路\n将每个字符入栈，当遇到`']'`时出栈，直至遇到`'['`，`'['`前的所有数字出栈，即为`k`，将出栈得到的括号内所有字符重复 `k`次，入栈。\n### 代码\n``` python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        for i in s:\n            if i == \"]\":\n                tmp = stack.pop()\n                ch = \"\"\n                while tmp != \"[\":\n                    ch = tmp + ch\n                    tmp = stack.pop()\n                time = 0\n                c = 0\n                while stack and stack[-1].isdigit():\n                    t1 = stack.pop()\n                    time += int(t1) * 10 ** c\n                    c+=1\n                ch = ch * time\n                stack.append(ch)\n            else:\n                stack.append(i)\n        if stack:\n            res = \"\".join(i for i in stack)\n        return res\n```\n### 复杂度\n* 时间复杂度：$O(N)$，需要遍历一遍字符\n* 空间复杂度：$O(N)$，主要来源于栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499379","body":"## 思路\n用两个栈实现队列。一个栈执行 `push`操作，另一个栈执行 `pop` 和 `peek` 操作。当队列出队时，将`push`到第一个栈的所有元素出栈至第二个栈，栈中元素即为第一个栈的逆序排列，栈顶元素即使队头元素。\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.inqueue = []\n        self.outqueue = []\n\n    def push(self, x: int) -> None:\n        self.inqueue.append(x)\n\n    def pop(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue.pop()\n\n    def peek(self) -> int:\n        if not self.outqueue:\n            while self.inqueue:\n                self.outqueue.append(self.inqueue.pop())\n        return self.outqueue[-1]\n\n    def empty(self) -> bool:\n        if not self.inqueue and not self.outqueue: # 两个栈均为空时\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n## 复杂度\n* 空间复杂度： $2N \\rightarrow O(N)$\n* 时间复杂度：\n    * 入队：$O(1)$\n    * 出队：$O(N)$\n    * peek：$O(N)$\n    * empty：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189804822","body":"## 思路\n* 从题目可知左侧块的最大值应小于右侧块的最小值，从而记录下每一个局部最大值即是答案。\n* 每个块的最大值从左到右顺序递增，使用单调递增栈（入栈元素大于等于栈中所有元素）进行记录。\n* 由于单调递增栈每个元素入栈时都要把比当前元素大的所有值出栈后再入栈，修改原始递增栈为局部最大值入栈即可。\n## 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: stack.append(num)\n#        print(stack)\n        return len(stack)\n```\n## 复杂度\n* T: $O(N)$\n* S: $O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190931989","body":"## 思路\n* 将链表首尾串联形成循环链表\n* 旋转 k 次后的尾结点位置为 $(len(link) - k)\\% len(link)$，从该位置断开，取该位置下个结点为头节点即可。\n## 代码\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return None\n        length = 1\n        cur = head\n        while cur.next:\n            cur = cur.next\n            length+=1\n        target = (length-k)%length \n        # print(target)\n        cur.next = head\n        # cur = head\n        for _ in range(target):\n            cur = cur.next\n        head = cur.next\n        cur.next = None\n        return head\n```\n## 复杂度\n* T: $O(N)$\n* S:$O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bzlff":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185074522","body":"### 思路\n将list→str→int → result+k → str → list\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        \n        result = int(''.join(map(str, num))) + k\n        \n        return [int(i) for i in str(result)]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186187289","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        \n        n = len(s)\n        ans = [0] * n\n        idx = -n\n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx-i)\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186540856","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stack) - 1:\n            self.top += 1\n            self.stack[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1: \n            return -1\n        ans = self.stack[self.top]\n        self.top -= 1\n\n        return ans\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186999400","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        \n        ans = []\n        \n        for c in s:\n            \n            if c == ']':\n                temp_str = ''\n                temp_iter = ''\n                while ans and ans[-1] != '[':\n                    temp_str = ans.pop() + temp_str\n                ans.pop()\n                \n                while ans and ans[-1].isdigit():\n                    temp_iter = ans.pop() + temp_iter\n                    \n                ans.append(temp_str * int(temp_iter))\n            else:\n                ans.append(c)\n                \n        return ''.join(ans)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157737","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self._in_stack, self._out_stack, self._front = [], [], None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self._in_stack:  # 判断有没有元素\n            self._front = x  # 表示队首\n        \n        self._in_stack.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # 如果空, 添加元素\n            while self._in_stack:\n                self._out_stack.append(self._in_stack.pop())\n        \n        return self._out_stack.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.empty():\n            raise Exception(\"[ERROR] The queue is empty!\")\n\n        if not self._out_stack:  # 空的话，直接输出None\n            return self._front\n        else:\n            return self._out_stack[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return not self._in_stack and not self._out_stack\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzkains":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185077761","body":"y总说这个是高精度加法\n# 高精度加法\nc++中的高精度加法一般是从低位到高位\n所以需要reverse\n然后正常加就行\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        for (int & c : num) {\n            k += c;\n            c = k % 10;\n            k /= 10;\n        }\n        while (k) num.push_back(k % 10), k /= 10;\n        reverse(num.begin(), num.end());\n        return num;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186107567","body":"# 思路\n左边右边分别求一下最近的值，然后求最小\n# 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, INT_MAX);\n        for (int i = 0, j = -1; i < n; i ++) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = i - j;\n        }\n        for (int i = n - 1, j = -1; i >= 0; i --) {\n            if (s[i] == c) j = i;\n            if (j != -1) res[i] = min(res[i], j - i);\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394469","body":"# 思路\n数组模拟栈\n# 代码\n```C++\nclass CustomStack {\npublic:\n    vector<int> stk, inc;\n    int maxsize;\n    \n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n    }\n    \n    void push(int x) {\n        if (stk.size() < maxsize) {\n            stk.push_back(x);\n        }\n        return ;\n    }\n    \n    int pop() {\n        // 考虑数组为空的情况\n        if (stk.size()) {\n            int t = stk.back();\n            stk.pop_back();\n            return t;\n        }\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        int l = min(k, (int)stk.size());\n        for (int i = 0; i < l; i ++) {\n            stk[i] += val;\n        }\n        return ;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186781852","body":"# 思路\n按规则 dfs 结果\n# 代码\n```C++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188480408","body":"# 思路\n简单模拟题\n# 代码\n```C++\nclass MyQueue {\npublic:\n    stack<int> a, b;\n\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        a.push(x);\n    }\n    \n    int pop() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        b.pop();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    int peek() {\n        while (a.size()) {\n            b.push(a.top());\n            a.pop();\n        }\n        int c = b.top();\n        while (b.size()) {\n            a.push(b.top());\n            b.pop();\n        }\n        return c;\n    }\n    \n    bool empty() {\n        return a.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189700997","body":"# 思路\n贪心解法，排序后数组和原数组相比较，找到分界点\n# 代码\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> sarr = arr;\n        sort(sarr.begin(), sarr.end());\n        unordered_map<int, int> cnt;\n        int res = 0;\n        for (int i = 0, s = 0; i < arr.size(); i ++) {\n            if (cnt[arr[i]] == 1) s --;\n            else if (cnt[arr[i]] == 0) s ++;\n            cnt[arr[i]] --;\n            if (cnt[sarr[i]] == -1) s --;\n            else if (cnt[sarr[i]] == 0) s ++;\n            cnt[sarr[i]] ++;\n            if (!s) res ++;\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191186843","body":"# 思路\n链表模拟题\n# 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head) return head;\n        int n = 0;\n        for (ListNode* p = head; p; p = p->next) n ++;\n        k %= n;\n        if (!k) return head;\n\n        ListNode* f = head;\n        while (k -- && f) f = f->next;\n        ListNode* s = head;\n        while (f->next) {\n            s = s->next;\n            f = f->next;\n        }\n        f->next = head;\n        head = s->next;\n        s->next = NULL;\n        return head;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenmengyu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084170","body":"# 思路\n类似于大数相加，由于可能溢出，所以把两个数转成数组存储，从数组对应的数字低位开始相加，若同位相加大于10，需要进位。\n\n# 代码JS\n```js\nvar addToArrayForm = function(num, k) {\n    let num2 = (k + '').split('')\n    let len = Math.max(num.length, num2.length)\n    let flag = 0 // 进位标志\n    let result = []\n    num.reverse()\n    num2.reverse()\n    for (let i = 0; i < len; i++) {\n        let sum = (num[i] || 0) + (num2[i] || 0) / 1 + flag\n        flag = Math.floor(sum / 10)\n        sum = sum % 10\n        result.push(sum)\n    }\n    if (flag) {\n        result.push(flag)\n    }\n    return result.reverse()\n};\n```\n# 复杂度\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191642","body":"### 思路\r\n先找出字符c在字符串s中的所有下标数组cArr，然后先遍历字符串s，再遍历数组cArr，获得字符串s中每个字符下标和cArr中值的最小距离。\r\n### 代码\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n    let len = s.length\r\n    let cArr = []\r\n    let start = 0\r\n    let index, answer = []\r\n    while(~(index = s.indexOf(c, start))) {\r\n        cArr.push(index)\r\n        start = index + 1\r\n    }\r\n    for (let i = 0; i < s.length; i++) {\r\n        let temp\r\n        for (let j = 0; j < cArr.length; j++) {\r\n            if (temp === void 0) {\r\n                temp = Math.abs(i - cArr[j])\r\n            } else {\r\n                temp = Math.min(Math.abs(i - cArr[j]), temp)\r\n            }\r\n        }\r\n        answer.push(temp)\r\n    }\r\n    return answer\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186501052","body":"### 思路\r\n数组模拟栈\r\n### 代码\r\njs\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = []\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length > 0) {\r\n        return this.stack.pop()\r\n    } else {\r\n        return -1\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for (let i = 0; i < this.stack.length && i < k; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187595971","body":"### 思路\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let stack = [], resStack = []\r\n    let num = 0\r\n    let str = ''\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === '[') {\r\n            stack.push(num)\r\n            resStack.push(str)\r\n            num = 0\r\n            str = ''\r\n        } else if (s[i] === ']') {\r\n            let count = stack.pop()\r\n            let temp = new Array(count).fill(str).join('')\r\n            str = resStack.pop() + temp\r\n        } else if (/\\d/.test(s[i])) {\r\n            num = num * 10 + s[i] * 1\r\n        } else {\r\n            str += s[i]\r\n        }\r\n    }\r\n    return str\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188839685","body":"### 思路\n栈只能后进先出\n### 代码\n```js\nvar MyQueue = function() {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n     return this.outStack[this.outStack.length - 1];\n};\nMyQueue.prototype.in2out = function() {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop());\n    }\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190051620","body":"### 代码\n\n```JS\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n\n    return count;\n};\n```\n### 复杂度\n时间复杂度：O(NlogN) \n控件复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uancen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185084621","body":"## Idea\n\n首先循环处理num，k提供加数/辅助处理进位\n\n再单独拿出一个循环处理剩下的k，直接加在num头部\n\n## Code\n\n```GO\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\nfunc addToArrayForm(num []int, k int) []int {\n\tvar res_head []int\n\tvar n int = len(num)\n\ti := n - 1\n\tfor i >= 0 || k > 0 {\n\t\tif i < 0 {\n\t\t\tbreak\n\t\t}\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tsum -= 10\n\t\t\tk++ // add the 10 as 1 to k\n\t\t}\n\t\tnum[i] = sum // 0<=sum<=9\n\t\ti--\n\t}\n\tfor k > 0 {\n\t\tres_head = append(res_head, k%10)\n\t\tk /= 10\n\t}\n\treverse(res_head)\n\tnum = append(res_head, num...)\n\treturn num\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197390","body":"## Idea\n\nres[i] = min(d to left c, d to right c)\n\n* first loop from l to r: record \"c\" as idx and update res[i]=i-idx\n* second loop from r to l: record \"c\" as idx and update res[i]=min(res[i], idx-i) \n\n## Code\n\n```go\nfunc min(a, b int) int {\n\tif a > b {\n\t\treturn b\n\t} else {\n\t\treturn a\n\t}\n}\nfunc shortestToChar(s string, c byte) []int {\n\t// res[i] = min(d to left c, d to right c)\n\tn := len(s)\n\tres := make([]int, n)\n    // -n --> make res[i] = (i + n) large enough for the second round iteration to overwrite it\n\tidx := -10007 \n\tfor i, a := range s {\n\t\tif byte(a) == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = i - idx\n\t}\n    // \n    // 2n --> make (2n - i) large enough for the first iteration record to be min\n\tidx = 20007\n\tfor i := n - 1; i >= 0; i-- {\n\t\tif s[i] == c {\n\t\t\tidx = i\n\t\t}\n\t\tres[i] = min(res[i], idx-i)\n\t}\n\treturn res\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1) | return not considered ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371628","body":"## Idea\n\nstk array +  cur --> top\n\nuse diff to implement incrementing \n\n## Code\n\n```go\ntype CustomStack struct {\n\tstk  []int\n\tdiff []int\n\tcur  int\n}\n\nfunc Constructor(maxSize int) CustomStack {\n\treturn CustomStack{\n\t\tcur:  -1,\n\t\tstk:  make([]int, maxSize, maxSize),\n\t\tdiff: make([]int, maxSize, maxSize),\n\t}\n}\n\nfunc (this *CustomStack) Push(x int) {\n\tif this.cur < len(this.stk)-1 {\n\t\tthis.cur++\n\t\tthis.stk[this.cur] = x\n\t}\n}\n\nfunc (this *CustomStack) Pop() int {\n\tif this.cur == -1 {\n\t\treturn -1\n\t}\n\tres := this.stk[this.cur] + this.diff[this.cur]\n\tif this.cur != 0 {\n\t\tthis.diff[this.cur-1] += this.diff[this.cur]\n\t}\n\tthis.diff[this.cur] = 0\n\tthis.cur--\n\treturn res\n}\n\nfunc (this *CustomStack) Increment(k int, val int) {\n\tif this.cur == -1 {\n\t\treturn\n\t}\n\tif k > this.cur+1 {\n\t\tthis.diff[this.cur] += val\n\t} else {\n\t\tthis.diff[k-1] += val\n\t}\n}\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636290","body":"## Idea\n\n遍历字符串，分情况处理\n\n* 数字\n* 字母\n* [\n  * 进入到新的[]，需要重新记录对应的num和str\n  * 则上个[]的num和str入栈，记录该num和str\n* ]\n  * num和str出栈，拼接\n\n整体理解为进入到最里面的[]，向外扩展；肯定还可以用递归实现，下次看到再写吧~\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    string decodeString(string s)\n    {\n        vector<string> strstk;\n        vector<int> numstk;\n\n        int num = 0;\n        string str = \"\";\n        for (char c : s)\n        {\n            if (c >= '0' && c <= '9')\n            {\n                num *= 10;\n                num += (c - '0');\n            }\n            else if (c == '[')\n            {\n                numstk.push_back(num);\n                strstk.push_back(str);\n                num = 0;\n                str = \"\";\n            }\n            else if (c == ']')\n            {\n                int numtmp = numstk.back();\n                string strtmp = strstk.back();\n                numstk.pop_back();\n                strstk.pop_back();\n                for (int i = 0; i < numtmp; i++)\n                {\n                    strtmp = strtmp + str;\n                }\n                str = strtmp;\n            }\n            else\n            {\n                str += c;\n            }\n        }\n        return str;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)\n  * 辅助栈的极端情况","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484263","body":"## Idea\n\n双栈模拟队列；而非栈+辅助栈模拟队列\n\n**后者push总是O(N)**，pop简单为O(1)。\n\n但是在双栈模拟情况下，仍能保证pop为O(1)，即进行一次O(N)操作后，在s2不为空前，总是O(1)的操作。\n\n## Code\n\n```cpp\nclass MyQueue {\npublic:\n\t// stack in\n\tstack<int> s1;\n\t// stack out\n\tstack<int> s2;\n    MyQueue() {\n    \n    }\n    \n    void push(int x) {\n    \ts1.push(x);\n    }\n    \n    int pop() {\n    \tif(s2.empty())\n    \t{\n    \t\twhile(!s1.empty())\n    \t\t{\n    \t\t\ts2.push(s1.top());\n    \t\t\ts1.pop();\n    \t\t}\n    \t}\n    \tint res = s2.top();\n    \ts2.pop();\n    \treturn res;\n    }\n    \n    int peek() {\n    \tint res = this->pop();\n    \ts2.push(res);\n    \treturn res;\n    }\n    \n    bool empty() {\n    \treturn s1.empty()&&s2.empty();\n    }c\n};\n```\n\n## Complexity\n\n* Time O(1)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460557","body":"## Idea\n\n单调栈\n\n## Code\n\n```java\n// 参考题解，没有特别理解\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190929199","body":"## Idea\n\n利用环找到新的头尾节点，因为内部关系没变，只修改\n\n* 尾节点指向头节点\n* 找到新的尾节点后\n  * 设置新头节点（新尾节点的下一个）\n  * 设置新尾节点（next置为nullptr）\n\n## Code\n\n```cpp\nclass Solution\n{\npublic:\n    ListNode *rotateRight(ListNode *head, int k)\n    {\n        if (head == nullptr || head->next == nullptr)\n        {\n            return head;\n        }\n        if (k == 0)\n        {\n            return head;\n        }\n        ListNode *tail = head;\n        ListNode *newtail = head;\n        ListNode *newhead;\n        int n = 1;\n        // 原来的尾结点指向原来的头结点，形成环\n        while (tail->next != nullptr)\n        {\n            tail = tail->next;\n            n++;\n        }\n        tail->next = head;\n        // 找到断开环的位置\n        for (int i = 0; i < (n - k % n - 1); i++)\n        {\n            newtail = newtail->next;\n        }\n        // 新的头结点指向断开环的位置\n        newhead = newtail->next;\n        newtail->next = nullptr;\n\n        return newhead;\n    }\n};\n```\n\n## Complexity\n\n* Time O(N)\n* Space O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nuomituxedo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185093417","body":"## 思路\r\n1. convert to num to integer\r\n2. add k to integer to get sum\r\n3. convert sum to list of integers\r\n\r\n## 代码 （Python)\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        num_int = int(''.join(map(str, num)))\r\n        sum = num_int + k\r\n        new_num = []\r\n        for d in str(sum):\r\n            new_num.append(int(d))\r\n        return new_num\r\n```\r\n\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186098624","body":"## 思路\r\n1. initialize the res array with the largest possible distance：len(s) \r\n2. iterate through the input, if we encounter c, update res for indices < index of latest c and memorize the index of the latest c\r\n3. update res for indices >= index of latest c until we encounter the next c\r\n\r\n## Code\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        last_c = 0\r\n        for i in range(0, len(s)):\r\n            res.append(len(s))\r\n        for i in range(0, len(s)):\r\n            if s[i] == c:\r\n                #update left hand side up to the last seen c\r\n                for j in range (last_c, i):\r\n                    res[j] = min(res[j], i-j)\r\n                last_c = i\r\n                #update right hand side\r\n                for j in range (i, len(s)):\r\n                    res[j] = j - i\r\n                    # stop updating right side if see next c\r\n                    if s[j] == c:\r\n                        continue\r\n        return res\r\n```\r\n\r\n### time complexity: O(n)\r\n### space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186290559","body":"## 思路 (python)\n用list来实现stack\n\n## Code\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n        \n    def push(self, x: int) -> None:\n        if len(self.stack) == self.n: return\n        self.stack.append(x)\n        return\n        \n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(len(self.stack), k)):\n            self.stack[i] += val\n```\n\n## 时间复杂度\npop: O(1) \npush: O(1)\nincrement: O(k), 1<= k <=n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187674314","body":"## 思路 （用stack)\n遍历input string\n如果element不是“]\", 放进stack\n如果element是”[\", 算出repeatSubstring, 然后放入stack\n最后把返回stack里的elements as a string\n\n## Code (python)\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for c in s:\n            if c != \"]\":\n                stack.append(c)\n            else:\n                repeatSubstring=\"\"\n                multiplier=\"\"\n                while stack and stack[-1] !='[':\n                    repeatSubstring = stack.pop() + repeatSubstring\n                stack.pop() #remove '['\n                while stack and stack[-1].isnumeric():\n                    multiplier=stack.pop() + multiplier\n                stack.append(repeatSubstring*int(multiplier))\n        return \"\".join(stack)\n```\n\n### time complexity: O(n)\n### space compolexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189212437","body":"## 思路 \n用两个stack来实现queue, stack2的作用是暂时缓存stack1的elements\n\n## Code (python)\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2.pop()\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def peek(self) -> int:\n        front_element=None\n        while(self.stack1):\n            self.stack2.append(self.stack1.pop())\n        front_element=self.stack2[-1]\n        while(self.stack2):\n            self.stack1.append(self.stack2.pop())\n        return front_element\n\n    def empty(self) -> bool:\n        return len(self.stack1)==0\n```\n\n### 时间复杂度： push O(1), pop和peek O(n), empty O(1)\n### 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190445393","body":"## 思路\n参考了答案 自己没想出来\nThe key idea here is: at any time where both counter arrays are identical it means we've reached a new sortable chunk \n\n## code:\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        chunks, counter_a, counter_b = 0, collections.Counter(), collections.Counter()\n        for a, b in zip(arr, sorted(arr)):\n            counter_a[a] += 1\n            counter_b[b] += 1\n            #at any time where both counter arrays are identical\n            #it means we've reached a new sortable chunk \n            chunks += counter_a == counter_b\n        return chunks\n```\n\n### time complexity:  sorting: O(nlogn), check for identical counter arrays: O(n^2) --> overall: O(n^2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970849","body":"## 思路\r\nbrute force\r\n如果head为空 直接返回空\r\n先遍历一遍linkedlist找到长度，先简化一下k (k=k % length)\r\n遍历到倒数k的node 切断与前面node的连接 让它变成新的head node\r\n把第二个linkedlist的尾巴连到原始的head上\r\n\r\n##代码（Python）\r\n```python\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        ### return if head is empty\r\n        if not head: return None\r\n        \r\n        # find out the total number of nodes in the linkedlist\r\n        # apply modulo to k to get the actual number of rotations needed\r\n        length = -1\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        while dummy:\r\n            length += 1\r\n            dummy = dummy.next\r\n        k = k % length\r\n        # if no rotation is needed, directly return head\r\n        if k == 0: return head\r\n        \r\n        # 1. create a dummy node, travel the list nodes to the node to be cut (new end)\r\n        # 2. after this operation we end up with 2 smaller linkedlists\r\n        dummy = ListNode(0)\r\n        dummy.next = head\r\n        for i in range(0, length - k):\r\n            dummy = dummy.next\r\n        new_head = ListNode(0)\r\n        new_head = dummy.next # new_head points to the new head node\r\n        \r\n        dummy.next = None #make dummy the end node, now we have 2 linkedlists\r\n        \r\n        # 3. create dummy2 to point to the second linkedlist and travel to its end node\r\n        dummy2 = ListNode(0)\r\n        dummy2 = new_head\r\n        \r\n        while dummy2.next:\r\n            dummy2 = dummy2.next\r\n        \r\n        # 4. now relink the two linkedlists\r\n        dummy2.next = head\r\n        return new_head\r\n```\r\n空间复杂度： O(1)\r\n时间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongranherz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185096544","body":"## 思路\n1.将 num和k从后往前相加，两者长度未知，通过 while k!=0 or i>=0 来使长度统一。\n2.每一位的累加和sum放入res中，是否进位通过carry判断。\n3.while完毕后，需要判断carry是否为零。\n\n##  python代码\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res=[]\n        carry=0\n        i=len(num)-1\n        while k!=0 or i>=0:\n            x=num[i] if i>=0 else 0 \n            y=k%10 if k!=0 else 0\n\n            sum = x+y+carry\n            res.append(sum%10)\n            carry=sum//10\n\n            i-=1\n            k//=10\n        \n        if carry!=0: res.append(carry)\n\n        return res[::-1]\n```\n## 复杂度分析\n设N为数组长度\n时间复杂度： O(max(N，K))\n空间复杂度： O(max(N，K))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190287","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        res = [n+1]*n\n        idx = -1\n        for i in range(n):  # 左侧 c 位置\n            if s[i]==c:\n                idx = i\n            if idx!=-1:\n                res[i] = i - idx\n        idx = n\n        for i in range(n-1,-1,-1): # 右侧 c 位置\n            if s[i] == c:\n                idx = i\n            if idx!= n:\n                res[i]= min(idx - i,res[i])\n        return res\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413552","body":"## python代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.length=0\n        self.maxSize=maxSize\n    def push(self, x: int) -> None:\n        if self.length!=self.maxSize:\n            self.stack.append(x)\n            self.length+=1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.length-=1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i]+=val\n\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186814030","body":"解法一：辅助栈法\n本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\n\n算法流程：\n\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n\t当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n\t当 c 为字母时，在 res 尾部添加 c；\n\t当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 0：\n\t\t记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；\n\t\t记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n\t\t进入到新 [ 后，res 和 multi 重新记录。\n\t当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:\n\t\tlast_res是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n\t\tcur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n返回字符串 res。\n\n复杂度分析：\n\n时间复杂度 O(N)，一次遍历 s；\n空间复杂度 O(N)，辅助栈在极端情况下需要线性空间，例如 2[2[2[a]]]。\n\n```\n# k神写法\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9': # 这里用isdigit（）合适\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n# 自己的\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # (str, int) 记录之前的字符串和括号外的上一个数字\n        num = 0\n        res = \"\"  # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c\n        return res\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539903","body":"# 用两个栈解决\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.A, self.B = [], []\n    \n    def push(self, x: int) -> None:\n        self.A.append(x)\n\n    def pop(self) -> int:\n        if self.B: return self.B.pop()\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B.pop()\n\n    def peek(self) -> int:\n        if self.B: return self.B[-1]\n        #if not self.A: return -1\n        while self.A:\n            self.B.append(self.A.pop())\n        return self.B[-1]\n\n    def empty(self) -> bool:\n        if self.A or self.B:\n            return False\n        else:\n            return True\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768482","body":"理解排序块：也就是分好块之后进行排序，将所有块连在一起可以成为升序排序。\n比如[7，8，1]，后面出现了一个1，导致前面的都需要一起排序。\n\n如何将题目和单调栈联系在一起：\n1 单调栈，保证栈是递增的，如果出现一个小于栈顶的数字x，保存栈顶并弹出，然后弹出栈中比x小的数字，最后存入栈顶。记录栈的长度\n2 题目中，数组需要是递增的，如果出现一个小于前面数字的数字x，则将前面大于x的数字都需要进行排序（类似上面栈顶弹出的操作）\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \t\t\t\t\t # 栈顶对比\n                head = stack.pop()\t\t\t\t\t\t\t # 保存栈顶\n                while stack and num < stack[-1]: stack.pop() # 弹出栈中比x小的数字，\n                stack.append(head)\t\t\t\t\t\t     # 存入栈顶\n            else: stack.append(num)\n        return len(stack)\n```\n\n复杂度分析：\n时间复杂度 O(N) \n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191123114","body":"# 方法1：每次右移1格，k次执行k次。但是方法超时。\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next: return head\n        def rightmove(head):\n            pre=head\n            cur=head\n            tailpre=ListNode(-1)\n            tailpre.next=head\n            tail=head\n            while cur:\n                cur=cur.next\n                if cur:\n                    tail=tail.next\n                    tailpre=tailpre.next\n            tailpre.next=None\n            tail.next=pre\n\n            return tail\n        \n        while k>0:\n            k-=1\n            head=rightmove(head)\n        \n        return head\n```\n# 方法2，成环，成环之后右移动k次，然后断开。\n代码就不写了，想法比较重要","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gr52":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097387","body":"/*\r\n思路 \r\n先将数组x遍历,用字符串类型拼接,强制转换与k相加,\r\n在csdn 找到的方法(大佬求解释,不太懂)直接将数值,转换成字符串\r\n*/\r\n//代码\r\nvar x=[1,2,3,4]\r\nvar k=54\r\nfor(var i=0,str='';i<x.length;i++){\r\n        str+=x[i]\r\n}\r\nvar A=Number(str)+k\r\n const converToArray = number => [...`${number}`].map(el => parseInt(el))\r\nconsole.log(converToArray(A) ); \r\n//复杂度：\r\n//时间复杂度： O（n）\r\n//空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186209924","body":"var shortLen = function(s, c) {\r\nvar s2 = Array(s.length).fill(0);\r\nfor (var i = 0; i < s.length; i++) {\r\n                       if (s1[i] === c) {\r\n                       continue;\r\n                       }\r\nfor (let j = i, count1 = 0; j < s.length; j++, count1++) {\r\n                        if (s1[j] === c) {\r\n                        return count1;\r\n                      }\r\n}\r\nfor (let j = s.length, count2 = 0; j >= 0; j--, count2++) {\r\n                      if (s1[j] === c) {\r\n                      return count2;\r\n                        }\r\n}\r\n         s2[i] = Math.min(count1, count2);\r\n}\r\nconsole.log(s2);\r\n}\r\n\r\nvar s = \"loveleetcode\", c = 'e';\r\nconsole.log(shortLen(s, c));\r\n##时间复杂度\r\n空间O(N^2)\r\n时间O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188954566","body":"### 思路就是用两个栈来模拟队列，当进行弹出操作时，将一个栈的元素全部弹出，再压入另一个栈，栈顶元素就为最先进入的元素\r\nvar MyQueue = function() {\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n\r\nMyQueue.prototype.push = function(x) {\r\n  this.stack1.push(x);\r\n};\r\n\r\n\r\nMyQueue.prototype.pop = function() {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n\r\n  return this.stack2.pop();\r\n};\r\n\r\n\r\nMyQueue.prototype.peek = function() {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  } else {\r\n    return this.stack1[0];\r\n  }\r\n};\r\n\r\n\r\nMyQueue.prototype.empty = function() {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n### 复杂度\r\n时间复杂度：O（1）\r\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hydelovegood":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185097824","body":"# 整体思路\r\n1. 转换num或转换K，相加后再转换成数组\r\n2. 防止进位问题，可以将数组转换成数字，而后和k相加，再转换成数组\r\n# 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s, m = 0, 1\r\n        ans = []\r\n        for i in num[::-1]:\r\n            s += i * m\r\n            m *= 10\r\n        s += k\r\n        for i in str(s):\r\n            ans.append(int(i))\r\n        return ans\r\n```\r\n# 复杂度分析\r\n- 时间复杂度On\r\n- 空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075787","body":"# 思路\n首尾两次遍历\n# 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546631","body":"# 思路\n模拟所有的操作，注意边界条件和特判\n# 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n# 复杂度\n时间复杂度On\n空间复杂度On\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612890","body":"# 思路\r\n使用一个栈和一个数组解决问题\r\n# 代码\r\n ```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字\r\n        num = 0\r\n        res = \"\"  # 实时记录当前可以提取出来的字符串\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n# 复杂度分析\r\n时间复杂度On\r\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188535834","body":"# 思路\n使用两个栈，第一个记录进队元素，第二个记录队头元素\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190270184","body":"今天的题目有点难，没有思路，学习了一波单调栈\n# 思路\n对于第i个数 当且仅当i和它前面所有数的最大值 小于 i后面所有数的最小值时 可以把i和它前面的数分出去 结果 + 1\n# 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr = zip(arr, range(len(arr)))\n        arr = sorted(arr)\n        arrs = [0]*len(arr)\n        for idx,i in enumerate(arr):\n            arrs[i[1]] = idx\n        m = -float('inf')\n        res = 0\n        for i in range(len(arrs)):\n            m = max(m, arrs[i])\n            if m == i:\n                res += 1\n        return res\n```\n引用自力扣 @Thinking first\n# 复杂度分析\n时间复杂度On\n空间复杂度On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191071447","body":"# 思路\n双指针典型题，取巧的话可以转成数组再转回来\n# 代码\n```python\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        # 双指针\n        if head:\n            p1 = head\n            p2 = head\n            count = 1\n            i = 0\n            while i < k:\n                if p2.next:\n                    count += 1\n                    p2 = p2.next\n                else:\n                    k = k % count\n                    i = -1\n                    p2 = head\n                i += 1\n\n            while p2.next:\n                p1 = p1.next\n                p2 = p2.next\n\n            if p1.next:\n                tmp = p1.next\n            else:\n                return head\n            p1.next = None\n            p2.next = head\n            return tmp\n```\n# 复杂度分析\n时间复杂度On\n空间复杂度O1","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nikojxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185098164","body":"## 思路\r\n每次循环，把数组的最后一位pop出来 和 K除10取余的结果相加，如果有进位再加1，K等于K/10取整，再记一下当前进位标记，开始下一次循环，直到 A为空 且 K为0 且 进位标记为false\r\n\r\n## 代码（JS）\r\n```javascript\r\nfunction addToArrayFormOfInteger(A, K) {\r\n  // res存结果，sum是每一位加的结果，addOneFlag是进位标记\r\n  let res = [], sum = 0, addOneFlag = false\r\n  while(A.length || K || addOneFlag) {\r\n    sum = (A.pop() || 0) + K % 10 + addOneFlag\r\n    K && (K = Math.floor(K / 10))\r\n    addOneFlag = sum >= 10\r\n    res.push(sum % 10)\r\n  }\r\n  return res.reverse()\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186092929","body":"## 思路\n遍历每一个字符，在前后同时寻找目标字符，找到了就停止，开始遍历下一个字符\n\n```javascript\nfunction shortestToChar(s, c) {\n  let res = []\n  for (let i = 0; i < s.length; i++) {\n    let count = 0\n    while (i - count >= 0 || count < s.length - i) {\n      if (s[i - count] === c || s[i + count] === c) {\n        res.push(count)\n        break\n      }\n      count ++\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n^2)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186431946","body":"## 思路\r\n数组实现，push时判断长度超出，pop时判断数组内是否还有数据\r\n\r\n## 代码\r\n```javascript\r\nclass CustomStack {\r\n  constructor(maxSize) {\r\n    this.data = []\r\n    this.maxSize = maxSize\r\n  }\r\n\r\n  push(x) {\r\n    if(this.data.length < this.maxSize) {\r\n      this.data.push(x)\r\n    }\r\n  }\r\n\r\n  pop() {\r\n    return this.data.pop() || -1\r\n  }\r\n\r\n  increment(k, val) {\r\n    for(let i = 0; i < this.data.length; i++) {\r\n      if(i >= k) break\r\n      this.data[i] += val\r\n    }\r\n  }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186825671","body":"## 思路\n1.创建两个栈，一个存数字，一个存字符\n2.遇到 '[' 时，把数字和当前的结果分别放入两个栈内\n3.遇到 ']' 时，把当前的结果 * (数字栈顶的数字）次，再加上字符栈顶的字符，视作当前的结果\n4.遇到数字时，multi值记录，可能会有几位数，所以 * 10\n5.遇到普通字符时，直接在当前结果后面加上该字符\n\n## 代码\n```javascript\nfunction decodeString (s) {\n  let multiStack = [], resStack = [], res = '', multi = 0\n  for(let str of s) {\n    if(str === '[') {\n      multiStack.push(multi)\n      resStack.push(res)\n      multi = 0\n      res = ''\n    } else if(str === ']') {\n      res = resStack.pop() + res.repeat(multiStack.pop())\n    } else if(!isNaN(str)) {\n      multi = multi*10 + parseInt(str)\n    } else {\n      res += str\n    }\n  }\n  return res\n}\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189095766","body":"## 思路\r\n\r\n创建两个栈，一个表示队列内的数据，一个作为数据转移的临时栈\r\n\r\n\r\n## 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n    this.stack1 = []\r\n    this.stack2 = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1.pop()\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    while(this.stack1.length > 1) {\r\n        this.stack2.push(this.stack1.pop())\r\n    }\r\n    let res = this.stack1[0]\r\n    while(this.stack2.length) {\r\n        this.stack1.push(this.stack2.pop())\r\n    }\r\n    return res\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190319047","body":"## 思路\r\n参考了答案，使用map计数分桶的方式实现\r\n\r\n## 代码\r\n```javascript\r\nfunction maxChunksToSorted(arr) {\r\n  let sortArr = [...arr].sort((x,y) => x-y)\r\n  let countMap = new Map();\r\n  let ans = 0\r\n  let diffNum = 0\r\n  for(let i = 0; i < arr.length; i++) {\r\n    let m = arr[i]\r\n    countMap.set(m, (countMap.get(m) || 0) + 1)\r\n    if(countMap.get(m) === 1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(m) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    let n = sortArr[i]\r\n    countMap.set(n, (countMap.get(n) || 0) - 1)\r\n    if(countMap.get(n) === -1) {\r\n      diffNum ++\r\n    }\r\n    if(countMap.get(n) === 0) {\r\n      diffNum --\r\n    }\r\n\r\n    if(diffNum === 0) ans ++\r\n  }\r\n  return ans\r\n}\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度 O(n*logn)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191177194","body":"## 思路\n1.先遍历一遍获取链表长度，k/长度取余得到需要移动的次数\n\n2.循环第一步得到的次数，每一次都把最后一个node的next指向当前的第一个node，倒数第二个node的next置为null\n\n3.需要注意链表为空和只有一个node的情况\n\n## 代码\n```javascript\nvar rotateRight = function(head, k) {\n  if(!head || !head.next) return head\n  let cur = head\n  let length = 1\n  while(cur.next) {\n    length ++\n    cur = cur.next\n  }\n  let count = k % length\n  while(count > 0) {\n    let pre = null\n    let cur = head\n    while(head.next) {\n      pre = head\n      head = head.next\n    }\n    head.next = cur\n    pre.next = null\n    count --\n  }\n  return head\n};\n```\n\n## 复杂度\n- 时间复杂度 O(n)\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fangxianshen":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100852","body":"##Go解法思路\n```\nfunc addToArrayForm(num []int,k int)(ans []int){\n\tfor i := len(num)-1;i>=0;i--{\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >=10{\n\t\t\tk ++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans,sum)\n\t}\n\tfor ; k>0;k/=10{\n\t\tans = append(ans,k%10)\n\t}\n\treverse(ans)\n\treturn\n}\n\nfunc reverse(num []int){\n\tfor i,n := 0,len(num);i<n/2;i++{\n\t\tnum[i],num[n-1-i] = num[n-1-i],num[i]\n\t}\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186893829","body":"##Go代码\r\n\r\n'''\r\npackage main\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"math\"\r\n)\r\n\r\nfunc shortestToChar(s string, c byte) []int {\r\n\tpos, answer := -len(s), make([]int, len(s))\r\n\tfor i := 0; i < len(s); i++ {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = i - pos\r\n\t}\r\n\tfor i := pos - 1; i >= 0; i-- {\r\n\t\tif s[i] == c {\r\n\t\t\tpos = i\r\n\t\t}\r\n\t\tanswer[i] = int(math.Min(float64(answer[i]), float64(pos-i)))\r\n\t}\r\n\treturn answer\r\n}\r\n\r\nfunc main() {\r\n\ts := \"loveleetcode\"\r\n\tvar str byte = 'e'\r\n\tfmt.Println(shortestToChar(s,str))\r\n}\r\n\r\n'''","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911685","body":"#Day 4  GO解法\n```\nvar i int\n\nfunc run(s string) string{\n\tres := \"\"\n\tnum := 0\n\tfor ; i<len(s);i++{\n\t\tif s[i] >= '0' && s[i] <= '9'{\n\t\t\tnum = num *10 + int(s[i]-'0')\n\t\t}else if (s[i] >= 'a'&& s[i] <= 'z'){\n\t\t\tres += string(s[i])\n\t\t}else if s[i] == '[' {\n\t\t\ti++\n\t\t\ttmp := run(s)\n\t\t\tfor j := 0;j<num;j++{\n\t\t\t\tres += tmp\n\t\t\t}\n\t\t\tnum =0\n\t\t}else{\n\t\t\tbreak\n\t\t}\n\t}\n\treturn res\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jokertzw":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185100878","body":"### 思路\nlist变为str再变为int然后求和后再转化为list\n### 代码\n```python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        sum = int(''.join(map(str, num))) + k\n        return [int(i) for i in str(sum)]\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186084611","body":"### 思路\n遍历s，如果在相应位置的字符等于c，则该位置的最短距离一定为0。如果不是c，则重新遍历s，计算离每个c的距离，从中取最小值\n### 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        res = []\n        for i in range(len(s)):\n            if s[i] == c:\n                res.append(0)\n            else:\n                res.append(min(abs(i - j) for j in range(len(s)) if s[j] == c))\n        return res\n```\n**复杂度分析**\n- 时间复杂度：O(n^2) 这里嵌套了两层for循环\n- 空间复杂度：O(n) n为res长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186393084","body":"### 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        self.n = maxSize\n        self.stack = []\n        self.inc = []\n\n\n    def push(self, x):\n        if(len(self.stack) < self.n):\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self):\n        if(len(self.stack) == 0):\n            return -1\n        else:\n            return self.stack.pop() + self.inc.pop()\n\n\n    def increment(self, k, val):\n        for i in range(min(k, len(self.inc))):\n            self.inc[i] += val\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187081216","body":"### 思路\n这里面括号都是整对出现的，是一个很经典的括号问题，可以用到栈来解决。，遇到左括号进栈，右括号出栈\n### 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        stack = [(1, [])]\n        currK = []\n        for i in range(len(s)):\n            if s[i].isdigit():\n                currK.append(s[i])\n            elif s[i] == '[':\n                k = int(\"\".join(currK))\n                stack.append((k, []))\n                currK = []\n            elif s[i] == ']':\n                k, cstr = stack.pop()\n                stack[-1][1].extend(k*cstr)\n            else:\n                stack[-1][1].append(s[i])\n\n        return \"\".join(stack[0][1])\n```\n**复杂度分析**\n- 时间复杂度：O(n),其中n为解码后的s的长度。\n- 空间复杂度：O(n),其中n为解码后的s的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188442598","body":"### 思路\n进队列和进栈操作相同，都可以用append来实现，这里设置两个栈，出队列的时候，需要先用栈一元素全部到栈二，然后栈二出栈即可得到相应元素\n### 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack.append(x)\n\n    def pop(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            while len(self.stack) > 1:\n                self.stack2.append(self.stack.pop())\n            res = self.stack.pop()\n            while len(self.stack2) > 0:\n                self.stack.append(self.stack2.pop())\n            return res\n\n    def peek(self):\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack[0]\n\n    def empty(self):\n        return len(self.stack) == 0\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189697436","body":"### 借鉴官方题解\n### 代码\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        stack = []\n        for a in arr:\n            if stack and stack[-1] > a:\n                cur = stack[-1]\n                while stack and stack[-1] > a:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(a)\n        return len(stack)\n```\n**复杂度分析**\n- 时间复杂度：O(n) \n- 空间复杂度：O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190937927","body":"### 思路\n我们可以先确定链表的长度和链表的最后一个元素，把链表变成一个环。然后找到第length-k-1的位置将幻切割即可得到最终答案\n### 代码\n```python\nclass Solution(object):\n    def rotateRight(self, head, k):\n        lastElement = head\n        length = 1\n        while ( lastElement.next ):\n            lastElement = lastElement.next\n            length += 1\n        k = k % length\n        lastElement.next = head\n        tempNode = head\n        for _ in range( length - k - 1 ):\n            tempNode = tempNode.next\n        answer = tempNode.next\n        tempNode.next = None\n        return answer\n```\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyang258":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185102829","body":"```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        int kLength = 0;\n        int kcounter = k;\n        while(kcounter > 0){\n            kcounter /= 10;\n            kLength++;\n        }\n        int numLength = num.length;\n        List<Integer> res = new ArrayList<Integer>();\n        // find num or k whichever has smallest length as counter to loop\n        int counter = kLength > numLength ? numLength : kLength;\n        int carry = 0;\n        // add digit with digit and if exceed 10 then add 1 to carry and remainder to list\n        while(counter > 0){\n            int remainder = k % 10;\n            k /= 10;           \n            int digit = (num[numLength - 1] + remainder + carry) % 10;\n            carry = (num[numLength - 1] + remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n            counter--;\n            numLength--;\n        }\n        // if k is longer digit, then we add remaining k to list\n        while(k > 0){\n            int remainder = k % 10;\n            k /= 10;\n            int digit = (remainder + carry) % 10;\n            carry = (remainder + carry) / 10;\n            // add remainder to each digit\n            res.add(0, digit);\n        }\n        // if num array is longer, then we add remaining num array to list\n        while(numLength > 0){\n            int digit = (num[numLength - 1] + carry) % 10;\n            carry = (num[numLength - 1] + carry) / 10;\n            res.add(0, digit);\n            numLength--;\n        }\n        // if we have remaining carry, we add carry to list\n        if(carry > 0){\n            res.add(0, carry);\n        }\n        return res;\n    }\n```\n\n  Time Complexity: O(max(N,M)) which N is length of num array and M is digit of k  <br/>\n  Space Complexity: O(max(N, M)) since we need to store the result and it is the longest number between length num array and digit of k <br/>\n## 思路\n#### 我需要把两个数相加，那我就只需要把每个digit的数相加然后除以10，余数就是现在的digit的数，如果超过10就加入carry 加到下一个digit 比如个位上 num array是5，k的个位是6，那最终结果的个位必然是1，我们把多出来的10加到十位数就行，具体可视化参照小学加法列式子","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186091786","body":"#### 思路\n- 先从左往右遍历整个string，遇到和c一样的字母，那它的distance就是0，往右的字母就以左边的这个字母为基准记录距离\n- 然后从右往左遍历整个string，同样道理，遇到和c一样的字母，那它的distance就是0，往左的字母就以这个字母为基准记录距离，但是需要和原本位置的array item比小，小的才是答案\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n        int prev = Integer.MIN_VALUE / 2;\n        \n        for(int i = 0; i < n; i++){\n            if(s.charAt(i) == c) \n                prev = i;\n            \n            res[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for (int i = n-1; i >= 0; --i) {\n            if (s.charAt(i) == c) \n                prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n```\nTime Complexity: O(N) -- loop through string twice, N is length of string <br/>\nSpace Complexity: O(N) -- we store the answer with an array in length N which is the length of string","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520151","body":"### 思路\r\n- 用array模拟\r\n\r\n```java\r\nclass CustomStack {\r\n    int maxSize;\r\n    int size;\r\n    int[] data;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.size = 0;\r\n        this.data = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(size < maxSize)\r\n            data[size++] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(size == 0) return -1;\r\n        return data[--size];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(k > size){\r\n            for(int i = 0; i < size; i++){\r\n                data[i] += val;\r\n            }\r\n        }else{\r\n            for(int i = 0; i < k; i++){\r\n                data[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\nTime complexity: <br/>\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(min(k, size))\r\nSpace complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187342571","body":"#### 思路 <br/>\nuse two stack\n- one hold the multiplier\n- one to hold the string characters\nwe push the string characters to charStack and we convert the multiplier to digit and store into count stack. Once we meet ']' that means we have a complete '[ ]' so we could apply the mulitplier on the top of countStack to the char pattern inside the bracket. Then we get the decoded char arrays and push it back to charStack. we continue doing this until the string input is at the end. Then we would have the result string character in stack. Then we need to use string builder to convert the char stack to string.\n\n```java\npublic String decodeString(String s) {\n        Stack<Character> charStack = new Stack<>();\n        Stack<Integer> countStack = new Stack<>();\n        for(int i = 0; i < s.length(); i++){\n            // start to pop when we find ]\n            if(s.charAt(i) == ']'){\n                List<Character> tempString = new ArrayList<Character>();\n                while(charStack.peek() != '['){\n                    tempString.add(charStack.pop());\n                }\n                // remove [\n                charStack.pop();\n                int k = 0;\n                // get the number k\n                if(!countStack.isEmpty()){\n                    k = countStack.pop();\n                }\n                // push back multiplied partial string back to stack\n                while(k > 0){\n                    for (int j = tempString.size() - 1; j >= 0; j--) {\n                        charStack.push(tempString.get(j));\n                    }\n                    k--;\n                }\n            }else if(Character.isDigit(s.charAt(i))){\n                int k = s.charAt(i) - '0';\n                while(Character.isDigit(s.charAt(i+1))){\n                    k = k*10 + (s.charAt(i+1) - '0');\n                    i++;\n                }\n                countStack.push(k);\n            }else{\n                charStack.push(s.charAt(i));\n            }\n        }\n        StringBuilder res = new StringBuilder();\n        while(!charStack.isEmpty()){\n            res.insert(0, charStack.pop());\n        }\n        return res.toString();\n    }\n```\nTime Complexity: O(N* M) we loop through all characters in string thus it will have N loops, which N is the length of string, and for each time we need to run k times in order to apply multiplier, so the worst case is Max(k), thus M, so it is N * M\n\nSpace Complexity: we use to stacks which the total length is the length of string, we also use stringBuilder to hold result, so the space is O(N), N is the length of result.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189061235","body":"##### 思路\n\n使用两个stack来模拟queue的运行模式，因为stack是FILO，所以我们要把它调个头。假设queue的顺序是FIFO，那新的element进来时我们应该把它加在屁股上，所以把所有queue的element都加入holder里面然后在把element加入进去就是加在屁股上了，然后我们再把holder的所以element都返回给queue\n\n```java\nclass MyQueue {\n    Stack<Integer> queue;\n    Stack<Integer> holder;\n    public MyQueue() {\n        queue = new Stack<>();\n        holder = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!queue.isEmpty()){\n            holder.push(queue.pop());\n        }\n        holder.push(x);\n        while(!holder.isEmpty()){\n            queue.push(holder.pop());\n        }\n    }\n    \n    public int pop() {\n        return queue.pop();\n    }\n    \n    public int peek() {\n        return queue.peek();\n    }\n    \n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n```\nTime Complexity:\n- push: O(n)\n- pop: O(1)\n- peek: O(1)\n- empty: O(1) \n\nSpace Complexity: using two stack, so it is O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189747262","body":"##### 思路\n可以观察到在sort好的array中，左边chunk的最大值一定小于等于右边chunk的最小值，所以我们只需要找到array里面每个position的右边chunk最小值(可以通过反向遍历得到)，然后我们再遍历array并记录左边的最大值，对比两个值，只要最小值大于等于最大值，那这便说明符合条件\n\n```java\npublic int maxChunksToSorted(int[] arr) {\n        // we need to find right side chunk min for each position\n        int[] rightMin = new int[arr.length + 1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length - 1; i >= 0; i--){\n            rightMin[i] = Math.min(arr[i], rightMin[i+1]);\n        }\n        int leftMax = Integer.MIN_VALUE;\n        int res = 0;\n        for(int i = 0; i < arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax <= rightMin[i+1]){\n                res++;\n            }\n        }\n        return res;\n    }\n```\nTime Complexity: O(N) which N is the length of array - 遍历两遍array\n\nSpace Complxity: O(N) which N is the length of array - 用一个array储存右边chunk最小值","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190954446","body":"##### 思路\n因为list有长度，所以移动了k次，其实是移动了k%length次。我们先算出实际移动的k，然后利用快慢双指针，让快指针先移动实际k次，然后快慢指针同时向后移动，直到快指针到达list末尾时停止。此时慢指针的下一个node就是新的头，慢指针本身是新的尾巴，所以我们就把新的头拿出来，然后把慢指针的next设置为null，最后把快指针的next设置成老的head，然后return新的头就得到正确答案\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        // find the length of list\n        ListNode count = head;\n        int counter = 0;\n        while(count != null){\n            count = count.next;\n            ++counter;\n        }\n        ListNode fast = head;\n        ListNode slow = head;\n        k = k % counter;\n        if(k == 0) return head;\n        while(k > 0){\n            fast = fast.next;\n            --k;\n        }\n        while(fast.next != null){\n            fast = fast.next;\n            slow = slow.next;\n        }\n        ListNode newHead = slow.next;\n        slow.next = null;\n        fast.next = head;\n        return newHead;\n    }\n```\nTime Complexity: O(N) which N is length of list\n\nSpace Complextiy: O(1), we did not use additional data structure ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kernelsue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185108946","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\t\tLinkedList<Integer> list = new LinkedList<Integer>();\r\n    \t        int carry = 0;\r\n\t\tint i = num.length-1;\r\n    \twhile(i >= 0||k != 0){\r\n    \t\tif(k == 0 && carry == 0){\r\n    \t\t\tlist.push(num[i]);\r\n    \t\t\ti--;\r\n    \t\t\tcontinue;\r\n\t\t     }\r\n    \t\tint cur = carry + k%10;\r\n\t\tif(i >= 0)  cur += num[i];\r\n\t\tlist.push(cur%10);\r\n\t\tcarry = cur/10;\r\n\t\tk /= 10;\r\n\t\ti--;\r\n\t}\r\n    \tif(carry != 0){\r\n    \t\tlist.push(1);\r\n\t}\r\n    \treturn list;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186383932","body":"```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n    \tif(s.length() == 1)  return new int[]{0};\r\n    \tint left = 0;\r\n    \tint right = 0;\r\n    \tint temp = Integer.MAX_VALUE;\r\n    \tint[] dist = new int[s.length()];\r\n    \twhile(right < s.length()){\r\n    \t\twhile(right != s.length() && s.charAt(right) != c)  right++;\r\n    \t\twhile(left < right){\r\n    \t\t\tif(right != s.length())  dist[left] = Math.min(Math.abs(left-temp), right-left);\r\n    \t\t\telse  dist[left] = left-temp;\r\n\t\t\tleft++;\r\n\t\t}\r\n    \t\tif(right != s.length()){\r\n\t\t\tdist[left] = 0;\r\n\t\t\ttemp = left;\r\n\t\t\tright++;\r\n\t\t}\r\n\t}\r\n    \treturn dist;\r\n    }\r\n}\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186394234","body":"```java\r\nclass CustomStack {\r\n\t     private int[] arr;\r\n\t     private int top;\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != arr.length-1)\r\n            arr[++top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top != -1){\r\n            top--;\r\n            return arr[top+1];\r\n        }else  return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int i = 0;\r\n        while(k != 0 && i <= top){\r\n            arr[i++] += val;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186949660","body":"```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n\t\tLinkedList<Character> stack = new LinkedList<Character>();\r\n\t\tLinkedList<Character> temp = new LinkedList<Character>();\r\n\t\tStringBuilder str = new StringBuilder();\r\n\t\t//暴力栈\r\n\t\tfor(int i = 0; i < s.length(); i++){\r\n\t\t\tchar c = s.charAt(i);\r\n\t\t\tif(c >= 'a' && c <= 'z' && stack.isEmpty())  str.append(c);\r\n\t\t\telse if(c != ']')  stack.push(c);\r\n\t\t\telse{\r\n\t\t\t\twhile(stack.peek() != '[')\r\n\t\t\t\t\ttemp.push(stack.pop());\r\n\t\t\t\tstack.pop();\r\n\t\t\t\tString times = \"\";\r\n\t\t\t\twhile(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9')\r\n\t\t\t\t\ttimes = stack.pop() + times;\r\n\t\t\t\tif(stack.isEmpty()){\r\n\t\t\t\t\tString t = \"\";\r\n\t\t\t\t\tfor(char ch : temp)\r\n\t\t\t\t\t\tt += ch;\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstr.append(t);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tCollections.reverse(temp);\r\n\t\t\t\t\tfor(int j = 0; j < Integer.valueOf(times); j++)\r\n\t\t\t\t\t\tstack.addAll(0, temp);\r\n\t\t\t\t}\r\n\t\t\t\ttemp.clear();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\t\treturn str.toString();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erikahuang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185110660","body":"```\r\nclass Solution:\r\n    def listsum1(self, a: list[int], k: int) -> list[int]:\r\n        # 时间和空间复杂度都为O(n)\r\n        carry = 0\r\n        n = max(len(a), len(str(k))+1\r\n        res = [0] * n\r\n        a = [0] * (n-len(a)) + a\r\n\r\n        for i in range(n-1, -1, -1):\r\n            res[i] = a[i] + k % 10 + carry\r\n            carry = res[i] // 10\r\n            res[i] = res[i] % 10\r\n            k = k // 10\r\n\r\n        return res[1:] if res[0] == 0 else res\r\n\r\n    def listsum2(self, a: list[int], k: int) -> list[int]:\r\n        a = \"\".join(map(str,a))\r\n        res = int(a) + k\r\n        return list(map(int, str(res)))\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078578","body":"## 思路\r\n\r\n> 三指针：slow指针指向目前的字符位置，fast1和fast2指向离s[solw]最近的两个'e'的位置。\r\n\r\n##代码\r\n\r\n```python\r\n#代码\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        from collections import defaultdict\r\n        s = list(s)\r\n        distance = [0]*len(s)\r\n        slow = fast1 = 0\r\n        fast2 = float(\"inf\")\r\n        while slow < len(s):\r\n            while fast1 < len(s) and s[fast1] != c:\r\n                fast1 +=1\r\n            while slow < len(s) and slow <= fast1:\r\n                if fast1 < len(s):\r\n                    distance[slow] = min(abs(fast1-slow), abs(fast2-slow))\r\n                    slow +=1\r\n                else:\r\n                    distance[slow] = abs(fast2-slow)\r\n                    slow +=1\r\n            fast2 = fast1\r\n            fast1 +=1\r\n        return distance\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186370986","body":"## 思路\r\n\r\n> 用list实现栈\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop() if self.stack else -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.stack))):\r\n            self.stack[i] +=val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: push-O(1);pop-O(1);inc-O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186688323","body":"## 思路\r\n\r\n> \"在栈里面每次存储两部分信息：左括号前的字符串, 左括号前的数字, 比如abc3[def], 当遇到第一个左括号的时候，压入栈中的是(\"abc\", 3), 然后遍历括号里面的字符串def, 当遇到右括号的时候, 从栈里面弹出一个元素(s1, n1), 得到新的字符串为s1+n1*\"def\", 也就是abcdefdefdef。对于括号里面嵌套的情况也是同样处理方式。\"\r\n>左括号触发压栈，右括号触发弹出。\r\n\r\n##代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = deque()\r\n        cnt = 0\r\n        string = ''\r\n\r\n        for char in s:\r\n            if char.isdigit():\r\n                cnt = int(char) + cnt*10\r\n                continue\r\n            elif char == '[':\r\n                stack.append((string, cnt))\r\n                string = ''\r\n                cnt = 0\r\n            elif char == ']':\r\n                tmp = stack.pop()\r\n                string = tmp[0] + tmp[1]*string\r\n            else:\r\n                string +=char\r\n\r\n        return string\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188677459","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n##代码\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in = []\r\n        self.stack_out = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.empty():\r\n            return None\r\n\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        else:\r\n            for i in range(len(self.stack_in)):\r\n                self.stack_out.append(self.stack_in.pop())\r\n            return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.stack_out.append(ans) # pop完需要补回去才能保持栈内元素不变\r\n        return ans\r\n\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (self.stack_in or self.stack_out)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189785879","body":"### [思路]\r\n>+ 单调栈\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n\r\n        for i in range(len(arr)):\r\n    \r\n            if stack and stack[-1] > arr[i]: # arr[i] 小于栈顶元素说明会改变前面的数组排序\r\n                head = stack.pop() \r\n                #储存当前的栈顶，以方便后续压栈，因为该栈顶仍是目前排序块的最大值\r\n                while stack and stack[-1] > arr[i]:\r\n                    stack.pop() # 去掉不能成为排序块最大值的元素\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])\r\n        \r\n        return len(stack)\r\n```\r\n\r\n### 复杂度\r\n>+时间复杂度：O(n)\r\n>+空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191019155","body":"## 思路\r\n\r\n> + 找到链表尾巴和链表长度，形成环链条，再找到新链表头，断开链表。\r\n\r\n##代码\r\n\r\n```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        \r\n        start = head\r\n        end = head\r\n        cnt = 1 # 计算链表长度\r\n\r\n        while end.next:\r\n            end = end.next\r\n            cnt += 1\r\n        \r\n        end.next = head\r\n\r\n        pos = cnt - k%cnt # 从链表头向后移动的步数，到达新链表头\r\n\r\n        while pos > 1:\r\n            start = start.next\r\n            pos -= 1\r\n\r\n        head = start.next\r\n        start.next = None\r\n\r\n        return head\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuang-mou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185111126","body":"### 思路\r\n由于k的位数是小于等于A数组位数的，直接利用python转化为字符进行相加\r\n### 代码\r\n```class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        s =  int(''.join(map(str,num))) + k\r\n        return [int(i) for i in str(s)]","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186196104","body":"```\nclass Solution:\n    def shortestToChar(self, S: str, C: str) -> List[int]:\n        \n        return [min(abs(i- j)  for j in [i for i in range(len(S)) if S[i] == C]) for i in range(len(S))]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545431","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.length = 0\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if self.length < self.maxSize:\n            self.length += 1\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.length is 0:\n            return -1\n        else:\n            self.length -= 1\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,self.length)):\n            self.stack[i] += val\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iloveqier":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112285","body":"```\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n    let narr = []\r\n    // k作为每一项都加的东西，余数是要存下的值，除数是下一次要加的东西\r\n    for (let i = num.length - 1; i > -1 || k > 0; i--, k = Math.floor(k / 10)) {\r\n        // 防止num遍历到最头部的时候，k依然有值,需要继续使用\r\n        if (i > -1) {\r\n            k = k + num[i]\r\n        }\r\n        narr.unshift(k % 10)\r\n    }\r\n    return narr\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186096624","body":"```js\nvar shortestToChar = function (s, c) {\n    let res = Array(s.length).fill(Infinity);\n    let cindexs = []\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           cindexs.push(i)\n           \n       }\n   }\n   for(let i=0;i<s.length;i++){\n       if(s[i]===c) {\n           res.push(0)\n           continue\n       }\n       for(let ci of cindexs) {\n           let distance = Math.abs(ci-i)\n           //当发现distance开始大于当前res[i]了，说明res[i]已经是最小距离了，后边只会越来越大\n           if(distance>res[i]) break\n           res[i] = distance\n       }\n\n   }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360684","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n    this.maxSize = maxSize\n    this.curSize = 0\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n    if (this.curSize < this.maxSize) {\n        this.stack.push(x)\n        this.curSize++\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n    if (this.curSize === 0) {\n        return -1\n    }\n    this.curSize--\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n    this.stack.map((item,i)=>{\n        if(i<k){\n            this.stack[i] += val\n        }\n    })\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186911027","body":"```js\nvar decodeString = function (s) {\n    let stack = []\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] == ']') {\n            let repeatStr = ''\n            let repeatCount = ''\n            while (stack && stack[stack.length - 1] != '[') {\n                repeatStr = stack.pop() +repeatStr\n            }\n            stack.pop()\n            while (stack && /\\d/.test(stack[stack.length - 1])) {\n                repeatCount = stack.pop() + repeatCount\n            }\n            repeatStr = repeatStr.repeat(repeatCount * 1);\n            stack.push(repeatStr)\n        } else {\n            stack.push(s[i])\n        }\n    }\n    return stack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188822222","body":"```js\n\nvar MyQueue = function () {\n    this.inStack = []\n    this.outStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    this.inStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    if (!this.outStack.length) {\n        this.in2out()\n    }\n    return this.outStack[this.outStack.length-1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    return !this.inStack.length && !this.outStack.length\n};\n\nMyQueue.prototype.in2out = function () {\n    while (this.inStack.length) {\n        this.outStack.push(this.inStack.pop())\n    }\n};\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189717710","body":"```js\nvar maxChunksToSorted = function (arr) {\n    let stack = []\n    for (let i = 0; i < arr.length; i++) {\n        let ac = arr[i]\n        let stc = stack[stack.length - 1]\n        if (stack.length && stc > ac) {\n            while (stack.length && stack[stack.length-1] > ac) stack.pop()\n            stack.push(stc)\n        } else {\n            stack.push(ac)\n        }\n    }\n    return stack.length\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190973981","body":"```js\nvar rotateRight = function (head, k) {\n    if(!head || !head.next) return head\n    let count = 0,now = head\n    while (now) {\n        now = now.next\n        count++\n    }\n    k = k % count\n    let slow = (fast = head)\n    while (fast.next) {\n        if (k-- <= 0) {\n            slow = slow.next\n        }\n        fast = fast.next\n    }\n    fast.next = head\n    let res = slow.next\n    slow.next = null\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duke-github":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185112936","body":"## 思路\n    将数组从后往前加给k k每次取余作为结果 /10参与下一次运算\n## 复杂度\n    时间复杂度 O(max(n,m)) m n 为数组的长度 和k的长度 空间复杂度 O(n)\n## 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> result = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; i--) {\n            k += num[i];\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        while (k > 0) {\n            result.addFirst(k % 10);\n            k /= 10;\n        }\n        return result;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186101492","body":"## 思路 \n     从前到后一次判断c和当前位置的距离 再从后往前判断c和当前位置的距离 取较小的值作为结果\n## 复杂度\n    时间复杂度O(n) 空间复杂度O(n)\n## 代码\n```java\n  public int[] shortestToChar(String s, char c) {\n        char[] ss= s.toCharArray();\n        int[] result = new int[ss.length];\n        int temp = 1-s.length();\n        for(int i=0;i<ss.length;i++){\n            if(c!=ss[i]){\n                result[i] = i-temp;\n            }else{\n                temp = i;\n            }\n        }\n        temp= 0;\n        for(int i=result.length-1;i>=0;i--){\n            if(c!=ss[i]){\n                result[i] = Math.min(Math.abs(temp-i),result[i]);\n            }else{\n                temp = i;\n            }\n        }\n        return result;\n    }\n  ```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186520696","body":"## 思路\n\n    使用数组记录栈的数据 使用一个下标记录栈指针当前所在的位置 出入栈的时候处理这个栈指针\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n    class CustomStack {\n    int[] stack;\n    int len;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        len=-1;\n    }\n\n    public void push(int x) {\n        if(len+1<stack.length){\n            len++;\n            stack[len] =x;\n\n        }\n    }\n\n    public int pop() {\n        if(len<0){\n            return -1;\n        }\n        len--;\n        return stack[len+1];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, len + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187600669","body":"## 思路\n\n    使用栈记录数据 左括号入栈 有括号出栈 数字则加倍\n\n## 复杂度\n\n    时间复杂度O(n) 空间复杂度O(n)\n\n## 代码\n\n```java\n class Solution {\n    public String decodeString(String s) {\n        Deque<Integer> stackNumber = new LinkedList<>();\n        Deque<String> stackString = new LinkedList<>();\n        StringBuilder stringBuilder = new StringBuilder();\n        int number = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '[') {\n                stackNumber.push(number);\n                number = 0;\n                stackString.push(stringBuilder.toString());\n                stringBuilder = new StringBuilder();\n            } else if (s.charAt(i) == ']') {\n                StringBuilder temp = new StringBuilder();\n                int curr_number = stackNumber.pop();\n                for (int j = 0; j < curr_number; j++) {\n                    temp.append(stringBuilder);\n                }\n                stringBuilder = temp.insert(0, stackString.pop());\n            } else if (s.charAt(i) > 47 && s.charAt(i) < 58) {\n                number = 10 * number + (s.charAt(i) - '0');\n            } else {\n                stringBuilder.append(s.charAt(i));\n            }\n        }\n        return stringBuilder.toString();\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189219881","body":"## 思路\n\n    使用双栈记录数据  压栈存数 翻转栈取数\n\n## 复杂度\n\n    时间复杂度O(1) 空间复杂度O(n)\n\n## 代码\n\n```java\nclass MyQueue {\n        //头栈\n        private Stack<Integer> headStack = new Stack<>();\n        //尾栈\n        private Stack<Integer> tailStack = new Stack<>();\n\n        public MyQueue() {\n        }\n\n        public void push(int x) {\n\n            headStack.push(x);\n        }\n\n        public int pop() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.pop();\n        }\n\n        public int peek() {\n            if (tailStack.empty()) {\n                while (!headStack.empty()) {\n                    tailStack.push(headStack.pop());\n                }\n            }\n            return tailStack.peek();\n        }\n\n        public boolean empty() {\n            return headStack.empty() && tailStack.empty();\n        }\n    }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189967735","body":"## 思路\n\t单调栈 将数组首个入栈 对其后的数据 大于等于当前栈顶则入栈 小于则出栈一个并比较下一个栈顶 直到大于等于栈顶或者栈空再入栈\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(n)\n## 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Deque<Integer> stack = new LinkedList<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()) {\n                stack.push(arr[i]);\n            } else {\n                Integer head = stack.pop();\n                while (stack.size() > 0 && arr[i] < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            }\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191205570","body":"## 思路\n\t成环再移位\n## 复杂度\n\t时间复杂度 O(n) 空间复杂度O(1)\n## 代码\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head==null){\n            return head;\n        }\n        ListNode temp = new ListNode(0, head);\n        //链表长度\n        int len = 1;\n        //成环\n        while (head.next != null) {\n            head = head.next;\n            len++;\n        }\n        head.next = temp.next;\n        head = head.next;\n        //后移等于长度- 前移位和长度的余数\n        int number = len - k % len;\n        //移位\n        while (number > 0) {\n            number--;\n            temp = head;\n            head = head.next;\n        }\n        temp.next = null;\n        return head;\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caterpillar-0":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118358","body":"### 思路\r\n按位依次相加\r\n### 代码\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int>res;\r\n        for(int i=num.size()-1;i>=0 || k>0;i--,k/=10){\r\n            if(i>=0){\r\n                k+=num[i];\r\n            }\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(),res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度：o(n)\r\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186071498","body":"### 思路\n两次遍历，找到离得最近的C的距离\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int>res;\n        //从前遍历\n        int index=INT_MAX;\n        for(int i=0;i<s.size();i++){\n            if(s[i]==c){\n                index=i;\n            }\n            res.push_back(abs(i-index));\n        }\n        //从后遍历\n        index=INT_MAX;\n        for(int i=s.size()-1;i>=0;i--){\n            if(s[i]==c){\n                index=i;\n            }\n            res[i]=min(res[i],abs(index-i));\n        }\n        return res;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度:o(n)\n* 空间复杂度:o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186377067","body":"### 代码\n```C++\nclass CustomStack {\nprivate:\n    int cap;//最大容量\n    int top;//目前元素栈顶\n    int* arr;//数组指针\npublic:\n    CustomStack(int maxSize) {\n        cap=maxSize;\n        top=-1;\n        arr=new int[cap];\n    }\n    ~CustomStack() {\n        delete [] arr;\n    }\n    \n    void push(int x) {\n        if(top<cap-1){\n            arr[++top]=x;\n        }\n    }\n    \n    int pop() {\n        if(top==-1)return -1;\n        return arr[top--];\n    }\n    \n    void increment(int k, int val) {\n        int board=min(k,top+1);\n        for(int i=0;i<board;i++){\n            arr[i]+=val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186710233","body":"### 思路\n用栈匹配括号，分别处理数字，字母和括号\n### 代码\n```C++\nclass Solution {\npublic:\n    string GetDigit(const string& s,size_t& ptr){\n        string ret=\"\";\n        //因为数字不止一位\n        while(isdigit(s[ptr])){\n            ret.push_back(s[ptr++]);//对ptr有改动，因此需要&\n        }\n        return ret;\n    }\n    string GetString(vector<string>& sub){\n        string temp=\"\";\n        for(string& s:sub){\n            temp+=s;\n        }\n        return temp;\n    }\n    string decodeString(string s) {\n        vector<string>myvec;\n        size_t ptr=0;\n        while(ptr<s.size()){\n            char ch=s[ptr];\n            //1、处理数字\n            if(isdigit(ch))myvec.push_back(GetDigit(s,ptr));\n            //2、处理字母\n            else if(isalpha(ch) || ch=='[')myvec.push_back(string(1,s[ptr++]));\n            //3、处理']'\n            else{\n                ++ptr;\n                vector<string>sub;\n                while(myvec.back()!=\"[\"){\n                    sub.push_back(myvec.back());\n                    myvec.pop_back();\n                }\n                myvec.pop_back();\n                reverse(sub.begin(),sub.end());\n                string temp=GetString(sub);\n                int times=stoi(myvec.back());\n                myvec.pop_back();\n                string temp_1;\n                while(times--){\n                    temp_1+=temp;\n                }\n                myvec.push_back(temp_1);\n            }\n        }\n        return GetString(myvec);\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188847635","body":"### 思路\n使用两个栈，来实现队列先进先出\n### 代码\n```C++\nclass MyQueue {\n    //优化，存在重复代码\nprivate:\n    stack<int>instack;\n    stack<int>outstack;\n    void in_out(){\n        if(outstack.empty()){\n            while(!instack.empty()){\n                outstack.push(instack.top());\n                instack.pop();\n            }\n        }\n    }\npublic:\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        instack.push(x);\n    }\n    \n    int pop() {\n        in_out();\n        int temp=outstack.top();\n        outstack.pop();\n        return temp;\n    }\n    \n    int peek() {\n        in_out();\n        return outstack.top();\n    }\n    \n    bool empty() {\n        return instack.empty() && outstack.empty();\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189989210","body":"### 思路\n单调栈，从栈底到栈头从小到大，注意留下的是每个区间的大值\n### 代码\n```C++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>mystack;\n        //单调栈,栈底到栈头从小到大\n        for(int i=0;i<arr.size();i++){\n            if(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                int temp=mystack.top();\n                while(!mystack.empty() && arr[i]<arr[mystack.top()]){\n                    mystack.pop();\n                }\n                mystack.push(temp);\n            }\n            else{\n                mystack.push(i);\n            }\n        }\n        return mystack.size();\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190975716","body":"### 思路\n将链表相接成环，判断头结点的位置\n### 代码\n```C++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if(head==nullptr)return nullptr;\n        //相接成环\n        ListNode* temp=head;\n        int size=1;\n        while(temp->next!=nullptr){\n            temp=temp->next;\n            size++;\n        }\n        //temp是原来的尾结点\n        temp->next=head;\n        int num=abs(size-k%size);\n        while(num--){\n            head=head->next;\n            temp=temp->next;\n        }\n        temp->next=nullptr;\n        return head;\n    }\n};\n```\n### 复杂度分析\n* 时间复杂度：o(n)\n* 空间复杂度：o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ashleyyma6":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185118412","body":"### Idea\n\nInput: an int in array form **num**, an int **k** to add\nOutput: result in array form\n\n1. array to int, add k, int to array\n   ~~2. int k to array, add array~~\n\n### Code\n\n```python\n    def addToArrayForm(self, num, k):\n        # array to int\n        int_res = int(''.join(str(n) for n in num))\n        int_res+=k\n        # int to array\n        res = [int(n) for n in str(int_res)]\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n) = O(n)\n- Space Complexity: O(1)+O(n) = O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139244","body":"### Idea\n- 1st loop: find all indices of *c*\n- 2nd loop: get abs min for all elements in *s*\n### Code\n```python\ndef shortestToChar(self, s, c):\n        index = []\n        res = [0]*len(s)\n        for i in range(len(s)):\n            if s[i] == c:\n                index.append(i)\n        for i in range(len(s)):\n            if i in index:\n                res[i]=0\n            else:\n                res[i] = min([abs(i-x) for x in index])\n        return res\n```\n\n**Complexity Analysis**\n- Time Complexity: O(n^2)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186342266","body":"### Idea\n- array with 2 pointers\n- 1 pointer for stack top, help to judge if exceed max size\n- 1 pointer for stack base & increment function, help to judge if empty\n- check max & update base when push/pop\n- increment: compare k with current top index -> decide the number of element to update\n\n### Code\n\n```python\ndef __init__(self, maxSize):\n        self.stack = [0]*maxSize\n        self.max = maxSize-1 # max index\n        self.base = -1\n        self.top = -1\n\n    def push(self, x):\n        if self.top<self.max:\n            if(self.top<0):\n                self.base+=1\n            self.top+=1\n            self.stack[self.top]=x\n        \n    def pop(self):\n        if self.top>=0 :\n            res = self.stack[self.top]\n            self.stack[self.top] = 0\n            self.top-=1\n            if(self.top<0):\n                self.base-=1\n            return res\n        else:\n            return -1\n        \n    def increment(self, k, val):\n        if(self.base>=0):\n            if (self.top+1)>=k:\n                for i in range(k):\n                    self.stack[i]+=val\n            else:\n                for e in range(self.top+1):\n                    self.stack[e]+=val\n\n```\n\n**Complexity Analysis**\n- Time Complexity: \n  - push: O(1)\n  - pop:O(1)\n  - increment: O(n)\n- Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186642403","body":"### Idea\n1. Traverse *s*\n   1. push number to stack *num*\n   2. push [ & characters to stack *char*, until meet ]\n   3. when meet ], pop stack *char* & add characters together until meet [\n   4. pop the stack *num*,  decode characters, push result back to stack *char*\n2. return stack *char* content\n### Code\n\n```python\ndef decodeString(self, s):\n        num = []\n        char = []\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                n = \"\"\n                while(s[i].isdigit()):\n                    n+=s[i]\n                    i+=1\n                num.append(int(n))\n            elif s[i] == ']':\n                tmp = \"\"\n                while char[-1]!='[':\n                    tmp = char.pop()+tmp\n                char.pop()\n                tmp = tmp*num.pop()\n                char.append(tmp)\n                i+=1\n            else:\n                char.append(s[i])\n                i+=1\n        res = \"\"\n        while len(char)>0:\n            res = char.pop()+res\n        return res\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188466203","body":"### Idea\n\n- push: push to stack1\n- pop: pop from stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- peek: return the first element of stack2\n  - if stack2 is empty, move stack1 content to stack2 first\n- empty: return if stack1 and stack2 all empty\n- check empty before pop, peek\n\n### Code\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2.pop()\n        else: return None\n\n    def peek(self):\n        if not self.empty():\n            if len(self.stack2)==0:\n                while len(self.stack1)>0:\n                    self.stack2.append(self.stack1[-1])\n                    self.stack1.pop(-1)\n            return self.stack2[-1]\n        else: return None\n\n    def empty(self):\n        return len(self.stack1)+len(self.stack2) == 0\n```\n\n**Complexity Analysis**\n\n- Time Complexity:\n  - push: O(1)\n  - pop: O(n)\n  - peek: O(n)\n  - empty: O(1)\n- Space Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189956971","body":"### Idea\n1. check if the left subarray is smaller than the right subarray, if smaller, get a new chunck\n2. Traversal, get the max of left subarray and the min of right subarray, compare\n\n### Code\n\n```python\ndef maxChunksToSorted(self, arr):\n\n    length = len(arr)\n    left = [0]*length\n    right = [0]*length\n    \n    for i in range(len(arr)):\n        if i == 0:\n            left[i]=arr[i]\n        else:\n            left[i]=max(left[i-1],arr[i])\n    \n    for i in reversed(range(len(arr))):\n        if i == length-1:\n            right[i]=arr[i]\n        else:\n            right[i]=min(right[i+1],arr[i])\n    res = 0\n    for i in range(len(arr)-1):\n        if left[i]<=right[i+1]:\n            res+=1\n    return res+1\n```\n\n**Complexity Analysis**\n\n- Time Complexity:O(n)+O(n)+O(n)=O(n)\n- Space Complexity:O(n)+O(n)=O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190940014","body":"### Idea\n- find the length of list, k%length to find the rotation needed\n- need to switch two sublists, list splits at length-k\n- one pointer for the end of right sublist\n- one pointer for the end of left sublist\n\n### Code\n\n```python\ndef rotateRight(self, head, k):\n    if k==0:\n        return head\n    if head==None or head.next==None:\n        return head\n    \n    length = 0\n    p1 = head\n    while p1 != None:\n        length+=1\n        p1 = p1.next\n        \n    rotate = k%length\n    \n    p1 = head\n    while rotate>0:\n        p1 = p1.next\n        rotate-=1\n    p2 = head\n    while p1.next!=None:\n        p1=p1.next\n        p2=p2.next\n    p1.next = head\n    head = p2.next\n    p2.next = None\n    return head\n\n```\n\n**Complexity Analysis**\n\n- Time Complexity: O(n)+O(n)=O(n)\n- Space Complexity: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuki-yzy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185123309","body":"# 思路\n\n将num与k末位相加，加到k上，k中自动进位，只需将k取余放入数组中即可\n\n# 代码\n\n\n```js\nvar addToArrayForm = function(num, k) {\n    let res = []\n    let len = num.length - 1\n    while(len >= 0 || k > 0) {\n        if(len >= 0) {\n            k += num[len]\n            len--\n        }\n        res.push(k % 10)\n        k = parseInt(k / 10)\n    }\n    return res.reverse()\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075915","body":"# 思路\n\n从S[i]位置开始，分别向左和向右进行搜索，取最小距离存到数组中\n\n# 代码\n\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    let l = i,r = i,min = Infinity;\n    while (l >= 0) {\n      if (S[l] === C) {\n        min = Math.min(min, i - l);\n        break;\n      }\n      l--;\n    }\n    while (r < S.length) {\n      if (S[r] === C) {\n        min = Math.min(min, r - i);\n        break;\n      }\n      r++;\n    }\n    res[i] = min;\n  }\n  return res;\n};\n```\n\n# 复杂度\n\n时间：O(n)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186353755","body":"# 思路\n\n设置最大容量，维护一个stack\n\n# 代码\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack =[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return\n    }\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k,this.stack.length)\n    for(let i = 0;i < len;i++) {\n        this.stack[i] += val\n    }\n};\n```\n\n# 复杂度\n\n时间:O(n)\n\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187084895","body":"# 思路\n\n遇到 [ 数字字母分别入栈，遇到 ] 栈顶元素出栈\n\n# 代码\n\n```js\nconst decodeString = (s) => {\n    let numStack = [];        \n    let strStack = [];       \n    let num = 0;              \n    let result = '';          \n    for (const char of s) {   \n        if (!isNaN(char)) {  \n            num = num * 10 + Number(char); \n        } else if (char == '[') {  \n            strStack.push(result); \n            result = '';           \n            numStack.push(num);   \n            num = 0;              \n        } else if (char == ']') {  \n            let repeatTimes = numStack.pop(); \n            result = strStack.pop() + result.repeat(repeatTimes); \n        } else {                   \n            result += char;       \n        }\n    }\n    return result;\n};\n\n```\n\n# 复杂度\n\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188499267","body":"# 思路\n\n双栈模拟\n\n# 代码\n\n```js\nvar MyQueue = function() {\n    this.stackIn = []\n    this.stackOut = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackIn.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    const size = this.stackOut.length\n    if(size) {\n        return this.stackOut.pop()\n    }\n    while(this.stackIn.length) {\n        this.stackOut.push(this.stackIn.pop())\n    }\n    return this.stackOut.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const x = this.pop();\n    this.stackOut.push(x);\n    return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n     return !this.stackIn.length && !this.stackOut.length\n};\n```\n\n# 复杂度\n\n时间：O(1)\n\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189726069","body":"# 思路\n\n使用滑动窗口，因为原数组与分块后块的位置相同，可以通过加法求和进行分块\n\n# 代码\n\n```js\nvar maxChunksToSorted = function(arr) {\n    const sortArr = [...arr];\n    sortArr.sort((a, b) => a - b);\n    let count = 0,sum1 = 0,sum2 = 0;\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sortArr[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n}\n```\n\n# 复杂度\n\n时间复杂度:O(nlogn)\n\n空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zpc7":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185132808","body":"### 思路\n一开始没考虑到大数的运算会丢失精度, 还说题目简单;\n参考的题解用了通用的方法\n### 代码 TS\n```ts\n// 一开始没有考虑到大数计算的进度丢失情况, 使用了下面的写法\n// function addToArrayForm(num: number[], k: number): number[] {\n//     const sum: number = Number(num.join('')) + k;\n\n//     return (sum + '').split('').map(item => Number(item));\n// };\n\nvar addToArrayForm = function (num: number[], k: number): number[] {\n    const res = [];\n    const n = num.length;\n\n    // 从低位加到高位, 所以采用从大到小的顺序循环\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n\n        // 需要进位的情况, 将进位加在K上, 便于下一次循环\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    // 考虑nums比较小, K比较大的情况, 循环结束后, K还有值, 例如:111+88888, 需要将他补充回数组\n    while (k > 0) {\n        res.push(k % 10);\n        k = Math.floor(k / 10)\n    }\n    // 不采用反转的话, 每次都需要在数组最前面插值(shift), 时间复杂度高\n    return res.reverse();\n};\n```\n### 复杂度\n时间 O(n)\n空间 O(1) ? 不太确定, 没太搞懂空间复杂度的分析, 求大佬解答","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186154745","body":"## 思路\n先存下所有的c在原数组中的位置; 然后遍历的时候, 对比距离取得最小值\n## 代码 TS\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n    // 存储匹配字符'c'在原数组中的索引\n    const indexArr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i);\n        }\n    }\n\n    const res = [];\n\n    // 计算s的每一项索引, 与indexArr绝对值, 然后取最小的\n    for (let index = 0; index < s.length; index++) {\n        if (s[index] === c) {\n            res[index] = 0;\n        } else {\n            const indexDistanceArr: number[] = indexArr.map(item => Math.abs(item - index));\n            res[index] = Math.min(...indexDistanceArr);\n        }\n    }\n\n    return res\n};\n```\n## 复杂度\n时间: O(n2)\n空间: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186467029","body":"## 思路\n利用数组实现, 难度简单\n## 代码 TS\n```ts\nclass CustomStack {\n    maxSize: number;\n    stack: number[];\n\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n        this.stack = [];\n    }\n\n    push(x: number): void {\n        const length = this.stack.length;\n        if (length < this.maxSize) {\n            this.stack.push(x);\n        }\n    }\n\n    pop(): number {\n        const length = this.stack.length;\n        if (length === 0) return -1;\n        return this.stack.pop()\n    }\n\n    increment(k: number, val: number): void {\n        const length = this.stack.length;\n        for (let i = 0; i < Math.min(length, k); i++) {\n            this.stack[i] += val\n        }\n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度\n时间: O(n)(确切地说: Math.min(N, K)) 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186563811","body":"## 思路\n\n实在没做出来, 思路太混乱了, 参考大佬的[题解](https://leetcode.cn/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/), 翻译了一个 `TS` 的版本\n\n## 代码 TS\n```ts\nfunction decodeString(s: string): string {\n    let stack = [], str = '', multi = 0;\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === '[') {\n            stack.push([multi, str]);\n            str = '';\n            multi = 0;\n        } else if (s[i] === ']') {\n            let [currentMulti, lastStr] = stack.pop();\n            str = lastStr + str.repeat(currentMulti);\n        } else if ('0' <= s[i] && s[i] <= '9') {\n            multi = multi * 10 + Number(s[i]);\n        } else {\n            str += s[i]\n        }\n    }\n    return str;\n};\n```\n## 复杂度\n时间:O(n) 空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188630937","body":"## 思路\n这个题目简单, 但是需要注意只能使用指定类型的API\n## 代码 TS\n```ts\nclass MyQueue {\n    stack: number[] = [];\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack.push(x)\n    }\n\n    pop(): number {\n        let tempArray = [];\n        const removedItem = this.stack[0];\n        for (let i = 1; i < this.stack.length; i++) {\n            tempArray.push(this.stack[i])\n        }\n        this.stack = tempArray\n        return removedItem\n    }\n\n    peek(): number {\n        return this.stack[0];\n    }\n\n    empty(): boolean {\n        return !this.stack.length;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## 复杂度\n时间: O(n) 空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190446229","body":"## 思路\n没做出来, 参考了题解\n##  代码 PY3\n```python\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count = collections.defaultdict(int)\n        ans = nonzero = 0\n\n        for x, y in zip(arr, sorted(arr))\n            count[x] += 1\n            if count[x] == 0: nonzero -= 1\n            if count[x] == 1: nonzero += 1\n\n            count[y] -= 1\n            if count[y] == -1: nonzero += 1\n            if count[y] == 0: nonzero -= 1\n\n            if nonzero == 0: ans += 1\n\n        return ans\n\n```\n## 复杂度\n时间: O(NlogN)\n空间: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yujian920":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185136875","body":"### 思路\r\n\r\n暴力解法：字符串转换，然后用 BigInt 转换保证大数精度不丢失\r\n### 代码\r\n\r\n\r\n```typescript（此处换成你的语言，比如js，py 等）\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(item => Number(item))\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，类型转换部分时间复杂度不会算，余下部分应该是 O(2*n)也就是 O(n)\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188549571","body":"### 思路\nJS 实现栈没什么好说的，这里用两个栈的方式实现队列，像是两杯水倒来倒去\n### 代码\n\n```typescript\nclass MyQueue {\n    private stack1: number[] = []\n    private stack2: number[] = []\n\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.stack1.push(x)\n    }\n\n    pop(): number {\n        if(!this.stack1.length) return\n\n        while(this.stack1.length) {\n            const stackValue = this.stack1.pop();\n            this.stack2.push(stackValue)\n        }\n\n        const popValue = this.stack2.pop();\n\n        while(this.stack2.length) {\n            const stackValue = this.stack2.pop();\n            this.stack1.push(stackValue)\n        }\n\n        return popValue\n    }\n\n    peek(): number {\n        return this.stack1[0]\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kiirii4":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185137931","body":"### 思路\n将num[n-1]相加赋值于k，对其结果求余，作为该位的值，k / 10 的结果再和num[n-2]相加，对其结果求余，作为该位的值，以此类推\n\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> vec;\n        int len = num.size();\n        for(int i = len - 1; 0 <= i || k >= 1; i--, k /= 10){\n            if( i >= 0){\n                k += num[i];\n            }\n            vec.push_back(k % 10);\n        }\n        reverse(vec.begin(), vec.end());\n        return vec;\n    }\n};\n```\n### 复杂度分析\n时间：O(max(n,logk) <n为输入数组长度 >\n空间：O(1) 除返回值外，所用空间为常数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186083081","body":"### 思路\n打算遍历string的每个字符，再从每个被指向的字符派出两个指针分别从左右同时遍历至string的边界，若元素与c相等，则将计算相对位置差来赋值。\n### 代码\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> answer(n,-1);\n        for(int i = 0 ; i < n; ++i){\n                if(s[r] == c){\n                    answer[i] = i - l;\n                    break;\n                }\n            }\n            for(int r = i; r < n; ++r){\n                if(s[r] == c && answer[i] != -1){\n                    answer[i] = min(answer[i], r - i);\n                    break;\n                }\n                else if(s[r] == c){\n                    answer[i] = r - i;\n                    break;\n                }\n            }\n        }\n        return answer;\n    }\n};\n```\n### 复杂度分析\n时间：O(n^2)\n空间：O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186395331","body":"## 思路\r\npush和pop操作只是基于数组的限制操作，\r\nincrement操作为了和其他操作一样消耗常数时间，额外维护一个数组储存每一位的增量，在元素被pop出时再添加上\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    vector<int> vec, add;\r\n    int top = -1;\r\n    CustomStack(int maxSize) {\r\n        vec.resize(maxSize);\r\n        add.resize(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != vec.size() - 1){\r\n            top++;\r\n            vec[top] = x;\r\n        }\r\n    } \r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n            return -1;\r\n        int ret = vec[top] + add[top];\r\n        if(top != 0){\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0; \r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1 , top);\r\n        if(lim >= 0)\r\n            add[lim] += val;\r\n        } \r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n## 复杂度分析\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731145","body":"## 思路\n使用递归，遇到数字，记录至multi，遇到字母，将其加入本层的字符串中，遇到\"[\"进入新的一层递归，并将下一层返回的字符串重复multi次加至本层的字符串中，遇到“]”返回本层字符串\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return dfs(s, i);\n    }\n\n    string dfs(string &s, int &i){\n        int multi = 0;\n        string res = \"\";\n        for(; i < s.size(); ++i){\n            if('0' <= s[i] && s[i] <= '9')\n                multi = multi * 10 + (s[i] - '0');\n            else if(s[i] == '['){\n                string temp = dfs(s ,++i);\n                while(multi != 0){\n                    res += temp;\n                    --multi;\n                }\n            }\n            else if(s[i] == ']')\n                return res;\n            else\n                res += s[i];\n        }\n        return res;\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$ 在递归的过程中索引是更新的，一次遍历\n- 空间复杂度：$O(n)$ 最坏情况下（如：3[3[3[a]]]）递归次数为(n-4)/3，需要线性空间\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188595534","body":"## 思路\n 区分了输入和输出栈，只有在输出栈为空时，才从输入栈中取元素压入，如此一来每一个元素最多被分别被压入压出2次\n\n## 代码\n```c++\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stk1.push(x);\n    }\n    \n    int pop() {\n        int ret = 0;\n        if(stk2.empty())\n            in2out();\n        ret = stk2.top();\n        stk2.pop();\n        return ret;\n    }\n\n    \n    int peek() {\n        if( stk2.empty()){\n            in2out();\n        }\n        return stk2.top();\n    }\n    \n    bool empty() {\n        return stk1.empty() && stk2.empty();\n    }\nprivate:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    void in2out(){\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n    }\n\n\n\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n## 复杂度分析\nn为栈长度\n空间:O(n)\n时间:每一操作都是O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189824934","body":"## 思路\n建立一个栈来存储每一块中的最大元素，一次遍历数组，若栈为空，或遍历中的数字大于栈顶，即将遍历中的数字压入栈，若栈不为空且遍历中的数字小于栈顶，则将栈顶拷贝存储下来，出栈直至栈顶元素小于或等于遍历中的元素，再将存储起来的最大元素压入栈顶。\n## 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stk;\n        int head = 0;\n        for(int i = 0; i < arr.size(); ++i){\n            if(stk.empty() || arr[i] >= head){\n                stk.push(arr[i]);\n                head = arr[i];\n            }\n            else if(arr[i] < stk.top()){\n                head = stk.top();\n                while(!stk.empty() && arr[i] < stk.top())\n                    stk.pop();\n                stk.push(head);\n            }\n        }\n        return stk.size();\n    }\n};\n```\n## 复杂度分析\nn为数组长度\n时间：一次遍历，对排序块的修正也最多遍历一次 O(n)\n空间：排序块最多为数组长度，这种情况下为线性空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ucashurui":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141689","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## 思路\n\n---\n\n从低位按位进行相加，记录进位，前面位置不够了插入新的位。（看了题解还是借助str来偷懒比较方便啊！）\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        count = len(num) - 1\n        while k or carry:\n            if count < 0:\n                num.insert(0,0)\n                count = 0\n            single_k = k % 10\n            k //= 10\n            num[count] += single_k + carry\n            carry = num[count] // 10\n            num[count] %= 10\n            count -= 1\n        return num\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** $O(N)$，\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186122298","body":"[Link to LeetCode Problem](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\n\n## 思路\n\n---\n\n从左和从右分别遍历一遍，找到和目标字符最近的距离\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        num_char = len(s)\n        answer = [num_char for _ in range(num_char)]\n        # find left closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[i] == c: \n                cur_dist = 0\n            else: \n                cur_dist += 1\n            answer[i] = cur_dist\n        # find right closest\n        cur_dist = num_char\n        for i in range(num_char):\n            if s[num_char - 1 - i] == c:\n                cur_dist = 0\n            else:\n                cur_dist += 1\n            answer[num_char - 1 - i] = min(answer[num_char - 1 - i], cur_dist)\n        return answer\n```\n\n## 复杂度分析\n\n---\n\n- ****Time:**** $O(N)$\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186487537","body":"Link to LeetCode Problem\n\n## 思路\n\n---\n\n设计一个增量栈用于记录increment操作带来的增量，在pop时返回栈中值和增量栈的和，并调整增量栈，而不是直接在increment操作时直接在栈中加上，能将increment的时间复杂度从O(N)降到O(1)。\n\n## 代码\n\n---\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.inc = []\n        self.maxSize = maxSize\n        self.size = 0\n        \n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.size += 1\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            if self.size > 1:\n                self.inc[-2] += self.inc[-1]\n            self.size -= 1 \n            return self.stack.pop(-1) + self.inc.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k, self.size)-1] += val\n```\n\n## 复杂度分析\n\n- ****Time:**** $O(1)$ （对于pop, push和increment都是）\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186713928","body":"## 思路\n\n---\n\n用一个栈保存遇到的字符，当遇到’]’时开始弹出，直到’[’时当前字符串获取完毕，开始获取重复的次数n，然后将字符串重复n次，并将重复n次后的字符串重新压入栈，如此循环。最终将栈中所有字符串和并后返回\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            char = s[i]\n            if char != ']':\n                stack.append(char)\n            else:\n                tmp_str = ''\n                while stack[-1] != '[':\n                    tmp_str = stack.pop(-1) + tmp_str\n                stack.pop(-1)\n                num_str = ''\n                while stack and stack[-1].isdigit():\n                    num_str = stack.pop(-1) + num_str\n                tmp_res = tmp_str * int(num_str)\n                stack.append(tmp_res)\n        return ''.join(stack)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)， N是字符串解码后的长度*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188541605","body":"## 思路\n\n---\n\n两个栈来回倒，为了使pop和peek两操作都是O(1)的时间复杂度，选择在push的时候倒一下\n\n## 代码\n\n---\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop(-1))\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop(-1))\n    def pop(self) -> int:\n        return self.stack1.pop(-1)\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N) for push，N为队列最长的长度，O(1)for pop,peek和empty*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740301","body":"## 思路\n\n---\n\n单调栈，能分块的条件是下一个块的最小值大于等于前一个块的最大值，我们使用一个单调栈保存遇到的值，如果新的值大于等于栈顶的值就入栈，否则就要判断这个比栈顶小的值是不是比栈顶前面的块的最大值都大，不满足的就出栈（相当于合并块），最后栈的长度就是最多能完成排序的块的数量。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for n in arr:\n            if not stack or n >= stack[-1]:\n                stack.append(n)\n            else:\n                tmp = stack.pop()\n                while stack and stack[-1] > n:\n                    stack.pop()\n                stack.append(tmp)\n        return len(stack)\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(N)*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190970768","body":"## 思路\n\n---\n\n先遍历一遍找到末尾节点和总节点数，下一遍遍历找到新的末尾节点和头节点（注意k有可能比总节点数大，需要求模），然后更改节点之间的关系即可。\n\n## 代码\n\n---\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head or not head.next or k==0: return head\n        n_nodes = 1\n        tail = p = head\n        while tail.next:\n            n_nodes += 1\n            tail = tail.next\n        for _ in range(n_nodes - k%n_nodes - 1):\n            p = p.next\n        tail.next = head\n        new_head = p.next\n        p.next = None\n        return new_head\n```\n\n## 复杂度分析\n\n---\n\n- 时间复杂度：*O(N)*\n- 空间复杂度：*O(1)*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xixiao51":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185141987","body":"### Idea\nTake K as a carry and add it to the lowest digit, then update carry, and keep going to higher digit.\n\n\n### Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int cur = k;\n        int i = num.length - 1;\n        while(i >= 0 || cur > 0) {\n            if(i >= 0) {\n                cur = cur + num[i--];\n            }\n            res.add(cur % 10);\n            cur /= 10; \n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(max(n, logk)), n is the length of num\n- Space complexity: O(max(n, logk))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186075682","body":"### Idea\nLoop twice on the string S.\nFirst forward pass to find shortest distant to character on left.\nSecond backward pass to find shortest distant to character on right.\n\n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] answer = new int[len];\n        int d = len;\n        for(int i = 0; i < len; i++) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = d;\n        }\n        \n        d = len;\n        for(int i = len - 1; i >= 0; i--) {\n            d = s.charAt(i) == c ? 0 : d + 1;\n            answer[i] = Math.min(answer[i], d);\n        }\n        \n        return answer;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n), n is the length of string s\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186435493","body":"### Idea\nUse an array to represent the stack. Push will add new integer to the array. Pop removes the last element in the array and increment will add val to the first k elements of the array.\n\n### Code\n```java\nclass CustomStack {\n    private List<Integer> stack;\n    private int max;\n\n    public CustomStack(int maxSize) {\n        stack = new ArrayList<>();\n        max = maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size() < max) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if(stack.isEmpty()) {\n            return -1;\n        }\n        int top = stack.get(stack.size() - 1);\n        stack.remove(stack.size() - 1);\n        return top;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = Math.min(stack.size(), k); i > 0; i--) {\n            stack.set(i - 1, stack.get(i - 1) + val);\n        }\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) for push and pop and O(k) for increment.\n- Space complexity: O(n), n is the maxsize\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604148","body":"### Idea\nUse 2 stacks one to store all the integer k and one to store all the decoded strings.\n### Code\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder str = new StringBuilder();\n        Stack<Integer> num = new Stack<>();\n        Stack<StringBuilder> letters = new Stack<>();\n        int k = 0;\n        for(char c: s.toCharArray()) {\n            if(Character.isDigit(c)) {\n                k = k * 10 + (c - '0');\n            } else if(c == '[') {\n                num.push(k);\n                k = 0;\n                letters.push(str);\n                str = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder temp = letters.pop();\n                for(int i = num.pop(); i > 0; i--) {\n                    temp.append(str);\n                }\n                str = temp;\n            } else {\n                str.append(c);\n            }\n        }\n        \n        return str.toString();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(kn)\n- Space complexity: O(num(k) + num(char))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188233701","body":"### Idea\nuse two stacks to make a queue\n\n### Code\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    private int front;\n    \n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    // O(1)\n    public void push(int x) {\n        if(stack1.isEmpty()) {\n            front = x;\n        }\n        stack1.push(x);\n    }\n    \n    // Amortized O(1)\n    public int pop() {\n        if(stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    // O(1)\n    public int peek() {\n        if(stack2.isEmpty()) {\n            return front;\n        }\n        return stack2.peek();\n    }\n    \n    // O(1)\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(1) per operation, Pop - Amortized O(1) per operation.\n- Space complexity: O(n) for Push, O(1) for others\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905757","body":"### Idea\nnon-strictly increasing stack\n\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> stack =  new Stack<>();\n        for(int i: arr) {\n            if(!stack.isEmpty() && i < stack.peek()) {\n                int top = stack.peek();\n                while(!stack.isEmpty() && i < stack.peek()) {\n                    stack.pop();\n                }\n                stack.add(top);\n            } else {\n                stack.add(i);\n            }\n        }\n        \n        return stack.size();\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190800674","body":"### Idea\n1. To close the linked list into the ring.\n\n2. To break the ring after the new tail and just in front of the new head.\n\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        ListNode tail = head;\n        int len = 1;\n        while(tail.next != null) {\n            tail = tail.next;\n            len++;\n        }\n        tail.next = head;\n        ListNode cur = head;\n        for(int i = 1; i <  len - (k % len); i++) {\n            cur = cur.next;\n        }\n        tail = cur.next;\n        cur.next = null;\n\n        return tail;\n    }\n}\n```\n\n**Complexity Analysis**\n- Time complexity: O(n)\n- Space complexity: O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185152522","body":"### 思路\r\n\r\n大数加法的阉割版，将 K 看作是每次加法的进位即可。\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const { length } = num;\r\n\r\n  let carry = k;\r\n  for (let i = length - 1; i >= 0; i--) {\r\n    const value = (num[i] + carry) % 10;\r\n    carry = Math.floor((num[i] + carry) / 10);\r\n    num[i] = value;\r\n  }\r\n\r\n  while (carry) {\r\n    num.unshift(carry % 10);\r\n    carry = Math.floor(carry / 10);\r\n  }\r\n\r\n  return num;\r\n};\r\n```\r\n\r\n+ 时间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n+ 空间复杂度 $O(N + logK)$, N 为传入数据 num 的长度, K 是传入的数字，logK 表示数字K的位数\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heng518":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185153547","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int len = num.size() - 1;\n        bool flag = true;\n        \n        while(len >= 0 || k > 0)\n        {\n            if(flag)\n            {\n                if(len >= 0)\n                {\n                    k += num[len];\n                    len--;\n                }\n                res.insert(res.begin(), k % 10);\n                k /= 10;\n            \n                if(k == 0)\n                    flag = false;\n            }\n            else\n            {\n                res.insert(res.begin(), num[len]);\n                len--;\n            }\n        }\n        \n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186186039","body":"class Solution {\npublic:\n vector<int> shortestToChar(string s, char c) {\n        vector<int> vec;\n        vector<int> res;\n        \n        for(int i = 0; i < s.size(); i++)\n            if(s[i] == c)\n                vec.push_back(i);\n        \n        for(int i = 0; i < s.size(); i++)\n        {\n            int temp = INT_MAX;\n            for(int j = 0; j < vec.size(); j++)\n            {\n                temp = min(temp, abs(vec[j] - i));\n            }\n            res.push_back(temp);\n        }\n        \n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yaya-bb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185155634","body":"\n## 题目地址()\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/submissions/\n\n## 前置知识\n\n- 数组的遍历，栈\n\n\n\n## 思路\n-逐位相加\n\n\n## 代码\n\n- 语言支持：JavaScript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    const n = num.length;\n    //数组遍历循环\n    for(let i = n - 1; i>= 0; i--)\n    {\n        let sum = num[i] + k%10 ;\n        k = Math.floor(k/10);\n        if(sum >= 10)\n        {\n            k++;\n            sum -=10;\n        }\n        result.push(sum);\n    }\n    //如果出现num循环后k还有剩余则需要进行下面循环\n    for(;k>0;k = Math.floor(k/10))\n    {\n        result.push(k % 10);\n    }\n    //由于利用栈的push，所以是先进后出，所以应当将其逆序\n    result.reverse();\n    return result;\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$，for循环遍历\n- 空间复杂度：$O(n)$，创建新的空间存放结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186208679","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/submissions/\r\n\r\n\r\n## 前置知识\r\n\r\n- 数组的遍历\r\n\r\n\r\n## 思路\r\n首先从左往右遍历字符串s,记录左边最后一个出现的坐标；\r\n然后从右到左遍历，判断到右侧的c字符的距离是否比到左侧距离小或者左侧没有c字符的字符，则进行替换c字符的坐标；\r\n\r\n## 关键点\r\n\r\n-  如何获取距离最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：Javascript\r\n\r\nJavascript\r\n\r\n```Javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let res = Array(s.length);\r\n\r\n    //贪心法\r\n    //先从左到右遍历\r\n    for(let i = 0 ;i <s.length ; i++)\r\n    {\r\n        if(s[i] === c)\r\n        {\r\n            res[i] = i;\r\n        }else{\r\n            //void 0 == undefined)，如果左侧没有出现过c字符，则为Infinity\r\n            res[i] = (res[i-1] === void 0 ? Infinity : res[i-1]);\r\n        }\r\n    }\r\n    //从右往左遍历\r\n    for(let i = s.length -1; i>= 0;i--)\r\n    {\r\n        //如果左侧没有c字符或者右侧出现的c字符距离更近，就更新\r\n        if(res[i] === Infinity || res[i+1] - i < i- res[i])\r\n        {\r\n            res[i] = res[i+1];\r\n        }\r\n    }\r\n    for(let i = 0 ;i <res.length ; i++){\r\n        res[i] = Math.abs(res[i] - i);\r\n    }\r\n    return res;\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531885","body":"/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    //用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\r\n    this.max = maxSize;\r\n    this.stack = [];\r\n\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    //如果栈还未增长到 maxSize ，就将 x 添加到栈顶\r\n    if(this.stack.length < this.max)\r\n    {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    //弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1\r\n   var res = this.stack.pop();\r\n   return res == null ? -1 : res;\r\n   \r\n\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0 ; i < this.stack.length;i++)\r\n    {\r\n        if(i <k)\r\n        {\r\n            this.stack[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669786","body":"/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nconst decodeString = (s) => {\r\n    let numStack = [];       \r\n    let strStack = [];        \r\n    let num = 0;            \r\n    let result = '';     \r\n    for (const char of s) {   \r\n        if (!isNaN(char)) {   \r\n            num = num * 10 + Number(char);\r\n        } else if (char == '[') {  \r\n            strStack.push(result); \r\n            result = '';           \r\n            numStack.push(num);    \r\n            num = 0;               \r\n        } else if (char == ']') {  \r\n            let repeatTimes = numStack.pop(); \r\n            result = strStack.pop() + result.repeat(repeatTimes); \r\n        } else {                   \r\n            result += char;        \r\n        }\r\n    }\r\n    return result;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189161902","body":"\r\n## 题目地址()\r\n\r\nhttps://leetcode.cn/problems/implement-queue-using-stacks/submissions/\r\n\r\n\r\n## 前置知识\r\n\r\n- 栈，队列\r\n\r\n\r\n\r\n## 关键点\r\n\r\n-  两个栈实现队列\r\n\r\n## 代码\r\n\r\n- 语言支持：Javascript\r\n\r\nja Code:\r\n\r\n```python\r\nvar MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    // void push(int x) 将元素 x 推到队列的末尾\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    // int pop() 从队列的开头移除并返回元素\r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    // int peek() 返回队列开头的元素\r\n    if(!this.stack2.length){\r\n        this.out();\r\n    }\r\n    return this.stack2[this.stack2.length -1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length == 0 && this.stack2.length == 0;\r\n};\r\n\r\nMyQueue.prototype.out = function(){\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n}\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tlntin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185157127","body":"1. [题目链接](https://leetcode.cn/problems/add-to-array-form-of-integer/submissions/)\r\n\r\n### 简单理解\r\n- 从低位往高位计算，逢十进一。数组直接从右往左数，而数字的话，每次求10的余数，求完后除10即可。\r\n- 如果数组size不够，那就再首位插入元素1实现进1操作。\r\n- 后面发现可能k比num长。所以还需要把多余的k插入到num中。\r\n- 最后输出结果即可。可以用std::move(num)直接将值移出，防止重复拷贝，节省内存。\r\n\r\n### 最终代码\r\n```bash\r\n#include <iostream>\r\n#include <vector>\r\n\r\nusing namespace std;\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n    // 反向迭代，利用加法进位来计算\r\n    int temp = 0;\r\n    int n = num.size();\r\n    for (int i = 0; i < num.size(); ++i) {\r\n      temp = num[n - i - 1] + k % 10;\r\n      k = k / 10;\r\n      num[n - i - 1] = temp % 10;\r\n      if (temp >= 10) {\r\n        if (n - i - 2 >= 0) {\r\n          num[n - i - 2] += 1;\r\n        } else {\r\n          n += 1;\r\n          num.insert(num.begin(), 1);\r\n        }\r\n      }\r\n    };\r\n    // 补丁，k可能比Num长，需要将k剩余部分插入\r\n    while (k > 0) {\r\n      num.insert(num.begin(), k % 10);\r\n      k = k / 10;\r\n    }\r\n    return std::move(num);\r\n  }\r\n};\r\n\r\n\r\n\r\nint main() {\r\n  std::vector<int> v1 = {1,3,8};\r\n  int data = 955;\r\n  Solution s;\r\n  std::vector<int> v2 = s.addToArrayForm(v1, data);\r\n  for (const int & x: v2) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 结果\r\n![image](https://user-images.githubusercontent.com/28218658/179150726-78be3d31-e26a-4c6f-812a-8add0dae6953.png)\r\n\r\n用时：24ms，内存25.8MB。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080712","body":"- 题目[链接](https://leetcode.cn/problems/shortest-distance-to-a-character/submissions/)\r\n### 解题思路\r\n- 左右两边各遍历一次，分别获取邻接最近值，然后用min函数对比两者谁更小。\r\n- 直接string可以改成cosnt string &,减少数据拷贝。\r\n- 返回还是直接用std::move，减少内存拷贝，直接移动结果。\r\n\r\n\r\n### 代码\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历，假设c再第一个位置\r\n    index = 0;\r\n    for (int i = s.size() - 1; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], abs(i - index));\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 复杂度分析\r\n1. 时间复杂度：$O(n)$，一层遍历。\r\n2. 空间复杂度：$O(n)$，因为构建了一个数组，且数组内存无法避免，当然可以用std::move做一些空间优化。\r\n\r\n### 优化思路1：\r\n- 第二次遍历的时候，初始值其实就是上一次的最终索引，并且可以优化一下，将一个n遍历拆分成index右边与左边，去掉abs函数，减少n次if判断。\r\n- 优化后时间复杂度与空间复杂度不变。\r\n\r\n```cpp\r\n// Copyright 2022\r\n#include <iostream>\r\n#include <vector>\r\n#include <string>\r\n\r\nusing std::vector;\r\nusing std::string;\r\n\r\nclass Solution {\r\n public:\r\n  vector<int> shortestToChar(const string & s, char c) {\r\n    // 前向遍历，假设c在最后一个位置\r\n    std::vector<int> result(s.size(), 0);\r\n    int index = s.size() - 1;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        result[i] = abs(i - index);\r\n      }\r\n    }\r\n    // 后向遍历1，此时已经知道了index的初始值, index右边的均大于index\r\n    // 并且不需要判断s[i] == c\r\n    for (int i = s.size() - 1; i > index; --i) {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], i - index);\r\n      }\r\n    // 后向遍历2，此时i恒小于index\r\n    for (int i = index; i >= 0; --i) {\r\n      if (s[i] == c) {\r\n        index = i;\r\n      } else {\r\n        // 此处结果取短距离\r\n        result[i] = std::min(result[i], index - i);\r\n      }\r\n    }\r\n    return std::move(result);\r\n  }\r\n};\r\n\r\n\r\nint main() {\r\n  std::string str(\"loveleetcode\");\r\n  char c1 = 'e';\r\n  Solution s;\r\n  std::vector<int> res = s.shortestToChar(str, c1);\r\n  for (const int & x : res) {\r\n    std::cout << x << \" \";\r\n  }\r\n  std::cout << std::endl;\r\n}\r\n```\r\n\r\n### 成果\r\n![image](https://user-images.githubusercontent.com/28218658/179337923-38b90c6a-552a-4a13-8e33-e7122dba3a55.png)\r\n\r\n执行用时：0ms(估计是bug)，内存6.6MB。\r\n### 优化思路2：\r\n- 既然后向遍历可以通过拆分来取消abs操作，前向遍历也是可以这么干的。\r\n- 先取index=n-1;并且result[i] = index - i;当出现`s[i] == c`，直接break出来，进行后续循环。\r\n- 后续循环时候，result[i] = i - index。这样abs函数就彻底消除了，又少了n个if，应该能再快一些。\r\n- 暂时就不写代码了，感兴趣的自行测试。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186382804","body":"- 题目[链接](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\n\n### 解题思路\n- 就是简单设计一个栈就行了，比较常规的数据结构题目\n- 唯一就是多了一个批量增加栈底n个元素值的功能，需要加一个min操作。\n- 由于max_size固定，所以采用数组做栈，而不是用链表或者动态数组。\n\n### 代码\n```cpp\n// Copyright 2022\n#include <iostream>\n\nclass CustomStack {\n private:\n  int * data;\n  int max_size;\n  int top;\n\n public:\n  explicit CustomStack(int maxSize): max_size(maxSize), top(0) {\n    data = new int[maxSize];\n  }\n  ~CustomStack() {\n    delete [] data;\n  }\n\n  void push(int x) {\n    if (top < max_size) {\n      data[top] = x;\n      ++top;\n    }\n  }\n\n  int pop() {\n    if (top > 0) {\n      --top;\n      return data[top];\n    } else {\n      return -1;\n    }\n  }\n\n  void increment(int k, int val) {\n    k = std::min(k, top);\n    for (int i = 0; i < k; ++i) {\n      data[i] += val;\n    }\n  }\n};\n\n\n\nint main() {\n  CustomStack stack(3);\n  stack.push(1);\n  stack.push(2);\n  std::cout << stack.pop() << std::endl;\n  stack.push(2);\n  stack.push(3);\n  stack.push(4);\n  stack.increment(5, 100);\n  stack.increment(2, 100);\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n  std::cout << stack.pop() << std::endl;\n}\n```\n\n\n### 复杂度分析\n|            | push   | pop    | increment |\n| ---------- | ------ | ------ | --------- |\n| 时间复杂度 | $O(1)$ | $O(1)$ | $O(n)$    |\n| 空间复杂度 | $O(1)$ | $O(1)$ | $O(1)$    |\n\n\n\n### 成果\n\n![](https://s2.loli.net/2022/07/17/N4iGqMwluScfeE5.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186726697","body":"- 题目[连接](https://leetcode.cn/problems/decode-string/submissions/)\n### 代码\n```cpp\n// CopyRight 2022\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing std::string;\n\nclass Solution {\n public:\n  string decodeString(const string & s) {\n    std::string result;\n    std::vector<char> stack1;\n    std::vector<char> temp_stack;\n    int temp_num;\n    int p;\n    std::string temp_str;\n    for (const char & c : s) {\n      if (c != ']') {\n        stack1.emplace_back(c);\n      } else {\n        // 出栈取字符串\n        while(stack1.back() != '[') {\n          temp_stack.emplace_back(stack1.back());\n          stack1.pop_back();\n        }\n        // 去除 \"[\"\n        stack1.pop_back();\n        // 出栈取数组\n        p = 1;\n        temp_num = 0;\n        while((!stack1.empty()) && ('0' <= stack1.back()) && (stack1.back() <= '9')) {\n          temp_num += p * (stack1.back() - '0');\n          stack1.pop_back();\n          p *= 10;\n        }\n        // 获取当前临时字符串(记得反向)\n        temp_str.resize(temp_stack.size());\n        for (int i = 0; i < temp_stack.size(); ++i) {\n          temp_str[temp_stack.size() -1 - i] = temp_stack[i];\n        }\n        // std::cout << temp_num << \"\\t\" << temp_str << \"\\t\" << std::endl;\n        // 成果插入stack1(这里貌似可以优化, 因为会导致后续重复循环, 但是要是不插入，如何做到数据对齐？)\n        for (int i =0; i < temp_num; ++i) {\n          stack1.insert(stack1.end(), temp_str.begin(), temp_str.end());\n        }\n        //清空temp_stack\n        temp_stack.clear();\n        temp_str.clear();\n      }\n    }\n    // 打印最终结果\n    result.resize(stack1.size());\n    for (int i = 0; i < stack1.size(); ++i) {\n      result[i] = stack1[i];\n    }\n    return std::move(result);\n  }\n};\n\n\nint main() {\n  Solution s;\n  std::string res = s.decodeString(\"3[a2[c]]\");\n  std::cout << res << std::endl;\n  std::cout << s.decodeString(\"10[a]2[bc]\") << std::endl;\n  std::cout << s.decodeString(\"2[abc]3[cd]ef\") << std::endl;\n  std::cout << s.decodeString(\"abc3[cd]xyz\") << std::endl;\n}\n```\n\n### 复杂度\n- 时间：$O(n^2)$\n- 空间: $O(n)$\n\n### 结果\n![c61fb2e7d9c552d97327037bad88d5a3.png](https://s2.loli.net/2022/07/18/Y14wDcpRWVGiUMH.png)\n\n### 优化\n- 成果不插入到原stack，减少遍历次数与空间占用(那数据如何对齐？)\n- 中间不加入temp_str，减少空间占用（但是会增加更多遍历次数，不太划算）\n- 所以还是放弃了。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188539976","body":"- 题目[链接](https://leetcode.cn/problems/implement-queue-using-stacks/)\n### 思路\n- 用两个栈，两次遍历，实现队列的功能。\n- 貌似没啥难度，就是费空间，费时间\n\n\n### 代码\n```cpp\n// CopyRight 2022\n#include <stack>\n#include <iostream>\n\n\nclass MyQueue {\n private:\n  std::stack<int> tail_stack;\n  std::stack<int> head_stack;\n public:\n  MyQueue() {\n\n  }\n    \n  void push(int x) {\n    tail_stack.emplace(x);\n  }\n    \n  int pop() {\n    // tail倒腾给head\n    int res = -1;\n    // 先判断tail有没有新加入的元素\n    if (tail_stack.size() > 0) {\n      // 再把tail_stack的值放到head去\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      tail_stack.pop();\n      // 然后再把head的值倒腾回tail，不然顺序会乱\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  int peek() {\n    // 返回队列开头的元素，需要和pop做差不多相同的动作，只不过最后不需要Pop即可返回\n    // 先判断tail有没有新加入的元素\n    // tail倒腾给head\n    int res = -1;\n    // 先判断tail有没有新加入的元素\n    if (tail_stack.size() > 0) {\n      // 再把tail_stack的值放到head去\n      while (tail_stack.size() > 1) {\n        head_stack.emplace(tail_stack.top());\n        tail_stack.pop();\n      }\n      res = tail_stack.top();\n      // 然后再把head的值倒腾回tail，不然顺序会乱\n      while (head_stack.size() > 0) {\n        tail_stack.emplace(head_stack.top());\n        head_stack.pop();\n      }\n    }\n    return res;\n  }\n    \n  bool empty() {\n    return (head_stack.size() + tail_stack.size() == 0);\n  }\n};\n\n\nint main() {\n  MyQueue queue;\n  queue.push(1);\n  queue.push(2);\n  queue.push(3);\n  queue.push(4);\n  std::cout << queue.pop() << std::endl;\n  queue.push(5);\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n  std::cout << queue.pop() << std::endl;\n}\n```\n\n### 复杂度分析\n\n| 复杂度类型 | push   | pop/peer | empty  |\n| ---------- | ------ | -------- | ------ |\n| 时间复杂度 | $O(1)$ | $O(n)$   | $O(1)$ |\n| 空间复杂度 | $O(1)$ | $O(1)$   | $O(1)$ |\n\n\n### 成果\n![b0bcb4b0943617a4ecce3fe6c3a13759.png](https://s2.loli.net/2022/07/19/5GCebk6zsHXtAEo.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189779524","body":"- 题目[链接](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\n- \n### code\n```bash\n// Copyright 2022\n#include <iostream>\n#include <vector>\n#include <stack>\n\n\nusing std::vector;\n\n\nclass Solution {\n private:\n  std::stack<int> my_stack;\n public:\n  int maxChunksToSorted(vector<int>& arr) {\n    int top = 0;\n    for(const int & x : arr) {\n      if (my_stack.size() > 0) {\n        if (x >= my_stack.top()) {\n          my_stack.emplace(x);\n        } else {\n          top = my_stack.top();\n          while (my_stack.size() > 0 && my_stack.top() > x) {\n            my_stack.pop();\n          }\n          my_stack.emplace(top);\n        }\n\n      } else {\n        my_stack.emplace(x);\n      }\n    }\n    return my_stack.size();\n  }\n};\n\n\nint main() {\n  /*\n    最多多少块？\n    观察可得，倒序情况下，不可分块，也就是1块整体\n    顺序情况下，理论上可以随便分块，切n-1刀，分成n块（虽然每块1）\n    这样来看，顺序排列的元素个数就是最终能分的块多少\n    利用单调栈求顺序排列元素有多少，即后入栈的元素必须大于先入栈的，否则元素出栈，\n    直到满足要求(或者栈为空), 再将栈顶元素加回来\n  */\n  Solution s1;\n  std::vector<int> v1 = {5,4,3,2,1};\n  std::cout << s1.maxChunksToSorted(v1) << std::endl;\n\n  Solution s2;\n  std::vector<int> v2 = {2,1,3,4,4};\n  std::cout << s2.maxChunksToSorted(v2) << std::endl;\n\n  Solution s3;\n  std::vector<int> v3 = {4, 2, 2, 1, 1};\n  std::cout << s3.maxChunksToSorted(v3) << std::endl;\n\n}\n```\n\n### 复杂度\n- 时间：$O(n)$, 空间$O(n)$\n\n### 成果\n![694cc3d3cd98d9c1eda495ae144297b0.png](https://s2.loli.net/2022/07/20/bWSV4ieN7mYEk5O.png)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190963482","body":"### 思路\n- 普通链表转循环链表，然后偏移head到对应位置就行了。\n- [链接](https://leetcode.cn/problems/rotate-list/submissions/)\n\n### 代码\n```cpp\n#include <iostream>\n\n/**\n * Definition for singly-linked list.\n */\n struct ListNode {\n     int val;\n     ListNode *next;\n     ListNode() : val(0), next(nullptr) {}\n     ListNode(int x) : val(x), next(nullptr) {}\n     ListNode(int x, ListNode *next) : val(x), next(next) {}\n };\nclass Solution {\npublic:\n  ListNode* rotateRight(ListNode* head, int k) {\n    // 旋转链表？循环链表!\n    // list.size() <500, 但是k可能会很大，所以先遍历一下List获取size比较合适\n    // 只要把链表变成循环链表，然后从size - (k % size)的位置断开，就能实现旋转链表了\n    // 第一步：获取最后一个节点，不包含null节点\n    ListNode * p1 = head;\n    std::size_t size = 0;\n    while (p1 && p1->next) {\n      size ++;\n      p1 = p1->next;\n    }\n    if (p1 && !p1->next) {\n      ++size;\n    }\n    // 第二步，构建循环链表(前提head不为null)\n    if (p1) {\n      p1->next = head;\n      // 第三步，计算head偏移位置\n      int n = size - (k % size);\n      // 第四步，偏移head,断开head前一个节点\n      ListNode * p2 = head;\n      for (int i = 1; i < n; ++i) {\n        p2 = p2->next;\n      }\n      head = p2->next;\n      p2->next = nullptr;\n    }\n    return head;\n  }\n};\n```\n\n### 复杂度\n- 时间：$O(n)$\n- 空间：$O(1)$\n\n### 结果\n![2a3d738bd20baaae45bf663d26fe7741.png](https://s2.loli.net/2022/07/21/JOTipmMgB685HsA.png)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richypang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185158822","body":"## 代码（注释解析了每一步的思路）\n\nclass Solution:\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        #将数组转化为str形式存储\n        temp = \" \"\n        for i in num:\n            temp = temp + str(i)\n        #整数相加\n        number = int(temp) + k\n        result = []\n        for j in str(number):\n            result.append(int(j))\n        return result\n## 复杂度 \n\n时间复杂度 O(n)\n空间复杂度O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111174","body":"## 思路\n\n>1.先试用一次循环记录下所有c出现的位置并记录在have_c中\n\n>2.再次循环每一个字母，利用其所在的index分别与have_c相减获取其绝对值并记录最小值\n将最小值记录在result中输出\n\n##代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        have_c = []\n        for i in range(len(s)):\n            if s[i] == c:\n                have_c.append(i)\n        print(have_c)\n        result = []\n        for i in range(len(s)):\n            if s[i] == c:\n                result.append(0)\n            else:\n                min = 99999999999\n                for j in range(len(have_c)):\n                    if min > abs(have_c[j] - i):\n                        min = abs(have_c[j] - i)\n                result.append(min)\n        return result\n\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186411631","body":"## 思路\r\n\r\n> 注意push时不超过最大maxsize，pop时stack仍有数字\r\n\r\n##代码\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_len = maxSize\r\n        self.current_len = 0\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_len:\r\n            self.stack.append(x)\r\n            self.current_len += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0: return -1\r\n        else:\r\n            self.current_len -= 1\r\n            return self.stack.pop()\r\n\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        less = min(k,len(self.stack))\r\n        for i in range(0,less):\r\n            self.stack[i] += val\r\n\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: pop push 为O(1) increment 为O(n)\r\n> + 空间复杂度: O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186624023","body":"## 思路\n\n> 判断遇到的是字符串还是数字还是括号，分别作不同处理\n\n##代码\n\n```python\n#\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, times = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([times, res])\n                res, times = \"\", 0\n            elif c == ']':\n                cur_times, last_res = stack.pop()\n                res = last_res + cur_times * res\n            elif '0' <= c <= '9':\n                #判断多位数字情况\n                times =  times * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188417974","body":"## 思路\n\n> 使用两个stack来实现队列需求\n\n##代码\n\n```python\n#\nclass MyQueue:\n\n    def __init__(self):\n        #建立input，output两个stack\n        self.input = []\n        self.output = []\n\n\n    def push(self, x: int) -> None:\n        #将新元素放进input stack中\n        self.input.append(x)\n\n\n    def pop(self) -> int:\n        #判断是否为空\n        if self.empty():\n            return None\n        if self.output:\n            return self.output.pop()\n        else:\n            #若不为空，则将input中的pop到output中\n            while self.input:\n                val = self.input.pop()\n                self.output.append(val)\n            #pop output的元素\n            return self.output.pop()\n\n\n\n    def peek(self) -> int:\n        res = self.pop()\n        self.output.append(res)\n\n        return res\n\n\n\n    def empty(self) -> bool:\n        #当两个stack都为空时，才return true\n        if not (self.output or self.input):\n            return True \n        else:\n            return False\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189631616","body":"## 借鉴官方题解思路\n\n> + 思路描述\n\n##代码\n\n```python\n#\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        dict_a = collections.defaultdict(int)\n        dict_b = collections.defaultdict(int)\n        max_ans = 0\n        for i,j in zip(arr,sorted(arr)):\n            dict_a[i] += 1\n            dict_b[j] += 1\n            if dict_a == dict_b: max_ans+= 1\n        return max_ans\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190849726","body":"## 思路\n\n> 使用快指针指向新节点的第一位，慢指针获取新节点的最后一位，在对链表进行拼接操作\n\n##代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        #初始临界条件\n        if (not head or not head.next): return head\n        total = 0\n        cur = head\n        #获取整个链表的长度\n        while cur:\n            cur = cur.next\n            total += 1\n        #取余数避免重复循环\n        k = k % total\n        #创建快慢指针\n        slow = head\n        fast = head\n        while fast.next:\n            if (k <= 0):\n                slow = slow.next\n            k = k -1 \n            fast = fast.next\n        #快指针的位置即为新链表的头节点\n        fast.next = head\n        result = slow.next\n        slow.next = None\n        return result\n\n\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fenchuiyun":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185161504","body":"### 思路\r\n目标：实现两个大非负整数相加<br>\r\n背景：像整型integer和long的数据都是有数据范围的\r\n\r\n### 代码\r\n```java\r\n    class Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n                // 先把k转换为数组\r\n        char[] chars = String.valueOf(k).toCharArray();\r\n        int maxLength = Math.max(num.length,chars.length);\r\n        int minLength = Math.max(num.length,chars.length);\r\n        int tmp = 0;\r\n        int[] result = new int[maxLength + 1];\r\n        for (int offset = 0; offset < minLength; offset++) {\r\n            int numIdx = num.length - 1 - offset;\r\n            int charsIdx = chars.length -1 - offset;\r\n            if (numIdx>=0&&charsIdx>=0){\r\n                int sum = chars[charsIdx]-'0'+num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else if (numIdx>=0){\r\n                int sum = num[numIdx]+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }else {\r\n                int sum = chars[charsIdx]-'0'+tmp;\r\n                tmp = sum/10;\r\n                int y = sum%10;\r\n                result[maxLength-offset] = y;\r\n            }\r\n        }\r\n        if (tmp!=0){\r\n            result[0] = tmp;\r\n        }\r\n        if (result[0]==0){\r\n            return Arrays.stream(result).skip(1).boxed().collect(Collectors.toList());\r\n        }else {\r\n            return Arrays.stream(result).boxed().collect(Collectors.toList());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186156714","body":"### 思路\n- 方法一：暴力破解，对象下标为i的元素，从数组nums中查找离下标i最近且值为target的下标。 \n- 方法二：两次遍历（今日学习到的），一次从左到右的便利，对于下标为i的数据，我们可以得到左边离它最近的位置，通过两次遍历可以解决问题。\n\n```java\n//方法一\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 方法一: 暴力算法\n        // 针对i下标的数据，在数组中查询最近的一个\n        char[] chars = s.toCharArray();\n        int[] result = new int[chars.length];\n        for (int i = 0; i < chars.length; i++) {\n            int offset = s.length();\n            result[i] = getLocalOffset(chars,c,i);\n        }\n        return result;\n    }\n\n    private  int getLocalOffset(char[] array, char target, int idx) {\n        char value = array[idx];\n        if (value==target){\n            return 0;\n        }\n        int tmp = 100000;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i]==target&&Math.abs(i-idx)<tmp) {\n                tmp = Math.abs(i-idx);\n            }\n        }\n        return tmp;\n    }\n}\n```\n### 复杂度\n时间复杂度O(n^2)<br>\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186515973","body":"### 思路\n栈的特点，先进先出，利用数组来实现，下标pushIdx永远指向下一个元素的位置，则pop的位置为pushIdx-1\n### 代码\n```java\nclass CustomStack {\n\n    Integer[] values;\n    int pushIdx = 0;\n\n    public CustomStack(int maxSize) {\n        this.values = new Integer[maxSize];\n    }\n    \n    public void push(int x) {\n        if(pushIdx >= values.length){\n            return;\n        }else{\n            values[pushIdx]=x;\n            pushIdx ++;\n        }\n    }\n    \n    public int pop() {\n        if(pushIdx-1>=0){\n            return values[(pushIdx--)-1];\n        }else{\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int i = 0;\n        while(i<pushIdx&&i<k){\n            values[i]=values[i]+val;\n            i++;\n        }\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186857952","body":"### 思路\n把经过编码的字符串，还原成解码后的字符串\n需要解析匹配口号，如[]，可以利用栈\n```java\nclass Solution {\n    public String decodeString(String s) {\n        //  把经过编码的字符串，还原成解码后的字符串   k[encoded_string]\n        // 我们需要解析匹配括号,如[] ，想到利用栈\n        char[] chars = s.toCharArray();\n        Stack<Character> stack = new Stack<>();\n        int idx = 0;\n        while (true){\n            if (idx>=chars.length){\n                break;\n            }\n            char val = chars[idx];\n            if (val==']'){\n                String blabla = getString(stack);\n                for (char c : blabla.toCharArray()) {\n                    stack.push(c);\n                }\n            }else{\n                stack.push(val);\n            }\n            idx++;\n        }\n        String reversedResult = \"\";\n        while (!stack.isEmpty()){\n            Character pop = stack.pop();\n            reversedResult += pop;\n        }\n\n        return new StringBuilder(reversedResult).reverse().toString();\n    }\n\n    private String getString(Stack<Character> stack) {\n        if (stack.isEmpty()){\n            return \"\";\n        }\n        String reversedVal = \"\";\n        while (true){\n            Character pop = stack.pop();\n            if (pop=='['){\n                break;\n            }else {\n                reversedVal += pop;\n            }\n        }\n        StringBuilder sb = new StringBuilder(reversedVal);\n        String value = sb.reverse().toString();\n        String reverseCount = \"\";\n        while (!stack.isEmpty()){\n            Character countNumb = stack.peek();\n            if (countNumb-'9'>0){\n                break;\n            }\n            reverseCount+=countNumb;\n            stack.pop();\n        }\n        Integer count = Integer.valueOf(new StringBuilder(reverseCount).reverse().toString());\n        String result = \"\";\n        for (Integer i = 0; i < count; i++) {\n            result+=value;\n        }\n        return result;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n) <br>\n空间复杂度: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189934192","body":"### 思路\n正如[2,1,3,4,4]分片成[2,1][3][4][4]\n我们可以观察发现**前面的分段**中的最小值小于**后面的分段**<br>\n我们用chunk[]数组来代表分片的结果，fmax(chunk[x])代表以chunk[x]分片中的最大值,fmin(chunk[x])代表chunk[x]分片中的最小值<br>\n则对于正确的分段数组有,对于0<=i<j来说，始终有**fmax(chunk[i])< fmin(chunk[j])**\n\n对于我们如何分片的指导:\n- 对于下标为i的元素，加入当前chunk，如果fmax(chunk)<待处理数据中最小的值，那么这个chunk就可以分出来了\n\n### 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // 我们用chunk[]数组来代表分片的结果\n        // fmax(chunk[x])代表以chunk[x]分片中的最大值,fmin(chunk[x])代表chunk[x]分片中的最小值\n        // 则对于0<=i<j来说，始终有fmax(i)< fmin(chunk[j])\n        // 贪心，每次就尝试块数量最小的分法，最总能得到正确的结果吗？\n        // i代表待处理的数据开头下标,用max代表上一个chunk的最大值\n        // 如何分片，对与max < 待处理数据的最小值，即可分片\n        // flag来表示是否分过片\n\n        // 获得以下标idx+1为头的最小数据\n        int[] min = new int[arr.length];\n        int idx = arr.length-2;\n        int tmp = arr[arr.length-1];\n        while (idx>=0){\n            int val = arr[idx];\n            min[idx]=tmp;\n            if (val<tmp){\n                tmp = val;\n            }\n            idx--;\n        }\n        // 当前几个分片\n        int result = 0;\n        int max = -1;\n        boolean isChuned = false;\n        for (int i = 0; i < arr.length-1; i++) {\n            int val = arr[i];\n            if (max<val){\n                max = val;\n            }\n            // 判断当前数据是否可以分片\n            if (max<=min[i]){\n                result++;\n                isChuned = true;\n            }else {\n                isChuned = false;\n            }\n        }\n        return result+1;\n\n    }\n}\n```\n### 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry-lllman":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185162752","body":"### 解题思路:\r\n从低位往高位处理\r\n1. 将 k 与 num[i] 相加, k += num[i]\r\n2. 将 k % 10 后添加到 res 中\r\n3. 每次遍历都将 k /= 10\r\n4. 返回 res\r\n\r\n### case:\r\n1. 注意 k / 10 需要处理浮点数的问题 k = Math.floor(k / 10)\r\n2. 当 i < 0 时（即num遍历完了，k仍有余值）不再需要 k += num[i]\r\n\r\n```ts\r\nfunction addToArrayForm(num: number[], k: number): number[] {\r\n  const res = []\r\n  const leng = num.length\r\n  for (let i = leng - 1; i >= 0 || k > 0; i--, k = Math.floor(k / 10)) {\r\n    if (i >= 0) {\r\n      k += num[i]\r\n    }\r\n    res.push(k % 10)\r\n  }\r\n  res.reverse()\r\n  return res\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186179190","body":"## 解题思路\n从中间往两边查找\n\n## 代码\n```ts\nfunction shortestToChar(s: string, c: string): number[] {\n  const leng = s.length\n  const ans: number[] = new Array(leng)\n  for (let i = 0; i < leng; i++) {\n    for (let j = 0; j < leng; j++) {\n      if (s[i + j] === c || s[i - j] === c) {\n        ans[i] = j\n        break\n      }\n    }\n  }\n  return ans\n};\n```\n\n## 复杂度分析\n时间复杂度：O(n2)，两层循环  \n空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1190087929","body":"```ts\nclass CustomStack {\n  data: number[] = []\n  maxSize: number\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n  }\n\n  push(x: number): void {\n    if (this.data.length === this.maxSize) return\n    this.data.push(x)\n  }\n\n  pop(): number {\n    return this.data.pop() || -1\n  }\n\n  increment(k: number, val: number): void {\n    for(let i = 0; i < k && i < this.data.length; i++) {\n      this.data[i] += val\n    }\n  }\n}\n\n```\n### 复杂度分析\n时间复杂度：\npush,pop O(1), increment O(min(k, ctn))\n空间复杂度：\nO(1)\n\n看题解做的优化，这题要是按照上面的写面试基本凉了～\n### 优化思路\n1. 额外维护一个maxSize长度的数组，每次increment时将increments[k] += val，这样就将复杂度降低到了O(1)\n2. 在pop时将栈顶的值与对应在increments中的值相加返回，在返回之前将increments[top - 1] += increments[top]的值\n以上这两个操作就能满足increment将k(stack.length)个值都加val的要求了\n```ts\nclass CustomStack {\n  maxSize: number\n  stack: number[] = []\n  increments: number[]\n  constructor(maxSize: number) {\n    this.maxSize = maxSize\n    this.increments = new Array(maxSize).fill(0)\n  }\n\n  push(x: number): void {\n    if (this.stack.length < this.maxSize) {\n      this.stack.push(x)\n    }\n  }\n\n  pop(): number {\n    const ind = this.stack.length - 1\n    if (ind < 0) return -1\n    if (ind > 0) {\n      this.increments[ind - 1] += this.increments[ind]\n    }\n    const res = this.stack.pop() + this.increments[ind]\n    this.increments[ind] = 0\n    return res\n  }\n\n  increment(k: number, val: number): void {\n    let i = Math.min(k, this.stack.length) - 1\n    if (i >= 0) {\n      this.increments[i] += val\n    }\n  }\n}\n\n### 复杂度分析\n时间复杂度：O(1)\n空间复杂度：额外维护了一个大小为 maxSize 的数组，平均复杂度 O(maxSize/N)，N为操作次数\n```","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190150684","body":"## 解题思路\n 利用单调栈，当审查元素比栈顶元素小，则从栈顶开始对比栈内每一个元素，将大于审查元素的全部剔除，维持住单调性\n 最后返回单调栈的长度即可\n\n## 代码实现\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n  let incStack: number[] = []\n  for (let i = 0; i < arr.length; i++) {\n    if (incStack.length && arr[i] < incStack[incStack.length - 1]) {\n      const temp = incStack[incStack.length - 1]\n      // 将小的元素剔除，维护单调栈的单调性\n      while (incStack[incStack.length - 1] > arr[i]) incStack.pop()\n      // 最后再将审查元素添加到栈内\n      incStack.push(temp)\n    } else {\n      incStack.push(arr[i])\n    }\n  }\n  return incStack.length\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190992188","body":"## 解题思路\n遍历链表，形成环形链表，同时记录链表长度 leng\n移动 leng - k 个位置，就到了新的尾节点，下一个就是新的头节点了\n断开尾节点与头节点的链接，返回新的头节点即可\n### Case\nk 可能大于 leng，所以 k 需要 %= leng 以后才是实际需要移动的数值\n\n## 代码\n```ts\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n\tif (!head) return head\n\tlet leng = 1\n\tlet p = head\n\twhile (p.next) {\n\t\tp = p.next\n\t\tleng++\n\t}\n\tp.next = head\n\n\tk %= leng\n\tk = leng - k\n\twhile (k--) {\n\t\tp = p.next\n\t}\n\thead = p.next\n\tp.next = null\n\treturn head\n};\n```\n## 复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nickyk319":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163309","body":"### 思路\r\n\r\nSimulate the way we do addition manually.\r\n\r\n1. Iterate array from right to left\r\n2. Do addition between last element and integer K. \r\n3. Every time only keep the last digit of the result, and put it into a list. \r\n4. Forward the rest digits of the result to do summation with the previous element in the array. \r\n5. Repeat the above process until array out of index or the value been set to zero\r\n6. The reverse of the list will be the answer to return.\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        ArrayList<Integer> ans = new ArrayList<>();\r\n        int curVal = k;\r\n        int i = len - 1;\r\n        while (i >= 0 || curVal > 0) {\r\n            if (i >= 0) {\r\n                curVal += num[i];\r\n            }\r\n            ans.add(curVal % 10);\r\n            curVal /= 10;\r\n            i--;\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为nums数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387841","body":"### 思路\n\nUse ArrayList to simulate Stack\n\n### 代码\n\n\n```java\nclass CustomStack {\n    private int size;\n    private ArrayList<Integer> stack = new ArrayList<>();\n    public CustomStack(int maxSize) {\n       size = maxSize; \n    }\n    \n    public void push(int x) {\n        if (stack.size() < size) {\n            stack.add(x);\n        }\n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        } else {\n            return stack.remove(stack.size() - 1);\n        }\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < stack.size(); ++i) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：increment is O(N)，push() and pop() are O(1)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612833","body":"### 思路\n\nUse two stack, one used for numbers and the other used for string. \n\nConsider 4 circumstances:\n1. element is digit, store it in variable k.\n2. element is '[', push the number and string to countStack and stringStack respectively.\n3. element is ']', decode string by append k times current string to the top of the stringStack.\n4. element is a character, append to currentString.\n\n### 代码\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();\n        Stack<StringBuilder> stringStack = new Stack<>();\n        StringBuilder currentString = new StringBuilder();\n        int k = 0;\n        \n        for (char ch: s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                k = k * 10 + ch - '0';        \n            } else if (ch == '[') {\n                countStack.push(k);\n                stringStack.push(currentString);\n                currentString = new StringBuilder();\n                k = 0;\n            } else if (ch == ']') {\n                StringBuilder decodeString = stringStack.pop();\n                for (int currentK = countStack.pop(); currentK > 0; currentK--) {\n                    decodeString.append(currentString);\n                }\n                currentString = decodeString;\n            } else {\n                currentString.append(ch);\n            }\n        }\n        return currentString.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189138309","body":"### 思路\n\nUse two stack. consider stack1 as back of queue, stack2 as front of queue.\n\n1. push(x) ==> just push x into stack1\n2. peek() ==> because the front of queue is the bottom element in the stack, we need to make sure stack2 is empty, then pop all the element in stack1 and push into stack2.\n3. pop() ==> do peek first to make sure stack2 is not empty, then just pop stack2. \n\n\n\n### 代码\n\n\n```java\nclass MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while(!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) for worst cases. Average O(1) because each element only move at most one time.\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190382247","body":"### 思路\n\nNo matter the array is sorted or not, the sum of element inside each chunk will be the same. We just need to count the number of equal sum, it is the maxinum number of chunks we can get.\n\n\n### 代码\n\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(sorted);\n        int sum1 = 0, sum2 = 0, count = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n\n            if (sum1 == sum2) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(NlogN) \n- 空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185163334","body":"### Idea\n每次位移一个\n### Code\n``` \npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        //.       0 1 2\n        // num = [2,1,5], k = 1806\n        //            |         \n        //            5.   +     6. => 11 (1 % 1) ==> [1]\n        //           |\n        //           1     +.   0   => 1 + 0 + 1 = 2 ==> 2 % 0 ==> [2, 1]\n        //         |\n        //         2.      +.   8.  => 2 + 8 + 0 = 10 => 0 % 1 ==> [0, 2, 1]\n        //.      |\n        //.      0         +.   1   ==>. 0 + 1 + 1 == > 2 % 0 ==> [2, 0, 2, 1]\n        //      |\n        int bitIndex = num.length - 1;\n        int overFlow = 0;\n        while (k != 0 || bitIndex >= 0 || overFlow != 0) {\n            int valFromNum = bitIndex >= 0 ? num[bitIndex] : 0;\n            int valFromK = k % 10;\n            k = k / 10;\n            int numVal = valFromNum + valFromK + overFlow;\n            overFlow = numVal / 10;\n            ans.add(0, numVal % 10);\n            bitIndex--;\n        }\n        \n        return ans;\n    }\n```\n\n###  complexity\nTime: O(max (N, len(K)));\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186110330","body":"### Algo\n    // s: c xxxx c xxxx c xx c\n    //.     |\n    //.   |.     |\n    // -> 0 1234 0 1234 0 12 0\n    //    0 4321 0 4321 0 21 0 <-\n    //.   0 1221 0 1221 0 11 0\n    //.   xxx c xxx\n    //.   MMM 0 123\n    //.   321 0 MMM\n    // \n    // For any certain index, the closest distance from c, is either the occurence of c before it or after it\n    // so we can go through the array from head to tail, to count the distance from c before it\n    // and do it again from tail to head to count the distance from c after it.\n    // Take the min value as the answer.\n    // To count the distance, whenver met a c, refresh the distance to 0, and every movement plus 1 on the distance, start with distance as Integer.MAX_VALUE\n    \n\n### Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        Arrays.fill(ans, Integer.MAX_VALUE);\n        \n        int distance = Integer.MAX_VALUE;\n        for (int i = 0; i < ans.length; i++) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        distance = Integer.MAX_VALUE;\n        for (int i = ans.length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                distance = 0;\n            } else {\n                distance = distance < Integer.MAX_VALUE ? distance + 1 : distance;\n            }\n            if (distance < ans[i]) {\n                ans[i] = distance;\n            }\n        }\n        \n        return ans;\n    }\n}\n```\n### Time Complexity\n1. Time: O(n)\n2. Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186360602","body":"### Algo\n//     Since we need to maintain \"random\" access which is not possible with stack/queue/deque\n//     so lets use array to mock a stack, luckily the array size is given.\n    \n//     1. we first init an array with length as maxSize, and maintain a pnt to indicate the next avaible slot\n//        so pnt == 0, means empty; pnt == arr.length means full\n//     2. for each push, check the pnt position; if available, insert into pnt and pnt++\n//     3. same logic for pop, return arr[pnt - 1] and pnt--;\n//     4. increment just start with index 0 till Min(pnt - 1, k);\n    \n### Code\n```java\nclass CustomStack {\n    private int[] arr;\n    private int nextAvailableSlot = 0;          //  |\n    public CustomStack(int maxSize) {           // [y,y,y]\n        arr = new int[maxSize];                 //. 0 1 2\n    }\n    \n    public void push(int x) {                    // [1,2,y]    // [1,2,y]\n        if (nextAvailableSlot < arr.length) {    //      |     //    |\n            arr[nextAvailableSlot] = x;                        //  [1,2,y]\n            nextAvailableSlot++;                               //.      |\n        }                                                      //  [1,2,3]\n    }                                                          //.         |\n    \n    public int pop() {\n        if (nextAvailableSlot != 0) {            // [1,2,y]\n            nextAvailableSlot--;                 //.   |\n            return arr[nextAvailableSlot];       //.   2\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int tillIndex = Math.min(k, nextAvailableSlot );   //  [1,2,3]           [1,2,3]        \n        for (int i = 0; i < tillIndex; i++) {              //.         |                 |\n            arr[i] += val;                                   // tillIndex = 3    tillIndex = min(2,3) = 2\n        }                                                  // [101, 102, 103]    [201, 202, 103]  \n    }\n}\n```\n### Complexity\n1. Time: O(1) for push and pop, O(k) for increment\n2. Space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186843684","body":"### Algo\n//     11:18PM\n//     Constraints:\n//     1. K > 0\n//     2. 2[4]/3a/2[]\n//     3. digits are only repeat\n        \n//     test case:\n//     1. abc\n//     2. a3[a]\n//     3. 3[a3[b]]c\n        \n        \n//     \"a3[a2[c]]\"  \n//     1. get the string => a\n//     2. get the repeated number => 3\n//     3. get the repeated string => a2[c]\n//         3.1 get the string => a\n//         3.2 get the repeated number => 2\n//         3.3 get the repeated string => c\n//             3.3.1 get the string => c\n//             3.3.2 get the repeated number => 0\n//         3.4 get built string repeated number * returned string => 2 * c = cc\n//         3.5 prefix string => a + cc = acc\n//     4. get built string repeated number * returned string => 2 * acc = accaccacc\n//     5. prefix string => a + accaccacc = aaccaccacc\n    \n    // \"3[2[c]]\"\n    // 1. get string => \"\"\n    // 2. get the repeated number => 3\n    // 3. get the repeated string => 2[c]\n    //     3.1 get the string => \"\"\n    //     3.2 get the repeated number => 2\n    //     3.3 get the repeated string => c\n    //         3.3.1 get the string => c\n    //         3.3.2 get repeated number => 0  ==> !end!\n    //     3.4 get built string repeated number * returned string => 2 * c = cc\n    //     3.5 prefix string => \"\" + cc = cc\n    // 4. get built string repeated number * returned string => 3 * cc = cccccc\n    // 5. prefix string => \"\" + cccccc = cccccc\n    \n### Code\nclass Solution {\n    public String decodeString(String s) {                  \n        return helper(s, 0, s.length() - 1);\n    }\n    \n    private String helper(String s, int startIndex, int endIndex) {     //         \"3[a]2[bc]\"       // a\n        int index = startIndex;                                         // index = 0 \n        StringBuilder ans = new StringBuilder();\n        while (index <= endIndex) {\n            String prefixString = getPrefixString(s, index, endIndex);      // prefix= \"\"\n            index += prefixString.length();                                 // index = 0;\n\n            String repeatedNumber = getRepeatedNumber(s, index, endIndex);  // repeat =  \"3\"\n            if (repeatedNumber.length() == 0 || Integer.valueOf(repeatedNumber) == 0) {\n                ans.append(prefixString);\n                continue;\n            }\n            index += repeatedNumber.length();                                // index = 1\n\n            index += 1; // forward one step to skil [                        // index = 2; \n            int repeatedStringEnds = getRepeatEndIndex(s, index, endIndex);  // reapted = 3\n                                                                             // rewind 1 step for ]\n            String repeatedString = helper(s, index, repeatedStringEnds - 1); // str = \"a\"\n            index = repeatedStringEnds + 1;\n            String returnString = \"\";\n\n            int repeatedNum = Integer.valueOf(repeatedNumber);                // return = \"aaa\"\n            for (int i = 0; i < repeatedNum; i++) {\n                returnString += repeatedString;\n            }\n            ans.append(prefixString).append(returnString);\n        }\n        \n        return ans.toString();                       //\n    }\n                                                                              // |\n    private String getPrefixString(String s, int startIndex, int endIndex) {  // 3[a]2[bc]\n        // keep tracking until meets a number or ends\n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;\n        while (index <= endIndex && s.charAt(index) >= 'a' && s.charAt(index) <= 'z') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }\n                                                                                           // ||\n    private String getRepeatedNumber(String s, int startIndex, int endIndex) {             // 3[a]2[bc]\n        // get first start should be a number or the end \n        StringBuilder sb = new StringBuilder();\n        int index = startIndex;                                                            // sb = 3\n        while (index <= endIndex && s.charAt(index) >= '0' && s.charAt(index) <= '9') {\n            sb.append(s.charAt(index));\n            index++;\n        }\n        return sb.toString();\n    }                                                                              \n                                                                                 //   ||\n    private int getRepeatEndIndex(String s, int startIndex, int endIndex) {      // 3[a]2[bc]\n        // get first start should be a [ or end index                            //.012345678\n        int numberOfBackBracket = 0;                                             //    1\n        int index = startIndex;\n        while (index <= endIndex) {                                              //    \n           if (s.charAt(index) == ']') {\n               numberOfBackBracket++;\n           }\n            \n           if (numberOfBackBracket == 1) {\n               return index;\n           }\n            \n           if (s.charAt(index) == '[') {\n               numberOfBackBracket--;\n           }\n            index++;\n        }\n        \n        return -1;\n    } \n}\n### Complexity\n1. Time: O(n);\n2. Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188484438","body":"### AlGO\n//     peek 1\n//     Stack1 [ \n//     Stack2 [2,\n//         peek ==> 2\n//         pop  ==> 1\n//     Queue  [1, 2]\n//         pop ==> 1\n    \n//     Start with two stack, push and pop, both are empty at beginning\n//     we also need another vairable peekHolder to hold the first element in stackPush\n//                |\n//     StackPush [3,4\n//     StackPop  [\n//                |\n//     Queue [2,3,4]\n    \n//     push 1\n//         peekHolder = 1\n//     push 2\n//         for push action, add to push stack\n//     peek \n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push  ==> 1\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top\n//     peek\n//         the top of stack pop\n//     push 3\n//         peekHolder = 3\n//     push 4\n//         for push action, add to push stack\n//     peek\n//         the top of stack pop == > 2\n//     pop\n//         for pop, transfer all elements from push to pop if pop is empty\n//         then remove stack top  ==> 2\n//     peek\n//         the top of stack pop if pop stack is not empty\n//         otherwise, the stack bot for stack push\n### Code\n```java\nclass MyQueue {\n    private Deque<Integer> pushStack;\n    private Deque<Integer> popStack;\n    private Integer pushStackBot;\n    public MyQueue() {\n        pushStack = new ArrayDeque<>();\n        popStack = new ArrayDeque<>();\n        pushStackBot = null;\n    }\n    \n    public void push(int x) {\n        if (pushStack.isEmpty()) {\n            pushStackBot = x;\n        }\n        pushStack.offerLast(x);\n    }\n    \n    public int pop() {\n        if (popStack.isEmpty()) {\n            while (!pushStack.isEmpty()) {\n                popStack.offerLast(pushStack.pollLast());\n            }\n            pushStackBot = null;\n            return popStack.pollLast();\n        } else {\n            return popStack.pollLast();\n        }\n    }\n    \n    public int peek() {\n        if (popStack.isEmpty()) {\n            return pushStackBot;\n        } else {\n            return popStack.peekLast();\n        }\n    }\n    \n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty();\n    }\n}\n```\n### Complexity\n1. Time: O(1) for all operation\n2. Space: O(n), n is the number of elements in queue","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189425016","body":"### Algo\n类似于merge sort的想法\n### Code\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        \n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        \n        int chunks = 0;\n        \n        Map<Integer, Integer> valCntInSorted = new HashMap<>();\n        // Map<Integer, Integer> valCntInOrg = new HashMap<>();\n                                                                                // org:   1 3 2 4 4\n        int index = 0;                                                          // sorted:1 2 3 4 4\n        int diff = 0;\n        while (index < arr.length) {                                            //.           |         \n            if (!valCntInSorted.containsKey(sorted[index]) || valCntInSorted.get(sorted[index]) >= 0) {                   // diff.    2 \n                diff++;         \n            } else {\n                diff--;                                                     //           1\n            }\n            valCntInSorted.put(sorted[index], valCntInSorted.getOrDefault(sorted[index], 0) + 1); // 1,0, 2,1, 3,0\n            \n            \n            //====//\n            if (!valCntInSorted.containsKey(arr[index]) || valCntInSorted.get(arr[index]) <= 0) {                     // diff    2\n                diff++;\n            } else {                      // diff   0\n                diff--;\n            }\n            valCntInSorted.put(arr[index], valCntInSorted.getOrDefault(arr[index], 0) - 1); // 1, 0, 2,0, 3,0\n            \n            if (diff == 0) {\n                chunks++;\n            }\n\n            index++;\n        }\n        \n        return chunks;\n    }\n}\n```\n### Complexity\n1. Time: O(nlogn) ==> sort\n2. Space:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191079803","body":"### Algo\n1. find the Length of list\n2. find the newHead\n### Code\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        \n        ListNode tail = head;\n        int listLen = 1;\n        while (tail.next != null) {\n            tail = tail.next;\n            listLen++;\n        }\n        \n        int rotation = k % listLen;\n        if (rotation == 0) {\n            return head;\n        }\n        \n        // newHead move [len - rotate] steps , newHeadPrev = [len-rotation-1]\n        ListNode newHead = head, newHeadPrev = head;\n        for (int i = 0; i < listLen - rotation - 1; i++) {\n            newHeadPrev = newHeadPrev.next;\n        }\n        newHead = newHeadPrev.next;\n        \n        tail.next = head;\n        newHeadPrev.next = null;\n        head = newHead;\n        \n        return head;\n    }\n}\n```\n### Complexity\n1. Time: O(N)\n2. Space: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsmmxmm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185165999","body":"# 基本信息\n\n## 题号&链接\n\n****[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)****\n\n## 截图题面\n\n整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n\n例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= num.length <= Math.pow(10,4)`\n\n所以直接转换成integer不太行\n\n- 全都是正整数，不用考虑符号\n\n## **M-atch**\n\n从最后一位开始，一位一位加减，放进list里，然后reverse\n\n## 复杂度\n\n一次遍历 时间O(n)\n\n除结果外没有新增空间，这算O(n)?\n\n# Code\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        // int sum = 0;\n        // for(int i = 0; i < num.length; i++){\n        //     sum = sum * 10 + num[i];\n        // }\n        // sum += k;\n        // \n        // while(sum != 0){\n        //     res.add(sum % 10);\n        //     sum /= 10;\n        // }\n        // Collections.reverse(res);\n        // return res;\n\n        int pointer = num.length - 1;\n        int left = 0;\n        \n        while(pointer >= 0){\n            int temp = num[pointer] + k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n            pointer--;\n            \n        }\n        while(k > 0){\n            int temp =  k % 10 + left;\n            left = temp / 10;\n            temp = temp % 10;\n            res.add(temp);\n            k /= 10;\n        }\n        if (left == 1){\n            res.add(left);\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186036688","body":"# 基本信息\n\n## 题号&链接\n\n****[821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)****\n\n## 截图题面\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n# UMPIRE\n\n## **U-nderstand**\n\n- `1 <= s.length <= 104`\n- `s[i]` 和 `c` 均为小写英文字母\n- 题目数据保证 `c` 在 `s` 中至少出现一次\n\n## **M-atch**\n\n滑动窗口\n\n大while：右指针移动：\n\n小while：左指针不满足条件时移动→没和right相等时候：计算最短距离（区分targetChar在前面还是在后面，取最小值）left++，\n\n此时right == left，判断要不要更新preTarget，right++\n\n## **P-lan**\n\n补丁：right已经走完了，left没有：left补全\n\n## 复杂度\n\n时间：2次遍历 O(n)\n\n空间：除结果数组外常数级别新增：O(1)?\n\n# Code\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int right = 0, left = 0;\n        int preTarget = -10000;\n        int max = 10000;\n        char[] sc = s.toCharArray();\n        while (left <= right && left < res.length && right < res.length){\n            res[right] = max;\n            while(sc[right] == c && left < right){\n                res[left] = Math.min(right - left, left - preTarget);\n                left++;\n            }\n            if(sc[right] == c) {\n                res[right] = 0;\n                preTarget = right;\n            }\n                right ++;\n        }\n        while(left < res.length){\n            res[left] = left - preTarget;\n            left++;\n        }\n        return res;\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186367229","body":"# 基本信息\n\n## 题号&链接\n\n****[1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)****\n\n## 截图题面\n\n```\n\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n```\n\n# UMPIRE\n\n## **M-atch**\n\n尴尬了，脑子里想着的是用栈做队列或者用队列做栈。\n\n写完看了题解发现可以用数组。\n\n## **P-lan**\n\n```java\nthis.maxSize = maxSize;\n这里我写错了一次\n```\n\n## 复杂度\n\n时间不会写\n\n空间O(maxSize)?\n\n# Code\n\n```java\nclass CustomStack {\n    Deque<Integer> deq;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        deq = new ArrayDeque<Integer>();\n        this.maxSize = maxSize;\n\n    }\n    \n    public void push(int x) {\n        //System.out.println(\"deq.size()=:\"+deq.size()+\";maxSize=:\"+maxSize);\n        if(deq.size() < maxSize) {\n            deq.addLast(x);\n        }\n    }\n    \n    public int pop() {\n        if(!deq.isEmpty()){\n            return deq.pollLast();\n        }else{\n            return -1;\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        Deque<Integer> temp = new ArrayDeque<>();\n        int count = 0;\n        if(deq.size() <= k){\n            while(count < deq.size()){\n                deq.addFirst(deq.pollLast() + val);\n                count++;\n            }\n        }else{\n            while(count < k){\n                temp.addLast(deq.pollFirst() + val);\n                count++;\n            }\n            while(count > 0){\n                deq.addFirst(temp.pollLast());\n                count--;\n            }\n        }\n    }\n}\n```\n\na","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186683643","body":"# 基本信息\n\n## 题号&链接\n\n****[394. 字符串解码](https://leetcode.cn/problems/decode-string/)****\n\n## 截图题面\n\n```java\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n• `s` 中所有整数的取值范围为 `[1, 300]`\n\n有可能不是一位数\n\n## **M-atch**\n\n放到栈里，遇到‘]’的话，往前找 ‘[’ 和 k，找到后重复k次，并放回栈内（以防止 [] 嵌套）\n\n## 复杂度\n\n空间算O(n)\n\n时间摆烂不会算 O(n^2)?\n\n# Code\n\n做了好久哦，以及写的好麻烦，运行的好慢哦。\n\n我要看看题解\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        \n        if(s.length() <= 3) return s;\n        \n        int i = 0;\n        char[] c = s.toCharArray();\n        StringBuffer sb = new StringBuffer();\n        Deque<Character> deque = new ArrayDeque<>();\n        \n\n        while(i < c.length){\n         \n            if(c[i] == ']'){\n                int k = 0;\n                char temp = deque.pollLast();\n                StringBuffer sbTemp = new StringBuffer();\n                while (temp != '['){\n                    sbTemp.append(temp);\n                    temp = deque.pollLast();\n                }\n                char tempk = deque.peekLast();\n                int count = 0;\n                while(tempk - '0' <= 9 && tempk - '0' >= 0 && !deque.isEmpty()){\n                    k += Math.pow(10,count) * ( deque.pollLast() - '0');\n                    //System.out.println(\"k=:\"+k+\";tempk=:\"+tempk);\n                    if (!deque.isEmpty()) {\n                        tempk = deque.peekLast();\n                        count++;\n                    }\n                    \n                }\n                sbTemp.reverse();\n                char[] sbChar = sbTemp.toString().toCharArray();\n                while(k > 0){\n                    //System.out.println(\"sbTemp=:\"+sbTemp.toString()+\";deque=:\"+deque.toString());\n                    for(char cT: sbChar){\n                        deque.addLast(cT);\n                    }\n                    k--;\n                }\n\n            }else{\n                deque.addLast(c[i]);\n            }\n            i++;\n            \n        }\n        while(!deque.isEmpty()){\n            sb.append(deque.pollFirst());\n        }\n        return sb.toString();\n\n    }\n}\n```\n\n害","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189027369","body":"****[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)****\n\n5/10： 虽然是easy题，但是我不会写\n\n7/19 ：感受到自己的进步了，写出来了！虽然stack的函数不是很熟练。\n\n```java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n\n    public MyQueue() {\n        s1 = new Stack<Integer>();\n        s2 = new Stack<Integer>();\n\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.push(s1.pop());\n            }\n\n        }\n        return s2.pop();\n        \n\n    }\n    \n    public int peek() {\n        if(!s2.isEmpty() ){\n            \n        }else{\n            while(!s1.isEmpty()){\n                s2.add(s1.pop());\n            }\n\n        }\n        return s2.peek();\n\n    }\n    \n    public boolean empty() {\n        return s2.isEmpty() && s1.isEmpty();\n\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n****[2](https://leetcode.cn/problems/implement-stack-using-queues/)****","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189900290","body":"# 基本信息\n\n## 题号&链接\n\n****[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)****\n\n## 截图题面\n\n```java\narr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。\n\n我们最多能将数组分成多少块？\n\n示例 1:\n\n输入: arr = [5,4,3,2,1]\n输出: 1\n解释:\n将数组分成2块或者更多块，都无法得到所需的结果。\n例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。 \n示例 2:\n\n输入: arr = [2,1,3,4,4]\n输出: 4\n解释:\n我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。\n然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。 \n\n来源：力扣（LeetCode）\n链接：https://leetcode.cn/problems/max-chunks-to-make-sorted-ii\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\n单调栈，需要整体递增的\n\n如果：arr[deq.peekLast()] <= arr[i]，i入栈\n\n否则，弹出栈顶元素，“直到栈为空或者栈顶元素小于当前元素。之后我们还需要将分块的代表元素重新压入栈，也就是需要记录弹出元素中最大的那一个。最后记录栈长度，就是结果“\n\n”“部分参考了以下链接，没想出来。\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/](https://leetcode.cn/problems/max-chunks-to-make-sorted/solution/zui-duo-neng-wan-cheng-pai-xu-de-kuai-by-d1nt/)\n\n## 复杂度\n\n时间：O(n)：一次遍历\n\n空间：O(n)：新增了一个栈，最多放n个元素\n\n# Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 1;\n        while(arr.length == 1)  return 1;\n        int i = 1;\n        int cur = arr[0];\n        Deque<Integer> deq = new ArrayDeque<>();\n        deq.addLast(0);\n        while(i < arr.length){\n            if(arr[deq.peekLast()] <= arr[i]){\n                deq.addLast(i);\n                i++;\n            }else{\n                int max = i;\n                while(!deq.isEmpty() && arr[i] < arr[deq.peekLast()]){\n                    max = arr[max] > arr[deq.peekLast()]? max: deq.peekLast();\n                    deq.pollLast();\n                }\n                deq.addLast(max);\n                i++;\n            }\n            //System.out.println(\"deq=:\"+deq.toString());\n        }\n        return deq.size();\n    }\n}\n```\n\n写的比较麻烦，可以再精简精简。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190983172","body":"# 基本信息\n\n## 题号&链接\n\n****[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)****\n\n## 截图题面\n\n```java\n给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\n```\n\n# UMPIRE\n\n## **U-nderstand**\n\n## **M-atch**\n\n想考我链表，想得美嘿嘿嘿\n\n放到数组里然后旋转三次\n\n## **P-lan**\n\n## 复杂度\n\n时间：O(n) 多次遍历\n\n空间：O(n) 新增一个数组\n\n# Code\n\n```java\npublic ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return head;\n        ListNode dummy = new ListNode(-1 , head);\n        int length = 0;\n        ListNode cur = dummy;\n        while(cur.next != null){\n            cur = cur.next;\n            length++;\n            \n        }\n\n        k = k % length;\n        //System.out.println(\"length=:\"+length);\n\n        int[] arr = new int[length];\n        cur = dummy.next;\n        for(int i = 0; i < arr.length; i++){\n            arr[i] = cur.val;\n            if(cur != null) cur = cur.next;\n        }\n\n        reverse(arr, 0, length - 1);\n        reverse(arr, 0, k - 1);\n        reverse(arr, k, length - 1);\n        cur = dummy.next;\n\n        for(int i = 0; i < arr.length; i++){\n            cur.val = arr[i];\n            cur = cur.next;\n        }\n\n        return dummy.next;\n\n    }\n    public void reverse(int[] arr, int start, int end){\n        for(int i = start; i <= (start + end  - 1)/ 2; i++){\n            int temp = arr[i];\n            //System.out.println(\"i=:\"+i+\";k - i=:\"+(k - i));\n            arr[i] = arr[end - i + start];\n            arr[end - i + start] = temp;\n        }\n    }\n```\n\n其实想直接旋转链表来着，没写出来。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fan-svg":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185167863","body":"### 思路\n从最低位进行相加，大于10则向前一位加一\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        int sum = 0;\n\n        for(int i = n - 1; i >= 0; --i){\n            sum = num[i] + k % 10;\n            k /= 10;\n            if(sum>=10){\n                ++k;\n            }\n            res.push_back(sum%10);\n        }\n        while(k>0){\n            res.push_back(k%10);\n            k /= 10;\n        }\n\n        reverse(res.begin(),res.end());\n\n        return res;\n    }\n};\n```\n### 复杂度\n时间复杂度：O(max(n,log k))，最大不会超过O(n)\n\n空间复杂度：O(1)。使用的空间为常数\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186204571","body":"### 思路\n先从左往右遍历一遍字符串，记录与目标字符之间距离结果，再从右往左遍历一遍字符串，此时与目标字符之间距离结果需与从左往右的结果进行比较，选择较小的结果的为最终结果\n### 代码\n``` C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> res(n);\n        int pos = INT_MIN/2;\n        for(int i = 0; i < n; i++){\n            if(s[i]==c){\n                pos = i;\n            }\n            res[i] = i - pos;\n        }\n        pos = INT_MAX/2;\n        for(int i = n - 1; i >= 0; i--){\n            if(s[i] == c){\n                pos = i;\n            }\n            res[i] = min(res[i],pos - i);\n        }\n\n        return res;\n    }\n};\n```\n### 复杂度\n##### 时间复杂度：O(n),n为字符串长度\n##### 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186537641","body":"### 思路\n用vector数组来模拟栈，通过top值来表示表示当前栈顶位置。对应的函数操作根据栈的相关操作来实施。\n### 代码\n``` C++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != stack.size() - 1){\n            top++;\n            stack[top] = x;\n        }\n        \n        \n    }\n    \n    int pop() {\n        if(top == -1)\n            return -1;\n        top--;\n        return stack[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int len = min(k,top+1);\n        for(int i = 0; i < len; i++){\n            stack[i] += val;\n        }\n    }\nprivate:\n    vector<int> stack;\n    int top;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuzejia":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185168321","body":"## 思路\n\n+ 一开始想的 数组转化数学位数进行相加  A[i] * Math.pow(10, A.length - i - 1) 结果会出现计算不准确\n+ 采用 两数组从尾部开始相加。 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\n\n## 题解\n```\n// 采用 两数组 对应位数相加 大于 10 进一位; 最后一位相加 大于10 数组尾部 补 1；\nfunction addToArrayForm(A: number[], K: number): number[] { \n    let list = (K+'').split('')\n    let len_A = A.length - 1;\n    let len_K = list.length - 1;\n    let result = <any>[];\n    let n = 0\n    \n    // 两数组存在值 继续执行\n    while (A[len_A] >= 0  || Number(list[len_K]) >= 0) {\n\n        // 位数之和\n        let sum = Number(list[len_K] || 0) + ( A[len_A]?A[len_A] : 0 ) + n;\n\n        // 重置 n\n        n = 0\n        // 位数之和 是否 大于 10\n        if(sum >= 10) n = 1;\n\n        // 余数添加进去\n        result.push(sum%10);\n\n        // 递减\n        len_K--\n        len_A--\n    }\n\n    // 处理最后一位结果 大于 10 \n    if(n === 1) {\n        result.push(1);\n    }\n    \n\n    return result.reverse();\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212500","body":"## 思路\n左右遍历 取最小值\n## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n  const n = s.length;\n  const result: number[] = [];\n  let ids = s.indexOf(c);\n\n  for (let i = 0; i < s.length; i++) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.abs(ids - i);\n  }\n\n  ids = s.lastIndexOf(c);\n\n  for (let i = n - 1; i >= 0; i--) {\n    if (s[i] === c) {\n      ids = i;\n    }\n    result[i] = Math.min(result[i], Math.abs(ids - i));\n  }\n\n  return result;\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186379692","body":"## 思路\n使用数组模拟栈\n## 代码\n```\nclass CustomStack {\n  private _stack: number[] = []; // 栈\n  private _stackSize = -1; // 栈最大长度\n  constructor(maxSize: number) {\n    this._stackSize = maxSize;\n  }\n\n  push(x: number): void {\n    // 不能超过栈最大长度\n    if (this._stack.length === this._stackSize) return;\n    this._stack[this._stack.length] = x;\n  }\n\n  pop(): number {\n    // 栈空返回 -1\n    return this._stack.length === 0 ? -1 : this._stack.pop()!;\n  }\n\n  increment(k: number, val: number): void {\n    for (let i = 0; i < k; i++) {\n      this._stack[i] ? (this._stack[i] += val) : null;\n    }\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622983","body":"## 思路\n利用栈进行操作\n\n如果是字符数字获取相连数字值\n\n如果是字符 进行拼接字符\n\n将数字值和字符串进行数组存储\n\n遇到 [ 时进行入栈\n\n遇到 ] 时进行出栈，出栈的时候 通过repeat方法进行复制 拼接\n\n## 代码\n```typescript\nfunction decodeString(s: string) {\n  let stack: Array<[number, string]> = [];\n\n  // 入栈\n  function add(k: [number, string]) {\n    stack.push(k);\n  }\n\n  function pop(): [number, string] {\n    return stack.pop() ?? [0, \"\"];\n  }\n\n  let str: string = \"\";\n  let l: [number, string] = [0, \"\"];\n  for (let i = 0; i < s.length; i++) {\n    const e = s[i];\n\n    // 如果是数字 进行数组计算\n    if (!isNaN(Number(e.toString()))) {\n      l[0] = l[0] * 10 + Number(e);\n    } else if (e === \"[\") {\n      l[1] = str;\n      add(l);\n\n      l = [0, \"\"];\n      str = \"\";\n    } else if (e === \"]\") {\n      let p: [number, string] = pop();\n\n      // str 拿到的是 最后一个 [] 内的值\n      str = p[1] + str.repeat(p[0]);\n    } else {\n      str += e;\n    }\n  }\n\n  return str;\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189116410","body":"## 思路\n采用两个栈 stack_1 和 stack_2\n\npush 的时候都压入 stack_1 栈\n\n出栈的时候 先把 stack_1 中的数据 入栈到 stack_2 中 这样队列的第一个元素 就在 stack_2 栈顶\n\n当 stack_2 中存在值 栈顶 永远是 队列的开头\n\n当 stack_1 和 stack_2 都为空的时候 表示 队列为空\n```typeScript\nclass MyQueue {\n  // 栈的特点 先进后出\n  stack_1: number[] = [];\n  stack_2: number[] = [];\n  constructor() {}\n\n  push(x: number): void {\n    this.stack_1.push(x);\n  }\n\n  // 从队列的开头移除并返回元素\n  pop(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2.pop()!;\n  }\n\n  // 返回队列开头的元素\n  peek(): number {\n    if (this.stack_2.length === 0) {\n      while (this.stack_1.length > 0) {\n        this.stack_2.push(this.stack_1.pop()!);\n      }\n    }\n    return this.stack_2[this.stack_2.length - 1];\n  }\n\n  // 判断队列是否为空\n  empty(): boolean {\n    return !this.stack_1.length && !this.stack_2.length ? true : false;\n  }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463079","body":"## 思路 \n没解出来\n看到 单调栈 和 滑动窗口 研究了下 真奇妙\n\n## 代码\n单调栈\n```typeScript\nfunction maxChunksToSorted(arr: number[]): number {\n  let stack: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    const e = arr[i];\n    if (stack && stack[stack.length - 1] > e) {\n      let cru = stack[stack.length - 1];\n      while (stack && stack[stack.length - 1] > e) {\n        stack.pop();\n      }\n      stack.push(cru);\n    } else {\n      stack.push(e);\n    }\n  }\n  return stack.length;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170165","body":"#### 代码 \n\n```Python\n\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i=len(num)-1\n        while k>0:\n            added = num[i]+k\n            num[i]=added%10  # remainder\n            k=added//10    # carry\n            i-=1\n            if i<0 and k>0:\n                num.insert(0,0)\n                i=0\n        return num\n```\n\n#### 复杂度分析\n时间复杂度： O(N)  </br>\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052450","body":"### 思路 \n从左至右遍历s， 得到左边最近c的距离\n从右至左遍历s， 得到右边最近c的距离与左边最近c的距离的较小值\n#### 代码 Python\n\n```Python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        #time O(N) space O(N)\n        res=[float('inf')]*len(s)\n        last_c = float('inf')\n        for i in range(len(s)):\n            if s[i]==c:\n                last_c=i\n            res[i]=abs(last_c-i)\n        \n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                last_c=i\n            res[i]=min(res[i],abs(last_c-i))\n        return res\n\n\n```\n\n#### 复杂度分析\n时间复杂度：O(N)    </br>\n空间复杂度：O(N)\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188597906","body":"#### 代码 Python\n\n```Python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            \n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n           \n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        if self.stack1 or self.stack2:\n            return False\n        else:\n            return True\n\n```\n\n#### 复杂度分析\n时间复杂度： O(N) </br>\n空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phoenixflyingsky":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170186","body":"### Idea\n\njust add the end of two numbers\n\n### Code\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int len = num.length;\n        int carry = 0;\n        int index = len - 1;\n\n        while(index >= 0 && k > 0) {\n            int temp = k % 10;\n            int total = temp + num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n            k = k / 10;\n        }\n\n        while(index >= 0) {\n            int total = num[index] + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            index--;\n        }\n\n        while(k > 0) {\n            int total = k % 10 + carry;\n\n            //update\n            carry = total / 10;\n            total = total % 10;\n\n            //put the num to res\n            res.add(0, total);\n\n            //update\n            k = k / 10;\n        }\n\n        if(carry != 0) {\n            res.add(0, carry);\n        }\n\n        return res;\n\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N), N is the longest of the two lengths（num.length & k.length()）\n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186150582","body":"### Idea\r\n- First loop: traverse from left to right to find the nearest c on the left.\r\n- Second loop:  traverse from right to left to find the nearest c on the right.\r\n### Code\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len = s.length();\r\n        int[] res = new int[len]; \r\n\r\n        int minNum = Integer.MIN_VALUE / 2; //make sure the num is smaller enough\r\n        int pre = minNum; //the distance of the nearest C on the left\r\n        for(int i = 0; i < len; i++) {\r\n            if(s.charAt(i) == c) {\r\n                pre = i;\r\n            }\r\n\r\n            res[i] = i - pre;//make sure the distance of nearest C on the left\r\n        }\r\n\r\n        int maxNum = Integer.MAX_VALUE / 2; //make sure the num is larger enough\r\n        int later = maxNum; // the distance of the nearest C on the right\r\n        for(int i = len - 1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                later = i;\r\n            }\r\n\r\n            res[i] = Math.min(res[i], (later - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**Complexity Analysis**\r\n- Time Complexity： O(N) \r\n- Space Complexity： O(1) (  The return value is not included in the space complexity.  )\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513643","body":"### Idea\n\nbuild an array(int[] stack) to save the data, and then build an array(int[] auxiliaryAdd) to save the increments\n\n### Code\n\n\n```java\nclass CustomStack {\n    int[] stack;//store data\n    int[] auxiliaryAdd; // the auxiliary array to store the increments\n    int len;// the length about this stack\n    int top = -1;// the num in the stack\n\n    public CustomStack(int maxSize) {\n        this.len = maxSize;\n        this.stack = new int[this.len];\n        this.auxiliaryAdd = new int[this.len];\n    }\n    \n    public void push(int x) {\n        if(this.top < (this.len - 1)) {\n            this.top++;\n            this.stack[this.top] = x;         \n        }\n    }\n    \n    public int pop() {\n        if(this.top < 0) {\n            return -1;\n        }\n\n        int temp = this.stack[this.top] + this.auxiliaryAdd[this.top];\n\n        if(this.top > 0) {\n            this.auxiliaryAdd[this.top - 1] += this.auxiliaryAdd[this.top]; //superimpose the previous increase\n        }\n\n        auxiliaryAdd[top] = 0; // we need to initialize this auxiliaryAdd[top] !!!!!!\n \n        this.top--;\n\n        return temp;\n    }\n    \n    public void increment(int k, int val) {\n        if(this.top == -1) {\n            return;// this means if the stack has none num, we do not need to do anything\n        }\n\n\n        int temp = Math.min(k - 1, this.top);\n\n        auxiliaryAdd[temp] += val;// this step is superimpose,  not just auxiliaryAdd[temp] = val; !!!\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(1)  (just get the num from the array)\n- Space Complexity： O(N) (cause we build two arrays to save data and increment)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187191289","body":"### Idea\nUse stack to simulate this process\n\n\n\n### Code\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<Integer> numStack = new ArrayDeque<>();//save the times\n        Deque<String> strStack = new LinkedList<>();//save the string\n        StringBuilder tail = new StringBuilder();//recode the string\n        \n        int len = s.length();\n        for(int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n\n            if(Character.isDigit(c)) {\n                //Character.isDigit(c) means if the c is num \n                int num = c - '0';\n                while(i + 1 < len && Character.isDigit(s.charAt(i + 1))) {\n                    //the num may do not just single\n                    num = num * 10 + s.charAt(i + 1) - '0';\n                    i++;\n                }    \n                numStack.push(num);          \n            }\n\n            else if(c == '[') {\n                //push the contents of tail to strStack\n                strStack.push(tail.toString());\n                tail = new StringBuilder();\n            }\n\n            else if(c == ']') {\n                //cause the things in brackets are saved in the tail \n                //times are saved in the numStack\n                //strStack contains string between two left brackets('[')\n\n                StringBuilder temp = new StringBuilder();\n                temp.append(strStack.pop());\n\n                int times = numStack.pop();\n                for(int j = 0; j < times; j++) {\n                    temp.append(tail);\n                }\n\n                tail = temp;\n            }\n\n            else {\n                tail.append(c);\n            }\n\n            //i++; \n            //we do not need i++, cause : for(int i = 0; i < len; i++)\n        }\n\n        return tail.toString();\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188797393","body":"### Idea\nUse two stacks to simulate this process\n\n\n\n### Code\n\n\n```java\n\nclass MyQueue {\n    Deque<Integer> inPut;\n    Deque<Integer> outPut;\n\n    public MyQueue() {\n        inPut = new ArrayDeque<>();\n        outPut = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        inPut.push(x);\n    }\n    \n    public int pop() {  \n        if(outPut != null && !outPut.isEmpty()) {\n            return outPut.pop();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());           \n        }\n\n        return outPut.pop();  \n    }\n        \n    public int peek() {\n         if(outPut != null && !outPut.isEmpty()) {\n            return outPut.peek();\n        }\n\n        while(inPut != null && !inPut.isEmpty()) {\n            outPut.push(inPut.pop());      \n        }\n\n        return outPut.peek();  \n    }\n    \n    public boolean empty() {\n        return (outPut.isEmpty() && inPut.isEmpty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190303585","body":"### Idea\nUsing monotonic incremental stack\n\n\n\n### Code\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for(int num : arr) {\n            int temp = Integer.MIN_VALUE;\n\n            while(!stack.isEmpty() && stack.peek() > num) {\n                //this means the num is smaller than the stack.peek(), so we need to merge them into one\n                //Because it is monotonically increasing, the first pop-up must be the largest, so we only need to record the value of the first pop-up\n                temp = Math.max(temp, stack.pop());\n            }\n\n            if(temp == Integer.MIN_VALUE) {\n                stack.push(num);//Num does not need to be merged with the previous block, so it is pushed into the stack\n            }\n            else {\n                stack.push(temp);\n            }\n        }\n\n        return stack.size();\n    }\n}\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191351567","body":"### Idea\nFirstly, calculate the point to be truncated: k%len.   \nThen cut it directly and connect the head to the tail (note that when k = = len, the head should be returned directly).\n\n\n\n### Code\n\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        //corner case\n        if(head == null || head.next == null || k == 0) {\n            return head;\n        }\n\n        int len = 0;// the length of head\n\n        ListNode dummy = new ListNode();\n        dummy.next = head;\n\n        ListNode last = dummy;\n\n        while(last.next != null) {\n            len++;\n            last = last.next;\n        }\n\n        int cut = len - k % len;\n\n        if(cut == len) {\n            return head;//pay attention: cause if cut == len ,  ListNode res = pre.next;(pre.next == null), and we will return null, so we need to return head if cut == len\n        } \n\n        ListNode pre = dummy;\n\n        for(int i = 0; i < cut; i++) {\n            pre = pre.next;\n        }\n\n        ListNode res = pre.next;\n        pre.next = null;\n        last.next = head;\n\n        return res;\n    }\n}\n\n\n```\n\n**Complexity Analysis**\n- Time Complexity： O(N) \n- Space Complexity： O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nehchsuy":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185170845","body":"### 思路\r\n先同时加array和数字\r\n再while loop 只剩下数字或者只剩下数组的情况\r\n\r\n### 代码:\r\n\r\n\r\n\r\n          class Solution:\r\n                  def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n                       def add(index, k, num):\r\n                           carry = 0\r\n                          while index >= 0 and k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num[index] = num[index] + current + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          while index >= 0 and carry:\r\n                              num[index] = num[index] + carry\r\n                              carry = 0\r\n                              if num[index] >= 10:\r\n                                  num[index] -= 10\r\n                                  carry = 1\r\n                              index -= 1\r\n                          \r\n                          k += carry\r\n                          while k:\r\n                              current = k % 10\r\n                              k = k // 10\r\n                              num = [current] + num\r\n                          return num\r\n                              \r\n                      \r\n                     return add(len(num) - 1, k, num)\r\n\r\n### 复杂度:\r\nTime: O(length of number + length of array) or O(N)\r\nSpace: O(length of number + length of array) or O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186082185","body":"### 思路\r\n\r\n先看最左最右是不是和c一样, 是一样设为0\r\n然后左往右, 右往左各遍历一次取上一个数 + 1和本数的最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float('inf') for char in s]\r\n        \r\n        if s[0] == c:\r\n            ans[0] = 0\r\n        if s[-1] == c:\r\n            ans[-1] = 0\r\n        \r\n        for i in range(1, len(s)):\r\n            if s[i] == c:\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = min(ans[i - 1] + 1, ans[i])\r\n                \r\n        for j in range(len(s) - 2, -1, -1):\r\n            if s[j] == c:\r\n                ans[j] = 0\r\n            else:\r\n                ans[j] = min(ans[j + 1] + 1, ans[j])\r\n        \r\n        return ans\r\n```\r\n### 复杂度\r\n时间复杂度 O(2 * 数组size) = O(n)\r\n空间复杂度 答案size O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186278497","body":"### 思路\n\n正常stack操作, 动态数组更新val\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.nums = []\n        self.size = 0\n        self.limit = maxSize\n\n    def push(self, x: int) -> None:\n        if self.size >= self.limit:\n            return\n        self.nums.append(x)\n        self.size += 1\n        return\n\n    def pop(self) -> int:\n        if not self.nums:\n            return -1\n        num = self.nums.pop()\n        self.size -= 1\n        return num\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.nums[i] += val\n        return\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### 复杂度分析\n\n时间复杂度: push / pull O(1), 改变增量 O(n)\n\n空间复杂度: O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186707653","body":"### 思路:\r\n\r\n不使用dfs一遍遍历\r\n两个栈, 一个压入乘数, 一个压入字符串\r\n\r\n预处理 给字符串两边加上\"[\" 和 \"]\"\r\n设原乘数为1\r\n\r\n遇到\"[\" 数字入栈, 乘数重新设为0, 将\"[\" 作为字符串mark压入字符栈\r\n遇到 lowercase字母, 如果是第一个字母, 创造新字符串, 不然更新最近字符串\r\n遇到乘数, 更新乘数\r\n遇到 \"]\" 把所有 前一个 \"[\"之前的字符串合并 (字符串出栈) x 最近的乘数 (乘数出栈) 再重新压入字符串栈中\r\n\r\n最后乘数栈为空, 字符串栈中唯一一个元素就是答案\r\n\r\n### 代码\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        strs = []\r\n        nums = []\r\n        \r\n        num = 1\r\n        s = \"[\" + s + \"]\"\r\n        \r\n        for char in s:\r\n            if char == \"[\":\r\n                strs.append(\"[\")\r\n                nums.append(num)\r\n                num = 0\r\n            elif char in \"0123456789\":\r\n                num = num * 10 + int(char)\r\n            elif char in \"abcdefghijklmnopqrstuvwxyz\":\r\n                if strs[-1] == \"[\":\r\n                    strs.append(char)\r\n                else:\r\n                    strs[-1] = strs[-1] + char\r\n            else:\r\n                temp = \"\"\r\n                while strs[-1] != \"[\":\r\n                    temp = strs[-1] + temp\r\n                    strs.pop()\r\n                times = nums.pop()\r\n                strs.pop()\r\n                strs.append(temp * times)\r\n                \r\n        return strs[-1]\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度: O(n) n 为字符串内所有元素个数\r\n空间复杂度: O(n) n 为字符串内所有元素个数\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188599398","body":"### 思路:\n\n用两个栈, 输入用一个栈, 输出用一个栈\n只有输出栈空的时候吧输入栈的数据dump 进输出栈\n\n### 代码\n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n    \n    def peek(self) -> int:\n        if self.stack2:\n            num = self.stack2.pop()\n            self.stack2.append(num)\n            return num\n        \n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n            \n        num = self.stack2.pop()\n        self.stack2.append(num)\n        return num\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n\n```\n\n### 复杂度:\n时间 O(n)\n空间 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189805698","body":"### 思路:\r\n\r\n一个chunk的定义就是往右边数的最小值, 然后比所有左边的值都大...以此为概念两个数组求最大最小.\r\n没有用到单调栈?\r\n\r\n### 代码:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        maxarr = []\r\n        minarr = []\r\n        \r\n        maxnum = float('-inf')\r\n        minnum = float('inf')\r\n        \r\n        for num in arr:\r\n            maxnum = max(num, maxnum)\r\n            maxarr.append(maxnum)\r\n            \r\n        for i in range(len(arr) - 1, -1, -1):\r\n            num = arr[i]\r\n            minnum = min(num, minnum)\r\n            minarr.append(minnum)\r\n            \r\n        minarr = minarr[::-1]\r\n            \r\n        ans = 1\r\n        for i in range(1, len(minarr)):\r\n            if minarr[i] >= maxarr[i - 1]:\r\n                ans += 1\r\n        \r\n        return ans\r\n\r\n```\r\n### 复杂度:\r\n\r\n时间 O(n)\r\n空间 O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191030424","body":"### 思路:\n\n先找到链表size, 再化简k\n然后找到链表最后的尾\n然后再从头开始头一个个接到尾上\n\n### 代码\n\n```python\n\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head: return head\n        size = 0\n        mark = head\n        \n        while mark:\n            size += 1\n            mark = mark.next\n        \n        k = k % size\n        \n        if k == 0:\n            return head\n        \n        move = size - k\n        \n        last = head\n        \n        while last.next:\n            last = last.next\n        \n        mark = head\n        \n        for _ in range(move):\n            newmark = mark.next\n            mark.next = None\n            last.next = mark\n            last = mark\n            mark = newmark\n        \n        return newmark\n\n\n```\n\n### 复杂度:\n\n空间: O(1)\n时间: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzyxts":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185188366","body":"### Idea\n\n从后往前加，while loop中更新list&integer\n\n### Code\n\n\n```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        digit = 0\n        \n        while num or k or digit:\n            n1 = num[-1] if num else 0\n            n2 = k%10\n\n            n = n1+n2+digit\n            \n            res.insert(0, n%10)\n            digit = 1 if n>= 10 else 0\n            \n            num = num[:-1]\n            k = k//10\n                \n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185975634","body":"### Idea\n\n- 找出 `==c` 的所有index positions, store in `pos`\n- j 表示 在s中的current index\n- i，k表示在`pos`中，相邻于j的index\n\n### Code\n\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        \n        i,j,k = 0,0,0\n        \n        while j < len(s):\n            if i == len(pos):\n                res.append(abs(pos[i-1]-j))\n                j+=1\n                \n            elif j <= pos[i]:\n                a = abs(pos[i]-j)\n                b = abs(pos[k]-j)\n                res.append(min(a,b))\n                j += 1\n                \n            else:\n                if i != 0:\n                    k+=1\n                i+=1\n\n        return res\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N) as `res` will extend?","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186440842","body":"\n### Idea\n\n按照示例的情况写\n\n### Code\n\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.list = []\n        \n\n    def push(self, x: int) -> None:\n        if len(self.list) < self.maxSize:\n            self.list.append(x)\n\n    def pop(self) -> int:\n        if not self.list:\n            return -1\n        else:\n            num = self.list[-1]\n            self.list = self.list[:-1]\n\n            return num\n        \n\n    def increment(self, k: int, val: int) -> None:\n        if k >= len(self.list):\n            k = len(self.list)\n        for i in range(k):\n            self.list[i] += val\n        \n```\n\n### Complexity\n- Time：push ：O(1)，pop：O(1)，increment：O(k)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186739082","body":"\n### Idea\n\n- 从s的第一位读起，根据读到的char进行不同操作：\n* 如果碰到数字则记录次数，如果碰到字母则记下并移到下一位，如果 `==[` 则记录读过的string和次数放进stack，如果 `==]` 则stack.pop() 补充一次[]的完整string\n- 当  \\[ \\] 次数相同时，一个完整的string已经完成，加进res中\n\n### Code\n\n```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        res = ''\n        l= 0\n        stack = []\n        cur = ''\n        i = 0\n        freq = 0\n        \n        while i < len(s):\n            if s[i] == '[':\n                l += 1\n                stack.append([cur,freq])\n                cur = ''\n                freq = 0\n                i+=1\n            elif s[i].isdigit():\n                while s[i].isdigit():\n                    freq = freq*10+int(s[i])\n                    i+=1\n            elif s[i] == ']':\n                l -=1\n                pre, num = stack.pop()\n                cur = pre + cur*num\n                if l == 0:\n                    res += cur\n                    cur = ''\n                i+=1\n                \n            elif s[i].isalpha():\n                cur += s[i]\n                i+=1\n            \n        return res+cur\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188169392","body":"### Idea\n\n- s1记录push进queue的数值\n- s2记录queue的头部信息\n- 当要调取queue头部信息时将s1的内容pop出来，push进s2中，当s2中无数据的时候再从s1中pop保留顺序\n\n### Code\n\n```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n        \n\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n        \n\n    def pop(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2.pop()\n        \n        \n    def peek(self) -> int:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            \n        return self.s2[-1]\n        \n        \n    def empty(self) -> bool:\n        return not (self.s1 or self.s2)\n\n```\n\n### Complexity\n- Time：push() & empty(): O(1), pop() & peek(): O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189508899","body":"### Idea\n\n- 单调栈stack储存一个单调递增的array，用于记录每一个chunk的最大值，最后return len(stack)\n- 遍历arr， 如果`>= 前一位` 则放进stack，表示可以作为一个单独的chunk，else则pop stack中的数直到满足单调栈的条件，此刻放入第一次pop的值进stack代表这个chunk的最大值\n\n### Code\n\n```python3\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        last = -1\n        \n        for num in arr:\n            while stack and stack[-1] > num:\n                last = max(stack.pop(), last)\n                \n            stack.append(max(num, last))\n                \n        return len(stack)\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190861320","body":"### Idea\n- 遍历list，记录list长度 `n` 以及 tail node `e1`\n- `tail.next = head` 连接list首尾\n- 计算break node `e2` where `e2.next` is the new head node\n\n### Code\n\n\n```python3\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if not head:\n            return head\n        dummy = ListNode(0)\n        dummy.next = head \n        \n        # length of the list\n        n = 0\n        e1 = dummy\n        while e1.next:\n            e1 = e1.next\n            n += 1\n            \n        e1.next = head\n        jumps = n - k%n\n        \n        # Find the break point\n        e2 = dummy\n        \n        for i in range(jumps):\n            e2 = e2.next\n\n        dummy.next = e2.next\n        e2.next = None\n        \n        return dummy.next\n\n```\n\n### Complexity\n- Time：O(N)\n- Space：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elainekuo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185190357","body":"### 思路\r\n\r\n逐位相加\r\n\r\n### 代码\r\n\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    let res = [];\r\n    let len = num.length;\r\n    for(let i=len-1; i>=0;i--){\r\n        let sum = num[i] + k % 10;\r\n        k = Math.floor(k / 10);\r\n        if(sum>=10){\r\n            k++;\r\n            sum -= 10;\r\n        }\r\n        res.push(sum);  \r\n    }\r\n    for(let i =k;i>0;i=Math.floor(i/10)){\r\n        res.push(i % 10)\r\n    }\r\n    res.reverse();\r\n    return res;\r\n\r\n};\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186100713","body":"\n### 思路\n\n先获取字符在字符串中的所有位置，然后遍历算出最小距离\n\n### 代码\n\n\n```js\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let targetS = getCharactorIndex(s,c);\n    let res = [];\n    for(let i=0; i<s.length; i++){\n        let min = Number.MAX_SAFE_INTEGER;\n        for(let j=0;j<targetS.length;j++){\n            min = Math.min(min,Math.abs(targetS[j] - i));\n        }\n        res.push(min);\n    }\nreturn res;\n\n};\n\nconst getCharactorIndex = (s,c) =>{\n    let res = [];\n    let charactorArray = s;\n    let idx = charactorArray.indexOf(c);\n    let num = 0;\n    while(idx != -1){\n        res.push(idx);\n        num++\n        idx = charactorArray.indexOf(c,idx+1);\n    }\n    return res;\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n^2)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186371345","body":"\n### 思路\n\n数组实现栈\n\n### 代码\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.n = maxSize;\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.n){\n        return\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.stack.length>0){\n       return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let temp = this.stack.splice(0,k>=this.stack.length?this.stack.length:k);\n    temp = temp.map((item)=>{\n        return item = item + val\n    })\n    this.stack = temp.concat(this.stack);\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186785147","body":"\n### 思路\n\n利用栈的方式；当遇到数字时，存入栈。 遇到‘【’时，记录前面的字符结果，然后入栈；遇到‘】’时，数字和上次的str同时出栈，然后计算本次的字符串的叠加。\n\n### 代码\n\n\n```js\nvar decodeString = function(s) {\n    let numStack = [];\n    let strStack = [];\n    let num =0;\n    let res = '';\n\n    for(let char of s){\n        if(!isNaN(char)){\n            num = num * 10 + Number(char);\n        }else if(char === '['){\n            strStack.push(res);\n            res = '';\n            numStack.push(num);\n            num = 0;\n        }else if(char ===']'){\n            res = strStack.pop() + res.repeat(numStack.pop());\n        }else{\n            res += char;\n        }\n    }\n    return res;\n\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188914373","body":"\n### 思路\n\npush方法将数据存入stack1中，用stack1来存储数据<br>\npop方法将stack1的数据弹出，当stack2为空时，将stack1的数据弹出，push到stack2中。然后再弹出最后一条，就是队列的第一条\n\n### 代码\n\n\n```js\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x);\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n     if(!this.stack2.length){\n         while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n         }\n     }\n     return this.stack2.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stack2.length){\n        while(this.stack1.length){\n             this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length;\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191383951","body":"### 思路\n1、确认移动步数为（链表长度%k）\n2、循环剩余移动部署，指针游走，确定最后链表结果。\n\n### 代码\n\n\n```js\nvar rotateRight = function(head, k) {\n    if (k === 0 || !head || !head.next) {\n        return head;\n    }\n    let n = 1;\n    let cur = head;\n    while(cur.next){\n        cur = cur.next;\n        n++\n    }\n    let move = n - k % n;\n    cur.next = head;\n    while(move){\n        cur = cur.next;\n        move--;\n    }\n    let ans = cur.next;\n    cur.next = null;\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ll491119940":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185193124","body":"## 思路\n输入K数字转换成数组，将数组从末位开始，按位相加，考虑进位，最后返回相加后数组\n\n## 代码\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let result = [];\n    let arrK = String(k).split('');\n    let flag = 0;\n    num.reverse();\n    arrK.reverse();\n    for(let i = 0; i < num.length || i < arrK.length; i++) {\n        var retNum = (num[i] || 0) + (+arrK[i] || 0) + flag;\n        if (retNum >= 10) {\n            retNum = retNum % 10;\n            flag = 1;\n        } else {\n            flag = 0;\n        }\n        result.push(retNum);\n    }\n\n    if(flag) {\n        result.push(1);\n    }\n    result.reverse();\n    return result\n};\n```\n## 算法复杂度\n\n+ 时间复杂度 O(n)\n+ 空间复杂度 O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186415178","body":"## 思路\n 用数组模拟栈；\n## 代码\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    const len = this.stack.length;\n    if(len >= this.maxSize) return;\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(!this.stack.length) return -1;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const minIdx = Math.min(this.stack.length, k)\n    for(let i = 0; i < minIdx; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度分析\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187672624","body":"## 思路\n 用两个栈分别记录数字和字符串\n\n## 代码\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let nums = [];              \n    let strs = [];              \n\n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {             \n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strs.push(result);\n            result = '';\n            nums.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const finalNums = nums.pop();        \n            result = strs.pop() + result.repeat(finalNums);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};\n```\n## 复杂度\n+ 时间复杂度： O(n)\n+ 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189214791","body":"## 思路\n用两个栈来模拟队列，一个负责push，一个负责pop，push时保证pop的栈为空，pop时保证push栈为空\n## 代码\n```\nvar MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n## 复杂度\n+ 时间复杂度: O(n)\n+ 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190389570","body":"\n## 思路\n滑动窗口，对比输入数组和排序后数组，每个分块中元素是一样的\n## 代码\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n   const sorted = [...arr];\n   sorted.sort((a,b) => (a - b));\n   let ans = 0;\n   let sums1 = 0;\n   let sums2 = 0;\n   for(let i = 0; i < arr.length; i++) {\n        sums1 += arr[i];\n        sums2 += sorted[i];\n\n        if (sums1 === sums2) {\n            ans++;\n            sums1 = sums2 = 0; // 这行不要也可以啦\n        }\n   }\n   return ans;\n};\n```\n## 复杂度\n+ 时间复杂度: O(NlogN)\n+ 空间复杂度: O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"2learnsomething":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185216971","body":"## 思路\n看成是两个数组的求和，然后遍历数组，数字不断做求余和求除操作,进行类似于按位求和操作，注意进位问题即可，最后返回结果的逆序。\n\n## 代码\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        temp = 0\n        while num or k or temp:\n            sum_k = k % 10\n            if num:\n                n = num.pop()\n            else: n = 0\n            ans.append((n+sum_k+temp)%10)\n            k //=  10\n            temp = (n+sum_k+temp)//10\n        return ans[::-1]\n```\n## 复杂度\n时间复杂度：O(n) \n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186104169","body":"## 思路\n很傻很直白的办法，先遍历一次用数组记录下目标c的位置，然后再遍历一次计算距离c的下标的最小值。属于是暴力求解，当规模更大的时候可能会超时，之后还需要改进\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = []\n        ans = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans.append(i) \n        for j in range(len(s)):\n            if s[j] == c:\n                res.append(0)\n            else:\n                min_ = min(list(map(lambda x:abs(x-j),ans)))\n                res.append(min_)\n        return res\n```\n## 复杂度分析\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416069","body":"## 思路\n利用python自带的列表进行栈的模拟，对于第三个问题，则采取直白的判断和遍历的方法。\n## 代码\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxsize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) <= k:\n            self.stack = list(map(lambda x:x+val,self.stack))\n        else:\n            for i in range(k):\n                self.stack[i] +=val\n```\n## 复杂度\n时间复杂度: O(N)\n\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186828526","body":"## 思路\n栈的使用，与判断括号匹配相似\n## 代码\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur, last = stack.pop()\n                res = last + cur * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n## 复杂度\n时间复杂度:O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188650642","body":"## 思路\n用两个栈进行模拟\n## 代码\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stracks = []\n        self.stracks_tmp = []\n\n    def push(self, x: int) -> None:\n        if self.stracks:\n            while self.stracks:\n                self.stracks_tmp.append(self.stracks.pop())\n            self.stracks.append(x)\n            while self.stracks_tmp:\n                self.stracks.append(self.stracks_tmp.pop())\n        else:\n            self.stracks.append(x)\n\n    def pop(self) -> int:\n        return self.stracks.pop()\n\n    def peek(self) -> int:\n        return self.stracks[-1]\n\n    def empty(self) -> bool:\n        if not self.stracks:\n            return True\n        else:\n            return False\n```\n## 复杂度分析\n时间复杂度:O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189832298","body":"## 思路\n构造单调栈，最后分的块的数目为栈中元素的数目\n## 代码\n```\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        max_, stack = arr[0], [arr[0]]\n        for i in range(1, len(arr)):\n            if arr[i] >= max_:\n                max_ = arr[i]\n                stack.append(arr[i])\n            else:\n                while stack and stack[-1] > arr[i]:\n                    stack.pop()\n                stack.append(max_)\n        return len(stack)\n```\n## 复杂度分析\n只需要遍历一次数组\n时间复杂度: O(N)\n\n空间复杂度:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191081611","body":"## 思路\n先求出链表长度，然后对k取模得到实际移动的步数，最后就是链表的拼接\n## 代码\n```\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if k == 0: return head\n        else:\n            if head:\n                lenth = 0\n                cur,slow,fast = head,head,head\n                while cur:\n                    cur = cur.next\n                    lenth += 1\n                k %= lenth\n                while k:\n                    fast = fast.next\n                    k -= 1\n                if fast != head:\n                    while fast.next:\n                        fast = fast.next\n                        slow = slow.next\n                    new_head = slow.next\n                    fast.next = head\n                    slow.next = None\n                    return new_head\n                else:\n                    return head\n            else:\n                return head\n```\n## 复杂度分析\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ataraxyadong":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185228684","body":"### 思路\n\n从低位到高位依次拿出`num`的值和`k`相加，将所加之和与10的余数加入到`list`中，直到`k=0`。最后将所得的`list`反转后即可得到。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int length = num.length;\n        int idxVal;\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            idxVal = num[length - 1 - i];\n            if (k != 0) {\n                list.add((idxVal + k) % 10);\n                k = (idxVal + k) / 10;\n            } else {\n                list.add(idxVal);\n            }\n            if (k != 0 && (length - 1 - i) <= 0) {\n                while (k != 0) {\n                    list.add(k % 10);\n                    k = k / 10;\n                }\n            }\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n```\n\n### 复杂度分析\n\n\\- 时间复杂度：O(N)，其中 `N = array.length`或者是`N = array.length + k的位数`。（不确定）\n\\- 空间复杂度：O(1)，（不确定）\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173029","body":"### 思路\n\n根据题目的提示**“数组的遍历(正向遍历和反向遍历)”**，分两次遍历数组：\n\n1. 第一次，正向遍历，出现在第一个c前的位置都给`Integer.MAX_VALUE`，出现c的位置赋值为0，其余的位置的先计算出“此位置到它**左边最近的c**的距离”\n2. 第二次，反向遍历，思路大致如上，不同处在于计算出“此位置到它**右边最近的c**的距离”，和“此位置到它**左边最近的c**的距离”相比，取小值即可\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] result = new int[length];\n        int currentIndex = Integer.MAX_VALUE;\n        for (int i = 0; i < length; i++) {\n            if (s.charAt(i) == c) {\n                result[i] = 0;\n                currentIndex = i;\n            } else {\n                result[i] = Math.abs(i - currentIndex);\n            }\n        }\n        for (int i = length - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                currentIndex = i;\n            } else {\n                result[i] = Math.min(Math.abs(i - currentIndex), result[i]);\n            }\n        }\n        return result;\n    }\n}\n```\n\n\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为字符串的长度。\n- 空间复杂度：O(N)（不确定）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186518458","body":"### 思路\n\n根据栈的结构，定义出三个变量：\n\n1. `int[] stack`用来存放值\n2. `int head`指定当前栈顶，当值为-1时表明此栈为空\n3. `int maxSize`接收指定的栈的大小\n\n- push\n\n  判断`head`是否到了栈的最大位置处，没有则添加\n\n- pop\n\n  判断`head`是否是空栈\n\n### 代码\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int head = -1;\n    int maxSize = 0;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.stack = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (head >= maxSize - 1) {\n            return;\n        }\n        this.stack[++head] = x;\n    }\n\n    public int pop() {\n        if (head == -1) {\n            return -1;\n        }\n        return this.stack[head--];\n    }\n\n    public void increment(int k, int val) {\n        if (head + 1 < k) {\n            for (int i = 0; i < head + 1; i++) {\n                stack[i] += val;\n            }\n            return;\n        }\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为指定栈的长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187666868","body":"### 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuffer result = new StringBuffer();\n        Stack<Integer> numberStack = new Stack<>();\n        Stack<StringBuffer> stringBufferStack = new Stack<>();\n        int count = 0;\n        for (char ch : s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                count = count * 10 + ch - '0';\n            } else if (ch == '[') {\n                numberStack.push(count);\n                count = 0;\n                stringBufferStack.push(result);\n                result = new StringBuffer();\n            } else if (Character.isAlphabetic(ch)) {\n                result.append(ch);\n            } else {\n                StringBuffer temp_str = stringBufferStack.pop();\n                int temp_num = numberStack.pop();\n                for (int i = 0; i < temp_num; i++) {\n                    temp_str.append(result);\n                }\n                result = temp_str;\n            }\n        }\n        return result.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189084434","body":"### 思路\n\n（通过题解学习）\n\n- 思路1\n\n  使用两个栈来实现队列，一个栈用来存放原本的顺序，另一个栈用来作为临时存放反转顺序使用。\n\n  `storeStack`和`reverseStack`\n\n  - push\n\n    入队的时候需要先把`storeStack`清空（把数据`pop`，然后`push`到`reverseStack`，直到`storeStack.empty() == true`），然后数据进`storeStack`，再把`reverseStack`的数据`pop`，然后`push`到`storeStack`\n\n  - pop\n\n    `storeStack`的`head`就是队列的`head`，出队时直接使用`storeStack.pop()`即可（`storeStack`不为空）\n\n- 思路2\n\n  使用两个栈来实现队列，一个栈用来存放`push`进来的数据，另一个栈用来存放需要`pop`的数据\n\n  `pushStack`和`popStack`\n\n  - push\n\n    入队时直接`push`到`pushStack`，如果此时的`pushStack`为空，需要将第一个值指定为`head`，方便`peek`\n\n  - pop\n\n    出队时，需要保证`popStack`不为空，如果是空，就把`pushStack`全部添加到`popStack`，然后再从`popStack`出队\n\n  - peek\n\n    如果`popStack`为空，那么head就是队首，如果不为空，队首就是`popStack`的栈顶\n\n### 代码\n\n#### 思路1\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> storeStack;\n    private Stack<Integer> reverseStack;\n\n    public MyQueue() {\n        this.storeStack = new Stack<>();\n        this.reverseStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        while (!storeStack.empty()) {\n            reverseStack.push(storeStack.pop());\n        }\n        storeStack.push(x);\n        while (!reverseStack.empty()) {\n            storeStack.push(reverseStack.pop());\n        }\n    }\n\n    public int pop() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.pop();\n    }\n\n    public int peek() {\n        if (storeStack.empty()) {\n            return Integer.MIN_VALUE;\n        }\n        return storeStack.peek();\n    }\n\n    public boolean empty() {\n        return storeStack.empty();\n    }\n}\n```\n\n#### 思路2\n\n```java\nclass MyQueue {\n\n    private Stack<Integer> pushStack;\n    private Stack<Integer> popStack;\n    // 队列的head\n    private int head;\n\n    public MyQueue() {\n        this.pushStack = new Stack<>();\n        this.popStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (pushStack.empty()) {\n            head = x;\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        if (popStack.empty()) {\n            while (!pushStack.empty()) {\n                popStack.push(pushStack.pop());\n            }\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        if (popStack.empty()) {\n            return head;\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：\n  1. 思路1\n     - 入队：O(N)\n     - 出队：O(1)\n  2. 思路2\n     - 入队：O(1)\n     - 出队：O(1)\n- 空间复杂度：O(1)\n  1. 思路1\n     - 入队：O(N)\n     - 出队：O(1)\n  2. 思路2\n     - 入队：O(1)\n     - 出队：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190371208","body":"### 思路\n\n（通过题解学习）\n\n使用栈来记录每个块的最大值，在栈中的值应该是递增的（存在相等的情况），最后计算栈的长度即可得知块的个数。\n\n遍历数组，当**栈为空**或者是**当前值大等于栈顶值**，将当前值入栈，认为是一个块；当栈不为空，出现了**当前值小于栈顶值**（就是当前值需要并入上一个块），先把记录当前块的最大值暂存，需要将栈顶值抛出，一直到**当前值大等于栈顶值**或者栈为空后，再将临时保存的当前块最大值入栈。\n\n主要的思路是：遍历到的num必须是**大等于**栈顶值才可以称为一个新的块，否则就需要并入前一个块\n\n### 代码\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Stack<Integer> blockMaxHeadStack = new Stack<>();\n\n        for (int num : arr) {\n\n            if (blockMaxHeadStack.empty() || num >= blockMaxHeadStack.peek()) {\n                blockMaxHeadStack.push(num);\n            }\n\n            if (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                // 获取记录当前块的最大值\n                int head = blockMaxHeadStack.pop();\n                while (!blockMaxHeadStack.empty() && num < blockMaxHeadStack.peek()) {\n                    blockMaxHeadStack.pop();\n                }\n                blockMaxHeadStack.push(head);\n            }\n        }\n        return blockMaxHeadStack.size();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191200440","body":"### 思路\n\n（通过题解学习）\n\n根据题目的要求，就是将链表（单向链表）的元素向后移动k个单位。\n\n首先，遍历链表，得到当前链表的头尾，将其头尾相接，形成一个环形链表；\n\n然后，计算`head`移动的最短路径（也就是head元素的新位置），并找到这个`head`\n\n最后，从`head`节点前把链表断开，就是`head`的前一个元素的`next`指为`null`\n\n### 代码\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n\n        if (head == null || k == 0 || head.next == null) {\n            return head;\n        }\n\n        ListNode iterator = head;\n        ListNode tail;\n        int size = 1;\n\n        while (iterator.next != null) {\n            iterator = iterator.next;\n            size++;\n        }\n        // 抓到链表的尾部 构成环形链表\n        tail = iterator;\n        tail.next = head;\n\n        // 从输入到输出，计算出元素最短移动路径\n        int offset = size - k % size;\n        if (offset == 0) {\n            return head;\n        }\n        iterator = head;\n        for (int i = 0; i < offset; i++) {\n            iterator = iterator.next;\n        }\n        head = iterator;\n\n        while (iterator.next != head) {\n            iterator = iterator.next;\n            if (iterator.next == head) {\n                iterator.next = null;\n                return head;\n            }\n        }\n        return null;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wzasd":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185232708","body":"### 思路\r\n\r\n本来想用`BigInteger`来进行大数计算，然后通过字符串进行数组转换，但是发现 leetcode 无法使用`BigInteger`，所以还是使用数组单项相加即可，主要考虑进位处理，另一个方法就是单位相加，逐一推出相应单位数就行了\r\n\r\n### 代码\r\n\r\n#### 写法一\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        for (int i = len - 1; i >= 0; i--) {\r\n            //数组中单项相加\r\n            int sum = num[i] + k % 10;\r\n            k = k / 10;\r\n            // 判断是否有进位的数\r\n            if (sum >= 10) {\r\n                ++k;\r\n                sum = sum - 10;\r\n            }\r\n            ans.add(sum);\r\n        }\r\n        //不确定是k大还是num代表的数据大，所以要进行两次运算\r\n        for (; k > 0; k /= 10) {\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n#### 写法二\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length;\r\n        List<Integer> ans = new ArrayList<>();\r\n        //简化上一步\r\n        for (int i = len - 1; i >= 0 || k > 0; i--, k /= 10) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;\r\n    }\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186191505","body":"### 思路\r\n\r\n使用二次遍历，第一次遍历获取所有命中字符的下表，第二次遍历计算最远距离，获取与上一次的距离最小值即可，注意处理只有一次的情况\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        List<Integer> cIndex = new ArrayList<>();\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char sChar = s.charAt(i);\r\n            if (sChar == c){\r\n                cIndex.add(i);\r\n            }\r\n        }\r\n        for (int i = 0, j = 0; i < s.length(); i++) {\r\n            if (s.charAt(i) == c){\r\n                ans[i]=0;\r\n                if (j != cIndex.size() - 1){\r\n                    j++;\r\n                }\r\n                continue;\r\n            }\r\n            if (j >= 1){\r\n                ans[i] = Math.min(Math.abs(cIndex.get(j) - i),Math.abs(cIndex.get(j-1) - i));\r\n            }else {\r\n                ans[i] = Math.abs(cIndex.get(j) - i);\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186429099","body":"### 思路\r\n\r\n通过LinkList 来模拟栈的使用，当然也可以使用数组，这里只要处理好边界条件就可以了\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack {\r\n\r\n    LinkedList<Integer> stack = new LinkedList<>();\r\n    int MaxSize;\r\n    public CustomStack(int maxSize) {\r\n        MaxSize = maxSize;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < MaxSize) {\r\n            stack.add(stack.size(),x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (stack.isEmpty()){\r\n            return -1;\r\n        }\r\n        int popNum = stack.getLast();\r\n        stack.removeLast();\r\n        return popNum;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        for (int i = 0; i < stack.size() && i < k; i++) {\r\n            stack.set(i,stack.get(i) + val);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186692154","body":"### 思路\r\n\r\n与之前的匹配字符串有点像，这里采用入栈的方式，分为三种情况\r\n\r\n1. 数字入栈，这里要对连续数字进行处理\r\n2. 字母还有“[”括号入栈\r\n3. 遇到“]”括号出栈，同时截取第二步括号之前的字符\r\n\r\n弹出\"[\"括号字符，获取重复的次数，处理这些字符串就可以了。\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    int curIndex;\r\n    public String decodeString(String s) {\r\n        LinkedList<String> ans = new LinkedList<>();\r\n        curIndex = 0;\r\n        while (curIndex < s.length()) {\r\n            char c = s.charAt(curIndex);\r\n            if (Character.isDigit(c)) {\r\n                String strDigit = getDigits(s);\r\n                ans.addLast(strDigit);\r\n            } else if (Character.isLetter(c) || c == '[') {\r\n                ans.addLast(String.valueOf(s.charAt(curIndex++)));\r\n            } else {\r\n                curIndex++;\r\n                LinkedList<String> subStr = new LinkedList<>();\r\n                while (!ans.peekLast().equals(\"[\")){\r\n                    subStr.addLast(ans.removeLast());\r\n                }\r\n                ans.removeLast();\r\n                Collections.reverse(subStr);\r\n                Integer repeatTimes = Integer.parseInt(ans.removeLast());\r\n                StringBuffer sb = new StringBuffer();\r\n                String o = getString(subStr);\r\n                while (repeatTimes-- > 0 ){\r\n                    sb.append(o);\r\n                }\r\n                ans.addLast(sb.toString());\r\n            }\r\n        }\r\n        return getString(ans);\r\n    }\r\n\r\n    public String getDigits(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while (Character.isDigit(s.charAt(curIndex))){\r\n            sb.append(s.charAt(curIndex++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    public String getString(LinkedList<String> ll) {\r\n        StringBuffer ans = new StringBuffer();\r\n        for (String s :\r\n                ll) {\r\n            ans.append(s);\r\n        }\r\n        return ans.toString();\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n        Solution1 solution1 = new Solution1();\r\n        System.out.println(solution1.decodeString(\"3[a]2[bc]\"));\r\n    }\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188507766","body":"### 思路\r\n\r\n理解栈和队列的思想就很好解了，使用 LinkList 来模拟栈，修改的时候只考虑增和删除的时候保证两个栈一样就行了。\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass MyQueue {\r\n    LinkedList<Integer> stack1;\r\n    LinkedList<Integer> stack2;\r\n    public MyQueue() {\r\n        stack1 = new LinkedList<>();\r\n        stack2 = new LinkedList<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stack1.addFirst(x);\r\n        in2tou(stack1,stack2);\r\n    }\r\n\r\n    public int pop() {\r\n        int popNum = stack2.removeFirst();\r\n        in2tou(stack2,stack1);\r\n        return popNum;\r\n    }\r\n\r\n    public int peek() {\r\n        return stack2.getFirst();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stack2.isEmpty();\r\n    }\r\n\r\n    public void in2tou(LinkedList<Integer> in,LinkedList<Integer> out){\r\n        out.clear();\r\n        for (int num : in) {\r\n            out.addFirst(num);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189768960","body":"### 思路\r\n\r\n辅助栈还是比较好理解的，只需要判断每个组的最大值，再去分析下一个数字与这个值得大小。逻辑如下\r\n\r\n1. 循环数组aar\r\n2. 判断栈是否为空，循环的数num是否比目前的栈顶元素大，如果大则入栈，如果小\r\n3. 则最大值出栈，循环往下寻找最小值，再将栈顶入栈\r\n\r\n依次得出栈的值则是最大的数了\r\n\r\n### 代码\r\n\r\n\r\n```java\r\n        LinkedList<Integer> stack = new LinkedList<>();\r\n        for (int num : arr) {\r\n            if (!stack.isEmpty() && num < stack.getLast()) {\r\n                int head = stack.removeLast();\r\n                while (!stack.isEmpty() && num < stack.getLast()) {\r\n                    stack.removeLast();\r\n                }\r\n                stack.addLast(num);\r\n            } else {\r\n                stack.addLast(num);\r\n            }\r\n        }\r\n        return stack.size();\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191004028","body":"### 思路\r\n\r\n代码不够简洁，但是只要有足够的中间变量就可以完成了，主要还是靠画图，如果不画图，逐渐狰狞！\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (k == 0 || head == null || head.next == null) {\r\n            return head;\r\n        }\r\n\r\n        int len = 0;\r\n        ListNode cur = head;\r\n        while (cur != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n\r\n        int movedLocation = k % len;\r\n\r\n        if (movedLocation == 0) {\r\n            return head;\r\n        }\r\n\r\n        cur = head;\r\n        for (int i = 0; i < len - movedLocation - 1; i++) {\r\n            cur = cur.next;\r\n        }\r\n\r\n        ListNode ans = cur.next;\r\n        ListNode ansLast = ans;\r\n        cur.next = null;\r\n        while (ansLast.next != null) {\r\n            ansLast = ansLast.next;\r\n        }\r\n        ansLast.next = head;\r\n        return ans;\r\n    }\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miluowzt":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236293","body":"# **思路**\r\n从后往前遍历数组，按位与k相加，遇10进1（结果大于10时，进位数1加到下一位进行计算），考虑结果如果存储LinkedList的addFirst或者ArraryList最后翻转。\r\n\r\n# **代码**\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n\r\n        LinkedList<Integer> numList = new LinkedList<Integer>();\r\n        int index = num.length-1;\r\n        while (index>=0||k!=0){\r\n            if(index>=0){\r\n                k=num[index]+k;\r\n                index--;\r\n            }\r\n            numList.addFirst(k%10);\r\n            k=k/10;\r\n        }  \r\n        return numList;\r\n    }\r\n}\r\n\r\n# **复杂度分析**\r\n时间复杂度：O(n)  \r\nwhile 循环运行n次，n为数组长度\r\n空间复杂度：O(n)  \r\n创建的一个空列表，这个列表占用的内存随着while 循环的增加而增加，最大到 n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223012","body":"# *思路*\n从左往右遍历一次，再从右往左遍历一次，取最小值。\n需要想到的点是开始charAt位置没有数值时，用一个假定的值来表示。\n最开始按照自己的想法写了一个很复杂的，虽然执行了但是时间复杂度是n方。\n# *代码*\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int length=s.length();\n        int [] arr= new int[length];\n        for(int i=0,index=-length;i<length;++i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=i-index;\n        }\n        for(int i=length-1,index=2*length;i>=0;--i){\n            if(s.charAt(i)==c){\n                index=i;\n            }\n            arr[i]=Math.min(arr[i],index-i);\n        }\n        return arr;\n    }\n}\n# *复杂度*\n时间复杂度：O(n)，其中n 是字符串 s 的长度。\n空间复杂度：O(1)。返回值不计算成空间复杂度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552049","body":"# *思路*\r\n用数组进行实现\r\n# *代码*\r\nclass CustomStack {\r\n    int [] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack=new int[maxSize];\r\n        top=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n       if(top !=stack.length-1){\r\n            ++top;\r\n            stack[top]=x;\r\n        }\r\n    }\r\n    \r\n\r\n  public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int length = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189732029","body":"# *思路*\r\n补卡，这道题一直没太想清楚，参考官方答案，理解后重写\r\n数字的问题，前期忽略了多位数的情况，导致报错\r\n\r\n# *代码*\r\n class Solution{\r\n\r\n        String src;\r\n        int ptr;\r\n       //int repTime ;\r\n\r\n        public String decodeString(String s) {\r\n            src = s;\r\n            ptr = 0;\r\n            return getdecodeStr();\r\n        }\r\n        public String getdecodeStr() {\r\n            //在最后一位的时候，ptr=9，如果charAt在前边汇报错\r\n            if(ptr== src.length()||src.charAt(ptr)==']'){\r\n                return \"\";\r\n            }\r\n            char cur = src.charAt(ptr);\r\n            String ret = \"\";\r\n            int repTime = 0;\r\n\r\n            if(Character.isDigit(cur)){\r\n                //拿出数字之后，往后移位（考虑多位数问题，一定要确保数字都拿完）\r\n                while (Character.isDigit(src.charAt(ptr))) {\r\n                    repTime = repTime * 10 + src.charAt(ptr++) - '0';\r\n                }\r\n                //过滤掉数字后边的[\r\n                ++ptr;\r\n                String str = getdecodeStr();\r\n\r\n                //拿完字母后后移到]\r\n                ++ptr;\r\n                while(repTime-->0){\r\n                    ret+=str;\r\n                }\r\n            }else {\r\n                ret=String.valueOf(cur);\r\n                ++ptr;\r\n            }\r\n            return ret+getdecodeStr();\r\n\r\n\r\n        }\r\n    }\r\n\r\n# *复杂度* \r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190081044","body":"# *思路*\n栈先进后出，队列先进先出，利用两个栈把栈1的数据导入栈2，再倒回去。\n\n# *代码*\nclass MyQueue {\n        \n        Stack<Integer> stack_1;\n        Stack<Integer> stack_2;\n        \n    public MyQueue() {\n        stack_1=new Stack();\n        stack_2=new Stack();\n    }\n    \n    public void push(int x) {\n        while (!stack_1.isEmpty()){\n            stack_2.push(stack_1.pop());\n        }\n        stack_2.push(x);\n        while (!stack_2.isEmpty()){\n            stack_1.push(stack_2.pop());\n        }\n\n    }\n    \n    public int pop() {\n        return stack_1.pop();\n    }\n    \n    public int peek() {\n        return stack_1.peek();\n    }\n    \n    public boolean empty() {\n        return stack_1.isEmpty();\n    }\n}\n#*复杂度*\n","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191166439","body":"# *思路*\n拼接成一个旋转链表，头尾相接。\n拼接成功后，右移位k位（原给定的链表长度为n），实际上为原链表从后往前第n-k个位置的next为null\n\n# *代码*\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head==null||k==0||head.next==null){\n            return head;\n        }\n        ListNode now =head;\n        int count=1;\n        while(!(now.next==null)){\n            now=now.next;\n            count++;\n        }\n        if (count==k||k%count==0){\n            return head;\n        }\n        now.next=head;\n        int n=count-k%count;\n        while (n-->0){\n            now=now.next;\n        }\n        head=now.next;\n        now.next=null;\n        return head;\n\n    }\n}\n# *复杂度*\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maylinglin":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185236729","body":"## 思路\n\n---\n\n把num从list转化成str，再转化成int与k相加，最后返回list形式。\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        x = ''.join(map(str, num))\n        sum = int(x) + k\n        return list(map(int, str(sum)))   # [int(i) for i in str(sum)]\n```\n\n## 复杂度\n\n---\n\n- ****Time:**** O(N)\n- ****Space:**** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194435","body":"## 思路\n\n\n首先从左往右遍历求距离，再从右往左遍历求距离，计算两边距离的最小值。\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n for i in range(n)]\n        dist = n\n        for i in range(n):\n            if s[i] == c:\n                dist = 0\n            else:\n                dist += 1 \n            ans[i] = dist\n        for j in range(n-1, -1, -1):\n            if s[j] == c:\n                dist = 0\n            else:\n                dist += 1\n            ans[j] = min(dist, ans[j])\n        return ans\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533825","body":"## 思路\n\n\n用数组模拟栈操作\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.stack.append(x)\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            self.size -= 1\n            return self.stack.pop()\n            \n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(k, self.size)):\n            self.stack[i] += val\n```\n\n## 复杂度\n\n\n- **Time:** push: O(1)， pop: O(1)， increment: O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187514265","body":"## 思路\n\n\n双栈，一个栈存放数字，一个栈存放字母\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"]\":\n                tmpstr = \"\"\n                numstr = \"\"\n                while stack and stack[-1] != \"[\":\n                    char = stack.pop()\n                    tmpstr = char + tmpstr\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop()\n                    numstr = num + numstr\n                stack.append(int(numstr) * tmpstr)\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189081575","body":"## 思路\n\n\n使用两个栈实现队列\n\n## 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        self.stack1.append(x)\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n\n    def pop(self) -> int:\n        return self.stack1.pop()\n\n    def peek(self) -> int:\n        return self.stack1[-1]\n\n    def empty(self) -> bool:\n        if self.stack1:\n            return False\n        else:\n            return True\n```\n\n## 复杂度\n\n\n- ****Time: push:**** O(N) ****pop:**** O(1) ****peek:**** O(1)  ****empty:**** O(1)\n- **Space:** O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190017798","body":"## 思路\n\n\n从左向右遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        n = len(arr)\n        for i in range(n):\n            m = arr[i]\n            while stack and stack[-1] > arr[i]:\n                m = max(stack.pop(), m)\n            stack.append(m)\n        return len(stack)\n```\n\n## 复杂度\n\n\n- ****Time:**** O(N)\n- **Space:** O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185238518","body":"### 整体思路\n\n模拟真正的加法计算过程\n从后往前依次逐位相加，如果 >=10 则进位\n每次加在 list 末尾，再将 list 反转\n\n### 代码\n\n```java\n    private  List<Integer> leetcodeSolution(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // 如果和 > 10，需要进位\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // 上面循环做完，是按照数组的长度求的结果，但是 k 可能比数组多很多位，所以还需要一个 while 循环\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n```\n\n### 复杂度分析\n时间复杂度：O(max(n,log k))，其中 n 为数组的长度。\n空间复杂度：O(1)。除了返回值以外，使用的空间为常数。","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188546091","body":"### 整体思路\n\n用两个栈，一个负责入，一个负责出\n\n### 代码\n\n```java\nclass MyQueue {\n    Stack<Integer> stack1,stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        if (stack2.empty()){\n            while (!stack1.empty()){\n                Integer data = stack1.pop();\n                stack2.push(data);\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty() && stack2.empty();\n    }\n}\n```\n\n### 复杂度分析\n\n时间复杂度：各个方法均为 O(1)\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brodxie":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185240028","body":"## 思路\r\n\r\n由于num可能很长，不能转int直接相加，模拟计算机的加法\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n    \t# space: O(max(M, N))\r\n        res = []\r\n        i = len(num) - 1\r\n        overflow = 0\r\n        # time: O(max(M, N))\r\n        while i >= 0 or k > 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            c = a + b + overflow\r\n            res.append(c % 10)\r\n            overflow = c // 10\r\n            i -= 1\r\n            k //= 10\r\n        if overflow:\r\n            res.append(overflow)\r\n        # time: O(max(M, N))\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n## 复杂度分析\r\nM为num.length, N为ceil(log10(k))\r\n\r\n- 时间复杂度: O(Max(M, N))\r\n- 空间复杂度: O(Max(M, N))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102244","body":"## 思路\r\n\r\n记录上个c的索引，得到当前字符和c的最小距离。正向反向分表遍历一次，取最小的。\r\n\r\n## 代码\r\n\r\n```python3\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n = len(s)\r\n        # space: O(N)\r\n        ans = [float('inf')] * n\r\n        last_c_index = float('-inf')\r\n        # time: O(N)\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], i - last_c_index)\r\n        last_c_index = float('inf')\r\n        # time: O(N)\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                last_c_index = i\r\n            ans[i] = min(ans[i], last_c_index - i)\r\n        return ans\r\n\r\n```\r\n\r\n## 复杂度分析\r\n\r\nN为s.length\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂: O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439305","body":"## 思路\n\n数组和栈的基本操作\n\n## 代码\n\n```python3\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        # space: O(maxSize)\n        self.array = [0] * maxSize\n        self.size = 0\n\n    def push(self, x: int) -> None:\n        if self.size >= self.maxSize:\n            return\n        self.array[self.size] = x\n        self.size += 1\n\n    def pop(self) -> int:\n        if self.size <= 0:\n            return -1\n        self.size -= 1\n        return self.array[self.size]\n\n    def increment(self, k: int, val: int) -> None:\n        # time: O(k)\n        for i in range(min(k, self.size)):\n            self.array[i] += val\n```\n\n## 复杂度分析\n\n- 初始化\n  - time: O(1)\n  - space: O(maxSize)\n- push\n  - time: O(1)\n  - space: O(1)\n- pop\n  - time: O(1)\n  - space: O(1)\n- increment\n  - time: O(k)\n  - space: O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186816024","body":"## 思路\r\n\r\n对s中的字符进行压栈, 如果遇到']'说明遇到了一个最内层的表达式, 进行解析, 再压到栈里.   \r\n\r\n## 代码\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # space: O(N)\r\n        stack = []\r\n        # time : O(N)\r\n        for c in s:\r\n            if c == ']':\r\n                token = ''\r\n                while stack and stack[-1] != '[':\r\n                    token = stack.pop() + token\r\n                stack.pop()\r\n                k = ''\r\n                while stack and stack[-1].isnumeric():\r\n                    k = stack.pop() + k\r\n                stack.append(token * int(k))\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n\r\n## 复杂度分析\r\n\r\nN为s.length\r\n\r\n- time: O(N)\r\n- space: O(N)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189007251","body":"## 思路\r\n\r\n- 使用两个栈：一个用于入队，一个用于出队。\r\n- 使用一个变量辅助保存队首元素。\r\n\r\n## 代码\r\n\r\n```python3\r\nclass MyQueue:\r\n\t\r\n    def __init__(self):\r\n        self.push_stack = []\r\n        self.pop_stack = []\r\n        self.push_stack_bottom = None\r\n\r\n    def push(self, x: int) -> None:\r\n        if not self.push_stack:\r\n            self.push_stack_bottom = x\r\n        self.push_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.pop_stack:\r\n            while self.push_stack:\r\n                self.pop_stack.append(self.push_stack.pop())\r\n        return self.pop_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.pop_stack:\r\n           return self.pop_stack[-1]\r\n        return self.push_stack_bottom\r\n\r\n    def empty(self) -> bool:\r\n        return not self.push_stack and not self.pop_stack\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- push\r\n  - time: O(1)\r\n  - space: O(N)\r\n- pop\r\n  - time: 平均 O(1) 最坏 O(N)\r\n  - space: O(1)\r\n- peek\r\n  - time: O(1)\r\n  - space: O(1)\r\n- empty\r\n  - time: O(1)\r\n  - space: O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386113","body":"## 思路\n\n利用单调栈的性质，求出每个块的最大值\n\n## 代码\n\n```python3\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and stack[-1] > num:\n                cur = stack[-1]\n                while stack and stack[-1] > num:\n                    stack.pop()\n                stack.append(cur)\n            else:\n                stack.append(num)\n        return len(stack)\n\n```\n\n## 复杂度分析\n\n设 N = arr.length\n\n- time: O(N)\n- space: O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"y525":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185251187","body":"class Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        carry = 0\r\n        i = 1\r\n        n = len(num)\r\n        while n-1 >= 0 or carry != 0 or k != 0:\r\n            if n-1 < 0:\r\n                number = k%10 + carry\r\n            else:\r\n                number = num[n-1] + k%10 + carry\r\n            k = k//10\r\n            carry = number//10\r\n            number = number % 10\r\n            res.append(number)\r\n            n -= 1\r\n        return res[::-1]\r\n\r\nspace complexity O(n) time complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185878663","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        answer = []\r\n        for i, v in enumerate(s):\r\n            if v == c:\r\n                res.append(i)\r\n        for i in range(len(s)):\r\n            m = math.inf\r\n            for j in range(len(res)):\r\n                m = min(abs(i-res[j]), m)\r\n            answer.append(m)\r\n        return answer\r\ntime complexity O(n^2) space complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441195","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.data = []\r\n    def isEmpty(self):\r\n        if len(self.data) == 0:\r\n            return True\r\n        else: \r\n            return False\r\n    def isFull(self):\r\n        if len(self.data) == self.maxSize:\r\n            return True\r\n        else:\r\n            return False\r\n            \r\n    def push(self, x: int) -> None:\r\n        if self.isFull() == True:\r\n            pass\r\n        else:\r\n            self.data.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.isEmpty() == True:\r\n            return -1\r\n        else:\r\n            return self.data.pop(-1)\r\n        return s.pop() if s is not None else -1\r\n        \r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(len(self.data)):\r\n            if i<k:\r\n                self.data[i] = self.data[i]+val\r\ntime complexity O(n) space complexity O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188353551","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        #stack\r\n        stack = []\r\n        for i in range(len(s)):\r\n            if s[i] != \"]\":\r\n                stack.append(s[i])\r\n            else:\r\n                st = \"\"\r\n                while stack[-1] != \"[\":\r\n                    st = stack.pop() + st\r\n                stack.pop()\r\n                num = \"\"\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num)*st)\r\n        return \"\".join(stack)\r\ntime complexity O(n) space complexity O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188654987","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        while self.s1:\r\n            self.s2.append(self.s1.pop())\r\n        self.s1.append(x)\r\n        while self.s2:\r\n            self.s1.append(self.s2.pop())\r\n            \r\n    def pop(self) -> int:\r\n        return self.s1.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.s1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return False if self.s1 else True","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189905583","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: list[int]) -> int:\r\n        stack = []\r\n        stack.append((arr[0], arr[0]))\r\n        for i in range(1, len(arr)):\r\n            minNum, maxNum = arr[i], arr[i]\r\n            while stack and stack[-1][1] > minNum:\r\n                prevMinNum, prevMaxNum = stack.pop()\r\n                minNum, maxNum = min(prevMinNum, minNum), max(prevMaxNum, maxNum)\r\n            stack.append((minNum, maxNum))\r\n        return len(stack)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191097100","body":"class Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        n = 0\r\n        dummy = ListNode(0, head)\r\n        pre = dummy\r\n        while head:\r\n            n += 1\r\n            head = head.next\r\n            pre = pre.next \r\n        if n <= 1:\r\n            return dummy.next\r\n        num = k % n\r\n        if num == 0:\r\n            return dummy.next\r\n        preN = dummy\r\n        head = dummy.next\r\n        while n-num-1 >= 0:\r\n            head = head.next\r\n            preN = preN.next\r\n            num += 1\r\n        preN.next = None\r\n       \r\n        pre.next = dummy.next\r\n        return head\r\n        \r\nTime complexity O(n), space complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185258544","body":"# LC989. Add to Array-Form of Integer\n## Main Idea\nFirst, it looks like we can convert the array `num` to integer and add it to `k`, but `num.length <= 1E+4` so this approach will cause integer overflow. So we will have to do the addition in array form.\n\nThen the idea is to simulate the entire process, add each digit of `num` and `k` with a `carry` bit. We will terminate the loop when we run out of digits for both `num` and `k` and `carry == 0`.\n\n## Code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int ptr = num.length - 1, carry = 0;\n        List<Integer> ret = new ArrayList<>();\n        while (ptr >= 0 || k > 0 || carry > 0) {\n            int d1 = ptr >= 0 ? num[ptr] : 0;\n            int d2 = k % 10;\n            int sum = d1 + d2 + carry;\n            ret.add(sum % 10);\n            ptr--;\n            k /= 10;\n            carry = sum >= 10 ? 1 : 0;\n        }\n        \n        Collections.reverse(ret);\n        return ret;\n    }\n}\n```\n\n## Complexity Analysis\nTime: `O(2*max(N, log(K)))`\n* Given a number `K`, its length will be `O(log_{2}(K))`, the time complexity depends on the length of `N` and `K`, whichever is longer.\n* Notice we want to insert digits at the end of the array and then reverse it after we finish the addition (reverse takes `O(res.size())`). If we insert at the head of array, then it will take `O(n^2)` of time.\n\nSpace: `O(1)`, as we didn't use additional spaces except the return array.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186129158","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(), count = Integer.MAX_VALUE;\n        int[] ret = new int[n];\n        Arrays.fill(ret, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        count = Integer.MAX_VALUE;\n        for (int i = n - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                count = 0;\n            }\n            \n            ret[i] = Math.min(ret[i], count);\n            if (count != Integer.MAX_VALUE)\n                count++;\n        }\n        \n        return ret;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186426699","body":"```java\nclass CustomStack {\n    private Deque<Integer> stack;\n    private int[] arr;\n    public CustomStack(int maxSize) {\n        stack = new ArrayDeque<>();\n        arr = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (stack.size() < arr.length) {\n            stack.push(x);\n        } \n    }\n    \n    public int pop() {\n        if (stack.isEmpty()) {\n            return -1;\n        }\n        int index = stack.size() - 1, ret = stack.pop() + arr[index];\n        if (index > 0) {\n            arr[index - 1] += arr[index];\n        }\n        arr[index] = 0;\n        return ret;\n    }\n    \n    public void increment(int k, int val) {\n        k = Math.min(k - 1, stack.size() - 1);\n        if (k >= 0) {\n            arr[k] += val;\n        }\n    }\n}\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191155942","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null) {\n            return head;\n        }\n        int n = getLen(head);\n        k %= n;\n        if (k == 0) {\n            return head;\n        }\n        \n        ListNode fast = head, slow = head;\n        for (int i = 0; i < k; i++) {\n            fast = fast.next;\n        }\n\n        while (fast.next != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        fast.next = head;\n        ListNode ret = slow.next;\n        slow.next = null;\n        return ret;\n    }\n    \n    private int getLen(ListNode head) {\n        int ret = 0;\n        while (head != null) {\n            ret++;\n            head = head.next;\n        }\n        return ret;\n    }\n}\n```\n\nTime: `O(n)`\n\nSpace: `O(1)`","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185259516","body":"- Time: $O(N)$, N is $max(num.size(), ceil(log(k)))$\n- Space: $O(1)$, no extra space is used apart from the output array.\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        res.reserve(num.size());\n        int p = num.size() - 1;\n\n        while (p >= 0 || k > 0) {\n            if (p >= 0) k += num[p--];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186111046","body":"- Time: $O(N)$\n- Space: $O(1)$\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> res(n, n);\n        \n        if (s[0] == c) res[0] = 0;\n\n        for (int i = 1; i < n; i++)\n            res[i] = s[i] == c ? 0 : res[i - 1] + 1;\n\n        for (int i = n - 2; i >= 0; i--)\n            res[i] = min(res[i], res[i + 1] + 1);\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387195","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `increment` $O(1)$\r\n- Space: $O(N)$, N is maxSize\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : capacity_(maxSize) {\r\n        inc_ = vector<int>(capacity_, 0);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top_ == capacity_ - 1) return;\r\n        stk_.push(x);\r\n        top_++;\r\n    }\r\n    \r\n    int pop() {\r\n        if (top_ == -1) return -1;\r\n\r\n        int x = stk_.top(); stk_.pop();\r\n        x += inc_[top_];\r\n\r\n        if (top_ > 0) \r\n            inc_[top_ - 1] += inc_[top_];\r\n        inc_[top_--] = 0;\r\n\r\n        return x;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        k = min(k - 1, top_);\r\n        if (k > -1) inc_[k] += val;\r\n    }\r\nprivate:\r\n    int capacity_;\r\n    int top_ = -1;\r\n    stack<int> stk_;\r\n    vector<int> inc_;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186696536","body":"- Time: $O(N)$. N is the length of the decoded string\n- Space: $(O(N)$. N is the length of the decoded string. This is the space used by the `tokens` stack.\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> tokens;\n\n        for (char c : s) {\n            if (c != ']') {\n                tokens.push(string(1, c));\n                continue;\n            }\n\n            // get the repeat patern\n            // everything after \"[\"\n            string p;\n            while (!tokens.empty() && tokens.top() != \"[\") {\n                p += tokens.top();\n                tokens.pop();\n            }\n            // pop out the \"[\"\n            tokens.pop();\n\n            // get the repeat number\n            // which comes right before the \"[\"\n            string num;\n            while (!tokens.empty() && isNumber(tokens.top())) {\n                num = tokens.top() + num;\n                tokens.pop();\n            }\n\n            // repeat the pattern string and put it back to the stack\n            tokens.push(repeat(stoi(num), p));\n        }\n\n        return join(tokens);\n    }\nprivate:\n    bool isNumber(const std::string& s) {\n        auto it = s.begin();\n        while (it != s.end() && std::isdigit(*it)) ++it;\n        return !s.empty() && it == s.end();\n    }\n\n    string repeat(int k, string s) {\n        string res;\n        while (k) {\n            res += s;\n            k--;\n        }\n        return res;\n    }\n    \n    string join(stack<string> stk) {\n        string res;\n        while (!stk.empty()) {\n            res += stk.top();\n            stk.pop();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188510676","body":"- Time: `push` $O(1)$, `pop` $O(1)$, `peek` $O(1)$\n- Space: $O(N)$\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        write_.push(x);\n    }\n    \n    int pop() {\n        if (read_.empty()) pour();\n        int x = read_.top();\n        read_.pop();\n        return x;\n    }\n    \n    int peek() {\n        if (read_.empty()) pour();\n        return read_.top();\n    }\n    \n    bool empty() {\n        return read_.empty() && write_.empty();\n    }\nprivate:\n    void pour() {\n        while (!write_.empty()) {\n            read_.push(write_.top());\n            write_.pop();\n        }\n    }\n\n    stack<int> read_;\n    stack<int> write_;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189729951","body":"- Time: $O(N)$, N is the size of arr.\r\n- Space: $O(N)$, the space used by the stack.\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        // a non-strictly increasing stack\r\n        stack<int> stk;\r\n        for (int n : arr) {\r\n            if (stk.empty() || n >= stk.top()) {\r\n                stk.push(n);\r\n            } else {\r\n                int top = stk.top(); stk.pop();\r\n                while (!stk.empty() && stk.top() > n)\r\n                    stk.pop();\r\n                stk.push(top);\r\n            }\r\n        }\r\n        return stk.size();\r\n    }\r\n};\r\n```\r\n\r\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190952790","body":"- Time: $O(N)$, N is the length of the list. In worst case the list is traversed twice.\n- Space: $O(1)$\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        if (!head || !head->next || k == 0) return head;\n\n        ListNode *rotated_head, *cur;\n        int n = 1;\n\n        cur = head;\n        while (cur->next) {\n            cur = cur->next;\n            n++;\n        }\n\n        k = n - k % n;\n        cur->next = head; // connect the tail and the head\n        while (k--) cur = cur->next;\n\n        rotated_head = cur->next;\n        cur->next = nullptr;\n        return rotated_head;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mirrors-cl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185287919","body":"思路\r\n按照 正常的手写加法的逻辑做的只是好像机器化了，感觉自己好弱\r\ncode\r\n```\r\nvar addToArrayForm = function(num, k) {\r\nconst res = [] \r\nvar str = k.toString();\r\nvar arr = str.split(\"\")\r\narr = arr.map(Number)\r\nlet carry = 0;\r\nlet l1 = num.length -1\r\nlet l2 = arr.length -1\r\nwhile(l1>=0 || l2>=0){\r\n    let x = l1 < 0 ? 0 : num[l1]\r\n    let y = l2 < 0 ? 0 : arr[l2]\r\n    let sum = x + y + carry\r\n    res.push(sum % 10)\r\n    carry = Math.floor(sum/10)\r\n    l1--\r\n    l2--\r\n}\r\nif(carry != 0 )res.push(carry)\r\nreturn res.reverse()\r\n\r\n};\r\n```\r\n复杂程度\r\n 还没学会怎么算基础有些差","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189052507","body":"```\nvar MyQueue = function() {\n    this.inarray = []\n    this.outarray2 = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inarray.push(x)\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  const size = this.outarray2.length;\n   if(size) {//push的时候判断输出栈是否为空\n       return this.outarray2.pop();//不为空则输出栈出栈\n   }\n   while(this.inarray.length) {//输出栈为空，则把输入栈所有的元素加入输出栈\n       this.outarray2.push(this.inarray.pop());\n   }\n   return this.outarray2.pop();\n\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n const x = this.pop();//查看队头的元素 复用pop方法，然后在让元素push进输出栈\n   this.outarray2.push(x);\n   return x;\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n   return !this.inarray.length && !this.outarray2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xqy97":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185331610","body":"## 题目描述\nhttps://leetcode.cn/problems/add-to-array-form-of-integer/\n\n## 解题思路\n\n###逐位相加，记录进位\n\n\n####难点\n1. 数字怎么按位拆分\n   * **数字不用拆分**\n    * **num[i] + k % 10 先相加再%10**\n2. 数组和数字位数不同时怎么处理\n   * 开始打算取位数最多的，其实只用对没加完的数字单独处理\n3. 进位处理\n    * 加到数字上\n    \n####js代码\n```javascript\n  var addToArrayForm = function(num, k) {\n  const res = []\n    \n  for(let i = num.length - 1; i>=0; i--) {\n      let sum = num[i] + k % 10\n      k = Math.floor(k / 10)\n      if (sum > 9) {\n        k++\n        res.push(sum % 10)\n      } else {\n        res.push(sum)\n      }\n  }\n  while(k) {\n      res.push(k%10)\n      k = Math.floor(k/10)\n  }\n  return res.reverse()\n  \n};\n```\n####复杂度\n* 时间复杂度 O(max(num.length, log k))\n* 空间复杂度 O(1)\n\n## 加法模版\n```\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\nwhile ( A 没完 || B 没完)\nA 的当前位\nB 的当前位\n\n    和 = A 的当前位 + B 的当前位 + 进位carry\n\n    当前位 = 和 % 10;\n    进位 = 和 / 10;\n\n判断还有进位吗\n```\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165018","body":"## 题目描述\nhttps://leetcode.cn/problems/shortest-distance-to-a-character/\n## 解题思路\n\n记录字符c出现的下标，遍历比较最短距离\n\n\n###我的暴力解法（👎👎👎\n\n####js代码\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n        let indexList = []\n        let res = []\n        for(let i = 0; i < s.length; i++) {\n            if (s[i] === c) {\n                indexList.push(i)\n                res[i] = 0\n            }\n        }\n        let k = 0\n        for(let i = 0; i < s.length; i++) {\n            if(!indexList.includes(i)) {\n                while(k+1 < indexList.length && Math.abs( indexList[k] - i) > Math.abs(indexList[k+1] - i)) {\n                    k += 1\n                }\n                res[i] =  Math.abs( indexList[k] - i)\n            }\n        }\n        return res\n    };\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n###官方题解\n\n- 双向遍历\n- 问题可以转换成，对s的每个下标i，求 \\\n    s[i]  到其左侧最近的字符 cc 的距离\\\n    s[i]  其右侧最近的字符 cc 的距离 \\\n  这两者的最小值。\n  \n####难点：\n在开始遍历的时候，不知道第一个等于目标字符的index在哪，为了简化逻辑，我们可以用 -n 或 2n 表示，这里 n 是 s 的长度。\n确保每一位到index的距离 >= n\n取n的话从右遍历，最小距离为1\n\n####js代码\n```javascript\nvar shortestToChar = function(s, c) {\n    let n = s.length\n    let res = new Array(n).fill(0)\n    for(let i = 0, index = 2*n; i < s.length; i++) {\n        if (s[i] === c) {\n            index = i\n        } else {\n            res[i] = Math.abs(i - index)\n        }\n    }\n    \n    for(let i = s.length - 1,index = 2*n; i >= 0; i--) {\n       if (s[i] === c) {\n           index = i\n       } else {\n           res[i] = Math.min(res[i], Math.abs(i - index))\n       }\n    }\n    return res\n};\n```\n####复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(1)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186513644","body":"## 题目描述\nhttps://leetcode.cn/problems/design-a-stack-with-increment-operation/\n\n## 解题思路\n用数组模拟栈，用变量记录栈顶位置\n\n\n####js代码\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n        this.res = new Array()\n        this.add = new Array()\n        this.maxSize = maxSize\n        this.top = -1\n    };\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n\n    if (this.top < this.maxSize - 1) {\n        ++this.top\n        this.res[this.top] = x\n        this.add[this.top] = 0\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.top >= 0) {\n        const item = this.res[this.top] + this.add[this.top]\n        this.top--\n        return item\n    }\n    return -1\n\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(k, this.top+1); i++) {\n        this.add[i] +=  val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n####复杂度\n* 时间复杂度 O(1)\n* 空间复杂度 O(maxSize)\n\n\n\n     \n  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622403","body":"### 题目描述\nhttps://leetcode.cn/problems/decode-string/\n\n### 解题思路\n把 ']' 当作出栈信号\n\n### 代码\n```javascript\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    const isNum = (n) => Number(n) >= 0 && Number(n) <= 9\n    let res=''\n    for(i=0; i<s.length; i++) {\n        if (s[i] !== ']') {\n            stack.push(s[i])\n        } else {\n            let str=''\n            let num=''\n            let str2=''\n            while(stack[stack.length - 1] !== '[') {\n                str = stack[stack.length - 1] + str\n                stack.length--\n            }\n            stack.length--\n            while(isNum(stack[stack.length - 1])) {\n                num = stack[stack.length - 1] + num\n                stack.length--\n            }\n            while(Number(num) > 0) {\n                str2 = str2 + str\n                num--\n            }\n            stack.push(str2)\n        }\n    }\n    for(i=0;i<stack.length;i++) {\n        res= res+stack[i]\n    }\n    return res\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188559217","body":"var MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2.pop()\n};\nMyQueue.prototype.peek = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            const i = this.stack1.pop()\n            this.stack2.push(i)\n        }\n    }\n    return this.stack2[this.stack2.length - 1]\n};\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190452579","body":"## 题目描述\nhttps://leetcode.cn/problems/max-chunks-to-make-sorted-ii/\n\n## 解题思路\n每块尽可能分小，后一块的数字必须比前一快的数字大，\n因为有重复数字，所以重复数字可以单独分一块，\n因为需要比较前后元素大小，所以联想到单调栈\n\n## 单调递增栈\n\n```javascript\nfor (遍历这个数组)\n{\n\tif (栈空 || 栈顶元素大于等于当前比较元素) {\n\t    入栈;\n\t} else {\n\t    while (栈不为空 && 栈顶元素小于当前元素) {\n                栈顶元素出栈;\n                更新结果;\n\t    }\n\t    当前数据入栈;\n\t}\n}\n```\n\n## 代码\n```javascript\nvar maxChunksToSorted = function(arr) {\n    let stack = []\n    for(let i = 0; i < arr.length; i++) {\n        if (!stack.length || arr[i] >= stack[stack.length - 1]) {\n            stack.push(arr[i])\n        } else {\n            const last = stack.pop()\n            while(stack[stack.length - 1] > arr[i]) {\n                stack.pop()\n            }\n            stack.push(last)\n        }\n    }\n    return stack.length\n};\n```\n\n##复杂度\n* 时间复杂度 O(n)\n* 空间复杂度 O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jakkiabc":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185338763","body":"自己用进位遍历的方法没跑出来，待会再想想= =\r\n暂时用  list→str→int 来计算sum 最后再转换回list \r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=int(''.join([str(x)for x in num]))\r\n        sum=n+k\r\n        return list(map(int,str(sum)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186190071","body":"先找到相同元素的位置，然后分别向左向右遍历找到min最小距离\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        start=[0 if a==c else n for a in s]\r\n        for i in range(1,n):\r\n            start[i]=min(start[i],start[i-1]+1)\r\nfor i in range(n-2,-1,-1):\r\n            start[i]=min(start[i],start[i+1]+1)\r\n        return start","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551571","body":"思路：差分数组\r\n`\r\n\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.nums = []\r\n\r\n    def push(self, x: int) -> None:\r\n      \r\n        if not self.nums:\r\n            self.nums.append(x)\r\n        else:\r\n            self.nums[-1] = self.nums[-1] - x\r\n            self.nums.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.nums:\r\n            return -1\r\n        x = self.nums.pop()\r\n        if self.nums:\r\n            self.nums[-1] += x\r\n        return x\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if not self.nums:\r\n            return\r\n        if len(self.nums) >= k:\r\n            self.nums[k - 1] += val\r\n        else:\r\n            self.nums[-1] += val\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187667410","body":"利用栈的性质（参考题解 \r\n\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387810","body":"思路：双指针遍历\r\n``\r\n\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head or not head.next:\r\n            return head\r\n        len=0\r\n        tail=head\r\n        while tail:\r\n            len+=1\r\n            tail=tail.next //求链表长度\r\n        k %=len \r\n        if k==0:\r\n            return head\r\n        fast,slow=head,head 双指针遍历\r\n        while k:\r\n            fast=fast.next\r\n            k-=1  //fast与slow距离k\r\n        while fast.next:\r\n            fast=fast.next\r\n            slow=slow.next \r\n        newHead=slow.next //新节点\r\n        slow.next=None 指向尾端\r\n        fast.next=head\r\n        return newHead``","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyoneday":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185356088","body":"## 思路\r\n\r\n0 <= K <= 10000，可直接加 1，不需要大数相加\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar addToArrayForm = function (num, K) {\r\n    const len = num.length || 0;\r\n    let numK = K;\r\n    const result = [];\r\n\r\n    for (let i = len - 1; i >= 0; i--) {\r\n        const a = num[i];\r\n        const b = numK % 10;\r\n       \r\n        let total = a + b;\r\n        numK = total >= 10 ? parseInt(numK / 10) + 1 : parseInt(numK / 10);\r\n        result[i] = total % 10;\r\n    }\r\n    while (numK > 0) {\r\n        result.unshift(numK % 10);\r\n        numK = parseInt(numK / 10);\r\n    }\r\n\r\n    return result;\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n时间复杂度: O(n)\r\n空间复杂度: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186194360","body":"## 思路\r\n\r\n从左向右遍历，记录字符右侧的距离；从右向左遍历，获取字符左侧的距离和之前距离的较小值。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  const tempArr = [];\r\n  const len = s.length;\r\n  let idx = -1;\r\n  for (let i = 0; i < len; i++) {\r\n    if (s[i] === c) {\r\n      idx = i;\r\n      tempArr[i] = 0;\r\n    } else if (idx === -1) {\r\n      tempArr[i] = Infinity;\r\n    } else {\r\n      tempArr[i] = i - idx;\r\n    }\r\n  }\r\n\r\n  idx = Infinity;\r\n  for (let i = len - 1; i > -1; i--) {\r\n    const val = tempArr[i];\r\n\r\n    if (s[i] === c) {\r\n      idx = i;\r\n    } else if (val > idx - i) {\r\n      tempArr[i] = idx - i ;\r\n    }\r\n  }\r\n\r\n  return tempArr;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186497063","body":"## 思路\r\n\r\n数据模拟栈。\r\n\r\n## 代码 js\r\n\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n  this.stack = [];\r\n  this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.stack.length < this.size) {\r\n    this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.stack.length === 0) {\r\n    return -1;\r\n  } else {    \r\n    return this.stack.pop();\r\n  }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  const len = k > this.stack.length ? this.stack.length : k;\r\n  for (let i = 0; i < len; i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度:  push, pop = O(1), increment = O(min(k, length))\r\n- 空间复杂度:  O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187015228","body":"## 思路 \r\n\r\n字符入栈，遇到 `]` 出栈\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar decodeString = function(s) {\r\n    const stack = [];\r\n\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] !== ']') {\r\n            stack.push(s[i]);\r\n        } else {\r\n            let result = \"\";\r\n            let tempStr = \"\";\r\n            let num = \"\";\r\n            while (stack[stack.length - 1] !== '[') {\r\n                const c = stack.pop();\r\n                tempStr = c + tempStr;\r\n            }\r\n            stack.pop();\r\n            while (/\\d/.test(stack[stack.length - 1]) && stack.length >= 0) {\r\n                const n = stack.pop();\r\n                num = n + num;\r\n            }\r\n            \r\n            for (let i = 0; i < +num; i++) {\r\n                result += tempStr;\r\n            }\r\n\r\n            for (let j = 0; j < result.length; j++) {\r\n                stack.push(result[j]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    return stack.join(\"\");\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)， n 为解码后的字符串长度\r\n- 空间复杂度 O(n)， n 为解码后的字符串长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188548383","body":"## 思路\r\n\r\n用两个栈模拟队列\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack.pop();\r\n    const len2 = temStack.length;\r\n    for (let j = 0; j < len2; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    const temStack = [];\r\n    const len = this.stack.length;\r\n    for (let i = 0; i < len; i++) {\r\n        temStack.push(this.stack.pop());\r\n    }\r\n    const res = temStack[len - 1];\r\n    for (let j = 0; j < len; j++) {\r\n        this.stack.push(temStack.pop());\r\n    }\r\n\r\n    return res;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack.length === 0;\r\n};\r\n\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190345234","body":"## 思路\r\n\r\n使用单调栈，遇到大于等于栈顶元素直接加入栈。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar maxChunksToSorted = function (arr) {\r\n  const stack = [];\r\n  for (let i = 0; i < arr.length; i++) {\r\n    const lastMax = stack[stack.length - 1];\r\n    if (i === 0) {\r\n      stack.push(arr[i]);\r\n    } else if (arr[i] >= stack[stack.length - 1]) {\r\n      stack.push(arr[i]);\r\n    } else {\r\n      while (arr[i] < stack[stack.length - 1] && stack.length) {\r\n        stack.pop()\r\n      }\r\n      stack.push(lastMax)\r\n    }\r\n  }\r\n  return stack.length;\r\n};\r\n```\r\n\r\n## 复杂度分析\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191111224","body":"## 思路\r\n\r\n先拿到长度，通过旋转值计算出需要截断的部分。\r\n\r\n## 代码 js\r\n\r\n```js\r\nvar rotateRight = function (head, k) {\r\n  if (!(head && head.next)) return head;\r\n  if (k === 0) return head;\r\n  let node = head;\r\n  const node4 = head;\r\n  let len = 1;\r\n  while (node.next) {\r\n    len++;\r\n    node = node.next\r\n  }\r\n\r\n    let newLen = k % len === 0 ? 0 : Math.abs(len - k % len);\r\n  if (newLen === 0) return node4;\r\n  while (newLen > 1) {\r\n    newLen--;\r\n    head = head.next;\r\n  }\r\n\r\n  let node3 = head.next;\r\n  head.next = null;\r\n  const node5 = node3;\r\n\r\n  while (node3 && node3.next) {\r\n    node3 = node3.next;\r\n  }\r\n  if (node3) {\r\n    node3.next = node4;\r\n  }\r\n \r\n  return node5;\r\n};\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chouqin99":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185362278","body":"思路:想把数组直接转成int，然后用加法加完了，再转换回来，但是貌似不是题目要的\r\ncode：\r\n`\r\n  #!/usr/bin/env python\r\n  \"\"\"add\"\"\"\r\n  \r\n  import os\r\n  from os import sys, path\r\n  \r\n  class Add(object):\r\n  \r\n      def list2str(self, inlist):\r\n          outstr = \"\"\r\n          for i in inlist:\r\n              outstri = ''.join(str(i))\r\n              outstr = outstr + outstri\r\n          return outstr\r\n\r\n      def add(self, x, k):\r\n          str_x = self.list2str(x)\r\n          str_k = self.list2str(k)\r\n          addint = int(str_x) + int(str_k)\r\n          return addint\r\n\r\n      def str2list(self, instr):\r\n          outlist = list(instr)\r\n          return outlist\r\n\r\n      def main(self, x, k):\r\n          addint = self.add(x, k)\r\n          outlist = self.str2list(str(addint))\r\n          print outlist\r\n\r\n  if __name__ == '__main__':\r\n      x = [1,1,0,0]\r\n      k = [3,4]\r\n      r = Add()\r\n      r.main(x,k)\r\n\r\n`","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216992","body":"## 思路\r\n  学习官方解题方式\r\n##代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        n = len(s)\r\n        res = [0 if s[i] == c else None for i in range(n)]\r\n\r\n        for i in range(1, n):\r\n            if res[i] != 0 and res[i - 1] is not None:\r\n                res[i] = res[i - 1] + 1\r\n\r\n        for i in range(n - 2, -1, -1):\r\n            if res[i] is None or res[i + 1] + 1 < res[i]:\r\n                res[i] = res[i + 1] + 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547277","body":"## 思路\r\n学习栈\r\n\r\n##代码\r\n\r\n```python\r\n    def __init__(self, size: int):\r\n        self.st = []\r\n        self.cnt = 0\r\n        self.size = size\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.size:\r\n            self.st.append(x)\r\n            self.cnt += 1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0: return -1\r\n        self.cnt -= 1\r\n        return self.st.pop()\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(0, min(self.cnt, k)):\r\n            self.st[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187661561","body":"## 思路\n学习官方解决\n\n##代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190463845","body":"## 思路\r\n官方学习\r\n```python\r\n    def maxChunksToSorted(self, arr):\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        ans = 0\r\n\r\n        for a, b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b: ans += 1\r\n\r\n        return ans\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhaogeg111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185368348","body":"解题思路\n\n- 整数的 数组形式  num 是按照从左到右的顺序表示其数字的数组。\n  例如，对于 num = 1321 ，数组形式是 [1,3,2,1] 。\n给定 num ，整数的 数组形式 ，和整数 k ，返回 整数 num + k 的 数组形式 。\n\n解题代码\n\n    int* addToArrayForm(int* num, int numSize, int k, int* returnSize){\n        int ksize = 0;//预设k的位数为0\n        int ktmp = k;\n        while(ktmp)      //得到k的位数\n        {\n            ksize++;\n            ktmp /= 10;\n        }\n        int size = numSize > ksize ? numSize + 1 : ksize + 1;   //开辟一个多+1位置的数组，防止有进位\n    \n        int* a = (int*)malloc(size*sizeof(int));\n    \n        int end = numSize - 1;//创建一个下标指向num数组的最后一个元素 \n        int carry = 0;\n        int i = 0;\n        while(end >= 0 || k > 0)   //2个有1个没有遍历完\n        {\n            if(end >= 0)\n            {\n                a[i] = carry + num[end] + k % 10;\n            }//num[end]为数组的最后一个元素 k%10 为k的最后一位\n            else\n            {\n                a[i] = carry + k % 10;\n            }\n    \n            if(a[i] >= 10)\n            {\n                a[i] = a[i] - 10;\n                carry = 1;//有进位\n            }\n            else\n            {\n                carry = 0;//carry=1表示进位为，0表示不进位\n            }\n            k /= 10;\n            end--;\n            i++;\n        }\n        if(carry == 1)\n        {\n            a[i++] = 1;\n        }\n    \n        int left = 0;\n        int right = i - 1;\n        while(left < right)\n        {\n            int tmp = a[left];\n            a[left] = a[right];\n            a[right] = tmp;\n            left++;\n            right--;\n        }//数组逆序\n    \n        *returnSize = i;\n        return a;\n    \n    }\n\n时间复杂度\n\nO（n^2)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159638","body":"### 题目描述\n\n````\n```\n给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。\n\n示例 1:\n\n输入: S = \"loveleetcode\", C = 'e'\n输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]\n说明:\n\n- 字符串 S 的长度范围为 [1, 10000]。\n- C 是一个单字符，且保证是字符串 S 里的字符。\n- S 和 C 中的所有字母均为小写字母。\n\n```\n````\n\n### 解题思路\n\n1. 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n2. 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n3. 比较1和2得出最短距离。找到速度最快的距离\n\n### 解题代码\n\n```c\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint *shortestToChar(char *s, char c, int *returnSize)\n{\n    int i, index;\n    int len = strlen(s);\n    int *p = (int *)malloc(len * sizeof(int));\n    if (p == NULL) {\n        return NULL;\n    }\n    memset(p, 0, len * sizeof(int));\n\n    // 从左到右遍历i，找出下标i到离它左侧最近的字符c的距离\n    index = -len; // 初始为-len，第一次遍历时，可能没有找到\n    for (i = 0; i < len; i++) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = i - index; // 求出距离\n    }\n\n    // 从右到左遍历i，找出下标i到离它右侧最近的字符c的距离\n    index = 2 * len; // 初始为2*len，第一次遍历时，可能没有找到\n    for (i = len - 1; i >= 0; i--) {\n        if (s[i] == c) {\n            index = i; // 更新index\n        }\n        p[i] = fmin(p[i], index - i); // 求出距离，并比较得出最短距离\n    }\n\n    *returnSize = len;\n    return p;\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186496698","body":"### 题目思路\n\n1、正常建立一个数组，记录当前的index和最大值，维护一个栈，如果需要统一加一个值，就直接for循环遍历\n2、正常建立两个数组，第一个数组用来存当前的入栈元素，第二个数组用来存当前index及小于该index值的元素需要加的数\ntypedef struct {\n    int maxnum;\n    int curInex;\n    int *arry;\n    int *increment;\n} CustomStack;\n\n\nCustomStack* customStackCreate(int maxSize) {\n    CustomStack *stacktmp = (CustomStack *)malloc(sizeof(CustomStack));\n    stacktmp->maxnum = maxSize;\n    stacktmp->curInex = 0;\n    stacktmp->arry = (int *)malloc(sizeof(int) * maxSize);\n    stacktmp->increment = (int *)malloc(sizeof(int) * maxSize);\n    memset(stacktmp->arry, 0, sizeof(int) * maxSize);\n    memset(stacktmp->increment, 0, sizeof(int) * maxSize);\n    return stacktmp;\n}\n\nvoid customStackPush(CustomStack* obj, int x) {\n    if ((obj == NULL) || (obj->curInex == obj->maxnum)) {\n        return;\n    }\n    obj->arry[obj->curInex] = x;\n    obj->curInex++;\n}\n// 3 100\nint customStackPop(CustomStack* obj) {\n    if ((obj == NULL) || (obj->curInex == 0)) {\n        return -1;\n    }\n    obj->curInex--;\n    int returnNum = obj->arry[obj->curInex] + obj->increment[obj->curInex];\n    if (obj->curInex) {\n        obj->increment[obj->curInex - 1] += obj->increment[obj->curInex];\n    }\n    obj->increment[obj->curInex] = 0;\n    return returnNum;\n}\n// 1,2,3 100 k = 3 num - 1 = 2\nvoid customStackIncrement(CustomStack* obj, int k, int val) {\n    if (obj == NULL || obj->curInex == 0) {\n        return;\n    }\n    int num = k < obj->curInex ? k : obj->curInex;\n    obj->increment[num - 1] += val;\n}\n\nvoid customStackFree(CustomStack* obj) {\n    free(obj->arry);\n    free(obj);\n}\n\n","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189746866","body":"int maxChunksToSorted(int *arr, int arrSize)\n{\n    /* 初始化循环变量x从数组右边开始往左，t为无穷大。 */\n    int x = arrSize - 1, t = INT_MAX, result = 0;\n    int rightMin[arrSize];\n\n    /* 先计算每个arr[x]右边的最小值，不包括arr[x]在内。 */\n    while(0 <= x)\n    {\n        rightMin[x] = t;\n        if(t > arr[x])\n        {\n            t = arr[x];\n        }\n        x--;\n    }\n\n    /* 然后从左往右再遍历一次。此时，t的含义变为，[0,x]范围内的最大值，初始化为arr[0]。 */\n    t = arr[0];\n    x = 0;\n    while(arrSize > x)\n    {\n        if(t < arr[x])\n        {\n            t = arr[x];\n        }\n        /* 当发现当前为止的最大值，不大于rightMin[x]时，即可切一刀。 */\n        if(t <= rightMin[x])\n        {\n            result++;\n        }\n        x++;\n    }\n\n    return result;\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnhu23":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185371267","body":"## Idea\r\niterate through the num array, add each digit to k , add the rightmost digit into the result list\r\n## Code\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int len = num.length;\r\n        for (int i = len-1; i >= 0; i--) {\r\n            k += num[i];\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            res.add(k % 10);\r\n            k /= 10;\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185991579","body":"##  Idea\r\nIterate from left to right, and then iterate from right to left\r\n## Code\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        char[] str = s.toCharArray();\r\n        int n = str.length;\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, Integer.MAX_VALUE);\r\n        for (int i = 0; i < n; i++) {\r\n            if (str[i] == c) {\r\n                res[i] = 0;\r\n            }\r\n            if (i < n-1 && res[i] != Integer.MAX_VALUE) {\r\n               res[i+1] = Math.min(res[i]+1, res[i+1]); \r\n            }\r\n        }\r\n        for (int i = n-1; i > 0; i-- ) {\r\n            if (res[i] != Integer.MAX_VALUE) {\r\n                res[i-1] = Math.min(res[i-1], res[i]+1);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n## Complexity\r\ntime: O(n)\r\nspace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186350565","body":"## Idea\r\nImplement with an array and keep track of current position. For increment, use an offset array and an int instead of incrementing all bottom k elements.\r\n## Code\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] offset;\r\n    int cur;\r\n    int diff;\r\n    \r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        offset = new int[maxSize];\r\n        cur = 0;\r\n        diff = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (cur == stack.length) return;\r\n        if (cur > 0) {\r\n            offset[cur-1] += diff;\r\n        }\r\n        diff = 0;\r\n        stack[cur] = x;\r\n        offset[cur] = 0;\r\n        cur++;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (cur == 0) return -1;\r\n        int res = stack[cur-1];\r\n        diff += offset[cur-1];\r\n        cur--;\r\n        return res+diff;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if (cur == 0) return;\r\n        int min = Math.min(k , cur);\r\n        offset[min-1] += val;\r\n    }\r\n    \r\n}\r\n```\r\n## Complexity\r\nTime: push O(1) , pop O(1), increment O(1)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186912390","body":"## Idea\ntwo stacks, one for number of repetition and one for the string\n## Code\n```\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<String> s2 = new Stack<>();\n        char[] str = s.toCharArray();\n        String res = \"\";\n        for (int i = 0; i < str.length; i++) {\n            if (str[i] >= '0' && str[i] <= '9') {\n                int num = 0;\n                while (str[i] >= '0' && str[i] <= '9') {\n                    num = num * 10 + (str[i] - '0');\n                    i++;\n                }\n                s1.push(num);\n                i--;\n            }\n            else if (str[i] == '[') {\n                s2.push(res);\n                res = \"\";\n            }\n            else if (str[i] == ']') {\n                int num = s1.pop();\n                StringBuilder sb = new StringBuilder(s2.pop());\n                for (int j = 0; j < num; j++) {\n                    sb.append(res);\n                }\n                res = sb.toString();\n            }\n            else {\n                res += str[i];\n            }\n        }\n        return res;\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188375666","body":"## Idea\r\nuse the second stack to retrieve the top element\r\n## Code\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    \r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n) for pop, peek and empty, O(1) for push\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189985198","body":"## Idea\nuse a monotonically increasing stack and store the max element for each chunk, return the size of chunk.\n\n## Code\n```\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n        int curMax = 0;\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[i] < stack.peek()) {\n                stack.pop();\n            }\n            curMax = Math.max(curMax, arr[i]);\n            stack.push(curMax);\n        }\n        return stack.size();\n    }\n}\n```\n## Complexity\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191091660","body":"## Idea\r\ntreat k as k mod len and rotate the linkedlist\r\n## Code\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        ListNode cur = head, tail = head;\r\n        int len = 1;\r\n        while (cur.next != null) {\r\n            cur = cur.next;\r\n            len++;\r\n        }\r\n        cur.next = head;\r\n        k = k % len;\r\n        for (int i = 0; i < len - k - 1; i++) {\r\n            tail = tail.next;\r\n        }\r\n        cur = tail.next;\r\n        tail.next = null;\r\n        return cur;\r\n    }\r\n}\r\n```\r\n## Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ye2222":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185386008","body":"## Code\n```c++\nvector<int> addToArrayForm(vector<int>& num, int k) {\n    int n = num.size();\n    int count = n-1;\n    vector<int> res;\n    // 因为可能不是相同位数操作，所以要确保每一位都参加运算\n    while(count >= 0 || k != 0) {\n        // 对k进行操作比较方便，进行加法运行时会遵循加减法原则\n        if(count >= 0) {\n            k += num[count];\n            count--;\n        }\n        res.insert(res.begin(), k%10);\n        k /= 10;\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n) \n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186052432","body":"## 思路\n正向遍历，给字符c右边的字符赋值距离，遇到另一个字符c停止；反向遍历，计算距离，同样遇到另一个字符c停止，距离取最小值\n## Code\n```c++\nvector<int> shortestToChar(string s, char c) {\n    int n = s.size();\n    vector<int> res;\n    for(int i = 0; i < n; i++) res.push_back(100001);\n    // 正向遍历\n    for(int i = 0; i < n; i++) {\n        if(s[i] == c) {\n            res[i] = 0;\n            for(int j = i + 1; j < n; j++) {\n                if(s[j] != c) res[j] = j - i;\n                else break; \n            }\n        }\n    }\n    // 反向遍历\n    for(int i = n - 1; i >= 0; i--) {\n        if(s[i] == c) {\n            for(int j = i - 1; j >= 0; j--) {\n                if(s[j] != c) {\n                    int dis = i - j;\n                    if(res[j] > dis) res[j] = dis;\n                } \n                else break;\n            }\n        }\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n^2)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546066","body":"## Code\nclass CustomStack {\npublic:\n    int maxSize;\n    int a[1001];\n    int count;\n    CustomStack(int maxSize) {\n        this->maxSize = maxSize;\n        this->count = 0;\n    }\n    \n    void push(int x) {\n        if(count < maxSize) {\n            a[count++] = x;\n        } else {\n            return;\n        }\n    }\n    \n    int pop() {\n        if(count > 0) {\n            int res = a[count-1];\n            count--;\n            return res;\n        }  \n        else {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < count && i < k; i++) {\n            a[i]+=val;\n        }\n    }\n};\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186724001","body":"## 思路\n利用栈先进后出的特性，进行括号匹配，将生成的字符一并压入栈中进行处理\n## Code \n```c++\nint power(int x, int k) {\n    int pow = 1;\n    for(int i = 0; i < k; i++) {\n        pow *= 10;\n    }\n    return x * pow;\n}\n\nstring decodeString(string s) {\n    stack <char> stk;\n    int n = s.size();\n    bool isNum =true;\n    string s1 = \"\";\n    int i = 1;\n    stk.push(s[0]);\n    while(!stk.empty() && i < n) {\n        if (s[i] == ']') {\n            isNum = true;\n            // 重复的字符\n            while(stk.top() != '[') {\n                char c = stk.top();\n                stk.pop();\n                s1.insert(0, 1, c);\n            }\n            // 弹出左括号\n            stk.pop();\n            // 重复的次数\n            int count = 0, pow = 0;\n            while(!stk.empty() && stk.top() - '0' <= 9 && stk.top() - '0' >= 0) {\n                count += power(stk.top()-'0', pow);\n                pow++;\n                stk.pop();\n            }\n            // 重复压入栈中\n            while(count > 0) {\n                for(int i = 0; i < s1.size(); i++) {\n                    stk.push(s1[i]);\n                }\n                count--;\n            }\n            s1 = \"\";\n        }\n        else if(isNum && s[i] != '[') {\n            stk.push(s[i]);\n        } \n        else if (s[i] == '[') {\n            stk.push(s[i]);\n            isNum = false;\n        }\n        else{\n            stk.push(s[i]);\n        }\n        i++;\n    }\n\n    string res;\n    while(!stk.empty()) {\n        res.insert(0, 1, stk.top());\n        stk.pop();\n    }\n    return res;\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189038312","body":"## 思路\n使用两个单调栈，利用两个栈进行元素的逆置，达到输出队首的目的\n## Code\n```c++\nclass MyQueue {\npublic:\n    stack<int> stk;\n    stack<int> temp;\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        stk.push(x);\n    }\n    \n    int pop() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        temp.pop();\n        for(int i = 0; i < n - 1; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    int peek() {\n        if(stk.empty()) return -1;\n        int n = stk.size();\n        for(int i = 0; i < n; i++) {\n            temp.push(stk.top());\n            stk.pop();\n        }\n        int res = temp.top();\n        for(int i = 0; i < n; i++) {\n            stk.push(temp.top());\n            temp.pop();\n        }\n        return res;\n    }\n    \n    bool empty() {\n        if(stk.empty()) return true;\n        return false;\n    }\n};\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189740812","body":"## 思路\n利用分组排序与原数据排序的特点，寻找每一个分组的分界点（分组的最大值），利用单调栈进行计数，存入每个分组的最大值。\n## Code\n```c++\nint maxChunksToSorted2(vector<int>& arr) {\n    stack<int> stk;\n    stk.push(arr[0]);\n    for(int i = 1; i < arr.size(); i++) {\n        // 当前的数大于前面最大值的时候，可以建立一个新的分组\n        if(arr[i] >= stk.top()) {\n            stk.push(arr[i]);\n        } \n        // 当前的数小于前面最大值的时候，可以与前面大于当前值的数值组成一个分组\n        else {\n            int temp = stk.top();\n            stk.pop();\n            while(!stk.empty() && arr[i] < stk.top()) {\n                stk.pop();\n            }\n            stk.push(temp);\n        }\n    }\n    return stk.size();\n}\n```\n## 复杂度\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uyplayer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185419128","body":"## 思路\r\n\r\n每次遍历最后一个元素和k加起来，如果大于10的话 进行近位\r\n\r\n## 代码\r\n``` go\r\n\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // 每次遍历提取最后一个元素\r\n    for i:=len(num)-1;i>=0;i-- {\r\n        // 最后一个元素和k加起来\r\n        sum := num[i] + k\r\n        k = k / 10\r\n        // 判断sum是否大于10\r\n        if sum > 10 {\r\n            k ++\r\n            sum = sum - 10\r\n        }\r\n        ans = append(ans, sum)\r\n\r\n    }\r\n\r\n    for ; k > 0; k /= 10 {\r\n        ans = append(ans, k%10)\r\n    }\r\n    reverse(ans)\r\n    return\r\n   \r\n}\r\n\r\n// 反转\r\nfunc reverse(num []int) {\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n## 复杂度分析\r\n- 时间复杂度：O(max(n,logk))，其中 n 为数组的长度。\r\n\r\n- 空间复杂度：O(1) ，除了返回值以外，使用的空间为常数。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211992","body":"## LC 821. 字符的最短距离\r\n[Leetcode连接](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n\r\n- [额外数组记录下标](#solution1)\r\n\r\n### <span id=\"solution1\">额外数组记录下标</span>\r\n\r\n- 首先用额外的数组来保存目标字符在给定字符串的下边\r\n- 遍历给定字符串下边和上面保存的目标字符的下边，计算它们两个的距离，取最小的距离\r\n- 结果保存到另一个额外的数组\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nimport \"math\"\r\nimport \"fmt\"\r\nfunc shortestToChar(s string, c byte) []int {\r\n\r\n\r\n    // 选贤获取e的下边\r\n    e := make([]int,0)\r\n    for i:=0;i<len(s);i++{\r\n        if s[i] == c {\r\n           e = append(e,i) \r\n        }\r\n\r\n    }\r\n    fmt.Println(e)\r\n    // 结果\r\n    result := make([]int,0)\r\n\r\n    for i:=0;i<len(s);i++{\r\n        min := 99999999\r\n        for j:=0;j<len(e);j++{\r\n            // fmt.Println(math.Abs(float64(e[j]-j)))\r\n            distance := int(math.Abs(float64(e[j]-i)))\r\n            fmt.Println(distance)\r\n            if distance < min {\r\n                min =  distance\r\n            }\r\n        }\r\n        fmt.Println(min)\r\n        result = append(result,min)\r\n\r\n    }\r\n\r\n    return result\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186446312","body":"\r\n## LC 1381. 设计一个支持增量操作的栈\r\n[Leetcode连接](https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/)\r\n\r\n- [思路](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n\r\n这一道设计题，已经给定了max长度，我们第一个想象的的一个数组,数组来可以模拟一个栈和栈操作\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\n// 构造一个结构体\r\ntype CustomStack struct {\r\n    maxLen int\r\n\tarray []int\r\n\r\n}\r\n\r\n// 新建一个stack\r\nfunc Constructor(maxSize int) CustomStack {\r\n\r\n    stack := CustomStack{\r\n\t\tmaxLen: maxSize,\r\n\t\tarray: make([]int, 0),\r\n\t}\r\n\treturn stack\r\n}\r\n\r\n// puhs操作\r\nfunc (this *CustomStack) Push(x int)  {\r\n\r\n    if len(this.array) < this.maxLen {\r\n\t\tthis.array = append(this.array, x)\r\n\t}\r\n\r\n}\r\n\r\n// pop操作\r\nfunc (this *CustomStack) Pop() int {\r\n\r\n    if len(this.array) == 0 {\r\n\t\treturn -1\r\n\t}\r\n\tnum := this.array[len(this.array)-1]\r\n\tthis.array = this.array[:len(this.array)-1]\r\n\treturn num\r\n\r\n}\r\n\r\n// 增大栈\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n\r\n    if len(this.array) <= k {\r\n\t\tfor i := 0; i < len(this.array);i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t} else {\r\n\t\tfor i := 0; i < k;i++ {\r\n\t\t\tthis.array[i] += val\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：pop & push O(1)，Increment : O(k)\r\n- 空间复杂度：O(maxSize) ,array 等长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186659388","body":"## LC 394. 字符串解码\r\n[Leetcode连接](https://leetcode.cn/problems/decode-string/)\r\n\r\n- [分支方法](#solution1)\r\n\r\n### <span id=\"solution1\">分支方法</span>\r\n\r\n本题中可能出现括号嵌套的情况，比如 2[a2[bc]]，这种情况下我们可以先转化成 2[abcbc]，在转化成 abcbcabcbc。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。具体的做法是，遍历这个栈：\r\n\r\n- 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\r\n- 如果当前的字符为字母或者左括号，直接进栈\r\n- 如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字（此时栈顶一定是数字，想想为什么？），就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\n\r\nfunc decodeString(s string) string {\r\n    // 栈\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        // 如果是数字进栈\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n            // 如果是字母或者左口号进栈\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            // 下边往前走一步\r\n            ptr++\r\n        } else {\r\n            // 遇到右括号\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                // 出栈\r\n                sub = append(sub, stk[len(stk)-1])\r\n                // 更新str\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            // 反转 \r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            //   stk[len(stk)-1] != \"[\" 已经碰到右括号']'，去掉它\r\n            stk = stk[:len(stk)-1]\r\n            // 出栈 的时候数字\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            // 更新栈\r\n            stk = stk[:len(stk)-1]\r\n            // 重复\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            // 添加到数组中\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度： 记解码后得出的字符串长度为 SS，除了遍历一次原字符串 ss，我们还需要将解码后的字符串中的每个字符都入栈，并最终拼接进答案中，故渐进时间复杂度为O(S+∣s∣)，即 O(S) \r\n- 空间复杂度：记解码后得出的字符串长度为 SS，这里用栈维护 TOKEN，栈的总大小最终与 SS 相同，故渐进空间复杂度为 O(S)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189139221","body":"## LC 232. 用栈实现队列\r\n[Leetcode连接](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n\r\n- [双栈模拟队列](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n通过双栈模拟队列\r\n- push 操作直接入队列\r\n- pop 操作直到第一个元素，队列里面元素移动到另一栈上\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n/\r\n//  MyQueue\r\n//  @Description: 队列结构体\r\n//\r\ntype MyQueue struct {\r\n\tinStack  []int\r\n\toutStack []int\r\n}\r\n\r\n//\r\n//  Constructor\r\n//  @Description: 创建\r\n//  @return MyQueue\r\n//\r\nfunc Constructor() MyQueue {\r\n\r\n\treturn MyQueue{\r\n\t\tinStack:  make([]int, 0),\r\n\t\toutStack: make([]int, 0),\r\n\t}\r\n\r\n}\r\n\r\n//\r\n//  Push\r\n//  @Description: 入队列\r\n//  @receiver this\r\n//  @param x\r\n//\r\nfunc (this *MyQueue) Push(x int) {\r\n\r\n\tthis.inStack = append(this.inStack, x)\r\n\r\n}\r\n\r\n//\r\n//  Pop\r\n//  @Description: 出队列\r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Pop() int {\r\n\r\n\t// outStack 长度等于0\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\r\n\t}\r\n\t// 获取最后一个元素\r\n\telem := this.outStack[len(this.outStack)-1]\r\n\t// 更新\r\n\tthis.outStack = this.outStack[:len(this.outStack)-1]\r\n\treturn elem\r\n\r\n}\r\n\r\n//\r\n//  Peek\r\n//  @Description: 最后一个元素\r\n//  @receiver this\r\n//  @return int\r\n//\r\nfunc (this *MyQueue) Peek() int {\r\n\r\n\tif len(this.outStack) == 0 {\r\n\t\tfor len(this.inStack) > 0 {\r\n\t\t\tthis.outStack = append(this.outStack, this.inStack[len(this.inStack)-1])\r\n\t\t\tthis.inStack = this.inStack[:len(this.inStack)-1]\r\n\t\t}\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push和empty操作O(1),pop和peek操作O(N),其中N是元素从一个栈移动到另一个栈次数\r\n- 空间复杂度：O(N) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443337","body":"## LC 768. 最多能完成排序的块 II\r\n[Leetcode连接](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n\r\n- [思路](#solution1)\r\n\r\n### <span id=\"solution1\">思路</span>\r\n\r\n分块后进行排序和原来数组相等的时候分块数量吧\r\n- 分块后每一个分块进行排序\r\n- 排序后，所有的分块进行连接\r\n- 排序数组和原来数组的前k元素相减去后的结果等于0的话，那么这位一个分块\r\n- 连接的数组是否相等原来的数组\r\n\r\n\r\n### Golang 代码\r\n\r\n``` go\r\n\r\nimport \"sort\"\r\n\r\nfunc maxChunksToSorted(arr []int) int {\r\n\r\n\tlength := len(arr)\r\n\tif length <= 1 {\r\n\t\treturn 1\r\n\t}\r\n\tarray := make([]int, length)\r\n\tcopy(array, arr)\r\n\tsort.Ints(array)\r\n\tsum, ret := 0, 0\r\n\tfor i := 0; i < l; i++ {\r\n\t\tsum += (arr[i] - array[i])\r\n\t\tif sum == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：排序：O(NLogN)，循环:O(N);其中N数组长度，O(N(1+logN))简化为O(NLogN)\r\n- 空间复杂度：O(N);其中N数组长度，创建了一个数组","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guixian001":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185422953","body":"### 思路\n\n常规思路\n先将给的数值转成数值，然后和给的 k 进行相加，再将其转换成数组\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num_length = len(num)\n        sum = 0\n        for index, i in enumerate(num):\n            sum += i * 10 ** (num_length - index  - 1)\n        sum += k\n        return [int(i) for i in str(sum)]\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223257","body":"### 思路\n\n分别计算数组位置中左侧和后侧的最近距离，然后最它们中的最小值作为当前 index 的数字。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [n+1] * n\n\n        c_index = -1\n        for index, char in enumerate(s):\n            if char == c:\n                c_index = index\n            if c_index != -1:\n                ans[index] = index - c_index \n\n        c_index = -1\n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                c_index = i\n            if c_index != -1:\n                ans[i] = min(ans[i], c_index - i)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551995","body":"### 思路\n\n1. 第一种方法比较依赖语言本身的特性，使用到了 Python 自己的数据结构，list 的 append/pop 方法\n2. 使用比较原生的方式实现，主要使用到数组的相关 crud\n\n### 代码\n- 方法 1\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = []\n        self._stack_cap = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self._stack) < self._stack_cap:\n            self._stack.append(x)\n\n    def pop(self) -> int:\n        if len(self._stack) > 0:\n            return self._stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        curr_count = len(self._stack)\n        for i in range(k):\n            if i <= curr_count - 1:\n                self._stack[i] += val\n```\n- 方法 2\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._stack = [0] * maxSize\n        self._stack_cap = maxSize\n        self._stack_index = -1  # 当前索引，-1 表示当前栈为空\n\n    def push(self, x: int) -> None:\n        if self._stack_index + 1 < self._stack_cap:\n            self._stack_index += 1\n            self._stack[self._stack_index] = x\n            \n\n\n    def pop(self) -> int:\n        if self._stack_index > -1:\n            top = self._stack[self._stack_index]\n            self._stack_index -= 1\n            return top\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(k):\n            if i <= self._stack_index:\n                self._stack[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189228149","body":"### 思路\n\n1. 关键是需要可以相出将一个栈（A栈）依次取出然后放到另外一个栈（B 栈）里面，从 B 栈出来的就是按照先进先出的顺序了，相当于内部做了一次翻转；\n2. 题目给出条件，所有操作都是有效的，不存在空队列去进行 pop() peak() 操作；\n3. 在调用 peak 的时候，我们将 A 栈的数据依次出栈，放入 B 栈，然后返回队列头的数据（及 B 栈的栈顶）；\n4. 在调用 pop 的时候，首先触发 peak，然后将 B 栈进行出栈操作；\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self._stack_one = []\n        self._stack_two = []\n\n    def push(self, x: int) -> None:\n        self._stack_one.append(x)\n\n    def pop(self) -> int:\n        self.peek()\n        return self._stack_two.pop()\n\n    def peek(self) -> int:\n        if len(self._stack_two) == 0:\n            while len(self._stack_one) != 0:\n                self._stack_two.append(self._stack_one.pop())\n        return self._stack_two[-1]\n\n    def empty(self) -> bool:\n        return len(self._stack_one) == 0 and len(self._stack_two) == 0\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190339214","body":"### 思路\n\n参考 [max-chunks-to-make-sorted-ii](https://github.com/suukii/91-days-algorithm/blob/master/basic/array-stack-queue/06.max-chunks-to-make-sorted-ii.md)\n\n### 代码\n\n1. 采用滑动窗口\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        count = 0\n        sum1 = 0\n        sum2 = 0\n\n        for i in range(len(arr)):\n            sum1 += arr[i]\n            sum2 += sorted_arr[i]\n\n            if (sum1 == sum2):\n                count += 1\n        \n        return count\n```\n\n2. 单调栈\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n\n        for i in arr:\n            if len(stack) == 0:\n                stack.append(i)\n                continue\n\n            if stack[-1] <= i:\n                stack.append(i)\n            else:\n                top = stack.pop()\n                while len(stack) != 0 and stack[-1] > i:\n                    stack.pop()\n                \n                stack.append(top)\n            \n        return len(stack)\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423747","body":"### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = 0\n        for i in range(len(num)-1,-1,-1):\n            num[i], temp = (temp+num[i]+k%10)%10, (temp+num[i]+k%10)//10\n            k = k//10\n        l = []\n        n = []\n        k += temp\n        while k:\n            l.append(k%10)\n            k//=10\n        while l:\n            n.append(l.pop())\n        return n+num\n```\n### 复杂度分析\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186139183","body":"### 思路\n首先遍历字符串找到给定字符的所有位置，然后再遍历字符串，比较每个字符和给定字符所有位置之间的距离，取最小的距离\n\n### 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        s_list = list(s)\n        temp = []\n        for i in range(len(s_list)):\n            if s_list[i] == c:\n                temp.append(i)\n        answer = []\n        for i in range(len(s_list)):\n            temp2 = []\n            for j in range(len(temp)):\n                m = abs(i - temp[j])\n                temp2.append(m)\n            answer.append(min(temp2))\n        return answer\n```\n\n**复杂度分析**  \n时间复杂度：O（n*k），n为字符串长度，k为给定字符在字符串中出现的次数  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186527404","body":"### 思路\n数组实现，push时注意判断是否长度溢出，pop时判断是否为空，定义一个记录栈顶位置的变量\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.length = maxSize\n        self.stack = []\n        self.top = 0\n\n    def push(self, x: int) -> None:\n        if self.top < self.length:\n            self.stack.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.stack:\n            self.top -= 1\n            return(self.stack.pop())\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if self.top == 0:\n            return -1\n        elif self.top < k:\n            for i in range(self.top):\n                self.stack[i] += val\n        else:\n            for i in range(k):\n                self.stack[i] += val\n```\n**复杂度分析**  \n- 时间复杂度：push和pop为O（1），increment为O（min（k，top））\n- 空间复杂度：O（1）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186751669","body":"### 思路\n遍历字符串，如果遇到‘【’，数字和字母，全部存到栈中；如果遇到‘】’，开始出栈，将‘【’之前的字母全都出栈并存到临时字符串中，然后数字部分出栈并存到次数字符串中，最后计算出重复的字符串并入栈\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        ans = []\n        for c in s:\n            if c == ']':\n                string = ''\n                count = ''\n                while ans and ans[-1] != '[':\n                    string = ans.pop() + string\n                ans.pop()\n                while ans and ans[-1].isnumeric():\n                    count = ans.pop() + count\n                ans.append(string * int(count))\n            else:\n                ans.append(c)\n        return ''.join(ans)\n```\n**复杂度分析**\n- 时间复杂度：O（n）\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188945623","body":"### 思路\r\n用两个栈模拟实现队列\r\n### 代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n        self.temp = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.queue.append(x)\r\n\r\n    def pop(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def peek(self) -> int:\r\n        while self.queue:\r\n            self.temp.append(self.queue.pop())\r\n        n = self.temp.pop()\r\n        self.queue.append(n)\r\n        while self.temp:\r\n            self.queue.append(self.temp.pop())\r\n        return n\r\n\r\n    def empty(self) -> bool:\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O（n）  \r\n- 空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189981219","body":"### 思路\n参考题解，应用单调栈，遍历数组，下一分块的最小值应该大于上一分块的最大值，每一分块用块中最大值表示，并且存于栈中，该栈单调增，最终分块数等于栈的长度\n### 代码\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = []\n        for x in arr:\n            if stack and stack[-1] > x:\n                top = stack[-1]\n                while stack and stack[-1] > x:\n                    stack.pop()\n                stack.append(top)\n            else:\n                stack.append(x)\n        return len(stack)\n```\n**复杂度分析**\n- 时间复杂度：O（n）  \n- 空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junzmer":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185423785","body":"### **思路**\r\n简单直接版\r\n\r\n1. 先把数组转成数字\r\n2. 相加\r\n3. 把数字转成数组，先除10求余数，然后除10求商，结果做个反转\r\n\r\n### **代码**\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        num_sum = 0\r\n        num = num[::-1]\r\n        num_length = len(num)\r\n        for i in range(num_length):\r\n            num_sum += (10 ** i) * num[i]\r\n        all_sum = num_sum + k\r\n        result = []\r\n        while all_sum > 0:\r\n            mod = all_sum % 10\r\n            all_sum = all_sum // 10\r\n            result.append(mod)\r\n        return result[::-1]\r\n```\r\n\r\n### **复杂度**\r\n\r\n- 时间复杂度O(N) N数组长度\r\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188666034","body":"### **思路**\r\n\r\n1. 获得c的所有索引\r\n2. 遍历s中的元素，索引小于最小索引的，最小距离是到最小索引的距离\r\n3. 大于最大索引的，最小距离是到最大索引的距离\r\n4. 位于上述两者中间的，计算所有距离，取最小值\r\n\r\n### **代码**\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        s = list(s)\r\n        len_s = len(s)\r\n        index_c = [index for (index,value) in enumerate(s) if value == c]\r\n        result = []\r\n        for i in range(len_s):\r\n            if i<=index_c[0] :\r\n                result.append(index_c[0]-i)\r\n            elif i>=index_c[-1]:\r\n                result.append(i-index_c[-1])\r\n            else:\r\n                min_dis = len_s\r\n                for k in index_c:\r\n                    dis = abs(i-k)\r\n                    if dis < min_dis:\r\n                        min_dis = dis\r\n                result.append(min_dis)\r\n        return result\r\n```\r\n### **复杂度**\r\n\r\n- 时间：O(N)\r\n- 空间：O(N)\r\n","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188631434","body":"### **思路**\r\n用python列表实现\r\npush -> list.append()\r\npop -> list.pop(0)\r\npeek -> list[0]\r\nempty -> len(list)\r\n\r\n### **代码**\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.queue = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.queue.append(x)\r\n        return self.queue\r\n\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue.pop(0)\r\n        return x\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        x = self.queue[0]\r\n        return x\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if len(self.queue) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n ```\r\n\r\n### **复杂度**\r\n\r\n- ### 时间复杂度 \r\n\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)\r\n\r\n- ### 空间复杂度：\r\npush  : O(1)\r\npop  : O(N)\r\npeek : O(1)\r\nempty :O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190328408","body":"### **思路**\r\n\r\n1. 构造栈，栈头为最大值\r\n2. 遍历数组，元素小于栈头，栈头出栈，保存为最大值，\r\n3. 元素依次与栈内数值比较，小于元素则出栈，不小于栈里的值，或者栈为空，最大值入栈\r\n4. 元素大于栈头，直接入栈，栈头为最大值\r\n\r\n### **代码**\r\n```python\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        # 单调栈\r\n        stack = [arr[0]]\r\n        head = arr[0]\r\n        for i in range(1,len(arr)):\r\n            if arr[i] < head and len(stack) > 0:\r\n                temp_head = head\r\n                while len(stack) > 0 and arr[i] < stack[-1] :\r\n                    if stack.pop(-1) > head:\r\n                        head = stack.pop(-1)\r\n                stack.append(head)\r\n            else:\r\n                stack.append(arr[i])   \r\n                head = arr[i]\r\n        return len(stack)\r\n```\r\n### **复杂度分析**\r\n执行用时：\r\n```\r\n20 ms, 在所有 Python 提交中击败了91.67%的用户\r\n内存消耗：13.2 MB, 在所有 Python 提交中击败了75.00%的用户\r\n```\r\n\r\n- 时间复杂度: O(N)\r\n- 空间复杂度: O(N)\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hx-code":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185455662","body":"var addToArrayForm = function(num, k) {\n    let res = [];\n    let len = num.length;\n    for(let i=len-1; i>=0;i--){\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if(sum>=10){\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);  \n    }\n    for(let i =k;i>0;i=Math.floor(i/10)){\n        res.push(i % 10)\n    }\n    res.reverse();\n    return res;\n\n};\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186492043","body":"class CustomStack:\n    def __init__(self, maxSize: int):\n        self.s = []\n        self.maxSize = maxSize\n    def push(self, x: int) -> None:\n        if len(self.s) < self.maxSize:\n            self.s.append(x)\n    def pop(self) -> int:\n        if not self.s:\n            return -1\n        return self.s.pop()\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.s))):\n            self.s[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187606802","body":"···js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234839","body":"var MyQueue = function() {\n    this.stack1 = [];\n    this.stack2 = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.stack2.length) {\n        this.stack1.push(this.stack2.pop());\n    }\n    this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.stack1.length) {\n        this.stack2.push(this.stack1.pop());\n    }\n    return this.stack2[this.stack2.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190263393","body":"```js/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function (arr) {\n    const sorted = [...arr];\n    sorted.sort((a, b) => a - b);\n\n    let count = 0,\n        sum1 = 0,\n        sum2 = 0;\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n\n        if (sum1 === sum2) {\n            count++;\n            sum1 = sum2 = 0; // 这行不要也可以啦\n        }\n    }\n\n    return count;\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"admu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185460667","body":"**思路**  \r\n一开始只能用list转数字相加方式，后来参考了进位方法：  \r\n1.1 循环判断条件当 k 和 列表都为空时候终止  \r\n1.2 取余方式每次去k的末尾值与列表末尾值进行相加，同时记录进位的值  \r\n\r\n**代码**  \r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res = []\r\n        carry = 0 \r\n        if len(str(k))>len(num):\r\n            num = [0]*(len(str(k))-len(num))+num\r\n        n = len(num)-1 \r\n        while n>=0 and k>=0:\r\n            i = num[n]\r\n            kk = k%10 \r\n            res.append((i+k+carry)%10)\r\n            carry = (i+kk+carry)//10 \r\n            n -= 1\r\n            k = (k-kk)//10 \r\n        if carry!=0: res.append(carry)\r\n        return res[::-1]\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186109783","body":"**思路**  \r\n1.1 一开始用暴力求解时间复杂度都是O(cn)空间复杂度O(cn)  \r\n1.2 看了题解进行优化,借助-n和2n进行双向搜索，秒啊  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        ans = [0] * n\r\n\r\n        idx = -n\r\n        for i, ch in enumerate(s):\r\n            if ch == c:\r\n                idx = i\r\n            ans[i] = i - idx\r\n        idx = 2 * n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n            ans[i] = min(ans[i], idx - i)\r\n        return ans\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186462349","body":"**思路**  \r\n***1381 https://leetcode.cn/problems/design-a-stack-with-increment-operation/submissions/***  \r\n1.1 利用列表append及pop实现复杂度O(k)    \r\n\r\n**代码**\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.list = []\r\n        self.index = 0\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.index< self.maxSize:\r\n            self.list.append(x)\r\n            self.index+=1\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.list)==0:\r\n            return -1 \r\n        else:\r\n            self.index-=1\r\n            return self.list.pop()\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if k > self.index:\r\n            k = self.index\r\n        for i in range(k):\r\n            self.list[i] += val\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(k)  \r\n1.2 空间复杂度 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625717","body":"**思路**  \r\n***394 https://leetcode.cn/problems/decode-string/  \r\n1.1 先讲所有非]进栈  \r\n1.2 遇到]时不停的出栈直到遇到了[  \r\n1.3 [前面判断下是否是数字以及栈非空，如果不是那么把数字出栈  \r\n1.4 出栈相加时候注意字符串顺序，正确顺序的str*nums完成后每一部分append到栈中  \r\n\r\n**代码**\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []\r\n        res = ''\r\n        for i in s:\r\n            if i != ']':\r\n                stack.append(i)\r\n            else:\r\n                word = stack.pop()\r\n                words = ''\r\n                while word!='[':\r\n                    words=word+words # 倒叙\r\n                    word = stack.pop()\r\n                num = stack.pop()\r\n                nums = ''\r\n                while num.isnumeric():\r\n                    nums=num+nums\r\n                    if stack and stack[-1].isnumeric():\r\n                        num = stack.pop()\r\n                    else: \r\n                        break\r\n                stack.append(words*int(nums))\r\n        return ''.join(stack)\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189157723","body":"**思路**  \r\n***232 https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/***  \r\n1.1 利用双栈实现,维护一个输入栈一个输出栈  \r\n1.2 因为把第一个栈pop后压入到第二个栈输入栈的顺序反过来这时候pop就能实现队列的pop功能  \r\n\r\n```python  \r\nclass MyQueue():\r\n    def __init__(self):\r\n        self.stackin = []\r\n        self.stackout = []\r\n        \r\n    def push(self,i):\r\n        self.stackin.append(i)\r\n        \r\n    def pop(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout.pop()\r\n    \r\n    def peak(self):\r\n        if not self.stackout:\r\n            while self.stackin:\r\n                self.stackout.append(self.stackin.pop())\r\n        return self.stackout[-1]\r\n    \r\n    def empty(self):\r\n        if not(self.stackin or self.stackout):\r\n            return True\r\n        return False\r\n```\r\n\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341806","body":"**思路**  \r\n菜鸡的一天，没有思路，还是看官方题解好  \r\n768 https://leetcode-solution.cn/solutionDetail?type=3&id=6&max_id=2  \r\n\r\n**代码**\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, A):\r\n        stack = []\r\n        for a in A:\r\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\r\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\r\n            if stack and stack[-1] > a:\r\n                # 我们需要将融合后的区块的最大值重新放回栈\r\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\r\n                cur = stack[-1]\r\n                # 维持栈的单调递增\r\n                while stack and stack[-1] > a: stack.pop()\r\n                stack.append(cur)\r\n            else:\r\n                stack.append(a)\r\n        # 栈存的是块信息，因此栈的大小就是块的数量\r\n        return len(stack)\r\n```\r\n**复杂度分析**  \r\n1.1 时间复杂度 O(n)  \r\n1.2 空间复杂度 O(n)  ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxiaomm":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185468498","body":"## 思路\n\n1. Add two numbers from right to left, column by column, and record the carry.\n2. If carry > 0, add it to the next column.\n3. Add the result to the first position of the result list.\n4. Implement the loop until all digit in two numbers has been calculated, or carry = 0;\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        int i = num.length - 1, carry = 0;\n        while (i >= 0 || k > 0 || carry > 0) {\n            int val1 = i < 0 ? 0 : num[i--];\n            int val2 = k % 10;\n            int sum = val1 + val2 + carry;\n            carry = sum / 10;\n            res.add(0, sum % 10);\n            k = k / 10;\n        }\n        return res;\n    }\n}\n```\n\nTime complexity: O(n), n is the greater length of the two numbers.\nSpace complexity: O(1), not include the space of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186159091","body":"\n# Link\n\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\n\n## Idea_1\n\n1. Traverse the string for two times;\n2. Firstly, when going from left to right, we record the distance from index i to their last/previous target character(first target on their left): ```i - prev```;\n3. Secondly, when going from right to left, we record the distance form index i to their right previous target(first target on their right), and compared with original value in the array;\n4. Update the minimum distance of every node;\n\n\n## Code_1\n\n```java\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        // 距离最左边的e的距离\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        // 倒序: 距离最右边的e的距离与之比较\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Use two pointer: ```slow``` and ```fast```.\n2. After finding the first target with ```fast``` on the right, write the distance of nodes on its left into the array, and store the index of this target as ```prev```.\n3. Continue the above step, compare the distance from the nodes to the previous target node and the next target node, update the array.\n\n\n\n## Code_2\n\n```java\nclass Solution {\n    // two pointer\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int i = 0, j = 0, prev = -1;;\n        while (i < len) {\n            // 找到右边的第一个e\n            while (j < len && s.charAt(j) != c )\n                j++;\n            if (j == len) break;    // 右边没有e了\n            \n            // 比较右边的e和左边的e哪个远\n            while (i <= j){\n                res[i] = Math.min(j-i, (prev==-1 ? len : i-prev));\n                i++;\n            }\n            prev = j++; // 记录前一个e的位置\n        }\n        // 若数组没填充完, 则填充, 距离左边e的距离即是结果\n        while (i < len) \n            res[i] = (prev==-1 ? i : i++ -prev);    \n        \n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the string.  \nSpace complexity: O(n), the length of output array.\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186548391","body":"\n# Link\n\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\n\n## Idea\n\n1. Use an array to store the increment, inc[i] means that from ```0 - i```, the element should add ```inc[i]```;\n2. While poping an element form the stack, the size of the stack decrease, and inc[i] should be update to 0; so we need to update the increment array;  \n3. Update the former: ```inc[i-1] += inc[i]```, because element from 0 to i-1 still should add inc[i], then update ```inc[i] = 0```;\n\n## Code\n\n```java\nclass CustomStack {\n    private int capacity;\n    private int[] inc;\n    Stack<Integer> s;\n    \n    // O(n), O(n)\n    public CustomStack(int maxSize) {\n        this.capacity = maxSize;\n        inc = new int[capacity];\n        s  = new Stack<>();\n    }\n    // O(1)\n    public void push(int x) {\n        if (s.size() < capacity)\n            s.push(x);\n    }\n    // O(1)\n    public int pop() {\n        if (s.isEmpty()) return -1;\n        \n        int i = s.size()-1;\n        if (i > 0)\n            inc[i-1] += inc[i];\n        int val = s.pop()+inc[i];\n        inc[i] = 0;\n        return val;\n    }\n    // O(1)\n    public void increment(int k, int val) {\n        int bound = Math.min(s.size(),k) - 1;\n        if (bound >= 0)\n            inc[bound] += val;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: Initialization: O(n); Others: O(1).\nSpace complexity: Initialization: O(n); Others: O(1).\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187440232","body":"\n## Link\n\nhttps://leetcode.com/problems/decode-string/\n\n## Idea_1\n\n1. Using Two Stack to sotre the number and decoded strings;\n2. While meeting digit or character, append it with varible ```count``` or ```res```;\n3. While meeting opening bracket```'['```, push digit and string into those two stack;\n4. While meeting closing bracket```']'```, pop the previous string  and count from the stack, decode current string for ```count``` times and append it to the previous string;\n\n## Code_1\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> in = new Stack<>();\n        Stack<String> stack = new Stack<>();\n        String res = \"\";\n        int i = 0, count = 0;\n        while (i < s.length()) {\n            char c = s.charAt(i++);\n            if (Character.isDigit(c))\n                count = count*10 + c - '0';\n            else if (c == '[') {\n                in.push(count);\n                stack.push(res);\n                res = \"\";\n                count = 0;\n            }\n            else if (Character.isAlphabetic(c))\n                res += c;\n            else if (c == ']') {\n                int cnt = in.pop();\n                StringBuilder temp = new StringBuilder(stack.pop());\n                for (int j = 0; j < cnt; j++) \n                    temp.append(res);\n                res = temp.toString();\n            }\n        }\n        return res;\n    }\n}\n```\n\n## Idea_2\n\n1. Using one stack to store everything;\n2. While meeting character instead of ```']'```, push it into the stack;\n3. While meeting ```']'```, pop the character from the stack;\n4. Use varible ```sb``` to store the substring until meet ```'['```;\n5. Then pop ```'['``` out, and use ```count``` to store the following digit;\n6. Decode the substring ```sb``` for ```count``` times and push it back to the stack;\n7. Pop the result from the stack;\n\n## Code_2\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        for(char c : s.toCharArray()) {\n            if(c != ']') \n                stack.push(c); //push everything but ]\n            else {\n                //step 1: \n                    //if you find a closing ] then \n                    //retrieve the string it encapsulates\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0, stack.pop());\n                String sub = sb.toString(); //this is the string contained in [ ]\n                stack.pop(); //Discard the '[';\n                //step 2: \n                    //after that get the number of\n                    // times it should repeat from stack\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0, stack.pop());\n                int count = Integer.valueOf(sb.toString()); // this is the number\n                //step 3: \n                    //repeat the string within the [ ] count \n                    //number of times and push it back into stack\n                while(count > 0) {\n                    for(char ch : sub.toCharArray())  \n                        stack.push(ch);\n                    count--;\n                }\n            }\n        }\n        //final fetching and returning the value in stack \n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n        return retv.toString();\n    }\n}\n```\n\n## Idea_3\n\n1. Using recursion and global varible ```index```;\n2. While meeting digits, build the number ```count``` by iterating over the string ```s```;\n3. While meeting ```'['```, ignore it and recursively find the nested string ```temp```;\n4. Decode the current pattern ```count[temp]```;\n5. While meeting ```']'```, finished and return;\n   \n\n## Code_3\n\n```java\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        String temp = \"\";\n        \n        while (index < s.length()) {\n            char ch = s.charAt(index++);\n            if (Character.isDigit(ch))\n                num = num*10 + ch - '0';\n            else if (ch == '['){\n                temp = decodeString(s);\n                for (int j = 0; j < num; j++)\n                    res.append(temp);\n                num = 0;\n            }\n            else if (Character.isAlphabetic(ch))\n                res.append(ch);  \n            else \n                break;\n                \n        }\n        return res.toString();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of decoded string.  \nSpace complexity: O(n), n is the length of decoded string. \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097770","body":"\n## Link\n\nhttps://leetcode.com/problems/implement-queue-using-stacks/\n\n## Idea\n\n1. Use two stacks;\n2. While poping, we push all the elements from stack1 into the stack2, and find the first element.\n\n\n## Code\n\n```java\nclass MyQueue {\n    Stack<Integer> s;\n    Stack<Integer> ss;\n    public MyQueue() {\n        s = new Stack<>();\n        ss = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s.push(x);\n    }\n    \n    public int pop() {\n        while (!s.isEmpty())\n            ss.push(s.pop());\n        int val = ss.pop();\n        while (!ss.isEmpty())\n            s.push(ss.pop());\n        return val;\n        \n    }\n    \n    public int peek() {\n        return s.get(0);\n    }\n    \n    public boolean empty() {\n        return s.isEmpty();\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: pop(): O(n), others: O(1).  \nSpace complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190379759","body":"\n## Link\n\nhttps://leetcode.com/problems/max-chunks-to-make-sorted-ii/\n\n## Idea\n\n1. Sort the array;\n2. Traverse the sorted and original array and compute their sum seperately, if the sum1 == sum2, the result plus 1;\n\n## Code\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int res = 0, sum1 = 0, sum2 = 0;\n        for (int i = 0; i < arr.length; i++) {\n            sum1 += arr[i];\n            sum2 += sorted[i];\n            if (sum1 == sum2) res += 1;\n        }\n        return res;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(nlogn), sort the array need nlogn time.  \nSpace complexity: O(n), clone the original array need n space. ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191405197","body":"\n## Link\n\nhttps://leetcode.com/problems/rotate-list/\n\n## Idea\n\n \n 1. Close the list into the ring.\n 2. Traverse the list and get the length of it.\n 3. Find the previous node of the last k % length node from the end of the list. \n 4. Break the ring at the position: after the new tail or before the new head.\n \n\n## Code\n\n```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null) return head;\n        ListNode dummy = new ListNode(-1,head), curr = dummy;\n        int len = 0;\n        while (curr.next != null) {\n            len++;\n            curr = curr.next;\n        }\n        curr.next = head;   // close the list into the ring\n        curr = dummy;\n        for (int i = 0; i < len-k%len; i++) \n            curr = curr.next;\n        head = curr.next;\n        curr.next = null;\n        return head;\n    }\n}\n```\n\n\n## Complexity\n\nTime complexity: O(n), n is the length of the list.  \nSpace complexity: O(1). \n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pgquestions":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185484818","body":"## 思路\r\n\r\n1、创建一个链表数组用来存放结果  \r\n2、把数组和数字相同位数的值进行相加。直到全部计算完  \r\n3、每次计算完的数字添加在数组头部  \r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> arr = new LinkedList<>();\r\n        int index = num.length - 1;\r\n        int temp = 0;\r\n        while (index >= 0 || k > 0 || temp > 0) {\r\n            int temp_data = k % 10 + temp;\r\n            k = k / 10;\r\n            if (index >= 0) {\r\n                temp_data += num[index];\r\n                index--;\r\n            }\r\n            arr.addFirst(temp_data % 10);\r\n            temp = temp_data / 10;\r\n        }\r\n        return arr;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185682411","body":"## 思路\r\n\r\n先从左往右进行遍历。  \r\n然后从右往左遍历，记录最小的值\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532017","body":"\r\n## 思路\r\n\r\n通过根据数组实现栈的思路\r\n\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass CustomStack {\r\n    private int[] arr;\r\n    private int index = -1;\r\n    private int limit = 0;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        limit = maxSize - 1;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (index == limit){\r\n            return;\r\n        }\r\n        index++;\r\n        arr[index] = x;\r\n    }\r\n\r\n    public int pop() {\r\n        if (index == -1){\r\n            return -1;\r\n        }\r\n        int ans = arr[index];\r\n        index--;\r\n        return ans;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int min = Math.min(k, index+1);\r\n        for (int i = 0; i < min; i++) {\r\n            arr[i] = arr[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(1)$\r\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187309867","body":"## 前置知识\r\n\r\n- 栈\r\n\r\n\r\n\r\n## 思路\r\n\r\n一个栈用来存放数字  \r\n一个栈用来存放字符串\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder str = new StringBuilder();\r\n        Stack<Integer> num = new Stack<>();\r\n        Stack<StringBuilder> str_sta = new Stack<>();\r\n        int k = 0;\r\n        for (char c : s.toCharArray()) {\r\n            if (Character.isDigit(c)) {\r\n                k = k * 10 + (c - '0');\r\n            } else if (c == '[') {\r\n                num.push(k);\r\n                k = 0;\r\n                str_sta.push(str);\r\n                str = new StringBuilder();\r\n            } else if (c == ']') {\r\n                StringBuilder temp = str_sta.pop();\r\n                for (int i = num.pop(); i > 0; i--) {\r\n                    temp.append(str);\r\n                }\r\n                str = temp;\r\n            } else {\r\n                str.append(c);\r\n            }\r\n\r\n        }\r\n        return str.toString();\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(kn)\r\n- 空间复杂度： O(num(k) + num(char))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188935888","body":"\r\n## 思路\r\n一个栈stackpush，一个栈stackpop。只有当stackpop为空时，可以把stackpush里面的数字进入到stackpop栈 ，并且需要一次性全部入栈\r\nstackpop用于出栈  \r\nstackpush用于进栈  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass MyQueue {\r\n    private Stack<Integer> stackpush;\r\n    private Stack<Integer> stackpop;\r\n\r\n    public MyQueue() {\r\n        stackpush = new Stack<>();\r\n        stackpop = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        stackpush.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.pop();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (!stackpop.isEmpty()) {\r\n            return stackpop.peek();\r\n        }\r\n        while (!stackpush.isEmpty()) {\r\n            stackpop.push(stackpush.pop());\r\n        }\r\n        return stackpop.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return stackpush.isEmpty() && stackpop.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190317364","body":"\r\n## 思路\r\n1、只要数组的数比栈顶大，则入栈\r\n2、数组的数比栈顶小，则出栈，同时继续比较数组与栈顶。依次继续\r\n3、栈的大小就是最多的块数\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length;i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()){\r\n                stack.push(arr[i]);\r\n            }else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191407764","body":"\r\n## 思路\r\n1、先统计链表的长度  \r\n2、计算实际需要移动的次数  \r\n3、使用快慢指针进行移动  \r\n慢指针为头，快指针的next连接到原先的头，然后再把慢指针的next指向null。  \r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：Java\r\n\r\nJava Code:\r\n\r\n```java\r\n\r\n/**\r\n * Definition for singly-linked list.\r\n * public class ListNode {\r\n *     int val;\r\n *     ListNode next;\r\n *     ListNode() {}\r\n *     ListNode(int val) { this.val = val; }\r\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\r\n * }\r\n */\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null || head.next == null) return head;\r\n        int count = 0;\r\n        ListNode now = head;\r\n\r\n        // 统计链表长度\r\n        while (now != null) {\r\n            now = now.next;\r\n            count++;\r\n        }\r\n        // 计算实际需要移动的次数\r\n        k = k % count;\r\n        ListNode slow = head;\r\n        ListNode fast = head;\r\n        // 使用快慢指针进行实现\r\n        while (fast.next != null) {\r\n            if (k-- <= 0) {\r\n                slow = slow.next;\r\n            }\r\n            fast = fast.next;\r\n        }\r\n        fast.next = head;\r\n        ListNode res = slow.next;\r\n        slow.next = null;\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(1)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eldinzhou":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185485651","body":"```go\nfunc addToArrayForm(num []int, k int) (ans []int) {\n    for i := len(num) - 1; i >= 0; i-- {\n        sum := num[i] + k%10\n        k /= 10\n        if sum >= 10 {\n            k++\n            sum -= 10\n        }\n        ans = append(ans, sum)\n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return\n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}","onTime":true},null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190278600","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: [int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangwenzhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185496245","body":"### 思路\n\n本来一开始想直接使用 JavaScript 的 api 的：\n1. 计算 sum 数组的值\n2. 把值和 k 相加\n3. 把值通过 `String(number).split('').map(n => Number(n))` 转换回数组\n\n出现的问题是 `IEEE754` 编码的数字会出现精度丢失的问题\n\n所以还是老老实实的使用逐位相加的方法\n\n1. 把数组中的位置从高到底相加\n2. 如果结果大于 10 的话，把进位 1 加入下一位的计算\n\n### 代码\n\n```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (let k; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n\n### 复杂度分析\n\n* 时间复杂度：O(n)\n* 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186141162","body":"### 思路\n\n* 把 c 在 s 字符串的位置放在一个新开辟的数组里\n* 遍历 s 字符串，把结束输入到数组中\n\n### 代码\n\n```js\nvar shortestToChar = function(s, c) {\n  const sArr = s.split('');\n  const cIndexArr = [];\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      cIndexArr.push(index);\n    }\n  });\n  const res = Array(s.length).fill(Infinity);\n  sArr.forEach((i, index) => {\n    if (i === c) {\n      res[index] = 0;\n      return;\n    }\n    for (const cIndex of cIndexArr) {\n      const dis = Math.abs(cIndex - index);\n      if (dis >= res[index]) {\n        break;\n      }\n      res[index] = dis;\n    }\n  });\n  return res;\n};\n```\n\n### 复杂度\n\n* 时间复杂度 O(N^2)\n* 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441685","body":"### 思路\n\n- 使用数组模拟 stack\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.stack = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length <= this.maxSize - 1) {\n    this.stack.unshift(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.stack.length === 0) {\n    return -1;\n  }\n  const elemrnt = this.stack.shift();\n  return elemrnt;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const stackLength = this.stack.length;\n  if (stackLength === 0) {\n    return [];\n  }\n this.stack = this.stack.map((i, index) => {\n    if (stackLength - index <= k ) {\n      return i + val;\n    }\n   return i;\n });\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度\n\n- Time：O(N)\n- Space：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187630436","body":"var decodeString = function(s) {\n    let numStack = [];          \n    let strStack = [];            \n    let num = 0, result = '';\n\n    for(let i = 0; i < s.length; i++) {\n        const item = s[i];\n\n        if(!isNaN(item)) {              // 判断是数字时\n            num = num * 10 + parseInt(item);\n        } else if(item === '[') {\n            strStack.push(result);\n            result = '';\n            numStack.push(num);\n            num = 0;\n        } else if(item === ']') {\n            const repeatTimes = numStack.pop();         // 从栈中获取次数\n            result = strStack.pop() + result.repeat(repeatTimes);\n        } else {\n            result += item;\n        }\n    }\n    return result;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189196478","body":"\tvar MyQueue = function () {\n\t  this.stack1 = [];\n\t  this.stack2 = [];\n\t};\n\t\n\tMyQueue.prototype.push = function (x) {\n\t  this.stack1.push(x);\n\t};\n\t\n\tMyQueue.prototype.pop = function () {\n\t  if (this.stack2.length > 0) {\n\t    return this.stack2.pop();\n\t  }\n\t\n\t  while (this.stack1.length > 0) {\n\t    this.stack2.push(this.stack1.pop());\n\t  }\n\t\n\t  return this.stack2.pop();\n\t};\n\t\n\tMyQueue.prototype.peek = function () {\n\t  let tmp = this.pop();\n\t  this.stack2.push(tmp);\n\t  return tmp;\n\t};\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shawnwu6688":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185508439","body":"# 989.Add to Array-Form of Integer\n\n**思路:**\n\n自己想的思路和leetcode上高赞答案差不多，但是实现起来，发现他的更优雅，果断使用他的实现思路。优雅，真的太优雅了！！！\n1. 不要用for循环，因为你不知道num,k那个长度更长，如果一开始将k转为数组来比较长度就太不优雅了！！！所以用while()\n2. 用LinkedList不要用ArrayList因为底层为链表实现的LinkedList可以头插\n3. 数组的每一位都与K整体相加，除10就是K的最新值参与下一次遍历，不用考虑进位问题\n4. 把数组相加的问题转化为对最新值处理问题，不用考虑长度和位数\n\n```java\npublic class AddToArrayFormOfInteger {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len = num.length;\n        int lastNum = k;\n        int i = len - 1;\n        LinkedList<Integer> result = new LinkedList<>();\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0)\n                lastNum += num[i];\n            //取模加入到数组\n            result.addFirst(lastNum % 10);\n            //更新最新值\n            lastNum /= 10;\n            i--;\n        }\n        return result;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186078726","body":"# 821. Shortest Distance to a Character\n\n**思路：**\n最无脑的思路\n1. 记录c的下标存入数组\n2. 遍历相减取最小绝对值\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c){\n                index.add(i);\n            }\n\n        }\n        int[] ret = new int[chars.length];\n        int minAbs = 0;\n        for (int i = 0; i < chars.length; i++) {\n            for (int j = 0; j < index.size(); j++) {\n                if (j ==0){\n                    //再次初始化\n                    minAbs = Math.abs(index.get(j) - i);\n                    continue;\n                }\n                minAbs = Math.min(Math.abs(index.get(j) - i), minAbs);\n\n            }\n            ret[i] = minAbs;\n\n        }\n        return ret;\n\n    }\n```\n>时间复杂度： O(n^2)\n> \n>空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186499905","body":"# 1381. Design a Stack With Increment Operation\n\n**思路：**\n1. 用数组来存储数据\n2. 用指针模拟栈的操作\n```java\npublic class CustomStack {\n\n    int[] stack;\n    int index;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        index = 0;\n    }\n\n    public void push(int x) {\n        if(index < stack.length){\n            stack[index]=x;\n            index ++;\n        }\n    }\n\n    public int pop() {\n        int ret = index - 1 <0? -1:stack[index - 1];\n        if (ret != -1){\n            index --;\n        }\n        return ret;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, index);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i < index; i++) {\n            if (i == index -1){\n                sb.append(stack[i]);\n            }else {\n                sb.append(stack[i]+\",\");\n            }\n\n\n        }\n        sb.append(\"]\");\n        return sb.toString();\n        //return Arrays.toString(stack);\n    }\n}\n```\n>时间复杂度：O(n)\n>空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187301558","body":"# 394. Decode String\n**思路:**\n1. 栈括号匹配处理小规模事件\n2. 递归调用处理整体事件\n```java\npublic String decodeString(String s) {\n        Stack<Integer> brackets = new Stack<>();\n        char[] chars = s.toCharArray();\n        char leftBracket = '[';\n        char rightBracket = ']';\n        //以\"3[a211[c]]\"为例，拿到\"a2[c]\"的位置，处理成\"3[acc]\"递归处理\n        //左括号位置确定倍数\n        Integer leftBracketIndex = -1;\n        //右括号位置确定括号内的字符\n        Integer rightBracketIndex = -1;\n\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == leftBracket) {\n                brackets.push(i);\n            }\n            if (chars[i] == rightBracket) {\n                leftBracketIndex = brackets.pop();\n                rightBracketIndex = i;\n                break;\n            }\n        }\n        if (leftBracketIndex == -1) {\n            return s;\n        } else {\n            StringBuilder times = new StringBuilder();\n            for (int i = leftBracketIndex -1; i >= 0; i--) {\n                if (chars[i] <48 || chars[i] >57){\n                    break;\n                }\n                times.append(chars[i]);\n            }\n            StringBuilder reverse = times.reverse();\n            int time = Integer.valueOf(reverse.toString());\n\n            StringBuilder tempString = new StringBuilder();\n            StringBuilder timedString = new StringBuilder();\n            tempString.append(chars, leftBracketIndex + 1, rightBracketIndex - (leftBracketIndex + 1));\n            for (int i = 0; i < time; i++) {\n                timedString.append(tempString);\n            }\n            StringBuilder sBuilder = new StringBuilder();\n\n            for (int i = 0; i < chars.length; i++) {\n                int i1 = leftBracketIndex - String.valueOf(time).length();\n                if (i1 < i && i <= rightBracketIndex) {\n\n                } else if (i1 == i) {\n                    sBuilder.append(timedString);\n                } else {\n                    sBuilder.append(chars[i]);\n                }\n            }\n            s = sBuilder.toString();\n            return decodeString(s);\n        }\n\n    }\n```\n>时间复杂度：O(n^2)\n>空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188901199","body":"# 232. Implement Queue using Stacks\n**思路:**\n1. 用两个栈模拟队列操作\n```java\npublic class MyQueue {\n    private Stack<Integer> stack;\n    private Stack<Integer> tempStack;\n    public MyQueue() {\n        stack = new Stack<>();\n        tempStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack.push(x);\n    }\n\n    public int pop() {\n        int popInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                popInt =  stack.pop();\n            }else {\n                tempStack.push(stack.pop());\n            }\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n        return popInt;\n    }\n\n    public int peek() {\n        int peekInt = 0;\n        while (stack.size() != 0){\n            if (stack.size() == 1){\n                peekInt =  stack.peek();\n            }\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            stack.push(tempStack.pop());\n        }\n\n        return peekInt;\n    }\n\n    public boolean empty() {\n        return stack.empty();\n    }\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        while (stack.size() != 0){\n\n            tempStack.push(stack.pop());\n\n        }\n        while (tempStack.size() != 0){\n            if (tempStack.size() == 1){\n                sb.append(tempStack.peek());\n            }else {\n                sb.append(tempStack.peek()).append(\",\");\n            }\n            stack.push(tempStack.pop());\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n}\n```\n>时间复杂度 O(n)\n>空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190295429","body":"# 768. Max Chunks To Make Sorted II\n**Thinking:**\n1. Assuming there are already those maximum partitions, what features are in these partitions?\n   1. The minimum value in the latter partition is greater than the maximum value in the previous partitions.\n   2. based on above,we have a stack storage the biggest number in each partition and ensure the condition above.\n2. How could we make it?\n   1. iterate array,if `arr[i] >= stack.top()`,`arr[i]` can be one of the latter partition. \n   2. if not, compare to each number in stack if the number bigger than `arr[i]`: `stack.pop()`,till any number is smaller,each `stack.pop()`means partitions which the numbers represent has been merged\n```java\npublic class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int currMax = arr[0];\n        Stack<Integer> stack = new Stack<>();\n        stack.push(arr[0]);\n        for (int i = 1; i < arr.length; i++) {\n            if (arr[i] >= stack.peek()){\n                stack.push(arr[i]);\n                currMax = arr[i];\n            }else {\n                stack.pop();\n                while (!stack.empty()){\n                    if (arr[i]<stack.peek()){\n                        stack.pop();//merge\n                        break;\n                    }\n                    stack.push(currMax);\n                }\n                if (stack.empty()){\n                    stack.push(currMax);\n                }\n            }\n        }\n\n        return stack.size() == 0? 1 : stack.size();\n    }\n\n}\n```\n> Time Complexity O(n^2)\n> Space Complexity O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185520837","body":"## 思路\r\n\r\n> + k作为位数累加,进位\r\n\r\n##代码\r\n\r\n```go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n\ti := len(num) - 1\r\n\tfor i >= 0 || k > 0 {\r\n\t\tif i > 0 && k > 0 {\r\n\t\t\tsum := num[i] + k%10\r\n\t\t\tnum[i] = sum\r\n\t\t\tk = k / 10  // drop the last element of k\r\n\r\n\t\t\tif sum > 9 {\r\n\t\t\t\tnum[i] = sum % 10\r\n\t\t\t\tk++ //  add carry(1) to k\r\n\t\t\t}\r\n\t\t\ti--\r\n\t\t} else if i >= 0 {\r\n\t\t\tbreak\r\n\t\t} else {\r\n\t\t\tnum = append([]int{k % 10}, num...)\r\n\t\t}\r\n\t}\r\n\r\n\treturn num\r\n}   \r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186214965","body":"## 思路\r\n\r\n> + 两次遍历-即求s[i]到c左右最近距离的最小值\r\n\r\n## 代码\r\n\r\n```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    ans := make([]int, n)\r\n\r\n    idx := -n\r\n    for i, ch := range s {\r\n        if byte(ch) == c {\r\n            idx = i\r\n        }\r\n        ans[i] = i - idx\r\n    }\r\n\r\n    idx = n * 2\r\n    for i := n - 1; i >= 0; i-- {\r\n        if s[i] == c {\r\n            idx = i\r\n        }\r\n        ans[i] = min(ans[i], idx-i)\r\n    }\r\n    return ans\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    }\r\n    return a\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n\r\n> + 时间复杂度：O(n)\r\n> + 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543466","body":"## 思路\r\n\r\n> + 模拟\r\n\r\n## 代码\r\n\r\n```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{\r\n        make([]int, 0),\r\n        maxSize,\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) > 0 {\r\n        res := this.stack[len(this.stack)-1]\r\n        this.stack = this.stack[:len(this.stack)-1]\r\n        return res\r\n    }\r\n    return -1\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    }\r\n    for i := 0; i < k; i++ {\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(1)\r\n> + 空间: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187447665","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n## 代码\r\n\r\n```go\r\nfunc decodeString(s string) string {\r\n    stk := []string{}\r\n    ptr := 0\r\n    for ptr < len(s) {\r\n        cur := s[ptr]\r\n        if cur >= '0' && cur <= '9' {\r\n            digits := getDigits(s, &ptr)\r\n            stk = append(stk, digits)\r\n        } else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\r\n            stk = append(stk, string(cur))\r\n            ptr++\r\n        } else {\r\n            ptr++\r\n            sub := []string{}\r\n            for stk[len(stk)-1] != \"[\" {\r\n                sub = append(sub, stk[len(stk)-1])\r\n                stk = stk[:len(stk)-1]\r\n            }\r\n            for i := 0; i < len(sub)/2; i++ {\r\n                sub[i], sub[len(sub)-i-1] = sub[len(sub)-i-1], sub[i]\r\n            }\r\n            stk = stk[:len(stk)-1]\r\n            repTime, _ := strconv.Atoi(stk[len(stk)-1])\r\n            stk = stk[:len(stk)-1]\r\n            t := strings.Repeat(getString(sub), repTime)\r\n            stk = append(stk, t)\r\n        }\r\n    }\r\n    return getString(stk)\r\n}\r\n\r\nfunc getDigits(s string, ptr *int) string {\r\n    ret := \"\"\r\n    for ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\r\n        ret += string(s[*ptr])\r\n    }\r\n    return ret\r\n}\r\n\r\nfunc getString(v []string) string {\r\n    ret := \"\"\r\n    for _, s := range v {\r\n        ret += s\r\n    }\r\n    return ret\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(n)\r\n> + 空间: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189127036","body":"## 思路\r\n\r\n> + 双栈\r\n\r\n## 代码\r\n\r\n```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\nfunc (q *MyQueue) Push(x int) {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\nfunc (q *MyQueue) in2out() {\r\n    for len(q.inStack) > 0 {\r\n        q.outStack = append(q.outStack, q.inStack[len(q.inStack)-1])\r\n        q.inStack = q.inStack[:len(q.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    x := q.outStack[len(q.outStack)-1]\r\n    q.outStack = q.outStack[:len(q.outStack)-1]\r\n    return x\r\n}\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        q.in2out()\r\n    }\r\n    return q.outStack[len(q.outStack)-1]\r\n}\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.inStack) == 0 && len(q.outStack) == 0\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间: O(1)\r\n> + 空间: O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191324785","body":"## 思路\r\n\r\n> + 闭合为环-将给定的链表连接成环，然后将指定位置断开\r\n\r\n## 代码\r\n\r\n```go\r\nfunc rotateRight(head *ListNode, k int) *ListNode {\r\n    if k == 0 || head == nil || head.Next == nil {\r\n        return head\r\n    }\r\n    n := 1\r\n    iter := head\r\n    for iter.Next != nil {\r\n        iter = iter.Next\r\n        n++\r\n    }\r\n    add := n - k%n\r\n    if add == n {\r\n        return head\r\n    }\r\n    iter.Next = head\r\n    for add > 0 {\r\n        iter = iter.Next\r\n        add--\r\n    }\r\n    ret := iter.Next\r\n    iter.Next = nil\r\n    return ret\r\n}\r\n```\r\n\r\n## 复杂度\r\n\r\n> + 时间:O(n)\r\n> + 空间:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aiweng1981":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185533265","body":"#Python 3\n#Idea:对将其从列表变字符串，再变整型，完成加法，再将结果变成字符串，最后字符串换成列表。\ndef day1(A,K):\n    A0 = []\n    for i in A:\n        A0.append(str(i))\n    A1 = \"\".join(A0)\n    a1 = int(A1)\n    sm = a1 + K\n    sm1 = str(sm)\n    sm2 = []\n    for j in sm1:\n        sm2.append(int(j))\n    return sm2\nA = [1,2,0,0]\nK = 304\nday1(A,K)\n#Complexity\n#Time: O(N)\n#Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186165511","body":"## 思路\n\n> + 思路描述: 看的答案，先学习一下；后来发现自己的思路和答案差不多，但是不会写，哈哈！\n\n##代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n\n        n = len(s)\n        ans = [0] * n\n\n        idx = -n\n        for i, ch in enumerate(s):\n            if ch == c:\n                idx = i\n            ans[i] = i - idx\n\n        idx = 2 * n\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                idx = i\n            ans[i] = min(ans[i], idx - i)\n        return ans\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186384452","body":"## 思路\n\n> + 思路描述:这个题目比较懵，先打卡，慢慢琢磨！\n\n##代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.c = maxSize\n        self.s = []\n\n    def push(self, x: int) -> None:\n        if len(self.s) < self.c:\n            self.s.append(x)\n\n    def pop(self) -> int:\n        if self.s:\n            return self.s.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.s))):\n            self.s[i] += val\n\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187290014","body":"## 思路\n\n> + 思路描述:这个题目开始没有明白，但是后来对着答案，慢慢琢磨明白！\n\n##代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n              \n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n```python\n#代码\n\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N)\n> + 空间复杂度:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189177220","body":"## 思路\n\n> + 思路描述:这类题目不熟悉，不过还是有所收获，有些感觉了！\n\n##代码\n\n\n```python\n#代码\nclass MyQueue:\n    def __init__(self):\n        self.queue = []\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n    def pop(self) -> int:\n#弹出第一个元素\n        return self.queue.pop(0)\n    def peek(self) -> int:\n#返回第一个元素\n        return self.queue[0]\n    def empty(self) -> bool:\n        return not self.queue\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(1)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190277906","body":"## 思路\n\n> + 思路描述:头一次遇上hard！能看懂答案，觉得就OK了、\n\n##代码\n\n\n```python\n#代码\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        count_a = collections.defaultdict(int)\n        count_b = collections.defaultdict(int)\n        ans = 0\n\n        for a, b in zip(arr, sorted(arr)):\n            count_a[a] += 1\n            count_b[b] += 1\n            if count_a == count_b: ans += 1\n\n        return ans\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(N**2)\n> + 空间复杂度:  O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lime":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185549904","body":"### 思路\r\n用数组进行累加\r\n### 代码\r\n```c++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        for(int i = num.size() - 1; i > -1; i--){\r\n            num[i] += k % 10;\r\n            k = k / 10;\r\n        }\r\n        while(k > 0){\r\n            num.insert(num.begin(), k % 10);\r\n            k /= 10;\r\n        }\r\n        int j = num.size() - 1;\r\n        while(j > 0){\r\n            if(num[j] >= 10){\r\n                num[j] -= 10;\r\n                num[j - 1]++;\r\n            }     \r\n            j--;\r\n        }\r\n        if(num[0] >= 10){\r\n            num[0] -= 10;\r\n            num.insert(num.begin(), 1);\r\n        }\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216657","body":"# 思路\n蛮力\n# 代码\n```c++\nvector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> re;\n        for(int i = 0; i < s.length(); i++){\n            if(s[i] == c){\n                re.push_back(i);\n            }\n        }\n        int count = 0;\n        while(count < s.length()){\n            int min = INT_MAX;\n            for(int i = 0; i < re.size(); i++){\n                if(min > abs(re[i] - count)){\n                    min = abs(re[i] - count);\n                }\n            }\n            ans.push_back(min);\n            count++;\n        }\n        return ans;\n    }\n```\n**复杂度**\n- 时间O(n2)\n- 空间O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186506125","body":"# 代码\n```c++\nclass CustomStack {\npublic:\n\n    vector<int> res;\n    int top;\n\n    CustomStack(int maxSize) {\n        res.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != res.size() - 1){\n            top++;     \n            res[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1){\n            return -1;\n        }\n        else{\n            top--;\n            return res[top + 1];\n        }\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k; i++){\n            if(i > top){\n                break;\n            }\n            res[i] += val;\n        }\n        return;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187051742","body":"# 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> str;\n        stack<int> nums;\n        int i = 0;\n        while(i < s.length()){\n            int num = 0;\n            while(s[i] >= '0' && s[i] <= '9'){\n                num = num * 10 + (s[i] - '0');\n                i++;\n            }            \n            if(num != 0){\n                nums.push(num);\n            }\n            if(s[i] != ']'){\n                str.push(s[i]);\n            }\n            else{\n                int n = nums.top();\n                nums.pop();\n                string zifu = \"\";\n                string zifu1 = \"\";\n                while(str.top() != '['){\n                    zifu.insert(zifu.begin(), str.top());\n                    str.pop();\n                }\n                str.pop();\n                for(int i = 0; i < n; i++){\n                    zifu1 += zifu;\n                }\n                for(int i = 0; i < zifu1.length(); i++){\n                    str.push(zifu1[i]);\n                }\n            }\n            i++;\n        }\n        string ans = \"\";\n        while(!str.empty()){\n            ans.insert(ans.begin(), str.top());\n            str.pop();\n        }\n        return ans;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189123157","body":"# 代码\n```c++\nclass MyQueue {\npublic:\n    stack<int> stk1;\n    stack<int> stk2;\n\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while(!stk1.empty()){\n            stk2.push(stk1.top());\n            stk1.pop();\n        }\n        stk1.push(x);\n        while(!stk2.empty()){\n            stk1.push(stk2.top());\n            stk2.pop();\n        }\n    }\n    \n    int pop() {\n        int t = stk1.top();\n        stk1.pop();\n        return t;\n    }\n    \n    int peek() {\n        return stk1.top();\n    }\n    \n    bool empty() {\n        return stk1.empty();\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456030","body":"# 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"acoada":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185584460","body":"## 思路\n\n```raw\nres = []\nwhile (A or B):\n    a = A 当前位\n    b = B 当前位\n    \n    sum = a + b + 进位\n    \n    进位, 当前位 = divmod(sum, 10)\n    res.insert(0, 当前位)\n\n如果还有非 0 进位， res.insert(0, carry)\n```\n\n## 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx, sum_, carry = len(num) -1, 0, 0\n        while idx >= 0 or k != 0:\n            a = num[idx] if idx >= 0 else 0\n            b = k % 10 if k else 0\n\n            sum_ = a + b + carry\n            carry, curr = divmod(sum_, 10)\n            idx -= 1\n            k //= 10\n            res.insert(0, curr)\n        if carry:\n            res.insert(0, carry)\n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206414","body":"## 思路\n\n1. 找到所有 `s` 中 `c` 的坐标\n2. 对于 `s` 中的每个元素都计算和所有 `c` 的坐标的距离\n\n## 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [None for _ in range(len(s))]\n        c_idxes = [idx for idx, i in enumerate(s) if i == c]\n\n        for idx, i in enumerate(s):\n            res[idx] = min( abs(idx - c_idx) for c_idx in c_idxes)\n        \n        return res\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546673","body":"## 思路\n\n按题义模拟即可\n\n## 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self._storage = []\n        self._room = maxSize\n\n    def push(self, x: int) -> None:\n        if self._room > 0:\n            # got room to store element\n            self._storage.append(x)\n            self._room -= 1\n        \n    def pop(self) -> int:\n        try:\n            res = self._storage.pop()\n        except IndexError:\n            return -1\n        else:\n            self._room += 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        for idx in range(len(self._storage[:k])):\n            self._storage[idx] += val\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187612588","body":"## 思路\n\n栈的应用。\n\n## 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in s:\n            if i != \"]\":\n                # keep pushing char into stack until the end `]`\n                stack.append(i)\n            else:\n                lookback = []\n                while (c := stack.pop()) != \"[\":\n                    lookback.append(c)\n                lookback = \"\".join(lookback[::-1])\n                repeat_time = []\n                try:\n                    while (c := stack.pop()) in \"0123456789\":\n                        repeat_time.append(c)\n                except IndexError:\n                    pass\n                else:\n                    # well, c is not number for now, put it back\n                    stack.append(c)\n                repeat_time = int(\"\".join(repeat_time[::-1]))\n                stack.append(repeat_time * lookback)\n\n        return \"\".join(stack)\n```\n\n## 复杂度\n\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195523","body":"## 思路\n\n基础数据结构，模拟即可。\n\n## 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.in_ = []\n        self.out = []\n\n    @staticmethod\n    def _switch(source, target):\n        while source:\n            target.append(source.pop())\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        # out -> in_\n        self._switch(self.out, self.in_)\n        self.in_.append(x)\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        # in_ -> out\n        self._switch(self.in_, self.out)\n        return self.out[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.in_) + len(self.out) == 0\n```\n\n## 复杂度\n\n- Time: O(1) (摊还分析下是 O(1)，最差 O(N))\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190456694","body":"## 思路\n\n题目比较抽象，举一个🌰️  \n\n输入 `arr := [2, 1, 3, 4, 4]`  \n\n1. 切分成若干份  `[2, 1]`, `[3, 4]`, `[4]`  \n2. 每一份独立排序 `[1, 2]`, `[3, 4]`, `[4]`\n3. 将上面得到的组件拼起来 `res := [1, 2, 3, 4, 4]`\n\n在保证 `sorted(arr) == res` 的前提下，上面第 1 步，最多能切多少块出来？  \n\n有点类似桶排序/计数排序：\n\n将原数组和整体排好序的数组并排(zip)在一起向前遍历，检查 `arr[:i]` 和 `sorted_arr[:i]` 是否**计数**一致，是则可多切一块 (`res +=1`)。\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr):\n        res = 0\n        c1 = Counter()\n        c2 = Counter()\n        for a, b in zip(arr, sorted(arr)):\n            c1[a] += 1\n            c2[b] += 1\n            if c1 == c2:\n                res += 1\n        return res\n```\n\n## 复杂度\n\n- Time: O(N^2)\n- Space: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"duanyaqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185585215","body":"# Day 1. [989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n## 思路\r\n加法有以下公式：\r\n\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10   \r\n\r\n直接遍历相加即可，保存 carry，最后有 carry 额外加 1，从小到大加，最后保存的结果要翻转\r\n- 动态数组遍历数组\r\n- int 数字 `%10` 取最低位，`/10` 为了遍历下一个最低位\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0; \r\n    vector<int> res;\r\n    \r\n    // 遍历数组，进行加\r\n    for (int i = num.size() - 1; i >= 0; --i) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + num[i] + carry;  //关键公式!!!\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    // 如果 k 还没处理完，继续处理 k\r\n    while (k > 0) {\r\n        int kn = k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = kn + carry; //关键公式!!! 此时 num[i] 已经是 0 了\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n    }\r\n\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 优化\r\n\r\n发现两个循环其实是一样的，可以放在一起处理\r\n\r\n```c++\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    int carry = 0;\r\n        \r\n    vector<int> res;\r\n    int i = num.size() - 1;\r\n    // 放到一起处理, 如果有一个变成 0, sumn 这里就相当于 + 0\r\n    while (i >= 0 || k > 0) {\r\n        int a = i < 0 ? 0 : num[i];\r\n        int kn = k == 0 ? 0 : k % 10;\r\n        k /= 10;\r\n\r\n        int sumn = a + kn + carry;\r\n\r\n        res.push_back(sumn % 10);\r\n        if (sumn >= 10) {\r\n            carry = 1;\r\n        } else {\r\n            carry = 0;\r\n        }\r\n        i--;\r\n    }\r\n\r\n    // 如果有进位\r\n    if (carry == 1) res.push_back(1);\r\n    reverse(res.begin(), res.end());\r\n\r\n    return res;\r\n}\r\n```\r\n\r\n没变化\r\n> + 时间复杂度: O(max(n,logk))\r\n> + 空间复杂度: O(1)，常数级别，只有res\r\n\r\n\r\n## 模板\r\n\r\n加法模板\r\n```c++\r\nwhile ( A 没完 || B 没完)\r\n    A 的当前位\r\n    B 的当前位\r\n\r\n    和 = A 的当前位 + B 的当前位 + 进位carry\r\n\r\n    当前位 = 和 % 10;\r\n    进位 = 和 / 10;\r\nend\r\n\r\n判断还有进位吗\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186090818","body":"# Day 2. [821. 字符的最短距离](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\n## 思路\r\n\r\n暴力\r\n\r\n- 找出来所有字符c的位置\r\n- 每个位置都与s的每个字符计算距离, 更新最小值\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    vector<int> cset;\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) \r\n            cset.push_back(i);\r\n    }\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        for (int j = 0; j < cset.size(); ++j) {\r\n            res[i] = min(res[i], abs(i - cset[j]));\r\n        }\r\n    }\r\n\r\n    return res;\r\n}\r\n```\r\n> + 时间复杂度: O(mn), m是c的个数, n 是s的长度\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 优化\r\n\r\nbfs + 判断 (主要好久没写bfs了, 练练手)\r\n\r\n\r\n```c++\r\nvector<int> shortestToChar(string s, char c) {\r\n    vector<int> res(s.size(), 0x3f3f3f3f);\r\n\r\n    queue<int> q;\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        if (s[i] == c) {\r\n            q.push(i);\r\n        }\r\n    }\r\n\r\n    while (q.size()) {\r\n        int idx = q.front(); q.pop();\r\n\r\n        for (int i = 0; i < s.size(); ++i) {\r\n            int dis = abs(i - idx);\r\n            if (res[i] > dis) {\r\n                res[i] = dis;\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    return res;\r\n}\r\n```\r\n\r\n\r\n> + 时间复杂度: O(mn)\r\n> + 空间复杂度: O(m + n)\r\n\r\n\r\n## 模板\r\n\r\nbfs 迭代模板\r\n```c++\r\nqueue<int> q;\r\n// q.push(i);\r\nwhile (q.size()) {\r\n    int idx = q.front(); q.pop();\r\n\r\n    for (int i = 0; i < s.size(); ++i) {\r\n        int dis = abs(i - idx);\r\n        if (res[i] > dis) {\r\n            res[i] = dis;\r\n            //q.push(i);\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457659","body":"# Day 3. [1381. 设计一个支持增量操作的栈](https://leetcode.cn/problems/design-a-stack-with-increment-operation/)\r\n## 思路\r\n\r\n直接用 stack 模拟\r\n\r\n- increment 的时候，需要用一个辅助栈，计算出需要 +val 的边界 `int remain = max(0, (int)(mSt.size() - k));`\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mSt.size() < mMaxSize) {\r\n            mSt.push(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mSt.size() == 0) return -1;\r\n        int num = mSt.top(); mSt.pop();\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        stack<int> mStTmp;\r\n        int remain = max(0, (int)(mSt.size() - k));    // 不加的个数\r\n\r\n        while (remain) {                        // 把不加 val 的数字给跳过去\r\n            mStTmp.push(mSt.top()); mSt.pop();\r\n            remain--;\r\n        }\r\n\r\n        while (mSt.size()) {                    // 把剩下的 mSt 里的元素 + val\r\n            mStTmp.push(mSt.top() + val); mSt.pop();\r\n        }\r\n\r\n        while (mStTmp.size()) {                 // \r\n            mSt.push(mStTmp.top()); mStTmp.pop();\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    stack<int> mSt;\r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 优化\r\n\r\n直接用数组模拟栈就好了，对栈底元素好处理\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (mVec.size() < mMaxSize) {\r\n            mVec.push_back(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (mVec.size() == 0) return -1;\r\n        int num = mVec.back(); mVec.erase((--mVec.end()));\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, (int)mVec.size()); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    vector<int> mVec;\r\n};\r\n```\r\n\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 负优化\r\n\r\n去除繁琐的 erase，直接用 `top` 表示栈顶位置\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top]; \r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = 0; i < min(k, top+1); ++i) \r\n            mVec[i] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // 表示栈顶\r\n    vector<int> mVec;\r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n---\r\n## 究极优化\r\n\r\n- 只有在 pop 操作时，我们才需要知道栈顶元素的具体值，在其余的情况下，我们只要存储每个元素的增量就行了。\r\n- 因此在遇到 pop 操作时，我们返回栈顶元素的初始值加上增量 add[top]。\r\n- `add[i]` 表示前 i - 1 个元素的增量\r\n\r\n```c++\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : mMaxSize(maxSize) {\r\n        mVec.resize(maxSize);\r\n        mInc.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top < mMaxSize - 1) {\r\n            ++top;\r\n            mVec[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1) return -1;\r\n        int num = mVec[top] + mInc[top]; \r\n        if (top > 0) {\r\n            mInc[top - 1] += mInc[top];\r\n        }\r\n        mInc[top] = 0;\r\n        --top;\r\n        return num;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = min(k - 1, top); \r\n        \r\n        if (idx >= 0)   // top 可能是 -1\r\n            mInc[idx] += val;\r\n    }\r\n\r\nprivate:\r\n    int mMaxSize;\r\n    int top;        // 表示栈顶\r\n    vector<int> mVec, mInc; //mInc[i] 表示下标<=i的元素的增量\r\n};\r\n```\r\n> + 时间复杂度: O(1)\r\n> + 空间复杂度: O(1)\r\n\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637162","body":"# Day 4. [394. 字符串解码](https://leetcode.cn/problems/decode-string/)\r\n## 思路\r\n\r\n递归解析表达式，编译原理，符合 LL(1) 文法\r\n- 从左向右分析（Left-to-right-parse）\r\n- 最左推导（Leftmost-derivation）\r\n- 超前查看一个符号（1-symbol lookahead）\r\n\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit() {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string getString() {    \r\n        if (ptr == src.size() || src[ptr] == ']') {\r\n            return \"\";  //String -> eps\r\n        }\r\n\r\n        string res;             // 最后返回的结果\r\n        char cur = src[ptr];    // ptr下标的字符\r\n\r\n        if (isdigit(cur)) {\r\n            // String -> Digits[String] String\r\n            // 解析 Digits \r\n            int times = getDigit(); //字符串乘的次数\r\n            // 过滤左括号\r\n            ++ptr;\r\n            // 解析 string\r\n            string str = getString();\r\n            // 过滤右括号\r\n            ++ptr;\r\n            // 字符串累乘\r\n            while(times--) \r\n                res += str;\r\n        } else if (isalpha(cur)) {\r\n            // String -> Alpha String\r\n            // 解析 Alpha\r\n            res = src[ptr++];\r\n        }\r\n\r\n        return res + getString();       \r\n        // 走到这一步，后边可能还有表达式,\r\n        // 所以要继续递归并且把后边的结果拼接起来\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        src = s;\r\n        ptr = 0;\r\n        return getString();\r\n    }\r\n\r\nprivate:\r\n    string src;\r\n    size_t ptr;\r\n};\r\n```\r\n> + 时间复杂度: O(n)，n 为 s 长度\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 栈\r\n\r\n两个栈分别维护数字和字符串\r\n\r\n```c++\r\nclass Solution {\r\npublic:\r\n    int getDigit(string &src, size_t &ptr) {\r\n        int res = 0;\r\n        while (ptr < src.size() && isdigit(src[ptr])) {\r\n            res = res * 10 + src[ptr] - '0';\r\n            ptr++;\r\n        }\r\n        return res;\r\n    }\r\n\r\n    string decodeString(string s) {        \r\n        stack<int> numSt;\r\n        stack<string> stringSt;\r\n        string res;\r\n        int numT;\r\n        size_t ptr = 0; \r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n\r\n            if (cur == '[') {\r\n                ptr++;\r\n                numSt.push(numT);\r\n                stringSt.push(res);\r\n                res = \"\";\r\n            } else if (cur == ']') {\r\n                ptr++;\r\n                string tmpSrc;\r\n                int times = numSt.top(); numSt.pop();\r\n                while (times--)\r\n                    tmpSrc += res;\r\n                res = stringSt.top() + tmpSrc; stringSt.pop();\r\n            } else if (isdigit(cur)) {\r\n                numT = getDigit(s, ptr);\r\n            } else if (isalpha(cur)) {\r\n                ptr++;\r\n                res += cur;\r\n            }  \r\n        } \r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n\r\n> + 时间复杂度: O(n)，n 为 s 长度\r\n> + 空间复杂度: O(n)\r\n\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188982095","body":"# Day 5. [232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n## 思路\r\n\r\n两个栈来回倒，这怎么难度又下去了\r\n\r\n\r\n```c++\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        while (st.size()) {\r\n            stT.push(st.top()); st.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        while (stT.size()) {\r\n            st.push(stT.top()); stT.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n    \r\n    int peek() {\r\n        stT = st;\r\n        while (stT.size() != 1) {\r\n            stT.top(); stT.pop();\r\n        }\r\n\r\n        int res = stT.top(); stT.pop();\r\n        return res;\r\n    }\r\n    \r\n    bool empty() {\r\n        return st.empty();\r\n    }\r\n\r\nprivate:\r\n    stack<int> st, stT;    \r\n};\r\n```\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)\r\n\r\n----\r\n\r\n## 模板\r\n\r\n无模板","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190490612","body":"# Day 6. [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n## 思路\r\n\r\n将原数组进行分块后，对各分块分别进行排序后的结果等于原数组排序后的结果.\r\n\r\n下一个分块中的所有数字都会大于等于上一个分块中的所有数字.\r\n\r\n- 栈存每个分块的最大值\r\n- 如果遍历到的新数字比之前分块的最大值都要大，我们就把它作为一个新的分块\r\n- 如果遍历到的新数字小于之前某些分块的最大值，那这些分块都要被合成一个分块\r\n\r\n\r\n```c++\r\nint maxChunksToSorted(vector<int>& arr) {\r\n    stack<int> st;\r\n    st.push(arr[0]);\r\n\r\n    for (int i = 1; i < arr.size(); ++i) {\r\n        if (arr[i] >= st.top()) {\r\n            st.push(arr[i]);\r\n        } else {\r\n            int head = st.top(); st.pop();  // 先把头部取出来\r\n            while (st.size() != 0 && arr[i] < st.top()) { // 合并比他大的数\r\n                st.pop();\r\n            }\r\n            st.push(head);\r\n        }\r\n    }\r\n\r\n    return st.size();\r\n}\r\n```\r\n> + 时间复杂度: O(N)，N 为数组长度。\r\n> + 空间复杂度: O(N)\r\n\r\n----\r\n## 模板\r\n\r\n无模板","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185589950","body":"# 思路\r\n\r\n```\r\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\r\n\r\n```\r\n\r\n# 代码\r\n\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K) {\r\n        int a_len = A.size() - 1, sum = 0, carry = 0;\r\n        vector<int> res;\r\n        while (a_len >= 0 || K != 0) {\r\n            int x = a_len >= 0 ? A[a_len] : 0;\r\n            int y = K != 0 ? K % 10 : 0;\r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            K /= 10;\r\n            a_len--;\r\n            res.push_back(sum);\r\n        }\r\n        if (carry != 0)\r\n            res.push_back(carry);\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n# 复杂度\r\n+ 时间复杂度：O(n);\r\n+ 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225771","body":"# 思路\r\n```\r\n记录下c的索引，然后每个字符挨个求最小值\r\n```\r\n\r\n# 代码\r\n```\r\nvector<int> shortestToChar(string &s, char c) {\r\n        vector<int> index;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c) {\r\n                index.push_back(i);\r\n            }\r\n        }\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); i++) {\r\n            if (s[i] == c)\r\n                res.push_back(0);\r\n            else {\r\n                int min_index = s.length();\r\n                for (int j = 0; j < index.size(); j++) {\r\n                    int deterval = index[j] - i >= 0 ? index[j] - i : i - index[j];\r\n                    if (deterval < min_index)\r\n                        min_index = deterval;\r\n                }\r\n                res.push_back(min_index);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n# 复杂度\r\n+ 空间：O(N)\r\n+ 时间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547531","body":"/*\r\n * 1. 思路: 正常的用数组直接操作,incr的时间复杂度为O(k), 可以用前缀和用时间换空间\r\n * 2. 时间复杂度: O(1), 空间复杂度: O(1)\r\n * */\r\n \r\n```\r\nclass CustomStack\r\n{\r\npublic:\r\nCustomStack(int maxSize)\r\n{\r\n    this->maxSize = maxSize;\r\n    stack = new int[maxSize];\r\n    incre = new int[maxSize];\r\n    cur = 0;\r\n}\r\n\r\nvoid push(int x)\r\n{\r\n    if (cur == maxSize)\r\n        return;\r\n    stack[cur] = x;\r\n    incre[cur] = 0;\r\n    cur++;\r\n}\r\n\r\nint pop()\r\n{\r\n    if (cur == 0)\r\n        return -1;\r\n    int res = stack[cur - 1] + incre[cur - 1];\r\n    if (cur > 1)\r\n        incre[cur - 2] += incre[cur - 1];\r\n    incre[cur - 1] = 0;\r\n    cur--;\r\n    return res;\r\n}\r\n\r\nvoid increment(int k, int val)\r\n{\r\n    if (cur == 0)\r\n        return ;\r\n    if (k > cur)\r\n        incre[cur - 1] += val;\r\n    else\r\n        incre[k - 1] += val;\r\n}\r\n\r\n~CustomStack()\r\n{\r\n    delete[] stack;\r\n    delete[] incre;\r\n}\r\nprivate:\r\nint maxSize;\r\nint* stack;\r\nint* incre;\r\nint cur;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186853934","body":"/*\r\n * 1、思路: 利用栈，非']'即入栈，否则出栈;\r\n * 2、出栈的时候注意将一个[]之内解码好的压回栈，最后在对栈中所有解码后的字符串进行拼接;\r\n * 2、需要注意char转string，利用string的构造函数string(n, char);\r\n * 3、数字可能是多位的，因此需要注意转换;\r\n * 4、时间复杂度O(n), 空间复杂度O(n)\r\n * */\r\n\r\n```\r\nstring decodeString(string &s)\r\n    {\r\n        stack<string> data;\r\n        for(int i = 0; i < s.length(); i++)\r\n        {\r\n            // 数字、字母和左方括号入栈\r\n            if ((s[i] >= '0' && s[i] <= '9') || (s[i] == '[') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >= 'A' && s[i] <= 'Z'))\r\n            {\r\n                data.push(string(1, s[i]));\r\n            }\r\n                // 右方括号出栈\r\n            else\r\n            {\r\n                string cur = \"\";\r\n                while(data.top().data()[0] != '[')\r\n                {\r\n                    cur = data.top() + cur;\r\n                    data.pop();\r\n                }\r\n                data.pop();\r\n                // 取整数\r\n                int digit = 0;\r\n                int carry = 1;\r\n                while(!data.empty() && data.top().data()[0] >= '0' && data.top().data()[0] <= '9')\r\n                {\r\n                    digit = digit + (data.top().data()[0] - '0') * carry;\r\n                    carry *= 10;\r\n                    data.pop();\r\n                }\r\n                string res = \"\";\r\n                for (int j = 0; j < digit; j++)\r\n                    res += cur;\r\n                data.push(res);\r\n            }\r\n        }\r\n        string res = \"\";\r\n        while(!data.empty())\r\n        {\r\n            res = data.top() + res;\r\n            data.pop();\r\n        }\r\n        return res;\r\n    }\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189128910","body":"/*\r\n * leetcode: 232\r\n * 用两个栈模拟队列,可以通过在pop时只有reverse为空时再倒腾栈来优化\r\n * 时间复杂度:均摊O(1), 空间复杂度:O(n)\r\n * */\r\n\r\n```\r\nclass MyQueue{\r\npublic:\r\n    MyQueue()\r\n    {\r\n\r\n    }\r\n\r\n    void push(int x)\r\n    {\r\n        normal_stack.push(x);\r\n    }\r\n\r\n    int pop()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        reverse_stack.pop();\r\n        return res;\r\n    }\r\n\r\n    int peek()\r\n    {\r\n        if (reverse_stack.empty())\r\n        {\r\n            while(!normal_stack.empty())\r\n            {\r\n                reverse_stack.push(normal_stack.top());\r\n                normal_stack.pop();\r\n            }\r\n        }\r\n\r\n        int res = reverse_stack.top();\r\n        return res;\r\n    }\r\n\r\n    bool empty()\r\n    {\r\n        return (normal_stack.empty() && reverse_stack.empty());\r\n    }\r\nprivate:\r\n    stack<int> normal_stack;\r\n    stack<int> reverse_stack;\r\n\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190458724","body":"/*\r\n * 1.思路: 单调栈大值融合小值构成递增栈\r\n * 2.时间复杂度: O(n), 空间复杂度:O(n)\r\n * */\r\n ```\r\nint maxChunksToSorted(vector<int>& arr)\r\n    {\r\n        stack<int> info;\r\n        int max_value;\r\n        for(auto it: arr)\r\n        {\r\n            if(!info.empty() && it < info.pop())\r\n            {\r\n                max_value = info.top();\r\n                if(it < max_value)\r\n                {\r\n                    while(!info.empty() && info.top() > it)\r\n                    {\r\n                        info.pop();\r\n                    }\r\n                    info.push(max_value);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                info.push(it);\r\n            }   \r\n        }\r\n        return info.size();\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kaiykk":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185593642","body":"## 思路\n\n> + 思路描述\n倒着过一遍num，和k逐位相加。\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        idx = len(num) - 1\n        while k or idx > -1:\n            cur = k % 10 + num[idx] if idx >= 0 else k % 10\n            k //= 10\n            if cur >= 10:\n                k += 1\n                cur = cur % 10\n            res.append(cur)\n            idx -= 1\n        res.reverse()\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度: O(N)\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186180673","body":"## 思路\n\n> + 思路描述\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j - i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i - j)\n                    i -= 1\n        return res\n```\n\n## 复杂度\n\n> + 时间复杂度:  O(n)\n> + 空间复杂度:  O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186544663","body":"## **思路：用数组模拟**\n\n朴素的模拟方法\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = list()\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [n+val for n in self.stack]\n        else:\n            self.stack = [n+val for n in self.stack[:k]] + self.stack[k:]\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) push pop是O(1)，increment是O(n)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188955309","body":"## 思路\n一个栈存放数字，一个栈存放字母\n```python\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop 掉'['\n                cnt = ''\n                while stack and stack[-1].isdigit():\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) \n        return ''.join(stack)\n```\n\n## 复杂度分析\n- 时间复杂度：O(n) \n- 空间复杂度：O(n) ","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189184499","body":"## 思路\n- 两个栈来回变换，两个栈stackin和stackout一个只用来进新的元素一个只用来出结果。用一个辅助的self.front变量，记录stackin最前面的元素。\n- pop的时候，可以在stackout空的时候倒出来，不空的时候直接出栈顶即可。peak的时候，如果stackout非空的话，肯定就是栈顶的元素，否则，就是self.front.\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stackin = []\n        self.stackout = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        if not self.stackin:\n            self.front = x\n        self.stackin.append(x)\n\n    def pop(self) -> int:\n        if not self.stackout:\n            while self.stackin:\n                self.stackout.append(self.stackin.pop())\n        if self.empty():\n            return\n        return self.stackout.pop()\n\n    def peek(self) -> int:\n        return self.stackout[-1] if self.stackout else self.front\n\n    def empty(self) -> bool:\n        return not self.stackin and not self.stackout\n```\n\n## 复杂度\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cachezhou0617":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185598055","body":"## 思路\r\n\r\n> + 参考题解后解答，回去查看讲义和类似题目 巩固之\r\n\r\n##代码\r\n\r\n```java\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n\r\n```\r\n\r\n\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225705","body":"### 思路\r\n\r\n双向遍历，记录最小的值\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // 从左往右遍历\r\n        for (int i = 0, index = -n; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = i - index;\r\n\r\n        }\r\n        \r\n        // 从右往左遍历\r\n        for (int i = n - 1, index = 2 * n; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                index = i;\r\n            }\r\n            res[i] = Math.min(res[i], index - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551756","body":"### 思路\r\n\r\n有点迷糊，参考题解 多次调试大概理解 数组模拟栈的思路 继续研究一下\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length -1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k,top+1);\r\n        for (int i = 0; i < limit; ++i){\r\n            stack[i] = stack[i] + val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187669690","body":"### 思路\r\n\r\n想起算法4中Dijkstra的双栈算术表达式求值算法，思路一样 只不过将()变成[] \r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp = temp + c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为字符串长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189229330","body":"### 思路\r\n\r\n栈先进后出  队列先进先出\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\n//leetcode submit region begin(Prohibit modification and deletion)\r\nclass MyQueue {\r\n    // 创建两个栈 出入\r\n    Stack<Integer> stkIn;\r\n    Stack<Integer> stkOut;\r\n    public MyQueue() {\r\n        stkIn = new Stack<>();\r\n        stkOut = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stkIn.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stkOut.isEmpty()){\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stkOut.isEmpty()) {\r\n            while(!stkIn.isEmpty()){\r\n                stkOut.push(stkIn.pop());\r\n            }\r\n        }\r\n        return stkOut.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stkOut.isEmpty() && stkIn.isEmpty();\r\n    }\r\n}\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190428049","body":"### 思路\r\n\r\n对数组进行循环入栈，遇到大于等于栈顶的元素直接入栈，若小于栈顶的元素，先取出栈顶元素，然后入栈 \r\n栈的元素个数即为所得块的最大个数\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> resStk = new Stack<>();\r\n        resStk.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++ ) {\r\n            if(!resStk.isEmpty() && arr[i] >= resStk.peek()){\r\n                resStk.push(arr[i]);\r\n            } else {\r\n                int curMax =resStk.pop();\r\n                while(!resStk.isEmpty() && resStk.peek() > arr[i]) {\r\n                    resStk.pop();\r\n                }\r\n                resStk.push(curMax);\r\n            }\r\n        }\r\n        return resStk.size();\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度:O(n)\r\n空间复杂度:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangtuo1999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185599809","body":"## 思路\r\n把 k 转换成数组，再将 num 和 k 两个数组反转。双指针，从头到尾依次将余数插入结果数组中。\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n  const num1 = num.reverse();\r\n  const num2 = k\r\n    .toString()\r\n    .split(\"\")\r\n    .map((item) => parseInt(item))\r\n    .reverse();\r\n  const result = [];\r\n  let m = 0;\r\n  let n = 0;\r\n  let extra = 0;\r\n  while (m < num1.length && n < num2.length) {\r\n    const sum = num1[m++] + num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (m < num1.length) {\r\n    const sum = num1[m++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  while (n < num2.length) {\r\n    const sum = num2[n++] + extra;\r\n    extra = sum > 9 ? 1 : 0;\r\n    result.push(sum % 10);\r\n  }\r\n  if (extra) {\r\n    result.push(1);\r\n  }\r\n  return result.reverse();\r\n};\r\n```\r\n## 复杂度\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218481","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (s, c) {\r\n  const result = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    for (let j = 0; j < s.length; j++) {\r\n      if (s[j] === c) {\r\n        result[i] = Math.abs(i - j);\r\n        break;\r\n      }\r\n    }\r\n    for (let j = s.length - 1; j >= 0; j--) {\r\n      if (s[j] === c && Math.abs(i - j) < result[i]) {\r\n        result[i] = Math.abs(i - j);\r\n      }\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186532482","body":"## 思路\r\n顺序栈，学过数据结构的都懂\r\n\r\n## 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.ptr = 0;\r\n  this.stack = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.ptr < this.maxSize) {\r\n    this.stack[this.ptr++] = x;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.ptr === 0) {\r\n    return -1;\r\n  }\r\n  return this.stack[--this.ptr];\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (let i = 0; i < Math.min(k, this.ptr); i++) {\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187635454","body":"```javascript\r\nvar decodeString = function (s) {\r\n  let numStack = [];\r\n  let strStack = [];\r\n\r\n  let num = 0,\r\n    result = \"\";\r\n\r\n  for (let i = 0; i < s.length; i++) {\r\n    const item = s[i];\r\n\r\n    if (!isNaN(item)) {\r\n      num = num * 10 + parseInt(item);\r\n    } else if (item === \"[\") {\r\n      strStack.push(result);\r\n      result = \"\";\r\n      numStack.push(num);\r\n      num = 0;\r\n    } else if (item === \"]\") {\r\n      const repeatTimes = numStack.pop();\r\n      result = strStack.pop() + result.repeat(repeatTimes);\r\n    } else {\r\n      result += item;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189199748","body":"```javascript\r\nvar MyQueue = function () {\r\n  this.front = null;\r\n  this.stack1 = [];\r\n  this.stack2 = [];\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n  if (this.stack1.length === 0) {\r\n    this.front = x;\r\n  }\r\n  this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n  if (this.stack2.length === 0) {\r\n    while (this.stack1.length > 0) {\r\n      this.stack2.push(this.stack1.pop());\r\n    }\r\n  }\r\n  return this.stack2.pop();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n  if (this.stack2.length > 0) {\r\n    return this.stack2[this.stack2.length - 1];\r\n  }\r\n  return this.front;\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n  return this.stack1.length === 0 && this.stack2.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392983","body":"## 思路\r\n前缀和\r\n\r\n## 代码\r\n```javascript\r\nvar maxChunksToSorted = function (arr) {\r\n  let sum1 = 0;\r\n  let sum2 = 0;\r\n  let ans = 0;\r\n  let arr2 = [...arr].sort((a, b) => a - b);\r\n  for (let i in arr) {\r\n    sum1 = sum1 + arr[i];\r\n    sum2 = sum2 + arr2[i];\r\n    if (sum1 == sum2) {\r\n      ans += 1;\r\n      sum1 = 0;\r\n      sum2 = 0;\r\n    }\r\n  }\r\n  return ans;\r\n};\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cytrue":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185613290","body":"           public List<Integer> addToArrayForm(int[] num, int k) {\n\n        List<Integer> res=new ArryList<Integer>();\n        int n=num.length;\n        for(int i=n-1;i>=0;--i)\n        {\n            int sum=num[i] + k % 10;//如果K=123这个数，那K % 10 取出来的是个数的余数，即把3取出来\n            K / =10;//相当于K=K/10；就是123除于10并取整返回，那就是往前进一位，返3去掉，返回12值给下一次用\n            if(sum>=10)//如果sum得出来的值大于10\n            {\n                k++;//把进位的值放在k上，即k进一位，加1\n                sum-=10;//把相加的值减掉进位\n            }\n            res.add(sum);\n        }\n        //如果num的位数小于K的位数，那还需要多一步处理K剩下的数\n        for(; k > 0;k / =10)//每次循环K的前进一位，如果小于0则表示已经没有数可以进位了\n        {\n            res.add(k % 10 ); //把K的余数取出来返回\n        }\n\n        Collections.reverse(res);\n        return res;\n\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173222","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] ans=new int[n];\n        for(int i=0,idx=-n;i<n;++i)\n        {\n            //第一层循环，从左往右找，主要是先找到值，更新找到值的后面偏移量，idx的初始值无所谓\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=i-idx;\n        }\n    //开始第二层循环,从右往左找\n      for(int i=n-1,idx=2*n;i>=0;--i)\n        {\n            if(s.charAt(i)==c)\n            {\n                idx=i;\n            }\n            ans[i]=Math.min(ans[i],idx-i);\n\n        }\n        return ans;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186413613","body":"//定义这个类，必须要有弹出和增加数据的接口\r\n//新增一个限制的数，还控制数量的增加，每次增和弹出栈的时候，先弹出数组的那个数，限制再减一\r\n\r\n class customerStack2{\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public customerStack2(int maxSize)\r\n    {\r\n    stack=new int[maxSize];\r\n    top =-1;\r\n    }\r\n\r\n    //新增一个数\r\n    public void push(int x)\r\n    {\r\n        if(top!=stack.length-1)\r\n\r\n        {\r\n            top++;\r\n            stack[top]=x;\r\n\r\n        }\r\n\r\n    }\r\n\r\n    // 弹出一个数\r\n    public   int pop()\r\n    {\r\n\r\n        if (top==-1)\r\n        {\r\n            return -1;\r\n        }\r\n\r\n        --top;\r\n        return stack[top+1];\r\n\r\n    }\r\n\r\n    //在每个数据上面增加一个数字\r\n    public void increment(int k,int x)\r\n    {\r\n\r\n        int max=Math.min(k, top+1);\r\n        for(int i=0;i<max;i++)\r\n        {\r\n         \r\n            stack[i] +=x;\r\n        }\r\n\r\n\r\n    }\r\n\r\n }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186728695","body":"//用栈来解决\n//数字和字母都进栈，当碰到】号时，就开始循环重复生成字符串，生完后再反转\n\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190402692","body":"public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n\n        //arr=2,1,3,4,4\n        //expect=1，2，3，4，4\n        for (int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            //第一轮，x=2，y=1\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            //count.map key=2,value=1\n            //nonzero=1;\n\n            //第二轮，x=1，y=2\n            //count.map key=1,value=1\n            //nonzero=1\n\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n\n\n            count.put(y, count.getOrDefault(y, 0) - 1);\n\n            //count map key=1 value=-1\n            //nonzero=2\n\n            //第二轮\n            //count map key=2 value=0；\n\n            //nonzero=1\n\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n\n            if (nonzero == 0) {\n                ans++;\n            }\n        }\n\n        return ans;\n    }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckyryan-web":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615180","body":"```ts\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const res: number[] = []\n\n    // 从数组的最右边开始计算，来模拟数字相加操作\n    const len = num.length\n\n    for (let i = len - 1; i >= 0; --i) {\n        let carry = num[i] + k % 10\n\n        k = Math.floor(k / 10)\n\n        if (carry >= 10) {\n            k++\n            carry = carry - 10\n        }\n\n        res.push(carry)\n    }\n\n    while (k > 0) {\n        res.push(k % 10)\n        k = Math.floor(k / 10)\n    }\n\n    res.reverse()\n\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207697","body":"```ts\n/**\n * 正反遍历:\n * 思路为正反两个方向都遍历一次数据，然后取两次数组每个下表比较的最小值即可\n */\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n\n    /** 先定义一个跟 s 长度一样的数组去存储值 */\n    const answer: number[] = new Array(n).fill(0)\n\n    // 正向遍历\n    for (let i = 0, j = -n; i < n; i++) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        // 计算每个下标到 \"c\" 字符串的距离\n        answer[i] = i - j\n\n    }\n\n    // 反向遍历\n    for (let i = n - 1, j = 2 * n; i >= 0; i--) {\n        if (s[i] === c) {\n            j = i\n        }\n\n        answer[i] = Math.min(answer[i], j - i)\n\n    }\n\n    return answer\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186416013","body":"```ts\nclass CustomStack {\n    protected stack!: number[]\n    protected top!: number\n\n    constructor(maxSize: number) {\n        this.stack = new Array(maxSize)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        // 只要是不超过栈的最大长度\n        if (this.top !== this.stack.length - 1) {\n            this.top++\n            this.stack[this.top] = x\n        }\n    }\n\n    pop(): number {\n        // 判断为空的栈\n        if (this.top === -1) {\n            return -1\n        }\n        this.top--\n        return this.stack[this.top + 1]\n    }\n\n    increment(k: number, val: number): void {\n        const limit = Math.min(k, this.top + 1)\n        for (let i = 0; i < limit; i++) {\n            this.stack[i] = this.stack[i] + val\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187648428","body":"```ts\n/**\n * @author liuyuan\n * @date 2022-07-18 22:39\n * @since 1.0.0\n */\n\nfunction decodeString(s: string): string {\n    // 重复字符串\n    let stack_count: any[] = []\n    let stack_str: any[] = []\n\n    let result = ''\n\n    // 重复次数的栈\n    let count = 0\n\n    for (let i = 0; i < s.length; i++) {\n        // 当前遍历到的字符串\n        let item = s[i]\n\n        if (!isNaN(Number(item))) {\n            count = count * 10 + parseInt(item)\n        } else if (item === '[') {\n            stack_str.push(result)\n            result = ''\n\n            stack_count.push(count)\n            count = 0\n        } else if (item === ']') {\n            const repeatTimes = stack_count.pop()\n            result = stack_str.pop() + result.repeat(repeatTimes)\n        } else {\n            result = result + item\n        }\n    }\n\n    return result\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189062920","body":"```ts\nclass MyQueue {\n    protected inStack: number[]\n\n    protected outStack: number[]\n\n    constructor() {\n        this.inStack = []\n        this.outStack = []\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    /**\n     * 把所有的数据都弹入另一个队列，然后在另一个队列 pop()\n     */\n    pop(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.formatIn2Out()\n        }\n\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return !this.inStack.length && !this.outStack.length\n    }\n\n    formatIn2Out() {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190392499","body":"使用滑动窗口解法，只需要排序后的数组跟原数组进行比较，判断分区后的代码总和与原数组一致即可判断为可分区\n\n```ts\nfunction maxChunksToSorted(arr: number[]): number {\n    const sorted = [...arr]\n\n    sorted.sort((a, b) => a - b)\n\n    let count = 0\n\n    /** 原分组的和 */\n    let sum1 = 0\n\n    /** 分块后的数组的和 */\n    let sum2 = 0\n\n    for (let i = 0; i < arr.length; i++) {\n        sum1 = sum1 + arr[i]\n\n        sum2 = sum2 + sorted[i]\n\n        if (sum1 === sum2) {\n            count++\n        }\n    }\n\n    return count\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191276779","body":"```ts\n\n\n/** \n * 思路: \n * 旋转链表，其实就是把倒数第二位的 next -> null, 然后最后一位的 next 从 null 指向于头部,这个流程就是旋转了一位\n * 假设如题目中的 1 -> 2 -> 3 -> 4 -> 5 旋转一位，其实就是 4 -> null 和 5 -> 1, 然后再返回最后一位指向 head 最后一个节点，即可得到结果\n * \n * 推算:\n * 以此为推算，就可以假设移动的最后一个节点为 K, 倒数第二位节点为 K+1\n * 也就是 (K+1).next = null , K.next = head, 然后返回 K 即可\n * \n * 计算移动位数的时候，只需要考虑到 k & count(链表长度)的结果即可， 因为长度为 3 的链表往右边移动 4 位跟往右边移动一位的结果是一样的\n */\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\n    /** 排除空链表和移动为 0 的极端情况 */\n    if (!head || !head?.next || k === 0) {\n        return head\n    }\n\n    /** 链表中的总长度, 上面判断了空和长度为 0 的情况，所以长度至少为 1 */\n    let count = 1\n\n    let p = head\n\n    /** 计算链表的总长度 */\n    while (p?.next !== null) {\n        p = p.next\n        count++\n    }\n\n    /** 最终移动的位置 */\n    k = k % count\n\n    let slow: ListNode | null = head\n\n    let fast: ListNode | null = head\n\n    while (fast?.next) {\n        if (k-- <= 0) {\n            slow = slow.next!\n        }\n        fast = fast.next\n    }\n\n    /** \n     * 此时已经形成一个环形链表了, 然后把慢指针的 next 返回即为结果，然后再把 next -> null 来砍断链表\n     */\n    fast!.next = head\n\n    const res = slow.next\n\n    slow.next = null\n\n    return res\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185615532","body":"### **思路：加法问题**\n\n倒着过一遍num，和k逐位相加。\n\n1. k的位数：用取mod和地板除可以直接把k用掉的位置扔掉，同时如果要进位，直接进位到k上即可。是一种比较便捷的方式。\n2. 一开始想用先初始化n长度的list存储结果，但是其实list长度很难定，所以可以直接用reverse，reverse复杂度是O(n)\n3. 注意会有k长度比num大的情况的！并不都是k长度小于n，所以要考虑遍历完还有k或者carry的情况\n    \n\n### **代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        res = []\n        for i in range(len(num)-1, -1, -1):\n            cur_n = num[i]\n            cur_add = k % 10\n            add_n = cur_n + cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        while k or carry:\n            cur_add = k % 10\n            add_n = cur_add + carry\n            res.append(add_n % 10)\n            carry = add_n // 10\n            k //= 10\n        res.reverse()\n        return res\n\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(min(n,k)) reverse复杂度是O(n) 所以是n长度和k长度最小值\n- 空间复杂度：O(1) 没有额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186173638","body":"## **思路: 正反双指针**\n\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n### **代码**\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)): # j是右指针，右指针碰到c的话，就开始计算左指针\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n) n是s长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525310","body":"## **思路2：前缀和思想**\n\n用一个incrementals数组来记录加的数字最远加到哪里。在pop出去的时候只要对应找该位置加了多少即可，不需要全部都记录\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxsize/n)  把n当作操作数的话，平均来看是maxsize/n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187596495","body":"### **思路**\n\n不是']'就全部入栈，碰到']'开始解码，解码就是一个个拆出来，碰到'['停止拆字符串，碰到数字就另外算要重复的数字是多少。这里有两个地方容易错，一个是数字未必是个位数，一个是出栈之后的str不要直接拼到结果上，继续入栈（不然这样的case无法通过\"3[a2[c]]\"），最后把栈当作结果join一下即可。\n\n### **代码**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i, char in enumerate(s):\n            if char != ']':\n                stack.append(char)\n            elif char == ']':\n                repeat_s = ''\n                while stack and stack[-1] != '[':\n                    repeat_s = stack.pop() + repeat_s\n                stack.pop() # pop 掉'['\n                cnt = ''\n                while stack and stack[-1].isdigit(): # 可能有多个数字\n                    cnt = stack.pop() + cnt\n                repeat_s = repeat_s * int(cnt)\n                stack.append(repeat_s) # 这里是一个要点，重复的字符串直接压回栈里\n        return ''.join(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) 遍历\n- 空间复杂度：O(n) 用了辅助站","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189002648","body":"思路\n相当于两个栈容器，互相倒来倒去。\n代码\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2.pop()\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack1) + len(self.stack2) == 0\n\n复杂度分析\n时间复杂度：O(n) 最坏O(n)，最好O(1)\n空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190237191","body":"### **思路1：单调栈**\n\n一开始的做法是**找单调递增的地方，在每个单调递增的地方切块，是不对的。**也就是扫描数组，记录下一个大于数i的数，如果是单调递增的，下一个比数i大的数就是1，记录递增的数量（每次加1），递增数量和就是结果，但是`[4,2,2,1,1]`过不了！所以题目还有一层意思就是**每一个块要比前一个块大**，每个块的最小要比前一个块的最大要大。\n\nsukki的图很清楚：\n\n[https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kuai-iihua-do/)\n\n### **代码**\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        stack = [] # 用单调栈存储一个块的最大值，单调栈是递增的\n        for i, n in enumerate(arr):\n            if stack and n < stack[-1]: # 碰到更小的值，就得把前面的一个个拿出来，知道形成新的块能够合并掉这个最小值\n                cur_val = stack[-1]\n                while stack and n < stack[-1]:\n                    stack.pop()\n                stack.append(cur_val)\n            else: # 碰到更大的值，可以无脑作为一个新的块\n                stack.append(n)\n        return len(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190998189","body":"### **思路**\n\n先计算链表的长度，记为cnt，k对链表长度取余是要旋转的次数，旋转几次，就是倒数第几个链表拆出来作为头，相当于找到要旋转断开的地方，拆成两个链表，把后面的链表拼到前面的链表上，后面链表指向头，前面链表指向None\n\n### **代码**\n\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: ListNode, k: int) -> ListNode:\n        if not head:\n            return\n        cnt = 0\n        cur = head\n        while cur:\n            cur = cur.next\n            cnt += 1\n        k = k % cnt\n        cur = head\n        cut = 0\n        res = None\n        while cur.next: # cur会停在最后一个node\n            cut += 1\n            if cut == cnt - k: # 碰到要切断的node，就是cur.next\n                tmp = cur.next\n                cur.next = None\n                cur = tmp\n                res = cur\n            else:\n                cur = cur.next\n        if res:\n            cur.next = head\n        return res if res else head\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185624746","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186215661","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186519978","body":"### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187022598","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189096773","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190220524","body":"#### 解题思路\n> 单调栈\n\n#### 代码实现\n\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    //定义最大数据栈\n    let res=[]\n    for(let i = 0; i < arr.length; i++) {\n        if(res.length==0){\n            res.push(arr[i])\n        }else{\n            if(arr[i]>=res[res.length-1]){\n                res.push(arr[i])\n            }else{\n                let max=res[res.length-1]\n                while(arr[i]<res[res.length-1]){\n                    res.pop()\n                }\n                res.push(max)\n            }\n        }\n    }\n    return res.length\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N)$，N为数组长度\n- 空间复杂度：$O(N)$，N为数组长度\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185628129","body":"### 思路\n新建一个数组，长度为num和k的长度的最大值，从num和k的末尾开始相加，得到的值赋值到新数组中，注意进位。\n\n### 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n  let size = Math.max(num.length, (k + '').length);\n  let res = new Array(size);\n  let j = num.length - 1;\n  for (let i = res.length - 1; i >= 0; i--) {\n    let sum = k % 10;\n    if (j >= 0) sum += num[j];\n    if (res[i]) sum += res[i];\n    if (i === 0) {\n      res[i] = sum;\n    } else {\n      res[i] = sum % 10;\n      res[i - 1] = Math.floor(sum / 10);\n    }\n    k = Math.floor(k / 10);\n    j--;\n  }\n  if (res[0] >= 10) {\n    let s = res[0];\n    res[0] = s % 10;\n    res.unshift(Math.floor(s /10));\n  }\n  return res;\n};\n```\n\n### 复杂度\n* time: O(n)\n* space: O(n)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186381448","body":"```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.arr = [];\n  this.maxSize = maxSize;\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.arr.length < this.maxSize) this.arr.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if (this.arr.length === 0) return -1;\n  else return this.arr.pop();\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  for (let i = 0; i < k; i++) {\n    if (i >= this.arr.length) break;\n    this.arr[i] += val;\n  }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n/**\n * 栈\n * time: O(n)\n * space: O(n)\n*/\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189059597","body":"```javascript\n\nvar MyQueue = function() {\n  this.stack1 = [];\n  this.stack2 = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack1.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this.stack1.length > 0) {\n    this.stack2.push(this.stack1.pop());\n  }\n  let res = this.stack2.pop();\n  while (this.stack2.length > 0) {\n    this.stack1.push(this.stack2.pop());\n  }\n  return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack1[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack1.length === 0;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n/**\n * 栈\n * time: O(n)\n * space: O(n)\n * 定义两个栈，pop的时候，将stack1的数据全部pop到stack2，返回stack2栈顶的值，再将stack2全部pop回stack1\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"johnxizhao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185630005","body":"## 思路\r\n遍历数组，从后向前加；随时更新进位变量;\r\n最后需要注意进位是否为1\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        if(k == 0) {\r\n            return Arrays.stream(num).boxed().collect(Collectors.toList());\r\n        }\r\n        StringBuffer sb = new StringBuffer();\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        int carry = 0;\r\n        int ans = 0;\r\n        int i = n - 1;\r\n        while(i >= 0 || k != 0) {\r\n            int x = i >= 0 ? num[i] : 0;\r\n            int y =  k != 0 ? k % 10 : 0;\r\n            int sum = x + y + carry;\r\n            carry = sum / 10;\r\n            ans = sum % 10;\r\n            i--;\r\n            res.add(0, ans);\r\n            k /= 10;\r\n        }\r\n        \r\n        if(carry != 0) {\r\n            res.add(0, carry);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186207847","body":"## 思路\r\n0，双指针：i 进行字符串遍历，j 进行目标字符位置的固定；\r\n1，从左向右遍历，记录每个字符与其左边的目标字符的距离；\r\n2，再从右向左遍历，记录每个字符与其右边出现的目标字符的距离，与结果数组中的取小值；\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.length() == 0) {\r\n            return new int[0];\r\n        }\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res, n + 1);\r\n        // j 记录左侧第一个 c 的坐标\r\n        for(int i = 0, j = -1; i < n; i++) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        // 从右向左遍历，j 为第一个 c 的坐标\r\n        for(int i = n - 1, j = -1; i >= 0; i--) {\r\n            if(s.charAt(i) == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = Math.min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186679035","body":"## 思路\r\n数组模拟栈，用变量记录栈顶的位置\r\n···\r\nclass CustomStack {\r\n    int[] st;\r\n    int top = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        st = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top == st.length - 1) {\r\n            return;\r\n        }\r\n        top++;\r\n        st[top] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1) {\r\n            return -1;\r\n        }\r\n        return st[top--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int cnt = k > st.length ? st.length : k;\r\n        for(int i = 0; i < cnt; i++) {\r\n            st[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n···","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187006693","body":"## 思路\r\n1，以一对中括号来解析字符串，用数组来维护一个栈，除右括号其他都进栈；遇到右括号则出栈；\r\n2，进栈需要将数字字符处理妥当，处理成字符；两位及以上的数字容易出错；\r\n```\r\nclass Solution {\r\n    int idx;\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        LinkedList<String> st = new LinkedList<>();\r\n        int n = s.length();\r\n        while(idx < n) {\r\n            if(Character.isDigit(s.charAt(idx))) {\r\n                st.add(getDigit(s));\r\n            }\r\n            else if(s.charAt(idx) != ']') {\r\n                st.add(String.valueOf(s.charAt(idx++)));\r\n            }\r\n            else {\r\n                LinkedList<String> path = new LinkedList<>();\r\n                while(!\"[\".equals(st.peekLast())) {\r\n                    path.add(st.pollLast());\r\n                }\r\n                Collections.reverse(path);\r\n                String sub = getString(path);\r\n                st.pollLast();\r\n                int cnt = Integer.valueOf(st.pollLast());\r\n                String str = getSubString(cnt, sub);\r\n                st.add(str);\r\n                idx++;\r\n            }\r\n        }\r\n        return getString(st);\r\n    }\r\n\r\n    private String getDigit(String s) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(Character.isDigit(s.charAt(idx))) {\r\n            sb.append(s.charAt(idx++));\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getString(LinkedList<String> path) {\r\n        StringBuffer sb = new StringBuffer();\r\n        for(String s : path) {\r\n            sb.append(s);\r\n        }\r\n        return sb.toString();\r\n    }\r\n\r\n    private String getSubString(int cnt, String sub) {\r\n        StringBuffer sb = new StringBuffer();\r\n        while(cnt-- > 0) {\r\n            sb.append(sub);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT：O(n)，遍历字符串\r\nS：O(n)，数组模拟栈\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188799537","body":"## 思路\r\n两个栈实现队列，一个进一个出\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s1.isEmpty() && s2.isEmpty()) {\r\n            return -1;\r\n        }\r\n        if(s2.isEmpty()) {\r\n            while(!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189784256","body":"## 思路\r\n维护一个栈，遍历数组，并与栈顶元素比较，\r\n1，当前数小于栈顶，栈顶出栈；\r\n2，当前数大于等于栈顶，直接入栈\r\n\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        if(arr == null || arr.length == 0) {\r\n            return 0;\r\n        }\r\n        LinkedList<Integer> st = new LinkedList<>();\r\n        int head = 0;\r\n        for(int x : arr) {\r\n            if(!st.isEmpty() && x < st.getLast()) {\r\n                head = st.pollLast();\r\n                while(!st.isEmpty() && x < st.getLast()) {\r\n                    st.pollLast();\r\n                }\r\n                st.add(head);\r\n            }\r\n            else {\r\n                st.add(x);\r\n            }\r\n        }\r\n        return st.size();\r\n    }\r\n}\r\n```\r\n##  复杂度\r\nT:O(N)\r\nS:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"incipe-win":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185631706","body":"## 思路\r\n把 `k` 的每一位转换成一个 vector，然后进行两个 vector 相加即可。\r\n## 代码\r\n````cpp\r\nclass Solution {\r\nprivate:\r\n    vector<int> addTwo(vector<int> &num1, vector<int> &num2) {\r\n        // [1, 2, 0, 0] + [3, 4]\r\n        int size1 = num1.size() - 1, size2 = num2.size() - 1;\r\n        vector<int> ans;\r\n        int carry = 0;\r\n        while (size1 >= 0 || size2 >= 0) {\r\n            int x1 = size1 >= 0 ? num1[size1] : 0;\r\n            int x2 = size2 >= 0 ? num2[size2] : 0;\r\n            int sum = x1 + x2 + carry;\r\n            carry = sum / 10;\r\n            sum %= 10;\r\n            ans.emplace_back(sum);\r\n            --size1;\r\n            --size2;\r\n        }\r\n        if (carry) {\r\n            ans.emplace_back(carry);\r\n        }\r\n        reverse(ans.begin(), ans.end());\r\n        return ans;\r\n    }\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> num1;\r\n        while (k) {\r\n            num1.emplace_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(num1.begin(), num1.end());\r\n        return addTwo(num, num1);\r\n    }\r\n};\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185717663","body":"## 思路\n暴力法，直接记录所有结果的给定字符的位置，遍历一遍字符串，取距离最小的值\n## 代码\n````cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> ans;\n        vector<int> tmp;\n        int size = s.size();\n        for (int i = 0; i < size; ++i) {\n            if (s[i] == c) {\n                tmp.emplace_back(i);\n            }\n        }\n        int cnt = 0;\n        for (int i = 0; i < size; ++i) {\n            int minn = INT_MAX;\n            for (int j = 0; j < (int)tmp.size(); ++j) {\n                minn = min(minn, abs(tmp[j] - i));\n            }\n            ans.emplace_back(minn);\n        }\n        return ans;\n    }\n};\n````\n## 时空复杂度\n时间复杂度：$O(n \\times k)$ <br />\n空间复杂度：$O(k)$ <br />\nk为字符的个数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186235143","body":"## 思路\r\n利用数组模拟栈的 `push`, `pop` 操作，最后的 `increment` 直接把数组前 `k` 个加上 `val` 即可。\r\n## 代码\r\nC++\r\n````cpp\r\nclass CustomStack {\r\nprivate:\r\n    vector<int> vec;\r\n    int cnt;\r\n    int maxSize;\r\npublic:\r\n    CustomStack(int _maxSize) {\r\n        cnt = 0;\r\n        maxSize = _maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (cnt < maxSize) {\r\n            vec.emplace_back(x);\r\n            ++cnt;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (cnt == 0) {\r\n            return -1;\r\n        }\r\n        int ret = vec[cnt - 1];\r\n        vec.pop_back();\r\n        --cnt;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        if (cnt < k) {\r\n            k = cnt;\r\n        }\r\n        for (int i = 0; i < k; ++i) {\r\n            vec[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n````\r\nPython\r\n````python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.cnt = 0\r\n        self.vec = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.cnt < self.maxSize:\r\n            self.vec.append(x)\r\n            self.cnt += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.cnt == 0:\r\n            return -1\r\n        self.cnt -= 1\r\n        return self.vec.pop(-1)\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > self.cnt:\r\n            k = self.cnt\r\n        for i in range(k):\r\n            self.vec[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(k)$\r\n空间复杂度：$O(maxSize)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187585157","body":"## 思路\r\n利用两个栈，一个存储数字的栈，一个存储字符串的栈。\r\n如果是 `[`，把数字存入数织栈，把遇到 `]` 之前的字符串存到字符串栈里面，如果遇到 `]`，则按照题目要求解码字符串。\r\n## 代码\r\nC++\r\n````cpp\r\nclass Solution {\r\n  public:\r\n    string decodeString(string s) {\r\n        int size = s.size();\r\n        int num = 0;\r\n        stack<int> num_stack;\r\n        stack<string> str_stack;\r\n        string cur = \"\";\r\n        string result = \"\";\r\n        for (int i = 0; i < size; ++i) {\r\n            if (isdigit(s[i])) {\r\n                num = 10 * num + (s[i] - '0');\r\n            } else if (s[i] == '[') {\r\n                num_stack.push(num);\r\n                str_stack.push(cur);\r\n                num = 0;\r\n                cur.clear();\r\n            } else if (isalpha(s[i])) {\r\n                cur += s[i];\r\n            } else if (s[i] == ']') {\r\n                int k = num_stack.top();\r\n                num_stack.pop();\r\n                for (int j = 0; j < k; ++j) {\r\n                    str_stack.top() += cur;\r\n                }\r\n                cur = str_stack.top();\r\n                str_stack.pop();\r\n            }\r\n        }\r\n        result = result + cur;\r\n        return result;\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        size = len(s)\r\n        num = 0\r\n        num_stack = list()\r\n        str_stack = list()\r\n        cur = str()\r\n        result = str()\r\n        for i in range(size):\r\n            if s[i].isdigit():\r\n                num = num * 10 + int(s[i])\r\n            elif s[i] == '[':\r\n                num_stack.append(num)\r\n                str_stack.append(cur)\r\n                num = 0\r\n                cur = \"\"\r\n            elif s[i].isalpha():\r\n                cur += s[i]\r\n            elif s[i] == ']':\r\n                k = num_stack.pop(-1)\r\n                for j in range(k):\r\n                    str_stack[-1] += cur\r\n                cur = str_stack.pop(-1)\r\n        result = result + cur\r\n        return result\r\n````\r\n## 时空复杂度\r\n记字符串的长度为 $N$, 由于 `s` 中所有的整数取值范围都是 `[1, 300]`, 故拼接字符串的时间复杂度可以忽略。\r\n时间复杂度：$O(N)$\r\n空间复杂度：$O(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189097171","body":"## 思路\r\n只要理解了栈和队列的基本思想，就可以写出此题了。\r\n## 代码\r\nC++\r\n````cpp\r\nclass MyQueue {\r\n  private:\r\n    stack<int> st1, st2;\r\n\r\n  public:\r\n    MyQueue() {}\r\n\r\n    void push(int x) { st1.push(x); }\r\n\r\n    int pop() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            st2.pop();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        st2.pop();\r\n        return ret;\r\n    }\r\n\r\n    int peek() {\r\n        int ret = 0;\r\n        if (!st2.empty()) {\r\n            ret = st2.top();\r\n            return ret;\r\n        }\r\n        while (!st1.empty()) {\r\n            st2.push(st1.top());\r\n            st1.pop();\r\n        }\r\n        ret = st2.top();\r\n        return ret;\r\n    }\r\n\r\n    bool empty() {\r\n        return st1.empty() && st2.empty();\r\n    }\r\n};\r\n````\r\nPython\r\n````python\r\nclass MyQueue:\r\n    \r\n    def __init__(self):\r\n        self.st1 = []\r\n        self.st2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.st1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2.pop(-1)\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2.pop(-1)\r\n\r\n\r\n    def peek(self) -> int:\r\n        if len(self.st2):\r\n            return self.st2[-1]\r\n        while len(self.st1):\r\n            self.st2.append(self.st1.pop(-1))\r\n        return self.st2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not (len(self.st1) or len(self.st2))\r\n````\r\n## 时空复杂度\r\n时间复杂度：$O(1)$\r\n空间复杂度：$O(N)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"revisegoal":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185633040","body":"## 进位处理\n从低位往高位相加，并处理进位，可以用k同时存储进位信息，每次迭代有 k = (num[i] + k) / 10\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int len = num.length;\n        for (int i = len - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n        while (k != 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n}\n```\n\n```go\nfunc addToArrayForm(num []int, k int) []int {\n    res := make([]int, 0)\n    for i := len(num) - 1; i >= 0; i-- {\n        res = append(res, (num[i] + k) % 10)\n        k = (num[i] + k) / 10\n    }\n    for k != 0 {\n        res = append(res, k % 10)\n        k /= 10\n    }\n    for i, j := 0, len(res) - 1; i < j; i, j = i + 1, j - 1 {\n        res[i], res[j] = res[j], res[i]\n    }\n    return res\n}\n```\n- time: O(max(len(num), digit(k))，时间复杂度是和的长度n，是num和k最大的那个（可能会是max(len(num), digit(k)) + C，不过大O表示法忽略常数项C，可以不做讨论）\n- space: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185703099","body":"## 遍历\n左右遍历数组\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            res[i] = Math.min(res[i], pre - i);\n        }\n        return res;\n    }\n}\n```\n```go\nfunc shortestToChar(s string, c byte) []int {\n    const (\n        INT_MAX = int(^uint(0) >> 1)\n        INT_MIN = ^INT_MAX\n    )\n    res := make([]int, 0)\n    pre := INT_MIN / 2\n    for i := 0; i < len(s); i++ {\n        if s[i] == c {\n            pre = i\n        }\n        res = append(res, i - pre)\n    }\n    pre = INT_MAX\n    for i := len(s) - 1; i >= 0; i-- {\n        if s[i] == c {\n            pre = i\n        }\n        tmp := pre - i\n        if tmp < res[i] {\n            res[i] = tmp\n        }  \n    }\n    return res\n}\n```\n- time: O(n)\n- space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186483335","body":"## 栈\n数组实现栈\n```java\nclass CustomStack {\n    int[] stack;\n    int top = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top < stack.length) {\n            stack[top++] = x;\n        }\n    }\n    \n    public int pop() {\n        return top != 0 ? stack[--top] : -1;\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < top; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n```go\ntype CustomStack struct {\n    stack []int\n    top int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        stack: make([]int, maxSize, maxSize),\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.top >= len(this.stack) {\n        return\n    }\n    this.stack[this.top] = x\n    this.top++\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if this.top == 0 {\n        return -1\n    }\n    this.top--\n    return this.stack[this.top]\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    for i := 0; i < k && i < this.top; i++ {\n        this.stack[i] += val\n    }\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n- time: push, pop = O(1), increment = O(min(k, top))\n- space: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187662435","body":"## 栈\n辅助栈，解码顺序是由内向外，越里面的括号越先解码，符合栈先入后出原则\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Deque<String> resStack = new LinkedList<>();\n        Deque<Integer> multiStack = new LinkedList<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for (char ch : s.toCharArray()) {\n            if (ch == '[') {\n                multiStack.push(multi);\n                multi = 0;\n                resStack.push(res.toString());\n                res = new StringBuilder();\n            } else if (ch == ']') {\n                StringBuilder tmp = new StringBuilder();\n                tmp.append(resStack.pop());\n                int repeat = multiStack.pop();\n                for (int i = 0; i < repeat; i++) {\n                    tmp.append(res);\n                }\n                res = tmp;\n            } else if (Character.isDigit(ch)) {\n                multi = multi * 10 + ch - '0';\n            } else {\n                res.append(ch);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n- time: O(n)，n为字符串长度\n- space: 栈空间，O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189189933","body":"## 栈\n双栈实现队列\n```java\nclass MyQueue {\n    Deque<Integer> pushStack = new LinkedList<>();\n    Deque<Integer> popStack = new LinkedList<>();\n    public MyQueue() {\n\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n- time: O(n)\n- space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190341873","body":"## 计数\n遍历数组，若和有序数组expect计数相同，则说明此时可分块，res++\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int res = 0;\n        int nonzero = 0;\n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        for (int i = 0; i < arr.length; i++) {\n            int x = arr[i], y = expect[i];\n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if (count.get(x) == 0) {\n                nonzero--;\n            }\n            if (count.get(x) == 1) {\n                nonzero++;\n            }\n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if (count.get(y) == 0) {\n                nonzero--;\n            }\n            if (count.get(y) == -1) {\n                nonzero++;\n            }\n            if (nonzero == 0) {\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n- time: O(nlogn)，排序\n- space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckysq999":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185637894","body":"### 思路\n两数相加\n当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n = num.length;\n        List<Integer> res = new LinkedList<>();//LinkedList比ArrayList快\n        int i = n - 1, sum = 0, carry = 0, x = 0, y = 0;\n        while (i >= 0 || k != 0) {\n            x = i >= 0 ? num[i] : 0;\n            y = k >= 0 ? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            i--;\n            k = k / 10;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186193656","body":"### 思路\ntask：求当前下标字符到指定字符的最近距离\n\naction:\n需要两次遍历 \n\n对 s 的每个下标 i，求 \n\n从最左边开始，找到 s[i] 左侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n从最右边开始，找到 s[i] 右侧最近的字符c的下标，并计算 s[i] 到其下标的距离\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n=s.length();\n        int[] answer=new int[n];\n\n        for(int i=0, index=-n;i<n;i++)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=i-index;\n        }\n\n        for(int i=n-1, index=2*n-1;i>=0;i--)\n        {\n            if(s.charAt(i)==c) index=i;\n            answer[i]=Math.min(answer[i],index-i);\n        }\n        return answer;\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547707","body":"\n### 思路\n\n利用数组模拟栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n    public CustomStack(int maxSize) {\n        stack=new int[maxSize];\n        top=-1;\n    }\n    \n    public void push(int x) {\n        if(top<(stack.length-1))\n        {\n            top=top+1;\n            stack[top]=x;\n        }\n\n    }\n    \n    public int pop() {\n        if(top>-1)\n        {\n            int t=top;\n            top=top-1;\n            return stack[t];\n        }\n        else\n            return -1;\n    }\n    \n    public void increment(int k, int val) {\n    for(int i=0;i<Math.min(k,top+1);i++)\n    {\n        stack[i]+=val;\n    }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push:O(1) pop:O(1) increment: O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187603841","body":"### 思路\n\n难点：括号内嵌套括号，使用栈解决问题。\n\n一个字母栈，一个数字栈\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        String res =new String();\n        StringBuffer ans=new StringBuffer();\n        Stack<Integer> multiStack=new Stack<>();\n        Stack<StringBuffer> ansStack=new Stack<>();\n        int multi=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c))multi=multi*10+c-'0';\n            else if(c=='['){\n                ansStack.add(ans);\n                multiStack.add(multi);\n                ans=new StringBuffer();\n                multi=0;\n            }else if(Character.isAlphabetic(c)){\n                ans.append(c);\n            }else{\n                StringBuffer ansTmp=ansStack.pop();\n                int tmp=multiStack.pop();\n                for(int i=0;i<tmp;i++)ansTmp.append(ans);\n                ans=ansTmp;\n            }\n        }\n        return ans.toString();\n       \n    }\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149227","body":"### 思路\n双栈：一个是输入栈，另一个辅助作为输出栈\n\n### 代码\n\n\n```java\nclass MyQueue {\n    Deque<Integer> deque1;\n    Deque<Integer> deque2;\n\n    public MyQueue() {\n        deque1 = new ArrayDeque<>();\n        deque2 = new ArrayDeque<>();\n    }\n\n    public void push(int x) {\n        deque1.push(x);\n    }\n\n    public int pop() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.pop();\n    }\n\n    public int peek() {\n        if (deque2.isEmpty())\n            f();\n        return deque2.peek();\n    }\n\n    public boolean empty() {\n        if (deque1.isEmpty() & deque2.isEmpty())\n            return true;\n        else\n            return false;\n\n    }\n\n    public void f() {\n        while (!deque1.isEmpty())\n            deque2.push(deque1.pop());\n    }\n\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push()和empty()是O(1)，pop()和peek()是O(n)\n- 空间复杂度：O(n),额外的内存来存储队列中的元素\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190343354","body":"### 思路\n\n\n是否是排序块只需要用到该块的 元素最大值 head 。\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dereklisdr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185638851","body":"/* 思路 */\n- 两个数相加：从个位数相加(从右向左) 考虑进位 一个一个加入ArrayList入List首位\n\n/* 代码 Java */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        \n        for (int i = num.length-1; i >= 0; i--) {\n            int current = k%10 + num[i];\n            k /= 10;\n            \n            if (current >= 10) {\n                k += 1;\n            }\n            \n            result.add(0, current%10);\n        }\n        \n        while (k > 0) {\n            result.add(0, k%10);\n            k /= 10;\n        }\n        \n        return result;\n    }\n}\n\n/* 时间和空间分析\nTime  : O(n) - 一次循环\nSpace : O(n) - 两数相加的位数\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218643","body":"/* Idea\n- loop 1(left to right): compare the index with the first closet left c\n- loop 2(right to left): compare the index with the first closet right c\n- compare two loop indexs, and take the min value\n*/\n\n/* Code Java */\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] res = new int[len];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < len; ++i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = len-1; i >= 0; --i) {\n            if (s.charAt(i) == c) prev = i;\n            res[i] = Math.min(res[i], prev - i);\n        }\n\n        return res;\n    }\n}\n\n/* Complexity Analysis\nTime  : O(n) : 2 n loops\nSpace : O(n) : return n int array\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186313748","body":"/* Idea\n-  Use int[] to simulate stack.\n*/\n\n/* Code Java */\nclass CustomStack {\n    private int[] items;\n    // size: count of current items occupied; pointer to next item.\n    private int size = 0;\n\n    public CustomStack(int maxSize) {\n        items = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size == items.length)\n            return;\n        items[size++] = x;\n    }\n\n    public int pop() {\n        if (size == 0)\n            return -1;\n        return items[--size];\n    }\n\n    public void increment(int k, int val) {\n        for (int i = 0; i < Math.min(k, size); i++) {\n            items[i] += val;\n        }\n    }\n}\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n/* Complexity Analysis\nTime Complexity : O(n)\nspase Complexity: O(maxSize)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186588234","body":"//没做出来 参考\nclass Solution {\n    public String decodeString(String s) {\n        \n        int lastIndex = s.lastIndexOf('[');\n        if(lastIndex<0) return s;\n        int temp=lastIndex-1;\n        String repeatString=\"\";\n        while(temp>=0){\n            if(Character.isDigit(s.charAt(temp))){\n                temp--;\n            }\n            else break;\n        }\n        \n        int repeatNum=Integer.parseInt(s.substring(temp+1,lastIndex));\n        \n        String rpStr=s.substring(lastIndex+1, s.indexOf(']',lastIndex));\n        rpStr=rpStr.repeat(repeatNum);\n        s=s.replace((s.substring(temp+1,s.indexOf(']',temp+1)+1)),rpStr);\n        return decodeString(s);      \n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189114277","body":"/* Idea\n-  第1个Stack用来push, 第2个Stack用来pop and peek.\n- 把第1个stack pop出来的数放到第2个Stack中，然后pop就是按照queue的次序pop\n*/\n\n/* Code Java */\nclass MyQueue {\n    Stack<Integer> in = new Stack<Integer>();\n    Stack<Integer> out = new Stack<Integer>();\n    \n    public MyQueue() {\n        \n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        int res;\n        if (!out.empty()){\n            res = out.pop();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.pop();\n        }\n        return res;\n    }\n    \n    public int peek() {\n        int res;\n        if (!out.empty()){\n            res = out.peek();\n        }else{\n            while(!in.empty()){\n                out.push(in.pop());\n            }\n            res = out.peek();\n        }\n        return res;\n    }\n    \n    public boolean empty() {\n        return (in.empty() && out.empty());\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n/* Complexity Analysis\nTime Complexity : push O(1), pop and peek: O(n)\nspase Complexity: O(n)\n*/","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189760137","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] rightMin = new int[arr.length+1];\n        rightMin[arr.length] = Integer.MAX_VALUE;\n        for(int i = arr.length-1; i>=0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]);\n        }\n        \n        int leftMax = Integer.MIN_VALUE;;\n        int count = 0;\n        for(int i = 0; i<arr.length; i++){\n            leftMax = Math.max(leftMax, arr[i]);\n            if(leftMax<=rightMin[i+1]){\n                count++;\n            }\n        }\n        return count;\n        \n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191060774","body":"Idea\n- 分两个cases 1. k>list size 2. k<list size 来计算最后一个node.next = null的位置\n- 然后首位连接起来 返回head\n\nCode\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        \n        if(head == null) return null;\n        if(k == 0) return head;\n            \n        int size = 0;\n        ListNode cur = new ListNode();\n        cur = head;\n            \n        while(cur.next != null){\n            size++;\n            cur = cur.next;\n        }\n        size++;\n        \n        int steps = 0;\n        \n        //calculate the steps is the key!\n        if (k == size){\n            return head;\n        }else if (k < size){\n            steps = size - 1 - k;\n        }else if (k > size){\n            steps = size - 1 - (k % size); //trick here. should consider test cases\n        }\n        \n        cur = head;\n        for(int i = 0; i < steps; i++){\n            cur = cur.next;\n        }\n        \n        ListNode endNode = cur;\n        while(endNode.next != null)\n        {\n            endNode = endNode.next;\n        }\n        endNode.next = head;\n        head = cur.next;\n        cur.next = null;\n        \n        return head;\n    }\n}\n\nComplexity\nTime  complexity: O(n)\nSpace complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"perfqi":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185644120","body":"常规思路：1.数组和数字相互转换；2.两数组逐位相加\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; --i) {\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10) {\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10) {\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530094","body":"考察栈的存储结构，操作\n\n class CustomStack {\n\n    static class Node {\n        int val;\n        int delta;\n        Node(int val) {\n            this.val = val;\n            this.delta = 0;\n        }\n    }\n\n    Node[] stack = null;\n    int len = 0;\n\n    public CustomStack(int maxSize) {\n        stack = new Node[maxSize];\n    }\n    \n    public void push(int x) {\n        if (len < stack.length) {\n            stack[len++] = new Node(x);\n        }\n    }\n    \n    public int pop() {\n        if (len <= 0) return -1;\n        Node top = stack[len - 1];\n        if (len >= 2) {\n            stack[len - 2].delta += top.delta;\n        }\n        len--;\n        return top.val + top.delta;\n    }\n    \n    public void increment(int k, int val) {\n        if (len >= k && k >= 1) {\n            stack[k - 1].delta += val;\n        } else if (len > 0) {\n            stack[len - 1].delta += val;\n        }\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mryao1":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185647007","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> sum = new ArrayList<Integer>();\n        int length = num.length;\n        num[length - 1] += k;\n        for (int i = length - 1; i > 0; i--) {\n            int curNum = num[i];\n            if (curNum > 9) {\n                num[i - 1] += curNum / 10;\n                num[i] %= 10;\n            }\n            sum.add(num[i]);\n        }\n        do {\n            sum.add(num[0] % 10);\n            num[0] /= 10;\n        } while (num[0] > 0);\n        Collections.reverse(sum);\n        return sum;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186516976","body":"```java\nclass CustomStack {\n\n    private final Integer maxSize;\n\n    private Integer top;\n\n    private final Integer[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        top = 0;\n        arr = new Integer[maxSize];\n    }\n\n    public void push(int x) {\n        if (top.equals(maxSize)){\n            return;\n        }\n        arr[top++] = x;\n    }\n\n    public int pop() {\n        if (top <= 0){\n            return -1;\n        }\n        return arr[--top];\n    }\n\n    public void increment(int k, int val) {\n        k = k<top? k : top;\n        for (int i = 0; i < k; i++) {\n            arr[i] += val;\n        }\n    }\n}\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187660017","body":"```java\npublic String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        Stack<Object> stack = new Stack<>();\n        for (int i = 0; i < chars.length; i++) {\n            if (Character.isDigit(chars[i])) {\n                int repit = 0;\n                do {\n                    repit = 10 * repit + Integer.parseInt(String.valueOf(chars[i]));\n                    i++;\n                } while (Character.isDigit(chars[i]));\n//                i--;\n                stack.push(repit);\n            }\n            if (']' != chars[i]){\n                stack.push(chars[i]);\n            } else {\n                StringBuilder temp = new StringBuilder();\n                while (!String.valueOf(stack.peek()).equals(\"[\")){\n                    temp.insert(0, stack.pop());\n                }\n                stack.pop();\n                int count = Integer.parseInt(String.valueOf(stack.pop()));\n                String toString = temp.toString();\n                for (int j = 1; j < count; j++) {\n                    temp.append(toString);\n                }\n                stack.push(temp.toString());\n            }\n        }\n        StringBuilder rtn = new StringBuilder();\n        while (!stack.empty()){\n            rtn.insert(0, stack.pop());\n        }\n        return rtn.toString();\n\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189137456","body":"```java\nclass MyQueue {\n\n    private final Stack<Integer> inStack;\n\n    private final Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (!outStack.empty()){\n            return outStack.pop();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return pop();\n    }\n\n    public int peek() {\n        if (!outStack.empty()){\n            return outStack.peek();\n        }\n        while (!inStack.empty()){\n            outStack.push(inStack.pop());\n        }\n        return peek();\n    }\n\n    public boolean empty() {\n        return inStack.empty()&& outStack.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400110","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int[] expect = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(expect);\n        int count = 0;\n        int i = 0;\n        int sumL = 0;\n        int sumR = 0;\n        while (i < arr.length) {\n            sumL+=arr[i];\n            sumR+=expect[i];\n            if (sumL == sumR){\n                count++;\n                sumL = 0;\n                sumR = 0;\n            }\n            i++;\n        }\n        return count;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"likeyousmile":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185652987","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        nstr = ''.join(map(str,num))\n        n = int(nstr)\n        res = n + k\n        return list(map(int,str(res)))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhg1992":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185656280","body":"```go\nfunc addToArrayForm(num []int, k int) []int {\n\tvar ans []int\n\tfor i := len(num) - 1; i >= 0; i-- {\n\t\tsum := num[i] + k%10\n\t\tk /= 10\n\t\tif sum >= 10 {\n\t\t\tk++\n\t\t\tsum -= 10\n\t\t}\n\t\tans = append(ans, sum)\n\t}\n\tfor ; k > 0; k /= 10 {\n\t\tans = append(ans, k%10)\n\t}\n\treverse(ans)\n\treturn ans\n}\nfunc reverse(num []int) {\n\tfor i, n := 0, len(num); i < n/2; i++ {\n\t\tnum[i], num[n-1-i] = num[n-1-i], num[i]\n\t}\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liquanluo":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658739","body":"```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int increase = 0;\n        reverse(num.begin(), num.end());\n        int pos = 0;\n        vector<int> result;\n        while (k > 0 || pos < num.size() || increase > 0 ) {\n            auto digit = k % 10;\n            auto num_digit = pos < num.size() ? num[pos] : 0;\n            auto new_val = num_digit + digit + increase;\n            increase = new_val / 10;\n            new_val = new_val % 10;\n            result.push_back(new_val);\n            \n            ++pos;\n            k = k / 10;\n            // cout << new_val << endl;\n        }\n        \n        // cout << result.size() << endl;\n        reverse(result.begin(), result.end());\n        return result;\n        \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213458","body":"### Solution:\n- 1. Initialize a result vector which has the same size as string, all the value is INF, [INF, INF....]  O(n)\n- 2. Find the c in the string, and mark the corresponding position as 0 [INF,..0... 0....INF]  O(n)\n- 3. Then for each c, update's left and right value incrementally, until it hits the boundary of the vector or 0 O(n)\n- Time complexity O(n)\n### Code:\n\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> results(s.size(), INT_MAX);\n        for (int i = 0; i < s.size(); ++i ) {\n            if (s[i] == c) {\n                results[i] = 0;\n            }\n        }\n        \n        for (int i = 0; i < s.size(); ++i ) {\n            if (results[i] == 0) {\n                update_left(results, i);\n                update_right(results, i);\n            }\n        }\n    \n        return results;\n    }\n    \n    \n    void update_left(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx > 0) {\n            --idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    \n    void update_right(vector<int>& results, int idx) {\n        auto distance = 0;\n        while (idx < results.size() - 1) {\n            ++idx;\n            ++distance;\n            if (distance < results[idx]) {\n                results[idx] = distance;\n            }\n            else {\n                break;\n            }\n            \n        }\n    }\n    \n    \n};\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186433116","body":"### Solution:\n1. use vector as underlying data structure\n2. push() -> vector.push_back()   O(1) or O(n)\n3. pop() -> vector.pop_back and return last element O(1)\n4. increment() -> increment elements at the bottom O(n)\n\n### Code:\n\n\n```c++\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : _maxSize(maxSize){\n        \n        \n    }\n    \n    void push(int x) {\n        if (_v.size() < _maxSize) {\n            _v.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if (_v.size() == 0) {\n            return -1;\n        }\n        else {\n            auto result = _v[_v.size() -1];\n            _v.pop_back();\n            return result;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int i = 0;\n        while (k > 0 && i < _v.size()) {\n            _v[i] += val;\n            ++i;\n            --k;\n        }\n    }\n    \nprivate:\n    vector<int> _v;\n    int _maxSize;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186725285","body":"### Solution:\ndata structure: stack to store\n1. loop whole string\\\n     1.1. if digit, letters or [ push to stack\\\n     1.2. if ] pop until find [, \\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; then find all the digit before, convert to int\\\n           &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int * [string], push back to stack\n2. when we running out of s,  pop out all the string from the stack and return\n\n### Code:\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<char> st;\n        for (auto c : s) {\n            if (c == ']') {\n                auto str = find_str(st);\n                auto repeat = find_num(st);\n                string repeated_str;\n                while (repeat > 0) {\n                    repeated_str += str;\n                    --repeat;\n                }\n                // cout << \"repeated_str\" << repeated_str << endl;\n                for (auto repeated_char : repeated_str) {\n                    st.push(repeated_char);\n                }\n            }\n            else {\n                st.push(c);\n            }\n        }\n        \n        string result;\n        while (!st.empty()) {\n            auto c = st.top();\n            result += c;\n            st.pop();\n        }\n        reverse(result.begin(), result.end());\n        \n        return result;\n        \n    }\n    \nprivate:\n    string find_str(stack<char>& st) {\n        string str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (c == '[') {\n                st.pop();\n                break;\n            }\n            else{\n                str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(str.begin(), str.end());\n        // cout << \"find str\" << str << endl;\n        return str;\n    }\n    \n    int find_num(stack<char>& st) {\n        string num_str;\n        while (!st.empty()) {\n            auto c = st.top();\n            if (!isdigit(c)) {\n                break;\n            }\n            else{\n                num_str += c;\n                st.pop();\n            }\n        }\n        \n        reverse(num_str.begin(), num_str.end());\n        // cout << \"find num_str\" << num_str << endl;\n        int num = stoi(num_str);\n        return num;\n    }\n    \n};\n\n```\n\n**complexity analysis**\n- Time：O(N)，\n- Space：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188614107","body":"```c++\n/***\nData structure: push_stack, pop_stack\n1. push stack is used to push item into queue, like this:[a,b,c\n2. pop stack is used to pop item out of queue, like this: a,b,c]\n3. when we need to push item, we check if pop stack has items, \n    if it is, we put everything back to push stack, \n    then push to push stack\n4. when we need to peek or pop item, we check if push stack has items,\n    if it is, we put everything back to pop stack,\n    then do peek or pop\n5. empty(), both stacks are empty\n***/\n\n\nclass MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        while (!pop_stack.empty()) {\n            auto val = pop_stack.top();\n            push_stack.push(val);\n            pop_stack.pop();\n        }\n        \n        push_stack.push(x);\n    }\n    \n    int pop() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n        \n        auto result = pop_stack.top();\n        pop_stack.pop();\n        return result;\n    }\n    \n    int peek() {\n        while (!push_stack.empty()) {\n            pop_stack.push(push_stack.top());\n            push_stack.pop();\n        }\n    \n        return pop_stack.top();  \n    }\n    \n    bool empty() {\n        return push_stack.empty() && pop_stack.empty();\n    }\n    \nprivate:\n    stack<int> push_stack;\n    stack<int> pop_stack;\n    \n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191035289","body":"```c++\n// 1. find the size of the list O(n)\n// 2. make the linked list become a circle O(1)\n// 3.  move the head to size - (k % size) O(n)\n// 4. cut the circle before the head O(1)\n// 5. return the head\n\n\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n        \n        \n        ListNode* dummy = new ListNode(0);\n        dummy->next = head;\n        int size = 0;\n        auto cur = head;\n        auto pre = dummy;\n        while (cur != nullptr) {\n            ++size;\n            cur = cur->next;\n            pre = pre->next;    \n        }\n        \n        if (size == 0) {\n            return head;\n        }\n        \n        pre->next = dummy->next;\n        cur = head;\n        pre = dummy;\n        k = size - (k % size);\n        while (k > 0) {\n            cur = cur->next;\n            pre = pre->next;   \n            --k;\n        }\n        pre->next = nullptr;\n        return cur;\n        \n    }\n};\n```\n\nTime: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aq666888":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185658990","body":"### 解题思路\n\n​\t将数组的每一位倒序取出然后和k进行相加，确保k每次是个位数。\n\n​\t当前位 = (A 的当前位 + B 的当前位 + 进位carry) % 10\n\n​\t注意，AB两数都加完后，最后判断一下进位 carry, 进位不为 0 的话加在前面。\n\n​\t最后反转数组\n\n### 代码实现\n\n```java\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    List<Integer> res = new ArrayList<Integer>();  \n    int carry=0; //判断进位\n    int i=num.length -1; //判断数组里的整数是否遍历结束\n    // 可以用 LinkeList，或者 ArrayList 往后加，最后反转\n\n    while (i >= 0 || k!= 0) { \n        int x = i>= 0 ? num[i]: 0;\n        int y = k!= 0 ? k % 10 : 0;\n                    \n        int sum = x + y + carry;\n        res.add(sum % 10);\n        carry =sum/10;\n        i--;\n        k=k/10;\n    }\n        if(carry !=0)res.add(carry);\n        Collections.reverse(res);\n        return res;\n       \n\t}\n}    \n```\n\n\n\n### 复杂度：\n\n```md\n时间复杂度 : O(min(n,k)) \n空间复杂度: O(n)\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211456","body":"\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n int length=s.length();\n        List<Integer> list=new ArrayList<Integer>();\n        int[] res=new int[length];\n        for(int i=0;i<length;i++)\n        {\n            if(s.charAt(i)==c)\n            {\n                list.add(i);\n            }\n        }\n        int i=0;\n        int j=0;\n        while(i<length)\n        {\n            int min=Math.abs(list.get(j)-i);\n            while(j<list.size())\n            {\n                if(min>Math.abs(list.get(j)-i))\n                {\n                    min=Math.abs(list.get(j)-i);\n                }\n                j++;\n            }\n            res[i]=min;\n            j=0;\n            i++;\n        }\n        return res;\n\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186439547","body":"class CustomStack {\n        int[]stack;\n        int top;\n    public CustomStack(int maxSize) {\n        stack=new int [maxSize];\n        top=-1;\n\n    }\n    \n    public void push(int x) {\n        if(top!=stack.length-1)\n        {\n            top++;\n            stack[top]=x;\n        }\n    }\n    \n    public int pop() {\n          if(top==-1)\n        {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];   \n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i)\n        {\n            stack[i] += val;\n        }\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187570040","body":" StringBuilder res = new StringBuilder();\n        int multi = 0;\n        // LinkedList<Integer> stack_multi = new LinkedList<>();\n        // LinkedList<String> stack_res = new LinkedList<>();\n        Stack<Integer> stack_multi = new Stack<>();\n        Stack<String> stack_res = new Stack<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.push(multi);\n                stack_res.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.pop();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.pop() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c+\"\");\n            else res.append(c);\n        }\n        return res.toString();","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189132256","body":"class MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new ArrayDeque<Integer>();\n        outStack = new ArrayDeque<Integer>();\n    }\n\n    public void push(int x) {\n        inStack.push(x);\n    }\n\n    public int pop() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.pop();\n    }\n\n    public int peek() {\n        if (outStack.isEmpty()) {\n            in2out();\n        }\n        return outStack.peek();\n    }\n\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n\n    private void in2out() {\n        while (!inStack.isEmpty()) {\n            outStack.push(inStack.pop());\n        }\n    }\n}\n\n时间复杂度O（1）\n空间复杂度O（n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190337226","body":"class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for (int num : arr) {\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samlu-ecnu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660112","body":"### 思路\n\n数字还原后相加，再转换为数字列表。\n\n### 代码\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        degit = 0\n        for d in num:\n            degit *= 10\n            degit += d\n        # print(degit)\n        k += degit\n        # print(k)\n\n        res = []\n        while k != 0:\n            res.append(k % 10)\n            # print(res)\n            k //= 10\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186223951","body":"### 思路\n\n遍历一遍字符串，得到`id_list`存储相等的索引，并且置返回数组`ans`对应位置为0；再次遍历数组，对于每个不相等的字符位置计算`id_list`中，与之最近的索引距离，并记录在返回数组`ans`对应位置。\n\n### 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        ans = [-1] * len(s)\n        id_list = []\n        for i in range(len(s)):\n            if s[i] == c:\n                ans[i] = 0\n                id_list.append(i)\n        for i, ch in enumerate(s):\n            if ch != c:\n                min_dst = len(s)\n                for idx in id_list:\n                    min_dst = min(min_dst, abs(i - idx))\n                ans[i] = min_dst\n                \n        return ans\n```\n\n### 复杂度\n\n时间复杂度：$O(n^2)$\n\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541287","body":"### 思路\n\n使用列表模拟堆栈，调用列表方法实现功能。\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.maxSize > len(self.stack):\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675530","body":"### 思路\n\n根据字符串中不同种类的字符分情况讨论，利用栈储存每一次的乘数以及中间结果。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, num = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([num, res])\n                res, num = \"\", 0\n            elif c == ']':\n                cur_num, last_res = stack.pop()\n                res = last_res + cur_num * res\n            elif '0' <= c <= '9':\n                num = num * 10 + int(c)            \n            else:\n                res += c\n        return res\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n时间复杂度：$O(n^2)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189227283","body":"### 思路\n\n利用两个栈之间来回储存每一个元素，实现队列的相应功能。\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def peek(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        res = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return res\n\n\n    def empty(self) -> bool:\n        return self.stack1 == []\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190434807","body":"### 思路\n\n虚假的困难。。考虑分块需要排序，于是可以递增范围和排序完的数组进行对比。对比的方式这里可以计算前缀和是否相等，如果前缀和相等，就是一个分块。\n\n这里的充要性体现在：分块的范围与排序后的范围是一致的，于是分块后的操作就是对这个范围之内的元素进行坐标改变，而元素数值不会进行改变，两个范围的数值和相同，说明可以通过对分块的坐标进行某种改变来得到排序后的数组。\n\n### 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        sorted_arr = sorted(arr)\n\n        arr_sum = 0\n        sorted_sum = 0\n\n        res = 0\n\n        for x, y in zip(arr, sorted_arr):\n            arr_sum += x\n            sorted_sum += y\n\n            if arr_sum == sorted_sum:\n                res += 1\n        \n        return res\n```\n\n### 复杂度\n\n时间复杂度：$O(nlog(n))$\n\n空间复杂度：$O(n)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191178242","body":"### 思路\n\n整体右移`k`个位置等于以`n-k`位置之后的节点作为头节点，将链表成环，并以`n-k`位置之后进行断裂。\n\n### 代码\n\n```python\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        if head is None or head.next is None or k == 0:\n            return head\n        cur = head\n        n = 1\n        while cur.next:\n            cur = cur.next\n            n += 1\n        \n        add = n - k % n\n\n        if add == n:\n            return head\n        \n        cur.next = head\n        \n        while add:\n            cur = cur.next\n            add -= 1\n        \n        ret = cur.next\n        cur.next = None\n        \n        return ret\n```\n\n### 复杂度\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhongxiangxiang":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660258","body":"## 思路\r\n将num和k都转成数组（增加了额外空间，呜呜～～）并倒序，每个元素因此相加，若大于等于10，下一次相加另外再加1\r\n\r\n## 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    let arr1 = num.reverse()\r\n    let arr2 = String(k).split('').reverse().map(item => Number(item))\r\n    let i = 0\r\n    let arr = []\r\n    let extra = 0\r\n    while(i < arr1.length || i < arr2.length) {\r\n        let sum = (arr1[i] || 0) + (arr2[i] || 0) + extra\r\n        if (sum >= 10) {\r\n            arr.push(sum - 10)\r\n            extra = 1\r\n        } else {\r\n            arr.push(sum)\r\n            extra = 0\r\n        }\r\n        i++\r\n    }\r\n    if (extra === 1) {\r\n        arr.push(1)\r\n    }\r\n    \r\n    return arr.reverse()\r\n};\r\n```\r\n\r\n## 复杂度\r\n时间：O(n), 数组的reverse不知道复杂度多少\r\n空间：O(n),","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180166","body":"```js\r\nvar MyQueue = function() {\r\n    this.arr = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.arr.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.arr.shift()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.arr[0]\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.arr.length === 0\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190460802","body":"## 代码\r\n```js\r\nvar maxChunksToSorted = function(arr) {\r\n    // 单调递增栈\r\n    let stack = [arr[0]] // 存每个分块的最大值\r\n    for (let i = 1; i < arr.length; i++) {\r\n        if (arr[i] >= stack[stack.length - 1]) {\r\n            // arr[i]大于等于前面分块的最大值，可以独立分一个块\r\n            stack.push(arr[i])\r\n        } else {\r\n            // 小于，就合到上一个分块\r\n            let temp = stack.pop() // 上一分块的最大值\r\n            while (arr[i] < stack[stack.length - 1]) {\r\n                // 将小于上一分块的pop掉，合并为一个分块\r\n                stack.pop()\r\n            }\r\n            // 合并之后的分块push回去\r\n            stack.push(temp)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hatorimain":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185660712","body":"## 思路\n这题如果用链表做可以通过使用addFirst这个方法来降低复杂度，参考了leetcode 讨论区java的solution。\n将k加上数组的每位，然后mod10，得到的值放在linkedlist里。\n然后将k /= 10后将这个值加到下一位。\n\n## 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        int len = num.length - 1;\n        while(len >= 0 || k != 0){\n            if(len >= 0)  k += num[len--];\n            res.addFirst(k % 10);\n            k = k /10;\n        }\n        \n        return res;\n    }\n}\n```\n\n## 复杂度\n时间复杂度： O(max(n, log10(k)))\n空间复杂度：O(max(n, log10(k)))\n\n时间复杂度不是数组的长度就是log10k，空间复杂度是因为我们需要开新的空间来把结果存到linkedlist里面。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210190","body":"## 思路\n直接参考了力扣的最优解，用一个数组储存结果。\n最近的c的索引先设成无穷小。\n先从左边扫描一次数组比较每个index和最近的c的index的距离。然后存进数组对应的index。\n最近的c的索引设成无穷大。\n再从右边扫描一次数组比较每个index和最近的c的index的距离，然后与之前的数组的值比较，取小的那个。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int prev = Integer.MIN_VALUE / 2;\n        int[] ans = new int[n];\n        for(int i = 0; i < n; i++) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = i - prev;\n        }\n        \n        prev = Integer.MAX_VALUE / 2;\n        for(int i = n - 1; i >= 0; i--) {\n            if(s.charAt(i) == c) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n        return ans;\n    }\n}\n```\n\n## 复杂度\n- 时间复杂度： O(N)\n因为就是遍历了两遍数组\n- 空间复杂度：O(N)\n创建了一个跟原来n一样长度的数组来储存结果。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549032","body":"## 思路\n- 看了最佳题解的前缀和，但是不知道就是优化的代码是不是可以用java实现\n- 简单来说就是用一个increment数组来实现increment操作。\n- 如果increment了，且k < stack.size，那么increment[k]相当于要加的val。如果要pop了，那么这个inc[k-1]的地方会加上原来inc[k]的值。\n- push只要确认下边界没有超就行，\n\n## 代码\n\n```java\nclass CustomStack {\n    \n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n        \n    }\n    \n    public void push(int x) {\n        if(stack.size() < n)\n            stack.push(x);\n    }\n    \n    public int pop() {\n        int i = stack.size() - 1;\n        if(i < 0) return -1;\n        if(i > 0) inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if(i >= 0)\n            inc[i] += val;\n    }\n}\n\n\n```\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186572599","body":"##思路\n- 就是利用栈的特性，先把所有字符都压入栈中，遇到\"]\"时说明找到匹配。这个时候先将[]内的string存到一个地方。\n在读完string后，开始读数字k，数字有可能不是1位，所以要用一个base和循环来读数字。\n最后将 k * string压回栈中。继续匹配。最终栈内的字符串因为是反着的（出栈的时候顺序相反），所以result记得反着将栈中所有字母弹出来。\n\n\n## 代码\n```code \nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        \n        \n        for(int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == ']'){\n                List<Character> decodedString = new ArrayList<>();\n                while(stack.peek() != '['){\n                    decodedString.add(stack.pop());\n                }\n                stack.pop();\n                int k = 0;\n                int base = 1;\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\n                    k = k + (stack.pop() - '0') * base;\n                    base *= 10;\n                }\n                while(k != 0){\n                    for(int j = decodedString.size() - 1; j >= 0; j--){\n                        stack.push(decodedString.get(j));\n                    }\n                    k--;\n                }\n            }\n            else{\n                stack.push(s.charAt(i));\n            }\n        }\n       \n        char[] result = new char[stack.size()];\n        for(int i = result.length - 1; i >= 0; i--){\n            result[i] = stack.pop();\n        }\n        return new String(result);\n    }\n}\n```\n时间复杂度：O(maxK^(countK)⋅n).\n空间复杂度：O(sum(maxK^(countK) ⋅n))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224462","body":"## 思路\n用两个栈来实现队列，一个栈用来保存除了底部的所有数据。\n\n## 代码\n\n```java\nclass MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public int pop() {\n        peek();\n        return output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n```\n\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461363","body":"## 思路\n用排序计数的方法找到最小块\n今天答案直接抄官方题解了\n\n\n## 代码\n```java\n\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        int nonzero = 0;\n        \n        int[] expect = arr.clone();\n        Arrays.sort(expect);\n        \n        for(int i = 0; i < arr.length; ++i) {\n            int x = arr[i];\n            int y = expect[i];\n            \n            count.put(x, count.getOrDefault(x, 0) + 1);\n            if(count.get(x) == 0){\n                nonzero--;\n            }\n            if(count.get(x) == 1){\n                nonzero++;\n            }\n            \n            count.put(y, count.getOrDefault(y, 0) - 1);\n            if(count.get(y) == -1){\n                nonzero++;\n            }\n            if(count.get(y) == 0){\n                nonzero--;\n            }\n            if(nonzero == 0){\n                ans++;\n            }\n        }\n        \n        return ans;\n        \n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neado":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185661466","body":"### 思路\n\n最后一个元素开始遍历，遍历到最后一个元素若是索引到了尽头，而还有进位就依据 || k>0逻辑再次运算一遍\n维护一个相加数k\n并存储计算之后的结果\n最后返回结果数组\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int n=num.length;\n        LinkedList<Integer> res=new LinkedList<>();\n        for(int i=n-1;i>-1|| k>0;i--){\n            if(i>-1 ){\n                k=k+num[i];\n            }\n            Integer r=k%10;\n            res.addFirst(r);\n            k=k/10;\n        }\n        return res;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度(Time)：O(N)\n- 空间复杂度(Space)：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225868","body":"## 思路\n先遍历字符，存下标\n再bfs\n## 代码\n```java\nclass Solution {\n    int[] dirs = new int[]{-1, 1};\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] res = new int[n];\n\n        //填入-1 ，用于判断是否目标字符\n        Arrays.fill(res, -1);\n\n        Deque<Integer> d = new ArrayDeque<>();\n\n        //目标字符 入队，结果数组置为0\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                d.addLast(i);\n                res[i] = 0;\n            }\n        }\n        //bfs 遍历数据，从左到右，遍历目标字符下标\n        while (!d.isEmpty()) {\n            int t = d.pollFirst();\n            //前后搜索\n            for (int dir : dirs) {\n                //移动后下标\n                int index = t + dir;\n                //只处理非目标字符\n                if (index >= 0 && index < n && res[index] == -1) {\n                    //无论向哪个方向移动，距离都会加1\n                    res[index] = res[t] + 1;\n                    d.addLast(index);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552368","body":"## 思路\r\n\r\n## 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] arr;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        arr = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != arr.length - 1) {\r\n            arr[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        return arr[--top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int m = Math.min(k, top + 1);\r\n        for (int i = 0; i < m; ++i) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677968","body":"## 思路\r\n两个栈分别存 重复次数 和要重复的字符\r\n\r\n- 字符和数字分别赋值\r\n- 遇到 左括号 `[` 就存入栈，并清除字符临时存储变量值\r\n- 遇到右括号 `[`  就取出相应字符串，并循环拼接相应次数\r\n\r\n## 代码\r\n```java\r\n class Solution {\r\n    int mulN = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        LinkedList<Integer> muS = new LinkedList<>();\r\n        LinkedList<String> chS = new LinkedList<>();\r\n        for(char c : s.toCharArray()) {\r\n            //入栈 数字和字符\r\n            if(c == '[') {\r\n                muS.addLast(mulN);\r\n                chS.addLast(res.toString());\r\n                mulN = 0;\r\n                res = new StringBuilder();\r\n            }else if(c == ']') {\r\n                StringBuilder midT = new StringBuilder();\r\n                int n = muS.removeLast();\r\n                for(int i = 0; i < n; i++) {\r\n                    midT.append(res);\r\n                }\r\n                res = new StringBuilder(chS.removeLast() + midT);\r\n                //出栈\r\n            }else if(c >= '0' && c <= '9') {\r\n                //赋值数字\r\n                mulN = mulN * 10 + Integer.parseInt(c + \"\");\r\n            }else{\r\n                //赋值字符\r\n                 res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189235609","body":"```java\nclass MyQueue {\n\n     Stack<Integer> inStack;\n     Stack<Integer> outStack;\n    public MyQueue() {\n        inStack=new Stack<>();\n        outStack=new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        moveToOut();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        moveToOut();\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() &&outStack.isEmpty();\n    }\n\n    public void moveToOut(){\n        if(outStack.isEmpty()){\n                while(!inStack.isEmpty()){\n                    outStack.push(inStack.pop());\n                }\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaojunjun1110":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185663624","body":"#  思路\r\n从后往前累加，有很多边界要处理，参考了官方题解\r\n# Code\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int len = num.length;\r\n        int sum;\r\n        for(int i = len - 1; i >= 0; i--){\r\n            sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n       for (; k > 0; k /= 10) {\r\n           res.add(k % 10);\r\n       }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186210463","body":"## 思路\r\n\r\n> + 暴力法，分别左右遍历取最小,看题解原来双向遍历就好了。。。\r\n\r\n##代码\r\n\r\n```java\r\n#代码\r\n\r\n```class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int j, k;\r\n        int res[] = new int[s.length()];\r\n        for(int i = 0; i < s.length(); i++){\r\n            j = i -1;\r\n            k = i + 1;\r\n            int minLen = Integer.MAX_VALUE;\r\n            if(s.charAt(i) == c){\r\n                res[i] = 0;\r\n            } else {\r\n                while(j >= 0 || k < s.length()){\r\n                    if(j >= 0 && s.charAt(j) == c){\r\n                        minLen = Math.min(minLen, i - j);\r\n                    }\r\n                    if(k < s.length() && s.charAt(k) == c){\r\n                        minLen = Math.min(minLen, k - i);\r\n                    }\r\n                    j--;\r\n                    k++;\r\n                }\r\n                res[i] = minLen;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n2)\r\n> + 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxleah":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185664303","body":"### 思路\r\n1. 将整数加到数组最后一位即个位，取余作为个位\r\n2. 加和结果的整除结果进位，加到数组下一位\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        n = len(num)\r\n        i = n - 1\r\n        while i >= 0 or k > 0:\r\n            if i >= 0:\r\n                k += num[i]\r\n            res.append(k % 10)\r\n            i -= 1\r\n            k //= 10\r\n        res.reverse()\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(max(n, logk)，其中 n 为数组长度。（k有logk位数）\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186211008","body":"## 题目\r\n[821](https://leetcode.cn/problems/shortest-distance-to-a-character/)\r\nGiven a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\r\n\r\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\r\n\r\n## 左右分别找\r\n### 思路\r\n?\r\n**_左边最近_**----从左往右遍历, 当找到字符时, 更新字符位置loc, 字符位置在遍历到的位置i左边, distance = i-loc\r\n**_右边最近_**----从右往左遍历, 字符位置loc在遍历到的位置i右边, distance = loc-i\r\n**_比大小_**----将更小的值存到结果里\r\n\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =len(s)\r\n        res = [] \r\n\r\n        # 从左往右, 距离为i-loc\r\n        loc = - n # 若左边未找到c, 确保距离>=n\r\n        for i, ch in enumerate(s) :\r\n            if ch == c:\r\n                loc = i\r\n            res.append(i - loc)\r\n        \r\n        # 从右往左, 距离为loc-i\r\n        loc = 2*n # 若右边未找到c, 确保距离>=n\r\n        for i in range(n - 1, -1, -1):\r\n            if s[i] == c:\r\n                loc = i\r\n            res[i] = min(loc - i, res[i])\r\n        \r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n?\r\n- 时间复杂度：O(n)，其中 n 为数组长度。遍历两遍\r\n- 空间复杂度：O(1) \r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552453","body":"### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.count = 0\n        self.size = maxSize\n        self.add = [0] * self.size\n\n    def push(self, x: int) -> None:\n        if self.size > self.count:\n            self.stack.append(x)\n            self.count += 1\n\n    def pop(self) -> int:\n        if self.count == 0: \n            return -1\n        if self.count >= 2:\n            self.add[self.count-2] += self.add[self.count-1]\n        res = self.stack[self.count - 1] + self.add[self.count - 1]\n        self.add[self.count - 1] = 0\n        self.count -= 1\n        return res\n\n\n    def increment(self, k: int, val: int) -> None:\n        if self.count: \n            self.add[min(k - 1, self.count - 1)] += val\n","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunl1ght":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185665340","body":"# 思路\n\n遍历数组，每次都让数组的最后一位和数字的个位求和，代码如下：\n\n- 时间复杂度O(N)，\n\n- 空间复杂度O(N)\n\n# 代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<>();\n        int i = A.length - 1, sum = 0, carry = 0;\n        // 循环遍历数组A，每次都将数组末尾和数字K的个位进行求和\n        while (i >= 0 || K != 0) {  \n            int x = i >= 0 ? A[i]: 0;\n            int y = K != 0 ? K % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            K /= 10;\n            i--;\n            res.add(0, sum % 10);\n        }\n        if (carry != 0) res.add(0, carry);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213449","body":"## 思路\n先统计字符串s中出现的c的位置存入一列表，再将字符串各位置与列表中值依次对比，比较得出最小的存入输出数组中。\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chs = s.toCharArray();\n        int[] res = new int[chs.length];\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < chs.length; i++) {\n            if (chs[i] == c){\n                list.add(i);\n            }\n        }\n        for (int i = 0; i < chs.length; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < list.size(); j++) {\n                if (Math.abs(i - list.get(j)) < min) {\n                    min = Math.abs(i - list.get(j));\n                } \n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```\n## 复杂度\n- 时间复杂度O(N^2)\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186503503","body":"## 思路\n数组模拟栈，双数组，一个用于记录数据，一个用于记录增加的值。\n\n## 代码\n```java\nclass CustomStack {\n        int maxSize;\n        int size;\n        int[] data;\n        int[] inc;\n        public CustomStack(int maxSize) {\n            this.maxSize=maxSize;\n            data=new int[maxSize];\n            inc=new int[maxSize];\n        }\n\n        public void push(int x) {\n            if(size<maxSize){\n                data[size++]=x;\n            }\n        }\n\n        public int pop() {\n            if(size==0) return -1;\n            int res=data[size-1]+inc[size-1];\n            if(size>1){\n                inc[size-2]+=inc[size-1];\n            }\n            inc[size-1]=0;\n            size--;\n            return res;\n        }\n\n        public void increment(int k, int val) {\n            int min=Math.min(k,size);\n            if(min>0)\n                inc[min-1]+=val;\n        }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189198055","body":"## 思路\n\n模拟题\n\n队列-先进先出，栈-先进后出，因此，需要用到两个栈模拟队列\n\n## 代码\n```java\nclass MyQueue {\n\n    Stack<Integer> stack_in;\n    Stack<Integer> stack_out;\n\n    public MyQueue() {\n        stack_in = new Stack<>();\n        stack_out =  new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack_in.push(x);\n    }\n    \n    public int pop() {\n        check_stack_in();\n        return stack_out.pop();\n    }\n    \n    public int peek() {\n        check_stack_in();\n        return stack_out.peek();\n    }\n    \n    public boolean empty() {\n        return stack_in.isEmpty() && stack_out.isEmpty();\n    }\n\n    public void check_stack_in() {\n        if (!stack_out.isEmpty()) {\n            return;\n        }\n        while (!stack_in.isEmpty()) {\n            stack_out.push(stack_in.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190412380","body":"## 思路\n采用栈操作，可以发现升序的递增特征，每部分构成递增。首先遍历原数组，栈空直接存入栈中，\n- 栈head > 数组当前值，直接pop出栈，直到 >= 栈head项出现；\n- 栈head <= 数组当前值，入栈；\n最后返回栈的大小即为最大块数。\n\n## 代码\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        // 栈方法\n        // 判断栈中数据\n        Stack<Integer> stack = new Stack<>();\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.peek()) {\n                int head = stack.pop();\n                while (!stack.isEmpty() && num < stack.peek()) {\n                    stack.pop();\n                }\n                stack.push(head);\n            } else {\n                stack.push(num);\n            }\n        }\n        return stack.size();\n    }\n}\n```\n## 复杂度\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kerrhl":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667597","body":"### 思路\n参考了做的，倒着取取每个位数相加，单独考虑进位（没太看懂那种三个放在一起加的）\n\n### 代码\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans = []\n        \n        for i in range(len(num)-1, -1, -1):\n            all = num[i] + k % 10\n            k = k // 10\n            if all >= 10:\n                k = k + 1\n            ans.append(all % 10)\n            \n        while k > 0:\n            ans.append(k % 10)\n            k = k // 10\n        return ans[::-1]\n```\n### 复杂度\n时间复杂度: O(n)\n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orangejuz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185667727","body":"## 思路\r\n倒叙无脑加整数k\r\n## 代码\r\n```python3\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        i = 0\r\n        length = len(num)\r\n        carry = k\r\n        while(carry>0):\r\n            if i < length:\r\n                sum = num[-i-1] + carry\r\n                num[-i-1] = sum % 10\r\n                carry = sum // 10\r\n            else:\r\n                num = [carry%10] + num\r\n                carry = carry // 10\r\n            i+=1\r\n        return num\r\n```\r\n### 时间复杂度: O(n)\r\n### 空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186197767","body":"```python3\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        l = r = 0\r\n        n = len(s)\r\n        res = [n] * n\r\n        flag = False  \r\n        while r <= n - 1:\r\n            if s[r] == c:\r\n                res[r] = 0\r\n                while l <= r:\r\n                    res[l] = min(res[l], r - l)\r\n                    l += 1\r\n                r += 1\r\n                flag = True\r\n            else:\r\n                if flag:\r\n                    res[r] = res[r-1] + 1\r\n                r += 1\r\n        return res\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531817","body":"```python3\r\n\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187567839","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        \r\n        stack, res = [], \"\"\r\n        \r\n        for i in s:\r\n            if i != \"]\":\r\n                stack.append(i)\r\n\r\n            else:\r\n                word = stack.pop()\r\n                words = \"\"\r\n                while word != \"[\":\r\n                    words = word+words\r\n                    word = stack.pop()\r\n                \r\n                multi = stack.pop()\r\n                multi_times = \"\"\r\n                while multi.isnumeric():\r\n                    multi_times = multi + multi_times\r\n                    print(multi_times)\r\n                    if stack and stack[-1].isnumeric(): multi = stack.pop()\r\n                    else: break\r\n\r\n                stack.append(words*int(multi_times))\r\n        \r\n        \r\n        for i in stack: res += i\r\n        return(res)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188968558","body":"```python3\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.L = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.L.append(x)\r\n\r\n    def pop(self) -> int:\r\n        print(self.L)\r\n        return self.L.pop(0)\r\n\r\n    def peek(self) -> int:\r\n        return self.L[0]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if(len(self.L) == 0):\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191134572","body":"### 思想\r\n链表成环\r\n\r\n```python3\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        if not head or not head.next:\r\n            return head\r\n        count = 1\r\n\r\n        while(tail.next):\r\n            tail = tail.next\r\n            count += 1\r\n    \r\n        if k % count == 0:\r\n            return head\r\n\r\n        #首尾相连\r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        head = tail.next\r\n        tail.next = None\r\n        return head\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flyzenr":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185668901","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        l = len(num)\r\n        list_num = 0\r\n        for i in range(l):\r\n            list_num = list_num + num[i]*10^(l-(i-1))\r\n            print(num[i]*10^(l-(i-1)))\r\n        list2_num = list_num + k\r\n        str1 = str(list2_num)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186216337","body":"### Code\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        l = len(s)\n        cIndex = []\n        for i in range(l):\n            if s[i] == c:\n                cIndex.append(i)\n        lenlist = [[] for i in range(l)]\n        for index, j in enumerate(s):\n            if j == c:\n                lenlist[index] = 0\n            else:\n                short = l\n                for k in range(len(cIndex)):\n                    short = min(short, abs(index-cIndex[k]))\n                lenlist[index] = short\n        return lenlist\n\n```\n### 复杂度\n- 时间：O(l*k), l是s的长度，k是c的出现的次数\n- 空间：O(l)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549624","body":"### 思路\r\nincrement并不提前造好maxSize长度，而是根当前栈长度同步增加长度，省一点空间。\r\n\r\n### Code\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.size = 0\r\n        self.incrementals = []\r\n        \r\n    def push(self, x: int) -> None:\r\n        if(self.size < self.maxSize):\r\n            self.stack.append(x)\r\n            self.incrementals.append(0)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if(self.size == 0):\r\n            return -1\r\n        self.size -= 1\r\n        if(self.size >= 1):\r\n            self.incrementals[-2] += self.incrementals[-1]\r\n        return self.stack.pop() + self.incrementals.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.incrementals:\r\n            self.incrementals[min(k, self.size) - 1] += val\r\n```\r\n### 复杂度分析\r\n- 时间复杂度：均为O(1)\r\n- 空间复杂度：O(size)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187659729","body":"### 思路\n这个解码中涉及到了 [[]]中括号嵌套，正好可以利用栈中先进后出，后进先出的特点。\n### Code\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l = len(s)\n        stack,res,multi = [],\"\",0\n        for c in s:\n            if c == '[':\n                stack.append([res,multi])\n                res,multi = \"\",0\n            elif c == ']':\n                last_res,cur_multi = stack.pop()\n                res = last_res + cur_multi*res\n            elif '0' <= c <= '9':\n                multi = multi*10 + int(c)\n            else:\n                res += c\n        return res\n```\n### 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189217061","body":"### Code\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190459002","body":"### Code\r\n```\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        stack = []\r\n        for num in arr:\r\n            # 递增栈\r\n            if not stack or stack[-1] <= num:\r\n                stack.append(num)\r\n            else:\r\n                cur_max = stack.pop()\r\n                while stack and stack[-1] > num:\r\n                    stack.pop()\r\n                stack.append(cur_max)\r\n        return len(stack)\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c1f2h3":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673058","body":"# 思路\n\n写了一下，提交不对，应该是数据溢出了，直接变为两个数相加的办法不太行\n考虑一种做法，将其变为 num 数组中的元素依次与 k 相加，第一步先末位与 k 相加，结果对 10 取余与下一位相加，当前位置保留对 10 取余\n最后考虑是否有溢出位，然后添加到 0 位置上\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212302","body":"# 数组的遍历\n根据题意，单词中任一字符与目标字符 target 距离的最小值必然为其与前 1 个 target 和后一个 target 中较小的存在  \n因此通过简化题意，可以前后各遍历一次求解  \n第一次从左至右，目标是找到距离左边 target 的最小距离\n第二次从右至左，目标是找到距离右边 target 的最小距离\n\n代码如下：\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int[] dist = new int[len];\n        Arrays.fill(dist, len+1);\n        for(int i=0, j=-1; i<len; ++i){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i]= i-j;\n        }\n        for(int i=len-1, j=-1; i>=0; i--){\n            if(s.charAt(i)==c) j=i;\n            if(j!=-1) dist[i] = Math.min(dist[i], j-i);\n        }\n        return dist;\n    }\n}\n```\n时间复杂度：遍历两次数组，故为 O(N) \n空间复杂度：辅助空间使用数组长度为单词长度，故为 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186541483","body":"简单模拟题，选择用 List 来实现，其实用数组应该也一样，做长度判断即可\n```java\nclass CustomStack {\n\n    int maxSize;\n    List<Integer> stack = new ArrayList<>();\n    public CustomStack(int _maxSize) {\n        maxSize = _maxSize;\n    }\n    \n    public void push(int x) {\n        if(stack.size()==maxSize) return;\n        stack.add(x);\n    }\n    \n    public int pop() {\n        if(stack.size()==0) return -1;\n        int res = stack.get(stack.size()-1);\n        stack.remove(stack.size()-1);\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int n = k>stack.size()?stack.size():k;\n        for(int i=0; i<n; ++i)\n            stack.set(i, stack.get(i)+val);\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187637907","body":"使用两个栈，一个记录数字，一个记录字符\n当检测到\"[\"时，将数字入栈\n当检测到“]”时，将数字出栈，并与当前记录的 str 进行组合追加即可\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                // 合理的字符串前必然是数字，因此此处将数字入栈\n                stack_multi.addLast(multi);\n                // 将之前的字符入栈存储\n                stack_res.addLast(res.toString());\n                // 重新记录\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                // 字符串结束，需要根据数字栈和 res 组合成结果\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                // 将字符追加\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            // 判断数字部分\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180325","body":"思路：类似两个竹筒倒豆子，新来的加入到stack1里，想取第一个就把stack1的倒进stack2里，就可以取到第一个，然后放回去\n```java\nclass MyQueue {\n\n    Stack q1, q2;\n\n    public MyQueue() {\n        q1 = new Stack();\n        q2 = new Stack();\n    }\n    \n    public void push(int x) {\n        q1.push(x);\n    }\n    \n    public int pop() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.pop();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public int peek() {\n        while(!q1.empty())\n            q2.push(q1.pop());\n        int res = (int)q2.peek();\n        while(!q2.empty())\n            q1.push(q2.pop());\n        return res;\n    }\n    \n    public boolean empty() {\n        return q1.empty();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443684","body":"自己没做出来，看了题解理解了\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n        for(int num : arr) {\n            if(!stack.isEmpty() && num < stack.getLast()) {\n                int head = stack.removeLast();\n                while(!stack.isEmpty() && num < stack.getLast()) stack.removeLast();\n                stack.addLast(head);\n            }\n            else stack.addLast(num);\n        }\n        return stack.size();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dlm001128":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673085","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> tmp;\n        while(k){\n            tmp.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(num.begin(), num.end());\n        vector<int> res;\n        int t = 0;\n        int i = 0, j = 0;\n        for(; i < num.size() && j < tmp.size(); i++, j++){\n            res.push_back((num[i] + tmp[j] + t) % 10);\n            t = (num[i] + tmp[j] + t) / 10;\n        }\n        while(i < num.size()){\n            res.push_back((num[i] + t) % 10);\n            t = (num[i] + t) / 10;\n            i++;\n        }\n        while(j < tmp.size()){\n            res.push_back((tmp[j] + t) % 10);\n            t = (tmp[j] + t) / 10;\n            j++;\n        }\n        if(1 == t){\n            res.push_back(t);\n        }\n        int n = res.size() - 1;\n        while(0 == res[n--]){\n            res.pop_back();\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185673838","body":"## 思路\r\n从低位到高位相加， 利用carry进位\r\n\r\n## 代码\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        carry = 0\r\n        for i in range(len(num) - 1, -1, -1):\r\n            num[i], carry = (carry + num[i] + k % 10) % 10, (carry + num[i] + k % 10) // 10\r\n            k //= 10\r\n        B = []\r\n        carry = carry + k\r\n        while carry:\r\n            B = [(carry) % 10] + B\r\n            carry //= 10\r\n        return B + num\r\n```\r\n\r\n## 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186224694","body":"## 思路\n贪心算法：先从左往右，再从右往左，最后计算最短距离。\n\n## 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n## 复杂度分析\n时间：O(n)\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186358345","body":"## 思路\n第一反应是直观实现，看了题解发现可以用前缀和实现\n## 代码\n``` python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.max = maxSize\n        self.stack = []\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.max:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n```\n\n## 复杂度分析\n时间：O(1)\n空间：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186593772","body":"## 思路\n\n利用stack实现，'['出发入栈。\n\n## 代码\n```python\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for i in s:\n            if i == ']':\n                strs = ''\n                repeat = ''\n                while stack[-1] != '[':\n                    strs = stack.pop() + strs\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    repeat = stack.pop() + repeat\n                stack.append(int(repeat) * strs)\n                continue\n            stack.append(i)\n        return ''.join(stack)\n```\n\n##  复杂度分析\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189200907","body":"## 思路\n一个inStack 一个outStack。input把数据push到outStack。延展阅读好评，知道了使用场景。\n\n## 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.inStack = []\n        self.outStack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.inStack.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.outStack:\n          while self.inStack:\n              self.outStack.append(self.inStack.pop())\n\n        return self.outStack.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.inStack:\n            return self.inStack[0]\n        else:\n            return self.outStack[-1]\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if not self.inStack and not self.outStack:\n            return True\n        else:\n            return False\n```\n\n## 复杂度分析\n时间：O(n)\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aconcert":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185674070","body":"```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n\n    let pow = 0;\n    let val = 0;\n    let result = []\n\n    for(let i = num.length-1; i >= 0; i++){\n        val += num[i] * Math.pow(10,pow);\n    }\n\n    val+=k;\n    \n    for(let i = 0; i < num.length -1; i++){\n        result.push(val / (Math.pow(10, num.length)));\n        num.shift();\n    }\n\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186212745","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n\n  let cSet = new Set();\n  let result: number[] = [];\n\n  for (let index = 0; index < s.length; index++) {\n    const str = s[index];\n    if (str === c) {\n      cSet.add(index);\n    }\n  }\n\n  for (let index = 0; index < s.length; index++) {\n    let position = s.length;\n    cSet.forEach((ind) => {\n      if (Math.abs(Number(ind)-index) < position) {\n        position = Math.abs(Number(ind)-index);\n      }\n    })\n    result.push(position);\n  }\n\n  return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186543378","body":"```typescript\nclass CustomStack {\n    customStack: number[] = [];\n    maxSize: number;\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n    }\n\n    push(x: number): void {\n        const len = this.customStack.length;\n        if(len < this.maxSize){\n            this.customStack[len] = x;\n        }\n    }\n\n    pop(): number {\n        const len = this.customStack.length;\n        if(len > 0){\n            const lastOne = this.customStack[len-1];\n            delete this.customStack[len-1];\n            this.customStack.length--;\n            return lastOne;\n        }\n        return -1;\n    }\n\n    increment(k: number, val: number): void {\n        if(this.customStack.length < k){\n            k = this.customStack.length;\n        }\n        for(let i = 0; i < k ; i++){\n            this.customStack[i]+=val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187653669","body":"```typescript\nvar decodeString = function (s) {\n    let s_array = s.split('');\n\n    if (isNaN(Number(s_array[0]))) {\n        s_array.unshift('[');\n        s_array.unshift('1');\n        s_array.push(']')\n    }\n\n    return strdecode(s_array, 1);\n\n};\n\nfunction strdecode(k, repeat) {\n    let str_val = '';\n    let result_val = '';\n    let number_str = Number(k.shift());\n    let k_value = k.shift();\n\n    if (k.length === 0) {\n        return;\n    }\n\n    while (isNaN(k_value)) {\n        str_val += k_value;\n        k_value = k.shift();\n    }\n    if (!isNaN(k_value)) {\n        k.unshift(k_value);\n    }\n\n    for (let index = 0; index < repeat; index++) {\n        result_val += str_val;\n    }\n\n    return result_val + strdecode(k, k_value);\n\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189134913","body":"```typescript\nclass MyQueue {\n    stack: number[] = [];\n    mockQueue: number[] = [];\n    constructor() {\n    }\n\n    push(x: number): void {\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue.pop()!;\n    }\n\n    peek(): number {\n        if (this.mockQueue.length === 0) {\n            while(this.stack.length>0){\n                this.mockQueue.push(this.stack.pop()!);\n            }\n        }\n        return this.mockQueue[this.mockQueue.length-1];\n    }\n\n    empty(): boolean {\n        return this.stack.length === 0 && this.mockQueue.length ===0\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linjunhe":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675036","body":"```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        i = len(num) - 1\r\n        c = 0\r\n        while i >= 0 or k != 0:\r\n            a = num[i] if i >= 0 else 0\r\n            b = k % 10\r\n            sum = a + b + c\r\n            c   = sum // 10\r\n            res.append(sum % 10)\r\n            i = i - 1\r\n            k = k // 10\r\n        if c != 0:\r\n            res.append(c)\r\n        return res[::-1]\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219163","body":"```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        n = len(S)\r\n        res = [0 if c == C else n for c in S]\r\n        for i in range(1, n):\r\n           res[i] = min(res[i], res[i - 1] + 1)\r\n        for i in range(n - 2, -1, -1):\r\n            res[i] = min(res[i], res[i + 1] + 1)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551539","body":"```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n        self.len = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.len < self.maxSize:\r\n            self.stack.append(x)\r\n            self.len += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.len == 0:\r\n            return -1\r\n        else:\r\n            self.len -= 1\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(k):\r\n            if i < self.len:\r\n                self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187622566","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189185010","body":"```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1, s2;\r\n\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        // 先调用 peek 保证 s2 非空\r\n        peek();\r\n        return s2.pop();\r\n    }\r\n\r\n    public int peek() {\r\n        if (s2.isEmpty())\r\n            // 把 s1 元素压入 s2\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        return s2.peek();\r\n    }\r\n\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190410948","body":"```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        res = [arr[0]]\r\n        for i in range(1, len(arr)):\r\n            if arr[i] >= res[-1]:\r\n                res.append(arr[i])\r\n            else:\r\n                index = -1\r\n                for j in range(len(res) - 2, -1, -1):\r\n                    if res[j] <= arr[i]:\r\n                        index = j\r\n                        break\r\n                res = res[0:index + 1] + [res[-1]]\r\n        return len(res)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyqqq22":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185675275","body":"### 思路\r\n逆序遍历数组进行相加，有两种情况：\r\n1. num数组长度大于k位数；遍历完num后k为0，相加结果一致\r\n2. num数组长度小于k位数；遍历完后k不为0，则继续将k剩余数字逐个加上\r\n\r\n注意进位，若需要进位则在k前进一位后加一\r\n\r\n### 代码\r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        res=[]\r\n        for i in range(len(num)):\r\n            sum=num[-i-1]+k%10\r\n            k/=10\r\n            if sum>=10:\r\n                k+=1\r\n                sum-=10\r\n            res.append(sum)\r\n        while k:\r\n            res.append(k%10)\r\n            k/=10\r\n        return res[::-1]\r\n```\r\n### 复杂度分析\r\n时间复杂度: O(max(n,k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185758533","body":"### 思路\r\n两次遍历，分别寻找字符与左边c字符的最小距离和与右边c字符的最小距离，取两者最小值\r\n\r\n### 代码\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n=len(s)\r\n        res=[n]*n\r\n        cidex=-n\r\n        for i,ch in enumerate(s):\r\n            if ch==c:\r\n                cidex=i\r\n            res[i]=i-cidex\r\n        cidex=n\r\n        for i in range(-1,-len(s)-1,-1):\r\n            if s[i]==c:\r\n                cidex=i\r\n            res[i]=min(res[i],cidex-i)\r\n        return res\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度：O(n)，n为字符串s的长度\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186547537","body":"用top记录栈顶位置\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.stack=[0]*maxSize\r\n        self.top=-1\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top<len(self.stack)-1:\r\n            self.top+=1\r\n            self.stack[self.top]=x\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.top==-1:\r\n            popout=-1\r\n        else:\r\n            popout=self.stack[self.top]\r\n            self.top-=1\r\n        return popout\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<k:\r\n            self.stack=[x+val for x in self.stack]\r\n        else:\r\n            for i in range(k):\r\n                self.stack[i]+=val\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677632","body":"# 【Day 1】989. 数组形式的整数加法\n\n## 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for (int i = n - 1; i >= 0 || k > 0; --i, k /= 10) {\n            if (i >= 0) {\n                k += num[i];\n            }\n            res.push_back(k % 10);\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n## 复杂度\n**时间复杂度**：O(max(n,log k))，其中n为数组的长度\n\n**空间复杂度**：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225383","body":"# 【Day 2】821. 字符的最短距离\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186551813","body":"# 【Day 3】1381. 设计一个支持增量操作的栈\n\n## 代码\n\n```c++\nclass CustomStack {\npublic:\n\tint maxSize;\n\tvector<int>tmp;\n\tCustomStack(int maxSize) {\n\t\tthis->maxSize = maxSize;\n\t}\n\n\tvoid push(int x) {\n\t\tif (tmp.size() >= maxSize)\n\t\t{\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttmp.emplace_back(x);\n\t\t}\n\t}\n\n\tint pop() {\n\t\tif (tmp.size() == 0)\n\t\t\treturn -1;\n\t\telse\n\t\t{\n\t\t\tint x = tmp.back();\n\t\t\ttmp.pop_back();\n\t\t}\n\t}\n\n\tvoid increment(int k, int val) {\n\t\tfor (int i = 0; i < tmp.size() && i < k; i++)\n\t\t{\n\t\t\ttmp[i] += k;\n\t\t}\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187675016","body":"# 【Day 4】394. 字符串解码\n\n## 代码\n\n```C++\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189153792","body":"# 【Day 5】232. 用栈实现队列\n\n## 代码\n\n```C++\nclass MyQueue {\npublic:\n    stack<int> stIn;        //输入栈\n    stack<int> stOut;        //输出栈\n\n    //入栈无返回，有参数\n    void push(int x){\n        stIn.push(x);//先加入输入栈\n    }\n    //出栈有返回，返回出栈的元素\n    int pop(){\n        //只有当stOut为空的时候，再从stIn里面导入全部数\n        if(stOut.empty()){\n            //从stIn导入数据直到stIn为空\n            while(!stIn.empty()){\n                stOut.push(stIn.top());\n                stIn.pop();\n            }\n        }\n        //出栈的有元素，可以出栈，临时保存栈顶\n        int front = stOut.top();\n        stOut.pop();\n        return front;\n    }\n\n    int peek(){\n        int res = this->pop();  //直接使用已有的pop函数\n        stOut.push(res);    //因为pop函数弹出了元素res，所以在添加回去\n        return res;\n    }\n\n\n    bool empty(){\n        return stOut.empty()&&stIn.empty();\n    }\n};\n\n```\n\n## 复杂度\n\n时间复杂度：O(1)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190450446","body":"# 【Day 6】768. 最多能完成排序的块 II\n\n## 代码\n\n```C++\n// 官方题解\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int> stack;\n        for(int i =0;i<arr.size();i++){\n            // 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            // 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if(!stack.empty()&&stack.top()>arr[i]){\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.top();\n                // 维持栈的单调递增\n                while(!stack.empty()&&stack.top()>arr[i]){\n                    stack.pop();\n                }\n                stack.push(cur);\n            }else{\n                stack.push(arr[i]);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n};\n\n//Lee 只能通过一部分用例\nclass Solution {\npublic:\n\tint maxChunksToSorted(vector<int>& arr) {\n\t\tint ans = 0;\n\t\tint i = arr.size();\n\t\twhile (i != 0)\n\t\t{\n\t\t\tint j = max_element(arr.begin(), arr.begin() + i) - arr.begin();\n\t\t\twhile (j + 1 < arr.size() && arr[j] == arr[j + 1] && j < i-1)\n\t\t\t\tj += 1;\n\t\t\ti = j;\n\t\t\tans += 1;\n\t\t}\n\t\treturn ans;\n\t}\n};\n```\n\n## 复杂度\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"elon-lau":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185677997","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        temp = \"\"\n        for i in num:\n            temp += str(i)\n        temp = int(temp) + k\n        print([i for i in str(temp)])\n        return [int(i) for i in str(temp)]\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186222102","body":"## 思路\n\n> + 思路描述\n\n##代码\n\n```python\n#代码\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        temp_list = []\n        for i in range(len(s)):\n            temp_int = 0\n            while True:\n                if i - temp_int >= 0:\n                    if s[i-temp_int] == c:\n                        break\n                if i + temp_int <= len(s) - 1:\n                    if s[i+temp_int] == c:\n                        break\n                temp_int += 1\n            temp_list.append(temp_int)\n        return temp_list\n```\n\n## 复杂度\n\n> + 时间复杂度: O(n^2)\n> + 空间复杂度: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186522716","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\n# 代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) > 0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) >= k:\n            for i in range(k):\n                self.stack[i] += val\n        else:\n            for i in range(len(self.stack)):\n                self.stack[i] += val\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187670227","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\n# 代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n\n        stack = []\n        nums = 0\n        for char in s:\n            if char.isdigit(): \n                nums = nums*10 + int(char)\n            elif char != ']':  \n                if nums!=0:\n                    stack.append(nums)\n                    nums = 0\n                stack.append(char)\n            else:  \n                tmp_s = ''\n                while stack[-1]!='[':\n                    tmp_s = stack.pop(-1) + tmp_s\n                stack.pop(-1)\n                num = stack.pop(-1) \n                stack.append(num * tmp_s)\n\n        return ''.join(stack)  \n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189048751","body":"## 思路\n\n> + 思路描述\n用双栈模拟队列。\n\n## 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.instack = []\n        self.outstack = []\n\n    def push(self, x):\n        self.instack.append(x)\n\n    def pop(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack.pop()\n\n    def peek(self):\n        if len(self.outstack) == 0:\n            while self.instack:\n                self.outstack.append(self.instack.pop())\n        return self.outstack[-1]\n    def empty(self):\n        return len(self.instack) == 0 and len(self.outstack) == 0\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190128976","body":"## 思路\n\n> + 思路描述\n\n## 代码\n\n```python\nclass Solution:\n    def maxChunksToSorted(self, arr: [int]) -> int:\n        stack = []\n        for num in arr:\n            if stack and num < stack[-1]: \n                head = stack.pop()\n                while stack and num < stack[-1]: \n                    stack.pop()\n                stack.append(head)\n            else: \n                stack.append(num)\n        return len(stack)\n\n```\n\n## 复杂度\n\n> + 时间复杂度: \n> + 空间复杂度:\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nowkizzz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185679498","body":"var addToArrayForm = function(num, k) {\n    const res = [];\n    const nLen = num.length;\n    for (let i = nLen  - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gsgtgyb":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681120","body":"### 思路\n考虑到数组长度过长，不能进行累加后转换，采取逐位累加的方式，数组末尾累加之k上，取余。本人采取的是arraylist，参考答案后改为linkedlist\n### 代码\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n       int j = k;\n        int i = num.length -1;\n        LinkedList list = new LinkedList();\n        while (i >= 0 || j > 0) {\n            if (i>=0) {\n                j = j + num[i];\n            }\n            list.addFirst(j%10);\n            j = j / 10;\n            i--;\n        }\n        return list;\n    }\n}\n```\n### 复杂度分析\n时间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"irenia111":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185681843","body":"var addToArrayForm = function(A, K) {\n        const res = [];\n        const n = A.length;\n        for (let i = n - 1; i >= 0; --i) {\n        let sum = A[i] + K % 10;\n        K = Math.floor(K / 10);\n        if (sum >= 10) {\n          K++;\n            sum -= 10;\n        }\n        res.push(sum);\n      }\n        for (; K > 0; K = Math.floor(K / 10)) {\n        res.push(K % 10);\n      }\n        res.reverse();\n        return res;\n      };","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188832","body":"```\r\nvar shortestToChar = function(S, C) {\r\n    let res = [];\r\n    const sArr = S.split('');\r\n    for(let i=0;i<sArr.length;i++){\r\n        let leftArr;\r\n        let rightArr;\r\n        const curChar = sArr[i];\r\n        if(curChar === C){\r\n            res.push(0)\r\n        }else{\r\n            leftArr = sArr.slice(0, i).reverse();\r\n            rightArr = sArr.slice(i+1);\r\n            const leftDis = leftArr.indexOf(C) + 1;\r\n            const rightDis = rightArr.indexOf(C) + 1;\r\n            if(leftDis === 0){\r\n                res.push(rightDis)\r\n            }\r\n            if(rightDis === 0){\r\n                res.push(leftDis);\r\n            }\r\n            if(leftDis > 0 && rightDis > 0){\r\n                res.push(Math.min(leftDis, rightDis));\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186552331","body":"```\r\nvar CustomStack = function (maxSize) {\r\n    this.top = 0;\r\n    this.add = new Array(maxSize).fill(0);\r\n    this.stack = new Array(maxSize).fill(0);\r\n};\r\nCustomStack.prototype.push = function (val) {\r\n    if (this.top === this.stack.length) return;\r\n    this.stack[this.top] = val;\r\n    this.add[this.top] = 0;\r\n    this.top += 1;\r\n};\r\nCustomStack.prototype.pop = function () {\r\n    if (this.top === 0) return -1;\r\n    this.top -= 1;\r\n    if (this.top > 0)\r\n        this.add[this.top - 1] += this.add[this.top];\r\n    return this.stack[this.top] + this.add[this.top];\r\n};\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let len = Math.min(k, this.top);\r\n    if (len === 0) return;\r\n    this.add[len - 1] += val;\r\n};\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671696","body":"```\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) {\r\n            return \"\";\r\n        }\r\n        Deque<Integer> times = new ArrayDeque<>();\r\n        Deque<StringBuilder> dq = new ArrayDeque<>();\r\n        StringBuilder sb = new StringBuilder();\r\n        int index = 0;                               // index:已经处理好的字段\r\n        char ch = s.charAt(0);\r\n        OUT:\r\n        while (true) {\r\n            int i = index;\r\n            if (ch >= '0' && ch <= '9') {\r\n                while (ch >= '0' && ch <= '9') {\r\n                    ch = s.charAt(++i);\r\n                }\r\n                times.push(Integer.parseInt(s.substring(index, i)));\r\n                index = ++i;                            // 跳过'['\r\n                ch = s.charAt(i);\r\n            }\r\n            dq.push(sb);                               // 拿到新数字，要另起炉灶\r\n            sb = new StringBuilder();\r\n            while (ch < '0' || ch > '9') {\r\n                if (ch == ']') {\r\n                    int time = times.pop();              // 字符串复制\r\n                    String str = sb.toString();\r\n                    for (int j = 1;j < time;j++) {\r\n                        sb.append(str);\r\n                    }\r\n                    sb = dq.pop().append(sb);       // 连接到上一段末尾\r\n                } else {\r\n                    sb.append(ch);\r\n                }\r\n                index = ++i;                                // 跳过']'\r\n                if (i == s.length()) {\r\n                    break OUT;\r\n                }\r\n                ch = s.charAt(i);\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189187847","body":"```\r\nclass MyQueue {\r\n    private Stack<Integer> a;// 输入栈\r\n    private Stack<Integer> b;// 输出栈\r\n    \r\n    public MyQueue() {\r\n        a = new Stack<>();\r\n        b = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        a.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // 如果b栈为空，则将a栈全部弹出并压入b栈中，然后b.pop()\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(b.isEmpty()){\r\n            while(!a.isEmpty()){\r\n                b.push(a.pop());\r\n            }\r\n        }\r\n        return b.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return a.isEmpty() && b.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190443778","body":"```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> s = new Stack<>();\r\n        for(int i=0;i<arr.length;i++){\r\n            int v = -1;\r\n            while(!s.isEmpty() && s.peek()>arr[i]){\r\n                v=Math.max(v,s.pop());\r\n            }\r\n            if(v!=-1)\r\n                s.push(v);\r\n            else\r\n                s.push(arr[i]);\r\n        }\r\n        return s.size();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suiyi8760":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185684032","body":"正向思维的暴力解法，reverse和k的分解方式还可以优化，没时间了先交卷\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    const numArrReverse = num.reverse()\n    const kArrReverse = String(k).split('').map(item=>Number(item)).reverse()\n    let needCarry:boolean = false\n    const mapObject = (numArrReverse.length>kArrReverse.length?numArrReverse:kArrReverse)\n    return mapObject.reduce<number[]>((pre,cur,index)=>{\n       const sum = (numArrReverse[index]??0)+(kArrReverse[index]??0)+(needCarry?1:0)\n       console.log(sum)\n       if(sum>=10) {\n           needCarry = true\n       } else{\n           needCarry = false\n       }\n        return [...pre,sum%10,...(mapObject.length-1===index&&needCarry?[1]:[])]\n    },[]).reverse()\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225083","body":"```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const stringLength = s.length\n    const returnArr:number[] = new Array(stringLength).fill(0)\n    for(let i = 0,cPos = -stringLength;i<stringLength;i++){\n        if(s[i]===c){\n            cPos = i\n        }\n        returnArr[i] = i - cPos\n    }\n    console.log(returnArr)\n    for(let j = stringLength - 1,cPosRight = 2*stringLength;j>=0;j--){\n        if(s[j]===c){\n            cPosRight = j\n        }\n        returnArr[j] = Math.min(returnArr[j],cPosRight - j)\n    }\n    console.log(returnArr)\n    return returnArr\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186460622","body":"```typescript\n/*\n * @lc app=leetcode.cn id=1381 lang=typescript\n *\n * [1381] 设计一个支持增量操作的栈\n */\n\n// @lc code=start\nclass CustomStack {\n\n    stack: number[] = []\n\n    constructor(public maxSize: number = 0) {\n\n    }\n\n    push(x: number): void {\n        if (this.stack.length < this.maxSize) {\n            this.stack.push(x)\n        }\n    }\n\n    pop(): number {\n        return this.stack.pop() ?? -1\n    }\n\n    increment(k: number, val: number): void {\n        for (let i = 0; i < this.stack.length; i++) {\n            if (i < k) {\n                this.stack[i] = this.stack[i] + val\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n// @lc code=end\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189337623","body":"补卡 一个栈结构解决\n```typescript\nfunction decodeString(s: string): string {\n    const stack:string[] = []\n    for (let i = 0; i < s.length; i++) {\n      const element = s[i]\n      if(s[i]!==']'){\n        stack.push(element)\n      } else {\n        let repeatStr = '',\n        repeatCount = ''\n        while(stack[stack.length-1]!=='['){\n          repeatStr = stack.pop() + repeatStr\n        }\n        stack.pop()\n        while(/^[0-9]+.?[0-9]*/.test(stack[stack.length-1])){\n          repeatCount = stack.pop() + repeatCount\n        }\n        stack.push(repeatStr.repeat(Number(repeatCount)))\n        console.log(stack)\n      }\n    }\n    return stack.join('')\n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190348699","body":"原生api默秒全（🐶.jpg）\n```typescript\nclass MyQueue {\n    queue: number[] = []\n    constructor() {\n        \n    }\n\n    push(x: number): void {\n        this.queue.push(x)\n    }\n\n    pop(): number {\n        return this.queue.splice(0,1)[0]\n    }\n\n    peek(): number {\n        return this.queue[0]\n    }\n\n    empty(): boolean {\n        return this.queue.length === 0\n    }\n}\n```\n正式用栈解一下\n```typescript\nclass MyQueue {\n    inStack: number[] = []\n    outStack: number[] = []\n    constructor() {\n\n    }\n\n    push(x: number): void {\n        this.inStack.push(x)\n    }\n\n    pop(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack.pop() as number\n    }\n\n    peek(): number {\n        if (!this.outStack.length) {\n            this.in2out()\n        }\n        return this.outStack[this.outStack.length - 1]\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0\n    }\n\n    in2out(): void {\n        while (this.inStack.length) {\n            this.outStack.push(this.inStack.pop() as number)\n        }\n    }\n}\n```","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185691220","body":"思路\n---\n1、从末尾逐位取数向前做加法  \n2、设置一个变量FLAG标识是否有进位，若有则设置FLAG=1，反之为0    \n3、注意k和num长度边界值的判断  \n\n代码\n---\n``` JAVA\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int len=num.length-1;\n        int flag=0,tmp_k=0,tmp_num=0,sum=0;\n        List<Integer> res=new ArrayList<Integer>();\n        while(k>0||len>=0){\n            tmp_num = len>=0?num[len]:0;\n            tmp_k = k>0?k:0;\n            sum=flag+tmp_num+(tmp_k%10);\n            if(sum>=10){\n                flag=1;\n                sum=sum%10;\n            }else {\n                flag = 0;\n            }\n            k=k>0?k/10:0;\n            len--;\n            res.add(0,sum);\n        }\n        if(flag==1){\n            res.add(0,flag);\n        }\n        return res;\n    }\n}\n```\n复杂度\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186138233","body":"思路\n---  \n1、从左从右各循环一次，从左循环时找第i个字符左边最近的c，从右循环时找第i个字符右边最近的c  \n2、res记录最短距离并输出\n\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        if (s.length()==1) return new int[]{0};\n        int[] res =new int[s.length()];\n        Arrays.fill(res,s.length()+1);\n        for(int i=0,index=-1;i<s.length();i++){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=i-index;\n        }\n        for(int i=s.length()-1,index=-1;i>=0;i--){\n            if(s.charAt(i)==c) index=i;\n            if(index!=-1) res[i]=Math.min(res[i],index-i);\n        }\n        return res;\n    }\n}\n```\n复杂度分析\n---\n时间复杂度：O（n）  \n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186437794","body":"思路\n---\n用ArrayList模拟栈，要注意边界值的处理，即pop和push操作之前判断当前Array长度是否超出最大长度\n\n代码\n---\n```Java\nclass CustomStack {\n    List<Integer> stack ;\n    int maxSize;\n    public CustomStack(int maxSize) {\n        this.stack = new ArrayList<Integer>();\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size()<maxSize){\n            stack.add(x);\n        }\n    }\n    public int pop() {\n        if(stack.size()==0){\n            return -1;\n        }\n        int index=stack.size()-1;\n        int res=stack.get(index);\n        stack.remove(index);\n        return res;\n    }\n    public void increment(int k, int val) {\n        int size = k<stack.size()?k:stack.size();\n        for(int i=0;i<size;i++){\n            int tmp=stack.get(i)+val;\n            stack.set(i,tmp);\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187625321","body":"思路\n---\n首先将字符串遍历一遍，把字母和数字分别存在两个栈内。  \n主要注意：当字符等于‘[’时，证明需要记录新的字符子串；  \n当字符等于‘]’时，证明一个子串的信息已经全部给出，开始构造这个子串。\n\n代码\n---\n``` JAVA\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack_str = new Stack<String>();\n        Stack<Integer> stack_num = new Stack<Integer>();\n        String res=\"\";\n        int mul=0;\n        for(char c:s.toCharArray()){\n            if(Character.isDigit(c)){\n                mul=mul*10+(c-'0');\n            }else if(Character.isAlphabetic(c)){\n                res = res+c;\n            }else if(c=='['){\n                stack_str.push(res);\n                res=\"\";\n                stack_num.push(mul);\n                mul=0;\n            }else{\n                String str_tmp = stack_str.pop();\n                int num_tmp = stack_num.pop();\n                String res_tmp=\"\";\n                while(num_tmp>0){\n                    res_tmp += res;\n                    num_tmp--;\n                }\n                res = str_tmp+res_tmp;\n            }\n        }\n        return res;\n    }\n}\n```\n复杂度\n---\n时间复杂度：O(n)  \n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189168066","body":"思路\n---\n使用两个list，stack和stack_tmp  \n1、入栈时，先将stack内元素按顺序pop到stack_tmp   \n2、将目标元素存入stack内  \n3、最后将stack_tmp内的全部元素pop到stack中\n\n代码\n---\n``` python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.stack_tmp = []\n\n    def push(self, x: int) -> None:\n        while self.stack:\n            self.stack_tmp.append(self.stack.pop())\n        self.stack.append(x)\n        while self.stack_tmp:\n            self.stack.append(self.stack_tmp.pop())\n\n    def pop(self) -> int:\n        return self.stack.pop()\n\n    def peek(self) -> int:\n        length = len(self.stack)\n        return self.stack[length-1];\n\n    def empty(self) -> bool:\n        if not self.stack:\n            return True\n        return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rabbit2010520":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1185806802","body":"# Idea\n###### Traverse S from left to the right and find shortest distance from each element  in S to C.\n###### Traverse S from right to the left and find shortest distance  rom each element  in S to C.\n###### Then find the minimum value.\n\n# Code\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int len = s.length();\n        int [] arr = new int[len];\n        for(int i = 0, index = -len; i < len; i++){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = i - index;\n        }\n        \n        for(int i = len-1, index = 2 * len; i >= 0; i--){\n            if(s.charAt(i) == c){\n                index = i;\n            }\n            arr[i] = Math.min(arr[i], index - i);\n        }\n        return arr;\n    }\n}\n```\n# Complexity\n###### Time complexity: O(N)\n###### Space complexity: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ellie-wu05":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186024434","body":"## 用pointer记住前一个值和后一个值，求min\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre,nex,k = -1,-1,0\n        ans = [None] * len(s)\n        \n        while k < len(s) and s[k] != c:  k+=1\n        nex = k\n        \n        for i in range(len(s)):\n            if pre == -1:\n                dis = nex -i\n            elif nex == -1:\n                dis = i - pre\n            else:\n                dis = min((nex -i),(i-pre))\n            ans[i] = dis\n            \n            if s[i] ==c:\n                pre = nex\n                k = i+1\n                while k < len(s) and s[k] !=c: k+=1\n                nex = k\n                if nex == len(s): nex = -1\n                \n        return ans\n```\n## 复杂度：\n时间：On\n空间：On","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186385024","body":"'''\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n        self.inc = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n            self.inc.append(0)\n\n    def pop(self) -> int:\n        if not self.stack: return -1\n        if len(self.stack) >=2:\n            self.inc[-2] += self.inc[-1]\n        \n        return self.stack.pop() + self.inc.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.inc:\n            self.inc[min(k,len(self.stack))-1] += val\n        \n\n\n\n'''\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187677476","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        \n        for c in s:\n            if c != ']':\n                stack.append(c)\n                continue\n            else:\n                string =''\n                num = ''\n                while stack and stack[-1] !='[':\n                    string = stack.pop() + string\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    num = stack.pop() + num\n                stack.append(int(num) * string)\n        return ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189813017","body":"class Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        # [1,1,2,1,1,3,4,5,1,6]\n        # [1,1,5,6]\n        \n        stack = []\n        \n        for num in arr:\n            # 遇到一个比栈顶小的元素，而前面的块不应该有比 a 小的\n            # 而栈中每一个元素都是一个块，并且栈的存的是块的最大值，因此栈中比 a 小的值都需要 pop 出来\n            if stack and stack[-1] > num:\n                curr_max = stack[-1]\n                # 我们需要将融合后的区块的最大值重新放回栈\n                # 而 stack 是递增的，因此 stack[-1] 是最大的\n                while stack and stack[-1]>num:\n                    stack.pop()\n                # 维持栈的单调递增\n                stack.append(curr_max)\n            else:\n                stack.append(num)\n        # 栈存的是块信息，因此栈的大小就是块的数量\n        return len(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yopming":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186049958","body":"### 思路\n双向遍历。一个character离c最近距离只有两种情况，要么到左边的c，要么到右边的c。第一次遍历得出来每个character与其左边的c的距离（若出现在c之前，距离为s.size()）；第二次遍历得出来每个character与其右边的c的距离，取较小的那个。\n\n### 代码\n```lang-c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      std::vector<int> distances(s.size());\n      if (s.size() <= 0) {\n        return distances;\n      }\n      \n      int len = s.size();\n      int curr = len;\n      \n      // left traversal\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == c) {\n          curr = i;\n          distances[i] = 0;\n        } else {\n          distances[i] = std::min(len, std::abs(i - curr));\n        }\n      }\n      \n      // right traversal\n      for (int i = s.size() - 1; i >= 0; i--) {\n        if (s[i] == c) {\n          curr = i;\n        } else {\n          distances[i] = std::min(distances[i], std::abs(i - curr));\n        }\n      }\n      \n      return distances;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度：O(n) in which n is the size of string s.\n- 空间复杂度：O(1) if the return vector is not counted.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186258412","body":"### 思路\r\n使用vector来存储数据，使用单独一个变量来存储stack的size。\r\npush的时候，先检查当前vector的size是否小于stack size limit。然后把要插入的数放在vector的尾部。\r\npop的时候，先检查当前vector是否为空，返回-1如果为空。先暂存vector的back()，然后pop_back()，接着返回暂存的back()值，也就是stack后进先出（后进的数在vector尾部）。\r\nincrement的for循环要检查两个边界，一个是k，一个是vector的大小。\r\n\r\n### 代码\r\n```c++\r\nclass CustomStack {\r\nprivate:\r\n  std::vector<int> arr;\r\n  int stack_limit_;\r\n\r\npublic:\r\n    CustomStack(int maxSize) {\r\n      this->stack_limit_ = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n      if (arr.size() < this->stack_limit_) {\r\n        arr.push_back(x);\r\n      }\r\n    }\r\n    \r\n    int pop() {\r\n      if (arr.size() <= 0) {\r\n        return -1;\r\n      }\r\n      int back = arr.back();\r\n      arr.pop_back();\r\n      return back;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n      for (int i = 0; i < k; i++) {\r\n        if (i == arr.size()) {\r\n          break;\r\n        }\r\n        \r\n        arr[i] += val;\r\n      }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：Constructor $O(1)$, push $O(1)$, pop() $O(1)$, increment $O(k)$ in which k stands for the number of elements need to increase.\r\n- 空间复杂度：One vector and one int used，therefore $O(n)$ in which $n$ stands for stack size.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186668073","body":"### 思路\n使用两个stack，一个存数字，一个存之前已经decode完成的部分。\n由于input是valid，只存在如下4中情况\n* digit: 存入stack1。需要注意超过9的数字，需要先暂存。\n* alphabet: 拼接到局部变量\n* `[`: 把数字和已经之前已经deocde的string放入各自stack\n* `]`: 此时当前括号内的string还没有被push到stack2，而需要重复的数字已经被push了，所以要从stack1取top值。然后需要把之前decode完成的部分取出来，拼接当前括号的内容。最后要把拼接好的string赋予局部变量，以备下一次push时候所用。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // temp\n      std::string str;  // temp\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (isalpha(ch)) {\n          str += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};\n```\n\n**复杂度分析**\nAssume $N$ is the length of input string.\n- 时间复杂度 $O(kN)$ such that $k$ is the maximum of digits in the input string.\n- 空间复杂度 $O(N)$ or $O(m+n)$ such that $m$ is the number of digits, $n$ is the number of alphabets and $m+n <= N$ since the existence of brackets.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188059775","body":"### 思路\n两个stack，一个“正序”，一个“逆序”，这样push的时候push到正序，pop的时候从逆序pop，这样就可以实现FIFO，两个stack各实现一半。\n\n### 代码\n```c++\nclass MyQueue {\n  std::stack<int> stack0;\n  std::stack<int> stackQ;\n  \npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n      // move everything from stackQ to stack0\n      while (!stackQ.empty()) {\n        stack0.push(stackQ.top());\n        stackQ.pop();\n      }\n      \n      stack0.push(x);\n      \n      // move from stack0 to stackQ\n      while (!stack0.empty()) {\n        stackQ.push(stack0.top());\n        stack0.pop();\n      }\n    }\n    \n    int pop() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      int ele = stackQ.top();\n      stackQ.pop();\n      return ele;\n    }\n    \n    int peek() {\n      if (stackQ.empty()) {\n        return -1;\n      }\n      \n      return stackQ.top();\n    }\n    \n    bool empty() {\n      return stackQ.empty();\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(1)$ for pop(), peek(), and empty(), $O(n)$ for push()\n- 空间复杂度 $O(n)$ since two stacks are used","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189460643","body":"### 思路\n找最大块的数量也就是找单调减连续数字的数量。比如 21355 就是 21 3 5 5，但如果是 213554 的话，就变成了 21 3 554，两个相同的数能不能分割取决于之后有没有数字。\n\n遇到一个大于栈顶的数字，就将其压入栈，当作是一个新chunk的开头，但是一旦后面遇到小的数字了，就要反过来检查前面的数字，不停的pop栈顶，看看这个更小的数字到底是小于那一个chunk的开头。\n\n最后stack的size就是chunk的数量。\n\n### 代码\n```c++\nclass Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n      std::stack<int> chunk;\n      for (auto ele: arr) {\n        int max = chunk.empty() ? ele : std::max(chunk.top(), ele);\n        while (!chunk.empty() && (chunk.top() > ele)) {\n          chunk.pop();\n        }\n        chunk.push(max);\n      }\n      \n      return chunk.size();\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191092435","body":"### 思路\n由于k有可能大于linked list的长度，所以先遍历一遍linked list来得到长度，顺便把头尾相连。\n之后从头开始走，走n-(k%n)步，此时下一个节点就是head，然后断开连接即可。\n\n\n### 代码\n```c++\nclass Solution {\npublic:\n    ListNode* rotateRight(ListNode* head, int k) {\n      if (!head || !head->next) {\n        return head;\n      }\n      \n      ListNode* curr = head;\n      ListNode* res;\n      int n = 1;\n      \n      // get linked list length\n      while (curr->next != nullptr) {\n        n++;\n        curr = curr->next;\n      }\n      \n      k = n - (k % n);\n      curr->next = head; // circular\n      while (k--) {\n        curr = curr->next;\n      }\n      \n      res = curr->next;\n      curr->next = nullptr;\n      return res;\n    }\n};\n```\n\n**复杂度分析**\n- 时间复杂度 $O(n)$\n- 空间复杂度 $O(1)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luckytwj":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186080707","body":"##  思路\n### 扫描字符串字符 遇到等于c的 计算并设置c左边的距离 res[left],\n### 同时设置c右边的距离(在遇到下一个c之前的)res[right]\n### 取最短距离\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        \n        int[] res = new int[s.length()];\n        Arrays.fill(res,Integer.MAX_VALUE);\n        int start = 0;\n        for(int i = 0;i<s.length();i++){\n            if(s.charAt(i)==c){\n                res[i]=0;\n                int left = i-1;\n                while(left>=start){\n                    res[left]=Math.min(Math.abs(i-left),res[left]);\n                    left--;\n                }\n                int right = i+1;\n                while(right<s.length()&&s.charAt(right)!=c){\n                    res[right]=Math.abs(right-i);\n                    right++;\n                }                \n                start=i+1;\n            }\n                \n        }\n        return res;\n\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186388835","body":"#### 思路\n##### 数组实现\n```Java\nclass CustomStack {\n    int maxSize;  //定值\n    int size;\n    int[] arr;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        size = 0;        \n        arr = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (size > 0 && size >= maxSize) return;\n        arr[size++]=x;\n    }\n\n    public int pop() {\n        if (size > 0) {\n            int t = arr[size-1];\n            arr[size-1]=0;\n            size--;\n            return t;\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        for(int i = 0;i<size && i<k; i++){\n            arr[i]=arr[i]+val;\n        }\n    }\n}\n```\n复杂度 increment时间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186731570","body":"### 思路\r\n### 递归搜索  \r\n```java\r\nclass Solution {\r\n     int i  = 0;\r\n    public String decodeString(String s) {\r\n        \r\n        return dfs(s,0);\r\n    }\r\n   String dfs(String s, int curr) {\r\n\r\n        StringBuilder sb = new StringBuilder();\r\n        //i设置成全局变量\r\n        for ( i = curr; i < s.length(); i++) {\r\n            if (Character.isDigit(s.charAt(i))) {\r\n                int num = 0, k = i;\r\n                //拼数字\r\n                while (k < s.length() && Character.isDigit(s.charAt(k))) {\r\n                    num = 10 * num + (s.charAt(k) - '0');\r\n                    k++;\r\n                }\r\n                i = k;\r\n                if (s.charAt(i) == '[') {\r\n                    //这里dfs返回时 i已经更新了（来到了‘]’的位置了），\r\n                    //如果还使用当前局部变量会造成重复，所以需要全局变量 跳出当前循环\r\n                    String a = dfs(s, i + 1);\r\n                    //拼串\r\n                    for (int b = 0; b < num; b++)\r\n                            sb.append(a);\r\n                }\r\n\r\n            } else if (s.charAt(i) == ']') { \r\n                return sb.toString();\r\n            } else\r\n                sb.append(s.charAt(i));\r\n        }\r\n        return sb.toString();\r\n\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188496223","body":"### 思路\r\n#### 模拟\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> first;\r\n    Stack<Integer> second;\r\n    int size ;\r\n\r\n    public MyQueue() {\r\n        first = new Stack<>();\r\n        second = new Stack<>();\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        first.push(x);\r\n        size++;\r\n    }\r\n    \r\n    public int pop() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.pop();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            size--;\r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public int peek() {\r\n        int res = -1;\r\n        if(!empty()){\r\n            while(!first.isEmpty()){\r\n                second.push(first.pop());                \r\n            }\r\n            res = second.peek();            \r\n            while(!second.isEmpty()){\r\n                first.push(second.pop());\r\n            }\r\n            \r\n            return res;            \r\n        }\r\n        return res;\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return size>0?false:true;\r\n    }\r\n}\r\n```\r\n### 时间复杂度 O(n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189929060","body":"```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] sortArr = arr.clone();\r\n        Arrays.sort(sortArr);\r\n        int tmpSub = 0;\r\n        int ans = 0;\r\n        for (int i = 0; i < arr.length; i++) {\r\n            tmpSub += arr[i] - sortArr[i];\r\n            if (tmpSub == 0) {\r\n                ans++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190990311","body":"### 思路\r\n#### 首尾连接找分割点\r\n```java\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if (head == null) return head;\r\n        int len = 0;\r\n        ListNode curr = head, pre = curr;\r\n        while (curr != null) {\r\n            len++;\r\n            pre = curr;\r\n            curr = curr.next;\r\n        }\r\n\r\n        int start = k % len;\r\n        if (start == 0) return head;\r\n        //首尾连接\r\n        pre.next = head;\r\n        //分割位置\r\n        int split = len - start;        \r\n        pre = head;\r\n        ListNode startNode = head;\r\n        while (split-- > 0) {\r\n            pre = startNode;\r\n            startNode = startNode.next;\r\n        }\r\n        //分割\r\n        pre.next = null;\r\n        return startNode;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzz607":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186102380","body":"# 思路 \n暴力求解，先找出所有的c在s中的索引，然后依次计算s中每个字符与c的距离  \n\n# 代码\n```Go\nfunc shortestToChar(s string, c byte) []int {\n\tvar cIdx []int\n\tvar ret []int\n\n\tinitCIdx := func() {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tif s[i] == c {\n\t\t\t\tcIdx = append(cIdx, i)\n\t\t\t}\n\t\t}\n\t}\n\n\tgetDistance := func(idx int) int {\n\t\tmin := math.MaxInt32\n\t\tfor _, ii := range cIdx {\n\t\t\ttmp := int(math.Abs(float64(ii - idx)))\n\t\t\tif tmp < min {\n\t\t\t\tmin = tmp\n\t\t\t}\n\t\t}\n\t\treturn min\n\t}\n\n\tinitCIdx()\n\tfor i := 0; i < len(s); i++ {\n\t\tret = append(ret, getDistance(i))\n\t}\n\n\treturn ret\n}\n``` \n\n# 复杂度\n- 时间复杂度：O(NK)，K为c在s中的个数，N为s的长度  \n- 空间复杂度：O(K)，K为c在s中的个数","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1190361693","body":"### 思路\n\n双栈实现，其中一个栈用于出队操作时的辅助操作\n\n### 代码\n\n```Go\ntype MyQueue struct {\n\tinput *MyStack\n\toutput *MyStack\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tinput: new(MyStack),\n\t\toutput: new(MyStack),\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.input.Push(x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\t// 题目保证不会在空的栈上面调用pop/peek\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Pop()\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif this.output.IsEmpty() {\n\t\tthis.inputToOutput()\n\t}\n\treturn this.output.Peek()\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif this.input.Size() != 0 || this.output.Size() != 0 {\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (this *MyQueue) inputToOutput() {\n\tfor !this.input.IsEmpty() {\n\t\tthis.output.Push(this.input.Pop())\n\t}\n}\n\ntype MyStack struct {\n\tdata []int\n}\n\nfunc (receiver *MyStack) Pop() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\tv := receiver.data[len(receiver.data) - 1]\n\treceiver.data = receiver.data[:len(receiver.data) - 1]\n\treturn v\n}\n\nfunc (receiver *MyStack) Peek() int {\n\tif receiver.IsEmpty() {\n\t\treturn -1\n\t}\n\t\n\treturn receiver.data[len(receiver.data) - 1]\n}\n\nfunc (receiver *MyStack) Push(v int) {\n\treceiver.data = append(receiver.data, v)\n}\n\nfunc (receiver *MyStack) Size() int {\n\treturn len(receiver.data)\n}\n\nfunc (receiver *MyStack) IsEmpty() bool {\n\treturn len(receiver.data) == 0\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)。出栈时，最坏情况下是O(n)，但是之后的n个元素出栈是O(1)，从而平摊下来是O(1)\n- 空间复杂度：O(n)\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190353117","body":"### 思路\n\n想要分块排序后的序列与直接排序后的序列一致，那么必须满足条件： \n>**从左往右看，后面的块的最小值，要大于等于前面块的最大值**  \n\n那么，第一个块的最大值在哪里呢？ 可以设定为数组0号位置的值。据此，可以从1号位置往右遍历，找到最后一个小于0号位置的值的位置，从而得到第一个块的起止区间。\n\n以此类推，就可以得到所有块。  \n\n以上算法有一个最大的问题就是：每个块的最后一个位置，不遍历整个数组就无法得到。所以，要想得到一个时间复杂度比较合理的算法，就必须解决此问题。  \n\n根据题目的标签，可以使用单调栈来解决，具体来讲，是单调递增栈，算法如下：\n\n1. 初始时，将0号位置的值入栈，并从1号位置开始往右遍历 \n2. 判断当前遍历得到的元素，若该值大于等于栈顶元素，则直接入栈，否则转第3步\n3. 栈内元素依次出栈，直到新的栈顶元素的值大于等于该值\n4. 取下一个值并转2处理\n\n### 代码\n\n\n```Go\nfunc maxChunksToSorted(arr []int) int {\n\tvar cache []int\n\tfor _, item := range arr {\n\t\tlastIdx := len(cache) - 1\n\t\tif len(cache) != 0 && cache[lastIdx] > item {\n\t\t\tmax := cache[lastIdx]\n\t\t\tfor ; lastIdx >= 0; lastIdx-- {\n\t\t\t\tif cache[lastIdx] <= item {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tcache = append(cache[:lastIdx + 1], []int{max}...)\n\t\t} else {\n\t\t\tcache = append(cache, item)\n\t\t}\n\t}\n\treturn len(cache)\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，出现在顺序递增序列时","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191410520","body":"### 思路\n\n当旋转的次数与链接长度相等时，效果等同于未旋转。因此，旋转的次数需要对链表长度取余，然后再旋转即可 \n\n\n### 代码\n\n\n```Go\nfunc rotateRight(head *ListNode, k int) *ListNode {\n\tif head == nil {return head}\n\n\tvar listLen int\n\tvar p1 = head\n\tfor p1 != nil {\n\t\tlistLen++\n\t\tp1 = p1.Next\n\t}\n\n\tdiff := k % listLen\n\tif diff == 0 {\n\t\treturn head\n\t}\n\tp2 := head\n\tp1 = head\n\tfor i := 0; i < diff; i++ {\n\t\tp1 = p1.Next\n\t}\n\tfor p1.Next != nil {\n\t\tp1 = p1.Next\n\t\tp2 = p2.Next\n\t}\n\n\tnewHead := p2.Next\n\tp2.Next = nil\n\tp1.Next = head\n\treturn newHead\n}\n\n\n```\n\n**复杂度分析**  \n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zoulufeng":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189813947","body":"\r\n\r\n\r\n\r\n\r\n```python\r\ndef list_number(a_list, k):\r\n    a_num = []\r\n    for i in a_list:\r\n        a_num.append(str(i))\r\n    b_num = \"\".join(a_num)\r\n    a_number = int(b_num)\r\n    a_k = a_number + k\r\n    c_num = []\r\n    while(a_k > 10):\r\n        c_num.append(a_k % 10)\r\n        a_k = a_k // 10\r\n    c_num.append(a_k)\r\n    c_num.reverse()\r\n    return c_num\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186121556","body":"# Day02\r\n---\r\n## \tSolution1\r\n---\r\n### 使用语言 Python\r\n---\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        index_list = []\r\n        for index, value in enumerate(s):\r\n            if value == c:\r\n                index_list.append(index)\r\n        # print(index_list)\r\n        distance_list = []\r\n        for index, value in enumerate(s):\r\n            temp_list = []\r\n            for i in index_list:\r\n                temp_list.append(abs(index - i))\r\n            # print(temp_list)\r\n            distance_list.append(min(temp_list))\r\n            # print(distance_list)\r\n        return distance_list\r\n```\r\n时间复杂度：O(n^2)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186390157","body":"# Day03\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.a_list = [] * self.maxSize\r\n        self.numPop = 0\r\n        self.len_a = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if self.len_a < self.maxSize:\r\n            self.a_list.append(x)\r\n\r\n    def pop(self) -> int:\r\n        self.len_a = len(self.a_list)\r\n        if len(self.a_list) == 0:\r\n            return -1\r\n        return self.a_list.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        self.len_a = len(self.a_list)\r\n        if k > self.len_a:\r\n            for i in range(self.len_a):\r\n                self.a_list[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.a_list[i] += val\r\n```\r\n---\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188648564","body":"# day 04\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass Solution:  \r\n  def decodeString(self, s: str) -> str:  \r\n  s_list = list(s)  \r\n  \r\n  a_list = []  \r\n  for index, value in enumerate(s_list):  \r\n  if value != ']':  \r\n  a_list.append(value)  \r\n  else:  \r\n  right = len(a_list)  \r\n  left = \"\".join(a_list).rfind('[')  \r\n  left_left = left - 2  \r\n  num_left_left = a_list[left_left]  \r\n  \r\n  while(48 <= ord(num_left_left) <= 57):  \r\n  if left_left != 0:  \r\n  left_left -= 1  \r\n  num_left_left = a_list[left_left]  \r\n  else:  \r\n  left_left -= 1  \r\n  break  \r\n  int_num = 1  \r\n  int_num = \"\".join(a_list[left_left+1:left])  \r\n  ss = a_list[left + 1:right] * int(int_num)  \r\n  a_list[left_left+1:right + 1] = \"\"  \r\n  # print(a_list)  \r\n  for i in ss:  \r\n  a_list.append(i)  \r\n  s_list = s_list[:left - 1] + s_list[right + 1:]  \r\n  # print(s_list)  \r\n  \r\n  return \"\".join(a_list)\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(3n)$\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188646161","body":"# day 05\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass MyQueue:  \r\n  \r\n  def __init__(self):  \r\n  self.myQue = list()  \r\n  \r\n  def push(self, x: int) -> None:  \r\n  self.myQue.append(x)  \r\n  # print(self.myQue)  \r\n  \r\n  def pop(self) -> int:  \r\n  temp = self.myQue[0]  \r\n  del self.myQue[0]  \r\n  return temp  \r\n  \r\n    def peek(self) -> int:  \r\n  return self.myQue[0]  \r\n  \r\n  def empty(self) -> bool:  \r\n  return False if len(self.myQue) else True\r\n```\r\n时间复杂度：$O(n)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190089322","body":"# day06\r\n---\r\n## 使用语言： Python\r\n---\r\n```python\r\nclass Solution:  \r\n\tdef maxChunksToSorted(self, arr: List[int]) -> int:  \r\n\t\tstart_index, max_index, end_index = 0, 0, 0  \r\n\t\tc_list = []  \r\n\t    len_arr = len(arr)  \r\n\t    while start_index <= len_arr-1:  \r\n\t\t\tend_index = start_index  \r\n            max_index = start_index  \r\n            if start_index == (len_arr-1):  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\t\tbreak  \r\n\t\t    for index, value in enumerate(arr[start_index+1:]):  \r\n\t\t\t\tif arr[start_index] > value:  \r\n\t\t\t\t\tend_index = index+start_index+1  \r\n            max_number = max(arr[start_index:end_index + 1])  \r\n            max_index_temp = arr[start_index:end_index + 1].index(max_number)+ start_index  \r\n            while max_index != max_index_temp:  \r\n\t\t\t\tmax_index = max_index_temp  \r\n                end_index_temp = end_index  \r\n                for iindex, ivalue in enumerate(arr[(end_index+1):]):  \r\n\t\t\t\t\tif arr[max_index_temp] > ivalue:  \r\n\t\t\t\t\t\tend_index_temp = iindex + end_index+1  \r\n\t\t\t\t\tend_index = end_index_temp  \r\n\t\t\t        max_index_temp = arr[start_index:end_index + 1].index(max(arr[start_index:end_index + 1]))  \r\n\t\t\tif end_index == start_index:  \r\n\t\t\t\tc_list.append(arr[start_index])  \r\n\t\t\telse:  \r\n\t\t\t\tc_list.append(arr[start_index:end_index + 1])  \r\n\t\t\tstart_index = end_index + 1  \r\n\t\t# print(c_list)  \r\n\t\treturn(len(c_list))\r\n```\r\n时间复杂度：$O(n^3)$\r\n空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080530","body":"# day07\r\n---\r\n## 使用语言：Python\r\n> 没有技巧，全是感情\r\n---\r\n```python\r\nfrom typing import Optional\r\n# Definition for singly-linked list.\r\n\r\nclass ListNode:\r\n    def __init__(self, val=0, next=None):\r\n        self.val = val\r\n        self.next = next\r\n\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if head:\r\n            a_list = []\r\n            len_head = 1\r\n            real_k = 0\r\n            next_point = head.next\r\n            a_list.append(head.val)\r\n            while next_point:\r\n                a_list.append(next_point.val)\r\n                len_head += 1\r\n                next_point = next_point.next\r\n            real_k = k % len_head\r\n            # print(a_list)\r\n            b_list = [0 for i in range(len_head)]\r\n            for index, value in enumerate(a_list):\r\n                real_index = (real_k + index) % len_head\r\n                b_list[real_index] = value\r\n            # print(b_list)\r\n            L_head = ListNode(b_list[0])\r\n            cur = L_head\r\n            for i in range(1, len_head):\r\n                temp = ListNode(b_list[i])\r\n                cur.next = temp\r\n                cur = temp\r\n                if i == len_head - 1:\r\n                    cur.next = None\r\n\r\n            return L_head\r\n```\r\n---\r\n时间复杂度：$O(3n)$\r\n空间复杂度：$O(2n)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xxoojs":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186160050","body":"## 代码\n---\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n*/\nvar shortestToChar = function(s, c) {\n    let len = s.length,\n        answer = new Array(len),\n        i = 0,\n        pre = -Infinity;\n\n    while (i < len) {\n        if (s[i] === c) {\n            answer[i] = 0;\n            pre = i;\n        } else {\n            let nextIdx = s.indexOf(c, i);\n            if (~nextIdx) {\n                while (i <= nextIdx) {\n                    answer[i] = Math.min(i - pre, nextIdx - i);\n                    ++i;\n                }\n                --i;\n                pre = i;\n            } else {\n                answer[i] = i - pre;\n            }\n        }\n        ++i;\n    }\n\n    return answer;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186441698","body":"## 代码\n---\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.stack.length) {\n        return this.stack.pop();\n    }\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    const max = Math.min(this.stack.length, k);\n    for (let i = 0; i < max; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186722440","body":"## 代码\n---\n```\n/**\n * @param {string} s\n * @return {string}\n*/\nconst numReg = /[0-9]/;\nconst charReg = /[a-z]/;\nvar decodeString = function(s) {\n    let i = 0,\n        len = s.length,\n        stack = [],\n        times = '',\n        ret = '';\n    while (i < len) {\n        const char = s[i];\n        if (charReg.test(char)) {\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += char;\n            } else {\n                ret += char;\n            }\n        }\n        if (numReg.test(char)) {\n            times += char;\n        }\n        if (char === '[') {\n            stack.push({\n                times,\n                letters: ''\n            });\n            times = '';\n        }\n        if (char === ']') {\n            let fragment = stack.pop();\n            let _times = Number(fragment.times) || 1;\n            fragment = fragment.letters.repeat(_times);\n\n            const last = stack[stack.length - 1];\n            if (last) {\n                last.letters += fragment;\n            } else {\n                ret += fragment;\n            }\n        }\n        ++i;\n    }\n    return ret;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188769819","body":"## 代码 \r\n---\r\n```\r\nvar MyQueue = function() {\r\n    this.queue = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    return this.queue.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    return this.queue.shift();\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.queue[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.queue.length <= 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189903866","body":"## 代码\n---\n```\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n    let stack = [];\n    for (let i = 0; i < arr.length; i++) {\n        const cur = arr[i];\n        const top = stack[stack.length - 1];\n        if (!stack.length || cur >= top) {\n            stack.push(cur);\n        } else if (cur < top) {\n            while (stack.length && cur < stack[stack.length - 1]) {\n                stack.pop();\n            }\n            stack.push(top);\n        }\n    }\n    return stack.length;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191084844","body":"## 代码\n---\n```\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n*/\nvar rotateRight = function(head, k) {\n    if (!head || !k) return head;\n    let nodes = [];\n\n    while (head) {\n        nodes.push(head);\n        let prev = head;\n        head = head.next;\n        if (head) {\n            head.prev = prev;\n        }\n    }\n    const len = nodes.length;\n    let idx = (len - k % len) % len;\n    \n    const node = nodes[idx];\n    if (node.prev) {\n        node.prev.next = null;\n        nodes[len - 1].next = nodes[0];\n    }\n    \n    return node;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186183254","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size();\r\n        vector<int> res;\r\n        for(int i=n-1; i>=0; i--){\r\n            int sum = num[i]  + k % 10;\r\n            k = k / 10;\r\n            if (sum >= 10){\r\n                k++;\r\n            }\r\n            res.push_back(sum % 10);\r\n        }\r\n        for(;k>0; k/=10){\r\n            res.push_back(k%10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```\r\n#### 时间复杂度：O(n)\r\n#### 空间复杂度： O(n)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186169287","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> ret;\r\n        int pre_idx = -10000;\r\n        for(int i=0; i<n; i++){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret.push_back(i - pre_idx);\r\n        }\r\n        pre_idx = 10001;\r\n        for (int i=n-1; i>=0; i--){\r\n            if (s[i] == c){\r\n                pre_idx = i;\r\n            }\r\n            ret[i] = min(pre_idx - i, ret[i]);\r\n        }\r\n        return ret;\r\n    }\r\n};\r\n```\r\n### 时间复杂度：O(N);\r\n### 空间复杂度：O(1);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186270513","body":"```CPP\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    vector<int> add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add = vector<int> (maxSize, 0);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (top!=stk.size()-1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        } \r\n        int ret = stk[top] + add[top];\r\n        if (top != 0){\r\n            add[top-1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        top--;\r\n        return ret;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int num = min(k-1, top);\r\n        if (num >= 0){\r\n            add[num] += val;\r\n        }\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186601192","body":"```CPP\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        int n = s.size();\r\n        int count = 0;\r\n        stack<int> nums;\r\n        stack<string> str_stk;\r\n        for(int i=0;i<n; i++){\r\n            char ch = s[i];\r\n            if (ch >= '0' && ch <= '9'){\r\n                count = count * 10 + (ch - '0');\r\n            } else if (ch == '['){\r\n                nums.push(count);\r\n                str_stk.push(res);\r\n                count = 0;\r\n                res = \"\";\r\n            } else if (ch == ']'){\r\n                for(int j=0; j<nums.top(); j++){\r\n                    str_stk.top() += res;\r\n                }\r\n                nums.pop();\r\n                res = str_stk.top();\r\n                str_stk.pop();\r\n            } else {\r\n                res += ch;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n```\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189024707","body":"```CPP\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n    void in2out(){\r\n        while(!inStack.empty()){\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n        \r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (outStack.empty()){\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return (outStack.empty() && inStack.empty());\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wyz999":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186177862","body":"### 思路\r\n先从左到右遍历，记录左侧到最近c的距离\r\n\r\n从右到左，1，记录从右侧到最近c的距离,2，比较两个距离，取最小值\r\n\r\n### 代码\r\n\r\n```golang\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n:=len(s)\r\n    num :=make([]int, n)\r\n    idx:=-n\r\n    // 从左到右\r\n  for k,v:=range s{\r\n      if byte(v)==c{\r\n        idx=k\r\n      }\r\n    num[k]=k-idx\r\n  }\r\n    // 从右到左\r\n   idx=2*n\r\n  for i:=n-1;i>=0;i--{\r\n    if  s[i]== c{\r\n      idx=i\r\n    }\r\n    num[i]=min(num[i],idx-i)\r\n  }\r\n  return num\r\n}\r\n\r\nfunc min(a,b int) int{\r\n  if a>b {\r\n    return b\r\n  }\r\n  return a\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186396294","body":"### 思路\r\n用切片模拟栈操作\r\n\r\n### 代码\r\n```golang\r\n\r\ntype CustomStack struct {\r\n    maxSize int\r\n    stackLen int\r\n    val []int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    var num []int\r\n    customStack:=CustomStack{\r\n        maxSize: maxSize,\r\n        stackLen: 0,\r\n        val: num,\r\n    }\r\n    return  customStack\r\n    \r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if this.maxSize>this.stackLen{\r\n        // this.val[this.stackLen]=x\r\n      this.val= append(this.val,x)\r\n        this.stackLen++\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if this.stackLen==0{\r\n        return -1\r\n    }\r\n    last:=this.val[this.stackLen-1]\r\n    this.val=this.val[:this.stackLen-1]\r\n     this.stackLen--\r\n    return last\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k>=this.stackLen{\r\n        k=this.stackLen\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.val[i]+=val\r\n    }\r\n}\r\n\r\n```\r\n### 时空复杂度\r\n- 时间复杂度: push,pop 为O(1)\r\n- 空间复杂度：O(k)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189224374","body":"## 思路\r\n使用双栈，模拟队列增删改\r\n\r\n## 代码\r\n\r\n```golang\r\ngolang\r\n\r\ntype MyQueue struct {\r\n     inStack ,outStack []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.inStack =append(this.inStack,x)\r\n}\r\n\r\nfunc (this *MyQueue)inToOut(){\r\n    for len(this.inStack)>0{\r\n        this.outStack = append(this.outStack,this.inStack[len(this.inStack)-1])\r\n        this.inStack = this.inStack[:len(this.inStack)-1]\r\n    }\r\n}\r\n\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    op := this.outStack[len(this.outStack)-1]\r\n    this.outStack = this.outStack[:len(this.outStack)-1]\r\n    return op\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.outStack)==0{\r\n        this.inToOut()\r\n    }\r\n    return this.outStack[len(this.outStack)-1]\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n   return len(this.outStack)==0&&len(this.inStack)==0\r\n}\r\n\r\n\r\n```\r\n\r\n## 时空复杂度\r\n- 时间复杂度： O(1)\r\n- 空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186181472","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.length();\n        vector<int> ans(n);\n\n        for (int i = 0, idx = -n; i < n; ++i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = i - idx;\n        }\n\n        for (int i = n - 1, idx = 2 * n; i >= 0; --i) {\n            if (s[i] == c) {\n                idx = i;\n            }\n            ans[i] = min(ans[i], idx - i);\n        }\n        return ans;\n    }\n};\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186481890","body":"class CustomStack {\npublic:\n    int cnt = 0;\n    int maxsize = 0;\n    vector<int> s;\n    CustomStack(int maxSize) {\n        maxsize = maxSize;\n        cnt = 0;\n    }\n    \n    void push(int x) {\n        if (cnt < maxsize ) {\n            s.push_back(x);\n            cnt++;\n        }\n    }\n    \n    int pop() {\n        if (cnt == 0)return -1;\n        int t = s[cnt-1];\n        s.pop_back();\n        cnt--;\n        return t;\n        \n    }\n    \n    void increment(int k, int val) {\n        if (cnt < k) k = cnt;\n        for (int i = 0;i < k;i++) {\n            s[i] += val;\n        }  \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187515123","body":"class Solution {\npublic:\n    string decodeString(string s) {\n        int i = 0;\n        return decode(s, i);\n    }\n    string decode(string s, int& i) {\n        string res = \"\";\n        int n = s.size();\n        while (i < n && s[i] != ']') {\n            if (s[i] < '0' || s[i] > '9') {\n                res += s[i++];\n            } else {\n                int cnt = 0;\n                while (s[i] >= '0' && s[i] <= '9') {\n                    cnt = cnt * 10 + s[i++] - '0';\n                }\n                ++i;\n                string t = decode(s, i);\n                ++i;\n                while (cnt-- > 0) {\n                    res += t;\n                }\n            }\n        }\n        return res;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188974416","body":"class MyQueue {\npublic:\n    stack<int>out;\n    stack<int>in;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        in.push(x);\n    }\n    \n    int pop() {\n        while (out.empty()) {\n            while (!in.empty()) {\n                int x = in.top();\n                in.pop();\n                out.push(x);\n            }\n        }\n        int t = out.top();\n        out.pop();\n        return t;\n    }\n    \n    int peek() {\n        int t = this->pop();\n        out.push(t);\n        return t;\n    }\n    \n    bool empty() {\n        return in.empty()&&out.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190400807","body":"var maxChunksToSorted = function (arr) {\n  let sum1 = 0;\n  let sum2 = 0;\n  let ans = 0;\n  let arr2 = [...arr].sort((a, b) => a - b);\n  for (let i in arr) {\n    sum1 = sum1 + arr[i];\n    sum2 = sum2 + arr2[i];\n    if (sum1 == sum2) {\n      ans += 1;\n      sum1 = 0;\n      sum2 = 0;\n    }\n  }\n  return ans;\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ricjli":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186183393","body":"### Two times iteration:\n\niterate the string from left will calculate the distance to target `c` from the left. \n\niterate the string from right will calculate the distance to target `c` from the right. \n\nthen for each index, we have two lengths, then we can take the minimum value — this is the answer\n\n<aside>\n💡 **Default value for the distance:** \nwe need to set default value to -n, so that in this case, at the first left iteration, when we didn’t come across a target `character`. we can set the distance to `(i-n)` this is large enough for the second round iteration to overwrite it.\n\n</aside>\n\n<aside>\n💡 **Optimization:**\n in the second round iteration. we can start from the first round latest target index, \nsince there’s no target occurred after this index.\n\n</aside>\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length(); \n        int targetIndex = -n; \n        int [] res = new int [n];\n        for(int i = 0; i< n; i++){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] =  i - targetIndex;\n        }\n        for(int i = targetIndex; i >= 0 ; i--){\n            if(s.charAt(i) == c){\n                targetIndex = i;\n            }\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n        return res;\n    }\n}\n```\n\n### Complexity Analysis:\n\nTime : O(n)\n\nspace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186525625","body":"class CustomStack {\n    int maxSize;\n    int pointer;\n    int [] stack;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.pointer = 0;\n        this.stack = new int [maxSize]; \n    }\n    \n    public void push(int x) {\n        if(pointer < maxSize){\n            stack[pointer] = x;\n            pointer ++;\n        } \n    }\n    \n    public int pop() {\n        if(pointer==0){\n            return -1;\n        }\n        int res = stack[pointer - 1];\n        pointer--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i < pointer; i++){\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187583121","body":"### Simulation - 2 stacks\r\n\r\n```java\r\nclass Solution {\r\n\tpublic String decodeString(String s){\r\n\t\tStack<String> strStack = new Stack<>();\r\n\t\tStack<Integer> numStack = new Stack<>(); \r\n\t\tStringBuilder tail = new StringBuilder(); \r\n\t\t\r\n\t\tint len = s.length();\r\n\t\tfor(int i = 0; i <len; i++){\r\n\t\t\tchar c = s.chatAt(i);\r\n\t\t\tif(Character.isDigit(c)){\r\n\t\t\t\t // c - '0'  calculates the integer \r\n\t\t\t\tint num = c - '0';\r\n\t\t\t\twhile(i < len - 1 && Character.isDigit(s.charAt(i+1))){\r\n\t\t\t\t\tnum*= 10;\r\n\t\t\t\t\tnum += s.charAt(++i) - '0';\r\n\t\t\t\t}\r\n\t\t\t\tnumStack.push(num);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\t// save the last string \r\n\t\t\telse if (c == '['){\r\n\t\t\t\tstrStack.push(tail.toString());\r\n\t\t\t\ttail = new StringBuilder(); \r\n\t\t\t}\r\n\r\n\t\t\t// calculate the current string with the previous saving one\r\n\t\t\telse if (c == ']'){\r\n\t\t\t\tStringBuilder temp = new StringBuilder(); \r\n\t\t\t\ttemp.append(strStack.pop());\r\n\t\t\t\tint times = numStack.pop();\r\n\t\t\t\tfor(int i = 0; i < times; i++){\r\n\t\t\t\t\ttemp.append(tail);\r\n\t\t\t\t}\r\n\t\t\t\ttail = temp; \r\n\t\t\t}\r\n\t\t\t\r\n\t\t\telse {\r\n\t\t\t\ttail.append(c);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tail.toString(); \r\n\t}\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188983886","body":"class MyQueue {\n    \n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            while(!inStack.isEmpty()){\n                outStack.push(inStack.pop());\n            }\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190364483","body":"### Double iteration\n\nFor each element, we can say, if all the elements at its right is greater than all the elements at its left, there will be a new trunk. Since in this way, we can sort the trunk w/o interrupting the original order. \n`[2,1,3,4,4]`\n\n```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int len = arr.length; \n        int [] leftMax = new int[len];\n        int [] rightMin = new int [len];\n\n        leftMax[0] = arr[0];\n        for(int i = 1; i<len; i++){\n            leftMax[i] = Math.max(leftMax[i-1], arr[i]);\n        }\n        rightMin[len-1] = arr[len-1];\n        for(int i = len-2; i >= 0; i--){\n            rightMin[i] = Math.min(rightMin[i+1], arr[i]); \n        }\n\n        int res = 0;\n        for (int i = 1; i<len; i++ ){\n            if(leftMax[i-1] <= rightMin[i]){\n                res++;\n            }\n        }\n        return res + 1;\n    }\n}\n```\n\n<aside>\n💡 the final comparison cannot be `leftMax[i] → rightMin[i]` \nshould be `leftMax[i] - rightMin[i+1]`\n\n</aside>","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhaoling":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186189241","body":"解题\r\n\r\n## Idea:\r\n\r\n引入BigInteger类，相加转化为list。\r\n\r\n## Code:\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> result=new ArrayList<>();\r\n        String s=\"\";\r\n       for(int i=0;i<num.length;i++){\r\n           s+=num[i];\r\n       }\r\n       java.math.BigInteger a=new java.math.BigInteger(s);\r\n       java.math.BigInteger b=new java.math.BigInteger(String.valueOf(k));\r\n       java.math.BigInteger c;\r\n        c=a.add(b);\r\n        String d=String.valueOf(c);\r\n        for (int i=0;i<d.length();i++){\r\n            result.add(Integer.valueOf(d.charAt(i))-48);\r\n        }\r\n        return result;\r\n    }\r\n\r\n\r\n}\r\n```\r\n\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186188719","body":"Idea\r\n\r\n```\r\n从左到右和从右到左进行两次遍历计算各元素到目标字符的距离。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int len=s.length();\r\n        int[] result=new int[len];\r\n        for(int i=0;i<len;i++){\r\n            result[i]=Integer.MAX_VALUE;\r\n        }\r\n        for (int i=0;i<len;i++){\r\n            if(s.charAt(i)==c){\r\n                for (int j=0;j<len;j++){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i=len-1;i>0;i--){\r\n            if (s.charAt(i)==c){\r\n                for(int j=len-1;j>0;j--){\r\n                    if (Math.abs(i-j)<result[j]){\r\n                        result[j]=Math.abs(i-j);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186546899","body":"Code\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int[] add;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        int ret = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        }\r\n        add[top] = 0;\r\n        --top;\r\n        return ret;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit >= 0) {\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189074697","body":"Idea\r\n\r\n```\r\n使用两个横向摆放相对开口的栈模拟队列，右边栈储存元素，左边栈弹出元素。\r\n```\r\n\r\nCode\r\n\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> s1,s2;\r\n    public MyQueue() {\r\n        s1=new Stack<>();\r\n        s2=new Stack<>();\r\n    }\r\n\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n        int temp=peek();\r\n        s2.pop();\r\n        return temp;\r\n    }\r\n\r\n    public int peek() {\r\n        if (!s2.isEmpty()){\r\n            return s2.peek();\r\n        }\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n\r\n    }\r\n\r\n    public boolean empty() {\r\n        if (s1.isEmpty()&& s2.isEmpty()){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461353","body":"class Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Map<Integer, Integer> count = new HashMap();\r\n        int ans = 0, nonzero = 0;\r\n\r\n        int[] expect = arr.clone();\r\n        Arrays.sort(expect);\r\n\r\n        for (int i = 0; i < arr.length; ++i) {\r\n            int x = arr[i], y = expect[i];\r\n\r\n            count.put(x, count.getOrDefault(x, 0) + 1);\r\n            if (count.get(x) == 0) nonzero--;\r\n            if (count.get(x) == 1) nonzero++;\r\n\r\n            count.put(y, count.getOrDefault(y, 0) - 1);\r\n            if (count.get(y) == -1) nonzero++;\r\n            if (count.get(y) == 0) nonzero--;\r\n\r\n            if (nonzero == 0) ans++;\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flaming-cl":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186206888","body":"```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n// two pointers (i: read pointer; j: write pointer)\r\n// 1. when i points to c, handle all elements between i -> j\r\n//      i - j < j - lastJ ? i - j : j - lastJ\r\n//      if (j === i) lastJ = j;\r\n// 2. if c is not the last element of s, add the rest of elements for res (there is no fore j, only back j)\r\n//      while (res.length !== s.length) { res.push(res.length - lastJ); }\r\n\r\nvar shortestToChar = function(s, c) {\r\n    if (s.length === 1) return [0];\r\n    let res = [];\r\n    let j = 0;\r\n    let lastJ = null;\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            while (j <= i) {\r\n                res[j] = lastJ === null || (i - j < j - lastJ) ? i - j : j - lastJ;\r\n                if (j === i) lastJ = j;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    while (res.length !== s.length) {\r\n        res.push(res.length - lastJ);\r\n    }\r\n    return res;\r\n};\r\n```\r\nT: O(N)   \r\nS: O(1)   ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531186","body":"```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    // O(1)\r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    // O(1)\r\n    public int pop() {\r\n        if (top == -1) return -1;\r\n        return stack[top--];\r\n    }\r\n    \r\n    // O(N)\r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186604001","body":"Java\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Stack<Integer> tStack = new Stack<>();\r\n        Stack<String> sStack = new Stack<>();\r\n        String temp = \"\";\r\n        int times = 0;\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                times = times * 10 + c - '0';\r\n                continue;\r\n            }\r\n            if (c == '[') {\r\n                sStack.push(temp);\r\n                tStack.push(times);\r\n                temp = \"\";\r\n                times = 0;\r\n                continue;\r\n            }\r\n            if (c == ']') {\r\n                temp = sStack.pop() + temp.repeat(tStack.pop());\r\n                continue;\r\n            }\r\n            temp += c;\r\n        }\r\n        return temp;\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188474959","body":"Java\r\n```java\r\n// stack1: 插入用\r\n// stack2: 删除用（stack2 即倒过来的 stack1，需要取出数字时，调用 stack2）\r\n// 何时在 stack2 中插入值？\r\n// 有这么一种情况：有大量的插入操作，却只有很少的删除/取数操作\r\n// 所以 push 的时候，不必给 stack2 加入数字\r\n// 而是在「删除或取数时，且 stack2 为空时」，从 stack1 中逐一 pop，入栈 stack2\r\nclass MyQueue {\r\n    Stack<Integer> stack1 = new Stack<>();\r\n    Stack<Integer> stack2 = new Stack<>();\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        this.cleanQ1();\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        this.cleanQ1();\r\n        return stack2.get(stack2.size() - 1);\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.size() == 0 && stack2.size() == 0;\r\n    }\r\n\r\n    private void cleanQ1() {\r\n        if (stack2.size() == 0) {\r\n            int q1Len = stack1.size();\r\n            for (int i = 0; i < q1Len; i++) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n- 空间复杂度 O(N)\r\n- 时间复杂度\r\n  - 摊还时间复杂度 O(1) \r\n     - 最坏情况 O(N)：栈 2 为空，需要 for loop 挤压栈 1 时\r\n     - 最好情况 O(1)     \r\n\r\n摊还复杂度：高频次操作的时间复杂度小 + 低频次操作的时间复杂度高，二者均摊了每次操作的代价","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189493717","body":"Java\r\n```java\r\n//找到所有子集的最大值，这些最大值如果能按升序排列，那么这些子集也可以按升序排列    \r\n\r\n// 具体做法：   \r\n// - 维护一个单调栈（单调栈里，装着所有 target 子集的最大值）   \r\n// - 遍历数组   \r\n//  - 如果当前数字 >= 单调栈栈顶（前一个 target 子集的最大值），当前数字入栈   \r\n//  - 如果当前数字 < 单调栈栈顶，说明前面找好的子集最大值和当前数字——无法满足升序排列条件，那就把当前栈中找好的子集最大值们，一个个踢出单调栈，直到当前数字 < 栈顶元素，踢完后把上一个栈顶元素加回来\r\n// - 返回单调栈元素个数，即多少个可生序排列的子集个数 \r\nclass Solution {\r\n    Stack<Integer> stack = new Stack();\r\n    public int maxChunksToSorted(int[] arr) {\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            int stackTop = getStacktop();\r\n            if (arr[i] >= stackTop) {\r\n                stack.push(arr[i]);\r\n                continue;\r\n            }\r\n            while (stack.size() > 0 && arr[i] < getStacktop()) {\r\n                stack.pop();\r\n            }\r\n            stack.push(stackTop);\r\n        }\r\n        return stack.size();\r\n    }\r\n\r\n    int getStacktop() {\r\n        return stack.get(stack.size() - 1);\r\n    }\r\n}\r\n```\r\nT: O(N)\r\nS: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gelxgx":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1185772596","body":"### 思路\r\n在js里，直接先将数组合并为字符串，然后转化为数字进行相加\r\n避免精度丢失，查了一下可以使用BigInt方式解决\r\n相加完毕后，再转化为字符串，切分为数组\r\n\r\n### 代码\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n    let str = num.join('')\r\n    let count = BigInt(str) + BigInt(k)\r\n    let res = count.toString().split('')\r\n    return res\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n\r\n时间复杂度：O(n)\r\n空间复杂度：O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186213182","body":"### 思路\n通过循环，遍历两次\n### 代码\n\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const n=s.length;\n    const ans=new Array(n).fill(0);\n    for(let i=0,idx=-n;i<n;i++){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=i-idx;\n    }\n    for(let i=n-1,idx=2*n;i>=0;--i){\n        if(s[i]==c){\n            idx=i;\n        }\n        ans[i]=Math.min(ans[i],idx-i);\n    }\n    return ans;\n};\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186533856","body":"### 思路\n\n把属性挂在在this链上\n最后一个方法，首先把长度进行对比，for循环修改参数即可\n\n### 代码\n\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length  >= this.maxSize) {\n        return\n    }\n    this.list.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.list.length ? this.list.pop() : -1 \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let length = Math.min(k, this.list.length);\n    for (let i = 0; i < length; i++) {\n        this.list[i] += val;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187636888","body":"### 思路\r\n\r\n维护两个栈，用来记录需要重复的次数和需要重复的字符串\r\n\r\n### 代码\r\n\r\n\r\n```javascript\r\nvar decodeString = function(s) {\r\n    let numStack = [];              \r\n    let strStack = [];              \r\n\r\n    let num = 0, result = '';\r\n\r\n    for(let i = 0; i < s.length; i++) {\r\n        const item = s[i];\r\n\r\n        if(!isNaN(item)) {             \r\n            num = num * 10 + parseInt(item);\r\n        } else if(item === '[') {\r\n            strStack.push(result);\r\n            result = '';\r\n            numStack.push(num);\r\n            num = 0;\r\n        } else if(item === ']') {\r\n            const repeatTimes = numStack.pop();        \r\n            result = strStack.pop() + result.repeat(repeatTimes);\r\n        } else {\r\n            result += item;\r\n        }\r\n    }\r\n    return result;\r\n};\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186218926","body":"## 思路\n贪心法，最接近的值要么在左边，要么在右边\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int[] left = new int[s.length()];\n        int[] right = new int[s.length()];\n        left[0] = s.charAt(0) == c ? 0:Integer.MAX_VALUE-s.length();\n        for(int i = 1; i < s.length(); i++) {\n            if(s.charAt(i) == c)\n                left[i] = 0;\n            else\n                left[i] = left[i-1]+1;\n        }\n        right[s.length()-1] = s.charAt(s.length()-1) == c?0:Integer.MAX_VALUE-s.length();\n        for(int i = s.length()-2; i>=0;i--) {\n            if(s.charAt(i) == c)\n                right[i] = 0;\n            else\n                right[i] = right[i+1]+1;\n        }\n        for(int i = 0; i < left.length;i++)\n            ans[i] = Math.min(left[i],right[i]);\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186535387","body":"## 思路\n了解栈的工作方式即可\n## 代码\n```java\nclass CustomStack {\n    private int pointer;\n    private int[] stack;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.pointer = -1;\n    }\n    \n    public void push(int x) {\n        if(pointer < stack.length-1) {\n            pointer++;\n            this.stack[pointer] = x;\n        }\n\n    }\n    \n    public int pop() {\n        int val;\n        if(pointer < 0)\n            val = -1;\n        else {\n            val = this.stack[pointer];\n            pointer--;\n        }\n        return val;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i <= Math.min(k-1,this.pointer); i++)\n            this.stack[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187643314","body":"## 思路\n栈\n## 代码\n```java\nclass Solution {\n    static Stack<String> strings = new Stack<>();\n    public static String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        for(int i = 0; i < chars.length; i++) {\n            if(chars[i] != ']') {\n                if(Character.isDigit(chars[i])) {\n                    int tempCal = 0;\n                    while(Character.isDigit(chars[i])){\n                        tempCal = tempCal*10 + chars[i] - '0';\n                        i++;\n                    }\n                    i--;\n                    strings.push(String.valueOf(tempCal));\n                } else {\n                    strings.push(String.valueOf(chars[i]));\n                }\n\n            } else {\n                String poped, temp = \"\", newString=\"\";\n                while(!(poped = strings.pop()).equals(\"[\")) {\n                    temp = poped + temp;\n                }\n                poped = strings.pop();\n                int cal = Integer.parseInt(poped);\n                for(int j = 0; j < cal;j++) {\n                    newString += temp;\n                }\n                strings.push(newString);\n            }\n        }\n        String ans = \"\";\n        while(!strings.isEmpty()) {\n            ans = strings.pop()+ans;\n        }\n        return ans;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jessie725":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219318","body":"‘’‘\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int position = -n;\n        int[] res = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = i - position;\n        }\n        for (int i = position - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) {\n                position = i;   \n            }\n            res[i] = Math.min(res[i], position - i);\n        }\n        return res;\n    }\n}\n’‘’","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188598361","body":"class MyQueue {\n    Deque<Integer> in;\n    Deque<Integer> out;\n    \n    public MyQueue() {\n        in = new ArrayDeque<>();\n        out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        in.offerFirst(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pollFirst();\n    }\n    \n    public int peek() {\n        if (!out.isEmpty()) {\n            return out.peek();\n        }\n        else {\n            while (!in.isEmpty()) {\n                out.offerFirst(in.pollFirst());\n            }\n            return out.peek();\n        }\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191033999","body":"```\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        int len = 0;\n        ListNode curr = head;\n        while (curr != null && curr.next != null) {\n            curr = curr.next;\n            len++;\n        }\n        len++; // add last\n        curr.next = head;\n        \n        int offset = len - (k % len);\n        curr = head;\n        while (offset > 1) {\n            curr = curr.next;\n            offset--;\n        }\n        ListNode newHead = curr.next;\n        curr.next = null;\n        \n        return newHead;\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lsunxh":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186219816","body":"# Time: O(N), space O(N)\n        res = [len(s) for i in s]\n        leftC = -1\n        for i in range(len(s)):\n            if s[i] == c:\n                leftC = i\n            if leftC != -1:\n                res[i] = i - leftC\n        rightC = -1\n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                rightC = i\n            if rightC != -1:\n                res[i] = min(res[i], rightC - i)\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186387091","body":"Code:\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack = self.stack + [x]\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack == []:\n            return -1\n        else:\n            return self.stack.pop(len(self.stack)-1)\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        changeRange = min(len(self.stack), k)\n        for i in range(changeRange):","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186615278","body":"class Solution(object):\n    def getNum(self, s, rInd):\n        res = 0\n        place = 0\n        while rInd >= 0 and s[rInd].isnumeric():\n            res += 10**place*int(s[rInd])\n            place += 1\n            rInd -= 1\n        return res, rInd + 1\n    \n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # base case: \"a\", \"[a]\", \"3[a]\"\n        # recursive case: \"3[3[a]]\"\n        left = []\n        i = 0\n        disFromLast = len(s)\n        while disFromLast > 0:\n            i = len(s) - disFromLast\n            if s[i] == \"[\":\n                left.append(i)\n            elif s[i] == \"]\":\n                # get the last left bracket\n                lastLeft = left[-1]\n                left = left[:-1]\n                curStr = s[lastLeft+1:i]\n                if s[lastLeft-1].isnumeric():\n                    num, newInd = self.getNum(s, lastLeft-1)\n                else:\n                    num, newInd = 1, i\n                # update s\n                if i == len(s)-1:\n                    s = s[:newInd] + num * s[lastLeft+1:i]\n                else:\n                    s = s[:newInd] + num * s[lastLeft+1:i] + s[i+1:]\n            # updating i depends on length change in s\n            disFromLast -= 1\n        return s","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506364","body":"class MyQueue(object):\n    def __init__(self):\n        self.reversed = []\n        self.first = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.first.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        self.reversed.pop()\n        return res\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.reversed == []:\n            self.reverseFirst()\n        res = self.reversed[-1]\n        return res\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return self.first == [] and self.reversed == []\n    \n    def reverseFirst(self):\n        for i in range(len(self.first)-1, -1, -1):\n            self.reversed.append(self.first[i])\n        self.first = []","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189803513","body":"## Idea: \nWe scan through the array and update a list of chunks, which stores min and max of each chunk. If cur element in arr is greater than or equal to the max of the last elem in chunks, add a new chunk. Otherwise, we find the first occurrence in chunk where the current elem would fit and merge everything in between. We return the length of chunk at the end.\n## Complexity\n**Time:** O(N), not sure because the while loop could be O(N) worst case. \\\n**Space:** O(N).\n## Code\n```\nclass Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        # chunks stores (min, max) of each chunk\n        chunks = [(arr[0], arr[0])]\n        for i in range(1, len(arr)):\n            if arr[i] >= chunks[-1][1]:\n                chunks.append((arr[i], arr[i]))\n            else:\n                combineIndex = 0\n                while combineIndex < len(chunks) and arr[i] >= chunks[combineIndex][1]:\n                    combineIndex += 1\n                newMin = min(arr[i], chunks[combineIndex][0])\n                newMax = chunks[-1][1]\n                chunks = chunks[:combineIndex]\n                chunks.append((newMin, newMax))\n        return len(chunks)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190947923","body":"## Time: O(N), Space: O(1)\n```\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if head == None: return head\n        copy = head\n        cnt = 0\n        while copy != None:\n            cnt += 1\n            if copy.next == None:\n                oldTail = copy\n            copy = copy.next\n        k = k % cnt\n        if k == 0: return head\n        \n        oldTail.next = head\n        newTail = head\n        for i in range(cnt - k - 1):\n            newTail = newTail.next\n            \n        newHead = newTail.next\n        newTail.next = None\n        return newHead\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lanceli424":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186221215","body":"## 代码\n```\nfunction shortestToChar(s: string, c: string): number[] {\n    let result: number[] = [];\n    if (s.length === 0 || c.length === 0) {\n        return result;\n    }\n    let strArray = Array.from(s);\n    let indexs: number[] = [];\n    strArray.forEach((element, index) => {\n        if (element === c) {\n            indexs.push(index);\n        }\n    });\n    for (let i = 0; i <= indexs[0]; i++) {\n        result.push(indexs[0] - i);\n    }\n    for (let i = 0; i <= indexs.length - 2; i++) {\n        let start = indexs[i];\n        let end = indexs[i + 1];\n        for (let i = start + 1; i <= end; i++) {\n            let distance = Math.min(i - start, end - i);\n            result.push(distance);\n        }\n    }\n    for (let i = indexs[indexs.length - 1] + 1; i < strArray.length; i++) {\n        result.push(i - indexs[indexs.length - 1]);\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531249","body":"## 代码\n```\nclass CustomStack {\n    stack: number[];\n    maxSize: number;\n    size: number;\n    constructor(maxSize: number) {\n        this.stack = [];\n        this.maxSize = maxSize;\n        this.size = 0;\n    }\n\n    push(x: number): void {\n        if (this.size >= this.maxSize) {\n            return;\n        }\n        this.size += 1;\n        this.stack.push(x);\n    }\n\n    pop(): number {\n        if (this.size <= 0) {\n            return -1;\n        }\n        this.size -= 1;\n        return this.stack.pop();\n    }\n\n    increment(k: number, val: number): void {\n        let i = 0;\n        let size = this.size;\n        while (i < size && i < k) {\n            this.stack[i] += val;\n            i++;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189204290","body":"## 代码\n```\nfunction decodeString(s: string): string {\n    let length: number = s.length;\n    let stack: string[] = [];\n    for(let i: number = 0; i < length; i++) {\n        let char: string = s.charAt(i);\n        if(char === ']') {\n            let str:string = '';\n            while(true) {\n                let item = stack.pop();\n                if(item === '[') {\n                    break;\n                }\n                str = item + str;\n            }\n            let numStr:string = '';\n            while(true) {\n                let item: string = stack.pop();\n                if(!/\\d+/.test(item)) {\n                    stack.push(item);\n                    break;\n                }\n                numStr = item + numStr;   \n            }\n            let count:number = parseInt(numStr, 10);\n            stack.push(str.repeat(count));    \n        }else {\n            stack.push(char);   \n        }\n    }\n    return stack.join('');  \n};\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189201773","body":"## 代码\n```\nclass MyQueue {\n    outStack: number[]\n    inStack: number[]\n    constructor() {\n        this.outStack = [];\n        this.inStack = [];\n    }\n\n    push(x: number): void {\n        this.inStack.push(x);\n    }\n\n    pop(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack.pop();\n    }\n\n    peek(): number {\n        if (this.outStack.length === 0) {\n            this.in2out();\n        }\n        return this.outStack[this.outStack.length - 1];\n    }\n\n    empty(): boolean {\n        return this.inStack.length === 0 && this.outStack.length === 0;\n    }\n\n    in2out(): void {\n        while (this.inStack.length > 0) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190436688","body":"## 代码\n```\nfunction maxChunksToSorted(arr: number[]): number {\n    let count: number = 0;\n    let sorted = [...arr];\n    sorted.sort((a, b) => {\n        return a - b;\n    });\n    const length = arr.length;\n    let sum1: number = 0;\n    let sum2: number = 0;\n    for (let i = 0; i < length; i++) {\n        sum1 += arr[i];\n        sum2 += sorted[i];\n        if (sum1 === sum2) {\n            count++;\n        }\n    }\n    return count;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qycoder":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186225472","body":"### 思路\n求\ns[i]s[i] 到其左侧最近的字符 c 的距离\ns[i]s[i] 到其右侧最近的字符 c 的距离\n两者的最小值\n### 代码\n···\nconst shortestToChar = function(s, c) {\n    const n = s.length;\n    const ans = new Array(n).fill(0);\n\n    for (let i = 0, idx = -n; i < n; ++i) {\n        if (s[i] === c) {\n            idx = i;\n        }\n        ans[i] = i - idx;\n    }\n\n    for (let i = n - 1, idx = 2 * n; i >= 0; --i) {\n        if (s[i] == c) {\n            idx = i;\n        }\n        ans[i] = Math.min(ans[i], idx - i);\n    }\n    return ans;\n};\n···\n## 复杂度分析\n时间复杂度： O(n)\n空间复杂度：O(1)\n### \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qilin88":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186383345","body":"`/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.stack = [];\r\n    this.max = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if(this.stack.length < this.max){\r\n      this.stack.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n   return this.stack.pop() ?? -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    k = this.stack.length > k ? k : this.stack.length;\r\n    for(let i = 0; i < k; i++){\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n`\r\n# 复杂度\r\n## 时间复杂度：\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(n)\r\n- 空间复杂度：O(n)\r\n- push O(1)\r\n- pop O(1)\r\n- inc O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187632034","body":"`var decodeString = function(s) {\r\n    let str = '';\r\n    let num = '';\r\n    let numStack = [];\r\n    let strStack = [];\r\n    for(let i = 0; i < s.length; i++){\r\n\r\n        let item = s[i];\r\n        if(item === '['){ \r\n            numStack.push(Number(num));\r\n            strStack.push(str);\r\n            num = '';\r\n            str = ''\r\n        } else if(!isNaN(s[i])){\r\n            num += item\r\n        }else if(item === ']'){\r\n            str = strStack.pop() + str.repeat(Number(numStack.pop()));\r\n        }else {\r\n            str += item;\r\n        }\r\n    }\r\n    return str;\r\n};`\r\n# 时间复杂度O(n)\r\n# 空间复杂度 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189791229","body":"`var MyQueue = function() {\r\n    this.stack1 = [];\r\n    this.stack2 = [];\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack1.push(x);\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    while(this.stack1.length){\r\n        this.stack2.push(this.stack1.pop());\r\n    }\r\n    const result = this.stack2.pop();\r\n    while(this.stack2.length){\r\n       this.stack1.push(this.stack2.pop()); \r\n    }\r\n    return result;\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    return this.stack1[0];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return this.stack1.length === 0 \r\n};`\r\n# 时间复杂度\r\n## 删除 O(N)  其他O(1)\r\n# 空间复杂度\r\n## O(n)\r\n","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189953070","body":"`var maxChunksToSorted = function(arr) {\r\n    let arr2 = arr.slice().sort((a, b) => a - b);\r\n    let sum1 = 0;\r\n    let sum2 = 0;\r\n    let total = 0;\r\n    for(let i = 0; i < arr.length; i++){\r\n       if(sum1 === sum2){\r\n           total++;\r\n            sum1 = 0; \r\n            sum2 = 0;\r\n       } \r\n       sum1 += arr[i];\r\n       sum2 += arr2[i];\r\n    }\r\n    return total;\r\n};`\r\n- 时间复杂度：O(n)\r\n-  空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191063019","body":"`var rotateRight = function(head, k) {\r\n    if(!head || !k){\r\n        return head;\r\n    }\r\n    let len = 1;\r\n    let cur = head;\r\n    while(cur.next){\r\n        len++;\r\n        cur = cur.next;\r\n    }\r\n    k = len - k % len;\r\n    cur = head.next;\r\n    while(k){\r\n        cur = cur.next\r\n        k--;\r\n    }\r\n    let l = cur.next;\r\n    cur.next = null;\r\n    return l;\r\n};`\r\n- 时间复杂度 O(n)\r\n-  空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengheng-yun":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186424382","body":"##### 想法\r\n1. 设计一个大小为`MaxSize`大小的栈，因为固定大小，想到了用数组表示\r\n2. 进栈，要比较当前栈是否栈满；因此，如何判断当前栈的元素个数\r\n3. 出栈，要比较当前栈是否栈空；\r\n4. 不论进栈还是出栈，都要比较当前栈顶元素的索引值，因此，可以设计一个标志位，当作实例变量。在每次进行比较时，用`++top`或者`top--`可以指向当前的栈顶。\r\n##### 代码\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1; \r\n\r\n    }    \r\n    public void push(int x) {\r\n        //判断当前栈空间的长度\r\n        if(top!=stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }    \r\n    public int pop() {\r\n        if(top != -1){\r\n            int element = stack[top];\r\n            top--;\r\n            return element;\r\n        }else return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(top<k){\r\n            for(int i=0; i<=top; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }else{\r\n            for(int i=0; i<k; i++){\r\n                stack[i]+=val;\r\n            }\r\n        }\r\n\r\n    }\r\n}\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187461656","body":"#### code\r\n```Java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n       /*\r\n       分四种情形，数字、字母\r\n       '[' 和 ']'\r\n       */\r\n\r\n       StringBuilder result = new StringBuilder();\r\n       int num = 0;    \r\n       LinkedList<Integer> multi = new LinkedList<>();\r\n       LinkedList<String> str = new LinkedList<>();\r\n\r\n       for(Character c: s.toCharArray()){\r\n\r\n           if(c>='0' && c<='9') {\r\n               num = num * 10 + Integer.parseInt(c + \"\");\r\n           }else if(c=='['){\r\n               multi.addLast(num);\r\n               str.addLast(result.toString());\r\n               num = 0;\r\n               result = new StringBuilder();\r\n           }else if(c == ']'){\r\n               StringBuilder tmp = new StringBuilder();\r\n               int curTimes = multi.removeLast();\r\n               for(int i=1; i<=curTimes; i++) tmp.append(result);\r\n\r\n               result = new StringBuilder(str.removeLast() + tmp);\r\n \r\n           }else result.append(c);\r\n\r\n       }\r\n       return result.toString();\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189091664","body":"### 想法\r\n既然规定两个栈模拟队列，把其中一个栈当作正常栈，后进先出，另一栈模拟逆栈，将正常栈的元素倒序放入逆栈中\r\n### 在写代码时遇到的bug\r\n在处理`pop()`代码时，直接让栈`s_out`直接`pop`了，没有考虑到`s_out`可能是空栈，会报空栈异常\r\n### 代码\r\n```Java\r\nclass MyQueue {\r\n    private Stack<Integer> s_in;\r\n    private Stack<Integer> s_out;\r\n    int font = 0;  //队列头元素\r\n\r\n\r\n    public MyQueue() {\r\n        s_in = new Stack<Integer>();\r\n        s_out = new Stack<Integer>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s_in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!s_in.isEmpty()){\r\n            s_out.push(s_in.pop());\r\n        }\r\n        font = s_out.pop();\r\n\r\n        return font;\r\n\r\n    }\r\n    \r\n    public int peek() {\r\n       if(s_out.isEmpty()){\r\n           while(!s_in.isEmpty()){\r\n               s_out.push(s_in.pop());\r\n           }\r\n       }\r\n       return s_out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if(s_in.isEmpty() && s_out.isEmpty()){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smz1995":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457384","body":"**思路**\r\n栈的基本操作\r\n\r\n**Python代码**\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack:\r\n            return -1\r\n        else:\r\n            return self.stack.pop()\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k,len(self.stack())):\r\n            self.stack[i]+=val\r\n        \r\n**复杂度**\r\n\r\n- 时间：O(N)\r\n\r\n- 空间：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188753934","body":"## 思路\r\n\r\n> + 两个栈一个输入一个输出\r\n\r\n##代码\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack_in=[]\r\n        self.stack_out=[]\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack_in.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.stack_out:\r\n            return self.stack_out.pop()\r\n        while self.stack_in:\r\n            temp=self.stack_in.pop()\r\n            self.stack_out.append(temp)\r\n        return self.stack_out.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        ans=self.pop()\r\n        self.stack_out.append(ans)\r\n        return ans\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack_in)==0 and len(self.stack_out)==0\r\n\r\n\r\n## 复杂度\r\n\r\n> + 时间复杂度: O(n)\r\n> + 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186457895","body":"\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) return\n    this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.stack.length) return -1\n    return this.stack.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let n = this.stack.length < k ? this.stack.length : k\n\n    for (let i = n - 1; i >= 0; i--) {\n        this.stack[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\nn为数组长度\n- 时间复杂度：Push:$O(1)$, Pop:$O(1)$, increment:$O(k)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187379263","body":"\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    let num = 0, char = '', cur = '', top \n\n    for (let i = 0; i < s.length; i++) {\n        cur = s.charAt(i)\n\n        if (typeof +cur === 'number' && !isNaN(+cur)) {\n            num = num * 10 + +cur\n        } else if (cur === '[') {\n            stack.push([num, char])\n            num = 0\n            char = ''\n        } else if (cur === ']') {\n            top = stack.pop()\n            char = top[1] + new Array(top[0]).fill(char).join('')\n        } else {\n            char += cur\n        }\n    }\n\n    return char\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189149637","body":"- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar MyQueue = function() {\n    this.a = []\n    this.b = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.a.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this.b.length) return this.b.pop()\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n    return this.b.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this.b.length) return this.b[this.b.length - 1]\n    while (this.a.length) {\n        this.b.push(this.a.pop())\n    }\n\n    return this.b[this.b.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.a.length && !this.b.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：均摊$O(1)$\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190407922","body":"单调栈\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} arr\n * @return {number}\n */\nvar maxChunksToSorted = function(arr) {\n  const stack = []\n\n  for (let i = 0; i < arr.length; i++) {\n    if (!stack.length || stack[stack.length - 1] <= arr[i]) {\n      stack.push(arr[i])\n    } else {\n      const cur = stack.pop()\n      while(stack[stack.length - 1] > arr[i]) {\n        stack.pop()\n      }\n      stack.push(cur)\n    }\n  }\n  return stack.length\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moyuanhua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475438","body":"/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.arr = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.maxSize === this.arr.length){\n        return\n    }\n    this.arr.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.arr.length === 0){\n        return -1;\n    }\n    return this.arr.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let min = Math.min(k,this.arr.length );\n    for(let i=0;i< min;i++){\n        this.arr[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186981987","body":"```javascript\nvar isNumber = function(s) {\n    return !isNaN(Number(s))\n}\n\nvar getStackStrStr = function(stack= []){\n    // return stack.join();\n    let res = '';\n    while(stack.length){\n        res+=stack.shift()\n    }\n    return res;\n}\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  \n    let resStack = []\n    for(let i=0;i<s.length;i++){\n        let char = s[i];\n        if(char === ']'){\n            // 字符出栈\n            let tempchar = resStack.pop();\n            let tempstr = '';\n            while(tempchar !== '['){\n                tempstr = tempchar + tempstr\n                tempchar = resStack.pop();\n            }\n            tempchar = resStack.pop();\n            \n            let tempNum = ''\n            while(isNumber(tempchar)){\n                tempNum = tempchar + tempNum\n                tempchar = resStack.pop()\n            }\n            resStack.push(tempchar);\n            tempNum = Number(tempNum);\n\n\n            for(let i=0;i<tempNum;i++){\n                resStack.push(tempstr)\n            }\n\n\n            \n        }else{\n            resStack.push(char)\n        }\n    }\n    return resStack.join('')\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188889674","body":"```javascript\nvar MyQueue = function() {\n    this.pushStack = []\n    this.popStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0){\n        while(this.pushStack.length){\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    const last = this.pop();\n    this.popStack.push(last)\n    return last\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191182240","body":"```JavaScript\n/**\n * Definition for singly-linked list.\n * function ListNode(val, next) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.next = (next===undefined ? null : next)\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar rotateRight = function(head, k) {\n    let n = 1;\n    if(!head || !head.next || k === 0){\n        return head\n    }\n    let rightEnd = head;\n    while(rightEnd.next){\n        rightEnd = rightEnd.next;\n        n++\n    }\n\n    let add = n - k % n;\n    if(add === n){ // \n        return head\n    }\n\n    rightEnd.next = head;\n    while(add--){\n        rightEnd = rightEnd.next;\n    }\n    head = rightEnd.next;\n    rightEnd.next = null\n    return head\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"9vivian88":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186465529","body":"class Solution:\r\n    def addToArrayForm(self, num: list, k: int) -> list:\r\n        m = len(num)\r\n        num = num[::-1]\r\n        i = 0\r\n        sum = 0\r\n        res = []\r\n        for n in num:\r\n            sum += n * 10 ** i\r\n            i += 1\r\n        ret = sum + k\r\n\r\n        while ret > 0:\r\n            yushu = ret % 10\r\n            ret //= 10\r\n            res.append(yushu)\r\n\r\n        return res[::-1]","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186466400","body":" def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        c_index = []\r\n        str_len = len(s)\r\n        for i in range(str_len):\r\n            if s[i]==c:\r\n                c_index.append(i)\r\n\r\n        answer = [0]*str_len\r\n        for j in range(str_len):\r\n            answer[j]= min([abs(j-m) for m in c_index])\r\n        return answer","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186475633","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.val = []\r\n        self.size = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.val.append(x)\r\n            self.size +=1\r\n        else:\r\n            return -1\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.size ==0:\r\n            return -1\r\n        else:\r\n            pop_val = self.val[-1]\r\n            del self.val[-1]\r\n            self.size -=1\r\n            return pop_val\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        max_inc_num = min(k,self.size)\r\n        for i in range(max_inc_num):\r\n            self.val[i] = self.val[i] + val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187614280","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188961888","body":"class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stk =[]\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stk.append(x)\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.stk is not None:\r\n            return self.stk.pop(0)\r\n\r\n\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if  self.stk is not None:\r\n            return self.stk[0]\r\n\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        if not self.stk:\r\n            return True\r\n        else:\r\n            return False\r\n复杂度\r\n时间复杂度O(1)\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190422747","body":"class Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        \r\n        stack = []\r\n        for num in arr:\r\n            if stack and num < stack[-1]: \r\n                head = stack.pop()\r\n                while stack and num < stack[-1]: stack.pop()\r\n                stack.append(head)\r\n            else: stack.append(num)\r\n        return len(stack)\r\n复杂度\r\n时间复杂度O(n)\r\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guxuehua":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186494700","body":"#### JS  \n```\n function CustomStack(maxSize) {\n    this.arr = [];\n    this.maxSize = maxSize\n  }\n  CustomStack.prototype.push = function(x) {\n    const len = this.arr.length;\n    if (len < maxSize) { \n      this.arr[len] = x;\n    }\n    return;\n  }\n  CustomStack.prototype.pop = function () {\n    const len = this.arr.length;\n    if (len > 0) {\n      return this.arr.splice(0, 1);\n    }\n    return -1;\n  }\n  CustomStack.prototype.increment = function (k, val) {\n    return this.arr.map = function(item, index) {\n      if (index < k) {\n        return item + val;\n      }\n      return item;\n    }\n  }\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187654709","body":"JS实现\r\n```\r\nfunction decodeStr (s) {\r\n  const repetStack = [];\r\n  const resStack = [];\r\n\r\n  let res = '';\r\n  let repet = 0;\r\n\r\n  for(let i = 0; i < s.length; i++) {\r\n    let cur = s.charAt(i);\r\n    if (cur === '[') {\r\n      repetStack.push(repet);\r\n      resStack.push(res);\r\n      repet = '';\r\n      res = '';\r\n    } else if (cur === ']') {\r\n      let count = repetStack.pop();\r\n      let tempStr = '';\r\n      for(let j = 0; j < count; j++) {\r\n        tempStr += res;\r\n      }\r\n      res = resStack.pop() + tempStr;\r\n    } else if (cur >= '0' && cur <= '9') {\r\n      repet = repet * 10 + (cur-'0')\r\n    } else {\r\n      res += cur;\r\n    }\r\n  }\r\n  return res;\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirosola":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186500203","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186511542","body":"# 思路:用列表模拟\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.data = []\r\n        self.maxSize=maxSize\r\n        self.size = 0\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.size<self.maxSize:\r\n            self.data.append(x)\r\n            self.size += 1\r\n\r\n    def pop(self) -> int:\r\n        if self.size == 0:\r\n            return -1\r\n        else:\r\n            ans = self.data.pop()\r\n            self.size -= 1\r\n            return ans\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if self.size < k:\r\n            for i in range(self.size):\r\n                self.data[i] += val\r\n        else:\r\n            for i in range(k):\r\n                self.data[i] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n时间复杂度：O（k）\r\n空间复杂度：O（1）","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190449428","body":"# 思路：计数排序前后的数组前i个元素，计数相同就可以分块\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        ans = 0\r\n        count_a = collections.defaultdict(int)\r\n        count_b = collections.defaultdict(int)\r\n        for a,b in zip(arr, sorted(arr)):\r\n            count_a[a] += 1\r\n            count_b[b] += 1\r\n            if count_a == count_b:\r\n                ans += 1 \r\n        return ans\r\n        \r\n```\r\n时间复杂度：O(nlogn)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maoting":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186450526","body":"### 思路：\r\n从后往前进位，将k转化成字符串，处理进位\r\n\r\n### 代码\r\n```js\r\n   var addToArrayForm = function(num, k) {\r\n    let kIndex = (k + '').length - 1;\r\n    let nIndex = num.length - 1;\r\n    // 进位\r\n    let carrayBit = 0;\r\n    for (; kIndex >= 0 && nIndex >=0 ; kIndex--, nIndex--) {\r\n        let sum = carrayBit + (+(k+'').charAt(kIndex)) + num[nIndex];\r\n        num[nIndex] = sum % 10;\r\n        carrayBit = Math.floor(sum / 10);\r\n    }\r\n    // 相同位\r\n    if (kIndex <0 && nIndex < 0) {\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // k位数多\r\n    else if (kIndex <0) {\r\n        for (; nIndex >=0 ; nIndex--) {\r\n            let sum = carrayBit + num[nIndex];\r\n            num[nIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...num] : num;\r\n    }\r\n    // num位数多\r\n    else {\r\n        let tmpArr = new Array(kIndex);\r\n        for (; kIndex >=0 ; kIndex--) {\r\n            let sum = carrayBit + (+(k+'').charAt(kIndex));\r\n            tmpArr[kIndex] = sum % 10;\r\n            carrayBit = Math.floor(sum / 10);\r\n        }\r\n        return carrayBit ? [carrayBit, ...tmpArr, ...num] : [...tmpArr, ...num];\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)\r\n\r\n### 代码优化(参考题解)：\r\n从右到左，通过不断除以10来取对应位的数字\r\n如num = [1, 2] k=999。 \r\n第一次循环：k = 999 + 2 = 1001, res[0] = k % 10 = 1\r\n第二次循环：\r\n    k = Math.floor(k / 10) = 100 \r\n    k = k + 1 = 101\r\n    res[1] = k % 10 = 1\r\n\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1186476948","body":"### 思路：\r\n对于字符串中的位置为i的字符，寻找左侧字符C和右侧字符C的位置，并保存\r\nleft = 到其左侧最近的字符 c 的距离\r\nright = 到其右侧最近的字符 c 的距离\r\n如果字符的位置 > right，left = right, 并重新寻找right\r\nres[i] = min(i - left, right - i)\r\n\r\n### 代码\r\n```js\r\n   var shortestToChar = function(s, c) {\r\n    var res = [];\r\n    // 左指针\r\n    var left = -Infinity;\r\n    // 右指针\r\n    var right = 0;\r\n    var len = s.length;\r\n    function setPointer (left, right) {\r\n        left = right < 0 ? -Infinity : right;\r\n        for (var i = right + 1; i < len; i++) {\r\n            if (s[i] === c) {\r\n                right = i;\r\n                return [left, right];\r\n            }\r\n        }\r\n        if (i === len) {\r\n            right = Infinity;\r\n        }\r\n        return [left, right];\r\n    }\r\n    [left, right] = setPointer(-Infinity, -1);\r\n            \r\n    for (var charIndex = 0; charIndex < len; charIndex++ ) {\r\n        // 维护左指针\r\n        if (charIndex > right) {\r\n            [left, right] = setPointer(left, right);\r\n        }\r\n        res[charIndex] = Math.min(charIndex-left,  right - charIndex);\r\n    }\r\n    return res;\r\n};\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(1)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186530463","body":"### 思路：\r\n    按照规则实现\r\n\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function(maxSize) {\r\n    this.stack = new Array();\r\n    this.maxSize = maxSize\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if (this.stack.length < this.maxSize) {\r\n        this.stack.push(x);\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if (this.stack.length) {\r\n        return this.stack.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * 栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    const n = Math.min(this.stack.length, k);\r\n    for (let i = n - 1; i >= 0; i--) {\r\n        this.stack[i] += val; \r\n    }\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度push和pop为O(1)，increment为O（min（k，n））\r\n* 空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1189120052","body":"### 思路：\r\n遍历数组，\r\n1. 如果是'[',直接入栈\r\n2. 如果是'数字'，将连续数字字符识别出来，统一放入栈中\r\n3. 如果是']',进行处理\r\n-  ① 连续获取字符串，直到遇到”[“\r\n- ② 取出数字\r\n- ③ 计算出字符串后再入栈\r\n4. 如果是'普通字符'，正常入栈\r\n\r\n### 代码\r\n```js\r\nvar decodeString = function(s) {\r\n    let stack = [];\r\n    let len = s.length;\r\n    let i = 0;\r\n    while(i < len) {\r\n        let char = s[i];\r\n        if (char === '[') {\r\n            stack.push('[');\r\n            i++;\r\n        }\r\n        else if (/[0-9]/.test(+s[i])) {\r\n            let strNum = s[i];\r\n            i++;\r\n            while(/[0-9]/.test(+s[i])) {\r\n                strNum += s[i];\r\n                i++;\r\n            }\r\n            stack.push(strNum)\r\n        }\r\n        else if (char === ']') {\r\n            let str = stack.pop();\r\n            let cur = stack.pop();\r\n            while(true) {\r\n                if (cur === '[') break;\r\n                str = cur + str;\r\n                cur = stack.pop();\r\n            }\r\n            \r\n            const num = +stack.pop();\r\n            const strList = Array(num).fill().map(() => str).join('');\r\n            stack.push(strList);\r\n            i++;\r\n        }\r\n        else {\r\n            stack.push(s[i]);\r\n            i++;\r\n        }\r\n        \r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189126896","body":"### 思路：\r\n两个栈\r\n\r\n```js\r\nvar MyQueue = function() {\r\n    this.stack = [];\r\n    this.size = 0;\r\n};\r\n\r\n/**\r\n * Push element x to the back of queue. \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function(x) {\r\n    this.stack.push(x);\r\n};\r\n\r\n/**\r\n * Removes the element from in front of queue and returns that element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Get the front element.\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function() {\r\n    if (this.empty()) {\r\n        return;\r\n    }\r\n    var tmpStack = [];\r\n    var stack = this.stack;\r\n    var stackLen = stack.length;\r\n    var res;\r\n    for(var i = stackLen - 1; i > 0 ; i--) {\r\n        tmpStack.push(stack.pop());\r\n    }\r\n    res = stack.pop();\r\n    stack.push(res);\r\n    for(var i = 0; i < stackLen - 1 ; i++) {\r\n        stack.push(tmpStack.pop())\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns whether the queue is empty.\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function() {\r\n    return !this.stack.length;\r\n};\r\n```\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189871624","body":"### 思路：\r\n单调栈（递增）\r\n- 当前值大于等于栈顶，可以成块\r\n- 当前值小于栈顶，去掉之前比他大的值，只保留栈顶用于成块\r\n\r\n### 代码\r\n```js\r\n// 获取栈顶元素\r\nvar stackTop = (stack) => {\r\n    return stack[stack.length - 1];\r\n}\r\nvar maxChunksToSortedError = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n\r\n        }\r\n        else {\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n// [1,1,0,0,1]\r\n\r\nvar maxChunksToSorted = function(arr) {\r\n    if (!arr.length) return 0;\r\n    let ascStack = [arr[0]];\r\n    for (let i=1; i < arr.length; i++) {\r\n        let top = stackTop(ascStack);\r\n        if (arr[i] < top) {\r\n            // 小于的时候，只保留栈顶用于成块\r\n            while(ascStack.length && stackTop(ascStack) > arr[i]) {\r\n                ascStack.pop();\r\n            }\r\n            ascStack.push(top);\r\n        }\r\n        else {\r\n            // >= 可以独立成块\r\n            ascStack.push(arr[i]);\r\n        }\r\n    }\r\n    return ascStack.length;\r\n};\r\n```\r\n\r\n### 复杂度分析\r\n* 时间复杂度O(N)\r\n* 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youzhaing":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1186703874","body":"### 题目：[989. 数组形式的整数加法](https://leetcode.cn/problems/add-to-array-form-of-integer/)\r\n### 思路：\r\n利用数组和数字的特性分别处理num和k，在循环中加判断来处理num和k长度不一的问题\r\n### python代码\r\n```python \r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        index = len(num) - 1\r\n        flag = 0\r\n        res = []\r\n        while index >= 0 or k != 0:\r\n            x = num[index] if index >= 0 else 0\r\n            y = k % 10 if k != 0 else 0\r\n            sum = x + y + flag\r\n            res.append(sum % 10)\r\n            flag = sum // 10\r\n            k = k // 10\r\n            index -= 1\r\n        if flag != 0:\r\n            res.append(flag)\r\n        return res[::-1]\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":false},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186531027","body":"### 题目：1381. 设计一个支持增量操作的栈\r\n### 思路\r\n利用数组append和pop方法\r\n### python代码\r\n``` python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) == self.maxSize:\r\n            return False\r\n        else:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack: return -1\r\n        else:\r\n            return self.stack.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(min(maxSize, k))\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186812545","body":"### 题目：[394. 字符串解码](https://leetcode.cn/problems/decode-string/)\r\n### 思路：\r\n利用栈先进后出的特性模拟括号。遍历字符串，判断每个字符类型并进行不同处理。栈主要用来纪律记录每次括号之前已经整理好的字符串以及括号中字符串的循环次数。\r\n### python代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        res, tmp, mul = '', '', 0\r\n        for i in s:\r\n            if i.isdigit(): \r\n                mul = int(i) + 10 * mul\r\n            elif i == '[': \r\n                stack.append((mul, res))\r\n                res, mul = '', 0\r\n            elif i == ']':\r\n                mul1, tmp = stack.pop()  # tmp为[之前的所有字符\r\n                res = tmp + mul1 * res\r\n            else:\r\n                res += i\r\n        return res\r\n    \r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n), e.g. '1[a1[a1[a]]]'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188613232","body":"### 题目：[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)\r\n### 思路：\r\n用两个栈模拟队列，第一个栈尾是队列的开头，所以每次执行push操作的时候需要用另一个栈记录该栈的所有元素，清空该栈之后再执行push操作。\r\n### python代码\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack1.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.stack1: return False\r\n        return self.stack1[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if not self.stack1 and not self.stack2: return True\r\n        else: return False\r\n\r\n```\r\n### 复杂度\r\n- 时间复杂度：push: O(n), pop/peek/empty: O(1)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190030476","body":"### 题目 ：[768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)\r\n### 思路：\r\n使用栈来记录每个块中最大值，需要保证栈是单调的。遍历数组arr，将每个值和栈顶的值进行比较，如果大于等于栈顶值则入栈；小于栈顶值则将取出栈顶值，直到该值大于等于栈顶值，并记录下第一个被取出的栈顶值。例如：[5,1,1,8,1,6,5,9,7,8], 栈的变化过程为：[5] -> [5,8] -> [8] -> [9], 所以最后结果为1。\r\n### python代码\r\n```python\r\nclass Solution:\r\n    def maxChunksToSorted(self, arr: List[int]) -> int:\r\n        if not arr: return False\r\n        stack = []\r\n        i = 0\r\n        while i < len(arr):\r\n            if not stack: stack.append(arr[i])\r\n            elif arr[i] >= stack[-1]:\r\n                stack.append(arr[i])\r\n            elif arr[i] < stack[-1]:\r\n                head = stack.pop()\r\n                while stack and arr[i] < stack[-1]:\r\n                    stack.pop()\r\n                stack.append(head)\r\n            i += 1\r\n        return len(stack)\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)，遍历数组\r\n- 空间复杂度：O(n)，栈所需要的空间，最差能到O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186545797","body":"### 思路\r\n用数组实现\r\n### 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let len = Math.min(k, this.stack.length)\r\n    for(let i = 0; i < len; i++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n### 复杂度分析\r\n时间复杂度：push 和 pop 操作的时间复杂度为 O(1) 而 increment 操作的时间复杂度为 O(min(k, cnt))\r\n空间复杂度：O(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187631118","body":"### 思路\r\n新增两个栈，一个存倍数，一个存待拼接的 str\r\n当 item 是数字时，求具体倍数\r\n当 item === '[' 时，numStack 入栈，strStack 入栈，并且 result、num 重置\r\n当 item === ']' 时，numStack、strStack 出栈，并将 result 重复 对应倍数\r\n### 代码\r\n```js\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = []\r\n    let strStack = []\r\n    let num = 0, result = ''\r\n    for(let i= 0; i < s.length; i++) {\r\n        const item = s[i]\r\n        if(!isNaN(item)){\r\n            num = num * 10 + parseInt(item)\r\n        } else if(item === '[') {\r\n            strStack.push(result)\r\n            result = ''\r\n            numStack.push(num)\r\n            num = 0\r\n        } else if (item === ']') {\r\n            const repeatTimes = numStack.pop()\r\n            result = strStack.pop() + result.repeat(repeatTimes)\r\n        } else {\r\n            result += item\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189147371","body":"### 思路\r\n双栈实现\r\n### 代码\r\n```js\r\nvar MyQueue = function () {\r\n  this.inStack = [];\r\n  this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function (x) {\r\n  this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function () {\r\n  if (!this.outStack.length) {\r\n    this.in2out();\r\n  }\r\n  return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function () {\r\n  return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function () {\r\n  while (this.inStack.length) {\r\n    this.outStack.push(this.inStack.pop());\r\n  }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度： O(n)\r\n空间复杂度： O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hanwangxxx":[null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/14#issuecomment-1186549520","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190747230","body":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        def calculateLen(head):\n            n=1\n            while head.next:\n                n+=1\n                head = head.next\n            return n\n\n        if k==0 or not head or not head.next:\n            return head\n\n        n = calculateLen(head)\n        k=k%n\n        fast = slow = head\n        for i in range (k):\n            fast = fast.next\n        \n        while fast.next:\n            fast = fast.next\n            slow = slow.next\n\n        fast.next = head\n        head = slow.next\n        slow.next = None\n        \n        return head\n\n        \n        \n        \n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dujt-x":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1186977163","body":"# 思路：\r\n本题中可能出现括号嵌套的情况，比如`2[a2[bc]]`，这种情况下我们可以先转化成`2[abcbc]`，在转化成 `abcbcabcbc`。我们可以把字母、数字和括号看成是独立的 TOKEN，并用栈来维护这些 TOKEN。\r\n___\r\n# 代码实现\r\nC++\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string getDigits(string &s, size_t &ptr) {\r\n        string ret = \"\";\r\n        while (isdigit(s[ptr])) {\r\n            ret.push_back(s[ptr++]);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string getString(vector <string> &v) {\r\n        string ret;\r\n        for (const auto &s: v) {\r\n            ret += s;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    string decodeString(string s) {\r\n        vector <string> stk;\r\n        size_t ptr = 0;\r\n\r\n        while (ptr < s.size()) {\r\n            char cur = s[ptr];\r\n            if (isdigit(cur)) {\r\n                // 获取一个数字并进栈\r\n                string digits = getDigits(s, ptr);\r\n                stk.push_back(digits);\r\n            } else if (isalpha(cur) || cur == '[') {\r\n                // 获取一个字母并进栈\r\n                stk.push_back(string(1, s[ptr++])); \r\n            } else {\r\n                ++ptr;\r\n                vector <string> sub;\r\n                while (stk.back() != \"[\") {\r\n                    sub.push_back(stk.back());\r\n                    stk.pop_back();\r\n                }\r\n                reverse(sub.begin(), sub.end());\r\n                // 左括号出栈\r\n                stk.pop_back();\r\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\r\n                int repTime = stoi(stk.back()); \r\n                stk.pop_back();\r\n                string t, o = getString(sub);\r\n                // 构造字符串\r\n                while (repTime--) t += o; \r\n                // 将构造好的字符串入栈\r\n                stk.push_back(t);\r\n            }\r\n        }\r\n\r\n        return getString(stk);\r\n    }\r\n};\r\n```\r\n___\r\n# 复杂度分析\r\n时间复杂度：O(n)\r\n空间复杂度：O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189234348","body":"# 思路\r\n我们使用两个栈`s1,s2` 就能实现一个队列的功能。\r\n\r\n当调用`push`让元素入队时，只要把元素压入`s1`即可：\r\n___\r\n# 代码实现\r\nC++\r\n```C++\r\nclass MyQueue {\r\nprivate:\r\n    stack<int> inStack, outStack;\r\n\r\n    void in2out() {\r\n        while (!inStack.empty()) {\r\n            outStack.push(inStack.top());\r\n            inStack.pop();\r\n        }\r\n    }\r\n\r\npublic:\r\n    MyQueue() {}\r\n\r\n    void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n\r\n    int pop() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        int x = outStack.top();\r\n        outStack.pop();\r\n        return x;\r\n    }\r\n\r\n    int peek() {\r\n        if (outStack.empty()) {\r\n            in2out();\r\n        }\r\n        return outStack.top();\r\n    }\r\n\r\n    bool empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n};\r\n```\r\n___\r\n# 复杂度分析\r\n时间复杂度：O(1)\r\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"degndaixingqiu":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187137051","body":"```class Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<int> st_num;   \r\n        string symbol;       \r\n        int num=0;           \r\n        for(int i=0;i<s.size();i++)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9'){ \r\n                num=s[i]-'0'+num*10;\r\n            }else if(s[i]=='['){       \r\n                st_num.push(num);\r\n                num=0;\r\n                symbol+=s[i];\r\n            }else if(s[i]==']'){       \r\n                int j=symbol.size()-1;\r\n                string tmp_string;\r\n                while(symbol[j]!='[')\r\n                {\r\n                    tmp_string+=symbol[j];\r\n                    symbol.pop_back();\r\n                    j--;\r\n                }\r\n                symbol.pop_back();\r\n                int tmp_num=st_num.top();\r\n                st_num.pop();\r\n                reverse(tmp_string.begin(),tmp_string.end());\r\n                for(int k=0;k<tmp_num;k++)\r\n                {\r\n                    symbol+=tmp_string;\r\n                }\r\n            }else{                     \r\n                symbol+=s[i];\r\n            }\r\n        }\r\n        return symbol;\r\n    }\r\n};\r\n\r\n\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189082702","body":"```\r\nclass MyQueue {\r\npublic:\r\n    stack<int> st, tem;\r\n    MyQueue() {\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        st.push(x);\r\n    }\r\n    void get() {\r\n        if (tem.empty()) {\r\n            while (!st.empty()) {\r\n                tem.push(st.top());\r\n                st.pop();\r\n            } \r\n        }\r\n    }\r\n    int pop() {\r\n        int t;\r\n        get();\r\n        t = tem.top();\r\n        tem.pop();    \r\n        return t;\r\n    }\r\n    \r\n    int peek() {\r\n        get();\r\n        return tem.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return tem.empty() && st.empty();\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gzgzgzgzgzgz":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187260764","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        res = \"\"\r\n        num = 0\r\n        stack = []\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append([res, num])\r\n                res = \"\"\r\n                num = 0\r\n            elif c == \"]\":\r\n                prev_res, prev_num = stack.pop()\r\n                res = prev_res + prev_num * res\r\n            else:\r\n                res += c\r\n        return res\r\n\r\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191387926","body":"```python\r\n# Definition for singly-linked list.\r\n# class ListNode:\r\n#     def __init__(self, val=0, next=None):\r\n#         self.val = val\r\n#         self.next = next\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if not head:\r\n            return head\r\n        slow, fast = head, head\r\n        count = 0\r\n        temp = head\r\n        while temp:\r\n            count += 1\r\n            temp = temp.next\r\n        k = k % count\r\n        for i in range(k):\r\n            fast = fast.next\r\n        while fast.next:\r\n            slow = slow.next\r\n            fast = fast.next\r\n        fast.next = head\r\n        temp = slow.next\r\n        slow.next = None\r\n        return temp\r\n        \r\n        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187331590","body":"## 思路\r\n\r\n                /*  思路1：利用栈的性质；先把所有字符都压入栈中，遇到\"]\"时说明找到匹配\r\n                读到]时，用一个while循环将[和]之间的字符串读出，\r\n                我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，\r\n                然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\r\n                我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，\r\n                这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，\r\n                最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\r\n    \r\n                思路1.1：就是利用栈的特性，先把所有字符都压入栈中，遇到\"]\"时说明找到匹配。\r\n                这个时候先将[]内的string存到一个地方。\r\n                在读完string后，开始读数字k，数字有可能不是1位，所以要用一个base和循环来读数字。\r\n                最后将 k * string压回栈中。继续匹配。最终栈内的字符串因为是反着的（出栈的时候顺序相反），\r\n                所以result记得反着将栈中所有字母弹出来。\r\n\r\n*/\r\n\r\n## 代码\r\n\r\n```java\r\nclass Solution {\r\n        public String decodeString(String s) {\r\n            int len=s.length();\r\n            if(len<=0) return \"\";\r\n            Stack<String> stack=new Stack<>();\r\n            for(int i=0; i<len; i++){\r\n                char mid=s.charAt(i);\r\n\r\n\r\n                //读到]时，用一个while循环将[和]之间的字符串读出，\r\n                if(mid==']'){\r\n                    StringBuilder fir=new StringBuilder();\r\n                    while(!stack.peek().equals(\"[\")){\r\n                        //fir里面存取的就是[]之间的内容\r\n                        fir.insert(0,stack.pop());\r\n                    }\r\n                    //读出后将[pop删去，\r\n                    stack.pop();\r\n\r\n                    StringBuilder num=new StringBuilder();\r\n\r\n                    /*然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\r\n                    我就直接用parseInt将字符串转化为数字了*/\r\n                    while(!stack.isEmpty()&&(stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9')){\r\n                        num.insert(0,stack.pop());\r\n                    }\r\n                    int number=Integer.parseInt(num.toString());\r\n\r\n                    //，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可\r\n                    StringBuilder sec=new StringBuilder();\r\n                    for(int j=0; j<number; j++){\r\n                        sec.append(fir);\r\n                    }\r\n                    stack.push(sec.toString());\r\n                }\r\n                //至于其他情况，直接将其转化为字符串压入栈中即可\r\n                else{\r\n                    StringBuilder sb=new StringBuilder();\r\n                    sb.insert(0,mid);\r\n                    stack.push(sb.toString());\r\n                }\r\n            }\r\n\r\n            //最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\r\n            StringBuilder res=new StringBuilder();\r\n            while(!stack.isEmpty()){\r\n                res.insert(0,stack.pop());\r\n            }\r\n            return res.toString();\r\n        }\r\n    }\r\n```\r\n\r\n## 复杂度\r\n\r\n- 时间复杂度： O(N)\r\n- 空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188500355","body":"## 思路：\r\n\r\n### \t\t两个栈， 一个输出、输入栈\r\n\r\n## 代码\r\n\r\n```java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> inputStack;\r\n    private Stack<Integer> outputStack;\r\n    public MyQueue() {\r\n        inputStack = new Stack<>();\r\n        outputStack = new Stack<>();\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        //将元素 x 推到队列的末尾\r\n        inputStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        //将输入栈的数据放入输出栈中\r\n        //然后把输出栈里面的数据，放出（移除）一个来\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        return   outputStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        //同上,但最后就不是移除，就是显示（返回队列开头的元素）\r\n\r\n        if(outputStack.isEmpty()){\r\n            while(!inputStack.isEmpty()){\r\n\r\n                outputStack.push(inputStack.pop());\r\n\r\n            }\r\n\r\n        }\r\n        // 返回队列开头的元素\r\n        return outputStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        //判断两个栈是不是都是空的\r\n        return inputStack.isEmpty()&&outputStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## 复杂度\r\n\r\n- Time O(1)\r\n- Space O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinyi-arch":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187533435","body":"思路：找到'['和']'来锁定需要循环的项，从后往前遍历\r\nCode:\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack=list()\r\n        length=len(s)\r\n        i=length-1\r\n        while i>=0:\r\n            if s[i].isdigit()==False:\r\n                stack.append(s[i])\r\n                i-=1\r\n            else:\r\n                num=''\r\n                while i>=0 and s[i].isdigit():\r\n                    num=s[i]+num\r\n                    i-=1\r\n                sub=''\r\n                while stack[-1]!=']':\r\n                    tmp=stack.pop()\r\n                    if tmp!='[':\r\n                        sub+=tmp\r\n                stack.pop()\r\n                sub=int(num)*sub\r\n                stack.append(sub)\r\n\r\n        stack.reverse()\r\n        return ''.join(stack)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190116027","body":"思路：\r\n希望排序后的数字，还在原始的位置.所以先对数组排序，当每往后循环的一个数组的原始最大坐标等于当前位置时，就可以切分。\r\nCode:\r\nclass Solution(object):\r\n    def maxChunksToSorted(self, arr):\r\n        \"\"\"\r\n        :type arr: List[int]\r\n        :rtype: int\r\n        \"\"\"\r\n        arr_list=list(enumerate(arr))\r\n        arr_list.sort(key=lambda x:x[1])\r\n        temp=[]\r\n        num=0\r\n        for i in range(len(arr_list)):\r\n            temp.append(arr_list[i][0])\r\n            if max(temp)==i:\r\n                num=num+1\r\n                temp=[]\r\n        return num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191080280","body":"思路：若K>总长度N,只要移动K//N即可。用head.next完成其余操作\r\nCode:\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        tail = head\r\n        count = 1\r\n        if not head or not head.next:\r\n            return head\r\n        while tail.next:\r\n            tail = tail.next\r\n            count += 1\r\n        if k % count == 0:\r\n            return head \r\n        tail.next = head\r\n        k %= count\r\n        for i in range(count - k):\r\n            tail = tail.next\r\n        temp = tail.next\r\n        tail.next = None\r\n        return temp","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zenwangzy":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187582912","body":"# dfs\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int u = 0;\n        return dfs(s, u);\n    }\n\n    string dfs(string& s, int& u) {\n        string res;\n        while (u < s.size() && s[u] != ']') {\n            if (s[u] >= 'a' && s[u] <= 'z') res += s[u ++];\n            else if (s[u] >= '0' && s[u] <= '9') {\n                int k = u;\n                while (s[k] >= '0' && s[k] <= '9') k ++;\n                int t = stoi(s.substr(u, k - u));\n                u = k + 1;\n                string sa = dfs(s, u);\n                u ++;\n                while (t --) res += sa;\n            }\n        }\n        return res;\n    }\n};// O(n) O(n)\n```\n# stack\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n      if (s.empty()) {\n        return s;\n      }\n      \n      std::string k;    // num\n      std::string str;  // result\n      std::stack<int> countStack;\n      std::stack<std::string> stringStack;\n      \n      for (auto& ch: s) {\n        if (isdigit(ch)) {\n          k += ch;\n        } else if (ch == '[') {\n          countStack.push(std::stoi(k));\n          stringStack.push(str);\n          k = \"\";\n          str = \"\";\n        } else if (isalpha(ch)) {\n          str += ch;\n\n        } else if (ch == ']') {\n          // get previously decoded, such as in 3[a]2[bc]\n          // second '[' push 'aaa' to stack, get them now\n          std::string decodedString = stringStack.top();\n          stringStack.pop();\n          \n          // str is not pushed to stack yet, but times is already pushed \n          // add the decoded sting and repeated str\n          for (int i = 0; i < countStack.top(); i++) {\n            decodedString += str;\n          }\n          countStack.pop();\n          \n          // remember the local variable\n          str = decodedString;\n        }\n      }\n      \n      return str;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189145882","body":"# idea\n使用两个横向摆放相对开口的栈模拟队列，右边栈储存元素，左边栈弹出元素。 \n如果需要访问队头元素， 就把所有instack 元素一把撸过来到outstack pop 也是同理 其它简单\n注意pop时候临时储存top以后再return\n```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack,outStack;\n\n    void in2out() {\n    while (!inStack.empty()) {\n        outStack.push(inStack.top());\n        inStack.pop();\n    }\n}    \npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        inStack.push(x);\n\n    }\n    \n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();//注意此处不能直接返回 你需要一个局部变量暂存 \n        outStack.pop();\n        return x;\n\n    }\n    \n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n        \n\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"andyyxw":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187629977","body":"Code:\r\n```ts\r\nfunction decodeString(s: string): string {\r\n  const stack = []\r\n  let ret = ''\r\n  let count = 0\r\n  for (const c of s) {\r\n    if (c >= '0' && c <= '9') {\r\n      count = count * 10 + +c\r\n      continue\r\n    } else if (c === '[') {\r\n      stack.push({ count, lastRet: ret })\r\n      count = 0\r\n      ret = ''\r\n      continue\r\n    } else if (c === ']') {\r\n      const { count, lastRet } = stack.pop()\r\n      ret = lastRet + ret.repeat(count)\r\n      continue\r\n    }\r\n    ret += c\r\n  }\r\n  return ret\r\n};\r\n```\r\nComplexity:\r\n- Time complexity: O(n)\r\n- Space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189170203","body":"Code:\r\n```ts\r\nclass MyQueue {\r\n  pushStack: number[]\r\n  popStack: number[]\r\n\r\n  constructor() {\r\n    this.pushStack = []\r\n    this.popStack = []\r\n  }\r\n\r\n  transfer(): void {\r\n    if (this.popStack.length) return\r\n    while (this.pushStack.length) this.popStack.push(this.pushStack.pop())\r\n  }\r\n\r\n  push(x: number): void {\r\n    this.pushStack.push(x)\r\n  }\r\n\r\n  pop(): number {\r\n    this.transfer()\r\n    return this.popStack.pop()\r\n  }\r\n\r\n  peek(): number {\r\n    this.transfer()\r\n    return _.last(this.popStack)\r\n  }\r\n\r\n  empty(): boolean {\r\n    return !(this.pushStack.length || this.popStack.length)\r\n  }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190461387","body":"Code:\r\n```ts\r\n/** Algorithm: Sliding Window */\r\nfunction maxChunksToSorted(arr: number[]): number {\r\n  const sortedArr = [...arr].sort((a, b) => a - b)\r\n  let ret = 0\r\n  let sum1 = 0\r\n  let sum2 = 0\r\n\r\n  for (let i = 0; i < arr.length; i++) {\r\n    sum1 += arr[i]\r\n    sum2 += sortedArr[i]\r\n    if (sum1 === sum2) ret++\r\n  }\r\n\r\n  return ret\r\n}\r\n```\r\nTime Complexity: O(NlogN)\r\nTime Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190567251","body":"```ts\r\n/**\r\n * Algorithm: Fast and Slow Pointer\r\n * Time Complexity: O(N)\r\n * Space Complexity: O(1)\r\n */\r\nfunction rotateRight(head: ListNode | null, k: number): ListNode | null {\r\n  if (!head || k === 0) return head\r\n  // get effective rotate times\r\n  let cur = head, length = 1\r\n  while (cur.next && ++length) cur = cur.next\r\n  k %= length\r\n  if (k === 0) return head\r\n\r\n  let slow = head, fast = head\r\n  while (k-- > 0) fast = fast.next\r\n  while (fast.next) { slow = slow.next; fast = fast.next }\r\n  const ret = slow.next\r\n  slow.next = null\r\n  fast.next = head\r\n  return ret\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fourierhai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671196","body":"``` java\r\n\r\npublic String decodeString(String s) {\r\n        StringBuilder currStr = new StringBuilder();\r\n        int currNum = 0;\r\n        Stack<Integer> numsStack = new Stack<>();\r\n        Stack<StringBuilder> strsStack = new Stack<>();\r\n\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                numsStack.push(currNum);\r\n                strsStack.push(currStr);\r\n                //重新开始统计\r\n                currNum = 0;\r\n                currStr = new StringBuilder();\r\n            } else if (c == ']') {\r\n                //遇到] ，栈里面的数字和字符串都出栈，并且与括号内的字符串进行拼接\r\n                int prenum = numsStack.pop();\r\n                StringBuilder prestr = strsStack.pop();\r\n                //拼接字符串，可能需要进行多次拼接\r\n                for (int i = 0; i < prenum; i++) {\r\n                    prestr.append(currStr);\r\n                }\r\n                currStr = prestr;\r\n            } else if (c >= '0' && c <= '9') {\r\n                //遇到了数字，那么拼接数字，有可能不止个位数\r\n                currNum = currNum * 10 + Integer.parseInt(String.valueOf(c));\r\n            } else {\r\n                //其他，当作普通字符拼接，作为当前字符串\r\n                currStr.append(c);\r\n            }\r\n        }\r\n        return currStr.toString();\r\n    }\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189049685","body":"``` java\nclass MyQueue {\n\n    public Stack<Integer> stackPush;\n    public Stack<Integer> stackPop;\n\n    public MyQueue() {\n        this.stackPush = new Stack<Integer>();\n        this.stackPop = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        stackPush.push(x);\n    }\n    \n    public int pop() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.pop();\n    }\n    \n    public int peek() {\n        if (stackPop.isEmpty() && stackPush.isEmpty()) {\n            throw new RuntimeException(\"Queue is empty\");\n        }\n        if (stackPop.isEmpty()) {\n            while (!stackPush.isEmpty()) {\n                stackPop.push(stackPush.pop());\n            }\n        }\n        return stackPop.peek();\n    }\n    \n    public boolean empty() {\n        return stackPush.isEmpty() && stackPop.isEmpty();\n    }\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190462192","body":"```java\n//先打卡\npublic int maxChunksToSorted(int[] arr) {\n        LinkedList<Integer> stack = new LinkedList<Integer>();\n\n        for (int num : arr) {\n            if (!stack.isEmpty() && num < stack.getLast()) {\n                // 我们需要将融合后的区块的最大值重新放回栈\n                // 而 stack 是递增的，因此 stack[-1] 是最大的\n                int cur = stack.removeLast();\n                // 维持栈的单调递增\n                while (!stack.isEmpty() && num < stack.getLast()) {\n                    stack.removeLast();\n                }\n                stack.addLast(cur);\n            } else {\n                stack.addLast(num);\n            }\n        }\n        // 栈存的是块信息，因此栈的大小就是块的数量\n        return stack.size();\n    }\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangz001":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1187671250","body":"# 思路\r\n\r\n栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stk_multi = new LinkedList<>();\r\n        LinkedList<String> stk_res = new LinkedList<>();\r\n        for (char c : s.toCharArray()) {\r\n            if (c == '[') {\r\n                stk_multi.addLast(multi);\r\n                stk_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if (c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stk_multi.removeLast();\r\n                for (int i = 0; i < cur_multi; i++) {\r\n                    tmp.append(res);\r\n                }\r\n                res = new StringBuilder(stk_res.removeLast() + tmp);\r\n            }\r\n            else  if (c >= '0' && c <= '9') {\r\n                multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            }\r\n            else {\r\n                res.append(c);\r\n            }\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度：O(N)\r\n\r\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188609109","body":"# 思路\n\n- 实现栈：使用SLL\n  \n- 2个栈实现队列\n  \n\n# 代码\n\n```java\nclass MyQueue {\n    private class Stack {\n        private class ListNode {\n            int val;\n            ListNode next;\n            public ListNode(int val, ListNode next) {\n                this.val = val;\n                this.next = next;\n            }\n            \n            public ListNode(int val) {\n                this(val, null);\n            }\n        }\n        // Use SLL as a stack\n        \n        ListNode head;\n        \n        public Stack() {\n            head = new ListNode(0);\n        }\n        \n        public boolean isEmpty() {\n            return head.next == null;\n        }\n        \n        public int pop() {\n            int val = head.next.val;\n            head.next = head.next.next;\n            return val;\n        }\n        \n        public void push(int x) {\n            ListNode p = new ListNode(x, head.next);\n            head.next = p;\n        }\n        public int peek() {\n            return head.next.val;\n        }\n    }\n    \n    Stack in;\n    Stack out;\n    public MyQueue() {\n        in = new Stack();\n        out = new Stack();\n    }\n    \n    public void push(int x) {\n        in.push(x);\n    }\n    \n    public int pop() {\n        peek();\n        return out.pop();\n    }\n    \n    public int peek() {\n        if (out.isEmpty()) {\n            while (!in.isEmpty()) {\n                out.push(in.pop());\n            }\n        }\n        return out.peek();\n    }\n    \n    public boolean empty() {\n        return in.isEmpty() && out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n# 复杂度分析\n\n时间复杂度：\n\n- 入栈：O(1)\n  \n- 出栈：O(1)\n  \n\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1187984710","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []    \n        self.op = []\n    def push(self, x: int) -> None:\n        self.input.append(x)\n\n    def pop(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op.pop()    \n        \n    def peek(self) -> int:\n        if not self.op:\n            while self.input:\n                self.op.append(self.input.pop())\n        return self.op[-1] \n\n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.op) == 0\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190968022","body":"```python\nclass Solution:\n    def rotateRight(self, head: 'ListNode', k: 'int') -> 'ListNode':\n       \n        if not head:\n            return None\n        if not head.next:\n            return head\n        \n       \n        old_tail = head\n        n = 1\n        while old_tail.next:\n            old_tail = old_tail.next\n            n += 1\n        old_tail.next = head\n        \n        \n        new_tail = head\n        for i in range(n - k % n - 1):\n            new_tail = new_tail.next\n        new_head = new_tail.next\n        \n \n        new_tail.next = None\n        \n        return new_head\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"haoyangxie":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188387205","body":"# Idea \r\n用stack1来存储新加的元素，要使用pop或者peek时，将stack1的元素全部pop出来添加到stack2，此时stcak2的顺序就是先进先出(queue)\r\n\r\n```\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n\r\n    public MyQueue() {\r\n        stack1 = new Stack<>();\r\n        stack2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (stack2.isEmpty()) {\r\n            while (!stack1.isEmpty()) {\r\n                stack2.push(stack1.pop());\r\n            }\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack1.isEmpty() && stack2.isEmpty();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间：O(n)\r\n空间：O(n)\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189384265","body":"# Idea\r\n使用单调栈，遇到大于等于栈顶元素直接加入栈，如果当前元素小于栈顶，先将现在的栈顶取出，确保栈内没有大于该元素的元素最后将原先的栈顶加入。栈中元素个数就是最多块的个数。\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        Stack<Integer> stack = new Stack<>();\r\n        stack.push(arr[0]);\r\n        for (int i = 1; i < arr.length; i++) {\r\n            if (!stack.isEmpty() && arr[i] >= stack.peek()) {\r\n                stack.push(arr[i]);\r\n            } else {\r\n                int curMax = stack.pop();\r\n                while (!stack.isEmpty() && stack.peek() > arr[i]) {\r\n                    stack.pop();\r\n                }\r\n                stack.push(curMax);\r\n            }\r\n        }\r\n        return stack.size();\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace:  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190553938","body":"# Idea\r\n先确定链表的长度，遍历链表找到起始位置的前一个node，使node.next = null，最后将链表结尾与头部相连。\r\n\r\n# Code\r\n\r\n```\r\nclass Solution {\r\n    public ListNode rotateRight(ListNode head, int k) {\r\n        if(head == null || head.next == null) return head;\r\n        \r\n        ListNode dummy = head;\r\n        int length = 1;\r\n        while (dummy.next != null) {\r\n            length ++;\r\n            dummy = dummy.next; // dummy现在指到最后一个node\r\n        } //确定链表长度\r\n        \r\n        int pos = k % length;\r\n        length = length - pos;\r\n        ListNode cur = head;\r\n        \r\n        while (length > 1) {\r\n            length --;\r\n            cur = cur.next;\r\n        }\r\n        \r\n        dummy.next = head;\r\n        head = cur.next;\r\n        cur.next = null;\r\n        return head;\r\n    }\r\n}\r\n```\r\n\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chjillout":[null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/8#issuecomment-1188502616","body":"   ```\n public int[] shortestToChar(String S, char C) {\n        int n = S.length(), pos = -n, res[] = new int[n];\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = pos - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], pos - i);\n        }\n        return res;\n    } \n```\n\nComplexity O(n)","onTime":false},null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188497313","body":"class MyQueue {\n\n    Stack<Integer> input = new Stack();\n    Stack<Integer> output = new Stack();\n    \n    public void push(int x) {\n        input.push(x);\n    }\n\n    public void pop() {\n        peek();\n        output.pop();\n    }\n\n    public int peek() {\n        if (output.empty())\n            while (!input.empty())\n                output.push(input.pop());\n        return output.peek();\n    }\n\n    public boolean empty() {\n        return input.empty() && output.empty();\n    }\n}\n\n#### Complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188506954","body":"\n# 思路：\n put 1 2 3, get 1\n\n method1: 9:36 - 42 = 6min\n\n stack [\n sec_stack [3 2 \n put it back to stack1.\n\n time: O(n); space O(n)\n\n\nmethod2:  43 - 45 = 2min\n push: all ele to stack2, append. put it back to stack1.\nstack [3 2 1\nsec_stack [\n\n\n选method1 or method2， 看哪种操作更频繁。 插入频繁 （m1） or 查找（m2）。\n```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop() )\n        num = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append( self.stack2.pop() )\n        return num\n\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190767492","body":"\n# thought\n4:41 - 59 = 20min\n\n法1:m = k mod len(linkedlist) find last m - 1, m-1 point to None, make m point to head\n法2改进：既然都算出链表长度了就不要找倒数的节点了，直接知道是第几个节点了：\n len = 5 k=2 m = 2 断点：len-m-1=2\n len = 3 k=4 m =1 断点：len-m-1=\n\n\n # complexity\nO(n) space O(1)\n\n# code\n```      \n# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        pointer = head\n        length = 1\n        while pointer and pointer.next: # pointer point to last node\n            pointer = pointer.next\n            length += 1\n        if length == 0:\n            return head\n        m = k % length \n\n        if m == 0:\n            return head\n        # fa2：断点：len-m-1=2\n        slow = head\n        for i in range(length - m - 1):\n            slow = slow.next\n        last = slow\n        next_ll = slow.next\n        slow.next = None\n        #pointer is last node\n        pointer.next = head\n        return next_ll\n\n        \n        # fa1 : 找倒数m-1 node\n        # slow, fast = head, head\n        # pre = ListNode(-1)\n        # for i in range(m + 1):\n        #     pre = fast\n        #     fast = fast.next\n        # while fast:\n        #     pre = fast\n        #     slow = slow.next\n        #     fast = fast.next \n        # next_ll = slow.next\n        # slow.next = None \n        # pre.next = head\n        # return next_ll\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mhcn":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188512612","body":"### idea\r\n一共4种情况：字符、数字、[,]\r\n出现多位数字字符，将其转化为一个数\r\n然后利用辅助栈从内到外展开\r\n### code\r\n```java\r\n    public String decodeString(String s){\r\n        LinkedList<String> strStack = new LinkedList<>();\r\n        LinkedList<Integer> numStack = new LinkedList<>();\r\n\r\n         int times = 0;\r\n        StringBuilder sb = new StringBuilder();\r\n\r\n        final char[] chars = s.toCharArray();\r\n        for (int i=0; i< chars.length; i++){\r\n            if (Character.isLetter(chars[i])){\r\n                sb.append(chars[i]);\r\n            }else if (Character.isDigit(chars[i])){\r\n                times = times * 10 + chars[i] - '0';\r\n            }else if (chars[i] == '['){\r\n                numStack.addLast(times);\r\n                strStack.addLast(sb.toString());\r\n                times = 0;\r\n                sb = new StringBuilder();\r\n            }else if (chars[i] == ']'){\r\n                 StringBuilder temp = new StringBuilder();\r\n                 Integer multi = numStack.removeLast();\r\n                for (int j=0; j< multi; j++){\r\n                     temp.append(sb);\r\n                 }\r\n                sb = new StringBuilder(strStack.removeLast() + temp);\r\n            }\r\n\r\n        }\r\n        return sb.toString();\r\n    }\r\n```\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coconutice":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188517276","body":"## 思路\r\n一个stack用于入栈\r\n另外一个用于出栈\r\n\r\n## 代码\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.ins = []\r\n        self.outs = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.ins.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.outs:\r\n            while self.ins:\r\n                self.outs.append(self.ins.pop())\r\n        return self.outs[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        if self.outs or self.ins:\r\n            return False\r\n        else:\r\n            return True\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190997715","body":"\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        l = []\r\n        t = ListNode(0, head)\r\n        p = head\r\n        while p:\r\n            l.append(p.val)\r\n            p = p.next\r\n        if not l:\r\n            return head\r\n        stop = len(l) -  k % len(l)\r\n        if stop == len(l):\r\n            return head\r\n        count = 0\r\n        p = head\r\n        while count < stop -  1 and p:\r\n        \r\n            p = p.next\r\n            count += 1    \r\n        temp1 = p\r\n        while p and p.next:\r\n            p = p.next       \r\n        t.next = temp1.next\r\n        p.next = head\r\n        temp1.next = None\r\n        return t.next\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackgaoyuan":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188540304","body":"type MyQueue struct {\r\n\tinStack, outStack []int\r\n}\r\n\r\nfunc Constructor() MyQueue {\r\n\treturn MyQueue{}\r\n}\r\n\r\nfunc (this *MyQueue) Push(x int) {\r\n\tthis.inStack = append(this.inStack, x)\r\n}\r\n\r\nfunc (this *MyQueue) in2Out() {\r\n\t//将入栈的元素倒进出栈\r\n\tfor i := len(this.inStack) - 1; i >= 0; i-- {\r\n\t\tthis.outStack = append(this.outStack, this.inStack[i])\r\n\t}\r\n    this.inStack = nil\r\n}\r\n\r\n//从队列的开头移除并返回元素\r\nfunc (this *MyQueue) Pop() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n    //获取栈头元素（切片最后的元素）\r\n\tres := this.outStack[len(this.outStack)-1]\r\n    //移除栈头元素\r\n\tthis.outStack = this.outStack[:len(this.outStack) - 1]\r\n\treturn res\r\n}\r\n\r\n// 返回队列开头的元素\r\nfunc (this *MyQueue) Peek() int {\r\n\tif len(this.outStack) == 0 {\r\n\t\tthis.in2Out()\r\n\t}\r\n\treturn this.outStack[len(this.outStack)-1]\r\n}\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n\treturn len(this.inStack) == 0 && len(this.outStack) == 0\r\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190041412","body":"func maxChunksToSorted(arr []int) int {\r\n    // 排序后，对两个数组进行diff，偏移量为0时，表示可以分块\r\n\tb := append([]int{}, arr...)\r\n\tsort.Ints(b)\r\n\r\n\tret := 0\r\n\tdiff := 0\r\n\tm := map[int]int{}\r\n\tfor i := 0; i < len(arr); i++ {\r\n\t\tm[b[i]]++\r\n\t\tif m[b[i]] > 0 { //该数拉开了两个数组的差距，正向偏移（偏向b数组）\r\n\t\t\tdiff++\r\n\t\t} else { // 抵消了arr数组的偏移\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tm[arr[i]]--\r\n\t\tif m[arr[i]] < 0 { //该数拉开了两个数组的差距，负向偏移（偏向arr数组）\r\n\t\t\tdiff++\r\n\t\t} else { // 抵消了b数组的偏移\r\n\t\t\tdiff--\r\n\t\t}\r\n\r\n\t\tif diff == 0 {\r\n\t\t\tret++\r\n\t\t}\r\n\t}\r\n\treturn ret\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188696765","body":"# ****【Day 5】232. 用栈实现队列****\n\n## 思路：\n\n1. 由于Js里没有stack 类型，先构建一个包含必要功能的stack类\n2. 用两个stack来模拟先进先出\n3. 这里选择在push时维护第一个stack，利用第二个stack来reverse里面的元素顺序，于是pop和peek时取的是最先存放的元素\n\n## 代码\n\n```jsx\nclass Stack {\n    constructor() {\n        this.stack = [];\n    }    \n    \n    push = (x) => {\n        this.stack.push(x);\n    }\n    \n    pop = () => {\n        return this.stack.pop();\n    }\n    \n    size = () => {\n        return this.stack.length;\n    }\n    \n    peek = () => {\n        return this.stack[this.stack.length - 1];\n    }\n}\n\nclass MyQueue {\n    constructor() {\n        this.stack1 = new Stack();\n        this.stack2 = new Stack();    \n    }\n    \n    push = (x) => {\n        while (this.stack1.size() > 0) {\n            const item = this.stack1.pop();\n            this.stack2.push(item);\n        }\n\n        this.stack2.push(x);\n\n        while (this.stack2.size() > 0) {\n            const item = this.stack2.pop();\n            this.stack1.push(item);\n        }\n    }\n    \n    peek = () => {\n        return this.stack1.peek();   \n    }\n    \n    pop = () => {\n        return this.stack1.pop();\n    }\n    \n    empty = () => {\n        return this.stack1.size() === 0;\n    }\n}\n```\n\n## 复杂度分析\n\nTime Complexity: O(n) when pushing, O(1) when others\n\nSpace Complexity: O(n) when pushing, O(1) when others","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufeng727":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1188920030","body":"var MyQueue = function() {\n  this.is = [];\n  this.os = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.is.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (!this.os.length) {\n    while (this.is.length) {\n      this.os.push(this.is.pop());\n    }\n  }\n  return this.os[this.os.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return !this.is.length && !this.os.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fontendart":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189039042","body":"保打卡\n```javascript\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function () {\n    this.stack1 = []\n    this.stack2 = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n    let stack = this.stack1.length? this.stack1: this.stack2\n    stack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n    let res = stack2.pop()\n\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n\n    return res\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n    let stack1, stack2, value;\n    if (this.stack1.length) {\n        stack1 = this.stack1\n        stack2 = this.stack2\n    } else {\n        stack1 = this.stack2\n        stack2 = this.stack1\n    }\n    while (value = stack1.pop()) {\n        stack2.push(value)\n    }\n\n    let res = stack2.pop()\n    stack1.push(res);\n    while (value = stack2.pop()) {\n        stack1.push(value)\n    }\n    return res;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n    // console.log(this.stack1, this.stack2)\n    return !this.stack1.length && !this.stack2.length\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingchehu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189180981","body":"### 思路\r\n* 一個 stack 裝反序的數字 (最新的在最上層)，在 push 時使用另一個 help_stack 來保持 stack 裡的數字為反序\r\n* pop 跟 peek 則取最上層的數字\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack = []\r\n        self.help_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        # 先將 stack 內的都數字搬到 help_stack\r\n        while len(self.stack) > 0:\r\n            num = self.stack.pop()\r\n            self.help_stack.append(num)\r\n        # 將新數字放入 stack\r\n        self.stack.append(x)\r\n        # 接著把數字從 help_stack 搬回 stack\r\n        while len(self.help_stack) > 0:\r\n            num = self.help_stack.pop()\r\n            self.stack.append(num)\r\n\r\n    def pop(self) -> int:\r\n        return self.stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        return self.stack[-1]\r\n        \r\n\r\n    def empty(self) -> bool:\r\n        return len(self.stack) == 0\r\n```\r\n\r\nTime Complexity: O(N)\r\nSpace Complexity: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190380648","body":"```python\n# 將 sub array 與 sub sorted array 比對數字出現的次數\n# 次數都相同就代表 sub array 可以排序成 sub sorted array，也就代表可以分成一個 chunk\n\nclass Solution:\n    def maxChunksToSorted(self, arr: List[int]) -> int:\n        arr_counter = collections.defaultdict(int)\n        sorted_arr_counter = collections.defaultdict(int)\n        ans = 0\n        \n        sorted_arr = sorted(arr)\n        \n        for i in range(len(arr)):\n            arr_counter[arr[i]] += 1\n            sorted_arr_counter[sorted_arr[i]] += 1\n            if arr_counter == sorted_arr_counter:\n                ans += 1\n        return ans\n\n# Time: O(N^2) 迴圈裡加上 dict 比對\n# Space: O(N) 開了兩個 dict \n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cobayaz":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189171833","body":"func addToArrayForm(A []int, K int) (ans []int) {\n    for i := len(A) - 1; i >= 0; i-- {\n        //从后往前加 每次加一个  比如 K=806\n        sum := A[i] + K%10    //A[i] = 1   1 + 6\n        K /= 10\n        if sum >= 10 {\n            K++ //K往前进一位\n            sum -= 10  //sum 只留下个位数\n        }\n        ans = append(ans, sum) //添加0到数组首部\n    }\n\n\n//如果进位的是最后几位 循环添加\n    for ; K > 0; K /= 10 {\n        ans = append(ans, K%10)\n    }\n    //反转数组\n    reverse(ans)\n    return\n}\n\nfunc reverse(A []int) {\n    for i, n := 0, len(A); i < n/2; i++ {\n        A[i], A[n-1-i] = A[n-1-i], A[i]\n    }\n}\n","onTime":false},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189195841","body":"### 栈\n\n\n```go\n\ntype MyQueue struct {\n\tinstack []int \n\toutstack []int \n}\n\n\nfunc NewQueue() MyQueue {\n\treturn MyQueue{\n\t\tinstack: make([]int, 0),\n\t\toutstack: make([]int, 0),\n\t}\n}\n\n// push 压栈\nfunc (this *MyQueue) Push(x int)  {\n\tthis.instack = append(this.instack, x)\n}\n\n// 出栈\nfunc (this *MyQueue) in2out()  {\n\t// 当outstack空时，需要将instack全部转入outstack\n\tfor len(this.instack) > 0 {\n\t\tthis.outstack = append(this.outstack, this.instack[len(this.instack)-1])\n\t\tthis.instack = this.instack[:len(this.instack)-1]\n\t}\n}\n\n// pop\nfunc (this *MyQueue) Pop() int {\n\t// pop时需要先判断outstack是否为空\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\t// pop时出栈top, 然后更新outstack\n\tval := this.outstack[len(this.outstack)-1]\n\tthis.outstack = this.outstack[:len(this.outstack)-1]\n\treturn val\n}\n\n// peek\nfunc (this *MyQueue) Peek() int {\n\t// 因为outstack才是出栈功能部分，需要先判断是否为空\n\tif len(this.outstack) == 0 {\n\t\tthis.in2out()\n\t}\n\treturn this.outstack[len(this.outstack)-1]\n}\n\n// empty\nfunc (this *MyQueue) Empty() bool {\n\t// 仅当入栈和出栈都为空时，queue才为空\n\treturn len(this.outstack) == 0 && len(this.instack) == 0\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomato-tomato":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/17#issuecomment-1189231157","body":"```js\nvar MyQueue = function() {\n    this.mainStack = [];\n    this.tempStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.mainStack.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    while(this.mainStack.length > 1) {\n        this.tempStack.push(this.mainStack.pop());\n    }\n    const res = this.mainStack.pop();\n    while(this.tempStack.length) {\n        this.mainStack.push(this.tempStack.pop());\n    }\n\n    return res;\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.mainStack[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.mainStack.length;\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xfliudx":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/16#issuecomment-1188827861","body":"- Language: JAVA\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if(s == null || s.length() == 0){\r\n            return s;\r\n        }\r\n\r\n        int len = s.length();\r\n        Stack<Character> stack = new Stack<>();\r\n        for(int i = 0; i < len; i++){\r\n            char c = s.charAt(i);\r\n            if(c != ']'){\r\n                stack.push(c);\r\n            } else {\r\n                char sc = ' ';\r\n                StringBuffer sb = new StringBuffer();\r\n                while(!stack.isEmpty()){\r\n                    sc = stack.pop();\r\n                    if(sc != '['){\r\n                        sb.append(sc);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                int num = 0;\r\n                int idx = 0;\r\n                while(!stack.isEmpty()){\r\n                    char n = stack.peek();\r\n                    if(n >= '0' && n <= '9'){\r\n                        int tmp = 1;\r\n                        for(int m = 0; m < idx; m++){\r\n                            tmp *= 10;\r\n                        }\r\n                        num += tmp * (n - '0');\r\n                        idx++;\r\n                        stack.pop();\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                String pattern = sb.reverse().toString();\r\n                sb.setLength(0);\r\n\r\n                for(int j = 0; j < num; j++){\r\n                    sb.append(pattern);\r\n                }\r\n\r\n                for(int k = 0; k < sb.length(); k++){\r\n                    stack.push(sb.charAt(k));\r\n                }\r\n            }\r\n        }\r\n\r\n        StringBuffer res = new StringBuffer(stack.size());\r\n        while(!stack.isEmpty()){\r\n            res.append(stack.pop());\r\n        }\r\n\r\n        return res.reverse().toString();\r\n    }\r\n}\r\n```\r\n\r\nTime Complexity: O(n)\r\nSpace Complexity: O(n);","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"djd28176":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189702954","body":"```java\nclass Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int res = 0;\n        int[] sorted = arr.clone();\n        Arrays.sort(sorted);\n        int diff = 0;\n        for (int i = 0; i < arr.length; i++){\n            diff += arr[i] - sorted[i];\n            if (diff == 0){\n                res ++;\n            }\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190982420","body":"```java\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if(head == null) return null;\n        int n = 1;\n        ListNode tail = head;\n        while(tail.next != null){\n            n++;\n            tail = tail.next;\n        }\n        tail.next = head;\n        \n        ListNode newTail = head;\n\n        for(int i = 0; i < n-k%n- 1; i++){\n            newTail = newTail.next;\n        }\n        ListNode newHead = newTail.next;\n        newTail.next = null;\n        \n        return newHead;\n        \n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xilutian":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189754021","body":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        stack<int>maxStk;\n        maxStk.push(arr[0]);\n        for(int i=1;i<arr.size();i++){\n            if(arr[i]<maxStk.top()){\n                int maxNum=maxStk.top();\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\n                maxStk.push(maxNum);\n            }\n            else maxStk.push(arr[i]);\n        }\n        return maxStk.size();\n\n\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191159350","body":"```\r\nif (k == 0 || head == nullptr || head->next == nullptr) {\r\nreturn head;\r\n}\r\nint n = 1;\r\nListNode* iter = head;\r\nwhile (iter->next != nullptr) {\r\niter = iter->next;\r\nn++;\r\n}\r\nint add = n - k % n;\r\nif (add == n) {\r\nreturn head;\r\n}\r\niter->next = head;\r\nwhile (add--) {\r\niter = iter->next;\r\n}\r\nListNode* ret = iter->next;\r\niter->next = nullptr;\r\nreturn ret;\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189833390","body":"### 思路\r\n滑动窗口\r\n### js代码\r\n```JavaScript\r\nvar maxChunksToSorted = function (arr) {\r\n    const sorted = [...arr];\r\n    sorted.sort((a, b) => a - b);\r\n\r\n    let count = 0,\r\n        sum1 = 0,\r\n        sum2 = 0;\r\n\r\n    for (let i = 0; i < arr.length; i++) {\r\n        sum1 += arr[i];\r\n        sum2 += sorted[i];\r\n\r\n        if (sum1 === sum2) {\r\n            count++;\r\n            sum1 = sum2 = 0; \r\n        }\r\n    }\r\n\r\n    return count;\r\n};\r\n\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度: O(nlogn)\r\n- 空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189849757","body":"### Implementation\n```c++\nclass Solution\n{\npublic:\n  int maxChunksToSorted(vector<int>& arr)\n  {\n    std::stack<int> s;\n    for (auto const& ele : arr) {\n      if (s.empty() || s.top() <= ele) {\n        s.push(ele);\n      } else {\n        int chunkLeader = s.top();\n        s.pop();\n        while (!s.empty() && s.top() > ele) {\n          s.pop();\n        }\n        // Now the leader of the chunk is back to the stack\n        s.push(chunkLeader);\n      }\n    }\n    return s.size();\n  }\n};\n```\n### Complexity\n- Time complexity: O(n) \n- Space complexity: O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shunanch":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189964725","body":"参考题解，使用辅助栈\r\n\r\n```cpp\r\n#include<bits/stdc++.h>\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        vector<int> stack;\r\n        for(int num : arr) {\r\n            if(!stack.empty() && num < *stack.rbegin()) {\r\n                int head = *stack.rbegin();\r\n                stack.pop_back();\r\n                while(!stack.empty() && num < *stack.rbegin())\r\n                 stack.pop_back();\r\n                stack.push_back(head);\r\n            }\r\n            else stack.push_back(num);\r\n        }\r\n        return stack.size();\r\n    }\r\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yppah-eb":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1189968695","body":"### 思路\r\n\r\n参考题解的单调栈思路，满足条件的分块一定是后边分块的最小值不小于前边分块的最大值，所以保留每一个分块的最大值加入栈，最后取栈的长度即可\r\n\r\n### 代码\r\n\r\n\r\n```\r\nvar maxChunksToSorted = function(arr) {\r\n    const stack=[]\r\n    for(let i=0;i<arr.length ;i++){\r\n        let a=arr[i]\r\n        if(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n            const cur=stack[stack.length-1]\r\n            while(stack[stack.length-1]&&stack[stack.length-1]>a){\r\n                stack.pop()\r\n            }\r\n            stack.push(cur)\r\n        }else{\r\n            stack.push(a)\r\n        }\r\n    }\r\n    return stack.length\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raychenlei":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190386338","body":"**思路**\r\n\r\n自己没什么思路，按照题解里的两次遍历方法\r\n先遍历一遍，记录到当前数为止的最大值head\r\n然后从后往前遍历，如果遍历过的arr数组里的最小值比前一个分块的最大值head要大，块的数量 + 1\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public int maxChunksToSorted(int[] arr) {\r\n        int[] head = new int[arr.length];\r\n        head[0] = arr[0];\r\n        for(int i = 1; i < arr.length; i++){\r\n            head[i] = Math.max(head[i - 1], arr[i]);\r\n        }\r\n        int tail = Integer.MAX_VALUE, res = 0;\r\n        for(int i = arr.length - 1; i >= 0; i--){\r\n            if(tail >= head[i]){\r\n                res++;\r\n            }\r\n            tail = Math.min(tail, arr[i]);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n- 时间复杂度：O(n)\r\n\r\n- 空间复杂度：O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"woshichuanqilz":[null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/19#issuecomment-1190438348","body":"```\r\nclass Solution {\r\npublic:\r\n    int maxChunksToSorted(vector<int>& arr) {\r\n        stack<int>maxStk;\r\n        maxStk.push(arr[0]);\r\n        for(int i=1;i<arr.size();i++){\r\n            if(arr[i]<maxStk.top()){\r\n                int maxNum=maxStk.top();\r\n                while(!maxStk.empty()&&maxStk.top()>arr[i])maxStk.pop();\r\n                maxStk.push(maxNum);\r\n            }\r\n            else maxStk.push(arr[i]);\r\n        }\r\n        return maxStk.size();\r\n    }\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"willuuu":[{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/1#issuecomment-1189685480","body":"```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        sum = k\r\n        results=[]\r\n        i = len(num)-1\r\n        while True:\r\n            if sum == 0 and i <0:\r\n                break\r\n            current = 10**(len(num)-i-1)\r\n            if i >= 0:\r\n                sum += current*num[i] \r\n            reminder = int(sum%(current*10)/current)\r\n            results.insert(0, reminder)\r\n            sum = sum - reminder*current\r\n            i -= 1\r\n        return results\r\n```\r\n复杂度O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"christina-soda":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190642938","body":"### 思路\n\n1. 形成一个链表环； 2. 向右移动 （len_list - k % len_list）； 3. 得到新列表的head， 并断开链表环。\n\n### 代码\n\n\n```python\n\nclass Solution:\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        currentNode = head\n        len_list = 1\n        if head is None:\n            return None\n        while currentNode.next is not None:\n            len_list = len_list + 1\n            currentNode = currentNode.next\n        currentNode.next = head\n                \n        move = len_list - k % len_list\n        \n        for i in range(move):\n            currentNode = currentNode.next\n        head = currentNode.next\n        currentNode.next = None\n        \n        return head\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jia98shanliang":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1190893559","body":"\r\n\r\nclass Solution {\r\n         public ListNode rotateRight(ListNode head, int j) {\r\n             if(head == null || head.next == null) {\r\n                 return head;\r\n             }\r\n             ListNode tail = head;\r\n             int length = 1;\r\n             while(tail.next != null) {\r\n                 tail = tail.next;\r\n                 length++;\r\n             }\r\n             tail.next = head;\r\n             ListNode cur = head;\r\n             for(int i = 1; i <  len - (j % len); i++) {\r\n                 cur = cur.next;\r\n             }\r\n             tail = cur.next;\r\n             cur.next = null;\r\n\r\n             return tail;\r\n         }\r\n     }","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user-vannnn":[null,null,null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-8-daily-check/issues/20#issuecomment-1191234692","body":"CODE\r\n```\r\nclass Solution:\r\n    def rotateRight(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\r\n        if k==0 or not head or not head.next:\r\n            return head\r\n\r\n        n=1\r\n        cur=head\r\n\r\n        while cur.next:\r\n            cur=cur.next\r\n            n+=1\r\n\r\n        if(add:=n-k%n)==n:\r\n            return head\r\n        cur.next=head\r\n\r\n        while add:\r\n            cur=cur.next\r\n            add-=1\r\n\r\n        ret=cur.next\r\n        cur.next=None\r\n\r\n        return ret        \r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}