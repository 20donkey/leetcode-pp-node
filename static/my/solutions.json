{"372354984":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"553269487":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992070031","body":"Lee 251 double pointer\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];\r\n        int prev = - s.length(); // to assure the i - prev in first scan is bigger than any possible result;\r\n        \r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = i - prev;   \r\n        }\r\n        \r\n        for(int i = prev; i >= 0; i--){ // prev not pos\r\n            if(s.charAt(i) == c) prev = i;\r\n            ans[i] = Math.min(prev - i, ans[i]);   \r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"965682575":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1052561252":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991881171","body":"```\n/**\n * 解题思路：先把题做出来，再考虑优化\n * <p>\n * 1.直观的看，应该属于大整数相加的问题\n * 2.对num从后向前遍历，每次遍历中对k%10获得对应位数的值t，再对k/10\n * 3.使得num[i]+t；考虑两种情况，<=9和>=10；如何是第一种情况，直接相加就行；如何是第二种情况，要考虑进位\n * <p>\n * 时间复杂度：O(n)\n *\n * @author My\n * @date 2021/12/12\n */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> temp = new ArrayList<>();\n\n        //用于进位\n        int carry = 0;\n        for (int i = num.length - 1; i >= 0; i--) {\n            int t = k % 10 + num[i] + carry;\n            if (t > 9) {\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            temp.add(t % 10);\n            k /= 10;\n        }\n\n        while (k != 0) {\n            int t = k % 10 + carry;\n            if (t > 9) {\n                carry = 1;\n            } else {\n                carry = 0;\n            }\n            temp.add(t % 10);\n            k /= 10;\n        }\n\n        if (carry != 0)\n            temp.add(carry);\n\n        List<Integer> res = new ArrayList<>();\n        for (int i = temp.size() - 1; i >= 0; i--) {\n            res.add(temp.get(i));\n        }\n\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992012722","body":"### 思路\n暂时只能想到时间复杂度为O(n*m)的解法，想不到有哪些性能更优的解法，先解出来再说吧\n1.通过字符串s生成字符串数组chars，遍历chars，获得c在chars中的位置，通过list存储\n2.再次遍历chars，如果chars[i]!=c，将i与list中保存的值进行判断，找出最小的差值并保存到answer[i]中\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] chars = s.toCharArray();\n        int[] answer = new int[chars.length];\n\n        List<Integer> tags = new ArrayList<>();\n        //遍历chars，标记c在chars中的各个位置\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                tags.add(i);\n            }\n        }\n\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] != c) {\n                int min = 200;\n                for (Integer tag : tags) {\n                    min = Math.min(min, Math.abs(i - tag));\n                }\n                answer[i] = min;\n            }\n        }\n\n        return answer;\n    }\n}\n```\n### 复杂度\n时间复杂度：O(n*m)\nn:s的长度\nm:list的长度\n\n空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993057214","body":"### 解题思路\n解题思路：\n1.直观上的解题方式是用数组来实现，用int变量curSize记录当前stack中元素的数量，因此curSize的初始化值为0\n2.每次调用push()时，先检查curSize是否等于maxSize。如果不是，使得stack[curSize]=x，然后curSize++\n3.每次调用pop()时，先检查curSize是否等于0。如果是，直接返回-1；如果不是，先让curSize--，然后num=stack[curSize]。最后返回num\n4.每次调用increment()时，取得curSize和k中的较小值为k，遍历stack[0]-stack[k-1]，使得stack[i]+=val\n### 代码\n```java\nclass CustomStack {\n\n    private int[] stack;\n    private int maxSize;\n    private int curSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.maxSize = maxSize;\n        this.curSize = 0;\n    }\n\n    public void push(int x) {\n        if (curSize < maxSize) {\n            stack[curSize] = x;\n            curSize++;\n        }\n    }\n\n    public int pop() {\n        if (curSize == 0) {\n            return -1;\n        }\n\n        int num = stack[curSize];\n        curSize--;\n        return num;\n    }\n\n    public void increment(int k, int val) {\n        k = Math.min(k, curSize);\n        for (int i = 0; i < k; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n 时间复杂度：\n- push()：O(1)\n- pop()：O(1)\n- increment()：O(k)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994813013","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995345301","body":"#### 思路\n1.stack的特性是先进后出，queue的特性是先进先出\n\n2.使用2个stack来模拟queue，stack2主要用于存储val，每次新的val都回push进stack2的栈顶\n\n3.每次要执行pop()或peek()时，先将stack2中的val暂存至stack1。因此stack2栈底的val是最先进入的，也就是要返回的数值。这些数值在放入stack1后，会到stack1的栈顶，所以才可以返回\n#### 代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        this.stack1 = new Stack<>();\n        this.stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack2.push(x);\n    }\n\n    public int pop() {\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        Integer pop = stack1.pop();\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        return pop;\n    }\n\n\n    public int peek() {\n        while (!stack2.isEmpty()) {\n            stack1.push(stack2.pop());\n        }\n        Integer peek = stack1.peek();\n        while (!stack1.isEmpty()) {\n            stack2.push(stack1.pop());\n        }\n        return peek;\n    }\n\n    public boolean empty() {\n        return stack2.isEmpty();\n    }\n}\n```\n#### 复杂度分析\n时间复杂度：\n- push():O(1)\n- pop():O(n)\n- peek():O(n)\n- empty:O(1)\n\n空间复杂度：\n- O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1149004121":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991841813","body":"### 989. 数组形式的整数加法\n### 思路\n①将数组A转成整数，再将整数A和K进行运算，再将运算结果化为数组  \n\n- 优点：不用考虑数组运算的进位问题  \n- 存在问题： 时间复杂度必然增大，因为过程包含整成整数和拆成数组2部分；最大问题是数组A长度最大为1万，超出js的16位整数长度，会导致不精确问题  \n\n②利用数组进行运算  \n通过取余和整除的方法，把k的最低位取出与数组的最低位进行和运算；在进行加和的时候因为有可能超出9，要考虑进位，可考虑把进的那一位直接加在k上；由于k和数组的相对长度不知道，所以在第一次循坏完数组之后，要再循环一次k的剩余位数。\n\n### 代码\n\n\n```java  \n\n  var addToArrayForm = function (num, k) {\n    const numLen = num.length;\n    let res = [];\n    for (let i = numLen - 1; i >= 0; i--) {\n      let sum = num[i] + k % 10;\n      k = Math.floor(k / 10);\n      if (sum > 9) {\n        k++;\n        sum -= 10;\n      }\n      res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n      let sum = k % 10;\n      res.push(sum);\n    }\n    res.reverse();\n    return res;\n  };\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(MAX(m,n))，其中m为数组长度，n为k的位数。\n- 空间复杂度：O(MAX(m,n))，其中m为数组长度，n为k的位数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992170956","body":"### 821. 字符的最短距离\n### 思路\n字符串中某个字母到最近的c字符的距离，取MIN(i-l, r-i)。由于字符串的首位不一定都是c，因此可以设最左侧的l为-infinity，最右侧的r为infinity。通过从前往后，和从后往前遍历，取最小值即为结果。\n\n### 代码\n\n\n```js   \n\nvar shortestToChar = function(s, c) {\n    let len = s.length;\n    let res = [];\n    let prev = -Infinity;\n    for(let i = 0; i < len; i++){\n        if(s[i] === c) prev = i;\n        res[i] = i - prev;\n    }\n    prev = Infinity;\n    for(let i = len - 1; i >= 0; i--){\n        if(s[i] === c) prev = i;\n        res[i] = Math.min(res[i], prev - i);\n    }\n    \n    return res;\n};\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，2次循环遍历，线性时间复杂度。\n- 空间复杂度：O(1)，额外所用空间为常数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993147102","body":"### 1381. 设计一个支持增量操作的栈\n### 思路\n①   \n在js中没有栈，可以用数组实现，用变量存储maxSize，当数组中的个数小于maxSize时可以进行入栈操作，既push；如果栈不为空就进行pop操作；inc操作通过遍历下标从0到min(k - 1, len - 1)来操作。  \n\n②  \n在方法①中inc的时间复杂度为O(k)，若想继续降低时间复杂度，则要以空间换时间，用另一数组保存增加的信息，到pop时在讲其加回，避免反复累加。\n\n### 代码\n①  \n```js  \n\n\t /**\n\t * @param {number} maxSize\n\t */\n\tvar CustomStack = function(maxSize) {\n\t    this.maxSize = maxSize;\n\t    this.stack = [];\n\t};\n\t\n\t/** \n\t * @param {number} x\n\t * @return {void}\n\t */\n\tCustomStack.prototype.push = function(x) {\n\t    if(this.stack.length < this.maxSize){\n\t        this.stack.push(x);\n\t    }\n\t};\n\t\n\t/**\n\t * @return {number}\n\t */\n\tCustomStack.prototype.pop = function() {\n\t    if(this.stack.length === 0){\n\t        return -1\n\t    }else {\n\t        return this.stack.pop();\n\t    }\n\t};\n\t\n\t/** \n\t * @param {number} k \n\t * @param {number} val\n\t * @return {void}\n\t */\n\tCustomStack.prototype.increment = function(k, val) {\n\t    let index = Math.min(k - 1, this.stack.length - 1);\n\t    for(let i = 0; i <= index; i++){\n\t        this.stack[i] += val;\n\t    }\n\t};\n\t\n\t/**\n\t * Your CustomStack object will be instantiated and called as such:\n\t * var obj = new CustomStack(maxSize)\n\t * obj.push(x)\n\t * var param_2 = obj.pop()\n\t * obj.increment(k,val)\n\t */   \n\n```\n②  \n\n```js   \n\n\t/**\n\t * @param {number} maxSize\n\t */\n\tvar CustomStack = function(maxSize) {\n\t    this.maxSize = maxSize;\n\t    this.stack = new Array(this.maxSize).fill(0);\n\t    this.add = new Array(this.maxSize).fill(0);\n\t    this.top = -1;\n\t};\n\t\n\t/** \n\t * @param {number} x\n\t * @return {void}\n\t */\n\tCustomStack.prototype.push = function(x) {\n\t    if(this.top < this.maxSize - 1){\n\t        this.top++;\n\t        this.stack[this.top] = x;\n\t    }\n\t};\n\t\n\t/**\n\t * @return {number}\n\t */\n\tCustomStack.prototype.pop = function() {\n\t    if(this.top === -1){\n\t        return -1;\n\t    }\n\t    let val = this.add[this.top] + this.stack[this.top];\n\t    if(this.top !== 0){\n\t        this.add[this.top - 1] += this.add[this.top];\n\t    }\n\t    this.add[this.top] = 0;\n\t    this.top--;\n\t    return val;\n\t};\n\t\n\t/** \n\t * @param {number} k \n\t * @param {number} val\n\t * @return {void}\n\t */\n\tCustomStack.prototype.increment = function(k, val) {\n\t    let index = Math.min(k - 1, this.top);\n\t    if(index >= 0) this.add[index] += val;\n\t};\n\t\n\t/**\n\t * Your CustomStack object will be instantiated and called as such:\n\t * var obj = new CustomStack(maxSize)\n\t * obj.push(x)\n\t * var param_2 = obj.pop()\n\t * obj.increment(k,val)\n\t */\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：①：push、pop为O(1)，inc为O(k)；②：push、pop、inc皆为O(1)。\n- 空间复杂度：①：O(maxSize)用于保存数组；②：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920768","body":"### 394. 字符串解码\n### 思路\n最里面最后面的[]中的内容最先计算，先进后出，考虑用栈的形式储存。当遇到数字时，先用multi保存；遇到字母的时候用res保存；当遇到“[”时，压入栈；当遇到“]”时，弹出进行计算。\n\n### 代码\n\n\n```js   \n\n\tvar decodeString = function(s) {\n\t    let stack = [];\n\t    let res = \"\";\n\t    let multi = 0;\n\t    for(let char of s){\n\t        if(char >= 0 && char <= 9){\n\t            multi = multi * 10 + parseInt(char);\n\t        } else if(char === \"[\"){\n\t            stack.push([multi, res]);\n\t            multi = 0;\n\t            res = \"\";\n\t        } else if(char === \"]\"){\n\t            let lastMulti = 0, lastRes = \"\";\n\t            [lastMulti, lastRes] = stack.pop();\n\t            for(let i = 0; i < lastMulti; i++){\n\t                lastRes += res;\n\t            }\n\t            res = lastRes;\n\t        }else{\n\t            res += char;\n\t        }\n\t    };\n\t    return res;\n\t};\n\n```\n\n**复杂度分析**  \n\n- 时间复杂度：O(N)，N是字符串长度。\n- 空间复杂度：O(N)，N是字符串长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995479064","body":"### 232. 用栈实现队列\n### 思路\n要用栈来模拟队列，队列是先进先出，栈是先进后出，所以当实现出队动作时，无法直接从栈底拿到元素，需要将栈内元素一个个弹出到另一个栈，再从栈顶拿，而这时若对第二个栈实现出队就只需要从栈顶弹元素了，入队操作可以在第一个栈进行；若要出队，且第二个栈空了，再将第一个栈的元素都弹到栈2，重复操作。\n\n### 代码\n\n\n```ts  \n  \n\n\tclass MyQueue {\n\t    stack1:number[];\n\t    stack2:number[];\n\t    constructor() {\n\t        this.stack1 = [];\n\t        this.stack2 = [];\n\t    }\n\t\n\t    push(x: number): void {\n\t        this.stack1.push(x);\n\t    }\n\t\n\t    pop(): number {\n\t        if(this.stack2.length > 0){\n\t            return this.stack2.pop();\n\t        }else{\n\t            while(this.stack1.length > 0){\n\t                this.stack2.push(this.stack1.pop());\n\t            }\n\t            return this.stack2.pop();\n\t        }\n\t    }\n\t\n\t    peek(): number {\n\t        if(this.stack2.length > 0){\n\t            return this.stack2[this.stack2.length - 1];\n\t        }else{\n\t            while(this.stack1.length > 0){\n\t                this.stack2.push(this.stack1.pop());\n\t            }\n\t            return this.stack2[this.stack2.length - 1];\n\t        }\n\t    }\n\t\n\t    empty(): boolean {\n\t        return this.stack2.length === 0 && this.stack1.length === 0;\n\t    }\n\t}\n```\n\n**复杂度分析**  \n\n- 时间复杂度：push为O(1)；pop均摊为O(1),每个元素最多经历一次弹出到栈2；peek均摊为O(1)；empty为O(1)。\n- 空间复杂度：O(N)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"1916603886":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991911495","body":"\n### 思路：\n将其中一个变为数组，之前两个都变数组，纠结怎么获取索引，现在另一个每次自处自动补零。\n### 代码：\n\nvar addToArrayForm = function(num, k) {\n       let s = [];\n        let flag = false;\n        let nl = num.length;\n        while(nl != 0 || k != 0) {\n            let a = 0, b = k % 10 ;\n            if(nl !== 0) a = num[--nl];\n            k = parseInt(k/10);\n            \n            let ans = a + b;\n            \n            if(flag) {\n                ans += 1;\n                flag = false;\n            }\n            if( ans >= 10) flag = true;\n            s.push(ans % 10);\n        }\n        if(flag) s.push(1);\n        return s.reverse();\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992195419","body":"var shortestToChar = function(s, c) {\nlet arr = [];\n    let ans = [];\n    for (let i = 0; i < s.length; i++) {\n      if (s[i] === c) {\n        arr.push(i);\n      }\n    }\n    for (let i = 0; i < s.length; i++) {\n      let max = 1000;\n      for (let j = 0; j < arr.length; j++) {\n        if (Math.abs(i - arr[j]) < max) {\n          max = Math.abs(i - arr[j]);\n        }\n      }\n      ans.push(max);\n    }\n    return ans;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993447999","body":"var CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    // 注意：当有增量时，取栈中的每个元素加上增量的值再次存入栈中\n    let length = Math.min(k, this.stack.length);\n    for (let i = 0; i < length; i++) {\n        this.stack[i] += val;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ruohai0925":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilyzhaoyilu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mm12344":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzehan123":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991766191","body":"\n\n```java\n\nclass Solution {\npublic List<Integer> addToArrayForm(int[] num, int k) {\n    int len = num.length;\n    int count = 0;\n    int flag = 0;\n    List<Integer> ans = new ArrayList<>();\n    while (k > 0) {\n        int tmpNum = len - count - 1 < 0 ? 0: num[len - count - 1];\n        int sum = k % 10 + tmpNum + flag;\n        flag = sum / 10;\n        k /= 10;\n        count++;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    for(int i = len - count - 1; i > -1; i--) {\n        int sum = num[i] + flag;\n        flag = sum / 10;\n        ans.add(flag == 1 ? sum % 10 : sum);\n    }\n    if (flag == 1) {\n        ans.add(1);\n    }\n    Collections.reverse(ans);\n    return ans;\n}\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991945520","body":"\n- 语言支持：Java\n\nJava Code:\n\n```java\n\npublic class Solution {\n    /**\n     * @param S: \n     * @param C: \n     * @return: nothing\n     */\n    public int[] shortestToChar(String S, char C) {\n        int n = S.length();\n        int[] res = new int[n];\n        int pos = -n;\n        for (int i = 0; i < n; ++i) {\n            if (S.charAt(i) == C) pos = i;\n            res[i] = i - pos;\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            if (S.charAt(i) == C)  pos = i;\n            res[i] = Math.min(res[i], Math.abs(i - pos));\n        }\n        return res;\n    }\n}\n\n\n```\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992979075","body":"-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993810144","body":"Java Code:\n\n```java\n\nclass Solution {\n    int index = 0;\n    public String decodeString(String s) {\n        // write your code here\n        if (s.length() == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder();\n\n        int repeat = 0;\n\n        while (index < s.length()) {\n            char c = s.charAt(index);\n            if (c == '[') {\n                index++;\n                String sub = decodeString(s);\n                for (int i = 0; i < repeat; i++) {\n                    sb.append(sub);\n                }\n                repeat = 0;\n                index++;\n            } else if (c == ']') {\n                return sb.toString();\n            } else if (Character.isDigit(c)) {\n                repeat = repeat * 10 + c - '0';\n                index++;\n            } else {\n                sb.append(c);\n                index++;\n            }\n        }\n\n        return sb.toString();\n    }\n}\n\n```\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995330805","body":"\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n\n    //定义栈\n    private Stack<Integer> stackA;\n    private Stack<Integer> stackB;\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        stackA = new Stack<Integer>();\n        stackB = new Stack<Integer>();\n    }\n    \n    /** Push element x to the back of queue. */\n    //栈A入栈\n    public void push(int x) {\n        stackA.push(x);\n\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    //栈A出栈到栈B，栈B出栈\n    public int pop() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.pop();\n    }\n    \n    //栈A出栈到栈B，栈B出栈\n    /** Get the front element. */\n    public int peek() {\n        if(stackB.isEmpty()) {\n            while(!stackA.isEmpty()){\n                stackB.push(stackA.pop());\n            }\n        }\n        return stackB.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    //栈A和栈B都为空\n    public boolean empty() {\n        if(stackA.isEmpty() && stackB.isEmpty()){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"erik7777777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachtcoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chang-you":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mmboxmm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangwiitao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leungogogo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ai2095":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanglr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cicihou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shixinlovey1314":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pangjiadai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991847081","body":"## Python3\n```Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        number = 0\n        for n in num:\n            number = number * 10 + n\n        total_num = number + k\n        num_list = []\n        while total_num >= 10:\n            temp = total_num % 10\n            total_num = total_num // 10\n            num_list.append(temp)\n        num_list.append(total_num)\n        return num_list[::-1]\n```\n\n## 思路\n1. 可以用暴力解法\n2. 也可以每个位单独计算（注意进位）\n- time complexity: O(n)\n- space complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992053965","body":"## 思路\n1. 暴力记录每一个c的index，然后遍历找到最小值，时间复杂度O(nm)\n2. 遍历两次：从左到右，从右到左，记录最小值，时间复杂度O(m)\n\n## Python3 \n```Python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # # 两遍遍历 O(m*n)\n        # index_list = []\n        # ans = [len(s)] * len(s)\n        # for index, char in enumerate(s):\n        #     if char == c:\n        #         index_list.append(index)\n\n        # for index, char in enumerate(s):\n        #     min_distance = len(s)\n        #     for i in index_list:\n        #         distance = abs(i-index)\n        #         if distance < min_distance:\n        #             min_distance = distance\n        #     ans[index] = min_distance\n\n        # return ans\n\n        ans = [len(s)] * len(s)\n        index = -1\n\n        # from left to right\n        for i in range(len(s)):\n            if s[i] == c:\n                index = i\n            if index == -1:\n                continue\n            ans[i] = abs(i - index)\n\n        # from right to left\n        index2 = len(s)\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                index2 = j\n            if index2 == len(s):\n                continue\n            ans[j] = min(ans[j], abs(j-index2))\n\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993138334","body":"## Python3\n```Python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        # stack: FILO, append, pop\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        pointer = 0\n        for i in range(min(k, len(self.stack))):\n            self.stack[pointer] += val \n            pointer += 1\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luojiamun":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991904972","body":"### 思路\r\n\r\n- 思路与解法\r\n```\r\n- 逐位加；\r\n- 反向存，最后reverse，不然正向存，每次add数组都得挪位；\r\n```\r\n\r\n- 心得\r\n```\r\n- 第一次fail了因为大意了，这题要注意num和k的长短不一，不能一个for on num解决；\r\n```\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int carry = 0, i = num.length - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        \r\n        while(i >= 0 || k > 0 || carry > 0){\r\n            int left = i >= 0?num[i]:0;\r\n            i--;\r\n            int right = k % 10;\r\n            k = k / 10;\r\n            int sum = left + right + carry;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n        }\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n\r\n***k因为是常数，其实其长度可以忽略。***\r\n\r\ntime: O(Math.max(num.length, Math.log10(k)+1))\r\nspace: O(1)，不算结果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992526525","body":"### 思路\nArray遍历\n\n- 思路与解法\n```\n- 左右两边各扫一遍；\n- 第一遍扫出初始编号；\n- 第二遍更新编号找最小值；\n```\n\n- 心得\n```\n- array的题肯定不会只考array，因为是基础；\n- array一般肯定要考遍历，就像是binary tree；遍历就是左到右，右到左，左右各扫一遍，这是最基本的，可能再有结合双指针/滑动窗口的；总之就是一些结合题目已知条件需要找到合适的便利方式；\n- 这题还可以用stack，边push边更新；\n```\n\n### 代码\n```java\n//array遍历\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int ci = 20000;\n        Arrays.fill(res, 20000);\n        for(int i = 0;i < s.length();i++){\n            if(s.charAt(i) == c){\n                ci = 0;\n            }\n            res[i] = Math.min(ci, res[i]);\n            ci++;\n        }\n        \n        for(int i = s.length() - 1;i >= 0;i--){\n            if(s.charAt(i) == c){\n                ci = 0;\n            }\n            res[i] = Math.min(ci, res[i]);\n            ci++;\n        }\n        \n        return res;\n      \n    }\n}\n\n```\n\n### 复杂度\n\nArray遍历\nO(s.length());\nO(1)\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994280501","body":"### 思路\n\n- 思路与解法\n```\n- 基本方法是push入栈，遇到特殊字符`]`则开始出栈操作，属于栈的常见操作；\n- 考点主要在写法上，尤其是String的操作上，不要使用`+`，能用StringBuilder就多用，避免额外复杂度\n```\n\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<String> stack = new Stack<>();\n        \n        for(int i = 0;i < s.length();i++){\n            char cur = s.charAt(i);\n            \n            if(cur == ']'){\n                StringBuilder sb = new StringBuilder();\n                \n                while(!stack.peek().equals(\"[\")){\n                    sb.append(stack.pop());\n                }\n                //pop the [\n                stack.pop();\n                //find times\n                StringBuilder sbd = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))){\n                    sbd.append(stack.pop());\n                }\n                sbd.reverse();\n                int times = Integer.valueOf(sbd.toString());\n                stack.add(sb.toString().repeat(times));\n            } else {\n                stack.add(String.valueOf(cur));\n            }\n        }\n        StringBuilder sb = new StringBuilder();\n        \n        while(!stack.isEmpty()){\n            sb.append(stack.pop());\n        }\n        sb.reverse();\n        return sb.toString();\n    }\n}\n```\n\n### 复杂度\n\nO(N)，循环体会从头到尾遍历s.length();\nO(M)，要维护一个栈；M为解码后的长度；\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yiwchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921921","body":"思路：\r\n直接模拟\r\n代码：\r\nJava：\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        /* Set up */\r\n        int n = num.length;\r\n        int cur = k;\r\n        List<Integer> res = new ArrayList();\r\n        \r\n        /* run the addition backwards digit by digit*/\r\n        int i = n;\r\n        while (--i >= 0|| cur > 0){\r\n        /* Adding a new digit*/\r\n            if (i >= 0){\r\n                cur += num[i];\r\n            }\r\n        /* Carry addition simulator*/\r\n            res.add(cur % 10);\r\n            cur = cur / 10;;\r\n        }\r\n        /* return the result reversely since we adding up reversely*/\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\nScala:\r\n```\r\nobject Solution {\r\n    def addToArrayForm(num: Array[Int], K: Int): List[Int] = {\r\n        // Set up\r\n        var res = List[Int]()\r\n        var k = K\r\n        \r\n        // Reverse the num list, and initialize the carry\r\n        // Scala variable definition 101\r\n        // carry is repeatedly folding out and most addition is taken care here\r\n        val carry = num.reverse.foldLeft(0)((sum, x)=>{\r\n          val temp = k % 10 + x + sum\r\n          k = k / 10\r\n          res :::= List(temp % 10)\r\n          temp / 10}\r\n        )\r\n        // edge case when there is k or carry left\r\n        if(k == 0){\r\n          if (carry == 1) res :::= List(1)\r\n          res\r\n        }\r\n        else{\r\n          k = k + carry\r\n          while(k > 0){\r\n            res :::= List(k % 10)\r\n            k  = k / 10\r\n          }\r\n          res\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n复杂度：\r\nTC: O(n + k)\r\nSC: O(n + k)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qixuan-code":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995094216","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        return self.stack1\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack1:\n            a = self.stack1.pop()\n            self.stack2.append(a)\n        res= self.stack2.pop()\n        while self.stack2:\n            b = self.stack2.pop()\n            self.stack1.append(b)\n  \n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if len(self.stack1) == 0:\n            return True\n        else:\n            return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ZT4188":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thinkfurther":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pophy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuang456":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829936","body":"```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] nums, int k) {\r\n        LinkedList<Integer> res = new LinkedList<>(); // LinkedList addFirst()\r\n        for (int i = nums.length - 1; i >= 0; i --) {\r\n            res.addFirst((nums[i] + k) % 10);\r\n            k = (nums[i] + k) / 10;\r\n        }\r\n        while (k > 0) {\r\n            res.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n//Time O(n), Space O(n)\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992558904","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // two pass(forward, backward) and compare.\n       //  fp, bp edge condition\n\n        int len = s.length(); int fp = -len; \n      \n        int[] res = new int[len];\n        \n        for (int i = 0; i < len; i ++) {\n            if(s.charAt(i) == c) fp = i;\n            res[i] = i - fp;\n        }\n        \n        int bp = 2*len - 1;\n        for(int j = s.length() - 1; j >= 0; j --){\n            if(s.charAt(j) == c) bp = j;\n            res[j] = Math.min(res[j], bp - j);\n        }\n        \n        return res;\n    }\n}\n// Time: O(n). Space:O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993681672","body":"```java\n    int n;\n    int[] inc;\n    Stack<Integer> stack;\n    public CustomStack(int maxSize) {\n        n = maxSize;\n        inc = new int[n];\n        stack = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stack.size() < n)\n            stack.push(x);\n    }\n\n    public int pop() {\n        int i = stack.size() - 1;\n        if (i < 0)\n            return -1;\n        if (i > 0)\n            inc[i - 1] += inc[i];\n        int res = stack.pop() + inc[i];\n        inc[i] = 0;\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int i = Math.min(k, stack.size()) - 1;\n        if (i >= 0)\n            inc[i] += val;\n    }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994292058","body":"```java\npublic class Solution {\n    private int pos = 0;\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        String num = \"\";\n        for (int i = pos; i < s.length(); i++) {\n            if (s.charAt(i) != '[' && s.charAt(i) != ']' && !Character.isDigit(s.charAt(i))) {\n                sb.append(s.charAt(i));\n            } else if (Character.isDigit(s.charAt(i))) {\n                num += s.charAt(i);\n            } else if (s.charAt(i) == '[') {\n                pos = i + 1;\n                String next = decodeString(s);\n                for (int n = Integer.valueOf(num); n > 0; n--) sb.append(next);\n                num = \"\";\n                i = pos;\n            } else if (s.charAt(i) == ']') {\n                pos = i;\n                return sb.toString();\n            }\n        }\n        return sb.toString();\n    }\n}\nTime: O(n), Space: O(n)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995429310","body":"```java\nclass MyQueue {\n\n    /** Initialize your data structure here. */\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();   \n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n      inStack.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(!outStack.isEmpty()) return outStack.pop();\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        return outStack.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(!outStack.isEmpty()) return outStack.peek();\n        while(!inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n        return outStack.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n}\n// Time O(1), Space O(n);\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zol013":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991980237","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [float('inf') for _ in range(n)]\n        for i in range(n):\n            for j in range(i, n):\n                if s[j] == c:\n                    ans[i] = j - i\n                    break\n                    \n        for i in range(n-1,-1,-1):\n            for j in range(i,-1,-1):\n                if s[j] == c:\n                    ans[i] = min(ans[i],i-j)\n                    break\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993124094","body":"```\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.size = size\n        self.st = []\n        self.cnt = 0\n        self.incrementals = []\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.cnt += 1\n            self.st.append(x)\n            self.incrementals.append(0)\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        if self.cnt >= 1:\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.st.pop() + self.incrementals.pop()\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(k - 1, self.cnt - 1)] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994254023","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                repeatstr = ''\n                while stack and stack[-1] != \"[\":\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                repeatcnt = ''\n                while stack and stack[-1].isdigit():\n                    repeatcnt = stack.pop() + repeatcnt\n                int_cnt = int(repeatcnt)\n                stack.append(int_cnt * repeatstr)\n        \n        return ''.join(stack)\n```\nTC:O(N)\nSC:O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995502694","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.size1 = 0\n        self.stack2 = []\n        self.size2 = 0\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack1.append(x)\n        \n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        pop_val = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return pop_val\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        peek_val = self.stack2[-1]\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return peek_val\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.stack1:\n            return True\n        else:\n            return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qyw-wqy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"skinnyh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leo173701":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kidexp":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falconruo":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991748173","body":"** 思路：**\r\n1. 从后向前依次取一位数字与k相加，余数等于和模10，并存入返回数组，令k除10，继续遍历\r\n2. 遍历结束，判断k是否为0， 不为0则循环继续将余数存入数组res, k除10，继续，直至k=0\r\n3. 反转数组res并返回\r\n\r\n** 复杂度分析: **\r\n- 时间复杂度:  O(max(n, m))， 其中n为数组num的长度，m为数字k的位数\r\n- 空间复杂度:  O (1)\r\n-\r\n** 代码(C++): **\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        int n = num.size() - 1;\r\n        vector<int> res;\r\n\r\n        while (n >= 0) {\r\n            k += num[n];\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n            n--;\r\n        }\r\n\r\n        // for the condition that k not 0\r\n        while (k) {\r\n            res.push_back(k % 10);\r\n            k /= 10;\r\n        }\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992084192","body":"**思路:**\r\n1. 从前到后遍历，计算出每个字符的距离\r\n2. 从后到前再次遍历，计算出每个字符的距离取小值\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(n)，其中n是字符串的长度\r\n- 空间复杂度: O(1)\r\n\r\n**代码(C++):**\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.length();\r\n\r\n        vector<int> res(n, n - 1);\r\n        int idx = n - 1;\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        idx = 0;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            if (s[i] == c)\r\n                idx = i;\r\n            res[i] = min(res[i], abs(idx - i));\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992747551","body":"**思路:**\r\n使用数组模拟栈\r\n\r\n**时间复杂度:**\r\n- 时间复杂度: O(1) - push, pop; O(k) - increment\r\n- 空间复杂度: O(maxSize)\r\n\r\n**代码(C++):**\r\n```\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        size = maxSize;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (st.size() >= size) return;\r\n        st.push_back(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if (st.size() == 0) return -1;\r\n        int val = st.back();\r\n        st.pop_back();\r\n        return (val);\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int idx = (k <= st.size()) ? k : st.size();\r\n\r\n        for (int i = 0; i < idx; ++i)\r\n            st[i] += val;\r\n    }\r\nprivate:\r\n    int size;\r\n    vector<int> st;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994060650","body":"**思路:**\r\n使用辅助栈stack\r\n\r\n**复杂度分析:**\r\n- 时间复杂度：O(N)，其中 N 为解码后的 s 的长度\r\n- 空间复杂度：O(N)\r\n**代码（C++）：**\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res = \"\";\r\n        stack<string> st;\r\n        int n = s.length();\r\n\r\n        for (int i = 0; i < n; ++i) {\r\n            string tmp = \"\";\r\n            if (isalpha(s[i])) {\r\n                while (isalpha(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);\r\n            } else if (isdigit(s[i])) {\r\n                while (isdigit(s[i])) {\r\n                    tmp += s[i];\r\n                    ++i;\r\n                }\r\n                --i;\r\n                st.push(tmp);    \r\n            } else if (s[i] == '[') {\r\n                tmp += s[i];\r\n                st.push(tmp);\r\n            }\r\n            else if (s[i] == ']') {\r\n                while (st.top() != \"[\") {\r\n                    tmp.insert(0, st.top());\r\n                    st.pop();\r\n                }\r\n                // pop out '['\r\n                st.pop();\r\n\r\n                int repeat = stoi(st.top());\r\n                st.pop();\r\n\r\n                string newstr = \"\";\r\n                while (repeat--)\r\n                    newstr += tmp;\r\n                st.push(newstr);\r\n            }\r\n        }\r\n\r\n        while (!st.empty()) {\r\n            res.insert(0, st.top());\r\n            st.pop();\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995025905","body":"**思路:**\r\n使用两个栈head, end来实现队列\r\n\r\n**复杂度分析:**\r\n- 时间复杂度: O(n)\r\n- 空间复杂度: O(n)\r\n\r\n**代码(C++):**\r\n```\r\nclass MyQueue {\r\npublic:\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        while (!end.empty()) {\r\n            head.push(end.top());\r\n            end.pop();\r\n        }\r\n\r\n        end.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        while (!head.empty()) {\r\n            end.push(head.top());\r\n            head.pop();\r\n        }\r\n\r\n        int val = end.top();\r\n        end.pop();\r\n        return val;\r\n    }\r\n    \r\n    int peek() {\r\n        while (!head.empty()) {\r\n            end.push(head.top());\r\n            head.pop();\r\n        }\r\n\r\n        return end.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return head.empty() && end.empty();\r\n    }\r\nprivate:\r\n    stack<int> head, end;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florenzliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"q815101630":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991823659","body":"Ripple Adder\r\nSimilar to the implementation of ripple adder, The adder will add numbers at the same position, output the sum of the current position, and pass the carry to the next bit.\r\n\r\nPython\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], k: int) -> List[int]:\r\n        curSum = 0\r\n        carry = 0\r\n\r\n        # This can be achieved through continuing division, but I am lazy\r\n        if not A:\r\n            return [int(i) for i in str(k)]\r\n        elif not k:\r\n            return A\r\n\r\n        K = [int(i) for i in str(k)]\r\n        LA = len(A)-1\r\n        LK = len(K)-1\r\n\r\n        if LA <= LK:\r\n            target = K\r\n            idx = LK\r\n        else:\r\n            target = A\r\n            idx = LA\r\n        while LA >= 0 and LK >= 0:\r\n            curSum = A[LA] + K[LK] + carry\r\n            if curSum < 10:\r\n                target[idx] = curSum\r\n                carry = 0\r\n            else:\r\n                carry = curSum //10\r\n                target[idx] = curSum % 10\r\n            LA-=1\r\n            LK-=1\r\n            idx-=1\r\n        if LK != LA:\r\n            while idx >=0:\r\n                curSum = target[idx] + carry\r\n                if curSum < 10:\r\n                    target[idx] = curSum\r\n                    carry = 0\r\n                else:\r\n                    carry = curSum // 10\r\n                    target[idx] = curSum%10\r\n                idx-=1\r\n        if carry > 0:\r\n            target[0:0] = [carry]\r\n        return target\r\nTime Complexity: O(max(K,A))\r\nSpace Complexity: O(max(K,A))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959488","body":"遍历两遍array， 从左往右+从右往左。\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        ans = [float(\"inf\")]*len(s)\r\n\r\n        idx = float(\"inf\")\r\n        for i,v in enumerate(s):\r\n            if v == c:\r\n                idx = i\r\n            else:\r\n                if idx != float(\"inf\"):\r\n                    ans[i] = i-idx\r\n        \r\n        idx = float(\"inf\")\r\n\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                idx = i\r\n                ans[i] = 0\r\n            else:\r\n                if idx != float(\"inf\"):\r\n                    ans[i] = min(ans[i], idx-i)\r\n        \r\n        return ans\r\n```\r\n时空O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993141103","body":"# 用list 模拟 stack 就行，\r\n记录三个attributes, maxSize, size, stack\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n        self.size = 0\r\n    def push(self, x: int) -> None:\r\n        if self.size < self.maxSize:\r\n            self.stack.append(x)\r\n            self.size+=1\r\n\r\n    def pop(self) -> int:\r\n        if self.size>0:\r\n            self.size-=1\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        num = min(k, self.size)\r\n        for i in range(num):\r\n            self.stack[i] += val\r\n```\r\nTime: O(1) excepts O(min(k, size)) for increment\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994269545","body":"# Stack\r\nWhenever we see bracket, we can think about the stack. \r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        res = \"\"\r\n        times = \"\"\r\n        for char in s:\r\n            if char == \"[\":\r\n                stack.append((res, times))\r\n                res = \"\"\r\n                times = \"\"\r\n            elif \"0\" <= char <= \"9\":\r\n                times += char\r\n            elif \"a\" <= char <= \"z\":\r\n                res += char\r\n            elif char == \"]\":\r\n                lastRes, lastTimes = stack.pop()\r\n                res = lastRes + int(lastTimes)*res\r\n        return res\r\n```\r\nTimes: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995433101","body":"用两个栈，一个出，一个入，一些细节需要注意\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.inStack = []\r\n        self.outStack = []\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.inStack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack.pop()\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack.pop()\r\n            else:\r\n                return -1\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.outStack:\r\n            return self.outStack[-1]\r\n        else:\r\n            while self.inStack:\r\n                self.outStack.append(self.inStack.pop())\r\n            if self.outStack:\r\n                return self.outStack[-1]\r\n            else:\r\n                return -1\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return not self.inStack and not self.outStack\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen445":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850462","body":"### 代码\n``` Python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        k=[int(x) for x in str(k)]\n        i=len(num)-1\n        j=len(k)-1\n        carry=0\n        result=deque([])\n        while i>=0 or j>=0:\n            a=num[i] if i >=0 else 0 \n            b=k[j] if j>=0 else 0\n            s=a+b+carry\n            carry=s//10\n            result.appendleft(s%10)\n            i-=1\n            j-=1\n        if carry != 0:\n            result.appendleft(carry)\n        return result\n```\n### 复杂度\n\nTime: O(n)\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992040472","body":"### 代码\n``` python3\nclass Solution: \n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev_position=float('-inf')\n        result=[]\n        for i in range(len(s)):\n            if s[i] == c:\n                prev_position = i\n            result.append(i-prev_position)\n        prev_position=float('inf')\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                prev_position =i\n            result[i]= min(result[i],prev_position-i)\n        return result\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993194847","body":"### 代码\n\n``` Python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack=[]\n        self.size_limit=maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size_limit:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        return -1\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994290427","body":"### 代码\n``` Python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack=[]\n        for e in s:\n            if e==\"]\":\n                temp=[]\n                while stack[-1] != \"[\":\n                    temp.append(stack.pop())\n                stack.pop()\n                count=0\n                order=1\n                while stack and stack[-1].isnumeric():\n                    count+=int(stack.pop())*order\n                    order*=10\n                for i in range (count):\n                    stack.extend(temp[::-1])\n            else:\n                stack.append(e)\n        return \"\".join(stack)\n\n```\n\n### 复杂度\n\nTime: O(n)\n\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995502931","body":"### 代码\n``` Python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1=[]\n        self.stack2=[]\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n      \n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2.pop()\n       \n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"JachinM":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangyalei1026":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993190950","body":"# Main idea\r\nArray\r\n# Code\r\n```py\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        temp = self.stack[-1]\r\n        self.stack.pop()\r\n        return temp\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack),k)):\r\n            self.stack[i] += val\r\n```\r\n# Complexity\r\nTime complexity: O(1)\r\nSpace complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzz2015":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991759056","body":"## 思路\r\n- 倒序遍历num ，把 k 转化为每一位，做加法注意carry flag。时间复杂度 O(n)，空间复杂度为O(1)。\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) { \r\n        \r\n        int i=num.size()-1; \r\n        int carry =0; \r\n        vector<int> ret; \r\n        while(k||carry||i<num.size())\r\n        {\r\n            int value ;\r\n            if(i>=0)\r\n            {\r\n              value = k%10 + num[i] + carry; \r\n            }\r\n            else\r\n            {\r\n                value = k%10 + carry; \r\n            }\r\n            \r\n            carry = value/10; \r\n            ret.push_back(value%10); \r\n            \r\n            k = k/10; \r\n            i--; \r\n        }\r\n        \r\n        reverse(ret.begin(), ret.end()); \r\n        \r\n        return ret; \r\n        \r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991956160","body":"## 思路\n- f(i)为第i个位置的最短距离，f(i)和s字符串中在i 的前后最近的c 位置相关，有时候一次同时处理两个位置比较难，但是可分解成先处理前面的最近位置，再处理后面的最近位置则比较容易。实现方法，两次遍历，先从前往后，找到前面的最近位置，再从后往前，找到后面的最近位置，返回两次中最小的。时间复杂度为O(N)，空间复杂度为O(1)，不考虑输出的话。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        vector<int> ret(s.size(), INT_MAX); \n        // loop left. \n        int pos = -1; \n        for(int i=0; i< s.size(); i++)\n        {\n            if(s[i]==c)\n            {\n                pos = i; \n                ret[i] =0; \n            }\n            else if(pos!=-1)\n            {\n                ret[i] = i - pos; \n            }\n        }\n        pos = -1; \n        for(int i= s.size()-1; i>=0; i--)\n        {\n            if(s[i]==c)\n            {\n                pos = i; \n                ret[i] =0; \n            }\n            else if(pos!=-1)\n            {\n                ret[i] = min(ret[i], pos -i); \n            }\n        }\n        \n        return ret; \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992810434","body":"## 思路\n- 关键点如何处理incremental  number。利用一个数组记录对应位置的incremental，当pop时，累加当前位置的incremental value，同时把该incremental value传递前一个index。使用如下例子  stack   [  1  2  3  4 5]   incremental [100 100 100  100 100]  当pop  是  5 + 100    后stack  [ 1 2 3 4]  incremental [ 100 100 100 200]  再pop是  4 + 200 。这样起到累加的效果。时间复杂度为  O(1) ，空间复杂度为 O(N)，N为最大设置stack size。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\npublic:\n    \n    vector<int> stack; \n    int iSize; \n    vector<int> incSum; \n    CustomStack(int maxSize) {\n        \n        iSize = maxSize; \n        incSum.assign(iSize, 0); \n    }\n    \n    void push(int x) {\n        \n        if(stack.size() < iSize)\n        {\n            stack.push_back(x); \n        }        \n    }\n    \n    int pop() {\n        \n        if(stack.size())\n        {\n            int index = stack.size()-1;\n            int addValue = incSum[index];\n            if(index>0)\n            {\n                incSum[index-1] += addValue;                  \n            }\n            incSum[index] =0;            \n            int ret = stack.back() + addValue; \n            stack.pop_back();\n            return ret; \n        }\n        else\n            return -1; \n        \n    }\n    \n    void increment(int k, int val) {\n        \n        int index = min(k, int(stack.size()) ); \n        if(index>0)\n        {\n            incSum[index-1] += val; \n        }        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994403337","body":"## 思路\n- 对于括号匹配问题，栈是优先考虑的方法，也可以使用递归解法。一般我们定义递归方法要找到当前问题，如何进一步分解下一个子问题，最后考虑base情况如何返回，但是本问题复杂在于除了括号的嵌套，还有同层的括号。因此在递归回来后，还继续处理下一个问题。因此利用start 引用传递子问题完成到那个index，返回后继续操作。时间复杂度为O(n)，空间复杂度O(n). \n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        \n        int start =0; \n        return dfs(s, start);\n        \n    }\n    \n    string dfs(string& s, int& start)\n    {\n        string ret; \n        int num =0; \n        for( ; start< s.size(); start++)\n        {\n            if(s[start]>='0' && s[start]<='9')\n            {\n                num = (num*10 + (s[start]-'0')); \n            }\n            else if(s[start] == '[')\n            {\n                start++; \n                string tmp = dfs(s, start); \n                \n                for(int j=0; j< num; j++)\n                {\n                    ret += tmp; \n                }\n                num =0;\n            }\n            else if(s[start] == ']')\n            {\n                return ret; \n            }\n            else\n            {\n                ret.push_back(s[start]); \n            }\n        }\n        \n        return ret; \n        \n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995404870","body":"## 思路\n- 使用两个stack来模拟queue。因为stack 为先进后出，queue 为先进先出，因为两个stack两次reverse就能实现queue。具体实现，1个stack 放push ，另外一个stack 放pop。当pop为空时，把push stack的元素push 出来，放入pop stack。时间负责度为平均为 O(1)\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass MyQueue {\npublic:\n    \n    vector<int> pushStack; \n    vector<int> popStack; \n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n        pushStack.push_back(x); \n        \n    }\n    \n    int pop() {\n        \n        pushAllNode(); \n        if(popStack.size())\n        {\n            int ret = popStack.back(); \n            popStack.pop_back();\n            return ret;         \n        }\n        else\n            return -1; \n        \n    }\n    \n    int peek() {\n        pushAllNode(); \n        if(popStack.size())\n        {        \n            int ret = popStack.back(); \n            return ret; \n        }\n        else\n            return -1; \n    }\n    \n    bool empty() {\n        \n        return popStack.size()==0 && pushStack.size()==0; \n        \n    }\n    \n    void pushAllNode()\n    {\n        if(popStack.size()==0 )\n        {\n            while(pushStack.size())\n            {\n                int topNode = pushStack.back(); \n                pushStack.pop_back(); \n                popStack.push_back(topNode); \n            }\n        }        \n    }\n};\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tongxw":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829384","body":"## 思路\r\n遍历合并，类似合并有序数组/链表。\r\n## 代码\r\n```js\r\nvar addToArrayForm = function(num, k) {\r\n    ans = [];\r\n    i = num.length - 1;\r\n    carry = 0;\r\n    while (i >= 0 || k != 0) {\r\n        val1 = i >= 0 ? num[i] : 0;\r\n        val2 = k != 0 ? k % 10 : 0;\r\n        \r\n        sum = val1 + val2 + carry;\r\n        carry = Math.floor(sum / 10);\r\n        sum = sum % 10;\r\n        \r\n        ans.push(sum);\r\n        \r\n        i--;\r\n        k = Math.floor(k/10);\r\n    }\r\n    \r\n    if (carry != 0) {\r\n        ans.push(carry);\r\n    }\r\n\r\n    return ans.reverse();\r\n};\r\n```\r\nTC: O(max(N, logK))\r\nSC: O(max(N, logK))\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992053100","body":"## 思路\r\n正序遍历和逆序遍历，取最小值\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        \r\n        int count = n + 1;\r\n        for (int i=0; i<n; i++) {\r\n            char cur = s.charAt(i);\r\n            count = cur == c ? 0 : count + 1;\r\n            ans[i] = count;\r\n        }\r\n        \r\n        for (int i=n-1; i>=0; i--) {\r\n            char cur = s.charAt(i);\r\n            count = cur == c ? 0 : count + 1;\r\n            ans[i] = Math.min(ans[i], count);\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}\r\n```\r\nTC: O(n)\r\nSC: O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993189185","body":"## 思路\r\n用一个增量数组记录增值\r\n## 代码\r\n```java\r\nclass CustomStack {\r\n    Deque<Integer> stack;\r\n    int[] incre;\r\n    int size;\r\n    int max;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new LinkedList<>();\r\n        incre = new int[maxSize + 1];\r\n        max = maxSize;\r\n        size = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (size < max) {\r\n            stack.push(x);\r\n            size++;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (size == 0) {\r\n            return -1;\r\n        }\r\n\r\n        int val = stack.pop();\r\n        if (incre[size] != 0) {\r\n            val += incre[size];\r\n            incre[size - 1] += incre[size];\r\n            incre[size] = 0;\r\n        }\r\n        size--;\r\n        return val;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int total = Math.min(k, size);\r\n        incre[total] += val;\r\n    }\r\n}\r\n\r\n```\r\nTC: push: O(1), pop (1), increment O(1)\r\nSC: O(maxSize)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994208625","body":"### 思路\r\n1. 如果`s[i]`是字符，解析全部字符，比如\"abc\"，然后入栈；\r\n2. 如果`s[i]`是数字，解析全部数字，比如\"123\"，然后入栈；\r\n3. 如果`s[i]`是`'['`，放入栈内\r\n4. 如果`s[i]`是`']'`，开始解析\r\n    1. 字符串出栈，直到碰到`'['`，所有出栈的字符串拼接到一起。\r\n    2. `'['`出栈\r\n    3. 下一个栈顶的是数字，出栈，然后按照这个数字重复拼接字符串\r\n    4. 最后把处理好的字符串再放入栈内。\r\n5. 遍历结束后，所有栈内字符串出栈，反向拼接，输出\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        Deque<String> stack = new LinkedList<>();\r\n        int n = s.length();\r\n        char[] chars = s.toCharArray();\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        int i = 0;\r\n        while (i < n) {\r\n            if (Character.isLetter(chars[i])) {\r\n                while (i < n && Character.isLetter(chars[i])) {\r\n                    sb.append(chars[i]);\r\n                    i++;\r\n                }\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n            } else if (Character.isDigit(chars[i])) {\r\n                while (i < n && Character.isDigit(chars[i])) {\r\n                    sb.append(chars[i]);\r\n                    i++;\r\n                }\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n            } else if (chars[i] == '[') {\r\n                stack.push(\"[\");\r\n                i++;\r\n            } else if (chars[i] == ']') {\r\n                while (!stack.isEmpty() && !stack.peek().equals(\"[\")) {\r\n                    sb.insert(0, stack.pop());\r\n                }\r\n                String str = sb.toString();\r\n                \r\n                if (stack.size() < 2) {\r\n                    return null;\r\n                }\r\n                // pop the \"[\"\r\n                stack.pop();\r\n                \r\n                // pop the number\r\n                int times = 0;\r\n                try {\r\n                    times = Integer.parseInt(stack.pop());\r\n                } catch (Exception e) { // NumberException\r\n                    return null;\r\n                }\r\n                \r\n                // repeat\r\n                sb.setLength(0);\r\n                while (times > 0) {\r\n                    sb.append(str);\r\n                    times--;\r\n                }\r\n                \r\n                // push back\r\n                stack.push(sb.toString());\r\n                sb.setLength(0);\r\n                \r\n                i++;\r\n            }\r\n        }\r\n        \r\n        while (!stack.isEmpty()) {\r\n            sb.insert(0, stack.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n- TC: O(n) n为输出字符串长度\r\n- SC: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995464008","body":"## 思路\r\n两个栈，分别负责读写\r\n## 代码\r\n```java\r\nclass MyQueue {\r\n    Deque<Integer> in;\r\n    Deque<Integer> out;\r\n    public MyQueue() {\r\n        in = new LinkedList<>();\r\n        out = new LinkedList<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (empty()) {\r\n            return -1;\r\n        }\r\n        \r\n        if (out.isEmpty()) {\r\n            peek();\r\n        }\r\n        \r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!out.isEmpty()) {\r\n            return out.peek();\r\n        }\r\n        while (!in.isEmpty()) {\r\n            out.push(in.pop());\r\n        }\r\n        \r\n        return out.isEmpty() ? -1 : out.peek();        \r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n        \r\n    }\r\n}\r\n```\r\nTC: push O(1), pop O(n), peek O(n), empty O(1)\r\nSC: O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okbug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yan0327":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991699058","body":"思路：\r\n创建一个out数组用于存放结果。\r\npre代表进位，sum代表总和,k代表被加数\r\n数组从n-1到0开始遍历， 但是for的判断条件有i>=0||k>0||pre>0\r\n如果i>=0，则 sum= num[i]+k%10+pre\r\n否则 sum= k%10+pre\r\n最后处理：pre = sum/10; k /= 10 添加到out数组\r\n最后翻转数组即可\r\n```Go\r\nfunc addToArrayForm(num []int, k int) []int {\r\n    n := len(num)\r\n    pre,sum:=0,0\r\n    out := []int{}\r\n    for i:=n-1;i>=0||k>0||pre>0;i--{\r\n        if i >= 0{\r\n            sum = num[i]+k%10+pre\r\n        }else{\r\n            sum =k%10 + pre\r\n        }\r\n        pre = sum/10\r\n        k /= 10\r\n        out = append(out,sum%10)\r\n    }\r\n    reverse(out)\r\n    return out\r\n}\r\nfunc reverse(out []int) []int{\r\n    for i:=0;i<len(out)/2;i++{\r\n        out[i],out[len(out)-1-i] = out[len(out)-1-i] , out[i]\r\n    }\r\n    return out\r\n}\r\n```\r\n时间复杂度O（n）\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991925070","body":"思路：\r\n字符的最短距离，可以从前往后遍历，以及从后往前遍历求最小值。\r\n初始化一个out数组\r\n令flag = -1 ，flag表示前一个字符c出现的位置。\r\n从前往后遍历：（1）判断是否该字符为c （2）若c存在【flag >= 0】则此时out[i] = i-flag 否则 out[i] = math.MaxInt32\r\n从后往前遍历：（1）判断是否该字符为c （2）若c存在【flag >= 0】则此时out[i] = min（out[i]，flag-i）\r\n第二次遍历记得比较大小，为了得到最优解。求个最小值。\r\n最后题目出问题的地方是：flag >= 0 考虑 字符c在第一个的情况！\r\n```Go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    out := make([]int,len(s))\r\n    flag := -1\r\n    for i :=0;i<len(s);i++{\r\n        if s[i] == c{\r\n            flag = i\r\n        }\r\n        if flag >= 0{\r\n            out[i] = i-flag\r\n        }else{\r\n            out[i] = math.MaxInt32\r\n        }\r\n    }\r\n    flag = -1\r\n    for i := len(s)-1;i>=0;i--{\r\n        if s[i] == c{\r\n            flag = i\r\n        }\r\n        if flag >= 0{\r\n            out[i] = min(out[i],flag-i)\r\n        }\r\n    }\r\n    return out\r\n}\r\nfunc min(a,b int)int{\r\n    if a < b{\r\n        return a\r\n    }\r\n        return b\r\n}\r\n```\r\n时间复杂度O（N）\r\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992622969","body":"思路：\r\n构造函数构造栈以及容量\r\n入栈需要判断栈是否满了，如果不满才可以进行入栈操作\r\n出栈需要判断栈是否为空，不为空才能出栈\r\n批量增加，要判断此时的k是否大于栈的元素，如果大于要置为k，此时一个for循环遍历批量增加\r\n```Go\r\ntype CustomStack struct {\r\n    stack []int\r\n    total int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack{[]int{},maxSize}\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) <this.total{\r\n        this.stack = append(this.stack,x)\r\n    }\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) == 0{\r\n        return -1\r\n    }\r\n    out := this.stack[len(this.stack)-1]\r\n    this.stack = this.stack[:len(this.stack)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack){\r\n        k = len(this.stack)\r\n    }\r\n    for i:=0;i<k;i++{\r\n        this.stack[i] += val\r\n    }\r\n}\r\n```\r\n入栈，出栈 时间复杂度O（N）\r\n增量操作O（k）\r\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993696758","body":"思路：\r\n涉及到字符串解码，用栈是合理做法。\r\n这里的关键判断是 数字、 【、】、字符\r\n因此可以考虑用数字栈和字符串栈两个栈共同维护。\r\n遍历字符串： 用一个num和out维护当前数字num和字符串out\r\n1.若遇到数字，则num*10 + int(x-'0')，获取要重复的次数\r\n2.若遇到【则把之前的数字和字符串分别压入栈中\r\n3.若遇到】则把数字栈和字符串栈的数据弹出来，首先用数字栈弹出的数组重复增加当前字符串out,\r\n再用字符串栈弹出的原本的字符串拼接重复生成的字符串，作为最新的字符串\r\n4.若遇到字符，则直接拼接即可\r\n```Go\r\nfunc decodeString(s string) string {\r\n    numstack := []int{}\r\n    strstack := []string{}\r\n    num := 0\r\n    out := \"\"\r\n    for _,x := range s{\r\n        if x >= '0' && x <= '9'{\r\n            num = num*10 + int(x-'0')\r\n        }else if x == '['{\r\n            numstack = append(numstack,num)\r\n            strstack = append(strstack,out)\r\n            num = 0\r\n            out = \"\"\r\n        }else if x == ']'{\r\n            count := numstack[len(numstack)-1]\r\n            numstack = numstack[:len(numstack)-1]\r\n            out = strings.Repeat(out,count)\r\n            str := strstack[len(strstack)-1]\r\n            strstack = strstack[:len(strstack)-1]\r\n            out = str + out\r\n        }else{\r\n            out += string(x)\r\n        }\r\n    }\r\n    return out\r\n}\r\n```\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994932404","body":"思路：\r\n用两个栈实现一个队列。一个作为队列头栈，一个作为队列尾栈。\r\n插入则直接插入到队列尾栈。弹出和查看队列头，关键要先判断队列头栈是否为空，不空为可直接弹出值或取出队列头。\r\n如果队列头栈为空，则循环将队列尾栈压入队列头栈。\r\n判断是否为空即判断两个栈是否为空即可\r\n```Go\r\ntype MyQueue struct {\r\n    stackfront []int\r\n    stacktail []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{[]int{},[]int{}}\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Push(x int)  {\r\n    this.stacktail = append(this.stacktail,x)\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Pop() int {\r\n    if len(this.stackfront) > 0{\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        this.stackfront = this.stackfront[:len(this.stackfront)-1]\r\n        return out\r\n    }\r\n    for len(this.stacktail) > 0{\r\n        this.stackfront = append(this.stackfront,this.stacktail[len(this.stacktail)-1])\r\n        this.stacktail = this.stacktail[:len(this.stacktail)-1]\r\n    }\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        this.stackfront = this.stackfront[:len(this.stackfront)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Peek() int {\r\n    if len(this.stackfront) > 0{\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n        return out\r\n    }\r\n    for len(this.stacktail) > 0{\r\n        this.stackfront = append(this.stackfront,this.stacktail[len(this.stacktail)-1])\r\n        this.stacktail = this.stacktail[:len(this.stacktail)-1]\r\n    }\r\n        out := this.stackfront[len(this.stackfront)-1]\r\n    return out\r\n}\r\n\r\n\r\nfunc (this *MyQueue) Empty() bool {\r\n    return len(this.stackfront) == 0 && len(this.stacktail)==0\r\n}\r\n\r\n```\r\n时间复杂度 O（n）【内部操作】 外部操作是O（1）\r\n空间复杂度O（N）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenming-cao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mozro0327":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingzhan0312":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993100893","body":"## Note\n\n1. Push O(1), Pop O(1), Increment O(n), n is min(this.size,k);\n2. Space Complexity: O(n)\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize=maxSize;\n    this.size=0;\n    this.stack=[];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.size!==this.maxSize){\n        this.stack.push(x);\n        this.size++;\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.size===0) return -1;\n    this.size--;\n    return this.stack.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=Math.min(k-1,this.size-1);i>=0;i--){\n        this.stack[i]+=val;\n    }\n};\n\n/** \n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurallalala":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yingliufilms":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994112478","body":"```const decodeString = function (str) {\r\n  let stack = [];\r\n  let currStr = \"\";\r\n  let currNum = 0;\r\n\r\n  for (let i = 0; i < str.length; i++) {\r\n    if (str[i] === \"[\") {\r\n      stack.push(currStr);\r\n      stack.push(currNum);\r\n      currStr = \"\";\r\n      currNum = 0;\r\n    } else if (str[i] === \"]\") {\r\n      let prevNum = stack.pop();\r\n      let prevStr = stack.pop();\r\n      currStr = prevStr + currStr.repeat(prevNum);\r\n    } else if (str[i] >= \"0\" && str[i] <= \"9\") {\r\n      currNum = currNum * 10 + Number(str[i]);\r\n    } else {\r\n      currStr += str[i];\r\n    }\r\n  }\r\n  return currStr;\r\n};```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jin03041209":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agentzzz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"suukii":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992041436","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n## S1: 中心扩展法\n\n这是最符合直觉的思路，对每个字符分别进行如下处理：\n\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 `C`。\n- 只在一个方向找到的话，直接计算字符距离。\n- 两个方向都找到的话，取两个距离的最小值。\n\n[https://camo.githubusercontent.com/efaa1cd00bcef4ff7e2cf0c5cd7a37a60d403cf9f82439dffb63a1a48dcf3e06/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f3832315f302e706e67](https://camo.githubusercontent.com/efaa1cd00bcef4ff7e2cf0c5cd7a37a60d403cf9f82439dffb63a1a48dcf3e06/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f3832315f302e706e67)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        vector<int> res(S.length());\n\n        for (int i = 0; i < S.length(); i++) {\n            if (S[i] == C) continue;\n\n            int left = i;\n            int right = i;\n            int dist = 0;\n\n            while (left >= 0 || right <= S.length() - 1) {\n                if (S[left] == C) {\n                    dist = i - left;\n                    break;\n                }\n                if (S[right] == C) {\n                    dist = right - i;\n                    break;\n                }\n\n                if (left > 0) left--;\n                if (right < S.length() - 1) right++;\n            }\n\n            res[i] = dist;\n        }\n\n        return res;\n    }\n}\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 结果数组 res\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n\n- ****Time:**** $O(N^2)$，N 为 S 的长度，两层循环。\n- ***Space:** $O(1)$*\n\n## S2: 空间换时间\n\n空间换时间是编程中很常见的一种 trade-off (反过来，时间换空间也是)。\n\n- 因为目标字符 `C` 在 `S` 中的位置是不变的，所以我们可以提前将 `C` 的所有下标记录在一个数组 `cIndices` 中。\n- 然后遍历字符串 `S` 中的每个字符，到 `cIndices` 中找到距离当前位置最近的下标，计算距离。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> c_indices;\n        // Initialize a vector of size n with default value n.\n        vector<int> res(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) c_indices.push_back(i);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) {\n                res[i] = 0;\n                continue;\n            }\n\n            for (int j = 0; j < c_indices.size(); j++) {\n                int dist = abs(c_indices[j] - i);\n                if (dist > res[i]) break;\n                res[i] = dist;\n            }\n        }\n\n        return res;\n    }\n};\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 记录 C 字符在 S 字符串中出现的所有下标\n  var cIndices = [];\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) cIndices.push(i);\n  }\n\n  // 结果数组 res\n  var res = Array(S.length).fill(Infinity);\n\n  for (let i = 0; i < S.length; i++) {\n    // 目标字符，距离是 0\n    if (S[i] === C) {\n      res[i] = 0;\n      continue;\n    }\n\n    // 非目标字符，到下标数组中找最近的下标\n    for (const cIndex of cIndices) {\n      const dist = Math.abs(cIndex - i);\n\n      // 小小剪枝一下\n      // 注：因为 cIndices 中的下标是递增的，后面的 dist 也会越来越大，可以排除\n      if (dist >= res[i]) break;\n\n      res[i] = dist;\n    }\n  }\n  return res;\n};\n```\n\n- ****Time:**** $O(N*K)$，N 是 S 的长度，K 是字符 `C` 在字符串中出现的次数，*K <= N*。\n- ***Space:** $O(K)$，*K 为字符 `C` 出现的次数，这是记录字符 `C` 出现下标的辅助数组消耗的空间。\n\n## S3: 贪心\n\n其实对于每个字符来说，它只关心离它最近的那个 `C` 字符，其他的它都不管。所以这里还可以用贪心的思路：\n\n1. 先 `从左往右` 遍历字符串 `S`，用一个数组 left 记录每个字符 `左侧` 出现的最后一个 `C` 字符的下标；\n2. 再 `从右往左` 遍历字符串 `S`，用一个数组 right 记录每个字符 `右侧` 出现的最后一个 `C` 字符的下标；\n3. 然后同时遍历这两个数组，计算距离最小值。\n\n**优化 1**\n\n再多想一步，其实第二个数组并不需要。\n\n因为对于左右两侧的 `C` 字符，我们也只关心其中距离更近的那一个，所以第二次遍历的时候可以看情况覆盖掉第一个数组的值：\n\n1. 字符左侧没有出现过 `C` 字符\n2. `i - left` > `right - i` (i 为当前字符下标，left 为字符左侧最近的 `C` 下标，right 为字符右侧最近的 `C` 下标)\n\n如果出现以上两种情况，就可以进行覆盖，最后再遍历一次数组计算距离。\n\n**优化 2**\n\n如果我们是直接记录 `C` 与当前字符的距离，而不是记录 `C` 的下标，还可以省掉最后一次遍历计算距离的过程。\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n        vector<int> dist(n, n);\n\n        for (int i = 0; i < n; i++) {\n            if (S[i] == C) dist[i] = 0;\n            else if (i > 0) dist[i] = dist[i - 1] + 1;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (dist[i] == n\n                || (i < n - 1 && dist[i + 1] + 1 < dist[i]))\n                    dist[i] = dist[i + 1] + 1;\n        }\n\n        return dist;\n    }\n};\n```\n\n```jsx\n/**\n * 优化1：覆盖最近距离\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  // 第一次遍历：从左往右\n  // 找到出现在左侧的 C 字符的最后下标\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = i;\n    // 如果左侧没有出现 C 字符的话，用 Infinity 进行标记\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1];\n  }\n\n  // 第二次遍历：从右往左\n  // 找出现在右侧的 C 字符的最后下标\n  // 如果左侧没有出现过 C 字符，或者右侧出现的 C 字符距离更近，就更新 res[i]\n  for (let i = S.length - 1; i >= 0; i--) {\n    if (res[i] === Infinity || res[i + 1] - i < i - res[i]) res[i] = res[i + 1];\n  }\n\n  // 计算距离\n  for (let i = 0; i < res.length; i++) {\n    res[i] = Math.abs(res[i] - i);\n  }\n  return res;\n};\n\n/**\n * 优化2: 直接计算距离\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) res[i] = 0;\n    // 记录距离：res[i - 1] + 1\n    else res[i] = res[i - 1] === void 0 ? Infinity : res[i - 1] + 1;\n  }\n\n  for (let i = S.length - 1; i >= 0; i--) {\n    // 更新距离：res[i + 1] + 1\n    if (res[i] === Infinity || res[i + 1] + 1 < res[i]) res[i] = res[i + 1] + 1;\n  }\n\n  return res;\n};\n```\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ***Space:** $O(1)$*\n\n## S4: 窗口\n\n把 `C` 看成分界线，将 `S` 划分成一个个窗口。然后对每个窗口进行遍历，分别计算每个字符到窗口边界的距离最小值。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/07bbb9ef-1f56-41b2-9272-d313af7af06a/Untitled.png)\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string S, char C) {\n        int n = S.length();\n\n        int l = S[0] == C ? 0 : n;\n        int r = S.find(C, 1);\n\n        vector<int> dist(n);\n\n        for (int i = 0; i < n; i++) {\n            dist[i] = min(abs(i - l), abs(r - i));\n            if (i == r) {\n                l = r;\n                r = S.find(C, r + 1);\n            }\n        }\n\n        return dist;\n    }\n};\n```\n\n```jsx\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\n  let l = S[0] === C ? 0 : Infinity,\n    // 窗口右边界\n    r = S.indexOf(C, 1);\n\n  const res = Array(S.length);\n\n  for (let i = 0; i < S.length; i++) {\n    // 计算字符到当前窗口左右边界的最小距离\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n\n    // 遍历完了当前窗口的字符后，将整个窗口右移\n    if (i === r) {\n      l = r;\n      r = S.indexOf(C, l + 1);\n    }\n  }\n\n  return res;\n};\n```\n\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 for _ in range(n)]\n\n        l = 0 if s[0] == c else n\n        r = s.find(c, 1)\n\n        for i in range(n):\n            res[i] = min(abs(i - l), abs(r - i))\n            if i == r:\n                l = r\n                r = s.find(c, l + 1)\n        return res\n```\n\n- ****Time:**** $O(N)$，N 是 S 的长度。\n- ***Space:** $O(1)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993310567","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## S1: 模拟\n\n直观思路是在增量操作时进行模拟，每次进行增量操作时都遍历指定的 k 个元素，但这样时间复杂度是 $O(N)$。\n\n时间优化思路是，既然我们只有在出栈时才考虑元素的值，何不将增量操作延后到出栈时，如此便需要将所有增量操作都先存起来。\n\n- 借助另一个容器来记录增量操作。\n- 在出栈时，将栈顶元素加上增量弹出，并更新增量记录。\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize): max_size_(maxSize) {\n        stack_.resize(maxSize);\n        add_.resize(maxSize);\n    }\n    \n    void push(int x) {\n        if (top_ < max_size_ - 1) {\n            top_++;\n            stack_[top_] = x;\n        }\n    }\n    \n    int pop() {\n        if (top_ == -1) return -1;\n        int res = stack_[top_] + add_[top_];\n        if (top_ > 0) add_[top_ - 1] += add_[top_];\n        add_[top_] = 0; \n        top_--;\n        return res;\n\n    }\n    \n    void increment(int k, int val) {\n        int idx = min(k - 1, top_);\n        if (idx >= 0) add_[idx] += val;\n    }\nprivate:\n    vector<int> stack_;\n    vector<int> add_;\n    int top_ = -1;\n    int max_size_;\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n- ****Time:**** $O(1)$，所有操作的时间复杂度都是 $O(1)$。\n- ***Space:** $O(N)$*，使用了一个长度为 maxSize 的辅助数组来记录增量操作。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994202891","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n## S1: 递归\r\n\r\n![https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67](https://camo.githubusercontent.com/cfacf3e8bb0851bd0b122e218ad63e5ab2abf6d23d439dadf638ecb72298de74/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f747265652e706e67)\r\n\r\n`n[string]` 表示解析 `[]` 模板里面的内容，然后重复 `n` 次，即得到 `n` 个 `string` 拼接起来的字符串。\r\n\r\n根据题意，`[]` 里面还可以再嵌套 `[]` ，例如 `n[m[string]]`。这种情况下，我们得先解析最内层的模板，重复 `m` 次，然后将 `m * string` 的结果作为外层模板的解析内容，再重复 `n` 次。\r\n\r\n如果嵌套的层数更多，我们也是得先找到最内层的 `[]`，就像洋葱一样，一层层剥开，然后再从内到外一层层解析和拼接。这种层层嵌套的描述很容易就让人想到了递归。\r\n\r\n按照常规，写递归时不要过多考虑前后的递归函数，想好当前递归函数需要处理些什么就好了。\r\n\r\n- 在每个递归函数里我们处理一段没有嵌套模版的字符串。\r\n- 遇到英文字母时，进行简单的拼接。\r\n- 遇到数字时，累加数字。\r\n- 遇到 `[` 时，说明接下来是一个嵌套模版，开始递归处理。递归处理嵌套模版结束后，我们回到了当前递归层级，需要的信息有两个：\r\n    1. 嵌套模版的解码字符串\r\n    2. 嵌套模版的结束坐标\r\n- 获得嵌套模版的解码字符串后，重复 n 次拼接到当前层级的解码字符串中，接着从嵌套模版的结束坐标开始继续处理当前层级的字符串。\r\n- 遇到 `]` 时，说明处理当前层级模版的递归可以结束了，返回上一种情况需要的信息，解码字符串以及模版结束的坐标。\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        return decodeString(s, 0).first;\r\n    }\r\n\r\n    pair<string, int> decodeString(string s, int cur) {\r\n        int k = 0;\r\n        string decoded;\r\n        while (cur < s.size()) {\r\n            // 收集数字\r\n            if (isdigit(s[cur])) {\r\n                k = k * 10 + s[cur] - '0';\r\n                cur++;\r\n            }\r\n            // 收集字母\r\n            else if (isalpha(s[cur])) {\r\n                decoded.push_back(s[cur]);\r\n                cur++;\r\n            }\r\n            // 开始解析下一层嵌套\r\n            else if (s[cur] == '[') {\r\n                pair<string, int> res = decodeString(s, cur + 1);\r\n                // 解析完嵌套模式后\r\n                while (k-- > 0) {\r\n                    decoded.append(res.first);\r\n                }\r\n                k = 0;\r\n                cur = res.second;\r\n            }\r\n            // 结束当前递归\r\n            else if (s[cur] == ']') {\r\n                return {decoded, cur + 1};\r\n            }\r\n        }\r\n        return {decoded, -1};\r\n    }\r\n};\r\n```\r\n\r\n```jsx\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s, cur = 0) {\r\n    let k = 0;\r\n    let decoded = '';\r\n    while (cur < s.length) {\r\n        if (s[cur] === '[') {\r\n            const [str, pos] = decodeString(s, cur + 1);\r\n            decoded += str.repeat(k);\r\n            k = 0;\r\n            cur = pos;\r\n        } else if (s[cur] === ']') {\r\n            return [decoded, cur + 1];\r\n        } else if (/[0-9]/.test(s[cur])) {\r\n            k = k * 10 + parseInt(s[cur++]);\r\n        } else {\r\n            decoded += s[cur++];\r\n        }\r\n    }\r\n    return decoded;\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\r\n- ***Space:** $O(N)$*\r\n\r\n## S2: 循环+栈\r\n\r\n可以用递归解决的问题，也可以用循环+栈来解决。\r\n\r\n这里我用了正则 `/[a-zA-Z]+|[0-9]+|\\[|\\]/` 和 `exec()` 方法来遍历字符串并把它们拆分成 `token`，比如，`lz3[ab2[c]]` 会被拆分成 `lz`, `3`, `[`, `ab`, `2`, `[`, `c`, `]`, `]`。\r\n\r\n1. 遇到字母块 (`lz`)、数字时，入栈；\r\n2. 遇到 `[` 时，入栈，用来标识当前进入一个模板解析了；\r\n3. 遇到 `]` 时，说明当前模板遍历完了，我们可以开始解析了。\r\n    1. 开始出栈，把出栈的字母块都拼接起来。\r\n    2. 等出栈到 `[` 时，说明当前模板解析完成了。\r\n    3. 继续出栈一个元素，这个元素就是当前模板要重复的次数。\r\n    4. 把 `字母块 * 次数` 重新入栈，这是因为模板是可嵌套的，当前模板外面可能还有一层模板，所以我们要把当前层级的解析结果重新入栈，接着解析外层的模板。\r\n\r\n![https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67](https://camo.githubusercontent.com/cf2e9f7f12b4e571df77f88ec55ce574760d221c5b4551e0a179d361aad35f98/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f7375756b69692f39312d646179732d616c676f726974686d2f6173736574732f6465636f64655f737472696e675f737461636b2e706e67)\r\n\r\n```jsx\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    const reg = /[a-zA-Z]+|[0-9]+|\\[|\\]/g;\r\n    const stack = [];\r\n    const peek = () => stack[stack.length - 1]; // p.s. 这是一个不正经的栈\r\n\r\n    while (reg.lastIndex < s.length) {\r\n        let token = reg.exec(s)[0];\r\n        if (token !== ']') {\r\n            // 数字，字母，左括号通通入栈\r\n            stack.push(token);\r\n        } else {\r\n            // 遇到右括号就开始出栈\r\n            let str = '';\r\n            // [] 中间的就是要重复的模式，把它们全部出栈，拼接起来\r\n            while (peek() !== '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            // 丢掉左括号\r\n            stack.pop();\r\n            // 左括号前面的一定是模式重复的次数\r\n            const num = +stack.pop();\r\n            // 把复制操作后的字符串放回栈中，作为外层 [] 模式的一部分\r\n            stack.push(str.repeat(num));\r\n        }\r\n    }\r\n    return stack.join('');\r\n};\r\n```\r\n\r\n- ****Time:**** $O(N)$，N 是解码后字符串的长度。\r\n- ***Space:** $O(N)$*","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995352740","body":"[Link to LeetCode Problem](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## S1: 优化模拟\n\n维护两个栈，一个用来写 (push)，一个用来读 (pop)。\n\n往写栈中 push，从读栈中 pop。当读栈为空时，将写栈中的数据全部倒入读栈中。\n\n```cpp\nclass MyQueue {\npublic:\n    /** Initialize your data structure here. */\n    MyQueue() {\n    }\n    \n    /** Push element x to the back of queue. */\n    void push(int x) {\n        write_stack_.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    int pop() {\n        if (read_stack_.empty()) pour_();\n        int value = read_stack_.top();\n        read_stack_.pop();\n        return value;\n    }\n    \n    /** Get the front element. */\n    int peek() {\n        if (read_stack_.empty()) pour_();\n        return read_stack_.top();\n    }\n    \n    /** Returns whether the queue is empty. */\n    bool empty() {\n        return read_stack_.empty() && write_stack_.empty();\n    }\nprivate:\n    stack<int> write_stack_;\n    stack<int> read_stack_;\n\n    void pour_() {\n        while (!write_stack_.empty()) {\n            read_stack_.push(write_stack_.top());\n            write_stack_.pop();\n        }\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n- ****Time:**** `push` 是 $O(1)$，`pop` 均摊下来也是 $O(1)$，连续 N 次的 push 才会碰到一次 $O(N)$ 的 pop。\n- ***Space:** $O(N)$*","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingyingchu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"newbeenoob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"samaritan1998":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992431278","body":"## 字符的最短距离\n\n双向遍历的思想\n\n- 从左向右遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 i - prev。\n- 从右向左遍历，记录上一个字符 C 出现的位置 prev，那么答案就是 prev - i。\n- 这两个值取最小就是答案。\n\n```python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: \n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] == C: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\n\n时间复杂度和空间复杂度都为O(n)\n\n像这样双向遍历的题还有   分发糖果","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993133904","body":"## 设计一个支持增量操作的栈\n\n- 初始化栈\n- push和pop\n- 栈底的 k 个元素的值都增加 val\n\n```python\nclass CustomStack:\n\n    #初始化,maxSize为栈最多能容纳的元素数量\n    def __init__(self, maxSize: int):\n        self.st=[0]*maxSize\n        self.top=-1\n\n    #将元素x添加到栈顶   \n    def push(self, x: int) -> None: \n        if self.top != len(self.st) - 1:\n            self.top += 1\n            self.st[self.top] = x\n\n    #弹出栈顶元素        \n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    # 栈底的 k 个元素的值都增加 val\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n```\n\n此类设计题需要先分析时间空间复杂度，选定合适的数据结构\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a0bb94d-5f53-4234-be93-279d4e7c753d/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0a0bb94d-5f53-4234-be93-279d4e7c753d/Untitled.png)\n\n贴一个C++解法\n\n```cpp\nclass CustomStack {\nprivate:\n    vector<int> vc;\n    int maxSize;\npublic:\n    CustomStack(int maxSize_) {\n        maxSize = maxSize_;\n        vc.clear();\n        vc.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if (vc.size() == maxSize) {\n            return;\n        }\n        vc.push_back(x);\n    }\n    \n    int pop() {\n        if (vc.empty()) {\n            return -1;\n        }\n        int res = vc.back();\n        vc.pop_back();\n        return res;\n    }\n    \n    void increment(int k, int val) {\n        int len=0;\n        len = std::min( k, int(vc.size()) );\n        for (int i = 0; i < len; ++i) {\n            vc[i] += val;\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994681985","body":"## 字符串解码\n\ns = \"3[a]2[bc]\"      \"aaabcbc\"\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        numStack=[] #存倍数\n        strStack=[] #存待拼接的字符串\n        num=0\n        result=''\n        for c in s:\n            if c.isdigit(): #遇到数字\n                num=num*10+int(c) \n            elif c=='[':    #遇到[\n                strStack.append(result) #result串入栈\n                result=''  #result清零\n                numStack.append(num)\n                num=0\n            elif c==']':    #遇到]\n                repeatTime=numStack.pop()\n                result=strStack.pop()+result*repeatTime\n            else:           #遇到字母\n                result+=c\n\n        return result\n```\n\nnum 暂存数字 遇到左括号入栈 num清零   遇到右括号从栈中取出数字作为倍数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995803666","body":"## 两个栈实现队列\n\n```python\nclass CQueue:\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n    def appendTail(self, value: int) -> None: #入栈是放到入栈栈里\n        self.stack_in.append(value)\n\n    def deleteHead(self) -> int:\n        if not self.stack_out:  # 出栈栈为空\n            if not self.stack_in: # 都为空\n                return -1\n            else: # 把in栈中的东西全部倒入out栈中\n                while self.stack_in:\n                    self.stack_out.append(self.stack_in.pop())\n        \n        return self.stack_out.pop()\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ginnydyy":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991993182","body":"## Problem\r\nhttps://leetcode.com/problems/shortest-distance-to-a-character/\r\n\r\n## Note\r\n- Intuition: scan once and mark all the c index. scan again to calculate the distance comparing the marked index.\r\n- Improvement: scan once from left to right and calculate the initial distance. scan again from right to left and update the distance. Note that from left to right, need to use Integer.MIN_VALUE / 2 to avoid overflow.\r\n\r\n## Solution\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        if(s == null || s.isEmpty()){\r\n            return null;\r\n        }\r\n        \r\n        int[] res = new int[s.length()];\r\n        \r\n        int left = Integer.MIN_VALUE / 2;\r\n        for(int i = 0; i < s.length(); i++){\r\n            if(s.charAt(i) == c){\r\n                left = i;\r\n            }\r\n            res[i] = Math.abs(i - left);\r\n        }\r\n        \r\n        int right = Integer.MAX_VALUE;\r\n        for(int i = s.length() - 1; i >= 0; i--){\r\n            if(s.charAt(i) == c){\r\n                right = i;\r\n            }\r\n            res[i] = Math.min(res[i], Math.abs(right - i));\r\n        }\r\n        \r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n) n is the length of s.\r\n- S: O(1) no extra space is required.\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992774750","body":"## Problem\r\nhttps://leetcode.com/problems/design-a-stack-with-increment-operation/\r\n\r\n## Note\r\n- Use int array and record the maxSize and curSize\r\n\r\n## Solution\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n## Complexity\r\n- T: O(1) for push and pop, O(k) for increment.\r\n- S: O(n) n is the max size of the stack.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993936277","body":"## Problem\r\nhttps://leetcode.com/problems/decode-string/\r\n\r\n## Note\r\n- Stack\r\n- ']' is the key to decide in stack or out stack\r\n- Note that there are embeded cases\r\n\r\n## Solution\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if(s == null || s.isEmpty()){\r\n            return null;\r\n        }\r\n        \r\n        int n = s.length();\r\n        int cur = 0;\r\n        Stack<Character> stack = new Stack<>();\r\n        while(cur < n){\r\n            char c = s.charAt(cur);\r\n            if(c != ']'){\r\n                stack.push(c);  \r\n            }else{\r\n                List<Character> letters = new LinkedList<>();\r\n                while(!stack.isEmpty() && stack.peek() != '['){\r\n                    letters.add(0, stack.pop());\r\n                }\r\n                \r\n                stack.pop(); // pop the '['\r\n                \r\n                StringBuilder digits = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek())){\r\n                    digits.insert(0, stack.pop());\r\n                }\r\n                int num = Integer.parseInt(digits.toString());\r\n                for(int i = 0; i < num; i++){\r\n                    for(char letter: letters){\r\n                        stack.push(letter);\r\n                    }\r\n                }\r\n            }\r\n            cur++;\r\n        }\r\n        \r\n        StringBuilder sb = new StringBuilder();\r\n        while(!stack.isEmpty()){\r\n            sb.insert(0, stack.pop());\r\n        }\r\n        \r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n\r\n## Complexity\r\n- T: O(n). n is the length of the decoded string of s.\r\n- S: O(n). n is the length of the decoded string of s.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995059482","body":"## Problem\r\nhttps://leetcode.com/problems/implement-queue-using-stacks/\r\n\r\n## Note\r\n- Stack\r\n- No need to use size variable to make the current queue size. Only need to use stack's api.\r\n\r\n## Solution\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> inStack;\r\n    Stack<Integer> outStack;\r\n    \r\n\r\n    public MyQueue() {\r\n        inStack = new Stack<>();\r\n        outStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        inStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(outStack.empty()){\r\n            toOutStack();\r\n        }\r\n        return outStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(outStack.empty()){\r\n            toOutStack();\r\n        }\r\n        return outStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return inStack.empty() && outStack.empty();\r\n    }\r\n    \r\n    private void toOutStack(){\r\n        while(!inStack.isEmpty()){\r\n            outStack.push(inStack.pop());\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## Complexity\r\n- T: O(1) for push and empty methods. Amortized O(1) for pop and peek methods.\r\n- S: O(n) n is the size of the queue.","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"GemZq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littlemoon-zh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xbhog":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"st2yang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiezhengyun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kofzhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymkymk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"15691894985":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992154137","body":"day【2】题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character\n```python\n    class Solution(object):\n        def shortestToChar(self, S, C):\n            prev = float('-inf')\n            ans = []\n            for i, x in enumerate(S):\n                if x == C: prev = i\n                ans.append(i - prev)\n    \n            prev = float('inf')\n            for i in xrange(len(S) - 1, -1, -1):\n                if S[i] == C: prev = i\n                ans[i] = min(ans[i], prev - i)\n            return ans\n```\n复杂度分析\n\n- 时间复杂度：O(N)，其中 NN 是 S 的长度，遍历字符串两次。\n- 空间复杂度：O(N)，ans 数组的大小。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993648209","body":"【Day 3】1381. 设计一个支持增量操作的栈\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n1.使用list模拟栈，用变量top记录末尾元素\n\n2.push:直接在对应坐标（top+1）赋值\n\n3.pop ：返回list末尾值，对应top对应减1\n\n4.increment： 直接K和list中的k个较小值，然后，对应元素加Val，如果少于K全加\n```java\n    class CustomStack{\n        int[] length;\n        int index;\n        int maxSize;\n    \n        public CustomStack(int maxSize) {\n            length = new int[maxSize];\n            index = 0;\n            this.maxSize = maxSize;\n        }\n        public void push(int x){\n            if (index < maxSize){\n                length[index++] = x;\n            }\n        }\n        public int pop(){\n            if (index > 0){\n                return length[--index];\n            }else{\n                return -1;\n            }\n        }\n    \n        public void increment(int k, int val){\n            if (k > maxSize){\n                for (int i = 0; i < maxSize; i++){\n                    length[i] += val;\n                }\n                }else{\n                for (int i=0 ;i < k;i++){\n                        length[i] += val;\n                    }\n                }\n            }\n        \n    }\n```\n复杂度：\n\n时间复杂度：increment是O(N) pop、push 是O(1)\n\n空间复杂度：O(N)栈容量\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994534031","body":"day【4】题目地址(394. 字符串解码)\r\n\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n思考：成对的[]最后是重复的字符串，[前的数字是重复的次数，因此先讨论以下规则：\r\n\r\n- 如果是字母-添加到stack 当中\r\n- 如果是数字—先不急加入stack，因为可能有多位数字\r\n- 如果[，说明重复字符串开始，将数字入栈，并且数字清零\r\n- 如果是]说明字符串结束将重复字符串重复前存储的数字遍\r\n```python\r\n    class Solution:\r\n        def decodeString(self, s: str) -> str:\r\n            stack = []\r\n            for c in s:\r\n                if c == ']':#对前面的字符进行操作重复\r\n                    repeatStr = ''\r\n                    repeatCount = ''\r\n                    while stack and stack[-1] != '[':\r\n                        repeatStr = stack.pop() + repeatStr\r\n                    stack.pop()#去掉“[”\r\n                    while stack and stack[-1].isnumeric():\r\n                        repeatCount = stack.pop() + repeatCount\r\n                    stack.append(int (repeatCount) * repeatStr)\r\n                else:\r\n                    stack.append(c)\r\n            return \"\".join(stack)\r\n```\r\n复杂度：\r\n\r\n时间复杂度：O(N*k) 0整个字符串长度，k最大重复 \r\n\r\n空间复杂度：O(N)栈容量 解码后的长度 \r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995396694","body":"### 【Day 5】232. 用栈实现队列\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n```python\nclass MyQueue(object):\n    def __init__(self):\n    \tself.stack=[]\n    def push(self,x):\n        self.stack.append(x)\n    def pop(self):\n    \ta = self.stack[0]\n        self.stack = self.stack[1:]\n        return a\n    def peek(self):\n        return self.stack[0]\n    def empty(self):\n        if len(self.stack)!=0:\n            return False\n        else:\n            return True\n```\n\n复杂度：\n\n时间复杂度：push:O(1)   peek:O(1)  empty：O(1) pop:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feikerwu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xj-yan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991819951","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num2 = list()\n        while k:\n            tmp = k % 10\n            num2.append(tmp)\n            k //= 10\n        num2.reverse()\n        i, j = len(num) - 1, len(num2) - 1\n        isCarried = False\n        res = list()\n        while i >= 0 or j >= 0 or isCarried:\n            digit = (num[i] if i >= 0 else 0) +  (num2[j] if j >= 0 else 0) + (1 if isCarried else 0)\n            isCarried = True if digit >= 10 else False\n            res.append(digit % 10)\n            i -= 1\n            j -= 1\n        res.reverse()\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992551556","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n, pos = len(s), -float('inf')\n        res = [n] * n\n        for i in list(range(n)) + list(range(n)[::-1]):\n            if s[i] == c:\n                pos = i\n            res[i] = min(res[i], abs(i - pos))\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993673807","body":"```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.max_size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.max_size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if len(self.stack) >= 1:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n```\nTime Complexity: O(k), Space Complexity: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994916790","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        num = 0\n        for i in range(len(s)):\n            c = s[i]\n            if c.isnumeric():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append(res)\n                stack.append(num)\n                res = \"\"\n                num = 0\n            elif c.isalpha():\n                res += c\n            elif c == \"]\":\n                pre_num = stack.pop()\n                pre_string = stack.pop()\n                res = pre_string  + pre_num * res\n        return res\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995199441","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        self.in_stack, self.out_stack = [], []\n\n    def push(self, x: int) -> None:\n        self.in_stack.append(x)\n\n    def move(self) -> None:\n       if not self.out_stack:\n            while self.in_stack: self.out_stack.append(self.in_stack.pop())     \n                \n    def pop(self) -> int:\n        self.move()\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.out_stack[-1]\n\n    def empty(self) -> bool:\n        return (not self.in_stack) and (not self.out_stack)\n```\nTime Complexity: O(n), Space Complexity: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ychen8777":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilixikun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"peteruixi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"user1689":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xieyj17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shamworld":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991877147","body":"```js\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992047270","body":"```js\nvar shortestToChar = function(s, c) {\n    let arr = [];\n    let result = [];\n    for(let i = 0;i < s.length; i++){  \n        if(s[i]===c){\n            arr.push(i)\n        }\n    }\n    for(let i = 0;i < s.length; i++){\n        if(s[i]===c){\n            result[i] = 0;\n            continue\n        }\n        \n        for(let index of arr){\n            let res = Math.abs(index-i);\n            console.log(result)\n            if(res>=result[i]) break;\n            result[i] = res;\n        }\n    }\n    return result\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993123116","body":"```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stackList = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stackList.length>=this.maxSize) return null;\n    this.stackList.push(x); \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    \n    if(this.stackList.length==0) return -1;\n    return this.stackList.pop();\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    if(k<this.stackList.length){\n        for(let i = 0; i < k; i++){\n            this.stackList[i] += val\n        }\n    }else{\n        for(let i = 0; i < this.stackList.length; i++){\n            this.stackList[i] += val\n        }\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994220422","body":"```js\nvar decodeString = function(s) {\n    let numList = [];//数组数组\n    let numStr = \"\";//数组长度 \n    let str=\"\";//中括号里面的字符串\n    let stackList = [];//字符串数组\n    let result = \"\";\n    for(let i = 0; i < s.length;i++){\n        let n = s.charAt(i);\n        if(n>=0&&n<=9){\n            numStr += n;\n        } else if (n === '['){\n            numList.push(numStr);\n            stackList.push(str);\n            str = \"\";\n            numStr = \"\";\n        } else if (n === ']'){\n            let num = numList.pop();\n            let temp = \"\"\n            for(let j = 0;j < num; j++){\n                temp += str;\n            }\n            let stackStr = stackList.length>0?stackList.pop():'';\n            str = stackStr+temp; \n            // console.log(result,stackStr,temp);\n            if(numList.length==0){\n                result += str;\n                str = \"\";\n            }\n        } else {\n            if(numList.length==0){\n                result += n;\n            }else{\n                str += n; \n            }\n            \n        }\n    }\n    return result;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995375875","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.stackInList = [];\n    this.stackOutList = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.stackInList.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    return this.stackOutList.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.stackOutList.length){\n        while(this.stackInList.length){\n            this.stackOutList.push(this.stackInList.pop());\n        }\n    }\n    if(!this.stackOutList.length) return null;\n    return this.stackOutList[this.stackOutList.length-1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.stackOutList.length && !this.stackInList.length\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"learning-go123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a244629128":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhousibao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ysy0707":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunupdong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"machuangmr":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903092","body":"### 代码\r\n```java\r\nclass Solution {\r\n    // 思路： 1、将数组的最后一个元素和k的个位开始相加，\r\n    //       2、大于10 就向前进一位（k的前一位 + 1）\r\n     //        3、 重复以上步骤直到数组和k的位数结束\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n     List<Integer> rest = new LinkedList<>();\r\n    int len = num.length - 1;\r\n    for(int i = len;i >= 0;i--) {\r\n        int total = num[i] + k % 10;\r\n        //取 除过后一位的前面的值\r\n        k /= 10;\r\n        if(total >= 10) {\r\n            //大于10，则前面的值需要进1\r\n            k++;\r\n            total = total % 10;\r\n        }\r\n        rest.add(total);\r\n    }\r\n    while(k > 0) {\r\n        rest.add(k % 10);\r\n        k /=10;\r\n    }\r\n     Collections.reverse(rest);\r\n     return rest;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度O(N)\r\n- 空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992533315","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n    int[] arr = new int[s.length()];\r\n    // 从左到右遍历，则每个s[i]的值为， 当前下标减去上个元素C的下标\r\n     int pre = Integer.MIN_VALUE / 2;\r\n     for(int i = 0;i < arr.length;i++) {\r\n         if(s.charAt(i) == c) {\r\n             pre = i;\r\n         }\r\n         arr [i] = i - pre;\r\n     }\r\n\r\n     // 从右边向右边遍历，则\bs[i]的值就等于 pre - i ;\r\n      pre = Integer.MAX_VALUE;\r\n     for(int i = s.length() -1;i >=0;i--){\r\n         if(s.charAt(i) == c) {\r\n             pre = i;\r\n         }\r\n        arr[i] = Math.min(arr[i], pre - i);\r\n     }\r\n        return arr;\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993340372","body":"### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] arr = null;\r\n    int currentSize = -1;\r\n    int maxSize = 0;\r\n    public CustomStack(int maxSize) {\r\n     arr = new int[maxSize];\r\n     this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n     if(currentSize == maxSize - 1){\r\n         return ;\r\n     }\r\n     arr[++currentSize] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(currentSize == -1) {\r\n            return -1;\r\n        }\r\n      return arr[currentSize--];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n       int size = currentSize < k - 1 ? currentSize : k -1;\r\n       for(int i = 0;i <= size;i++) {\r\n           arr[i] +=val;\r\n       }\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度，push，pop O(1) ,incre: O(N)\r\n- 空间复杂度  O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994581368","body":"### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n    // 利用一个栈来存储字符\r\n    Stack<String> stack = new Stack();\r\n    for(int i = 0;i < s.length();i++) {\r\n        if(Character.isDigit(s.charAt(i)) || '[' == s.charAt(i)\r\n            || Character.isLowerCase(s.charAt(i))) {\r\n            stack.push(String.valueOf(s.charAt(i)));\r\n            continue;\r\n        }\r\n        if(']' == s.charAt(i)) {\r\n           List<String> c = new ArrayList<>();\r\n           while(!stack.isEmpty() &&!stack.peek().equals(\"[\")) {\r\n               c.add(stack.pop());\r\n           }\r\n           stack.pop();\r\n           Collections.reverse(c);\r\n           // 求[ 的数字\r\n           List<String> digit = new ArrayList();\r\n           while(!stack.isEmpty() && Character.isDigit(stack.peek().charAt(0))) {\r\n               digit.add(stack.pop());\r\n           }\r\n           Collections.reverse(digit);\r\n            // 内嵌括号中的字符串\r\n           String used = getUsdString(c);\r\n           // 内嵌括号中前面的数字\r\n           int value = Integer.parseInt(getUsdString(digit));\r\n           StringBuilder sb = new StringBuilder();\r\n           while(value-- > 0) {\r\n             sb.append(used);\r\n           }\r\n           stack.push(sb.toString());\r\n        }\r\n     }\r\n     List<String> res = new ArrayList<>();\r\n     while(!stack.isEmpty()) {\r\n         res.add(stack.pop());\r\n     }\r\n     Collections.reverse(res);\r\n     return getUsdString(res);\r\n    }\r\n\r\n    public String getUsdString(List<String> param) {\r\n        StringBuilder sb = new StringBuilder();\r\n        for(String str: param) {\r\n            sb.append(str);\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n````\r\n### 复杂度\r\n- 时间复杂度 O(N)\r\n- 空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995688768","body":"### 代码\r\n```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = null;\r\n    Stack<Integer> s2 = null;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        s1 = new Stack();\r\n        s2 = new Stack();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n         s1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n          if (s2.isEmpty()) {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wang-hejie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iambigchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991853617","body":"### 思路\n逐位相加，如果大于9，就要进位\n\n### 代码\n```js\nvar addToArrayForm = function(num, k) {\n    k = String(k).split('')\n    var length = Math.max(num.length, k.length)\n    var res = new Array(length).fill(0)\n    for (let index = length-1; index >= 0; index--) {\n        var a = num.length > 0 ? num.pop() : 0\n        var b  = k.length > 0 ?  k.pop() : 0\n        var sum = res[index] + a + +b\n        res[index] = sum % 10\n        if (sum > 9) {\n            if (index-1 >= 0) {\n                res[index - 1] = 1\n            } else {\n                res.unshift(1)\n            }\n        }\n    }\n    return res\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992074069","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n遍历s每个值，如果当前值正好是c，则跳过。否则，从当前值向左、右分别遍历，直到遇到c，再计算左右的最短距离。\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let res = new Array(s.length).fill(0)\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            continue\n        }\n        let l = i - 1\n        let r = i + 1\n        let disL = Infinity\n        let disR = Infinity\n        while(l >= 0) {\n            if (s[l] === c) {\n                disL = Math.abs(i - l)\n                break\n            } else {\n                l--\n            }\n        }\n        while(r < s.length) {\n            if (s[r] === c) {\n                disR = Math.abs(i - r)\n                break\n            } else {\n                r++\n            }\n        }\n        res[i] = Math.min(disL, disR)\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(1)$\n\n\n## 思路2\n\n先用数组存下所有c出现过的下标，再次遍历s，计算当前值和每个c出现过下标的距离，求出最小值\n\n## 关键点\n\n再次遍历s，计算最小距离时，因为indexArr存的是c出现过的下标，是递增，所以可以做一次剪枝\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let res = new Array(s.length).fill(0)\n    let indexArr = []\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            indexArr.push(i)\n        }\n    }\n\n    for(let i = 0; i<s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n            continue\n        }\n        let dist = Infinity\n        for(let j = 0; j< indexArr.length; j++) {\n            if (Math.abs(indexArr[j] - i) >= dist) {\n                break\n            }\n           dist = Math.abs(indexArr[j] - i)\n        }\n        res[i] = dist\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。k 为c在s出现过的次数。\n\n- 时间复杂度：$O(n*k)$\n- 空间复杂度：$O(k)$\n\n\n## 思路3\n\n第一次遍历，让s存下当前索引i左侧离着最近的c的坐标。只需要判断看i-1是否有值即可。\n\n第二次遍历，从右至左，判断当前索引i， res的左侧是否有c，或者 左侧到c的距离是否比右侧(i+1)的距离小，如果没有，则更新当前i 的值，更新成右侧的值\n\n第三次遍历，计算当前每个值和索引的距离\n\n## 关键点\n\n可以让res直接存当前距离，而不是索引来减少最后计算距离的遍历。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    var res = Array(s.length);\n    \n    for(let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = i\n        } else [\n            res[i] = res[i-1] == void 0 ? Infinity : res[i-1]\n        ]\n    }\n\n    for(let i = s.length -1; i >= 0; i--) {\n        if (res[i] == Infinity || i - res[i] > res[i+1] - i) {\n            res[i] = res[i+1]\n        }\n    }\n\n    for (let i = 0; i < res.length; i++) {\n        res[i] = Math.abs(i -res[i])\n    }\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(3n)$\n- 空间复杂度：$O(n)$\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    var res = Array(s.length);\n    \n    for(let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            res[i] = 0\n        } else [\n            res[i] = res[i-1] == void 0 ? Infinity : res[i-1] + 1\n        ]\n    }\n\n    for(let i = s.length -1; i >= 0; i--) {\n        if (res[i] == Infinity || res[i] > res[i+1] + 1) {\n            res[i] = res[i+1] + 1\n        }\n    }\n\n    return res\n  };\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(2n)$\n- 空间复杂度：$O(n)$\n\n\n## 思路4\n\n定义l和r，分别表示当前窗口左侧c的下标和右侧的下标。只需要计算在窗户内元素到两个边界的距离即可。如果遍历到达右侧边界时，将整个窗口向后移。\n\n## 关键点\n\nindexOf的第二个参数表示从第几个开始查询，第二个参数传为当前左侧边框下标，即可\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function (s, c) {\n    let res = Array(s.length)\n    let l = s[0] === c ? 0 : -Infinity\n    let r = s.indexOf(c, 0)\n\n    for(let i = 0; i < s.length; i++) {\n        res[i] = Math.min(Math.abs(i-l), Math.abs(i-r))\n        if (i === r) {\n            l = r\n            r = s.indexOf(c, l+1)\n        }\n    }\n\n    return res\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993129731","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n用数组模拟栈\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.val = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.val.length < this.maxSize) {\n        this.val.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.val.length === 0) {\n        return -1\n    }\n    return this.val.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(var i =0; i< k;i++) {\n        if (i < this.val.length) {\n            this.val[i] = this.val[i] + val\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n\n\n## 思路\n\n用increments来存所有的increment操作，increment[i]表示前i个值都加increment[i]值\n\n在pop的时候，只需要把栈顶值取出，加increment[i]。在更新维护increment[i-1]，将increment[i-1] 变成 increment[i] + increment[i-1]。然后重置increment[i]为0即可\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n    this.increments = Array(maxSize).fill(0)\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length < this.maxSize) {\n        this.list.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (this.list.length === 0) return -1\n    let i = this.list.length - 1\n    this.increments[i-1] += this.increments[i]\n    let res = this.list.pop() + this.increments[i]\n    this.increments[i] = 0\n    return res\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let i = Math.min(k, this.list.length) -1\n    if (i >= 0) {\n        this.increments[i] += val\n    }\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994250486","body":"## 思路\n\n利用栈存下非`]`字符, 遇到`]`时，进行取栈。取栈时，注意栈顶的值是字符串、数字、还是`[`。如果是字符串，则继续拼接需要重复的字符串。如果是数字，则继续拼接需要重复的次数。因为`[`和`]`是成对存在的，所以在判断是否是数字，只需要判断不是`[`即可。\n\n## 关键点\n\n在组装完重复的字数后，一定要在取一次栈顶，因为此时的栈顶是`[`。\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n    for (const c of s) {\n        if (c == ']') {\n           let repeacStr = ''\n           let repeacNum = ''\n           while(stack.length && stack[stack.length -1] !== '[') {\n               repeacStr = stack.pop() + repeacStr\n           }\n           stack.pop()\n           while(stack.length && !isNaN(stack[stack.length -1])) {\n                repeacNum = stack.pop() + repeacNum\n            }\n            stack.push(repeacStr.repeat(Number(repeacNum)))\n        } else {\n            stack.push(c)\n        }\n    }\n    return stack.join('')\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n## 思路2\n\n每遇到`[]`，就递归`[]`内部的字符串，重复组装好后返回。递归体是，遇到`[`进入递归，遇到`]`结束递归。遇到数字和字符串，还是继续拼接。\n\n## 关键点\n\n- \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    function dfs (start) {\n        let repeatStr = ''\n        let repeatNum = ''\n        while(start < s.length) {\n            if (!isNaN(s[start])) {\n                repeatNum = repeatNum + s[start]\n            } else if (s[start] === '[') {\n                let [dfs_start, dfs_str] = dfs(start+1)\n                start = dfs_start\n                repeatStr = repeatStr + dfs_str.repeat(Number(repeatNum))\n                repeatNum = ''\n            } else if (s[start] === ']') {\n                return [start, repeatStr]\n            } else {\n                repeatStr = repeatStr + s[start]\n            }\n            start++\n        }\n        return repeatStr\n    }\n    return dfs(0)\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995381069","body":"## 思路\n\n用栈实现队列，需要将栈整体倒序，借助于另外一个栈B. A.pop -> B.push 即可实现。每次push时，需要先将栈A复原再push，push完后再做倒序操作\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/*\n * @lc app=leetcode.cn id=232 lang=javascript\n *\n * [232] 用栈实现队列\n */\n\n// @lc code=start\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.list = []\n    this.helpstack = []\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    while(this.list.length) {\n        this.helpstack.push(this.list.pop())\n    }\n    this.helpstack.push(x)\n    while(this.helpstack.length) {\n        this.list.push(this.helpstack.pop())\n    }\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n   return  this.list.pop()\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.list[this.list.length-1]\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.list.length === 0\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ningli12":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjsuper":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993117832","body":"```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.s = []\r\n        self.ms = maxSize\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.s)==self.ms:\r\n            pass\r\n        else:\r\n            self.s.append(x)\r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.s:\r\n            return -1\r\n        temp = self.s.pop()\r\n        return temp\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k >= len(self.s):\r\n            self.s = [i+val for i in self.s]\r\n        else:\r\n            for i in range(0,k):\r\n                self.s[i] += val       \r\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994138418","body":"```\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        curs = ''\r\n        curn = 0\r\n        for i in s:\r\n            if i=='[':\r\n                stack.append((curs,curn))\r\n                curs = ''\r\n                curn = 0                \r\n            elif i.isdigit():\r\n                curn = curn*10+int(i)\r\n            elif i == ']':\r\n                cs,cn = stack.pop()\r\n                curs = cs+cn*curs\r\n            else:\r\n                curs += i\r\n        return curs\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"siyuelee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"miss1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doveshnnqkl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taojin1992":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834328","body":"# Understand:\r\n```\r\n1. num array won't be empty, no leading 0's, each digit is valid [0,9]\r\n2. k is non-negative, 1 <= k <= 10^4\r\n3. output most significant -> least significant\r\n4. k can have more digits\r\n\r\ncarry,\r\n99 + 1 -> 100\r\n98 + 1 -> 99\r\n789 + 12 -> 801\r\n1 + 99 -> 100\r\n```\r\n# Plan:\r\n```\r\ngo backward from the least significant digit, record carry and current sum digit, update k\r\n\r\ncheck k > 0\r\n\r\ncheck if carry == 1\r\n\r\nuse a linkedlist and insert into the head\r\n```\r\n# Evaluate:\r\n```\r\nTime: O(number of digits inside num + number of digits inside k) \r\n= O(nums.length + number of digits inside k) = O(max(nums.length, logk))\r\n\r\nSpace: O(max(nums.length, number of digits inside k) = O(max(nums.length, logk))\r\n\r\n```\r\n\r\n# Code:\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> sum = new LinkedList<>();\r\n        int carry = 0, newDigit = 0;\r\n        for (int pos = num.length - 1; pos >= 0; pos--) {\r\n            newDigit = num[pos] + k % 10 + carry;\r\n            carry = newDigit / 10;\r\n            newDigit %= 10;\r\n            sum.addFirst(newDigit);\r\n            k /= 10;\r\n        }\r\n        while (k > 0) {\r\n            newDigit = k % 10 + carry;\r\n            carry = newDigit / 10;\r\n            newDigit %= 10;\r\n            sum.addFirst(newDigit);\r\n            k /= 10;\r\n        }\r\n        \r\n        if (carry == 1) {\r\n            sum.addFirst(1);\r\n        }\r\n        return sum;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992584131","body":"\n# Understand:\n```\nIt is guaranteed that c occurs at least once in s.\ns[i] and c are lowercase English letters.\n1 <= s.length <= 10^4\n```\n# Plan:\n```\n\"record array\" to record the closest c index on its left\nthen record the closest c index on its right -> we can overwrite the same array with min value\n\nnote: no match on its left/right corner case\n\nmatch is guaranteed to exist though, either on its left or right\n```\n# Review:\n```\nInput: s = \"loveleetcode\", c = \"e\"\nOutput: [3,2,1,0,1,0,0,1,2,2,1,0]\n0.   1.  2. 3. 4  5  6. 7. 8. 9. 10 11\nl    o   v  e  l  e  e  t  c  o  d  e\n-1, -1, -1, 0, 1. 0. 0  1. 2  3. 4. 0   -> record, left to right\n3  , 2,  1 ,0, 1. 0. 0  1. 2  2. 1. 0\n\n\n\"aaba\"\n\"b\"\n```\n\n# Evaluate:\n```\nTime: O(s.length())\nSpace: O(s.length())\n```\n\n# Code:\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] record = new int[s.length()];\n        int curIndex = 0, nearestL = -1, nearestR = -1;\n        for (curIndex = 0; curIndex < s.length(); curIndex++) {\n            if (s.charAt(curIndex) == c) {\n                record[curIndex] = 0; \n                nearestL = curIndex;\n            } else {\n                record[curIndex] = nearestL == -1 ? -1 : curIndex - nearestL;\n            }\n        }\n        /// go from right to left, overwrite the original record array\n        for (curIndex = s.length() - 1; curIndex >= 0; curIndex--) {\n            if (s.charAt(curIndex) == c) {\n                nearestR = curIndex;\n            } else {\n                if (record[curIndex] == -1) { // left is invalid, then right is guaranteed to be valid\n                    record[curIndex] = nearestR - curIndex;\n                } else {    \n                    // two cases here: is right valid? -> can we find a match on its right?\n                    if (nearestR != -1) {\n                        record[curIndex] = Math.min(record[curIndex], nearestR - curIndex);\n                    }\n                }\n            }\n        }\n        return record;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993685604","body":"```\nclass CustomStack {\n    int capacity;\n    int size;\n    List<Integer> stack;\n    List<Integer> inc;\n    \n    public CustomStack(int maxSize) {\n        capacity = maxSize;\n        size = 0;\n        stack = new ArrayList<>();\n        inc = new ArrayList<>();\n    }\n    \n    public void push(int x) {\n        if (size < capacity) {\n            stack.add(x);  // stack: bottom -> top\n            inc.add(0);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size == 0) return -1;\n        \n        int ans = stack.get(size - 1) + inc.get(size - 1);\n        // at least 1 element left after popping\n        if (size >= 2) {\n            inc.set(size - 2, inc.get(size - 2) + inc.get(size - 1));\n        }\n        \n        // remove the tail of inc and stack lists\n        inc.remove(size - 1); // by index, O(1)\n        stack.remove(size - 1); // this line is needed in list implementation, as we use stack[size] = x; in array but use add(x) in list implementation\n        \n        size--;\n        \n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        // empty check\n        if (size > 0) {\n            inc.set(Math.min(k, size) - 1, inc.get(Math.min(k, size) - 1) + val);\n        }\n    } \n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994925628","body":"\n# Understand:\n```\n1 <= s.length <= 30\ns consists of lowercase English letters, digits, and square brackets '[]'.\ns is guaranteed to be a valid input.\nAll the integers in s are in the range [1, 300].\n\nInput: s = \"3[a2[c]]\"\nOutput: \"accaccacc\"\n\nk is guaranteed to be a positive integer\n\nyou may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.\n```\n# Plan: \n```\n\n2 stacks, Stack<StringBuilder>, Stack<Integer> \n\nk can be greater than 10\n\nif we see digit, build the complete integer (curFreq * 10 + s.charAt(curIndex) - '0')\n\nif we see letter, build the complete string (by curStr.append(s.charAt(curIndex));)\n\nif we see [, push curStr and curFreq into respective stacks, reset\n\n*if we see ], \ncurStr is the string to repeat\npop the top string, append the repeated string after it, it becomes the curStr\n```\n\n# Review:\n```\nInput: s = \"a3[a2[c]]e\"\nOutput: \"aaccaccacce\"\n\n\nc\n\na   2\na   3\n\n\nacc\n\na  3\n\ncurStr: aaccaccacc\n\ncurStr: aaccaccacce\n```\n# Evaluate: \n```\nTime: O(decoded res length)\n\nSpace: O(decoded res length)\n```\n\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        if (s.length() == 1) return s;\n        Stack<Integer> freqStack = new Stack<>();\n        Stack<StringBuilder> strStack = new Stack<>();\n        \n        int curIndex = 0;\n        StringBuilder curStr = new StringBuilder();\n        int curFreq = 0;   \n        \n        while (curIndex < s.length()) {\n            if (Character.isLetter(s.charAt(curIndex))) {\n                curStr.append(s.charAt(curIndex));\n            }\n            else if (Character.isDigit(s.charAt(curIndex))) {\n                curFreq = curFreq * 10 + s.charAt(curIndex) - '0';\n            }\n            else if (s.charAt(curIndex) == '[') {\n                strStack.push(curStr);\n                curStr = new StringBuilder();\n                \n                freqStack.push(curFreq);\n                curFreq = 0;\n            } else if (s.charAt(curIndex) == ']') {  // this part needs caution\n                StringBuilder temp = curStr; // temp is the str to repeat\n                curStr = strStack.pop();\n                \n                StringBuilder resStr = new StringBuilder();\n                int freq = freqStack.pop();\n                \n                for (int i = 0; i < freq; i++) {\n                    curStr.append(temp);\n                }\n                \n            }\n            curIndex++;\n        }\n        return curStr.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995437678","body":"```\r\nAll the calls to pop and peek are valid.\r\n\r\nTwo stacks, push only from one stack, pop only from the other stack (feeding each other before each operation)\r\n\r\nTime: O(1) amortized\r\nSpace: O(n)\r\n```\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> pushStack;\r\n    Stack<Integer> popStack;\r\n    \r\n    public MyQueue() {\r\n        pushStack = new Stack<>();\r\n        popStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while (!popStack.isEmpty()) {\r\n            pushStack.push(popStack.pop());\r\n        }\r\n        pushStack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while (!pushStack.isEmpty()) {\r\n            popStack.push(pushStack.pop());\r\n        }\r\n        return popStack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return pushStack.isEmpty() && popStack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"septasset":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennyxcao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"james20141606":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"muimi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallili":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"benngfour":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ergwang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mixtureve":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freedom0123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leolisgit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuliangyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chun1hao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"m-z-w":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinmenghan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lxy030988":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"HarryPangPang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheUsername":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwpanda":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992086263","body":"``` JavaScrpit\nconst shortestToChar = (s, c)=>{\n  s=s.split('');\n  let res = [];\n  //loop through the string array\n  for (let i=0; i<s.length; i++) {\n    let dist = Infinity;\n    if(s[i] === c) {\n      res.push(0);\n      continue;\n    }\n    \n    //nested loop to find the closest index\n    //counting forward from current i \n    for(let j=i; j<s.length; j++) {\n      if(s[j] === c) {\n        dist = j-i;\n        break;\n      }\n    }\n    //counting backward from current i\n    for(let j=i; j>=0; j--) {\n      if(s[j] === c) {\n        dist = Math.min(dist, i-j);\n        break;\n      }\n    }\n    res.push(dist);\n  }//end loop string array\n  return res;\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Nina1031":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fengchen321":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maqianxiong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hewenyi666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flame0409":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dongzegithub":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xy147":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ccslience":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiaowenhe":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843707","body":"```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int n = num.size() - 1;\n        int cur = k;\n        vector<int> result;\n        while(n >= 0 || cur)\n        {\n            if(n>=0)\n            {\n                cur = cur + num[n];\n            }\n            result.push_back(cur%10);\n            cur = cur / 10;\n            n--;\n        }\n        reverse(result.begin(), result.end());\n        return result;\n\n    }\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992234694","body":"##思路\r\n左右两边分别遍历，求最小距离\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, S: str, C: str) -> List[int]:\r\n        results = []\r\n        pos = float('-inf')\r\n        for i in range(len(S)):\r\n            if S[i] == C:\r\n                pos = i\r\n            results.append(i - pos)\r\n        pos = float('inf')\r\n        for i in range(len(S)-1,-1,-1):\r\n            if S[i] == C:\r\n                pos = i\r\n            results[i] = min(results[i],(pos - i))\r\n        return results\r\n```\r\n\r\n## 复杂度\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993365730","body":"```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) == 0:\r\n            return -1\r\n        a = self.stack[-1]\r\n        self.stack = self.stack[:-1]\r\n        return a\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        k = min(k ,len(self.stack))\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994694504","body":"```python3\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n\r\n        stack = []\r\n        for char in s:\r\n            if char != \"]\":\r\n                stack.append(char)\r\n            else:\r\n                sub_str = \"\"\r\n                while(1):\r\n                    ss = stack.pop()\r\n                    if ss != \"[\":\r\n                        sub_str = ss + sub_str\r\n                    else:\r\n                        break\r\n                int_value = ''\r\n                while(1):\r\n                    if len(stack) > 0 and stack[-1] >= '0' and stack[-1] <= '9':\r\n                        int_value = stack.pop() + int_value\r\n                    else:\r\n                        int_value = int(int_value)\r\n                        break\r\n\r\n                sub_str = int_value * sub_str\r\n                stack.append(sub_str)\r\n\r\n        return (\"\").join(stack)\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mglslg":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"max-qaq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tobepellucid":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sxr000511":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"july-aha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xyinghe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joriscai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cy-sues":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867656","body":"## code\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List <Integer> arr = new ArrayList <Integer>();\n        for(int i=num.length-1;i>=0;i--){\n            int p=k%10;\n            k=k/10;\n            int sum = num[i]+p;\n            if(sum>=10){\n                k+=1;\n                sum-=10;\n            }\n            arr.add(sum);\n        }\n        for(;k>0;k=k/10){\n            int s= k%10;\n            arr.add(s);\n        }\n        Collections.reverse(arr);\n        return arr;\n    }\n}\n```","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994819648","body":"## 思路\r\n数字一个栈，字母一个栈\r\n## Code\r\n```java\r\npublic String decodeString(String s) {\r\n        \r\n        Stack<Character> stack = new Stack<>();\r\n        \r\n        for(char c : s.toCharArray())\r\n        {\r\n            if(c != ']') \r\n                stack.push(c); // 把所有的字母push进去，除了]\r\n            \r\n            else \r\n            {\r\n                //step 1: 取出[] 内的字符串\r\n                \r\n                StringBuilder sb = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\r\n                    sb.insert(0, stack.pop());\r\n                \r\n                String sub = sb.toString(); //[ ]内的字符串\r\n                stack.pop(); // 去除[\r\n                \r\n                \r\n                //step 2: 获取倍数数字\r\n                    \r\n                sb = new StringBuilder();\r\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\r\n                    sb.insert(0, stack.pop());\r\n                    \r\n                int count = Integer.valueOf(sb.toString()); //倍数\r\n                \r\n                \r\n                //step 3: 根据倍数把字母再push回去\r\n                \r\n                while(count > 0)\r\n                {\r\n                    for(char ch : sub.toCharArray())  \r\n                        stack.push(ch);\r\n                    count--;\r\n                }\r\n            }\r\n        }\r\n        \r\n      //把栈里面所有的字母取出来，完事L('ω')┘三└('ω')｣\r\n        StringBuilder retv = new StringBuilder();\r\n        while(!stack.isEmpty())\r\n            retv.insert(0, stack.pop());\r\n\r\n        return retv.toString();\r\n    }\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shenzhengkang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryzhao5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mosihan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babbomax98":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Brandylulu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivalkshfoeif":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yibenxiao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ray-hr":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991898710","body":"# 思路 \n 1.列竖式法 \n\n2.低位到高位相加 \n \n3.考虑进位位  \n\n4.取反\n# 代码 \n```python  \n \nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        p1 = len(num) - 1\n        carry = 0\n        res = []\n        while p1 >= 0 or k != 0 or carry > 0:\n            adder1 = num[p1] if p1 >= 0 else 0\n            adder2 = k % 10\n            sum = adder1 + adder2 + carry\n            carry = 1 if sum >= 10 else 0\n            sum = sum - 10 if sum >= 10 else sum\n            res.append(sum)\n            p1 -= 1\n            k //= 10\n        return res[::-1]\n\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992337008","body":"# 思路 \n贪心 \n# 代码 \n```python \nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        res = [0 if s[i] == c else None for i in range(n)]\n\n        for i in range(1, n):\n            if res[i] != 0 and res[i - 1] is not None:\n                res[i] = res[i - 1] + 1\n\n        for i in range(n - 2, -1, -1):\n            if res[i] is None or res[i + 1] + 1 < res[i]:\n                res[i] = res[i + 1] + 1\n        return res\n``` ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993676939","body":"# 思路 \nincrement并不提前造好maxSize长度，而是根当前栈长度同步增加长度，省一点空间 \n# 代码 \n```python \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n        self.size = 0\n        self.incrementals = []\n        \n    def push(self, x: int) -> None:\n        if(self.size < self.maxSize):\n            self.stack.append(x)\n            self.incrementals.append(0)\n            self.size += 1\n\n    def pop(self) -> int:\n        if(self.size == 0):\n            return -1\n        self.size -= 1\n        if(self.size >= 1):\n            self.incrementals[-2] += self.incrementals[-1]\n        return self.stack.pop() + self.incrementals.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if self.incrementals:\n            self.incrementals[min(k, self.size) - 1] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994717130","body":"# 思路 \n两个栈实现 \n# 代码 \n```python \nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []  # (str, int) 记录左括号之前的字符串和左括号外的上一个数字\n        num = 0\n        res = \"\"  # 实时记录当前可以提取出来的字符串\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995436141","body":"# 思路 \n一个输入栈一个输出栈 \n# 代码 \n```python \nclass MyQueue:\n\n    def __init__(self):\n\n       self.stack_in = []\n       self.stack_out = []\n\n    def push(self, x: int) -> None:\n\n        self.stack_in.append(x)\n\n    def pop(self) -> int:\n         if self.empty():\n            return None\n\n         if self.stack_out:\n             return self.stack_out.pop()\n         else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n \n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nekomoon404":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chen-ds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"minuet-red":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mokrs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niyaolanggeyo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bowlofnoodles":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jerry9926":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kendj-staff":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asterqian":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jmstart":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lizzy-123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"edge-wzw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"20donkey":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lzcyx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naomiwufzz":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992425638","body":"## **思路: 正反双指针**\n\n正向和负向各计算一次，每次一个指针找c一个指针指向尚未计算的元素\n\n### **代码**\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s)] * len(s)\n        i = 0\n        for j in range(len(s)):\n            if s[j] == c:\n                while i <= j:\n                    res[i] = min(res[i], j-i)\n                    i += 1\n        i = len(s) - 1\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                while i >= j:\n                    res[i] = min(res[i], i-j)\n                    i -= 1\n        return res\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n) n是s长度\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993489193","body":"## **思路1：用数组模拟**\n\n朴素的模拟方法\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = list()\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.stack) < k:\n            self.stack = [n+val for n in self.stack]\n        else:\n            self.stack = [n+val for n in self.stack[:k]] + self.stack[k:]\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(n) push pop是O(1)，increment是O(n)\n- 空间复杂度：O(1)\n\n## **思路2：前缀和思想**\n\n用一个incrementals数组来记录加的数字最远加到哪里。在pop出去的时候只要对应找该位置加了多少即可，不需要全部都记录\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(maxsize/n)  把n当作操作数的话，平均来看是maxsize/n？？？\n\n## **思路3：空间优化的前缀和**\n\nincrementals在操作的时候才更新而不是初始化的时候更新\n\n### **代码**\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.st = []\n        self.cnt = 0\n        self.size = maxSize\n        self.increments = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n        \n    def pop(self) -> int:\n        if self.cnt == 0:\n            return -1\n        # 如果只剩一个元素，直接是pop出去\n        # 如果多于一个元素，pop出去的同时，更前面的元素要继承一下加的val\n        if self.cnt >= 2:\n            self.increments[self.cnt-2] += self.increments[self.cnt-1]\n        res = self.st.pop() + self.increments[self.cnt-1]\n        self.increments[self.cnt-1] = 0\n        self.cnt -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        # 分界线的地方+val，只在pop的时候才考虑加多少\n        if self.cnt:\n            self.increments[min(k, self.cnt)-1] += val\n        \n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(1)\n- 空间复杂度：O(cnt/n)  把n当作操作数的话，平均是cnt/n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994737977","body":"## **思路：栈**\n\n碰到右括号的时候出栈，其他都是进栈，需要注意的是，数字可能是多位数\n\n### **代码**\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != \"]\":\n                if char.isdigit() and stack and stack[-1].isdigit():\n                    stack.append(stack.pop()+char)\n                else:\n                    stack.append(char)\n            else:\n                cur = \"\"\n                while stack and stack[-1] != \"[\":\n                    cur = stack.pop() + cur\n                if cur:\n                    stack.pop()\n                    stack.append(int(stack.pop()) * cur)\n        return \"\".join(stack)\n```\n\n### **复杂度分析**\n\n- 时间复杂度：O(2n)\n- 空间复杂度：O(n)用了一个cur作为中间变量","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaysonss":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maxsarratt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bxcharlie":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zszs97":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yj9676":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carreylife":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fzzfgbw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsyxiaoba":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carterrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ff1234-debug":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzhsaga":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"heyqz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Clarence5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aatoe":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyifan2018":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eemsyw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linearindep":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iciue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiayinya":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chaggle":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sqshada":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daidaidashixiong666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xingkong1994":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"itsjacob":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alwaysbest":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pzl233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangshisong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baoqin87":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"MusicOfWind":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingcai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuetong3yu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995792391","body":"- [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n用两个栈来模拟队列的操作。\n\n因为要用栈的特性来实现队列，因此不能直接操作数组的头节点。\n\n核心思路：**用一个额外的栈空间倒腾一下**。\n\n```js\nvar MyQueue = function () {\n  this.stack = []\n  this.reverseStack = []\n}\n\n/**\n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function (x) {\n  this.stack.push(x)\n}\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function () {\n  if (!this.reverseStack.length) {\n    this.move()\n  }\n  return this.reverseStack.pop()\n}\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function () {\n  if (!this.reverseStack.length) this.move()\n  return this.reverseStack[this.reverseStack.length - 1]\n}\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function () {\n  return !this.stack.length && !this.reverseStack.length\n}\n\nMyQueue.prototype.move = function () {\n  while (this.stack.length) {\n    this.reverseStack.push(this.stack.pop())\n  }\n}\n```\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kbfx1234":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893740","body":"#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n```python\n// 91-day1-python\n\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        i = len(num) - 1\n        carry = 0\n        res = []\n        while i >= 0 or k != 0:\n            x = num[i] if i >= 0 else 0\n            y = k % 10 if k != 0 else 0\n\n            sum = x + y + carry\n            res.append(sum % 10)\n            carry = sum // 10\n\n            i -= 1\n            k //= 10\n        if carry != 0: res.append(carry)\n        return res[::-1]\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992598594","body":"#### [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n```cpp\n// 12-13\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993654649","body":"#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n```cpp\n// cpp 12-14\nclass CustomStack {\npublic:\n    int top;\n    vector<int> stk;\n    CustomStack(int maxSize) {\n        stk = vector<int>(maxSize, 0);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top + 1 < stk.size())\n            stk[++top] = x;\n    }\n    \n    int pop() {\n        if(top != -1)\n            return stk[top--];\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < k && i < stk.size(); ++i) {\n            stk[i] += val;\n        }\n\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994917977","body":"#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n```cpp\n//12-15\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<int> nums;\n        stack<string> let;\n        int num = 0;\n        string res = \"\";\n        for (auto i : s) {\n            if (i >= '0' && i <= '9') {\n                num = num * 10 + i - '0';\n            }\n            else if (i == '[') {\n                nums.push(num);\n                num = 0;\n                let.push(res);\n                res = \"\";\n            }\n            else if (i == ']') {\n                int k = nums.top();\n                nums.pop();\n                string temp = let.top();\n                for (int i = 0; i < k; i++) {\n                    temp += res;\n                }\n                res = temp;\n                let.pop();\n            }\n            else {\n                res += i;\n            }\n        }\n        return res;\n    }\n};\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crypteee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzcyes":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yliboom":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenbihao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuanaxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brainlds":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flagyk5":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuajingliu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891349","body":"#### 解题思路\n  1. 低位到高位逐位将数字加在一起\n  2. 若加法的结果大于等于 1010，把进位的 11 加入到下一位的计算中\n#### 代码实现\n\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度: O(max(n,logk), 其中 nn 为数组的长度\n- 空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992530602","body":"#### 解题思路\n- 从当前下标出发，分别向左、右两个方向去寻找目标字符 C。\n- 如果只在一个方向找到，直接计算字符距离。\n- 如果两个方向都找到，取两个距离的最小值\n\n#### 代码实现\n\n```\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n  const res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n#### 复杂度分析\n- 时间复杂度：$O(N^2)$，N 为 S 的长度，两层循环。\n- 空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993570481","body":"### 基础版\n### 思路\n  用数组模拟栈，用数组原生方法pop、push方法实现\n  \n### 代码\n\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if (this.stack.length >= this.maxSize) {\n    return;\n  }\n  this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  return this.stack.length ? this.stack.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  const length = Math.min(k, this.stack.length);\n  for (let i = 0; i < length; i++) {\n    this.stack[i] += val;\n  }\n};\n```\n### 复杂度\n- 时间复杂度 \n\n  push: O(1)\n\n  pop：O(1)\n  \n  increment：O(K) \n \n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994744108","body":"### 思路\n1. 将字符串从末尾开始遍历\n2. 遇到“]”入栈\n3. 拼接要出栈的字符串，遇到\"[\"出栈\n4. \"[\"后紧跟数据，累计最终的数字\n5. 将遍历后入栈的字符串出栈，进行反转拼接，得到最终结果\n\n### 代码\n\n```\n/**\n * @param {string} s\n * @return {string}\n */\n var decodeString = function(s) {\n    let stack = []; // 定义存储字符串的栈\n    let str = \"\"; // 定义最终返回的字符串\n    let num = \"\"; // 定义字符串重复的次数\n    const length = s.length;\n    for (let i = length - 1; i >= 0; i--) {\n      console.log(\"s[i]\", stack, i);\n      if (s[i] >= \"0\" && s[i] <= \"9\") {\n        // 解析出连续的数字\n        while (s[i] >= \"0\" && s[i] <= \"9\") {\n          num += s[i];\n          i--;\n          console.log(\"num\", num);\n        }\n        stack.push(\n          str.repeat(\n            Number(\n              num\n                .split(\"\")\n                .reverse()\n                .join(\"\")\n            )\n          )\n        ); // 拼接字符\n        str = \"\";\n        num = \"\"; //清空计数\n        i++;\n      } else if (s[i] === \"[\") {\n        // 遇到\"[\"时，将后续字符出栈\n        let curStr = stack.pop();\n        while (curStr !== \"]\") {\n          str += curStr;\n          curStr = stack.pop(); // 拼接出栈的字符串 \"[\"后跟着的一定是数字\n        }\n      } else {\n        // 将字符 或 \"]\"入栈\n        stack.push(s[i]);\n      }\n    }\n    return stack.reverse().join(\"\");\n  };\n```\n\n### 复杂度分析\n- 时间复杂度：O(n),循环遍历一遍\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995867065","body":"### 解题思路\n    定义两个栈，\n-   一个是pushStack, 执行push操作时，将元素入pushStack栈\n-   另一个是popStack,执行pop操作时，在popStack取元素；当popStack栈为空时，依次将pushStack元素pop取出，push进pushStack栈\n\n\n### 代码实现\n```\nvar MyQueue = function() {\n    this.pushStack = [];\n    this.popStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.pushStack.push(x)\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(this.popStack.length === 0) {\n        while(this.pushStack.length > 0) {\n            this.popStack.push(this.pushStack.pop())\n        }\n    }\n    return this.popStack[this.popStack.length - 1];\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.popStack.length === 0 && this.pushStack.length === 0;\n};\n\n```\n### 复杂度分析\n- 时间复杂度 $O(1)$\n- 空间复杂度 $O(N)$, N为队列元素个数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moxiaopao278":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guangsizhongbin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991821310","body":"```go\r\nfunc addToArrayForm(num []int, k int) (ans []int) {\r\n\r\n    // 考虑直接相加k\r\n    for i := len(num) - 1; i >= 0 || k > 0; i-- {\r\n        if i >= 0 {\r\n            k += num[i]\r\n        }\r\n        ans = append(ans, k % 10)\r\n        k /= 10\r\n    }\r\n    reverse(ans)\r\n    return\r\n}\r\n\r\n// 反序的时候，直接头与尾相交换\r\nfunc reverse(num []int){\r\n    for i, n := 0, len(num); i < n/2; i++ {\r\n        num[i], num[n-1-i] = num[n-1-i], num[i]\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991993472","body":"```go\r\nfunc shortestToChar(s string, c byte) []int {\r\n    n := len(s)\r\n    res := make([]int, n)\r\n\r\n    // 从左向右遍历, 记录c出现的前一个位置，保存 i - prev\r\n    prev := math.MinInt32 / 3\r\n    for i := 0 ; i < n; i ++ {\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        res[i] = i - prev\r\n    }\r\n\r\n    // 从右向左遍历, 记录c出现的前一个位置，保存 prev - i\r\n    prev = math.MaxInt32 / 3\r\n    for i := n - 1; i >= 0; i --{\r\n        if s[i] == c {\r\n            prev = i\r\n        }\r\n        res[i] = min(res[i] , prev - i)\r\n    }\r\n\r\n    return res\r\n}\r\n\r\nfunc min(a, b int) int {\r\n    if a > b {\r\n        return b\r\n    } else {\r\n        return a\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993170573","body":"```go\r\ntype CustomStack struct {\r\n    stack []int\r\n    size int\r\n}\r\n\r\n\r\nfunc Constructor(maxSize int) CustomStack {\r\n    return CustomStack {\r\n        make([]int, 0),\r\n        maxSize,\r\n    }\r\n\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Push(x int)  {\r\n    if len(this.stack) < this.size {\r\n        this.stack = append(this.stack, x)\r\n    }\r\n\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Pop() int {\r\n    if len(this.stack) > 0{\r\n        res := this.stack[len(this.stack) -1]\r\n        this.stack = this.stack[:len(this.stack)-1]\r\n        return res\r\n    }\r\n    return -1\r\n}\r\n\r\n\r\nfunc (this *CustomStack) Increment(k int, val int)  {\r\n    if k > len(this.stack) {\r\n        k = len(this.stack)\r\n    }\r\n\r\n    for i := 0; i < k; i++{\r\n        this.stack[i] += val\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * obj := Constructor(maxSize);\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * obj.Increment(k,val);\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994840380","body":"```go\r\nfunc decodeString(s string) string {\r\n    _, str := dnf(s,0)\r\n    return str\r\n}\r\n\r\nfunc  dnf( s string , i int) (int,string){\r\n    var mul int\r\n    var str string\r\n    var n int \r\n    var temp string \r\n    for n = i ; n < len(s); n++ {\r\n        if s[n] >= '0' && s[n] <= '9'{\r\n            mul = mul * 10 + int(s[n] - '0')\r\n        }else if( s[n] == '['){\r\n            n,temp = dnf(s,n+1)\r\n            for num := 0 ;  num < mul; num++{\r\n                str = str + temp\r\n            }\r\n            mul = 0\r\n        }else if( s[n] == ']'){\r\n            return n,str\r\n        }else{\r\n            str = str + string(s[n])\r\n        }\r\n    }\r\n    return n, str \r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995271287","body":"```go\r\ntype MyQueue struct {\r\n    inStack, outStack []int\r\n}\r\n\r\n\r\nfunc Constructor() MyQueue {\r\n    return MyQueue{}\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Push(x int)  {\r\n    q.inStack = append(q.inStack, x)\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Pop() int {\r\n    if len(q.outStack) == 0 {\r\n        for len(q.inStack) > 0 {\r\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\r\n            q.inStack = q.inStack[:len(q.inStack) - 1]\r\n        }\r\n    }\r\n    x := q.outStack[len(q.outStack) - 1]\r\n    q.outStack = q.outStack[:len(q.outStack) - 1]\r\n    return x\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Peek() int {\r\n    if len(q.outStack) == 0 {\r\n        for len(q.inStack) > 0 {\r\n            q.outStack = append(q.outStack, q.inStack[len(q.inStack) - 1])\r\n            q.inStack = q.inStack[:len(q.inStack) - 1]\r\n        }\r\n    }\r\n    x := q.outStack[len(q.outStack) - 1]\r\n    return x\r\n}\r\n\r\n\r\nfunc (q *MyQueue) Empty() bool {\r\n    return len(q.outStack) == 0 && len(q.inStack) == 0\r\n}\r\n\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * obj := Constructor();\r\n * obj.Push(x);\r\n * param_2 := obj.Pop();\r\n * param_3 := obj.Peek();\r\n * param_4 := obj.Empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winterdogdog":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yankang233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gentleman-goodman":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991839137","body":"> ### 思路\n>\n> 本来是想着是把两个数加起来，再依次取出个位，添加进结果中，但是这样会溢出。\n>\n> 于是选择从后往前遍历数组，末尾数字相加后添加进结果集中，同时判断一下有没有进位。\n>\n> 最后还要看看 k 和进位等于 0 没有，如果没有还要继续添加进结果集中。\n>\n> 最后需要Collections.reverse(res);反转链表\n>\n> <加法模板>\n>\n> while ( A 没完 || B 没完)\n>\n> A 的当前位\n>\n> B 的当前位\n>\n> 和 = A 的当前位 + B 的当前位 + 进位carry\n>\n> 当前位 = 和 % 10;\n>\n> 进位 = 和 / 10;\n>\n> 判断还有进位吗\n\n```java\nclass Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<>();\n            int carry = 0;//进位\n            int l1 = num.length - 1;//最右边的索引开始\n            while (l1 >= 0 || k != 0) {\n                int x = l1 < 0 ? 0 : num[l1];//最左边，也就是前面没有数了，就附上0\n                int y = k == 0 ? 0 : k % 10;//取余->取出个位数   ////最左边，也就是前面没有数了，就附上0\n                int sum = x + y + carry;\n                carry = sum / 10;\n                res.add(sum % 10);\n                l1--;\n                k = k / 10;\n            }\n            //最左边的carr可能还有，判断是不是0\n            if (carry != 0) {\n                res.add(carry);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n```\n\n> **复杂度分析**\n>\n> - 时间复杂度：O(N)\n> - 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038142","body":"Day2_821_字符的最短距离\n\n> ### 思路\n>\n> ```\n> * 思路 遍历字符串，找到目标字母，并用a数组记下位置 遍历字符串，\n> * 将当前位置与a数组的位置进行相减，取最小值，记住用绝对值。 C语言4ms通过。\n> ```\n\n```java\nclass Solution {\n        public List<Integer> addToArrayForm(int[] num, int k) {\n            List<Integer> res = new ArrayList<>();\n            int carry = 0;//进位\n            int l1 = num.length - 1;//最右边的索引开始\n            while (l1 >= 0 || k != 0) {\n                int x = l1 < 0 ? 0 : num[l1];//最左边，也就是前面没有数了，就附上0\n                int y = k == 0 ? 0 : k % 10;//取余->取出个位数   ////最左边，也就是前面没有数了，就附上0\n                int sum = x + y + carry;\n                carry = sum / 10;\n                res.add(sum % 10);\n                l1--;\n                k = k / 10;\n            }\n            //最左边的carr可能还有，判断是不是0\n            if (carry != 0) {\n                res.add(carry);\n            }\n            Collections.reverse(res);\n            return res;\n        }\n    }\n```\n\n> **复杂度分析**\n>\n> - 时间复杂度：O(n*m)\n>   n:s的长度\n>   m:list的长度\n>\n>   空间复杂度：O(n+m)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993598223","body":"Day3_1381_设计一个支持增量操作的栈_lc题解_数组方法\n\n> ### 思路\n>\n> ```\n> * 思路 看lc官方题解的，利用数组方法stack[]存数据，定义变量top设置栈顶\n> ```\n\n```java\n  class CustomStack {\n        int[] stack;\n        int top;\n\n        public CustomStack(int maxSize) {\n            stack = new int[maxSize];//数组size\n            top = -1;//初始化为-1，之后添加一个就刚好从0开始了\n        }\n\n        //添加\n        public void push(int x) {\n            if(stack.length-1!=top){\n                top++;\n                stack[top] = x;\n            }\n\n        }\n\n        //取出\n        public int pop() {\n            if(top ==-1){\n                return -1;\n            }\n            top--;\n            return stack[top + 1];\n\n        }\n\n        public void increment(int k, int val) {\n            int limit = Math.min(k, top + 1);//k和数组里面的数比较，取小的\n            //数-1 = 引\n            for (int i = 0; i < limit; i++) {\n                stack[i] += val;\n            }\n\n        }\n```\n\n> **复杂度分析**\n>\n> - 复杂度分析\n>\n>   时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)O(1)，inc 操作的渐进时间复杂度为 O(k)O(k)。\n>\n>   空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O({\\rm maxSize})O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878102","body":"Day4_394_字符串解码_lc题解\n\n> ### 思路\n>\n> ```\n> *实在是不会，栈stack不懂，看lc题解的，顺带添加了注释在代码上，引用lc题解的思路，主要就是只利用了一个栈来处理，字符串栈；以下是引用lc思路：\n> 题解这道题其实思路并不难想，因为很容易知道要用栈来解决，但是细节处会有很多不少地方要去注意和深究，首先是栈的使用，前面的题解很多都用了两个栈，一个数字栈，一个字符串栈，我这里的解法就只用一个栈，因为只用一个栈，所以不是字符栈，而是字符串栈stack\n> for循环遍历，分两种情况：\n> 遇到']'\n> 其他\n> 读到这里你可能会感到奇怪，除了]不是还有[、数字、字符这三种情况吗，为什么概括成其他呢，是的，的确如此，但是我们也显然知道]前面一定是字符串，字符串前面一定是[，而[前面也一定是数字，既然如此我们就可以直接全部一起解决\n> 读到]时，用一个while循环将[和]之间的字符串读出，我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n> \n> 作者：CharlesGao\n> 链接：https://leetcode-cn.com/problems/decode-string/solution/javayi-ge-zhan-jian-ji-qing-xi-jie-jue-wen-ti-by-c/\n> ```\n\n```java\n    class Solution {\n        public String decodeString(String s) {\n            int len=s.length();\n            if(len<=0) return \"\";\n            Stack<String> stack=new Stack<>();\n            for(int i=0; i<len; i++){\n                char mid=s.charAt(i);\n                /*读到]时，用一个while循环将[和]之间的字符串读出，\n                我这里用了StringBuilder来提高字符串拼接性能，读出后将[pop删去，\n                然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\n                我就直接用parseInt将字符串转化为数字了，然后是将上述字符串复制num倍，\n                这样处理后再将字符串放回栈中即可，至于其他情况，直接将其转化为字符串压入栈中即可，\n                最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n*/\n\n                //读到]时，用一个while循环将[和]之间的字符串读出，\n                if(mid==']'){\n                    StringBuilder fir=new StringBuilder();\n                    while(!stack.peek().equals(\"[\")){\n                        fir.insert(0,stack.pop());\n                    }\n                    //读出后将[pop删去，\n                    stack.pop();\n\n                    StringBuilder num=new StringBuilder();\n\n                    /*然后开始读数字num了，注意数字可能是很多位数字，这里处理方法很多，\n                    我就直接用parseInt将字符串转化为数字了*/\n                    while(!stack.isEmpty()&&(stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9')){\n                        num.insert(0,stack.pop());\n                    }\n                    int number=Integer.parseInt(num.toString());\n\n                    //，然后是将上述字符串复制num倍，这样处理后再将字符串放回栈中即可\n                    StringBuilder sec=new StringBuilder();\n                    for(int j=0; j<number; j++){\n                        sec.append(fir);\n                    }\n                    stack.push(sec.toString());\n                }\n                //至于其他情况，直接将其转化为字符串压入栈中即可\n                else{\n                    StringBuilder sb=new StringBuilder();\n                    sb.insert(0,mid);\n                    stack.push(sb.toString());\n                }\n            }\n\n            //最后出栈的时候要注意，字符串的总体顺序是反的，故要用insert拼接而不是append\n            StringBuilder res=new StringBuilder();\n            while(!stack.isEmpty()){\n                res.insert(0,stack.pop());\n            }\n            return res.toString();\n        }\n    }\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zulliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"supermeohh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Baiqr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"for123s":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992601931","body":"## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> idxs;\n        for(int i=0;i<s.size();i++)\n            if(s[i]==c)\n                idxs.push_back(i);\n        int l = 0, r = 0;\n        vector<int> res(s.size(),0);\n        int idx = 0;\n        while(r<idxs.size())\n        {\n            if(idx<=idxs[l])\n                res[idx] = idxs[l] - idx;\n            else if(idx>idxs[l]&&idxs[r]>=idx)\n                res[idx] = min(idx-idxs[l],idxs[r]-idx);\n            else\n            {\n                if(l==r)\n                    l--;\n                l++;\n                r++;\n                continue;\n            }\n            idx++;\n        }\n        r--;\n        while(idx<res.size())\n        {\n            res[idx] = idx - idxs[r];\n            idx++;\n        }\n        return res;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993667380","body":"## 代码\n\n- 语言支持：C++\n\nC++ Code:\n\n```c++\n\nclass CustomStack {\nvector<int> st;\nint idx;\npublic:\n    CustomStack(int maxSize) {\n        st.assign(maxSize,0);\n        idx = 0;\n    }\n    \n    void push(int x) {\n        if(idx<st.size())\n            st[idx++] = x; \n    }\n    \n    int pop() {\n        if(idx>0)\n            return st[--idx];\n        return -1;\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<k&&i<idx;i++)\n            st[i] += val;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994905226","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<char> st_c;\r\n        stack<int> st_num;\r\n        for(int i=0;i<s.size();++i)\r\n        {\r\n            if(s[i]>='0'&&s[i]<='9')\r\n            {\r\n                int temp = s[i]-'0';\r\n                while(s[i+1]>='0'&&s[i+1]<='9')\r\n                {\r\n                    ++i;\r\n                    temp = temp * 10 + s[i]-'0';\r\n                }\r\n                st_num.push(temp);\r\n            }\r\n            else if(s[i]==']')\r\n            {\r\n                string temp = \"\";\r\n                while(st_c.top()!='[')\r\n                {\r\n                    temp = st_c.top() + temp;\r\n                    st_c.pop(); \r\n                }\r\n                st_c.pop();\r\n                for(int j=0;j<st_num.top();++j)\r\n                {\r\n                    for(int k=0;k<temp.size();++k)\r\n                    {\r\n                        st_c.push(temp[k]);\r\n                    }\r\n                }\r\n                st_num.pop();\r\n            }\r\n            else\r\n            {\r\n                st_c.push(s[i]);\r\n            }\r\n        }\r\n        string res=\"\";\r\n        while(!st_c.empty())\r\n        {    \r\n            res = st_c.top() + res;\r\n            st_c.pop();\r\n        }\r\n        return res;\r\n    }\r\n};\r\n\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995904894","body":"## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass MyQueue {\r\n    stack<int> in;\r\n    stack<int> out;\r\npublic:\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int temp;\r\n        if(out.empty())\r\n        {\r\n            while(!in.empty())\r\n            {\r\n                temp = in.top();\r\n                in.pop();\r\n                out.push(temp);\r\n            }\r\n        }\r\n        temp = out.top();\r\n        out.pop();\r\n        return temp;\r\n    }\r\n    \r\n    int peek() {\r\n        int temp;\r\n        if(out.empty())\r\n        {\r\n            while(!in.empty())\r\n            {\r\n                temp = in.top();\r\n                in.pop();\r\n                out.push(temp);\r\n            }\r\n        }\r\n        temp = out.top();\r\n        return temp;\r\n    }\r\n    \r\n    bool empty() {\r\n        return in.empty()&&out.empty();\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bolunzhang2021":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simonsayshi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devosend":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991914988","body":"## 思路\r\n从后往前遍历相加。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        for i in range(len(num) - 1, -1, -1):\r\n            k += num[i]\r\n            if k >= 10:\r\n                num[i] = k % 10\r\n                k = k // 10\r\n            else:\r\n                num[i] = k\r\n                return num\r\n\r\n        while k > 0:\r\n            num.insert(0, k % 10)\r\n            k = k // 10\r\n\r\n        return num\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992051439","body":"## 思路\r\n正反两次遍历，取较小的值存储到列表中返回。\r\n## 代码\r\n```\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        result = []\r\n        min = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                min = i\r\n            result.append(i - min)\r\n        \r\n        max = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                max = i\r\n            result[i] = result[i] if result[i] < max - i else max - i\r\n        \r\n        return result\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n)\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993334991","body":"## 思路\r\n使用列表模拟\r\n## 代码\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k > len(self.stack):\r\n            k = len(self.stack)\r\n\r\n        for i in range(k):\r\n            self.stack[i] += val\r\n\r\n```\r\n## 复杂度分析\r\n - 时间复杂度：push: O(1), pop: O(1), inc: O(min(k, maxSize))\r\n - 空间复杂度：O(n)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995606236","body":"## 思路\r\n使用双栈模拟\r\n\r\n## 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop())\r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.s1) == 0 and len(self.s2) == 0\r\n\r\n```\r\n## 复杂度分析\r\n- 时间复杂度：O(n);\r\n- 空间复杂度：O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"comst007":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asuka1h":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biscuit279":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991830092","body":"# 思路：先求A+k的值，再转换成数组形式\n···\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = len(num)\n        A = 0\n        for i,a in enumerate(num):\n            A += a*(10**(n-i-1))\n        ans = A+k\n\n        res = [int(s) for s in str(ans)]\n        return res\n···\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992445844","body":"#思路：窗口法\n```\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        n = len(s)\n        ans = [0]*n\n        if s[0]==c:\n            l =0\n        else:\n            l=n\n        r = s.find(c,1)\n        for i in range(n):\n            ans[i] = min(abs(i-l),abs(r-i))\n            if i == r:\n                l = i\n                r = s.find(c, l+1)\n        return ans\n```\n时间复杂度:O(N)\n空间复杂度:O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x-joey":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biancaone":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hyxupup":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cassiechris":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sumukeio":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xvm03":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hengistchan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"youyiqin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"juleijs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rebel-ly":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Winperrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangcn111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"freesan44":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991861722","body":"## 思路\r\n通过int转换实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        #字符串与int的转换\r\n        resStr = \"\"\r\n        for i in num:\r\n            resStr +=str(i)\r\n        res = str(int(resStr)+k)\r\n        reslist = []\r\n        for i in res:\r\n            reslist.append(int(i))\r\n        return reslist\r\n\r\nif __name__ == '__main__':\r\n    A = [1,2,0,0]\r\n    K = 34\r\n    ret = Solution().addToArrayForm(A, K)\r\n    print(ret)\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992066017","body":"## 思路\r\n遍历两次数组实现\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        indexList = []\r\n        for index,val in enumerate(s):\r\n            if val == c:\r\n                indexList.append(index)\r\n        resList = []\r\n        p = 0\r\n        # print(indexList)\r\n        for index,val in enumerate(s):\r\n            # print(index)\r\n            if p < len(indexList)-1 and (abs(index-indexList[p]) > abs(index-indexList[p+1])):\r\n                p += 1\r\n            resList.append(abs(index-indexList[p]))\r\n        return resList\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995282874","body":"## 思路\r\n创建List来实现\r\n\r\n## 关键点\r\n\r\n-  \r\n\r\n## 代码\r\n\r\n- 语言支持：Python3\r\n\r\nPython3 Code:\r\n\r\n```python\r\n\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.Alist = []\r\n        self.Blist = []\r\n        self.peekIndex = None\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.Alist.append(x)\r\n        if len(self.Alist)== 1:\r\n            self.peekIndex = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        #如果B为空，就从A倒到B再处理\r\n        if len(self.Blist) == 0 and len(self.Alist) == 0:\r\n            return None\r\n        if len(self.Blist) != 0:\r\n            return self.Blist.pop()\r\n        else:\r\n            while len(self.Alist)!=0:\r\n                self.Blist.append(self.Alist.pop())\r\n            self.peekIndex = None\r\n            return self.Blist.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.Blist.__len__() == 0:\r\n            return self.peekIndex\r\n        else:\r\n            return self.Blist[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        if self.peekIndex == None and len(self.Blist) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"XiangyDeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yanjyumoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leige635539766":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"summer506hai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"saltychess":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihuiwen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhy3213":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995087469","body":"## 思路 \nlazy 倒\n## 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.forward=collections.deque()\n        self.backward=collections.deque()\n\n\n    def push(self, x: int) -> None:\n        self.forward.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.backward)==0:\n            while self.forward:\n                self.backward.append(self.forward.pop())\n        return self.backward.pop()\n\n    def peek(self) -> int:\n        if not len(self.backward)==0:\n            return self.backward[-1]\n        return self.forward[0]\n\n    def empty(self) -> bool:\n        return len(self.backward)==0 and len(self.forward)==0\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zywang0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hibriansun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jz1433":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aduispace":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenlong201807":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992058242","body":"## 代码块\r\n\r\n```javascript\r\n\r\nvar shortestToChar = function(s, c) {\r\n  const len = s.length;\r\n  let resultArr = [];\r\n\r\n  const helpFn = (curInd, len, ori, target) => {\r\n  let left = curInd;\r\n  let right = curInd;\r\n  let minLen = len;\r\n  if (ori.charAt(curInd) === target) {\r\n    return 0;\r\n  }\r\n\r\n  while (left >= 0) {\r\n    if (ori.charAt(left) === target) {\r\n      minLen = Math.min(curInd - left, len)\r\n      break;\r\n    }\r\n    left--\r\n  }\r\n\r\n  while (right <= len) {\r\n    if (ori.charAt(right) === target) {\r\n      minLen = Math.min(right - curInd, minLen)\r\n      break;\r\n    }\r\n    right++\r\n  }\r\n\r\n  return minLen;\r\n }\r\n  for(let i = 0; i < len; i++) {\r\n    resultArr.push(helpFn(i, len, s, c));\r\n  }\r\n  \r\n  return resultArr;\r\n};\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994870925","body":"### 代码块\r\n```javascript\r\n\r\nfunction checkRate(input) {\r\n  var re = /^[0-9]+.?[0-9]*/;\r\n  //判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/;//判断字符串是否为数字//判断正整数/[1−9]+[0−9]∗]∗/\r\n  return re.test(input);\r\n}\r\nvar decodeString = function (s) {\r\n  const stack = [];\r\n  let numStr = '';\r\n  for (let i = 0; i < s.length; i++) {\r\n    if (checkRate(s[i])) {\r\n      numStr += s[i];\r\n      continue;\r\n    } else {\r\n      if (numStr) stack.push(numStr);\r\n      numStr = '';\r\n\r\n      if (s[i] !== ']') {\r\n        stack.push(s[i]);\r\n      } else {\r\n        let tempStr = '';\r\n        while (stack.length) {\r\n          const curStr = stack.pop();\r\n          if (curStr !== '[') {\r\n            tempStr = curStr + tempStr;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        let curNum = stack.pop();\r\n        stack.push(tempStr.repeat(curNum));\r\n      }\r\n    }\r\n  }\r\n  return stack.join('');\r\n}\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qibao1112":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyue08":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992336884","body":"```javascript\r\nvar shortestToChar = function(S, C) {\r\n    var dd=[];\r\n    //从左到右，从右到左\r\n    for(var i=0;i<S.length;i++){\r\n            var left=S.lastIndexOf(C,i);\r\n            var right=S.indexOf(C,i);\r\n            if(left==-1){\t//左边不存在\r\n                dd.push(right-i);\r\n            }\r\n            else if(right==-1){\t\t//右边不存在\r\n                dd.push(i-left);\r\n            }else{               \r\n                right-i>i-left?dd.push(i-left):dd.push(right-i);\r\n            }\r\n    }\r\n    return dd;\r\n};\r\n\r\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994767327","body":"```javascript\r\nvar decodeString = function(s) {\r\n    let stack = []\r\n    for(let i = 0; i < s.length; i++){\r\n        if (stack.length === 0 || s[i] !== ']'){\r\n            if (/[0-9]/.test(s[i])){\r\n                for(let l = i + 1; l < s.length; l++){\r\n                    if (!/[0-9]/.test(s[l])) {\r\n                        stack.push(s.slice(i, l))\r\n                        i = l - 1;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                stack.push(s[i]);\r\n            }\r\n            continue;\r\n        }\r\n \r\n \r\n        // 核心处理。找遇到的第一个数字。如果这个数字之前还有数据，就解密这个局部串，放入栈。\r\n        // 如果这个数字之前没数据了，栈空，字符串累加\r\n        for (let j = stack.length - 1; j >= 0; j--) {\r\n            if (/[0-9]+/.test(stack[j])){\r\n                if (j === 0){\r\n                    let subStr = stack.slice(j + 2).join('').repeat(Number(stack[j]))\r\n                    stack = []\r\n                    for(let m = 0; m < subStr.length; m++){\r\n                        stack.push(subStr[m])\r\n                    }\r\n                } else {\r\n                    let subStr = stack.slice(j + 2).join('').repeat(Number(stack[j]))\r\n                    let k = stack.length - 1\r\n                    while(k !== j - 1){\r\n                        stack.pop()\r\n                        k--;\r\n                    }\r\n                    for(let p = 0; p < subStr.length; p++){\r\n                        stack.push(subStr[p])\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuezhongyuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watchpoints":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994605321","body":"## 思路\n- 递归也是一种栈\n\n## 代码 \n\n~~~c++\nclass Solution {\npublic:\n    \n    string decodeString(string s) {\n        int i = 0;\n        return decodeString(s, i);\n    }\n    //递归 时间复杂度 O(N) 空间复杂度 O(N)\n    string decodeString(const string& s, int& i) {\n        string res;\n        \n        while (i < s.length() && s[i] != ']') {\n            if (!isdigit(s[i]))\n                res += s[i++];\n            else {\n                int n = 0;\n                while (i < s.length() && isdigit(s[i]))\n                    n = n * 10 + s[i++] - '0';\n                    \n                i++; // '['\n                string t = decodeString(s, i);\n                i++; // ']'\n                \n                while (n-- > 0)\n                    res += t;\n            }\n        }\n        \n        return res;\n    }\n};\n~~~","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wanghuaikuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ShuchenWuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoanyang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921146","body":"### 思路\n先反转数组，然后循环相加\n\n### 代码\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  let x1 = num.reverse();\n  let x2 = k.toString().split('').reverse();\n  let count = x1.length > x2.length?x1.length:x2.length;\n  let result = [];\n  let isAdd = false;\n  for(let i=0;i<count;i++){\n    let num1 = x1[i] || 0;\n    let num2 = x2[i] || 0;\n    let num = Number(num1) + Number(num2);\n    if(isAdd){\n      isAdd = false;\n      num+=1;\n    }\n\n    if(num>=10){\n      num -=10;\n      isAdd = true;\n    }\n    result.push(num)\n  }\n  if(isAdd){\n    result.push(1)\n  }\n  return result.reverse()\n};\n```\n\n### 复杂度\n时间复杂度 O(n),其中n为Max(num.length,k)\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ymwang-2020":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chanceyliu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Craig-Cheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weichuliao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"absent1353":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"banjingking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"now915":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992071295","body":"- 算法\n```js\n function shortestToChar(s, c) {\n   let result = Array(s.length).fill(0)\n   let left = 0, right = 0, shortest = Infinity\n   for (let index = 0; index < s.length; index++) {\n      if (s[index] == c) continue\n\n      left = right = index\n      while (left >= 0 || right < s.length) {\n        if (s[left] == c) {\n          shortest = index - left\n          break\n        }\n        if (s[right] == c) {\n          shortest = right - index\n          break\n        }\n        left > 0 ? left-- : ''\n        right < s.length - 1 ? right++: ''\n      }\n     result[index] = shortest\n   }\n   return result\n }\n```\n- 时间复杂度\nO(n²)\n- 空间复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"akxuan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cdd111":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhiyuanpeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whitewhatpin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liudi9047":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guohuijiedesu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzyhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yourspeace":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"thisjustsoso":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ozhfo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yyangeee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pan-qin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"Crazy-xjm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"grapefruit-hellomonday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandaCure":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jawn-ha":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"panda-qin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lihanchenyuhua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"whgsh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kangxiaohan05":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ru8dgj0001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taoyr722":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"raoshuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ninghuangaa":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blanktime":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iceburgs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xlzy520":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vaqua":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dahuang257":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuichen17":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wsgouwan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kkwu314":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891441","body":"# 思路 1\n\n\n\n<aside> 💡 新建一个List<Integer>，从num的最右边的元素开始加。将超出个位数的remainder继续加到被/10的k上。将计算过的sum加入到List里。最后将剩余k加入list里然后reverse List\n\n</aside>\n\n# 代码\n\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i=n-1; i>=0; i--){\n            int sum = num[i]+k%10;\n            k/=10;\n            if (sum>=10){\n                k+=sum/10;\n                sum%=10;\n            }\n            ans.add(sum);\n        }\n        for (;k>0;k/=10){\n            ans.add(k%10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```\n\n# 复杂度分析\n\n\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)\n\n# 思路 2\n\n\n\n<aside> 💡 和上一种类似，但是直接将num[i]加到k中，再将k的个位数加到arr里\n\n</aside>\n\n# 代码\n\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i=n-1; i>=0 || k>0; i--,k/=10){\n            if (i>=0){\n                k+=num[i];\n            }\n            ans.add(k%10);\n        }\n        Collections.reverse(ans);\n        return ans;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度：O(N) *O*(max(*n*,log*k*))\n\n空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carsonlin9996":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"niuyibo0619":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chakochako":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991807958","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num1 = int(''.join(map(str,num)))\n        return list(map(int,list(str(num1+k))))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991999343","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for p, v in enumerate(s):\n            if v == c:\n                prev = p\n            ans.append(p - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994889788","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        res = \"\"\n        multi = 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mannnn6":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sogatechnology":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ariel-mu3":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sugar666":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liwangping":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cecilialmw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ph2200":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yunomin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993099154","body":"##### python\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.space_left = maxSize\n        self.l = []\n\n    def push(self, x: int) -> None:\n        if self.space_left > 0:\n            self.l.append(x)\n            self.space_left -= 1\n\n    def pop(self) -> int:\n        if len(self.l) > 0:\n            self.space_left += 1\n            return self.l.pop(-1)\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.l))):\n            self.l[i] += val\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hinancy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guochiscoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shibingchao123":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995412938","body":"class MyQueue:\r\n\r\n    def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            self.stack2 = self.stack1[::-1]\r\n            self.stack1 = []\r\n            return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if self.stack2:\r\n            return self.stack2[-1]\r\n        elif self.stack1:\r\n            return self.stack1[0]\r\n\r\n    def empty(self) -> bool:\r\n        if (not self.stack1) and (not self.stack2):\r\n            return True\r\n        else:\r\n            return False","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yukicoding":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lhjzuibang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nadostars":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xitice":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cyk1337":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ywang525":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"razor1895":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"famine330":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jsu-arch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yxq1997":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zbqnb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xjlgod":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bai170":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nerrolk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liyubin117":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bpointa":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991859929","body":"### 思路\n\n模拟竖式计算，新的一期打算开始试着用Java实现，自己不习惯Java，思路还是在Python上的思路，感觉实现得有点粗糙\n\n### Java代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n      ArrayList<Integer> klist=new ArrayList<>();\n      ArrayList<Integer> nums=new ArrayList<>();\n      for (int n:num)\n      {\n          nums.add(n);\n      }\n      while (k>0)\n      {\n          klist.add(0,k%10);\n          k=k/10;\n      }\n      int a=klist.size();\n      int b=nums.size();\n    if(a<b)\n    {\n        for (int i1=0;i1<b-a;i1++)\n        {\n            klist.add(0,0);\n        }\n    }\n    else if(b<a)\n    {\n        for (int i2=0;i2<a-b;i2++)\n        {\n            nums.add(0,0);\n        }\n    }\n  \n      ArrayList<Integer> ans=new ArrayList<>();\n      int saving=0;\n      for (int i=nums.size()-1;i>=0;i--)\n      {\n          int tmp=saving+klist.get(i)+nums.get(i);\n          ans.add(0,tmp%10);\n          saving=tmp/10 ;\n      }\n      if(saving>0)\n      {\n          ans.add(0,saving);\n      }\n\n    \n\n      \n      return ans;\n    }\n}\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992089496","body":"### 思路\r\n\r\n两边各自遍历\r\n\r\n### Java代码\r\n```Java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int l=s.length();\r\n        int idx1=-l,idx2=l*2;\r\n        int [] ans=new int[s.length()];\r\n        for (int i=0;i<l;i++)\r\n        {ans[i]=l+1;}\r\n        for (int i1=0;i1<s.length();i1++)\r\n        {\r\n            if(s.charAt(i1)==c)\r\n            {ans[i1]=0;\r\n            idx1=i1;\r\n            }\r\n            int tmp=i1-idx1;\r\n            if(tmp<ans[i1])\r\n            {ans[i1]=tmp;}\r\n\r\n        }\r\n        for (int i2=s.length()-1;i2>=0;i2--)\r\n        {\r\n            if(s.charAt(i2)==c)\r\n            {ans[i2]=0;\r\n            idx2=i2;\r\n            }\r\n            int tmp=idx2-i2;\r\n            if(tmp<ans[i2])\r\n            {ans[i2]=tmp;}\r\n\r\n        }\r\n        return ans;\r\n            }\r\n}\r\n\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间：O(n)\r\n空间：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993464394","body":"### 思路\n\n纯模拟\n\n### Java\n\n```Java\n\nclass CustomStack {\nList<Integer> cs;\nint tmp;\nint lim;\n    public CustomStack(int maxSize) {\n        cs=new ArrayList(); \n        tmp=0;\n        lim=maxSize;\n\n    }\n    \n    public void push(int x) {\n        if(this.tmp==this.lim)\n        {\n            return ;\n        }\n        cs.add(x);\n        tmp+=1;\n    }\n    \n    public int pop() {\n        if(tmp==0)\n        {return -1;}\n        \n        int ans=cs.get(tmp-1);\n        cs=cs.subList(0,tmp-1);\n        tmp-=1;\n        return ans;\n    }\n    \n    public void increment(int k, int val) {\n        int to_add=k;\n        if(tmp<k)\n        {to_add=tmp;}\n\n        for (int i=0;i<to_add;i++)\n        {\n            cs.set(i,cs.get(i)+val);\n        }\n         \n        \n\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994170223","body":"### 思路\n\n递归\n\n### Java代码\n```\nclass Solution {\n    public String decodeString(String s) {\n        int left=0;\n        for (int i=0;i<s.length();i++)\n        {\n            char c=s.charAt(i);\n            if(c=='[')\n            {\n             left=i;\n            }\n            if(c==']')\n            {\n                int j=left-1;\n                while(j>=0 && Character.isDigit(s.charAt(j)))\n                {j-=1;}\n                int cnt=Integer.valueOf(s.substring(j+1,left));\n                String new_String=s.substring(0,j+1);\n                \n                new_String+=s.substring(left+1,i).repeat(cnt);\n                \n                new_String+=s.substring(i+1,s.length());\n                return decodeString(new_String);\n\n            }\n        }\n        return s;\n\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiangyanlineu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rocjemaintiendrai":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994253341","body":"### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        Stack<Integer> numStack = new Stack<>();\n        Stack<String> strStack = new Stack<>();\n        int multi = 0;\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                numStack.push(multi);\n                strStack.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            } else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int curMulti = numStack.pop();\n                for(int i = 0; i < curMulti; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(strStack.pop() + tmp);\n            } else if(c >= '0' && c <= '9') {\n                multi = multi * 10 + Integer.parseInt(c + \"\");\n            } else {\n                res.append(c);\n            }\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995463189","body":"### 代码\n```java\nclass MyQueue {\n    Stack<Integer> inStack;\n    Stack<Integer> outStack;\n\n    public MyQueue() {\n        inStack = new Stack<>();\n        outStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        dumpInStack();\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        dumpInStack();\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return outStack.isEmpty() && inStack.isEmpty();\n    }\n    \n    private void dumpInStack() {\n        if(outStack.isEmpty()) {\n            while(!inStack.isEmpty()) {\n                outStack.push(inStack.pop());\n            }\n        }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunnyyujf":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zz10044":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"menglin-l":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991822250","body":"### 思路：\r\n#### 1.将k与num的最后一位(size - 1)数字相加，然后把得到的结果与10取模，便是数组新的最后一位，将其存入原数组中最后一位。\r\n#### 2.将1中的k与10取余，去掉个位，再与num的(size - 2)位相加，重复1过程。\r\n#### 3.利用LinkedList特性插入元素，直接返回最终结果，不需要再翻转。\r\n---\r\n\r\n### 代码部分：\r\n```Java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        LinkedList<Integer> ans = new LinkedList<>();\r\n        \r\n        int sum = 0, carry = 0, len = num.length - 1;\r\n        \r\n        while (len >= 0 || k != 0) {\r\n            int x = len >= 0 ? num[len] : 0;\r\n            int y = k != 0 ? k % 10 : 0;\r\n            \r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            \r\n            k /= 10;\r\n            len --;\r\n            \r\n            ans.addFirst(sum % 10);\r\n        }\r\n        \r\n        if (carry != 0) ans.addFirst(carry);\r\n        return ans;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### Time: O(N)\r\n#### Space: O(1), 长度为26的数组算作常数空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991968203","body":"#### 1. Determine the distance to the nearest c on the left. \r\n####     Traverse s from left to right and count the index from the maximum, the size of s, as the distance. \r\n####     Increase the next index by one. If c occurs, change the distance to zero.\r\n#### 2. Determine the distance to the nearest c on the right.\r\n####     Traverse s from right to left. Count the index and compare it with the previous value, then take the minimum. \r\n---\r\n\r\n```Java\r\nclass Solution {\r\n    // s = \"l  o  v  e  l  e  e  t  c  o  d  e\", c = \"e\", s.length() = 12\r\n    //     12 13 14  0  1  0  0  1  2  3  4  0 \r\n    //      3  2  1  0  1  0  0  1  2  2  1  0\r\n    public int[] shortestToChar(String s, char c) {\r\n        if (s.length() == 1) return new int[]{0};\r\n        \r\n        char[] cc = s.toCharArray();// O(N)\r\n        int[] res = new int[s.length()];// O(N)\r\n        int disLeft = s.length();\r\n        int disRight = s.length();\r\n        \r\n        // O(N)\r\n        for (int i = 0; i < cc.length; i ++) {\r\n            if (cc[i] == c) {\r\n                disLeft = 0;\r\n            }\r\n            res[i] = disLeft;\r\n            disLeft ++;\r\n        }\r\n        \r\n        // O(N)\r\n        for (int j = cc.length - 1; j >= 0; j --) {\r\n            if (cc[j] == c) {\r\n                disRight = 0;\r\n            }\r\n            res[j] = Math.min(res[j], disRight);\r\n            disRight ++;\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### Time: O(N)\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993295182","body":"### Thoughts:\r\n#### Use an array to denote that arr[i] represents the increment applied to all elements from stack[0, ..., i] or from the bottom element to the ith element.\r\n---\r\n### Code:\r\n```Java\r\nclass CustomStack {\r\n    Stack<Integer> stack = new Stack<>();\r\n    int[] additions;\r\n    int maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        this.additions = new int[maxSize + 1];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        // edge case: stack is full at maxSize\r\n        if (stack.size() == maxSize)\r\n            return;\r\n        // push val into stack\r\n        stack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        // edge case: stack is empty\r\n        if (stack.isEmpty())\r\n            return -1;\r\n        \r\n        // get addition amount for next num and erase it from arr\r\n        int amount = additions[stack.size()];\r\n        additions[stack.size()] = 0;\r\n        \r\n        // add amount to item below next val\r\n        additions[stack.size() - 1] += amount;\r\n        \r\n        return stack.pop() + amount;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // add val to kth index\r\n        additions[Math.min(k, stack.size())] += val;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n### Complexity:\r\n#### Time: O(1) for pop and push; O(N) for increment\r\n#### Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993908961","body":"#### thoughts: Using two stacks\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass Solution {\r\n    //\"abc3[a2[c]]\"\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return \"\";\r\n        \r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resultStack = new Stack<>();\r\n        char[] strArr = s.toCharArray();//strArr = a b c 3 [ a 2 [ c ] ]\r\n        int count = 0;\r\n        String curResult = \"\";\r\n        for (int i = 0; i < s.length(); i++) {//curResult = \"accaccacc\", count = 0, countStack: , resultStack:abc,\r\n            //calculate repeat number\r\n            if (Character.isDigit(strArr[i])) {\r\n                count = count * 10 + (strArr[i] - '0');\r\n            }\r\n            //push previous decoded string into stack\r\n            else if (strArr[i] == '[') {\r\n                countStack.push(count);\r\n                resultStack.push(curResult);\r\n                count = 0;\r\n                curResult = \"\";\r\n            }\r\n            //start to decode current string\r\n            else if (strArr[i] == ']') {//repeat:3\r\n                int repeat = countStack.pop();\r\n                StringBuilder temp = new StringBuilder(resultStack.pop());//temp:\r\n                for (int j = 0; j < repeat; j++) {\r\n                    temp.append(curResult);\r\n                }\r\n                curResult = temp.toString();\r\n            }\r\n            //normal character, concat to current string, preparing for decoding\r\n            else {\r\n                curResult += strArr[i];\r\n            }\r\n        }\r\n        return curResult;\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time : O(maxCount * N) where maxCount is max value of count, and n is the size of string array.\r\n#### Space : O(m + n) m is the number of letters and n is the number of digits.\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995446787","body":"#### approach: two stacks\r\n---\r\n\r\n#### code:\r\n```Java\r\nclass MyQueue {\r\n\r\n    private Stack<Integer> s1 = new Stack<>();\r\n    private Stack<Integer> s2 = new Stack<>();\r\n\r\n    // Initialize your data structure here. \r\n    public MyQueue() {\r\n        \r\n    }\r\n    \r\n    // Push element x to the back of queue.\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    // Removes the element from in front of queue and returns that element. \r\n    public int pop() {\r\n        if (s2.isEmpty()) {\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    // Get the front element. \r\n    public int peek() {\r\n        if (!s2.isEmpty()) {\r\n            return s2.peek();\r\n        } else {\r\n            while (!s1.isEmpty())\r\n                s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    // Returns whether the queue is empty. \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```\r\n---\r\n\r\n#### complexity:\r\n#### Time: peek() -> O(N), empty() -> O(1), pop() -> O(N), push() -> O(1)\r\n#### Space: peek() -> O(1), empty() -> O(1), pop() -> O(1), push() -> O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potatoma":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866936","body":"### 思路\n\n***\n\n先在对应位置一一相加，再进行进位操作\n\n### 代码\n\n***\n\nJavascript code:\n\n```javascript\nvar addToArrayForm = function(num, k) {\n    let temp = 0;\n    const kLen = k.toString().length;\n    for (let i = 0;i < kLen;i++) {\n        if (num.length < kLen) num.unshift(0);\n        temp = k % 10;\n        k = Math.floor(k / 10);\n        num[num.length - 1 - i] += temp;\n    }\n    const nLen = num.length;\n    for (let i = nLen - 1;i > 0;i--) {\n        if (num[i] >= 10) {\n            num[i - 1] += 1\n            num[i] = num[i] % 10;\n        }\n    }\n    if (num[0] >= 10) {\n        num[0] = num[0] % 10;\n        num.unshift(1);\n    }\n    return num;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度O(max(N,logk))\n\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992567484","body":"### 思路1\n\n***\n\n空间换时间：先记录每一个字符C出现的下标，再遍历一次字符串S，通过下标相减的绝对值找出每个字符距离C最近的距离\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    const targetIndex = [];\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) {\n            targetIndex.push(i);\n        }\n    }\n    const res = [];\n    for (let i = 0;i < s.length;i++) {\n        let min = Infinity;\n        for (let ti of targetIndex) {\n            if (min <= Math.abs(i - ti)) {\n                break;\n            }\n            min = Math.abs(i - ti);\n        }\n        res.push(min);\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N * K)，K是字符C在字符串S中出现的次数，K <= N\n\n空间复杂度：O(K)\n\n### 思路2\n\n***\n\n贪心，先从左往右遍历S，计算每个下标离左边距离C最近的距离，再从右往左遍历计算一次，如有更小的距离则覆盖\n\n### JavaScript代码\n\n***\n\n```javascript\nvar shortestToChar = function(s, c) {\n    let targetIndex = null;\n    const res = new Array(s.length);\n    for (let i = 0;i < s.length;i++) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex === null) {\n            res[i] = Infinity;\n        } else {\n            res[i] = Math.abs(i - targetIndex);\n        }\n    }\n    targetIndex = null;\n    for (let i = s.length - 1;i > -1;i--) {\n        if (s[i] === c) targetIndex = i;\n        if (targetIndex !== null) {\n            res[i] = Math.min(res[i], Math.abs(i - targetIndex));\n        }\n    }\n    return res;\n};\n```\n\n### 复杂度分析\n\n***\n\n时间复杂度：O(N)\n\n空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mahalasu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"maschinist-lzy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackielj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"francis-xsc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"autumndesea":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"snowballbears":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuyangqiqaq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinming-gu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lovewitch":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kashinggo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laofuwf":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991847136","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        total = 0\n        index = 0\n        \n        for n in num[::-1]:\n            total += (10 ** index) * n\n            index += 1\n        \n        total += k\n        \n        res = []\n        for digit in str(total):\n            res.append(int(digit))\n        \n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992107736","body":"```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        # len(s) is 1 bigger than max distance\n        res = [len(s)] * len(s)\n        \n        leftMost = rightMost = -1\n        \n        for i in range(len(s)):\n            if s[i] == c: leftMost = i\n            if leftMost != -1:\n                res[i] = i - leftMost\n        \n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c: rightMost = i\n            if rightMost != -1:\n                res[i] = min(res[i], rightMost - i)\n        \n        return res\n````","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993135666","body":"```python\nclass Node:\n    \n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        self.prev = None\n        \nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.head = None\n        self.tail = None\n        self.maxSize = maxSize\n        self.currSize = 0\n\n    def push(self, x: int) -> None:\n        if self.currSize >= self.maxSize: return\n        \n        self.currSize += 1\n        if self.head is None: \n            self.head = Node(x)\n            self.tail = self.head\n            return\n        \n        temp = self.tail\n        self.tail.next = Node(x)\n        self.tail = self.tail.next\n        self.tail.prev = temp\n        \n    def pop(self) -> int:\n        if self.currSize == 0: return -1\n        \n        self.currSize -= 1\n        res = self.tail.val\n        self.tail = self.tail.prev\n        \n        # re-init head and tail\n        if self.tail is None:\n            self.head = None\n            return res\n        self.tail.next = None\n        \n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        curr = self.head\n        for i in range(min(k, self.currSize)):\n            curr.val += val\n            curr = curr.next\npython","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995161496","body":"```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2.pop()\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        stack2 = []\n        while self.stack:\n            stack2.append(self.stack.pop())\n        res = stack2[-1]\n        \n        while stack2:\n            self.stack.append(stack2.pop())\n        \n        return res\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return len(self.stack) == 0\n        \n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zjp1483469269":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833580","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        c = 0\n        ans = []\n        for i in range(len(num)):\n            x = k % 10\n            k = k // 10\n            n,c = (x + num[len(num)-1-i] + c) % 10,(x + num[len(num)-1-i]+c) // 10\n            ans = [n]+ans\n        k = k+c\n        if k!=0:\n            while(k!=0):\n                ans = [k%10] + ans\n                k = k // 10\n            return ans\n        if c == 0:\n            return ans\n        else :\n            return [c]+ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992041299","body":"#### 思路\n记录下标index，以每个index为中心向周围增加给数组赋值，直到填满数组\n#### 代码\n```python3\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        index = [i for i,x in enumerate(s) if x == c]\n        ls = [-1]*len(s)\n        cnt = len(index)\n        for i in index:\n            ls[i] = 0\n        step = 0\n        while(cnt<len(s)):\n            step = step + 1\n            for i in index:\n                for j in [-step,step]:\n                    if i+j >= 0 and i+j < len(s) and ls[i+j] == -1:\n                        ls[i+j] = step\n                        cnt = cnt + 1\n        return ls\n```\n#### 复杂度分析\n时间复杂度：O（n）\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993171554","body":"#### 代码\n```python3\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.max_size = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if(len(self.stack) < self.max_size):\n            self.stack.append(x)\n        else:\n            return\n        \n    def pop(self) -> int:\n        stack = self.stack\n        if(len(stack) > 0):\n            return stack.pop(len(stack)-1)\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        stack = self.stack\n        for i in range(min(len(stack),k)):\n            stack[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994279440","body":"```python3\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                rs = ''\n                rn = ''\n                while stack and stack[-1]!='[' :\n                    rs = stack.pop() + rs\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    rn = stack.pop() + rn\n                stack.append(rs * int(rn))\n            else:\n                stack.append(c)\n        return ''.join(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995430417","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n        self.helpstack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        while self.stack :\n            self.helpstack.append(self.stack.pop())\n        res = self.helpstack.pop()\n        while self.helpstack :\n            self.stack.append(self.helpstack.pop())\n        return res\n\n    def peek(self) -> int:\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        if self.stack :\n            return False\n        else:\n            return True\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluerui":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joeychengtor":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"watermelondrip":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995336582","body":"```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.stk1 = list()\r\n        self.stk2 = list()  # create new queue\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        self.stk1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2.pop()\r\n        else:\r\n            while self.stk1:\r\n                self.stk2.append(self.stk1.pop())\r\n            return self.stk2.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if self.stk2:\r\n            return self.stk2[-1]\r\n        while self.stk1:\r\n            self.stk2.append(self.stk1.pop())\r\n        return self.stk2[-1] \r\n\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        return (len(self.stk2) == 0 and  len(self.stk1)== 0)\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jding0":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jk1452470209":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tao-mao":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994346256","body":"## Idea \nUse stack\n\n## Code \n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>(); \n        StringBuilder res = new StringBuilder();\n        for (int i = 0; i < s.length(); ++i) {\n            if (s.charAt(i) != ']') {\n                stack.add(s.charAt(i));\n            }\n            else {\n                StringBuilder sb = new StringBuilder();\n                List<Character> decodedString = new ArrayList<>();\n                while (stack.peek() != '[') {\n                    decodedString.add(stack.pop());           \n                }\n                stack.pop();\n                StringBuilder times = new StringBuilder();\n                while (!stack.isEmpty() && Character.isDigit(stack.peek())) {\n                    times.append(stack.pop());\n                }\n                int num = Integer.parseInt(times.reverse().toString());\n                while (num != 0) {\n                    for (int j = decodedString.size() - 1; j >= 0; j--) {\n                        stack.push(decodedString.get(j));\n                    }\n                    num--;\n                }\n            }\n        }\n        char[] result = new char[stack.size()];\n        for (int i = result.length - 1; i >= 0; i--) {\n            result[i] = stack.pop();\n        }\n        return new String(result);\n    }\n}\n```\n\n## Complexity\nTime: O(maxK^Kcount * n) Space O(sum(maxK^Kcount * n))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"agathawang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daniel-zheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moin-jer":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922037","body":"### 思路\n---\n逐位相加\n### 代码\n---\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> ans = new LinkedList<>();\n        int len = num.length;\n        int i = len - 1, tmp = k, carry = 0;\n        while (i >= 0 || tmp > 0 || carry > 0) {\n            int t = (i >= 0 ? num[i] : 0) + (tmp > 0 ? tmp % 10 : 0) + carry;\n            carry = t / 10;\n            ans.add(0, t % 10);\n            --i;\n            tmp /= 10;\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(max(num.length, logk))\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992095276","body":"### 思路\n---\n数组的遍历\n### 代码\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        Arrays.fill(ans, n + 1);\n        int pre = -n;\n        for (int i = 0; i < n; ++i) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], i - pre);\n        }\n\n        pre = 2 * n;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(N)\n+ 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993181943","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass CustomStack {\n\n    int[] stack;\n    int top;\n    int[] add;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n        add = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (top == stack.length - 1) {\n            return;\n        }\n        ++top;\n        stack[top] = x;\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        int res = stack[top] + add[top];\n        --top;\n        if (top >= 0) {\n            add[top] += add[top + 1];\n        }\n        add[top + 1] = 0;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int c = Math.min(top, k - 1);\n        if (c >= 0) {\n            add[c] += val;\n        }\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994334896","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度： O(n)\n+ 空间复杂度： O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995453258","body":"### 思路\n---\n栈\n### 代码\n---\n```java\nclass MyQueue {\n\n    Deque<Integer> stack1;\n    Deque<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n```\n### 复杂度分析\n---\n+ 时间复杂度：O(1)\n+ 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qizhongdd":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lllouiselao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huangxuang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangzhengneu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"just-focus":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"monkofeast":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994917638","body":"# 394. Decode String\n> [Click Me](https://leetcode.com/problems/decode-string/)\n## Algo\n1. Consider innermost decoding, stack is good\n2. new a stack for final output\n3. new a list for temp saving decode\n4. travel through the original str\n    1. if not ']', continue\n    2. if ']', stop, decode\n5. \n\n## Code\n```py\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        # the key here is to consider cases like jksd19[dsl]fion3[acc2[d]]\n        # this nested pattern should be decode from innermost str\n        # so stack is good for this task\n        # KEY!!!: ']' on the top of stack is the starting point to decode\n        \n        stack = []\n        decodeList = []\n        \n        # travel the ori str\n        for i in range(len(s)):\n            # if not , travel\n            if s[i] != ']':\n                stack.append(s[i])\n            # if ']', stop, start decoding\n            else:\n                while stack[-1] != '[': decodeList.insert(0, stack.pop())\n                stack.pop() # delete '['\n                # find the multi times\n                times, multi = 0, 1\n                while stack and stack[-1].isnumeric():\n                    times += multi*int(stack.pop())\n                    multi *= 10\n                stack = stack + decodeList*times\n                decodeList.clear()\n        \n        # (str).join(list): return a str\n        return \"\".join(stack)\n```\n\n## Comp\n### T: O(N)\n### S: O(max(decoded-list))","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hackbl":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhang6260":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994785258","body":"## JAVA版本\n\n使用栈来完成的，需要注意的是，数组可能存在多位的时候，从栈中取字母是否是否需要进行翻转。\n\n> ```java\n> class Solution {\n>     public  String decodeString(String s) {\n>         Stack<String> stack = new Stack<>();\n>         for(int i=0;i<s.length();i++){\n>             char temp = s.charAt(i);\n>             if(temp==']'){\n>                 StringBuffer sb = new StringBuffer();\n>                 while(!stack.isEmpty()&&!stack.peek().equals(\"[\")){\n>                     sb.append(stack.pop()+\"\");\n>                 }\n>                 if(stack.peek().equals(\"[\"))stack.pop();//弹出【\n>                 //数组可能为多位\n>                 StringBuffer num = new StringBuffer();\n>                 while(!stack.isEmpty()&&stack.peek().length()==1&&stack.peek().charAt(0)>='0'&&stack.peek().charAt(0)<='9'){\n>                     num.append(stack.pop());\n>                 }\n>                 num.reverse();\n>                 int n = Integer.parseInt(num.toString());\n>               \n>                 StringBuffer temp_sb = new StringBuffer();\n>                 for(int z=0;z<n;z++){\n>                     temp_sb.append(sb.toString());\n>                 }\n>                 if(stack.isEmpty()||stack.peek().equals(\"[\")){\n>                     stack.push(temp_sb.toString());\n>                 }else{\n>                     stack.push(stack.pop()+temp_sb.toString());\n>                 }\n>             }else if(stack.isEmpty()||(temp>='0'&&temp<='9')||temp=='['||stack.peek().equals(\"[\")){\n>                 stack.push(temp+\"\");\n>             }else {\n>                 stack.push(stack.pop()+temp);\n>             }\n>         }\n>         return stack.peek();\n>     }\n> }\n> ```\n\n__时间复杂度__：O(n) \n\n__空间复杂度__：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995454798","body":"## JAVA版本\n\n使用二个栈就来完成，模拟队列，要求弹出最先对栈的值，可以将栈的所有值，入栈到另一个栈中，这样在另个栈对的栈顶则是最开始进行的数字，当该栈为空后，则重复上面的操作。\n\n> ```java\n> class MyQueue {\n>     Stack<Integer> stack1;\n>     Stack<Integer> stack2;\n>     public MyQueue() {\n>         stack1 = new Stack<>();\n>         stack2 = new Stack<>();\n>     }\n>     public void push(int x) {\n>         stack1.push(x);\n>     }\n>     public int pop() {\n>         fun();\n>         if(stack2.isEmpty())return -1;\n>         return stack2.pop();\n>     }\n>     public int peek() {\n>         fun();\n>         if(stack2.isEmpty())return -1;\n>         return stack2.peek();\n>     }\n>     public boolean empty() {\n>         if(stack1.isEmpty()&&stack2.isEmpty()){\n>             return true;\n>         }else{\n>             return false;\n>         }\n>     }\n>     public void fun(){\n>         if(stack2.isEmpty()&&!stack1.isEmpty()){\n>             while(!stack1.isEmpty()){\n>             stack2.push(stack1.pop());\n>             }\n>         }\n>     }\n> }\n>\n> ```\n\n__时间复杂度__：O(N) \n\n__空间复杂度__：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jadeqi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"houhao1998":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cartie-zhoumo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yufanzh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"timmmyang":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992087884","body":"## 思路\r\n正反两次遍历分别比较距离左边和右边的目标字符的距离。\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        res = []\r\n        prev = -float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                prev = i\r\n            res.append(i - prev)\r\n        \r\n        prev = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i\r\n            res[i] = min(res[i], prev - i)\r\n        return res\r\n```\r\n## 复杂度\r\n时间：O(n)\r\n空间：O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994238922","body":"## 思路\r\n栈+循环\r\n## 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                tmp = ''\r\n                mul = ''\r\n                while stack and stack[-1] != '[':\r\n                    tmp = stack.pop() + tmp\r\n                stack.pop()\r\n                while stack and stack[-1].isdigit():\r\n                    mul = stack.pop() + mul    \r\n                tmp = tmp * int(mul)\r\n                stack.append(tmp)\r\n            else:\r\n                stack.append(c)\r\n        return ''.join(stack)\r\n```\r\n## 复杂度\r\n时间：O(n) n为解码后的字符串长度\r\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kennethalgol":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991873877","body":"##语言\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new LinkedList<>();\r\n\t\tfinal int len = num.length;\r\n\t\tfor(int i = len - 1; i >= 0; i--) {\r\n\t\t\tint sum = num[i] + k % 10;\r\n\t\t\tk /= 10;\r\n\t\t\tif(sum >= 10) {\r\n\t\t\t\tk++;\r\n\t\t\t\tsum -= 10;\r\n\t\t\t}\t\r\n\t\t\tres.add(0, sum);\r\n\t\t}\r\n\t\tfor(; k > 0; k /= 10) {\r\n\t\t\tres.add(0, k % 10);\r\n\t\t}\r\n\t\treturn res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992040617","body":"#语言\r\njava\r\n\r\n```java\r\nclass Solution {\r\n    /*\r\n    分析（非C字符的分类如下）：\r\n    1.只有左边有C字符： sdafC...\r\n    2.左右两边都有C字符：...CdsfsC...\r\n    3.只有右边有C字符：...Cdsff\r\n    (在后面可以用一句代码实现这三种情况)\r\n    */\r\n    public int[] shortestToChar(String S, char C) {\r\n        \r\n        int[] res = new int[S.length()];\r\n        int cur = S.indexOf(C), pre = cur;\r\n        for(int i = 0; i < S.length(); i++){\r\n            if(S.charAt(i) == C){//其实就是每当遍历到C就更新cur和pre\r\n                res[i] = 0;\r\n                pre = i;\r\n                cur = S.indexOf(C, i+1);//注意：这里如果当前是最后一个C时，此时cur为-1，这也保证了上面的情况3\r\n\r\n            }else{\r\n                res[i] = Math.min(Math.abs(pre - i), Math.abs(cur - i));//\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993124305","body":"# 语言\r\njava\r\n\r\n```java\r\nclass CustomStack {\r\n    \r\n    private int[] array;\r\n    private int maxSize;\r\n    private int curSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.array = new int[maxSize];\r\n        this.maxSize = maxSize;\r\n        this.curSize = 0;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(this.curSize < this.maxSize){\r\n            array[curSize++] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(this.curSize > 0){\r\n            return array[--curSize];\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        if(curSize > 0){\r\n            for(int i = 0; i < k && i < curSize; i++){\r\n                array[i] += val;\r\n            }\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(1)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994237863","body":"# 思路\r\n栈\r\n\r\n# 语言\r\njava\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res = new StringBuilder();\r\n        int multi = 0;\r\n        LinkedList<Integer> stack_multi = new LinkedList<>();\r\n        LinkedList<String> stack_res = new LinkedList<>();\r\n        for(Character c : s.toCharArray()) {\r\n            if(c == '[') {\r\n                stack_multi.addLast(multi);\r\n                stack_res.addLast(res.toString());\r\n                multi = 0;\r\n                res = new StringBuilder();\r\n            }\r\n            else if(c == ']') {\r\n                StringBuilder tmp = new StringBuilder();\r\n                int cur_multi = stack_multi.removeLast();\r\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\r\n                res = new StringBuilder(stack_res.removeLast() + tmp);\r\n            }\r\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\r\n            else res.append(c);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995369398","body":"# 思路\r\n栈\r\n\r\n# 语言\r\njava\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> stack1;\r\n    Stack<Integer> stack2;\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n        stack1=new Stack<>();\r\n        stack2=new Stack<>();\r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        stack1.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if(stack2.isEmpty()){\r\n            outStack1ToStack2();\r\n        }\r\n        return stack2.pop();\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if(stack2.isEmpty()){\r\n            outStack1ToStack2();\r\n        }\r\n        return stack2.peek();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return stack2.isEmpty()&&stack1.isEmpty();\r\n    }\r\n\r\n    public void outStack1ToStack2(){\r\n            while(!stack1.isEmpty()){\r\n                stack2.push(stack1.pop());\r\n            }\r\n    }\r\n}\r\n\r\n```\r\n\r\n# 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dana-dai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yqycs":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"oasans":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"changanyue":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sunstrongchina":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhumengcheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"laurence-try":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991995246","body":"```py\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        res = [len(s) for x in range (len(s))]\n        p = 0\n        count = 0\n        flag = False\n        while p < len(s):\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    res[p] = count\n            p += 1\n        count = 0\n        flag = False\n        p -= 1\n        while p >= 0:\n            if s[p] == c:\n                flag = True\n                count = 0\n                res[p] = 0\n            else:\n                if flag:\n                    count += 1\n                    if res[p] > count:\n                        res[p] = count\n            p -= 1\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinhma":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ronghuanyou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"last-battle":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991860618","body":"## 思路\r\n\r\n## 关键点\r\n\r\n从num的最后一位往前遍历，同时维护carry进位。循环条件是num下标合法或者k大于0才结束，那么累加的时候就要注意数组num下标的合法性。最后退出循环后再检查一下carry，防止漏加。将最后结果reverse后返回即可。 \r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n\r\n        int carry = 0;\r\n        for (int i = num.size() - 1, j = 0; i >= 0 || k > 0; --i, ++j) {\r\n            auto tmp = (i >= 0 ? num[i] : 0) + k % 10 + carry;\r\n            res.emplace_back(tmp % 10);\r\n            carry = tmp / 10;\r\n            k /= 10;\r\n        }\r\n\r\n        if (carry) {\r\n            res.emplace_back(carry);\r\n        }\r\n\r\n        reverse(res.begin(), res.end());\r\n\r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992064558","body":"## 思路\r\n\r\n## 关键点\r\n\r\n遍历s的时候，分别以当前位置往前、往后遍历，遇到期望字符c就更新dis，并结束某个方向的查找。\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res;\r\n        for (int i = 0; i < s.length(); ++i) {\r\n            int dis = s.length();\r\n            for (int pos = i; pos >= 0; --pos) {\r\n                if (s[pos] == c) {\r\n                    dis = min(i - pos, dis);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            for (int pos = i; pos < s.length(); ++pos) {\r\n                if (s[pos] == c) {\r\n                    dis = min(pos - i, dis);\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            res.emplace_back(dis);\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993130689","body":"## 思路\r\n\r\n## 关键点\r\n1、push和pop：非常简单就不说了\r\n2、increment：维护一个辅助栈，每次increment的时候就先把res栈中的所有元素都搞到tmp中，然后再从tmp中出栈搞到res，搞的时候判断个数，前k个元素加上增量值val\r\n\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) : cap(maxSize) {\r\n        \r\n    }\r\n    \r\n    void push(int x) {\r\n        if (num < cap) {\r\n            res.push(x);\r\n            ++num;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (!res.empty()) {\r\n            --num;\r\n            auto t = res.top();\r\n            res.pop();\r\n            return t;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        while (!res.empty()) {\r\n            tmp.push(res.top());\r\n            res.pop();\r\n        }\r\n        \r\n        while (!tmp.empty()) {\r\n            if (k-- > 0) {\r\n                res.push(tmp.top() + val);\r\n            } else {\r\n                res.push(tmp.top());\r\n            }\r\n            \r\n            tmp.pop();\r\n        }\r\n    }\r\nprivate:\r\n    int cap = 0;\r\n    int num = 0;\r\n    stack<int> res;\r\n    stack<int> tmp;\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994731006","body":"## 思路\r\n\r\n## 关键点\r\n\r\n从头遍历字符串\r\n1、遇到数字，一直凑数字\r\n2、遇到字母，一直凑字母\r\n3、遇到“[”，把上面凑的数字和字母都分别放到对应栈中，且复位数字和字母\r\n4、遇到“]”，表示可以结算了，分别从数字栈和字母栈中取出值，然后重复n次，进行累加\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```c++\r\n\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        string res;\r\n        \r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        int num = 0;\r\n        for (int i = 0; i < s.length(); ++i) {\r\n            if (s[i] >= '0' && s[i] <= '9') {\r\n                num = num * 10 + (s[i] - '0');\r\n            } else if ((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z')) {\r\n                res += s[i];\r\n            } else if (s[i] == '[') {\r\n                nums.push(num);\r\n                num = 0;\r\n                \r\n                strs.push(res); \r\n                res.clear();\r\n            } else {\r\n                int times = nums.top();\r\n                nums.pop();\r\n                for(int j = 0; j < times; ++ j) {\r\n                    strs.top() += res;\r\n                }\r\n                res = strs.top(); \r\n                strs.pop();\r\n            }\r\n        }\r\n        \r\n        return res;\r\n    }\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995730357","body":"## 思路\r\n\r\n## 关键点\r\n\r\n使用2个栈\r\n1、push的时候正常push到真正栈\r\n2、pop或者peek的时候先看辅助栈，不为空就从辅助栈里面取，否则把真正栈都出栈到辅助栈，再操作辅助栈\r\n\r\n## 代码\r\n\r\n- 语言支持：C++\r\n\r\nC++ Code:\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n    /** Initialize your data structure here. */\r\n    MyQueue() {\r\n    \r\n    }\r\n    \r\n    /** Push element x to the back of queue. */\r\n    void push(int x) {\r\n        realst.push(x);\r\n    }\r\n    \r\n    /** Removes the element from in front of queue and returns that element. */\r\n    int pop() {\r\n        int res;\r\n        if (helperst.empty()) {\r\n            while (!realst.empty()) {\r\n                helperst.push(realst.top());\r\n                realst.pop();\r\n            }\r\n        }\r\n        res = helperst.top();\r\n        helperst.pop();\r\n\r\n        return res;\r\n    }\r\n    \r\n    /** Get the front element. */\r\n    int peek() {\r\n        if (helperst.empty()) {\r\n            while (!realst.empty()) {\r\n                helperst.push(realst.top());\r\n                realst.pop();\r\n            }\r\n        }\r\n\r\n        return helperst.top();\r\n    }\r\n    \r\n    /** Returns whether the queue is empty. */\r\n    bool empty() {\r\n        return realst.empty() && helperst.empty();\r\n    }\r\nprivate:\r\n    stack<int> realst;\r\n    stack<int> helperst;\r\n};\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：$O(n)$\r\n- 空间复杂度：$O(n)$\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-sui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991831999","body":"var addToArrayForm = function(A, K) {\n    const res = [];\n    const n = A.length;\n    for (let i = n - 1; i >= 0 || K > 0; --i, K = Math.floor(K / 10)) {\n        if (i >= 0) {\n            K += A[i];\n        }\n        res.push(K % 10);\n    }\n    res.reverse();\n    return res;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992487560","body":"/**\r\n * @param {string} S\r\n * @param {character} C\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function (S, C) {\r\n  // 窗口左边界，如果没有就初始化为 Infinity，初始化为 S.length 也可以\r\n  let l = S[0] === C ? 0 : Infinity,\r\n    // 窗口右边界\r\n    r = S.indexOf(C, 1);\r\n\r\n  const res = Array(S.length);\r\n\r\n  for (let i = 0; i < S.length; i++) {\r\n    // 计算字符到当前窗口左右边界的最小距离\r\n    res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\r\n\r\n    // 遍历完了当前窗口的字符后，将整个窗口右移\r\n    if (i === r) {\r\n      l = r;\r\n      r = S.indexOf(C, l + 1);\r\n    }\r\n  }\r\n\r\n  return res;\r\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993299762","body":"/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n    this.queue = [];\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.queue.length<this.maxSize) this.queue.push(x)\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.queue.length==0) return -1;\n    return this.queue.pop()\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let i=0;\n    while(i<k&&i<this.queue.length){\n        this.queue[i] += val\n        i++\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994751248","body":"var decodeString = (s) => {\n  let stack = []\n  for (const char of s) {\n    if (char !== ']') { \n      stack.push(char)\n      continue\n    }\n    let cur = stack.pop() \n    let str = '' \n    while (cur !== '[') {\n      str = cur + str \n      cur = stack.pop() \n    }\n    let num = ''\n    cur = stack.pop() \n    while (!isNaN(cur)) {\n      num = cur + num \n      cur = stack.pop() \n    }\n    stack.push(cur)\n    stack.push(str.repeat(num))\n  }\n  return stack.join('')\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995503995","body":"var MyQueue = function() {\r\n    this.inStack = [];\r\n    this.outStack = [];\r\n};\r\n\r\nMyQueue.prototype.push = function(x) {\r\n    this.inStack.push(x);\r\n};\r\n\r\nMyQueue.prototype.pop = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack.pop();\r\n};\r\n\r\nMyQueue.prototype.peek = function() {\r\n    if (!this.outStack.length) {\r\n        this.in2out();\r\n    }\r\n    return this.outStack[this.outStack.length - 1];\r\n};\r\n\r\nMyQueue.prototype.empty = function() {\r\n    return this.outStack.length === 0 && this.inStack.length === 0;\r\n};\r\n\r\nMyQueue.prototype.in2out = function() {\r\n    while (this.inStack.length) {\r\n        this.outStack.push(this.inStack.pop());\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"52hzecho":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bochengwan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993116397","body":"### 思路\r\n利用一个额外的stack来存delta\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.myStack = []\r\n        self.delta = []\r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.myStack)<self.maxSize:\r\n            self.myStack.append(x)\r\n            self.delta.append(0)\r\n        \r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if len(self.myStack)==0:\r\n            return -1\r\n        delta = self.delta.pop()\r\n        \r\n        if self.delta:\r\n            self.delta[-1]+=delta\r\n        return self.myStack.pop()+delta\r\n        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = len(self.myStack)\r\n        if length ==0:\r\n            return None\r\n        inc_length = k\r\n        if k>length:\r\n            inc_length = length     \r\n        self.delta[inc_length-1]+=val\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：push,pop O(1), increment O(min(K, maxSize))\r\n- 空间复杂度：O(maxSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994972347","body":"### 思路\r\n\r\n通过辅助栈作为pop的存储，通过主栈作为push的存储\r\n\r\n### 代码\r\n\r\n\r\n```java（此处换成你的语言，比如js，py 等）\r\nclass MyQueue:\r\n    from collections import deque\r\n    def __init__(self):\r\n        \"\"\"\r\n        Initialize your data structure here.\r\n        \"\"\"\r\n        self.main_stack = []\r\n        self.aux_stack = []\r\n        \r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        \"\"\"\r\n        Push element x to the back of queue.\r\n        \"\"\"\r\n        if len(self.main_stack) == 0:\r\n            self.front = x\r\n        self.main_stack.append(x)\r\n            \r\n        \r\n\r\n    def pop(self) -> int:\r\n        \"\"\"\r\n        Removes the element from in front of queue and returns that element.\r\n        \"\"\"\r\n        if len(self.aux_stack)==0:\r\n            \r\n            self.aux_stack = self.main_stack[::-1]\r\n            self.main_stack = []\r\n        return self.aux_stack.pop()\r\n        \r\n\r\n    def peek(self) -> int:\r\n        \"\"\"\r\n        Get the front element.\r\n        \"\"\"\r\n        if len(self.aux_stack) == 0:\r\n            return self.front\r\n        return self.aux_stack[-1]\r\n\r\n    def empty(self) -> bool:\r\n        \"\"\"\r\n        Returns whether the queue is empty.\r\n        \"\"\"\r\n        \r\n        return len(self.main_stack)==0 and len(self.aux_stack)==0\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lareinawei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chiajune":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzh-zh3ndu1":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lydia61":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"astrking":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"doublew2w":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992618576","body":"## 思路\n遍历一次数组，将字符c的位置记录下来\n\n再次遍历数组，然后比较当前字符和目标字符的最小距离\n\n## 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> arr = new ArrayList<>();\n        int[] ret = new int[s.length()];\n        int p = 0;\n        //遍历数组，将字符C的位置存放起来\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) arr.add(i);\n        }\n        //遍历数组，比较出距离的最小值\n        for (int i = 0; i < s.length(); i++) {\n            //如果当前字符夹在两个目标字符中间，则比较最小的，否则直接取\n            if (p < arr.size() - 1 && Math.abs(arr.get(p) - i) > Math.abs(arr.get(p + 1) - i)) p++;\n            ret[i] = Math.abs(arr.get(p) - i);\n        }\n        return ret;\n    }\n}\n\n```\n## 复杂度分析\n\n时间复杂度：O（n）\n\n空间复杂度：O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forschers":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"toms-bigdata":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834648","body":"# 【Day 1】989. 数组形式的整数加法\n## 思路\n数字转化成数组，按位相加，注意进位\n## Golang代码\n```\nfunc reverse(num []int) {\n\tfor i, j := 0, len(num)-1; i < j; {\n\t\tnum[i], num[j] = num[j], num[i]\n\t\ti++\n\t\tj--\n\t}\n}\n\nfunc addToArrayForm(num []int, k int) []int {\n\tif k == 0 {\n\t\treturn num\n\t}\n\tk_list := make([]int, 5)\n\n\tfor i:=0;k != 0;i++{\n\t\tk_list[i] = k%10\n\t\tk/=10\n\t}\n\tmax_length := int(math.Max(float64(len(num)), float64(len(k_list)))) + 1\n\tans := make([]int, max_length)\n\treverse(num)\n\n\tfor i := 0; i < max_length; i++ {\n\t\tnum_num := 0\n\t\tk_num := 0\n\t\tans_num := ans[i]\n\t\tif i < len(num) {\n\t\t\tnum_num = num[i]\n\t\t}\n\t\tif i < len(k_list) {\n\t\t\tk_num = k_list[i]\n\t\t}\n\t\tdata := num_num + k_num + ans_num\n\t\tif data >= 10 {\n\t\t\tans[i+1] += 1\n\t\t}\n\t\tans[i] = data % 10\n\t}\n\n\treverse(ans)\n\ti := 0\n\tfor ans[i] == 0 {\n\t\ti++\n\t}\n\treturn ans[i:]\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992046651","body":"# 【Day 2】821. 字符的最短距离\n## 思路\n建立距离数组，找到首位和末位的字符，将距离数组首位字符之前和末位字符后的字符距离更新，之后将两字符之间的字母前向遍历一次，后向遍历一次，更新距离数组，返回距离数组\n## 代码\n```\nfunc shortestToChar(s string, c byte) []int {\n\tfirst_num := strings.IndexByte(s, c)\n\tlast_num := strings.LastIndexByte(s, c)\n\tarray := make([]int, len(s))\n\tif first_num == last_num {\n\t\tfor i := 0; i < len(s); i++ {\n\t\t\tarray[i] = int(math.Abs(float64(i - first_num)))\n\t\t}\n\t\treturn array\n\t}\n\n\tfor k, _ := range s[:first_num] {\n\t\tarray[k] = int(math.Abs(float64(k - first_num)))\n\t}\n\tif last_num < len(s)-1 {\n\t\tfor i := last_num;i<len(s);i++{\n\t\t\tarray[i] = int(math.Abs(float64(i - last_num)))\n\t\t}\n\t}\n\tif first_num + 1 < last_num{\n\t\tperiod_num := first_num\n\t\tfor i := first_num; i < last_num; i++ {\n\n\t\t\tif s[i] == c {\n\t\t\t\tperiod_num = i\n\t\t\t}\n\t\t\tarray[i] = int(math.Abs(float64(i - period_num)))\n\t\t}\n\t\tperiod_num = last_num\n\t\tfor i := last_num; i > first_num; i-- {\n\t\t\tif s[i] == c {\n\t\t\t\tperiod_num = i\n\t\t\t}\n\t\t\tarray[i] = int(math.Min(math.Abs(float64(i-period_num)), float64(array[i])))\n\t\t}\n\t}\n\treturn array\n}\n```\n## 复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993081130","body":"# 【Day 3】1381. 设计一个支持增量操作的栈\n## 思路\n数组模拟栈，唯一区别在inc,比较数组长度和K值，再循环增加\n## Golang代码\n```\ntype CustomStack struct {\n\tStack []int\n\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n\tif maxSize < 0{\n\t\treturn CustomStack{}\n\t}\n\treturn CustomStack{\n\t\tStack: make([]int , 0, maxSize),\n\t}\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n\tif len(this.Stack) < cap(this.Stack){\n\t\tthis.Stack = append(this.Stack, x)\n\t}\n}\n\n\nfunc (this *CustomStack) Pop() int {\n\tif len(this.Stack) == 0 {\n\t\treturn -1\n\t}else {\n\t\tpop := this.Stack[len(this.Stack)-1]\n\t\tthis.Stack = this.Stack[:len(this.Stack)-1]\n\t\treturn pop\n\t}\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n\tchange_num := int(math.Min(float64(k), float64(len(this.Stack))))\n\tfor i :=0;i<change_num;i++{\n\t\tthis.Stack[i] += val\n\t}\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994827676","body":"# 【Day 4】394. 字符串解码\n## 思路\n用栈执行括号匹配\n## golang代码\n```\nfunc decodeString(s string) string {\n\tstk := []string{}\n\tptr := 0\n\tfor ptr < len(s) {\n\t\tcur := s[ptr]\n\t\tif cur >= '0' && cur <= '9' {\n\t\t\tdigits := getDigits(s, &ptr)\n\t\t\tstk = append(stk, digits)\n\t\t} else if (cur >= 'a' && cur <= 'z' || cur >= 'A' && cur <= 'Z') || cur == '[' {\n\t\t\tstk = append(stk, string(cur))\n\t\t\tptr++\n\t\t} else {\n\t\t\tptr++\n\t\t\tsub := []string{}\n\t\t\tfor stk[len(stk)-1] != \"[\" {\n\t\t\t\tsub = append(sub, stk[len(stk)-1])\n\t\t\t\tstk = stk[:len(stk)-1]\n\t\t\t}\n\t\t\tfor i:=0;i<len(sub)/2;i++{\n\t\t\t\tsub[i],sub[len(sub)-i-1] = sub[len(sub)-i-1],sub[i]\n\t\t\t}\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\trepTime,_:=strconv.Atoi(stk[len(stk)-1])\n\t\t\tstk = stk[:len(stk)-1]\n\t\t\tt := strings.Repeat(getString(sub), repTime)\n\t\t\tstk = append(stk, t)\n\t\t}\n\t}\n\treturn getString(stk)\n}\n\nfunc getDigits(s string, ptr *int) string {\n\tret := \"\"\n\tfor ; s[*ptr] >= '0' && s[*ptr] <= '9'; *ptr++ {\n\t\tret += string(s[*ptr])\n\t}\n\treturn ret\n}\nfunc getString(v []string) string {\n\tret := \"\"\n\tfor _, s := range v {\n\t\tret += s\n\t}\n\treturn ret\n}\n```\n复杂度\n时间:O(n)\n空间:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995388032","body":"# 【Day 5】232. 用栈实现队列\n## 思路\n两个栈一个队头一个队尾，因golang语言特性，无需考虑溢出问题，push直接往队头栈推进，pop和peak判断队尾栈是否为空，为空则队头栈出，队尾栈入。\n## golang代码\n```\ntype MyQueue struct {\n\tfirstack []int\n\tsecstack []int\n}\n\n\nfunc Constructor() MyQueue {\n\treturn MyQueue{\n\t\tfirstack: []int{},\n\t\tsecstack: []int{},\n\t}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n\tthis.firstack = append(this.firstack,x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n\tif len(this.secstack) != 0{\n\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\tthis.secstack = this.secstack[:len(this.secstack)-1]\n\t\treturn popnum\n\t} else {\n\t\tif len(this.firstack) == 0{\n\t\t\treturn -1\n\t\t}else {\n\t\t\tfor len(this.firstack)!= 0{\n\t\t\t\tnum:= this.firstack[len(this.firstack)-1]\n\t\t\t\tthis.firstack = this.firstack[:len(this.firstack)-1]\n\t\t\t\tthis.secstack = append(this.secstack, num)\n\t\t\t}\n\t\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\t\tthis.secstack = this.secstack[:len(this.secstack)-1]\n\t\t\treturn popnum\n\t\t}\n\t}\n}\n\n\nfunc (this *MyQueue) Peek() int {\n\tif len(this.secstack) != 0{\n\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\treturn popnum\n\t} else {\n\t\tif len(this.firstack) == 0{\n\t\t\treturn -1\n\t\t}else {\n\t\t\tfor len(this.firstack)!= 0{\n\t\t\t\tnum:= this.firstack[len(this.firstack)-1]\n\t\t\t\tthis.firstack = this.firstack[:len(this.firstack)-1]\n\t\t\t\tthis.secstack = append(this.secstack, num)\n\t\t\t}\n\t\t\tpopnum := this.secstack[len(this.secstack) -1]\n\t\t\treturn popnum\n\t\t}\n\t}\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n\tif len(this.firstack) == 0 && len(this.secstack) == 0{\n\t\treturn true\n\t}\n\treturn false\n}\n```\n## 时间复杂度\npush:O(1)\npop,peak:因为队尾栈空时才会执行多次出入栈操作，平均时间复杂度为O(1)\nempty:O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jaywx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wu-zonglin":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"socrates2001":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shinnost":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"v-enzo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hwfrankfung":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991913378","body":"Codes\n-\n```javascript\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992480645","body":"Codes\n-\n```javascript\nvar shortestToChar = function(s, c) {\n    let arrs=s.split(c)\n    let res=[]\n    for(let i=0; i<arrs.length; i++) {\n        let len=arrs[i].length\n        for(let j=0; j<arrs[i].length; j++) {\n            if(i==0){\n                res.push(arrs[i].length-j)\n            }else{\n                if(i+1<arrs.length){\n                    res.push((1+j>len-j)?(len-j):(1+j))\n                }else{\n                    res.push(j+1)\n                }\n            }\n        }\n        if(i+1<arrs.length){\n            res.push(0)\n        }\n    }\n    return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993556331","body":"Codes\n-\n```javascript\n\nvar CustomStack = function(maxSize) {\n    this.array = [];\n    this.size = maxSize;\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.array.length < this.size){\n        this.array.push(x);\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.array.length == 0){\n        return -1;\n    }\n    return this.array.splice(this.array.length-1,1);\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < k; i++){\n        if(this.array[i]!=undefined){\n            this.array[i] =  this.array[i] + val;\n        }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994892607","body":"Codes\n-\n```javascript\nvar decodeString = function (s) {\n  let [stack, num, str] = [[], '', ''];\n    if (!isNaN(s[i])) {\n      num += s[i];\n      if (isNaN(s[i + 1])) {\n        stack.push(Number(num));\n        num = '';\n      }\n    } else if (s[i] === ']') {\n      str = '';\n      while (stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str;\n      }\n      stack.pop();\n      stack.push(str.repeat(stack.pop()));\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mrhero-web":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hondrytravis":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054401","body":"### 思路\n\n遍历每一个字符，对当前字符设左右双指针，返回较近c和当前字符距离。\n\n### 代码\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n    const result = []\n    \n    //  先找到前两个出现的位置\n    for (let i = 0, l = S.indexOf(C), r = S.indexOf(C, l + 1); i < S.length; i++) {\n        // 计算与左指针的距离\n        result[i] = Math.abs(l - i)\n        if (r === -1) continue\n\n        // 如果右指针存在,取较小的距离\n        result[i] = Math.min(result[i], r - i)\n\n        // 走到右指针则左右指针往下一个\n        if (i != r ) continue\n\n        result[i] = 0\n        l = r\n        r = S.indexOf(C, r + 1)\n    }\n    return result\n};\n```\n\n### 复杂度分析\n\n时间复杂度 O(n)\n\n空间复杂度 O(1)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awenbocc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vincentlw":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"richard-lyf":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922848","body":"class Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        carry = 0\n        nums = num\n        for i in range(len(num)-1,-1,-1):\n            tmp = (nums[i] + k % 10 + carry) % 10\n            carry = (nums[i] + k % 10 + carry) // 10\n            nums[i] = tmp\n            k = k // 10  \n\n        s = k + carry\n        b = []\n        while s:\n             b = [s % 10] + b\n             s = s // 10\n        return b + nums\n\n        # o n + max(0 , k-n)2  o max(1, k-n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992619471","body":"class Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i\r\n            ans.append(i - prev)\r\n        prev = float('inf')\r\n        for i in range(len(s) - 1, -1, -1):\r\n            if s[i] == c:\r\n                prev = i \r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n        \r\n        \r\n\r\n\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993667016","body":"class CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994861397","body":"class Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n        # on on","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gjts":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aruseito":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"harleyszhang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"badcoderchou":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"auto-sk":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"breezepython":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jianxinyu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cruiseyugh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abby-xu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zetavi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"anhtom2000":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhi22":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991886091","body":"```python3\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        lk = []\n        addOne = 0\n        while k:\n            k, m = divmod(k, 10)\n            lk.append(m)\n        ln = len(num); llk = len(lk)\n        res = [0 for _ in range(max(ln, llk)+1)]\n        num.reverse()\n        idx = 0\n        while idx < ln and idx < llk:\n            sum = num[idx] + lk[idx] + addOne\n            res[idx] = sum % 10\n            addOne = 0\n            if sum >= 10: addOne = 1\n            idx += 1\n        remain = num if ln > llk else lk\n        while idx < len(remain) or addOne:\n            if idx < len(remain): res[idx] += remain[idx]\n            res[idx] += addOne\n            addOne = 0\n            idx += 1\n            if res[idx] >= 10:\n                res[idx] %= 10\n                addOne = 1\n        if res[-1] == 0: res.pop()\n        res.reverse()\n        return res\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"master-guang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenjingjing85":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994926710","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        enTmp = ''\n        numTmp = ''\n        times = 0\n        stack = []\n        for ch in s:\n            if ch.isnumeric():\n                numTmp += ch\n            elif ch.isalpha():\n                enTmp += ch\n            elif ch =='[':\n                if numTmp != '':\n                    stack.append(int(numTmp))\n                if enTmp != '':\n                    stack.append(enTmp) \n                enTmp = ''\n                numTmp = ''\n            elif ch == ']':\n                en = stack.pop()\n                num = stack.pop()\n                en_whole = ''\n                for i in range(num):\n                    en_whole += en\n                stack.append(en)\n        return stack.pop()","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"forlittlebeauty":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991717494","body":"## 思路\n\n***\n\n1. sum the value of the num list\n2. add k\n3. return the list form of the final value\n\n***\n\n## 代码\n\n``` python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        # numSum = 0\n        # for n in num:\n        #     numSum = numSum*10+n\n        # numSum += k\n        # return list(str(numSum))\n        return (list(str(int(\"\".join(map(str, num))) + k)))\n```\n\n\n\n***\n\n时间复杂度: O(n) \n\n空间复杂度: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991975436","body":"## 思路\n\n***\n\n1. scan the list from left to right, when find c set the index = the position of c, so that our result array can record the distance between a character and the c show before that character.\n2. scan the list from right to left, change index whenever encounter a c. make record[i] = min(abs(i-index),record[i])\n\n***\n\n## 代码\n\n``` python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = []\n        index = len(s)-1\n        for i in range(len(s)):\n            if s[i]==c:\n                index = i\n            result.append(abs(index-i))\n        \n        index = 0\n        for i in range(len(s)-1,-1,-1):\n            if s[i]==c:\n                index = i\n            result[i] = min(result[i],abs(index-i))\n        return result\n```\n\n\n\n***\n\n时间复杂度: O(n) \n\n空间复杂度: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuxy94":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991874521","body":"## 思路\n把num先变成int 然后sum_int = k+num_int 再把sum_int变成sum_array\n\n## 代码\n``` python\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        ## step0: corner case\n        if k == 0:\n            return num\n        ## step1: change the array to number\n        n = len(num)\n        num_int = 0\n        for i in range(n):\n            num_int += num[i]*10**(n-1-i)\n        ## step2: compute the sum\n        sum_int = num_int + k\n        sum_array = []\n        ## step3: change the sum to array\n        while sum_int != 0:\n            quotient = sum_int//10\n            remainder = sum_int%10\n            ## update sum array and int\n            sum_array.insert(0,remainder)\n            sum_int = quotient\n        \n        return sum_array\n```\n\n## 复杂度分析\n时间 O(n^2)\n\n空间 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992302693","body":"## 思路\n1. 利用c在s的位置，初始化res\n2. 先计算左侧最短距离，存入res\n3. 再计算右侧最短距离，与之前结果比较，并存入res\n\n## 代码\n```python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        ## step1: setup result by the postion of c\n        n = len(s)\n        result = []\n        for i in range(n):\n            if s[i]==c:\n                result.append(0)\n            else:\n                result.append(n)\n        #step2: compute the min distance from left \n        for i in range(1,n):\n            result[i] = min(result[i], result[i-1]+1)\n        #step3: compute the min distance from right and compare with previous result\n        for i in range(-2,-(n+1),-1):\n            result[i] = min(result[i],result[i+1]+1)\n        \n        return result\n    ```\n\n## 复杂度分析\n空间: O(n)\n\n时间: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993570732","body":"## 思路\n非常naive的想法， 用array来实现stack。 优化后的算法可以参考官方题解\n\n## 代码\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.curSize = 0\n        self.stack = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if self.curSize < self.maxSize:\n            self.stack.append(x)\n            self.curSize += 1\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n\n        if self.stack:\n            self.curSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k,self.curSize)):\n            self.stack[i] += val\n\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## 复杂度分析\n时间复杂度：\npop/push: O(1)\nincrement: O(min(k,curSize))\n\n空间复杂度： O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993796863","body":"## 思路\n用stack 直接解决\n遇到 ']' 清空栈 考虑到数字不一定是个位数 我们先用str来记录 count 然后记得pop掉 '['\n\n## 代码\n```pyhton\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for char in s:\n            if char == ']':\n                ## clear the stack and reset everything\n                string = ''\n                count = ''\n                while stack and stack[-1]!='[':\n                    string = stack.pop() + string\n                stack.pop() # pop the '['\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(string*int(count))\n            else:\n                stack.append(char)\n        return ''.join(stack)\n```\n\n## 复杂度分析\n时间 O(n)\n\n空间 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995335217","body":"## 思路\n两个stack stack1装插入 stack2等到pop的时候 辅助stack1 清空\n\n## 代码\n``` pyhton\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if self.stack2:\n            return self.stack2.pop()\n        else:\n            self.stack2 = self.stack1[::-1]\n            self.stack1 = []\n            return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        elif self.stack1:\n            return self.stack1[0]\n\n    def empty(self) -> bool:\n        if (not self.stack1) and (not self.stack2):\n            return True\n        else:\n            return False\n\n```\n\n## 复杂度分析\n时间： O(n)\n\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xinnxuu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991851926","body":"# Idea\n\n---\n\n- Add numbers from right to left digit by digit. Add k's units' digit to first sum, tens' digit to second sum, hundreds' digit to third sum, and so on.\n- Beware of  the case that k > num.  (Whether k > 0 after the num loop)\n- And remember to reverse the result list.\n\n# Code (Java)\n\n---\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        for (int i = num.length - 1; i >= 0; i--){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                k++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        \n        while (k > 0){\n            res.add(k % 10);\n            k /= 10;\n        }\n        \n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# Complexity\n\n---\n\n- Time Complexity: O(N)\n- Space Complexity: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991973335","body":"## Notes\r\n\r\nTraverse the string twice, one from left to right, and one from right to left.\r\n\r\n## Code (Java)\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n]; \r\n        //left to right\r\n        int right = -10001;\r\n        for (int i = 0; i < n; i++){\r\n            res[i] = i - right;\r\n            if (s.charAt(i) == c){\r\n                res[i] = 0;\r\n                right = i;\r\n            }\r\n        }\r\n        //right to left\r\n        int left = 10001;\r\n        for (int i = n - 1; i >= 0; i--){\r\n            if (res[i] > left - i){\r\n                res[i] = left - i;\r\n            }\r\n            if (s.charAt(i) == c){\r\n                res[i] = 0;\r\n                left = i;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n\r\n```\r\n\r\n## Complexity\r\n\r\n- Time: O(N), N is the length of string s.\r\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993289238","body":"\r\n```java\r\n//1.原始解法\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top != -1) {\r\n            return stack[top--];\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n//2.增加一个数组专门记录increment，优化increment操作的时间复杂度至O(1)\r\nclass CustomStack {\r\n\r\n    int[] stack;\r\n    int top;\r\n    int[] add;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        add = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1){\r\n            stack[++top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1){\r\n            return -1;\r\n        }\r\n        int res = stack[top] + add[top];\r\n        if (top != 0) {\r\n            add[top - 1] += add[top];\r\n        } \r\n        add[top] = 0;\r\n        top--;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k - 1, top);\r\n        if (limit > -1){\r\n            add[limit] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n1. 解法1\r\n- 时间复杂度：除了increment是O(k), 其他全部是 O(1)\r\n- 空间复杂度：O(maxSize)\r\n2. 解法2\r\n- 时间复杂度：全部是 O(1)\r\n- 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994034613","body":"**思路**\n\n首先将除了右括号所有的字符全部压入栈，遇右括号之后开始出栈：先分别取得字母串和倍数，再按倍数重新把字母串压入栈中。最后打印出已经整理好的栈中全部内容即可。\n\n**代码**\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c != ']') {\n                stack.push(c);\n            } else {\n                //Push letters to stack\n                StringBuilder sb = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() >= 'a' && stack.peek() <= 'z' ){\n                    sb.insert(0, stack.pop()); \n                }\n                String str = sb.toString();\n                stack.pop(); //delete '['\n                //Push numbers to stack\n                StringBuilder num = new StringBuilder();\n                while(!stack.isEmpty() && stack.peek() >= '0' && stack.peek() <= '9' ){\n                    num.insert(0, stack.pop());\n                }\n                int count = Integer.valueOf(num.toString());\n                while (count > 0) {\n                    for (char ch : str.toCharArray()) {\n                        stack.push(ch);\n                    }\n                    count--;\n                }         \n            }\n        }\n        while (!stack.isEmpty()) {\n            res.insert(0, stack.pop());\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为解码后的 s 的长度\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995427677","body":"### **思路**\n\n用两个栈（pushStack 和 popStack）来模拟队列，每次队列进行push操作时先检查负责popStack中是否有元素，有则全部出栈到pushStack，再进行push。pop和peek操作则是先检查pushStack中是否有元素，有则全部出栈到popStack，再进行pop或peek。\n\n### **代码**\n\n```java\nclass MyQueue {\n    Stack<Integer> pushStack;\n    Stack<Integer> popStack;\n\n    public MyQueue() {\n         pushStack = new Stack<>();\n         popStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```\n\n### **复杂度分析**\n\n- 时间复杂度：push，pop，peek这三个操作为O(N)，N为栈的长度。其他操作O(1)。\n- 空间复杂度：O(N)，使用了两个栈。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weisday":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"missnanlan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866075","body":"## 思路\n\n1、逐位相加法，逐位数字相加在一起，遇到相加等于 10 的时候要进位，把进位的 1 加入到下一位计算中\n\n2、将整个加数 k 加数加入数组表示数的最低位(简单点)\n\n## 关键点\n\n- 要考虑进位的情况， 比如 num=[3,6,9]，n=45\n- 要考虑 n>num 的长度 的情况，比如 num=[3,6]，n=789\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n### 解法 1 逐位相加法\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\n\nvar addToArrayForm = function (n, k) {\n  var res = [];\n  for (var i = n.length - 1; i >= 0; --i) {\n    var sum = n[i] + (k % 10);\n    k = Math.floor(k / 10);\n    // 如果相加大于10，则进位，把进位的1加入到下一位计算中\n    if (sum >= 10) {\n      k++;\n      sum = sum % 10;\n    }\n    res.push(sum);\n  }\n  // 如果n>num的长度\n  for (; k > 0; k = Math.floor(k / 10)) {\n    res.push(k % 10);\n  }\n\n  return res.reverse();\n};\n```\n\n### 解法 2 将整个加数 k 加数加入数组表示数的最低位\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  const res = [];\n  const n = num.length;\n  for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n    if (i >= 0) {\n      k += num[i];\n    }\n    res.push(k % 10);\n  }\n  res.reverse();\n  return res;\n};\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(max(n,logk))$\n- 空间复杂度：$O(n)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992553025","body":"## 思路1\n\n- 找出 c 的下标的位置，放入到一个数组 tempArr 里面\n- 用 tempArr 与 i 相减得到绝对值，与 tempArr 下一个元素作比较，前一个元素比较大，则 tempArr 向后移动一个位置\n- 前一个元素小，则不需要动\n- 以上思路是参照别人的解法，感觉用两个循环不是很优雅，希望以后还是有自己的想法\n\n## 关键点\n\n- 如何求出两个下标之间的距离（两个下标相减的绝对值）\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (str, c) {\n  var answer = [];\n  var tempArr = [];\n  var k = 0;\n  // 找出 c的下标的位置，放入到一个数组tempArr里面\n  for (var i = 0; i < str.length; i++) {\n    var s = str.charAt(i);\n    if (s === c) tempArr.push(i);\n  }\n  //  用tempArr与i相减得到绝对值，与tempArr下一个元素作比较，前一个元素比较大，则tempArr向后移动一个位置\n  // 前一个元素小，则不需要动\n  for (var i = 0; i < str.length; i++) {\n    if (\n      k < tempArr.length - 1 &&\n      Math.abs(tempArr[k] - i) > Math.abs(tempArr[k + 1] - i)\n    )\n      k++;\n    answer.push(Math.abs(tempArr[k] - i));\n  }\n  return answer;\n};\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：O(n)\n- 空间复杂度：O(n)，这里有些疑问，不知道算不算O(2n)\n\n-----------\n\n## 思路2\n\n- 窗口，参照西法大佬的窗口解法\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function (s, c) {\n     \n   // 定义左边界,右边界\n    let l = s[0] === c ? 0 : Infinity, r = s.indexOf(c, 1);\n    const res = Array(s.length);\n\n    for (let i = 0; i < 1; i++) {\n        res[i] = Math.min(Math.abs(i - l), Math.abs(r - i));\n        \n        // 如果滑动到边界，则继续向右滑动\n        if (i === r) {\n            l = r;\n            r = s.indexOf(c,l+1)\n        } \n    }\n\n    return res;\n\n};\n\n```\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993620721","body":"## 思路1\r\n\r\n``` javascript\r\n\r\nvar CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    return this.arr.push(x);\r\n  }\r\n};\r\n\r\n\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length > 0) {\r\n    return this.arr.pop();\r\n  }\r\n  return -1;\r\n};\r\n\r\n\r\n\r\nCustomStack.prototype.increment = function (k, val) {\r\n  for (var i = 0; i < k && i < this.arr.length; i++) {\r\n    this.arr[i] += val;\r\n  }\r\n};\r\n\r\n```\r\n\r\n时间复杂度：push 和 pop 操作的时间复杂度为 O(1)，而 increment 操作的时间复杂度为 O(k)\r\n\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994903453","body":"``` javascript\n参照西法大佬的思路，试着用js，发现测试用例没有完全过去\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function (s) {\n  var repeatStr = \"\";\n  var repeatCount = 0;\n\n  var stack = [];\n\n  for (var i = 0; i < s.length; i++) {\n    // 出栈\n\n    if (s[i] === \"]\") {\n      repeatStr = \"\";\n      repeatCount = 0;\n\n      // 出栈是字母的话\n      while (stack[stack.length - 1] != \"[\") {\n        repeatStr = stack.pop() + repeatStr;\n      }\n\n      // pop 掉 [\n      stack.pop();\n\n      // 出栈是数字的话\n      while (stack[stack.length - 1] >= \"0\" && stack[stack.length - 1] <= \"9\") {\n        repeatCount = repeatCount*10 + Number(stack.pop());\n        stack.push(repeatStr.repeat(repeatCount));\n      }\n    } else {\n      // 入栈\n      stack.push(s[i]);\n    }\n  }\n  return stack.join(\"\");\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"venchyluo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yuanwenlai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sjingz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jlin-data":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"victoria011":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995340641","body":"思路\r\n\r\n使用两个 list, input 用来存输入, output 用来pop 元素(逆序输出) \r\n\r\n\r\n\r\n代码\r\n\r\n    class MyQueue:\r\n        def __init__(self):\r\n            self.input = []\r\n            self.output = []\r\n    \r\n        def push(self, x):\r\n            self.input.append(x)\r\n    \r\n        def pop(self):\r\n            self.peek()\r\n            return self.output.pop()\r\n    \r\n        def peek(self):\r\n            if not self.output:\r\n                while self.input:\r\n                    self.output.append(self.input.pop())\r\n            return self.output[-1]        \r\n    \r\n        def empty(self):\r\n            return not self.input and not self.output\r\n\r\n复杂度分析\r\n\r\nTime complexity: O(1)\r\n\r\nSpace complexity: O(1)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coreja":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991915086","body":"# 思路\n方法挺多的，可以用map以及reduce的方法把列表转字符串再转数字，最后再换成列表\n\n更合理的方法是运用列表模拟进位等操作，把k直接加到num的最后一位里，然后再进位，k自除10，num最后一位取余保留，直到k为0.\n\n# 代码\n```python\nclass Solution:\n    def addToArrayForm1(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(int(\"\".join(map(str, num))) + k)))\n\n    def addToArrayForm2(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(k + reduce(lambda x, y: 10 * x + y, num))))\n\n    def addToArrayForm3(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        carry = 0\n        res = []\n        while k or i >= 0:\n            left = k % 10\n            res_dig = num[i] + left + carry if i >= 0 else left + carry\n            if res_dig >= 10:\n                carry = 1\n                res_dig %= 10\n            else:\n                carry = 0\n            res.insert(0, res_dig)\n            i -= 1\n            k //= 10\n        if carry:\n            res.insert(0, 1)\n        return res\n\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num) - 1\n        while k:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n            if i < 0 and k:\n                num.insert(0, 0)\n                i = 0\n        return num\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992036434","body":"# 思路\n贪心法，从左到右+从右到左遍历，取最小值即可。\n\n简单描述就是，从第一个c开始向右遍历数组，下标c的结果取0，后面的结果就分别递增直到再次遇到c置0。同样的过程从最后一个c开始向左遍历，第二次遍历的时候和第一遍遍历的结果比较，取最小值。\n\n# 代码\n```python\nclass Solution:\n    # 贪心解法\n    def shortestToChar1(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [float('inf')] * n\n        cnt = float('inf')\n        for i in range(n):\n            if s[i] == c:\n                ans[i] = 0\n                cnt = 0\n            else:\n                cnt += 1\n                ans[i] = cnt\n        cnt = float('inf')\n        for i in range(n - 1, -1, -1):\n            if s[i] == c:\n                cnt = 0\n                continue\n            else:\n                cnt += 1\n                ans[i] = min(cnt, ans[i])\n        return ans\n    # 贪心法简单写法\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        ans = [0 if ch == c else None for ch in s]\n\n        for i in range(1, n):\n            if ans[i] != 0 and ans[i - 1] is not None:\n                ans[i] = ans[i - 1] + 1\n        for i in range(n - 2, -1, -1):\n            if ans[i] is None or ans[i] != 0 and ans[i + 1] + 1 < ans[i]:\n                ans[i] = ans[i + 1] + 1\n        return ans\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992851358","body":"# 思路\nnaive思路非常好想，按照需求实现即可\n\n但是考虑到increment操作针对的是栈，栈在这里只会访问栈顶，所以可以考虑对increment使用lazy操作\n只在出栈的时候去进行之前的increment操作，以规避对栈内元素过多的操作\n\n具体就是每次increment并不直接增加到它要求的栈底的k个元素，而是用另一个数组lazy_inc保存起来，\n只在pop的时候去加上lazy_inc的top-1元素，并将这个increment加到数组中的前一个元素中(这样就把它继承下去了)\n\n# 代码\n```python\n# naive思路\nclass CustomStack1:\n\n    def __init__(self, maxSize: int):\n        self.stack = [0] * maxSize\n        self.cur = 0\n\n    def push(self, x: int) -> None:\n        if self.cur >= len(self.stack):\n            return\n        self.stack[self.cur] = x\n        self.cur += 1\n\n    def pop(self) -> int:\n        if self.cur <= 0:\n            return -1\n        self.cur -= 1\n        return self.stack[self.cur]\n\n    def increment(self, k: int, val: int) -> None:\n        k = self.cur if k > self.cur else k\n        for i in range(k):\n            self.stack[i] += val\n\n\n#  lazy_increment做法\nclass CustomStack:\n    def __init__(self, maxSize: int):\n        self.top = 0\n        self.stack = [0] * maxSize\n        self.add = [0] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.top >= len(self.stack):\n            return\n        self.stack[self.top] = x\n        self.top += 1\n        return\n\n    def pop(self) -> int:\n        if self.top > 0:\n            self.top -= 1\n            self.stack[self.top] += self.add[self.top]\n            if self.top > 0:\n                self.add[self.top - 1] += self.add[self.top]\n            self.add[self.top] = 0\n            return self.stack[self.top]\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        k = min(k, self.top)\n        if k > 0:\n            self.add[k - 1] += val\n```\n# 复杂度\nTC: push O(1), increment O(1), pop O(1)\nSC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994069825","body":"# 思路\n经典栈的应用，遍历字符串，如果是数字就暂存在一个tmp_num字符串里，如果是字符那就直接入栈到stack。碰到 \"[\"就说明前面的数字读完了，把tmp_num转成int数字，入栈stack。\n\n此时栈的内容基本是数字+字符+数字+字符的组合，类似于`['c', 'r', 3, 'a', 'b', 2, 'x', 'y', 'z', 5, 'a', 'a']`，如果碰到了\"]\"，那就直接把数字之前的所有字符连成一起出栈，然后再把这个串重复这个数字遍。\n\n#代码\n```python\n    # 再写一遍，计算栈，不再使用\"#\"作为分隔了，可以当以后的板子用\n    def decodeString3(self, s: str) -> str:\n        tmp_num = \"\"\n        stack = []\n        for ch in s:\n            if ch == \"[\":\n                stack.append(int(tmp_num))\n                tmp_num = \"\"\n            elif ch == \"]\":\n                i = len(stack) - 1\n                while i >= 0:\n                    if isinstance(stack[i], int):\n                        break\n                    i -= 1\n                t = stack[i]\n                tmp = \"\".join(stack[i + 1:])\n                stack = stack[:i] + [tmp * t]\n            elif 48 <= ord(ch) <= 57:\n                tmp_num += ch\n            else:\n                stack.append(ch)\n        return \"\".join(stack)\n\n    # 参考题解写的递归法\n    def decodeString(self, s: str) -> str:\n\n        def dfs(i):\n            tmp_num = \"\"\n            res = \"\"\n            while i < len(s):\n                if '0' <= s[i] <= '9':\n                    tmp_num += s[i]\n                elif s[i] == '[':\n                    i, tmp = dfs(i + 1)\n                    res += tmp * int(tmp_num)\n                    tmp_num = \"\"\n                elif s[i] == ']':\n                    return i, res\n                else:\n                    res += s[i]\n                i += 1\n            return res\n\n        return dfs(0)\n\n```\n# 复杂度\nTC: O(n)\nSC: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995005971","body":"# 思路\n\n将一个栈定义为输入栈，一个栈定义为输出栈。\npush就往输入栈里压数据，pop的话就从输出栈里拿数据。如果输出栈里没有数据了，那就将输入栈的所有数据全部倒腾到输出栈里。\n\n这就好像是两个栈把底部黏在了一起，一个吃输入，一个吐输出，这就形成了一个队列。唯一要解决问题是两个栈之间的交流，即输入栈如何把数据挪到输出栈来。那要挪的时候没办法，只能一个一个搬，但是因为pop的总次数和搬运的总次数相当，所以\"均摊时间复杂度\"为 O(1)。\n这里解释一下，假设一共要pop n次，那么我一共也只需要挪n次数据(pop+push)，故均摊下来执行O(2n/n)得到O(1)的时间复杂度\n\n# 代码\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.front = None\n        self.in_stack = []\n        self.out_stack = []\n\n    def push(self, x: int) -> None:\n        if not self.in_stack:\n            self.front = x\n        self.in_stack.append(x)\n\n    def pop(self) -> int:\n        if not self.out_stack:\n            while self.in_stack:\n                self.out_stack.append(self.in_stack.pop())\n        return self.out_stack.pop()\n\n    def peek(self) -> int:\n        return self.out_stack[-1] if self.out_stack else self.front\n\n    def empty(self) -> bool:\n        return len(self.in_stack) == 0 and len(self.out_stack) == 0\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weilantao":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaozizhong":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pearlcoastal":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jinjin680":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"northseacoder":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"greyqt":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lagrangist":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asukareisj":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stefanleeee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huijunxu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"naivecoder1999":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxqkb":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"serena9":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995861211","body":"### 代码\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        \"\"\"\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        temp = self.stack2.pop()\n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n        return temp\n\n\n    def peek(self):\n        \"\"\"\n        Get the front element.\n        :rtype: int\n        \"\"\"\n        return self.stack1[0]\n\n\n    def empty(self):\n        \"\"\"\n        Returns whether the queue is empty.\n        :rtype: bool\n        \"\"\"\n        if len(self.stack1) == 0:\n            return True\n        else:\n            return False\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n\n### 复杂度\n时间复杂度：O(n)\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"imsingee":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzhengzhi":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"poidaze7":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"c2tr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"okkband":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bingbinxu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gz712d":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smallcodebo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zymacro":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"florencelll":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991916994","body":"### 思路\n1.把k转为数组，做数组逐位相加的运算，需要一个tmp array记录哪一位进1了;\n\n2.把num转为数字计算后再转数组;\n\n3.边把num加到k里，边存;\n\n\n采用3，有3个步骤：\n\n1.将num未计算的最低位取出来，跟k相加\n\n2.将k未存到AL的最低位存进去\n\n3.全部完成后 reverse刚刚的AL，因为是从低位存的，但每次都是addLast操作\n\n\n\n\n### 代码\n```Java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for (int i = num.length - 1; i >= 0 || k > 0; i--, k /= 10) {\n            //add num to k from low bits\n            if (i >= 0) {\n                k += num[i];\n            }\n            //add k's bit to AL from low\n            res.add(k % 10);\n        }\n        //reverse\n        Collections.reverse(res);\n        return res;   \n    }\n}\n```\n\n### 复杂度分析：\n时间复杂度 O(n)，这里n是 num、k的长度中的最大值(reverse的操作应该是logn的？）\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992191732","body":"### 思路\n左右两个指针，固定左指针，右指针遍历数组，计算最小距离\n\n明早学习一下O(n)是怎么解决的\n\n### 代码\n```Java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] ch = s.toCharArray();\n        int[] res = new int[ch.length];\n        \n        for (int i = 0; i < ch.length; i++) {\n            int dis = ch.length;\n            for (int j = ch.length -1; j >= 0; j--) {\n                if (ch[j] == c) {\n                    dis = Math.min(Math.abs(j - i), dis);\n                }\n            }\n            res[i] = dis;\n        }\n        return res;\n    }\n}\n```\n\n### 复杂度分析\n时间复杂度 O(n^2)\n\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993684390","body":"### 思路\n用数组做栈的底层，恰好是在尾部增删\n\n\n### 代码\n``` java\nclass CustomStack {\n    int[] stack;\n    int curSize;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        curSize = 0;    \n    }\n    \n    public void push(int x) {\n        if(curSize < stack.length) {\n            stack[curSize++] = x;\n        }\n    }\n    \n    public int pop() {\n        if(curSize > 0) {\n            return stack[--curSize];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        // int temp = Math.min(k,count);\n        for (int i = 0; i < k && i < curSize;i++){\n            stack[i] +=val;\n        }\n    }\n}\n\n```\n\n### 复杂度\n时间复杂度 push&pop O(1), increment O(n)\n\n空间复杂度 O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiwri-cc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kirito1017":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a-polarbear":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"krabbejing":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fullstackh":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"carinskyrim":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ziyangz":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"threegold-yxh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855499","body":"# [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n\n\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\n\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式。\n\n```java\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n```\n\n\n\n```java\n提示：\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n\n\n## 思路一\n\n模拟加法的过程即可\n\n\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //因为num的位数可以有10000位，所以肯定是超过了int，或者long的，那么只能通过数组按位计算\n        //每一位的值 = num数组在这一位上的值 + k数组在这一位上的值 + 前一位的进位\n        LinkedList<Integer> res = new LinkedList<>();\n        int carry = 0;\n        for(int i = num.length - 1; i >= 0; i--){\n            //拿当前k的最后一位 Take the last digit of the current k\n            int kLastDigital = k % 10;\n            //sum of the add\n            int sumOfAdd = num[i] + kLastDigital + carry;\n            //注意是头插到结果list中\n            res.addFirst(sumOfAdd % 10);\n\n            //处理carry和k\n            carry = sumOfAdd / 10;\n            k = k / 10;\n        }\n        //如果k提前结束了，那没有关系，后面全部加的都是0\n        //但如果是num先结束了，k还有剩余，那还要把k给处理完\n        while(k != 0){\n            int kLastDigital = k % 10;\n            int sumOfAdd = kLastDigital + carry;\n            //注意是头插到结果list中\n            res.addFirst(sumOfAdd % 10);\n            //处理carry和k\n            carry = sumOfAdd / 10;\n            k = k / 10;\n        }\n        //最后还要检查carry里面还有没有数，如果有的话，加进去\n        if(carry!=0){\n            res.addFirst(carry);\n        }\n\n        return res;        \n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(n)$\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992613526","body":"# [821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n\n\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n```java\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n```\n\n示例 2：\n\n```java\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n```\n\n提示：\n1 <= s.length <= 10<sup>4</sup>\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n\n\n\n\n\n## 方法一：先假定这个c的坐标存在，然后从左从右遍历两次\n\n```java\n//方法一：先假定这个c的坐标存在，然后遍历两次\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        //创建结果数组\n        int[] res = new int[s.length()];\n        //首先从左往右遍历，我们假定c最开始的下标是Integer.MIN_VALUE / 2\n        //除以2是为了防止负溢出\n        //它代表的含义是从左边算起的，离当前结点左边的最近的c的位置\n        int leftClosestPos = Integer.MIN_VALUE / 2;\n        for(int i = 0; i < s.length(); i++){\n            //如果找到了c，修改pos值\n            if(s.charAt(i) == c){\n                leftClosestPos = i;\n            }\n            res[i] = i - leftClosestPos;\n        }\n        //然后再从右边开始遍历\n        //它代表的含义是从右边算起的，离当前结点右边的最近的c的位置\n        int rightClosestPos = Integer.MAX_VALUE / 2;\n        for(int i = s.length() - 1; i >= 0; i--){\n            //如果找到了c，修改pos值\n            if(s.charAt(i) == c){\n                rightClosestPos = i;\n            }\n            //这里要和已有的左边的最近值比较，看谁更小\n            res[i] = Math.min(rightClosestPos - i, res[i]);\n        }\n        return res;\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：$O(n)$\n\n空间复杂度：$O(1)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993676570","body":"# [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n\n\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n\n\n## 思路一\n\n内部用双向链表，维护一个count去保存当前的结点个数，头结点是一个虚拟结点。\n\n\n\n```java\nclass CustomStack {\n    //虚拟头结点\n    private Node virtualHead;\n    //最大值\n    private int maxSize;\n    //当前栈内结点数\n    private int count;\n    //top index\n    private Node top;\n\n\n    //初始化栈\n    public CustomStack(int maxSize) {\n        virtualHead = new Node();\n        top = virtualHead;\n        this.maxSize = maxSize;\n        this.count = 0;\n    }\n    \n    public void push(int x) {\n        //if statck is full, do nothing\n        if(count == maxSize){\n            return;\n        }\n        Node node = new Node(x);\n        top.next = node;\n        node.pre = top;\n        top = node;\n        count ++;\n    }\n    \n    public int pop() {\n        if(count == 0){\n            return -1;\n        }\n        Node node = top;\n        top = top.pre;\n        top.next = null;\n        count --;\n        return node.value;\n    }\n    \n    public void increment(int k, int val) {\n        int upLimit = count < k ? count : k;\n        Node head = virtualHead;\n        for(int i = 0; i < upLimit; i++){\n            head = head.next;\n            head.value += val;\n        }\n    }\n\n\n    //内部结点\n    class Node{\n        Node pre;\n        int value;\n        Node next;\n        public Node(){\n\n        }\n        public Node(int value){\n            this.value = value;\n        }\n        public Node(Node pre, int value, Node next){\n            this.pre = pre;\n            this.value = value;\n            this.next = next;\n        }\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994922020","body":"class Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        //乘积积累量\n        int multi = 0;\n        //注意要有两个栈\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            //把当前的res和multi都放进栈，然后置为null，避免对接下来的元素产生影响\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) {\n                    tmp.append(res);\n                }\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linrax":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991897178","body":"# 思路\n\n将数组从低位到高位加到k上,最后反转\n\n# 代码\n\n语言支持:java\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<>();\n        for(int i = num.length-1;i >= 0|| k >0;i--,k/=10){\n            if(i>=0){\n                k+=num[i];\n            }\n            res.add(k%10);\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度  O(max(n,log k)) , n为数组长度\n\n空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993654236","body":"# 思路\r\n\r\n用数组作为底层构建栈\r\n\r\n# 代码\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int count;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        count = 0;    \r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(count < stack.length) stack[count++] = x;     \r\n    }\r\n    \r\n    public int pop() {\r\n        if(count == 0) return -1;\r\n        return  stack[--count];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int temp = Math.min(k,count);\r\n        for (int i = 0; i <temp;i++){\r\n            stack[i] +=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n# 复杂度分析\r\n\r\n时间复杂度 push、pop 为O(1) , increment 为O(N)\r\n\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994924883","body":"# 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n# 复杂度分析\n\n时间复杂度  O(N)\n\n空间复杂度 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"davont":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922745","body":"## code\n```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function (num, k) {\n  /**\n   * 大数相加，先将两个数反转\n   */\n  let numAStr = num.reverse();\n  let numBStr = k.toString().split('').reverse();\n  let temp = 0;\n  let result = [];\n  for (let i = 0; i < Math.max(numAStr.length, numBStr.length); i++) {\n    if (!numAStr[i]) {\n      numAStr[i] = 0;\n    }\n    if (!numBStr[i]) {\n      numBStr[i] = 0;\n    }\n    result[i] = numAStr[i] + +numBStr[i] + temp;\n    if (result[i] > 9) {\n      result[i] -= 10;\n      temp = 1;\n    } else{\n        temp = 0;\n    }\n  }\n  if (temp === 1) {\n    result.push(temp);\n  }\n  return result.reverse();\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992062594","body":"## 思路\n官方题解的思路二：空间换时间，实际上就是暴力，没有什么技术思想，但也是最容易想到的\n\n## code\n\n```js\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    const sArr = s.split('');\n    const keyArr = [];\n    const ans = [];\n    for (let i = 0; i < sArr.length; i++) {\n        const ele = sArr[i];\n        if(ele === c){\n            keyArr.push(i);\n        }\n    }\n    for (let i = 0; i < sArr.length; i++) {\n        const ele = sArr[i];\n        let minLen = sArr.length;\n        for (let j = 0; j < keyArr.length; j++) {\n            const keyEle = keyArr[j];\n            minLen = Math.min(minLen,Math.abs(keyEle - i));\n        }\n        ans.push(minLen);\n    }\n    return ans;\n\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993626180","body":"## 思路\n首先想到直觉法，但其实是有优化空间的。其实本身不难。\n\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\n var CustomStack = function(maxSize) {\n     this.stack = [];\n     this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this.stack.pop() || -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < this.stack.length && i < k; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994926933","body":"## code\n```js\nvar decodeString = function(s) {\n    const numStack = [];\n    const strStack = [];\n    let repeatTimes = '';\n    for (let i = 0; i< s.length; i++) {\n      const char = s[i];\n      if(!Number.isNaN(+char)){\n          repeatTimes += char;\n          continue;\n      }\n      if(repeatTimes){\n        numStack.push(+repeatTimes);\n        repeatTimes = '';\n      }\n      if(char === ']'){\n          let repeatStr = '';\n          while(strStack.length && strStack.slice(-1)[0]!=='['){\n            let a = strStack.slice(-1);\n            repeatStr = strStack.pop() + repeatStr;\n          }\n          strStack.pop();\n          strStack.push(repeatStr.repeat(numStack.slice(-1)));\n          numStack.pop();\n      }else{\n          strStack.push(char);\n      }\n    }\n    return strStack.join('');\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995491747","body":"## 思路\n双栈，感觉写的麻烦了\n\n## code\n```js\n\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    \n    while(this.outStack.length){\n        this.inStack.push(this.outStack.pop());\n    }\n    this.inStack.push(x)\n    \n    \n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.outStack.length){\n        return this.outStack.pop();\n    }else{\n        while(this.inStack.length){\n            this.outStack.push(this.inStack.pop());\n        }\n        return this.outStack.pop();\n    }\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    while(this.inStack.length){\n        this.outStack.push(this.inStack.pop());\n    }\n    return this.outStack[this.outStack.length-1]\n\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"joyce94":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993086458","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self) -> int:\n        if len(self.stack) > 0:\n            top = self.stack[-1]\n            self.stack.pop()\n            return top \n        else:\n            return -1 \n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(len(self.stack)):\n            if i == k:\n                return \n            self.stack[i] += val \n\n```\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995373663","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        top = self.stack1[0]\n        for i in range(1, len(self.stack1)):\n            self.stack2.append(self.stack1[i])\n        self.stack1 = self.stack2\n        self.stack2 = []\n        return top\n\n    def peek(self) -> int:\n        return self.stack1[0]\n\n    def empty(self) -> bool:\n        if len(self.stack1) == 0:\n            return True \n        return False\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"domorecode":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junqu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bruce-young233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eggeggliu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834504","body":"## 代码\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        reverse(num.begin(), num.end());\n        \n        vector<int> num2 = splitToArray(k);\n        \n        num = addTwoArrays(num, num2);\n        \n        reverse(num.begin(), num.end());\n        return num;\n    }\nprivate:\n    vector<int> splitToArray(int k) {\n        if (k < 0 || k > 10000) {\n            cout << \"invalid input\" << endl;\n            return {};\n        }\n        vector<int> res = {};\n        while (k) {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        return res;\n    }\n    \n    vector<int> addTwoArrays(vector<int>num1, vector<int>num2) {\n        int sz1 = num1.size();\n        int sz2 = num2.size();\n        int n = 0;\n        int carry = 0;\n        while (n < sz1 && n < sz2) {\n            int sum = num1[n] + num2[n] + carry;\n            carry = sum / 10;\n            num1[n++] = sum % 10;\n        }\n        while (n < sz1) {\n            int sum = num1[n] + carry;\n            carry = sum / 10;\n            num1[n++] = sum % 10;\n        }\n        while (n < sz2) {\n            int sum = num2[n++] + carry;\n            carry = sum / 10;\n            num1.push_back(sum % 10);\n        }\n        if (carry) {\n            num1.push_back(carry);\n        }\n        return num1;\n    }\n};\n```\n\n## 复杂度\n时间 O(n)\n空间 O(1)","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995352564","body":"```cpp\nclass MyQueue {\nprivate:\n    stack<int> inStack, outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {}\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    int pop() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        int x = outStack.top();\n        outStack.pop();\n        return x;\n    }\n\n    int peek() {\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top();\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"daxiadaxia":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"draculabo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ankidord":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tomtao626":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993647546","body":"## 思路\r\n> + 使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置\r\n## 代码\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.add = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        if self.top != 0:\r\n            self.add[self.top - 1] += self.add[self.top]\r\n        self.add[self.top] = 0\r\n        self.top -= 1\r\n        return ret\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k - 1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n## 复杂度\r\n> + 空间: O(1)\r\n> + 时间: O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923243","body":"## 思路\r\n+ > 栈\r\n## 代码\r\n+ > \r\n```python\r\ndef decodeString(self, s: str) -> str:\r\n        # time O(N)  space O(N)\r\n        stack=[]\r\n        i=0\r\n        while i<len(s):\r\n            if s[i]==\"]\":\r\n                repeated_str=''\r\n                repeated_num=''\r\n                while stack and stack[-1]!='[':\r\n                    repeated_str = stack.pop()+repeated_str  \r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeated_num=stack.pop()+repeated_num\r\n                stack.append(int(repeated_num)*repeated_str)\r\n            else:\r\n                stack.append(s[i])\r\n            i+=1\r\n        return ''.join(stack)\r\n```\r\n## 复杂度\r\n+ > 时间:O(n)\r\n+ > 空间:O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alanwgy":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"potato121":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baijian1990":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"l-mx-wq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"corki418":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lovemyse1f":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kuroky-chen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yachen-guo":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918651","body":"加法问题，重点在于进位的处理。使用carry位储存。\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> tmp = new LinkedList<>();\n        int n = num.length;\n        int i = n - 1, sum = 0, carry = 0;\n        while(i >= 0 || k!=0){\n            int x = i >= 0 ? num[i] : 0;\n            int y = k != 0? k % 10 : 0;\n            sum = x + y + carry;\n            carry = sum / 10;\n            k /= 10;\n            tmp.addFirst(sum % 10);\n            i--;\n        }\n        if(carry!=0) tmp.addFirst(carry);\n        List<Integer> res = new ArrayList<>(tmp);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992204581","body":"方法1：遍历找到左右指针，向中间扩散，时间复杂度O(N)。\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int left = -1;\n        int right = -1;\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) == c){\n                right = i;\n                int distance = 0;\n                if(left != -1){\n                    int start = left;\n                    int end = right;\n                    while(start <= end){\n                        res[start++] = distance;\n                        res[end--] = distance;\n                        distance++;\n                    }\n                } else{\n                    int end = right;\n                    while(end >= 0){\n                        res[end--] = distance++;\n                    }\n                }\n                left = i;\n            }\n        }\n        if(right!=s.length()-1){\n            int start = right;\n            int distance = 0;\n            while(start < s.length()){\n                res[start++] = distance++;\n            }\n        }\n        return res;\n    }\n}\n```\n方法2：仅供参考，时间复杂度较高（O(N^2)）\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        Map<Character,List<Integer>> map = new HashMap<>();\n        char[] charArr = s.toCharArray();\n        for(int i = 0; i < charArr.length; i++){\n            if(map.containsKey(charArr[i])){\n                map.get(charArr[i]).add(i);\n            } else{\n                List<Integer> list = new ArrayList<>();\n                list.add(i);\n                map.put(charArr[i],list);\n            }\n        }\n        int[] res = new int[charArr.length];\n        List<Integer> tmp = map.get(c);\n        for(int i = 0; i < charArr.length; i++){\n            int min = Integer.MAX_VALUE;\n            for(int j = 0; j < tmp.size(); j++){\n                int val = Math.abs(tmp.get(j) - i);\n                min = min < val?min:val;\n            }\n            res[i] = min;\n        }\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993627837","body":"利用数组作为base， 时间复杂度O(N)\n``` java\nclass CustomStack {\n    private int[] data;\n    private int head = -1;\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(head + 1 < data.length){\n            data[++head] = x;\n        }\n    }\n    \n    public int pop() {\n        if(head == -1) return -1;\n        else{\n            int pop = data[head];\n            data[head--]=0;\n            return pop;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int bound = Math.min(k,head+1);\n        for(int i = 0; i < bound; i++){\n            data[i]+=val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994924373","body":"时间复杂度O(N) N为字符串的长度\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                stk.removeLast();\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995608320","body":"题目要点：采用两个栈实现push操作\n```java\nclass MyQueue {\n    private Stack<Integer> a;\n    private Stack<Integer> b;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        a.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    /** Get the front element. */\n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zt4188":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jachinm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gemzq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"harrypangpang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"iamtheusername":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nina1031":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brandylulu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"clarence5":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903023","body":"```js\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    const res = [];\n    const n = num.length;\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\n        if (i >= 0) {\n            k += num[i];\n        }\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n```\n复杂度：数组长度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"musicofwind":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baiqr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"winperrr":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiangydeng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shuchenwuu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"craig-cheng":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crazy-xjm":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pandacure":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shanrufu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"husky-gong":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991805344","body":"# 解题思路\r\n - 遍历整个array，求出array的值\r\n - 将array求出的数字和给的数字相加\r\n - 将数字转化为array\r\n\r\n# 代码\r\n```\r\nprivate static int[] arrayAddInteger (int[] A, int k) {\r\n        int temp = 0;\r\n        int idx = 0;\r\n\r\n        List<Integer> list = new ArrayList<>();\r\n\r\n        while (idx < A.length) {\r\n            temp = temp * 10 + A[idx];\r\n            idx++;\r\n        }\r\n\r\n        System.out.println(temp);\r\n\r\n        int sum = temp + k;\r\n\r\n        System.out.println(sum);\r\n\r\n        while (sum != 0) {\r\n            list.add(sum % 10);\r\n            sum /= 10;\r\n        }\r\n\r\n        // convert to array\r\n        Collections.reverse(list);\r\n\r\n        int[] result = new int[list.size()];\r\n        for (int i = 0; i < list.size() ; i++) {\r\n            result[i] = list.get(i);\r\n        }\r\n\r\n        return result;\r\n    }\r\n```\r\n\r\n# 复杂度\r\n- 时间复杂度：O(n) 需要遍历整个数组\r\n- 空间复杂度：O(n) 返回数组需要开辟N的额外空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991929422","body":"# 解题思路\r\n- 使用两个指针，代表一个window，左边设为left，右边设置为right\r\n- curr代表当前遍历到的S的位置\r\n- 分为三个阶段：\r\n-- 初始化：left未进入S，right为第一个e出现的位置\r\n-- 中间阶段：left和right均为S中的某一个位置\r\n-- 最后阶段：left为S中最后一个e出现的位置，right已发生越界\r\n- 需要注意：\r\n-- 每次curr扫描到一个C，代表其已到达window的右边界，则需要将左边界设置为C当前位置，并且重新设定右边界\r\n-- 更新距离时，需要使用Math.min(Math.abs(curr - left), Math.abs(curr - right))求出最小值gap，设置到结果位置result[curr] = gap\r\n-- 不能设置为Integer.MIN_VALUE 和Intger.MAX_VALUE，因为会发生越界\r\n# 代码\r\n```\r\npublic static int[] minGap(String S, Character C) {\r\n        // set window [left, right] range\r\n        int left = -S.length();\r\n        int right = 0;\r\n\r\n        // initialize right first\r\n        while (right < S.length() && S.charAt(right) != C) {\r\n            right++;\r\n        }\r\n\r\n        // curr -> current position\r\n        int curr = 0;\r\n        int[] distance = new int[S.length()];\r\n\r\n        while (curr < S.length() && right < S.length()) {\r\n            if (S.charAt(curr) == C) {\r\n                distance[curr] = 0;\r\n                // it means curr has reached to the right edge of the window\r\n                // then have to update the left, right for a new window\r\n                left = curr;\r\n                while (left == right || (right < S.length() && S.charAt(right) != C)) {\r\n                    right++;\r\n                    // if right is out of S, then set it as Integer.MAX_VALUE\r\n                    if (right == S.length()) {\r\n                        right = 2 * S.length();\r\n                    }\r\n                }\r\n            } else {\r\n                // between current window\r\n                // update gaps for Characters in this window\r\n                int gap = Math.min(Math.abs(curr - left), Math.abs(right - curr));\r\n                distance[curr] = gap;\r\n            }\r\n            curr++;\r\n        }\r\n\r\n        return distance;\r\n    }\r\n```\r\n# 复杂度\r\n时间复杂度：O(n) 从左到右，只遍历一遍\r\n空间复杂度：O(n) 需要开辟新的空间，存储结果\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992897084","body":"# 思路\r\n1. 使用ArrayList模拟实现\r\n2. 构造函数：初始化ArrayList和maxSize\r\n3. push：如果list.size()<maxSize，才向其中添加数字；否则，返回。\r\n4. pop：判断list中是否有函数，有的话返回，并remove掉当前数字。否则，返回-1\r\n5. increment：【bottom】代表从list的0开始计算的k个元素进行加val\r\n\r\n# 代码\r\n```\r\nclass CustomStack {\r\n    List<Integer> list;\r\n    int maxSize;\r\n\r\n    public CustomStack(int maxSize) {\r\n        list = new ArrayList<>();\r\n        this.maxSize = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (maxSize > list.size()) {\r\n            list.add(x);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (list.size() > 0) {\r\n            int result = list.get(list.size() - 1);\r\n            list.remove(list.size() - 1);\r\n            return result;\r\n        } else {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        // bottom is start from 0\r\n        int cur = 0;\r\n        \r\n        while (cur <= list.size() - 1 && k > 0) {\r\n            int newVal = list.get(cur) + val;\r\n            list.set(cur, newVal);\r\n            cur++;\r\n            k--;\r\n        }\r\n    }\r\n}\r\n```\r\n# 复杂度\r\n时间复杂度：O(n) 因为有increment操作，可能需要遍历所有数\r\n空间复杂度：O(n) 构造了新的数据结构用于存放数字\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994144198","body":"# How:\r\n1. Regard every [] as a **new level** -> use DFS\r\n2. Use an **global** index i to iterate input string\r\n3. In DFS, 4 cases:\r\n-- '[' go to another level and combine returned string\r\n-- ']' break current level and return\r\n-- alphabetic: append to current level string\r\n-- number: get number before '['\r\n\r\n# Code\r\n```\r\nclass Solution {\r\n    int i = 0;\r\n    public String decodeString(String s) {\r\n        StringBuilder sb = new StringBuilder();\r\n        int count = 0;\r\n        String nextLevel = \"\";\r\n        \r\n        while (i < s.length()) {\r\n            char ch = s.charAt(i);\r\n            i++;\r\n            \r\n            if (ch == '[') {\r\n                nextLevel = decodeString(s);\r\n                while (count > 0) {\r\n                    sb.append(nextLevel);\r\n                    count--;\r\n                }\r\n                \r\n            } else if(ch == ']') {\r\n                break;\r\n            } else if (Character.isAlphabetic(ch)) {\r\n                sb.append(ch);\r\n            } else {\r\n                count = count * 10 + ch - '0';\r\n            }\r\n        }\r\n        \r\n        return sb.toString();\r\n        \r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime Complexity: O(n) loop char in the string only once\r\nSpace Complexity: O(n) recursion\r\n# Note:\r\n1. Should pay attention to input, what is **valid input**\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995185363","body":"# Note\r\n1. When push a new element (we need to add it to the bottom of S1 stack)\r\n-- make S1 result stake reverse -> push to S2 stack\r\n-- add new element to S2 top\r\n-- push back to S1 -> make the new element to the bottom of previous elements\r\n\r\n# Code\r\n``` java\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        // use s1 to record final result\r\n        if (s1.isEmpty()) {\r\n            s1.push(x);\r\n        } else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n            \r\n            s2.push(x);\r\n            \r\n            while (!s2.isEmpty()) {\r\n                s1.push(s2.pop());\r\n            }\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        return s1.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        return s1.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty();\r\n    }\r\n}\r\n\r\n```\r\n\r\n# Complexity\r\nTime Complexity: \r\npush: O(n)\r\npop: O(1)\r\npeek: O(1)\r\nempty: O(1)\r\n\r\nSpace Complexity:\r\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mayqiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"leonalhq":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiabin123":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zacherycao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991742873","body":"## Idea\n1. Use a carry variable to record previous sum's tenth value\nWhile loop (if num is not empty or k larger than zero or carry larger than zero): \n2. Pop num array's last element as variable LAST. If empty num, LAST = 0\n3. Append the ones digit of the summation to the ans array left side\n4. Update the carry to the summation's tens digit\n\n## Code:\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        carry = 0\n        ans = collections.deque()\n        while num or k>0 or carry > 0:\n            last = num.pop() if num else 0\n            cur = (carry + last + k%10)%10\n            carry = (carry + last + k%10)//10\n            k = k//10\n            ans.appendleft(cur)\n        return ans\n```\n\n## Complexity:\nTime: O(max(N, log_10(K)). N is the length of num array. Since we divide K by 10 every loop till K is zero, the complexity of this operation will be log base 10 of K.\nSapce: O(1). The space for carry, last is O(1). The space for the ans is O(max(N, log_10(K)).","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991976277","body":"## Idea\nArray to record position of the C. \n\n## Code\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = []\n        for i in range(len(s)):\n            if s[i] == c:\n                pos.append(i)\n        \n        ans = []\n        p1, p2 = math.inf, math.inf\n        if len(pos) == 1:\n            p1 = 0\n        else:\n            p1 = 0\n            p2 = 1\n        for i in range(len(s)):\n            if p2 != math.inf and i > pos[p2] and p2<len(pos)-1:\n                p1 += 1\n                p2 += 1\n            if i <= pos[p1] or  p2 == math.inf:\n                ans.append(abs(pos[p1] - i))\n            else:\n                ans.append(min(abs(i - pos[p1]),abs(pos[p2] - i) ))\n        return ans\n```\n\n## Complexity:\nTime: O(N)\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993041736","body":"## Idea\nArray\n\n## Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.capacity = maxSize\n        self.cache = []\n\n    def push(self, x: int) -> None:\n        if len(self.cache) < self.capacity:\n            self.cache.append(x)\n\n    def pop(self) -> int:\n        if not self.cache:\n            return -1\n        return self.cache.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        if len(self.cache) <= k:\n            for i in range(len(self.cache)):\n                self.cache[i] += val\n        else:\n            for i in range(k):\n                self.cache[i] += val\n\n\n# Your CustomStack object will be instantiated and called as such:\n# obj = CustomStack(maxSize)\n# obj.push(x)\n# param_2 = obj.pop()\n# obj.increment(k,val)\n```\n\n## Complexity:\nTine: Push: O(1). Pop: O(1). Increment: O(min(K, N))\nSpace: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994191258","body":"## Idea\nStack\n\n## Code:\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack =[]\n        num = \"\"\n        string = \"\"\n        for i in s:\n            if i.isdigit():\n                if string:\n                    stack.append(string)\n                    string = \"\"\n                num += i\n                \n            elif i.isalpha():\n                if num:\n                    stack.append(int(num))\n                    num == \"\"\n                string += i\n            else:\n                if i == \"[\":\n                    if num:\n                        stack.append(int(num))\n                        num = \"\"\n                else:\n                    tmp = string\n                    string = \"\"\n                    while type(stack[-1])!=int:\n                        tmp = stack.pop()+tmp\n                    stack.append(stack.pop()*tmp)\n        ans = string\n        while stack:\n            if type(stack[-1]) != int:\n                ans = stack.pop() + ans\n            else:\n                ans *= stack.pop()\n        return ans\n```\n## Complexity:\nTime: O(maxK^countK * N). N is the max length of encoded string. count K is the amount of numbers. maxK is the largest number\nSpace: O(sum(maxK^countK *N))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995302413","body":"## Idea\nStack\n## Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        self.stack.append(x)\n\n    def pop(self) -> int:\n        tmp = self.stack[0]\n        self.stack = self.stack[1:]\n        return tmp\n\n    def peek(self) -> int:\n        return self.stack[0]\n\n    def empty(self) -> bool:\n        return len(self.stack) == 0\n```\n\n## Complexity:\nTime: push, peak, empty: O(1) pop: O(n)\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zliu1413":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ts4331":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xueniuniu98":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"louxibai":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kelh93":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"qin-pan":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xulli1996":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"beckyyu96":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"renxumei":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liangsen-zju":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hellowxwworld":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"asaoba":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiahui-z":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"falsity":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"crystallatte":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhuzuojun":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"atree716":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoguanggit":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"abouty":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zippend":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tjuaachen":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"goddessiu":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangyingxuhalo":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lemon-hoyoung":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"huzizailushang":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"25829365639":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liang233":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"neal0408":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991914566","body":"### 思路\r\n倒着 按位相加，大于 10进位。但是写的有点乱七八糟。\r\n\r\n### 代码\r\n```Python3\r\nclass Solution:\r\n\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        A = num[::-1]\r\n        B = []\r\n        # 将 k 变数组。\r\n        while k:\r\n            B.append(k % 10)\r\n            k = (k - k % 10) // 10\r\n\r\n        # A比 B 短的时候。\r\n        if len(A) < len(B):\r\n            A, B = B, A\r\n\r\n        # 把 B加到 A 中。\r\n        for i in range(len(B)):\r\n            A[i] = A[i] + B[i]\r\n\r\n        # A 中超过 10 的做进位，超过 A 长度的做列表添加。\r\n        for i in range(len(A)):\r\n            if A[i] >= 10:\r\n                if i < len(A) - 1:\r\n                    A[i + 1] = A[i + 1] + A[i] // 10\r\n                    A[i] = A[i] % 10\r\n                else:\r\n                    A.append(A[i] // 10)\r\n                    A[i] = A[i] % 10\r\n\r\n        return A[::-1]\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992553389","body":"```Python3\nclass Solution:\n\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(s):\n            if x == c:\n                prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994833206","body":"### 思路\n这道题不太会， 应该是要先找到匹配的括号然后在做运算。。但是自己写不对。。。\n### 代码\n```Python3\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:\n                res += c\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995480197","body":"### 思路\n今天这个简单一点，终于是会写了。  一个顺序栈一个逆序栈来弥补没办法直接弹出队首的缺点。\n\n### 代码\n```python3\nclass MyQueue:\n    \n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n    \n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n        \n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        return self.stack2[-1] if self.stack2 else self.stack1[0]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n### 复杂度分析\n时间复杂度：push、peek O(1)。pop() O(1) 最坏 O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"taylucky":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jocelinlx":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"vuesch":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992583311","body":"## 参考题解的中心扩展法\n## js代码\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function (S, C) {\n// 定义最终返回结果\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    // 如果当前是目标字符，就什么都不用做\n    if (S[i] === C) continue;\n\n    // 定义两个指针 l, r 分别向左、右两个方向寻找目标字符 C，取最短距离\n    let l = i,\n      r = i,\n      shortest = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        shortest = Math.min(shortest, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        shortest = Math.min(shortest, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = shortest;\n  }\n  return res;\n};\n```\n### 复杂度分析\n- 时间复杂度：O(n^2)\n\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993664212","body":"## 思路\n没思路，作为并不是科班出身的本人来说，对前置知识**栈**和**前缀和**都不知道，先看题解了\n## 代码\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.max = maxSize;\n  this.stack = [];\n};\n\n/**\n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.stack.length < this.max) {\n    this.stack.push(x);\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  var res = this.stack.pop();\n  return res == null ? -1 : res;\n};\n\n/**\n * @param {number} k\n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  for (var i = 0; i < this.stack.length; i++) {\n    if (i < k) {\n      this.stack[i] += val;\n    }\n  }\n};\n```\n## 复杂度分析\n- 时间复杂度：push 和 pop 操作的时间复杂度为 O(1)O(1)，increment 操作的时间复杂度为 O(min(k, cnt))O(min(k,cnt))\n\n- 空间复杂度：O(1)O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994859042","body":"## 代码\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let len = s.length; stack = []\n  for(let i = 0; i < len; i++){\n    if(s[i] !== ']'){\n      stack.push(s[i])\n    } else {\n      let c = stack.pop()\n      let str = \"\"\n      while(c !== '['){\n        str = c + str \n        c = stack.pop()\n      }\n      let last = stack[stack.length - 1]\n      if(!Number.isNaN(parseInt(last))) {\n        stack.pop()\n        while(!Number.isNaN(parseInt(stack[stack.length - 1]))){\n          last = stack.pop() + last\n        }\n        let result = \"\"\n        for(let j = 0; j < last; j++){\n          result += str\n        }\n        stack.push(result)\n      } else {\n        stack.push(str)\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```\n## 复杂度分析\n- 时间复杂度 O(N)\n- 空间复杂度O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yulecc":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jax-van":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995900885","body":"## 思路\n使用两个栈实现队列，一个输入，一个输出，输入输出时倒腾一下，比如输出时将输入栈所有元素都添加到输出栈，最低层元素，即最先进栈元素就暴露在输出栈栈顶\n## 代码\n```java\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<>();\n    Stack<Integer> popStack = new Stack<>();\n\n    public MyQueue() {\n    }\n    \n    public void push(int x) {\n        while (!popStack.empty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        while (!pushStack.empty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        while (!pushStack.empty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n## 复杂度\n- 时间：O(n)\n- 空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wenjialu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995114076","body":"\r\n# thought\r\n  每次在push的时候，就是push在底部。 push之前把stack1先倒腾到stack2，Stack2.append().再倒回去\r\n 那pop \r\n stack1 321 --》 stack2 123 + 4 ---〉 stack1 4321 # push\r\n stack1 4321 pop1 # pop\r\n\r\n\r\n# code\r\nclass MyQueue:\r\n      def __init__(self):\r\n        self.stack1 = []\r\n        self.stack2 = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n        self.stack2.append(x)\r\n        while self.stack2:\r\n            self.stack1.append(self.stack2.pop())\r\n\r\n\r\n\r\n    def pop(self) -> int:       \r\n        return self.stack1.pop()\r\n\r\n\r\n    def peek(self) -> int:\r\n        return self.stack1[-1]\r\n\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return False if self.stack1 else True\r\n\r\n\r\n# completity\r\ntime & space O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yohannjin":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993528830","body":"思路：既然堆不能直接操作数据，那么就考虑使用向量进行管理。\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        //memo.reserve(maxSize);\n        max = maxSize;\n    }\n    \n    void push(int x) {\n        if(memo.size()< max)\n        {\n            memo.emplace_back(x);\n        }\n    }\n    \n    int pop() {\n        if(memo.empty())\n        {\n            return -1;\n        }\n        else\n        {\n            int tmp = memo.back();\n            memo.pop_back();\n            return tmp;\n        }\n    }\n    \n    void increment(int k, int val) {\n\n        int tmp = k;\n        if(memo.size() < k)\n        {\n            tmp = memo.size();\n        }\n        for(int i = 0; i < tmp ; i++)\n        {\n            memo[i] += val;\n        }\n    }\nprivate:\n    int max = 0;\n    vector<int> memo;\n\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993956550","body":"思路： 使用两个stack, 一个放数字，一个放字符，需要注意的是多位数字需要转换\n\n```cpp\nstring decodeString(string s) {\n        stack<int> num;\n        stack<char> letter;\n        int i = 0;\n        while(i < s.length())\n        {\n            if( isdigit(s[i]) ) //convert number and push to number stack\n            {\n                string tmp_num;\n\n                while(isdigit(s[i]))\n                {\n                    tmp_num.push_back(s[i]);\n                    i++;\n                }\n                int number{0};\n                int carry = 1;\n                while(!tmp_num.empty())\n                {\n                    number += carry * (tmp_num.back() - '0');\n                    tmp_num.pop_back();\n                    carry*=10;\n                }\n                num.push(number);\n                i--;\n            }\n            else if(s[i] == ']') //calculation unit reached\n            {\n               int times = num.top();\n               num.pop();\n               string str{};\n\n               while(true)\n               {\n                   char top = letter.top();\n                   letter.pop();\n\n                   if(top == '[')\n                   {\n                       break;\n                   }\n                   else \n                   {\n                       str.push_back(top);\n                   }\n               }\n            \n               reverse(str.begin(), str.end());\n               for(int j = 0; j< times; j++)\n               {\n                   for(auto k: str)\n                   {\n                       letter.push(k);\n                   }\n               }\n            }\n            else\n            {\n                letter.push(s[i]);\n            }\n            i++;\n        }\n\n        s.clear();\n        while(!letter.empty())\n        {\n            s.push_back(letter.top());\n            letter.pop();\n        }\n        reverse(s.begin(), s.end());\n        return s;            \n    }\n```\n\ntime: O(n), space: O(n) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995566639","body":"思路： 两个stack, 互相倒腾\n\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() \n    {\n        memo1 = {};\n        memo2 = {};\n    }\n    \n    void push(int x) \n    {\n        memo1.push(x);\n    }\n    \n    int pop() \n    {\n        if(memo1.empty())\n        {\n            return -1;\n        }\n\n        while(!memo1.empty())\n        {\n            memo2.push(memo1.top());\n            memo1.pop();\n        }\n\n        int ans = memo2.top();\n        memo2.pop();\n\n        while(!memo2.empty())\n        {\n            memo1.push(memo2.top());\n            memo2.pop();\n        }\n\n        return ans;\n    }\n    \n    int peek() \n    {\n        while(!memo1.empty())\n        {\n            memo2.push(memo1.top());\n            memo1.pop();\n        }\n\n        int tmp = memo2.top();\n\n        while(!memo2.empty())\n        {\n            memo1.push(memo2.top());\n            memo2.pop();\n        }\n        return tmp;\n    }   \n    \n    bool empty() \n    {\n        if(memo1.empty())\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n\nprivate:\n    stack<int> memo1;\n    stack<int> memo2;\n\n    \n    \n};\n```\ntime = O(n);\nspace = O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codewithiris":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991714436","body":"### 思路\n\n\n模拟,将num和k从个位起逐位相加，最终然后反转vector即可。\n例如:  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;num = [1, 2, 3, 4]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = 12  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4, 2]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [6, 4, 2, 1]  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-->ans = [1, 2, 4, 6] \n\n\n### 代码\n\n\n``` C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int n = num.size() - 1;\n        int flag = 0;\n        while(n >= 0 || k != 0){\n            int a = n < 0 ? 0 : num[n];\n            int b = k != 0 ? (k % 10) : 0;\n            int tmp = a + b + flag;\n            ans.push_back(tmp % 10);\n            flag = tmp / 10;\n            --n; k/=10;\n        }\n        if(flag != 0){\n            ans.push_back(flag);\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度: O(max(n,len(k)),其中n是num的长度, len(k)是k的长度\n- 空间复杂度：O(n), n是ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991940147","body":"### 思路\n\n\n&nbsp;&nbsp;初始化ans均为1.  \n&nbsp;&nbsp;第一次遍历字符串s，将ans中对应字符c的位置设置为0.    \n&nbsp;&nbsp;第二次遍历字符串s，遇到非字符c的便从左侧或者右侧寻找字符c，取最小值填入ans中.    \n\n\n### 代码\n\n\n``` C++\n\nclass Solution {\npublic:\n    void findC(string& s, int i, char c, vector<int>& ans){\n        int left = i - 1, right = i + 1, n = s.size();\n        while(left >= 0 || right < n){\n            if(left >= 0 && right < n){\n                if(s[left] == c || s[right] == c){\n                    ans[i] = right - i;\n                    return ;\n                }\n            }else if(left >= 0 && s[left] == c){\n                ans[i] = i - left;\n                return ;\n            }else if(right < n && s[right] == c){\n                ans[i] = right - i;\n                return ;\n            }\n            --left;\n            ++right;\n        }\n    }\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> ans(n, 1);\n        for(int i = 0; i < n; ++i){\n            if(s[i] == c) ans[i] = 0;\n        }\n        for(int i = 0; i < n; ++i){\n            if(s[i] != c) findC(s, i, c, ans);\n        }\n        return ans;\n    }\n};\n\n```\n\n**复杂度分析**\n- 时间复杂度: O(n)\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992857589","body":"### Note\n\n\n&nbsp;&nbsp;Use vector to store the data.\n&nbsp;&nbsp;Record the curIndex and execute the push, pop and increment operation through the curIndex.\n\n\n### Solution\n\n\n``` C++\n\nclass CustomStack {\npublic:\n    vector<int> stk;\n    int top, size;\n    CustomStack(int maxSize) {\n        stk.resize(maxSize);\n        size = maxSize;\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top != size -1){\n            ++top;\n            stk[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        --top;\n        return stk[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0; i < min(top + 1, k); ++i){\n            stk[i] += val;\n        }\n    }\n};\n\n```\n\n**Complexity**\n- T: O(1) for push and pop operation, O(k) for increment operation\n- S: O(n): n is the 'maxSize'","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993807919","body":"### Note\n\n\n* Use a stack to store the number and another stack to store the string.  \n* When faced with the char, add it into the temporary string. \n* When faced with the '[', push the temporary string into the string stack. \n* When faced with the ']', pop the top number of the number stack and repeat the content of the temporary string. \n* Finally, add the top element of the string stack to the temporary string.\n\n\n### Solution\n\n\n``` C++\n\nclass Solution {\npublic:\n    string decodeString(string s) {\n        int n = s.size();\n        stack<int> digit_stk;\n        stack<string> str_stk;\n        string str = \"\";\n        for(int i = 0; i < n; ++i){\n            if(isdigit(s[i])){\n                int a = s[i] - '0';\n                while(isdigit(s[++i])){\n                    a = a * 10 + s[i] - '0';\n                }\n                digit_stk.push(a);\n                --i;\n            }else if(s[i] == '['){\n                str_stk.push(str);\n                str = \"\";\n            }else if(s[i] == ']'){\n                string tmp;\n                for(int j = 0; j < digit_stk.top(); ++j){\n                    tmp += str;\n                }\n                str = tmp;\n                digit_stk.pop();\n                str = str_stk.top() + str;\n                str_stk.pop();\n            }else{\n                str += s[i];\n            }\n\n        }\n        return str;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n): iterate over the string s once.\n- S: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994999406","body":"### Note\n\n\n* Use two stacks to store the integer. Out_stack is to store the elements like the queue while the in_stack helps to push elements into the out_stack.  \n* Push: When faced with the push operation, push all the elements of the out_stack into the in_stack and after that, push the new element in. Then, push all the elements of the in_stack into the out_tack.  \n* Peek: Return the top element of the out_stack because the out_stack's distribution is already the same as the queue.  \n* Pop: Pop out the top element and return that integer.  \n* Empty: If the out_stack is empty, return 'true'.  \n\n\n### Solution\n\n\n``` C++\n\nclass MyQueue {\npublic:\n    stack<int> in_queue;\n    stack<int> out_queue;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        while(!out_queue.empty()){\n            in_queue.push(out_queue.top());\n            out_queue.pop();\n        }\n        in_queue.push(x);\n        while(!in_queue.empty()){\n            out_queue.push(in_queue.top());\n            in_queue.pop();\n        }\n    }\n    \n    int pop() {\n        int tmp = out_queue.top();\n        out_queue.pop();\n        return tmp;\n    }\n    \n    int peek() {\n        return out_queue.top();\n    }\n    \n    bool empty() {\n        if(out_queue.empty()) return true;\n        return false;\n    }\n};\n\n```\n\n**Complexity**\n- T: O(n)\n- S: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zwx0641":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991715965","body":"思路：\r\n从后往前遍历数组，k+num[i]的模就为结果数组的前一位，k /= 10\r\n存在遍历结束k还大于0的情况，用k/=10处理\r\n``` java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> ans = new ArrayList<>();\r\n        int i = num.length - 1;\r\n        while (i >= 0 || k > 0) {\r\n            if (i >= 0) {\r\n                k = num[i] + k;\r\n            }\r\n            ans.add(0, k % 10);\r\n            k/= 10;\r\n            i--;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n时间O(n) 空间O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991928973","body":"思路：\n从前往后从后往前两次遍历\ntmp记录c出现的位置\n第一次遍历ans[i]存放s中i位置字符与前一个c的距离\n第二次遍历比较min(ans[i], s中i位置字符与后一个c的距离)\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        //Arrays.fill(ans, s.length() + 1);\n        int i = 0, j = s.length() - 1, tmp = -1;\n        while (i < s.length()) {\n            if (s.charAt(i) == c) {\n                ans[i] = 0;\n                tmp = i;\n            } \n            if (tmp != -1) {\n                ans[i] = i - tmp;\n            } else {\n                ans[i] = s.length() + 1;\n            }\n            \n            i++;\n        }\n        tmp = -1;\n        while (j >= 0) {\n            if (s.charAt(j) == c) {\n                ans[j] = 0;\n                tmp = j;\n            }\n            if (tmp != -1) ans[j] = Math.min(ans[j], tmp - j);\n            \n            j--;\n        }\n        \n        return ans;\n    }\n}\n```\n时间：O(n)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992640911","body":"思路：\n使用数组来存放作为CusStack，cur表示当前需要填的数组位置  \npush就转化为放入cur位置，pop就为获取cur-1位置的值  \ninc就为数组前k个数加上val  \n``` java\nclass CustomStack {\n    int[] stack;\n    int cur = 0;\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (cur >= stack.length) {\n            return;\n        }\n        stack[cur] = x;\n        cur++;\n    }\n    \n    public int pop() {\n        if (cur == 0) {\n            return -1;\n        }\n        cur--;\n        return stack[cur];\n    }\n    \n    public void increment(int k, int val) {\n        for (int i = 0; i < k && i < cur; i++) {\n            stack[i] += val;\n        }\n    }\n}\n```\n时间：O(k) \n空间：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993881189","body":"\n``` java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stack1 = new Stack<>();\n        Stack<String> stack2 = new Stack<>();\n        String ans = new String();\n        int num = 0;\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '[') {\n                stack1.push(num);\n                stack2.push(ans);\n                num = 0;\n                ans = \"\";\n            } else if (ch == ']') {\n                int j = stack1.pop();\n                String str = stack2.pop();\n                for (int k = 0; k < j; k++) {\n                    str += ans;\n                }\n                ans = str;\n            } else if (ch >= '0' && ch <= '9') {\n                num = num * 10 + (ch - '0');\n            } else {\n                ans += ch;\n            }\n        }\n        return ans;\n    }\n}\n```\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995195865","body":"思路：\n一个栈用来入列，一个用来出列\n``` java\nclass MyQueue {\n    Stack<Integer> s1;\n    Stack<Integer> s2;\n    public MyQueue() {\n        s1 = new Stack<>();\n        s2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if (!s2.isEmpty()) {\n            return s2.pop();\n        } else {\n            while(!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if (!s2.isEmpty()) {\n            return s2.peek();\n        } else {\n            while(!s1.isEmpty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.peek();\n    }\n    \n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n```\n时间: push O(1) pop,peek O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wxj783428795":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991716414","body":"### 思路\r\n\r\n将K的每位与A的每位相加，如果大于10，则下一次相加要进位。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number[]} num\r\n * @param {number} k\r\n * @return {number[]}\r\n */\r\nvar addToArrayForm = function (num, k) {\r\n\r\n    let answer = []; \r\n    let carry = 0; // 进位\r\n    for (let i = 1; i <= num.length || k >= 1; i++) {\r\n        let num1 = num.length - i >= 0 ? num[num.length - i] : 0;\r\n        let num2 = k % 10;\r\n        let sum = num1 + num2 + carry; //每位的和记得加上上一位的进位\r\n        if (sum >= 10) { \r\n            answer.unshift(sum % 10);\r\n            carry = Math.floor(sum / 10)\r\n        } else {\r\n            answer.unshift(sum)\r\n            carry = 0\r\n        }\r\n        k = Math.floor(k / 10)\r\n    }\r\n    if (carry !== 0) { // 出循环后，如果最后进位不为0，则将进位添加到数组首位\r\n        answer.unshift(carry)\r\n    }\r\n    return answer;\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(N)，其中 N 为 num 和 k 中较长的长度。\r\n- 空间复杂度：O(N)，其中 N 为 answer 的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991931122","body":"### 思路\r\n\r\n第一次循环：找到s中所有c的下标。\r\n第二次循环：循环对比s中每个字符，到所有c的下标的距离，取其中的最小值放入answer中\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\n\r\nvar shortestToChar = function (s, c) {\r\n    let indexs = []; // 存储所有c在s中的下标\r\n    let answer = []; // 存储结果\r\n    for (let i = 0; i < s.length; i++) { // 第一遍循环先找到所有c在s中的下标\r\n        if (c === s[i]) {\r\n            indexs.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < s.length; i++) { // 第二遍循环\r\n        let distance = 0;\r\n        if (c === s[i]) { // 如果当前位等于c，则将0放入answer\r\n            answer.push(distance)\r\n        } else {\r\n            distance = Math.abs(i - indexs[0]);\r\n            for (let j = 1; j < indexs.length; j++) {// 循环判断当前位和每一个c的距离，取最小值\r\n                distance = Math.min(distance, Math.abs(i - indexs[j]));\r\n            }\r\n            answer.push(distance)\r\n        }\r\n    }\r\n    return answer;\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：O(NM)，其中 N 为s的长度，M为s中c出现的次数。\r\n- 空间复杂度：O(N+M)，其中 N 为s的长度，M为s中c出现的次数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992645250","body":"### 思路\r\njs用数组模拟栈，可以直接用数组的push和pop方法表示栈的入栈和出栈\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function (maxSize) {\r\n    this.values = [];\r\n    this.size = 0;\r\n    this.maxSize = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n    if (this.size < this.maxSize) {\r\n        this.values.push(x);\r\n        this.size += 1;\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n    if (this.size) {\r\n        this.size -= 1;\r\n        return this.values.pop();\r\n    }\r\n    return -1;\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n    let range = k < this.size ? k : this.size\r\n    for (i = 0; i < range; i++) {\r\n        this.values[i] += val;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n  - push ：O(1)，数组在末位添加元素，复杂度为O(1)。\r\n  - pop：O(1)，数组从末尾删除元素，复杂度为O(1)。\r\n  - increment：O(min(k,N))，其中N为数组长度，k为需要操作的元素数量。\r\n- 空间复杂度：O(N)，其中N为maxSize。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993865862","body":"### 思路\r\n\r\n1. 循环遍历字符串，将字符从头开始压栈，如果遇到']'，则开始出栈，直到'['。将括号之间的字符串标记为需要重复的字符串。\r\n2. 继续出栈，直到字符不为数字为止，这期间出栈的数字记为需要重复的次数。\r\n3. 循环创建重复字符串，并压入栈中\r\n4. 进入下一轮循环。\r\n\r\n### 代码\r\n```javascript\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function (s) {\r\n    let stack = [];\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === ']') {\r\n            let str = ''\r\n            let count = ''\r\n            while (stack.length && stack[stack.length - 1] != '[') {\r\n                str = stack.pop() + str;\r\n            }\r\n            stack.pop();\r\n            while (stack.length && Number.isInteger(+stack[stack.length - 1])) {\r\n                count = stack.pop() + count;\r\n            }\r\n            for (let j = 0; j < +count; j++) {\r\n                stack.push(str)\r\n            }\r\n        } else {\r\n            stack.push(s[i])\r\n        }\r\n    }\r\n    return stack.join('')\r\n};\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n- 空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994972024","body":"### 思路\r\n\r\n1.使用两个栈，一个为输入栈，一个为输出栈。\r\n2.数据入队列时，把数据压入输入栈。\r\n3.数据出队列时，如果输出栈为空，则依次弹出输入栈的所有元素，并压入输出站。然后弹出输出栈的第一个元素。\r\n4.peek方法就是返回输入栈的第一个元素，或输出站的最后一个元素。\r\n5.empty方法就是判断两个栈是否都为空。\r\n\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function () {\r\n    this.inStack = [];\r\n    this.outStack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nMyQueue.prototype.push = function (x) {\r\n    this.inStack.push(x)\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.pop = function () {\r\n    if (this.outStack.length === 0) {\r\n        while (this.inStack.length > 0) {\r\n            this.outStack.push(this.inStack.pop())\r\n        }\r\n    }\r\n    return this.outStack.pop()\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nMyQueue.prototype.peek = function () {\r\n    return this.inStack[0] || this.outStack[this.outStack.length - 1];\r\n};\r\n\r\n/**\r\n * @return {boolean}\r\n */\r\nMyQueue.prototype.empty = function () {\r\n    return this.inStack.length === 0 && this.outStack.length === 0;\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * var obj = new MyQueue()\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * var param_3 = obj.peek()\r\n * var param_4 = obj.empty()\r\n */\r\n```\r\n### 复杂度分析\r\n**复杂度分析不是很会，不一定对，如果有错，请指正。**\r\n- 时间复杂度：\r\n  - push() : O(1)\r\n  - peek() : O(1)\r\n  - empty() : O(1)\r\n  - pop() : O(1)\r\n- 空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"baddate":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991718618","body":"### 题目\n\n[https://leetcode-cn.com/problems/add-to-array-form-of-integer/](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n### 思路\n\n基本的加减法思路，从最低位开始，逐位相加，大于10就进1位（直接在原数k上操作），把结果存到一个新的数组res中，\n如果最后k仍然大于0，说明最终结果位数大于两个加数，这时候再将k值加到结果数组res中，\n最后再翻转该数组即可得到最终结果。\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        int n = num.size();\n        for(int i = n-1;i >= 0;i--)\n        {\n            int temp = num[i] + k % 10;\n            k /= 10;\n            if(temp >= 10)\n            {\n                k++;\n                temp -= 10;\n            }\n            res.push_back(temp);\n        }\n        while(k > 0)\n        {\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)，其中 N 为max(num数组长度，k的位数）。\n- 空间复杂度：O(N)，其中 N 为res数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992549533","body":"### **思路**\r\n\r\n两次遍历（正向&反向），取最小值\r\n\r\n### **代码**\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        vector<int> res(s.length(),0);\r\n        int temp = INT_MIN/2;\r\n        for (int i=0;i<s.length();i++)\r\n        {\r\n            if(s[i]==c)\r\n            {\r\n                temp=i;\r\n            }\r\n            res[i]=i-temp;\r\n        }\r\n        temp = INT_MAX/2;\r\n        for (int i=s.length()-1;i>=0;i--)\r\n        {\r\n            if(s[i]==c)\r\n            {\r\n                temp=i;\r\n            }\r\n            res[i]=min(temp-i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 字符串长度，遍历两次。\r\n- 空间复杂度：O(N)，N为res的大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993616865","body":"### 思路\r\n\r\n使用`vector`模拟栈，然后用一个变量`top`记录末尾元素\r\n\r\n`push`操作：直接在对应坐标（`top+1`）赋值\r\n\r\n`pop`操作：返回`vector`末尾值，`top`对应要减1（这里不能直接删除，因为之后可能还有其他操作）\r\n\r\n`inc`操作：直接取`k`和`vector`的size中的较小值，然后对应坐标增加`val`\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top + 1 != stk.size())\r\n        {\r\n            ++top;\r\n            stk[top]=x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if(top == -1)\r\n        {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stk[top+1];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int m = min(top+1, k);\r\n        for(int i=0;i<m;i++)\r\n        {\r\n            stk[i] += val;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：`O(k)+O(1)*3`，主要是根据`inc`操作时的`k`值改变，`pop`、`push`、`构造函数`均为`O(1)`\r\n- 空间复杂度：`O(maxSize)`，`vector`的大小占用空间","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994929145","body":"### 思路\n\n难点在于如果出现嵌套的情况，需要从内向外拼接，所以可以使用一个辅助栈的方法来处理，感觉有点类似于写计算器时的逆波兰表达式\n\n如果是数字，就直接压栈\n\n如果是字母或者左括号，直接压栈\n\n如果是右括号，执行出栈操作，如果左括号出栈，则临时字符串拼接完成，之后根据栈顶数字构造一个新的字符串，然后压栈，知道碰到下一个右括号，如此循环\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n        string res = \"\";\n        stack <int> nums;\n        stack <string> strs;\n        int num = 0;\n        int len = s.size();\n        for(int i = 0; i < len; ++ i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                num = num * 10 + s[i] - '0';\n            }\n            else if((s[i] >= 'a' && s[i] <= 'z') ||(s[i] >= 'A' && s[i] <= 'Z'))\n            {\n                res = res + s[i];\n            }\n            else if(s[i] == '[')\n            {\n                nums.push(num);\n                num = 0;\n                strs.push(res); \n                res = \"\";\n            }\n            else\n            {\n                int times = nums.top();\n                nums.pop();\n                for(int j = 0; j < times; ++ j)\n                    strs.top() += res;\n                res = strs.top();\n                                 \n                strs.pop();\n            }\n        }\n        return res;\n    }\n};\n\n```\n\n**复杂度分析**","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995539514","body":"### 思路\r\n\r\n使用两个栈模拟，一个做主要，一个做临时跳转。\r\n\r\npush：直接stk1入栈\r\n\r\npop：stk1一次入栈stk2，stk2的栈顶即为队列首位，移除之后，再将stk2入栈stk1\r\n\r\npeek：类似pop，去掉移除栈顶元素的操作\r\n\r\nempty：判空stk1即可\r\n\r\n====\r\n\r\n优化：\r\n\r\n每次再将stk2压入stk1有点复杂，所以可以直接用stk2做输出栈，而stk1做输入栈；这样只要stk2栈不空，栈顶元素就一直是队列首个元素；还有一点要注意，这时候要两个栈同时为空队列才是空。\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() {\r\n\r\n    }\r\n    \r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        int ret;\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n        ret = stk2.top();\r\n        stk2.pop();\r\n        while(!stk2.empty())\r\n        {\r\n            stk1.push(stk2.top());\r\n            stk2.pop();\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        int ret;\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n        ret = stk2.top();\r\n        while(!stk2.empty())\r\n        {\r\n            stk1.push(stk2.top());\r\n            stk2.pop();\r\n        }\r\n        return ret;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\n};\r\n\r\n//========优化\r\n\r\nclass MyQueue {\r\npublic:\r\n    stack<int> stk1;\r\n    stack<int> stk2;\r\n    MyQueue() {\r\n\r\n    }\r\n    void helper() {\r\n        while(!stk1.empty())\r\n        {\r\n            stk2.push(stk1.top());\r\n            stk1.pop();\r\n        }\r\n    }\r\n    void push(int x) {\r\n        stk1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(stk2.empty()) {\r\n            helper();\r\n        }\r\n        int ret = stk2.top();\r\n        stk2.pop();\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        if(stk2.empty()) {\r\n            helper();\r\n        }\r\n        int ret = stk2.top();\r\n        return ret;\r\n    }\r\n    \r\n    bool empty() {\r\n        return stk1.empty() && stk2.empty();\r\n    }\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：push/empty操作是O(1)，pop/peek操作平均也是O(1)\r\n- 空间复杂度：O(N)，N为队列元素数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"courtneyz94":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991738847","body":"```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        ans, i = [],len(num) -1\n        while k > 0 or i >= 0:\n            k,rmd = divmod(k + (num[i] if i >= 0 else 0),10)\n            ans.append(rmd)\n            i -= 1\n        return reversed(ans)\n```\n### Time Complexity O(n) , Space O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991977177","body":"```python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = -len(S)\n        ans = []\n        for i in range(len(S)):\n            if S[i] == C: \n                prev = i\n            ans.append(i - prev)\n\n        prev = 2 * len(S)\n        for i in range(len(S) - 1, -1, -1):\n            if S[i] == C: \n                prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n```\ntime complexity: o(n) space complexity: o(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"feifan-bai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991744742","body":"\n### 思路\n1. Add the k to the num array from the last digit\n2. Iterated with each digit to update the num array\n3. Deal with the carry situation(if need carry, num.insert(0, 0))\n\n\n*### 代码*\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        i = len(num)-1\n\n        while k > 0:\n            num[i] += k\n            k, num[i] = num[i] // 10, num[i] % 10\n            i -= 1\n\n            if i < 0 and k!= 0:\n                num.insert(0, 0)\n                i = 0\n        return num\n\n```\n\n- *复杂度分析**\n- 时间复杂度：O(N), N = max(num,len(k)) \n- 空间复杂度：O(N), N = max(len(num), len(k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992022067","body":"### 思路\n\n1. Traverse from left to right, record the last position where c appears,  ans_l = i - prev_l\n2. Traverse from right to left, record the last position where c appears, ans_r = prev_r - i\n3. Final ans = min(ans_l, ans_r)\n\n*### 代码*\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev_l,  prev_r = float('-inf'), float('inf')\n        ans = []\n        \n        for i, char in enumerate(s):\n            if char == c:\n                prev_l = i\n            ans.append(i - prev_l)\n        \n        for i in range(len(s)-1, -1, -1):\n            if s[i] == c:\n                prev_r = i\n            ans[i] = min(ans[i], prev_r - i)\n        \n        return ans\n\n```\n\n- *复杂度分析*\n- 时间复杂度：O(N), N = len(s)\n- 空间复杂度：O(N), N = len(ans)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993145847","body":"### 思路\n1. Using top, add[] array to record the top postion and increasement of stack.\n2. Push, if not reaching the limitation, top += 1, add new element\n3. Pop, if not empty, return original value of top + add[top]\n4. Increment, add[lim] + val\n\n*### 代码*\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.add = [0] * maxSize\n        self.top = -1\n        \n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        res = self.stk[self.top] + self.add[self.top]\n        if self.top != 0:\n            self.add[self.top-1] += self.add[self.top]\n        self.add[self.top] = 0\n        self.top -= 1\n        return res\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k-1, self.top)\n        if lim >= 0:\n            self.add[lim] += val\n```\n\n- *复杂度分析*\n- 时间复杂度：O(1)\n- 空间复杂度：O(N), N = maxSize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994093637","body":"*思路*\n1. Using a stack to store the number times and string to store the chars.\n2. When facing the char, added it to string\n3. When facing the '[', append the c\n4. When facing the ']', find the top number of times the stack and string[1:] * times \n\n*代码*\n\n```\nstack = []\n        res = \"\"\n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                string = ''\n                while not stack[-1].isnumeric():\n                    string = stack.pop() + string\n                times = ''\n                while stack and stack[-1].isnumeric():\n                    times = stack.pop() + times\n                if times:\n                    string = string[1:] * int(times)\n                if stack:\n                    stack.append(string)\n                else:\n                    res += string\n        return res + ''.join(stack)\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995088521","body":"*思路*\n1. Using 2 stacks to finalize the Quene\n2. Stack2 to store the elements reversely from stack 1\n3. Stack1 and front to implement the quene \n\n*代码*\n\n```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        self.front = None\n\n    def push(self, x: int) -> None:\n        # Push element x to the back of queue\n        if not self.stack1:\n            self.front = x\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n            self.front = None\n        return self.stack2.pop()\n\n    def peek(self) -> int:\n        if self.stack2:\n            return self.stack2[-1]\n        return self.front\n\n    def empty(self) -> bool:\n        if not self.stack1 and not self.stack2:\n            return True\n        return False\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n```\n*复杂度分析*\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhangnn2018":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991753962","body":"思路： 把数组num转换成整数，与k相加，再将得到的和转换成对应的数组\n代码：\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        nn=0\n        '''\n        for i in reversed(range(len(num))):\n            nn = nn + 10 ** (len(num) - 1 - i) * num[i]\n        '''\n        for n in num:\n            nn = nn*10+n\n        sum=nn+k\n        strs=str(sum)\n        l=[]\n        for j in range(len(strs)):\n            l.append(int(strs[j]))\n        return l\n复杂度（不是很确定对不对.....）：\n时间复杂度：O(N)，N是num+k的位数\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991943786","body":"#### 思路\r\n先遍历`s`找到所有等于`c`的元素下标，并存在数组`lab`里，  \r\n再次遍历`s`计算所有元素的下标与数组`lab`里元素值的差的绝对值，取最小的一个。\r\n\r\n#### 代码\r\n  ```python\r\n      class Solution(object):\r\n      def shortestToChar(self, s, c):\r\n          \"\"\"\r\n          :type s: str\r\n          :type c: str\r\n          :rtype: List[int]\r\n          \"\"\"\r\n          lab=[]\r\n          for i in range(len(s)):\r\n              if s[i]==c:\r\n                  lab.append(i)\r\n\r\n          res=[0]*len(s)\r\n          for i in range(len(s)):\r\n              lab0 = [abs(j-i) for j in lab]\r\n              res[i]=min(lab0)\r\n          return res\r\n ```\r\n#### 复杂度\r\n时间复杂度：O(NM), N为数组`s`的长度, M为数组`lab`的长度。  \r\n空间复杂度：O(M), M为数组`lab`的长度，最差情况下等于数组`s`的长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992851295","body":"#### 思路\r\n创建列表[]，对列表操作实现相关功能。\r\n\r\n#### 代码\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.maxSize = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if len(self.stack)<self.maxSize:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if len(self.stack)==0:\r\n            return -1\r\n        else:\r\n            return self.stack.pop(-1)\r\n\r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        for i in range(min(k,len(self.stack))):\r\n            self.stack[i]=self.stack[i]+val\r\n\r\n\r\n\r\n# Your CustomStack object will be instantiated and called as such:\r\n# obj = CustomStack(maxSize)\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# obj.increment(k,val)\r\n```\r\n#### 复杂度\r\n* 时间复杂度: O(N), 由increment的遍历带来的；\r\n* 空间复杂度：O(N), 栈的生成占用的空间。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994147853","body":"#### 思路\r\n* `nums`存数字；`res`存字符串(res从空字符串一直变成最终的结果字符串；中间入栈后清零，记录中间字符串)；\r\n* `num`计算多位数字对应的整数\r\n* 遇到`[`就入栈，遇到`]`就出栈。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), N为字符串长度，一层for循环；\r\n* 空间复杂度：O(M), 结果字符串的长度。\r\n\r\n#### 代码\r\n```python\r\nclass Solution(object):\r\n    def decodeString(self, s):\r\n        \"\"\"\r\n        :type s: str\r\n        :rtype: str\r\n        \"\"\"\r\n        stack = []  # 记录左括号之前的字符串\r\n        nums = [] #记录数字\r\n        num = 0\r\n        res = \"\"  # 实时记录当前可以提取出来的字符串\r\n        for i in s:\r\n            if i.isdigit():\r\n                num = num * 10 + int(i)\r\n            elif i == \"[\":\r\n                stack.append(res)\r\n                nums.append(num)\r\n                res, num = \"\", 0\r\n            elif i == \"]\":\r\n                topstr = stack.pop()\r\n                topnum = nums.pop()\r\n                res = topstr + res * topnum\r\n            else:\r\n                res = res + i\r\n        return res\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995269506","body":"#### 思路\r\n* 存的时候直接`append()`就行。\r\n* 删除并返回队首元素的时候，需要从`stack1`倒腾到`stack2`，这样才能使`stack1`栈底（即队首）的元素变成`stack2`的栈顶。\r\n* 返回队首元素的时候，记得把`pop()`出的元素，再`append()`回去，不然就被删了。\r\n\r\n#### 复杂度\r\n* 时间复杂度: O(N), pop函数的for循环；\r\n* 空间复杂度：O(N), 引入了两个栈。\r\n\r\n#### 代码\r\n```python\r\nclass MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n              \r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.stack1.append(x) \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.empty():\r\n            return None\r\n        if self.stack2:\r\n            return self.stack2.pop()\r\n        else:\r\n            for i in range(len(self.stack1)):\r\n                self.stack2.append(self.stack1.pop())\r\n            return self.stack2.pop()\r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        ans = self.pop()\r\n        self.stack2.append(ans)\r\n        return ans\r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return not (self.stack1 or self.stack2)\r\n        \r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"w-curiosity":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991771477","body":"### 思路\ntraverse each digit of the `num` and `k` in reverse order and do add operation\nreverse the list and return\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int carry = 0;\n        int p = num.length - 1;\n        List<Integer> list = new LinkedList<>();\n        while( p >= 0 || k > 0 || carry > 0) {\n            int cur = k % 10 + carry;\n            if(p >= 0) {\n                cur += num[p];\n                p--;\n            }\n            list.add(cur % 10);\n            carry = cur / 10;\n            k = k / 10;\n        }\n        Collections.reverse(list);\n        return list;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- TC = O(max(M,N)), M is the length of num, N is the numbers of digits of k\n- SC = O(1), use constant space","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991983018","body":"### 思路\niterate twice, from left to right, then from right to left, \nalways update the shortest distance\n\n### 代码\n\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\n        int len = s.length();\n        int loc = -20000;   // -2*10^4\n        char[] ch = s.toCharArray();\n\n        int[] ans = new int[len];\n        \n        // from left to right\n        for(int i = 0; i < len; ++i) {\n            if( ch[i]  == c ) {\n                loc = i;\n                ans[i] = 0;\n            } else {\n                ans[i] = i - loc;\n            }\n        }\n        \n        // from right to left\n        for(int i = len - 1; i >= 0; --i) {\n            if( ch[i]  == c ) {\n                loc = i;\n            } else {\n                ans[i] = Math.min(ans[i], Math.abs(loc - i));\n            }\n        }\n        \n        return ans;\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(N)\n- Space Complexitty = O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992699387","body":"### 思路\nusing array to simulate stack\n\n### 代码\n\n\n```java\n\nclass CustomStack {\n\n    private int[] stack;\n    private int pointer;\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.pointer = 0;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if( pointer < maxSize ) {\n            stack[pointer] = x;\n            ++pointer;\n        }\n    }\n    \n    public int pop() {\n        if( pointer > 0 ) {\n            --pointer;\n            return stack[pointer];\n        } else {\n            return -1;\n        }\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(k, pointer);\n        for(int i = 0; i < min; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty\n\t- SC = O(maxSize)\n\t- CustomStack O(1)\n\t- push TC = O(1)\n\t- pop TC = O(1)\n\t- increment TC = O(k)\n- Space Complexitty = O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993881706","body":"### 思路\n+ use stack, build string from inner\n+ iterate the string S\n\t+ if current character is digit, add to num\n\t+ if current character is letter, add to current string\n\t+ if current character is open square brackets, push num and current string into stack\n\t+ if current character is close square brackets, pop and build a new string\n\n\n### 代码\n\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        // stack for number\n        Stack<Integer> numStack = new Stack<>();\n        // stack for string\n        Stack<StringBuilder> stringStack = new Stack<>();\n        int num = 0;\n        for(char c: s.toCharArray()) {\n            if(Character.isDigit(c)) {\n                num = num * 10 + c - '0';\n            } else if(c == '[') {\n                stringStack.add(sb);\n                numStack.add(num);\n                sb = new StringBuilder();\n                num = 0;\n            } else if(Character.isLetter(c)) {\n                sb.append(c);\n            } else {\n                StringBuilder strTemp = stringStack.pop();\n                int numTemp = numStack.pop();\n                for(int i = 0; i < numTemp; i++) {\n                    strTemp.append(sb);\n                }\n                sb = strTemp;\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n**复杂度分析**\n- Time Complexitty = O(S), S the length of the decoded string\n- Space Complexitty = O(S)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995507741","body":"### 思路\n+ Two Stacks\n\n### 代码\n\n\n```java\n\nclass MyQueue {\n\n    private Stack<Integer> s1 = new Stack<Integer>();\n    private Stack<Integer> s2 = new Stack<Integer>();\n    private int front;\n\n    public MyQueue() {\n        this.s1 = s1;\n        this.s2 = s2;\n    }\n    \n    // push element x to the back of queue\n    public void push(int x) {\n        if (s1.empty()) {\n            front = x;\n        }\n        s1.push(x);\n    }\n    \n    public int pop() {\n        if(s2.empty()) {\n            while (!s1.empty()) {\n                s2.push(s1.pop());\n            }\n        }\n        return s2.pop();\n    }\n    \n    public int peek() {\n        if(!s2.empty()) {\n            return s2.peek();\n        }\n        return front;\n    }\n\n    public boolean empty() {\n        return s1.isEmpty() && s2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n**复杂度分析**\n- Time Complexitty \n\t- Push - O(1) per operation\n\t- Pop - 摊还复杂度 O(1) per operation\n\t- peek - O(1) per operation.\n\t- empty - O(1) per operation.\n- Space Complexitty = O(N)\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yrtryannn":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991794054","body":"```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = A.length;\n        for(int i = n - 1;i >= 0;i--){\n            int sum = A[i] + K % 10;       \n            K /= 10;    \n            if(sum >= 10){\n                K++;                       \n                sum -= 10;                  \n            }\n            res.add(sum);\n        }\n        while (K > 0) {\n            res.add(K % 10);\n            K /= 10;\n        }\n        Collections.reverse(res);\n        return res;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992055428","body":"```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == c) {\n                list.add(i);\n            }\n        }\n        if (list.isEmpty()) {\n            return new int[0];\n        }\n        int[] res = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            if (list.contains(i)) {\n                res[i] = 0;\n            } else {\n                res[i] = rearchMinDistance(i, list);\n            }\n        }\n        return res;\n    }\n\n    public int rearchMinDistance(int index, ArrayList<Integer> list) {\n        int minValue = 10000;\n        for (int i = 0; i < list.size(); i++) {\n            minValue = Math.min(minValue, Math.abs(index - list.get(i)));\n        }\n        return minValue;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992989378","body":"```\nclass CustomStack {\n\n    int[] data;\n    int head;\n\n    public CustomStack(int maxSize) {\n\n        data = new int[maxSize];\n        head = -1;\n    }\n    \n    public void push(int x) {\n\n        if (head == data.length - 1)\n            return;\n            \n        data[++head] = x;\n    }\n    \n    public int pop() {\n\n        if (head == -1)\n            return -1;\n\n        return data[head--];\n    }\n    \n    public void increment(int k, int val) {\n\n        for (int i = 0; i < Math.min(k, head + 1); i++)\n            data[i] += val;\n    }\n}\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995218550","body":"```\nclass MyQueue {\n    public Stack<Integer> a;\n    puiblic Stack<Integer> b;\n    \n    public MyQueue() {\n        a = new Stack<>();\n        b = new Stack<>();\n    }\n    \n    public void push(int x) {\n        a.push(x);\n    }\n    \n    public int pop() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.pop();\n    }\n    \n    public int peek() {\n        if(b.isEmpty()){\n            while(!a.isEmpty()){\n                b.push(a.pop());\n            }\n        }\n        return b.peek();\n    }\n    \n    public boolean empty() {\n        return a.isEmpty() && b.isEmpty();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zwmanman":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991814629","body":"### 思路\nCalculate the total sum in the array, each number * 10^idx.\nThen sum up with the k \nOut each digit in the total sum\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n\n        idx = len(num) - 1\n        sum_num = 0\n        res = []\n        for number in num:\n            sum_num = number * (10**idx) + sum_num\n            idx -= 1\n            \n        sum_num += k\n        \n        for digit in (str(sum_num)):\n            res.append(int(digit))\n            \n        return res\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，需要遍历数组。\n- 空间复杂度：O(N)，存储返回的数组\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959149","body":"### 思路\nIterate s and store index of c in a dictionary\nIterate s again and calculate the min diff of c index in dictionary \n\n### 代码\n\n\n```Python\nclass Solution(object):\n    def shortestToChar(self, s, c):\n        \"\"\"\n        :type s: str\n        :type c: str\n        :rtype: List[int]\n        \"\"\"\n        dictC = {}\n        dictC[c] = []\n        res = []\n        \n        for i in range(len(s)):\n            if s[i] == c:\n                dictC[c].append(i)\n        \n        for i in range(len(s)):\n            res.append(min([abs(i - ele) for ele in dictC[c]]))\n            \n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(NM)，其中 N 为数组长度, M为dictionary长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992839893","body":"### 思路\n\nCreate a stack and a global variable to keep the max size\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.stack = []\n        self.maxEle = maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxEle:\n            self.stack.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack) > 0:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(min(len(stack), k))，为增量k和数组长度中的较小值\n- 空间复杂度：O(Maxsize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993933745","body":"### 思路\n\nUse a stack to track element in the string. \n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        \n        \n        for item in s:\n            if item != ']':\n                stack.append(item)\n            else:\n                repeat_str = ''\n                repeat_num = ''\n                while stack and stack[-1] != '[':\n                    repeat_str = stack.pop() + repeat_str\n                    \n                stack.pop()\n                \n                while stack and stack[-1] in ('0123456789'):\n                    repeat_num = stack.pop() + repeat_num\n                \n                stack.append(int(repeat_num) * repeat_str)\n                \n        return \"\".join(stack)\n                \n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995350001","body":"### 思路\n\nUse two stack\n1. push: Everything will be pushed to stack1 first\n2. pop: while stack2 is not empty, pop() from stack2, else move everything to stack2\n3.peek: if stack is not empty, return last element from stack2 else return front\n3. empty: when both stack1 and stack2 are empty then it is empty\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n        self.front = None\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack1) == 0:\n            self.front = x\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stack2) == 0:\n            while len(self.stack1) != 0:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n        \n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack2:\n            return self.stack2[-1]\n        else:\n            return self.front\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N) for pop()，O(1) for other method\n- 空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kmshui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991820454","body":"```\nclass Solution(object):\n    def addToArrayForm(self, num, k):\n        \"\"\"\n        :type num: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        def num_to_lst(n):\n            result = []\n            while n:\n                result.append(n % 10)\n                n = n // 10\n\n            return result[::-1]\n        \n        k_lst = num_to_lst(k)\n        i = len(num) - 1\n        j = len(k_lst) - 1\n        \n        result = []\n        \n        carry = 0\n        while i >= 0 or j >= 0 or carry:\n            left = num[i] if i >= 0 else 0\n            right = k_lst[j] if j >= 0 else 0\n            \n            s = left + right + carry\n            result.append(s % 10)\n            carry = s // 10\n            \n            i -= 1\n            j -= 1\n            \n        return result[::-1]\n```\nTime: O(max(n, m))\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038994","body":"```\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        left = [float('inf') for _ in range(len(s))]\r\n        right = [float('inf') for _ in range(len(s))]\r\n        \r\n        cur_min = float('inf')\r\n        for i in range(len(s)):\r\n            if s[i] == c:\r\n                left[i] = 0\r\n                cur_min = 0\r\n            else:\r\n                cur_min += 1\r\n                left[i] = cur_min\r\n                \r\n        cur_min = float('inf')\r\n        for i in range(len(s)-1, -1, -1):\r\n            if s[i] == c:\r\n                right[i] = 0\r\n                cur_min = 0\r\n            else:\r\n                cur_min += 1\r\n                right[i] = cur_min\r\n                \r\n        result = [min(left[i], right[i]) for i in range(len(s))]\r\n        \r\n        return result\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993139062","body":"```\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        \"\"\"\r\n        :type maxSize: int\r\n        \"\"\"\r\n        self.arr = [float('inf') for _ in range(maxSize)]\r\n        self.top = 0\r\n        self.size = maxSize\r\n        \r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top != self.size:\r\n            self.arr[self.top] = x\r\n            self.top += 1\r\n            \r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.top == 0:\r\n            return -1\r\n        ret = self.arr[self.top-1]\r\n        self.top -= 1\r\n        return ret\r\n        \r\n\r\n    def increment(self, k, val):\r\n        \"\"\"\r\n        :type k: int\r\n        :type val: int\r\n        :rtype: None\r\n        \"\"\"\r\n        if self.top > 0:\r\n            for i in range(min(k, self.top)):\r\n                self.arr[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994218980","body":"```\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        \n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                unit = ''\n                while stack and stack[-1].isalpha():\n                    unit = stack.pop() + unit\n                stack.pop()\n\n                count = ''\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(int(count) * unit)\n        \n        return ''.join(stack)\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"smilejohnson":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991822957","body":"1. 取 k 的最后一位 lastOfk\n2. 取 num 的最后一位 lastOfNum\n3. 如果 sum(lastOfNum + lastOfk + flag) 大于等于10，进位标记为1，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n4. 如果 sum(lastOfNum + lastOfk + flag) 小于10， 进位标记为0，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n5.  然后遍历完 num, k 并确保flag最后的值为 0\n\n``` java\nclass Solution {\n    // 取 k 的最后一位 lastOfk\n    // 取 num 的最后一位 lastOfNum\n    // 如果 sum(lastOfNum + lastOfk + flag) 大于等于10，进位标记为1，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n    // 如果 sum(lastOfNum + lastOfk + flag) 小于10， 进位标记为0，将 sum(lastOfNum + lastOfk + flag) % 10 放置到 res 中\n    // 然后遍历完 num, k 并确保flag最后的值为 0\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> res = new LinkedList<>();\n        // 遍历k\n        int index = num.length - 1; // num 的最后一位\n        int flag = 0; // 进位\n        int lastOfNum = 0;\n        int lastOfk = 0;\n        int sum = 0;\n        while (k > 0 && index >= 0) {\n            lastOfk = k % 10;\n            k /= 10;\n            lastOfNum = num[index--];\n            sum = lastOfk + lastOfNum + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n        }\n        \n        while (k > 0) {\n            lastOfk = k % 10;\n            k /= 10;\n            sum = lastOfk + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n           \n        }\n\n        while (index >= 0) {\n            lastOfNum = num[index--];\n            sum = lastOfNum + flag;\n            if (sum >= 10) {\n                flag = 1;\n                res.addFirst(sum % 10);\n            } else {\n                flag = 0;\n                res.addFirst(sum);\n            }\n        }\n\n        if (flag == 1) {\n            res.addFirst(1);\n        }\n\n        return res;\n    }\n}\n```\n\n---\n- Time: O(max(m,n)) \n- Space: O(m+n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992112172","body":"思路：字符串 s 中的两个 c 之间用双指针法算距离，第一个 c 和最后一个 c 直接循环计算\n---\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        // 1. 统计 c 的个数并且将 c 对应的值置为0\n        char[] chs = s.toCharArray();\n        int length = chs.length;\n        int[] res = new int[length];\n        List<Integer> boundaries = new ArrayList<>();\n        for (int i = 0; i < length; i++) {\n            if (chs[i] == c) {\n                res[i] = 0;\n                boundaries.add(i);\n            } else {\n                res[i] = -1;\n            }\n        }\n        if (boundaries.isEmpty()) return res;\n        // 2. 值为0的下标，两两一对，利用双指针法将其范围内的值置为离其最近的举例\n        for (int i = 1; i < boundaries.size(); i++) {\n            getShortestDistance(res, boundaries.get(i - 1), boundaries.get(i));\n        }\n        // 3. 处理第一个0和最后一个0\n        int first = boundaries.get(0);\n        int value = 0;\n        while (first >= 0) {\n            res[first--] = value++;\n        }\n\n        int last = boundaries.get(boundaries.size() - 1);\n        value = 0;\n        while (last < length) {\n            res[last++] = value++;\n        }\n\n        return res;\n    }\n\n    // 计算数组在 [start,end] 范围内举例边界较短的举例\n    private void getShortestDistance(int[] nums, int start, int end) {\n        int value = 0;\n        while (start < end) {\n            nums[start++] = value;\n            nums[end--] = value;\n            value++;\n        }\n        if (start == end) nums[start] = value;\n    }\n}\n```\n---\n- Time: O(2N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993086622","body":"# 思路\n用数组模拟栈，从数组尾部添加、弹出，increase的时候，从第0个元素到第 min(k, arr.size) 元素增加 val\n\n# 代码\n```java\nclass CustomStack {\n    int capacity;\n    int count;\n    List<Integer> myStack;\n\n    public CustomStack(int maxSize) {\n        this.capacity = maxSize;\n        this.count = 0;\n        this.myStack = new LinkedList<>();\n\n    }\n\n    public void push(int x) {\n        if (this.count < this.capacity) {\n            this.count++;\n            this.myStack.add(x);\n        }\n    }\n\n    public int pop() {\n        if (this.count == 0) {\n            return -1;\n        }\n        // 弹出栈顶元素\n        int remove = this.myStack.remove(--this.count);\n        return remove;\n    }\n\n    public void increment(int k, int val) {\n        if (k > this.count) {\n            k = this.count;\n        }\n        for (int i = 0; i < k; i++) {\n            this.myStack.set(i, this.myStack.get(i) + val);\n        }\n    }\n}\n```\n\n# 复杂度\n- Time: O(N)\n- Space: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994305942","body":"# 思路\n- 当前为 [ 时递归，并累加 num 此递归函数的返回值（内层字符串）\n- 当前为 ] 时，返回当前 res\n- 当前为数字时更新 num\n- 当前为字母时更新 res\n\n# 代码\n```java\nclass Solution {\n    int index;\n    public String decodeString(String s) {\n        if (s == null || s.length() == 0) return s;\n        char[] str = s.toCharArray();\n        this.index = 0;\n        StringBuilder res = dfs(str);\n        return res.toString();\n    }\n\n    // 当前为 [ 时递归，并累加 num 此递归函数的返回值（内层字符串）\n    // 当前为 ] 时，返回当前 res\n    // 当前为数字时更新 num\n    // 当前为字母时更新 res\n    private StringBuilder dfs(char[] str) {\n        StringBuilder res = new StringBuilder();\n        int num = 0;\n        while (index < str.length) {\n            if (str[index] >= '0' && str[index] <= '9') {\n                num = 10 * num + str[index] - '0';\n            } else if (str[index] == '[') {\n                index++;\n                StringBuilder inside = dfs(str);\n                while (num-- > 0) {\n                    res.append(inside);\n                }\n                num = 0;\n            } else if (str[index] == ']') {\n                break;\n            } else {\n                res.append(str[index]);\n            }\n            index++;\n        }\n        return res;\n    }\n}\n```\n\n# 复杂度\n- Time : O(N)\n- Space: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hzgwebgit":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991824949","body":"思路\n数组尾数与k 逐项相加，大于10 则进位\n\n代码\n\nvar add = function(num, k) {\n    const res = [];\n    const len = num.length;\n    for (let i = len - 1; i >= 0; --i) {\n        let sum = num[i] + k % 10;\n        k = Math.floor(k / 10);\n        if (sum >= 10) {\n            k++;\n            sum -= 10;\n        }\n        res.push(sum);\n    }\n    for (; k > 0; k = Math.floor(k / 10)) {\n        res.push(k % 10);\n    }\n    res.reverse();\n    return res;\n};\n\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992185429","body":"思路\n找到C在S中的所有索引，通过对比S[i]在C Array中最小的偏移量得到结果更新arr[i]。\n\n代码\njavascript\nvar shortestToChar = function(s, c) {\n   const sArr = s.split('')\n   const len = sArr.length\n   const resArr = []\n   const arr = []\n   for(let i = 0;i<len;i++){\n       if(s[i] == c){\n          resArr.push(i) \n       }\n   }\n   for (let i = 0; i < len; i++) {\n       arr[i] =resArr.reduce((cur, item) => {\n            return Math.min(cur, Math.abs(i - item))\n        },100)\n    }\n    return arr\n};\n**复杂度分析**\n- 时间复杂度：O(MN)，其中N为S的length，M为C在S中的数量。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993408129","body":"思路\n利用js数组的push和pop\n\n代码\nvar CustomStack = function(maxSize) {\n    this.size = maxSize\n    this.list = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if(this.list.length<this.size){\n        this.list.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n   return this.list.length?this.list.pop():'-1'\n};\n\nCustomStack.prototype.increment = function(k, val) {\n   let len = Math.min(k, this.list.length);\n    for (let i = 0; i < len; i++) {\n        this.list[i] += val;\n    }\n};\n复杂度分析\n\n时间复杂度：O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994812688","body":"思路：找到第一个[计数，当找到对应数量的]后，截取循环前面数字次，然后替换掉原字符串，重复上面步骤，直到没有 [ ] 为止\n\n\nvar decodeString = function(s) {\n    while (/\\d\\[.*?\\]/g.test(s)) {\n        const len = s.length;\n        let i = 0;\n        let n = 0,\n            start = 0,\n            end = 0;\n        for (i; i < len; i++) {\n            if (s[i] === '[') {\n                n++;\n                if (n === 1) {\n                    start = i;\n                }\n            } else if (s[i] === ']') {\n                n--;\n                if (n === 0) {\n                    end = i;\n                    const str = s.slice(start, end + 1);\n                    const num = parseInt(s.match(/\\d.*/) &&\n                        s.match(/\\d.*/)[0]);\n                    s = s.replace(str, (e) => {\n                        let strP = ''\n                        for (let index = 0; index < num; index++) {\n                            strP += str.slice(1, str.length - 1);\n                        }\n                        return strP;\n                    });\n                    s = s.slice(0, start - num.toString().length) + s.slice(start);\n                    break;\n                }\n            }\n        }\n    }\n    return s;\n};\n复杂度：O(n2)\n空间度：0（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995821059","body":"### 思路\n\n 利用数组的 shift push 和数组的属性一次进行操作\n\n### 代码\n\n```\nvar MyQueue = function() {\n  this.list = []\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.list.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.list.length>0?this.list.shift():'null'\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n   return this.list.length>0?this.list[0]:'null'\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.list.length>0?false:true\n};\n```\n### 复杂度\n时间复杂度： o(N)\n空间复杂度： o(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"brent-liu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825083","body":"### 思路\n\t1. 创造一个空列表，用来存储结果\n\t2. 取出num列表的每一个数字，按照位次和K对应的位次相加，如果超过10就进位，获得num和k在每一个位次上的和\n\t3. 将每一位次的和按照相应的顺序append到list中，就得到结果\n### 代码\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new ArrayList<Integer>();\n        int n = num.length;\n        for (int i = n-1; i >= 0; --i){\n            int sum = num[i] + k % 10;\n            k /= 10;\n            if (sum >= 10){\n                k ++;\n                sum -= 10;\n            }\n            res.add(sum);\n        }\n        for (; k > 0; k /= 10){\n            res.add(k % 10);\n        }\n        Collections.reverse(res);\n        return res;    \n    }\n}\n```\n**复杂度分析**\n- 时间复杂度：O(max(O, logk)) \n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992112514","body":"### 思路\n\t1. 显示字符串s中存在字符c的位置i\n\t2. 从前往后遍历字符串s，记录每个位置从前往后数与i的距离\n\t3. 从后往前遍历字符串s，记录每个位置从后往前数与s的距离\n\t4. 取两个距离取最小值\n\n### 代码\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993560211","body":"### 思路\n\t1. 用数组来模拟栈，规定数字进来必须从最后一个index位进来，从最后一个index位出去。\n\t2. 栈顶位置其实就是ind= -1时的值，找一个变量记录栈顶位置即可\n\n### 代码\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if (top != stack.length - 1) {\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if (top == -1) {\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top + 1);\n        for (int i = 0; i < limit; ++i) {\n            stack[i] += val;\n        }\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994871300","body":"### 思路\n\t递归，推出BNF\n### 代码\nclass Solution {\n    String src;\n    int ptr;\n\n    public String decodeString(String s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n\n    public String getString() {\n        if (ptr == src.length() || src.charAt(ptr) == ']') {\n            // String -> EPS\n            return \"\";\n        }\n\n        char cur = src.charAt(ptr);\n        int repTime = 1;\n        String ret = \"\";\n\n        if (Character.isDigit(cur)) {\n            // String -> Digits [ String ] String\n            repTime = getDigits(); \n            ++ptr;\n            String str = getString(); \n            ++ptr;\n            while (repTime-- > 0) {\n                ret += str;\n            }\n        } else if (Character.isLetter(cur)) {\n            // String -> Char String\n            ret = String.valueOf(src.charAt(ptr++));\n        }\n        \n        return ret + getString();\n    }\n\n    public int getDigits() {\n        int ret = 0;\n        while (ptr < src.length() && Character.isDigit(src.charAt(ptr))) {\n            ret = ret * 10 + src.charAt(ptr++) - '0';\n        }\n        return ret;\n    }\n}\n\n### 复杂度分析\n- 时间复杂度：O(S)\n- 空间复杂度：O(S)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hdyhdy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825388","body":"思路：\n首先设立一个存放答案的切片。\n接着让数据数组从最后一位开始向前遍历，同时与k数的余数相加。\n相加完判断该值的大小，如果大于十输入到答案切片的时候要减十。\n最后再对答案切片做一个反转。\n\n```\nfunc addToArrayForm(num []int, k int) []int {\n    ans := make([]int,0)\n    for i := len(num) - 1; i >=0; i -- {\n        tem := num[i] + k % 10\n        k = k / 10\n        if tem >= 10 {\n            ans = append(ans,tem - 10)\n            k ++ \n        }else {\n            ans = append(ans,tem )\n        }   \n    }\n    for ; k > 0; k /= 10 {\n        ans = append(ans, k%10)\n    }\n    reverse(ans)\n    return ans \n}\n\nfunc reverse(num []int) {\n    for i, n := 0, len(num); i < n/2; i++ {\n        num[i], num[n-1-i] = num[n-1-i], num[i]\n    }\n}\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992030869","body":"思路：两次遍历，前后遍历，设立更新目标字符的位置。然后在两次遍历得出的相对位置中找到最小值。\n```\nfunc shortestToChar(s string, c byte) []int {\n    n := len(s)\n    res := make([]int, n)\n    left, right := math.MinInt32/2, math.MaxInt32/2\n\n    for i :=0; i < n ;i++ {\n        if s[i] == c{\n            left = i\n        } \n        res[i] = i - left\n    }\n    for i := n-1;i >= 0;i -- {\n        if s[i] == c {\n            right = i\n        }\n        res[i] = min(res[i], right-i)\n    }\n    return res\n}\n\nfunc min(a, b int) int {\n    if a > b {\n        return b\n    }else {\n        return a\n    }\n}\n```\n时间空间复杂度都为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993081170","body":"思路：结构体添加一个变量c，用于记录需要操作的位置。push和pop需要注意的地方在注意变量c在不同值的情况下操作是不一样的。\n```\ntype CustomStack struct {\n    stack []int\n    c int\n}\n\n\nfunc Constructor(maxSize int) CustomStack {\n    return CustomStack{\n        stack : make([]int,maxSize),\n        c : 0,\n    }\n}\n\n\nfunc (this *CustomStack) Push(x int)  {\n    if this.c < len(this.stack){\n        this.stack[this.c] = x\n        this.c ++ \n    }\n}\n\n\nfunc (this *CustomStack) Pop() int {\n    if this.c != 0 {\n\t\tthis.c--\n\t\treturn this.stack[this.c]\n\t}\n\treturn -1\n}\n\n\nfunc (this *CustomStack) Increment(k int, val int)  {\n    if k > this.c {\n\t\tfor i := 0; i < this.c; i++ {\n\t\t\tthis.stack[i] += val\n\t\t}\n\t} else {\n\t\tfor i := 0; i < k; i++ {\n\t\t\tthis.stack[i] += val\n\t\t}\n\t}\n\n}\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * obj := Constructor(maxSize);\n * obj.Push(x);\n * param_2 := obj.Pop();\n * obj.Increment(k,val);\n */\n```\n复杂度：\n时间：初始化、Pop和Push都为1，inc循环，所以最多为k\n空间：创建了maxsize大小的，所以空间为maxsize","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994311212","body":"这道题的思路是用栈去解决。\n首先设立两个栈，一个放数字，一个放字符。\n然后分条件操作。如果遇到字符，就把连续的字符保留下来。如果是遇到数字的话，那么首先将数字保留。如果遇到了【符号，那么就首先将字符和数字压住栈，接着把字符和数字保留的变量清零。如果遇到了】的话，那么就首先把栈中最顶的元素压出来，然后再将压入栈的元素与当前保留的字符相加。\n```\nfunc decodeString(s string) string {\n    numStack := []int{}\n    strStack := []string{}\n    num := 0\n    result := \"\"\n    for _, char := range s {\n        if char >= '0' && char <= '9' {\n            n, _ := strconv.Atoi(string(char))\n            num = num*10 + n\n        }else if char == '[' {\n            strStack = append(strStack,result)\n            result = \"\"\n            numStack = append(numStack,num)\n            num = 0 \n        }else if char == ']' {\n            count := numStack[len(numStack)-1]\n            numStack = numStack[:len(numStack)-1]\n            str := strStack[len(strStack)-1]\n            strStack = strStack[:len(strStack)-1]\n            result = string(str) + strings.Repeat(result, count)\n        }else {\n            result += string(char)\n        }\n    }\n    return result\n}\n```\n空间复杂度为n时间复杂度也为n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339289","body":"思路：用数组实现栈，用栈实现队列\n```\ntype MyQueue struct {\n    in Stack\n    out Stack\n}\n\ntype Stack []int\n\nfunc Constructor() MyQueue {\n    return MyQueue{}\n}\n\n\nfunc (this *MyQueue) Push(x int)  {\n    this.in = append(this.in, x)\n}\n\n\nfunc (this *MyQueue) Pop() int {\n    if len(this.in) == 0 {\n        return -1\n    }\n    que := this.in[0]\n    this.in = this.in[1:]\n    this.out = append(this.out, que)\n    return this.out[len(this.out)-1]\n}\n\n\nfunc (this *MyQueue) Peek() int {\n    return this.in[0]\n}\n\n\nfunc (this *MyQueue) Empty() bool {\n    if len(this.in) == 0 {\n        return true\n    }\n    return false \n}\n```\n时间复杂度和空间复杂度均为n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"simbafl":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825575","body":"-- java版\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for(int i=n-1;i>=0;--i){\r\n            int sum = num[i] + k % 10;\r\n            k = k /10;\r\n            if(sum >= 10){\r\n                k += 1;\r\n                sum -=10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for(; k>0; k/=10){\r\n            res.add(k%10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n-- python版\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for i in range(len(num)-1, -1, -1):\r\n            k += num[i] \r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        while k:\r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        return res\r\n```\r\n\r\n```py\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        res = []\r\n        for n in num[::-1]:\r\n            k += n \r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        while k:\r\n            res.insert(0, k%10)\r\n            k //= 10\r\n        return res\r\n```\r\n说到底还是遍历，时间复杂度：O(max(k, len(num)))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992440289","body":"-- java\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c){\r\n        int n = s.length();\r\n        int[] ans = new int[n];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for(int i=0;i<n;++i){\r\n            if(s.charAt(i) == c){prev = i;}\r\n            ans[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for(int i=n-1; i>=0; --i){\r\n            if (s.charAt(i) == c){prev = i;}\r\n            ans[i] = Math.min(ans[i], prev-i);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n```\r\n\r\n-- python\r\n```py\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(s):\r\n            if x == c:\r\n                prev = i \r\n            ans.append(i-prev)\r\n        prev = float('inf')\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c:\r\n                prev = j\r\n            ans[j] = min(ans[j], prev-j)\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993533857","body":"-- python\r\n\r\n```py\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stack) - 1:\r\n            self.top += 1\r\n            self.stack[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top > -1:\r\n            res = self.stack[self.top]\r\n            self.top -= 1\r\n            return res\r\n        else:\r\n            return -1\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        num = min(self.top+1, k)\r\n        for i in range(num):\r\n            self.stack[i] += val\r\n```\r\n\r\n```java\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994734954","body":"-- python \r\n```py\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = \"\"\r\n        for c in s:\r\n            if c.isdigit():\r\n                num = num * 10 + int(c)\r\n            elif c == \"[\":\r\n                stack.append((res, num))\r\n                res, num = \"\", 0\r\n            elif c == \"]\":\r\n                top = stack.pop()\r\n                res = top[0] + res * top[1]\r\n            else:\r\n                res += c \r\n            print(stack)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339557","body":"--java\r\n```java\r\nclass MyQueue {\r\n    private Stack<Integer> stackA;\r\n    private Stack<Integer> stackB;\r\n\r\n    public MyQueue() {\r\n        stackA = new Stack<Integer>();\r\n        stackB = new Stack<Integer>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        stackA.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(stackB.isEmpty()) {\r\n            while(!stackA.isEmpty()){\r\n                stackB.push(stackA.pop());\r\n            }\r\n        }\r\n        return stackB.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(stackB.isEmpty()) {\r\n            while(!stackA.isEmpty()){\r\n                stackB.push(stackA.pop());\r\n            }\r\n        }\r\n        return stackB.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        if(stackA.isEmpty() && stackB.isEmpty()){\r\n            return true;\r\n        }else{\r\n            return false;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n-- python\r\n```py\r\nclass MyQueue(object):\r\n\r\ndef __init__(self):\r\n    self.stack1 = []\r\n    self.stack2 = []\r\n\r\ndef push(self, x):\r\n    self.stack1.append(x)\r\n\r\ndef pop(self):\r\n    if not self.stack2:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n    return self.stack2.pop()\r\n\r\ndef peek(self):\r\n    if not self.stack2:\r\n        while self.stack1:\r\n            self.stack2.append(self.stack1.pop())\r\n    return self.stack2[-1]\r\n\r\ndef empty(self):\r\n    return not self.stack1 and not self.stack2\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rzhao010":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825675","body":"**思路：**\r\nAdding up by digits.\r\nIn the array, we start from the very end element.\r\nFor the integer k, each time we use the last digit (k % 10),\r\nif the sum is bigger than 9, add 1 to k(so we don't need another var to record it).\r\nAfter the loop, deal with the case k > 0 (maybe k is too big or we have addup).\r\n\r\n**代码**\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum > 9) {\r\n               k += 1;\r\n               sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**Time Complexity**\r\nTime: O(n), one for loop; \r\nSpace: O(n), use one arraylist","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991971762","body":"**Thoughts**\r\n1. Get all indices of c, go through s to compare i with indices of c\r\n2. Traverse s from head and tail side, record the last index of c , so `i - prev` and `prev - i` is the distance for each traverse, at last compare and select the smaller one\r\n\r\n**Code**\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        ArrayList<Integer> list = new ArrayList<>();\r\n        int[] res = new int[n];\r\n        int p = 0; \r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                list.add(i);\r\n            }\r\n        }\r\n        for (int i = 0; i < n; i++) {\r\n            if (p < list.size() - 1 && Math.abs(list.get(p) - i) > Math.abs(list.get(p + 1) - i)) {\r\n                p++;\r\n            }\r\n            res[i] = Math.abs(list.get(p) - i);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n\r\n```java\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        // in case out of boundry \r\n        int prev = Integer.MIN_VALUE / 2;\r\n        for (int i = 0; i < n; i++) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = i - prev;\r\n        }\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = n - 1; i >= 0; i--) {\r\n            if (s.charAt(i) == c) {\r\n                prev = i;\r\n            }\r\n            res[i] = Math.min(prev - i, res[i]);\r\n        }\r\n        return res;\r\n    }\r\n```\r\n**Time Complexity**\r\n* Time: O(n)\r\n* Space: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992900427","body":"**Thoughts**\r\n\r\nUsing two stack to stimulate the customStack, so for PUSH and POP, we can just go with the same operations. The second Stack will be used to hold the POP of first Stack, then we use an var to count and compare with k.\r\n\r\n**Code**\r\n\r\n```java\r\n    Stack<Integer> stack;\r\n    Stack<Integer> stack2 = new Stack<Integer>();\r\n    int s;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new Stack<Integer>();\r\n        s = maxSize;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (stack.size() < s) {\r\n            stack.push(x);\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (stack.size() == 0) {\r\n            return -1;\r\n        }\r\n        return stack.pop();\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int count = 0;\r\n        if (k > stack.size()) {\r\n            while (stack.size() > 0) {\r\n                int tmp = stack.pop();\r\n                stack2.push(tmp + val);\r\n            }\r\n            while (stack2.size() > 0) {\r\n                int tmp = stack2.pop();\r\n                stack.push(tmp);\r\n            }\r\n        } else {\r\n            while (stack.size() > 0) {\r\n                int tmp = stack.pop();\r\n                stack2.push(tmp);\r\n            }\r\n            while (stack2.size() > 0) {\r\n                int tmp = stack2.pop();\r\n                count++;\r\n                if (count <= k) {\r\n                    stack.push(tmp + val);\r\n                } else {\r\n                    stack.push(tmp);\r\n                }\r\n            }\r\n        }\r\n    }\r\n```\r\n\r\n**Time Complexity**\r\n* Time: PUSH and POP O(1), increment O(k)\r\n* Space: O(n), n is the size of the stack","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923912","body":"**Thoughts**\n1. Using two stacks to record the number and characters\n2. Traversing s, when it's number(digit), push(c);\n\t\t\twhen it's `[`, save current sb to stack;\n\t\t\twhen it's `]`, do the multiplication;\n\t\t\twhen it's char, append to sb\n\t\t\t\n**Code**\n```java\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        Deque<Integer> stack = new LinkedList<>();\n        Deque<StringBuilder> sbStack = new LinkedList<>();\n        for (Character c: s.toCharArray()) {\n            if (Character.isDigit(c)) {\n                multi = multi * 10 + c - '0';\n            } else if (c == '[') {\n                stack.push(multi);\n                sbStack.push(sb);\n                multi = 0;\n                sb = new StringBuilder();\n            } else if (c == ']') {\n                StringBuilder tmp = sbStack.pop();\n                int count = stack.pop();\n                for (int i = 0; i < count; i++) {\n                    tmp.append(sb.toString());\n                }\n                sb = tmp;\n            } else {\n                sb.append(c);\n            }\n        }\n        return sb.toString();\n    }\n```\n\n**Complexity**\n* Time: O(n)\n* Space: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sendsproject":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991825885","body":"思路：使用数列式两数相加模板，注意carry 的进位和取模操作 \r\n\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        p1 = len(num) -1 \r\n        carry = 0 \r\n        results = []\r\n        while p1 >=0 or k != 0 or carry>0:\r\n            add1 = num[p1] if p1 >=0 else 0 \r\n            add2 = k %10\r\n            sum = add1 + add2 + carry\r\n            carry = 1 if sum >= 10 else 0\r\n            sum = sum - 10 if sum >= 10 else sum\r\n            results.append(sum)\r\n            p1 -= 1\r\n            k //= 10\r\n        return results[::-1]\r\n\r\n时间复杂度 O(N)\r\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991972064","body":"解题思路：\r\n\r\n方法1： \r\n\r\n遍历列表两次，第一次遍历的时候储存所有c字符出现的位置，第二次遍历计算距离c字符下标的距离\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        #pos 储存每个c出现的位置\r\n        pos, res = [],[]\r\n        for i in range(len(s)):\r\n            if s[i]==c:\r\n                pos.append(i)\r\n        \r\n        #p指针在pos数组\r\n        p =0\r\n        # 再次遍历字符串\r\n        for i in range(len(s)):\r\n            # 如果当前i 小于pos[0],说明这个字符出现在第一个c字符的前面\r\n            # 那么直接用pos[0] - i \r\n            #这里pos[0] 储存的是character c 在S中出现的下标， 所以可以直接减\r\n            if i < pos[0]:\r\n                res.append(pos[0]-i)\r\n            # 如果当前i大于pos最后一个位置，说明这个字符出现在最后一个c字符的后面\r\n            #那么直接用i-pos[-1]\r\n            elif i > pos[-1]:\r\n                res.append(i - pos[-1])\r\n            # 如果就是字符就是c，那么数值为0，同时给p+1 为下一步做准备\r\n            elif i == pos[p]:\r\n                res.append(0)\r\n                p+=1\r\n            ##在两个c之间，所以返回距离的最小值\r\n            else:\r\n                res.append(min(pos[p]-i,i-pos[p-1]))\r\n        return res\r\n```\r\n\r\n时间复杂度O(N)\r\n空间复杂度O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993157125","body":"暴力解，前缀和没看懂答案 -贴一个暴力解答案\r\n\r\n```python\r\nclass CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.st = []\r\n        self.count = 0\r\n        self.maxSize = maxSize\r\n\r\n    def push(self, x):\r\n        if self.count <self.maxSize:\r\n            self.st.append(x)\r\n            self.count+=1\r\n\r\n    def pop(self):\r\n        if self.count==0:\r\n            return -1\r\n        self.count-=1\r\n        return self.st.pop()\r\n\r\n    def increment(self, k, val):\r\n        for i in range(0, min(self.count,k)):\r\n            self.st[i]+= val\r\n\r\n\r\n时间复杂度O(1), increment -- O(N)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994265782","body":"  把所有字符一个个放到 stack 里， 如果碰到了 ]，就从 stack 找到对应的字符串和重复次数，decode 之后再放回 stack 里\n\n``` python\ndef decodeString(self, s):\n        stack = []\n        for c in s:\n            if c != ']':\n                stack.append(c)\n                continue\n                \n            strs = []\n            while stack and stack[-1] != '[':\n                strs.append(stack.pop())\n            \n            # skip '['\n            stack.pop()\n            \n            repeats = 0\n            base = 1\n            while stack and stack[-1].isdigit():\n                repeats += (ord(stack.pop()) - ord('0')) * base\n                base *= 10\n            stack.append(''.join(reversed(strs)) * repeats)\n        \n        return ''.join(stack)\n\n\n时间复杂度O（N）\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995383073","body":"解题思路：\n\nstack - 后进先出\n\nqueue  - 前进先出\n\n使用两个栈形成负负得正\n\n```python\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n        \n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n时间复杂度: push -O(1), peek/pop -- O(1) worst case O(N)\n空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luoxingbiao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991828392","body":"**思路：**\n\n各位相加，从低到高位计算。nums数组从nums.length-1的位置开始遍历，每次遍历都与当前k的个位值相加，并加上当前一个进位值，\n在判断是否大于9，更新进位值。\n\n细节处理：当k的位数大于nums.length时，在遍历完nums数组后还要处理剩下的k，直到k为0。如果最后进位值为一，要在ans数组头部加1。\n\n**代码：**\n```\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        \n        List<Integer> ans = new LinkedList<Integer>();\n\n        int jinwei = 0;\n        for(int i = num.length - 1;i >= 0;i--){\n            int a = num[i] + (k % 10) + jinwei;\n            if(a >= 10){\n                jinwei = 1;\n                a %= 10;\n            }\n            else{\n                jinwei = 0;\n            }\n            ans.add(0,a);\n            k = k / 10;\n        }\n\n        while(k != 0){\n            if(jinwei != 0){\n                int a = (k % 10) + jinwei;\n                if(a >= 10){\n                    jinwei = 1;\n                    a %= 10;\n                }\n                else{\n                    jinwei = 0;\n                }\n                ans.add(0, a);\n            }\n            else{\n                ans.add(0, k % 10);\n            }\n\n            k = k / 10;\n\n        }\n\n        if(jinwei != 0){\n            ans.add(0,1);\n        }\n\n        return ans;\n\n\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(max(nums.length,len(k))),因为List是用LinkedList实现，所以在链表头部插入元素的时间复杂度为O(1)。\n\n空间复杂度：O(ans.size())。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992063676","body":"**思路：**\n\n双指针法，left表示当前字符左边第一个字符c的位置，right表示当前字符右边第一个字符c的位置。遍历该字符串，计算每个字符到left和right的距离，把较小值存在ans数组对应位上。当i大于right时，更新left和right的值。\n\n细节处理：当right == length，只有左侧有字符c，对每个元素只需计算abs(i - left)。\n\n**代码**\n```\nclass Solution {\n\n    public int[] shortestToChar(String s, char c) {\n        int length = s.length();\n        int[] ans = new int[length];\n        int left = 0, right = 1;\n        while(left < length && s.charAt(left) != c){\n            left++;\n        }\n        while(right < length && s.charAt(right) != c){\n            right++;\n        }\n\n        for(int i = 0;i < length;i++){\n            if(i > right){\n                if(right != length){\n                    left = right;\n                    right++;\n                    while(right < length && s.charAt(right) != c){\n                        right++;\n                    }\n                }\n            }\n\n            if(right == length){\n                ans[i] = Math.abs(left - i);\n            }\n            else{\n                ans[i] = Math.min(Math.abs(left-i),Math.abs(right - i));\n            }\n        }\n\n        return ans;\n\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度:O(n) 只需要遍历一遍字符串且s.charAt()的复杂度为O(1)。\n空间复杂度:O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993108546","body":"**思路**\n\n用一个数组模拟栈，top指针指向当前栈顶。\n\n**代码**\n\n```\nclass CustomStack {\n\n    int[] data;\n    int top;\n    public CustomStack(int maxSize) {\n        data = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < data.length - 1){\n            data[++top] = x;\n        }\n    }\n    \n    public int pop() {\n        int peek = -1;\n        if(top >= 0){\n            peek = data[top--];\n        }\n        return peek;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < Math.min(k, top + 1);i++){\n            data[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度**\n\n时间复杂度：push(),pop()在O(1)时间内完成，increment在O(n)的时间内完成。故时间复杂度为O(n)。\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994260529","body":"**思路**\n\n使用两个栈，一个保存括号内字符串重复的次数，一个保存该字符串。\n遍历字符串：遇到左括号就把它前面的数字压入数字栈，把它之前的字符串压入字符串栈；遇到右括号，数字栈顶元素k出栈，把当前括号内的字符串重复k次赋给temp，字符串栈顶元素出栈，与temp拼接，保存到结果字符串中；遇到字符，就append到当前字符串。\n\n**代码**\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder sb = new StringBuilder();\n        Stack<String> stackStr = new Stack<>();\n        Stack<Integer> stackInt = new Stack<>();\n        int times = 0;\n\n        for(Character c : s.toCharArray()){\n            if(c >= '0' && c <= '9'){\n                times = times * 10 + Integer.parseInt(String.valueOf(c));\n            }\n            else if(c == '['){\n                stackInt.push(times);\n                stackStr.push(sb.toString());\n                times = 0;\n                sb = new StringBuilder();\n            }\n            else if(c == ']'){\n                int k = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0;i < k;i++){\n                    temp.append(sb);\n                }\n                sb = new StringBuilder(stackStr.pop() + temp);\n            }\n            else{\n                sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度：O(n * max(k))\n\n\n空间复杂度：O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"linyang4":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991828416","body":"## 代码\n```JavaScript\nconst addToArrayForm = (num, k) => {\n    const result = []\n    let carry = 0 // 是否进位\n    for(let i = num.length - 1; i >= 0 || k > 0; i--) {\n        const numItem = num[i] || 0\n        let sum = numItem + (k % 10) + carry\n        if (sum >= 10) {\n            sum = sum - 10\n            carry = 1\n        } else {\n            carry = 0\n        }\n        k = Math.floor(k / 10)\n        result.push(sum)\n    }\n    if (carry === 1) {\n        result.push(1)\n    }\n    return result.reverse()\n};\n```\n\n## 复杂度分析\nM是num的长度, N是k的长度\n- 时间复杂度: O(max(M, logN))\n- 空间复杂度: O(max(M, N))\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992359109","body":"## 思路\r\n1. 创建一个index数组, 用于记录字符 c 在字符串 s 中出现的所有位置\r\n2. 循环字符串 s, 计算 s 中的每一个字符与 index 数组中的每一个 index 相减的绝对值, 然后取所有绝对值中最小的一个作为该字符与目标字符 c 的最短路径\r\n\r\n## 代码\r\n```JavaScript\r\nconst shortestToChar = (s, c) => {\r\n    const result = []\r\n    const cIndexs = []\r\n    // 第一次循环, 记录c在s中所有的位置\r\n    for(let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) {\r\n            cIndexs.push(i)\r\n        }\r\n    }\r\n    // 第二次循环, 计算最短距离\r\n    for (let i = 0; i < s.length; i++) {\r\n        if (s[i] === c) { \r\n            result.push(0)\r\n        } else {\r\n            let minDis =  Math.abs(cIndexs[0] - i)\r\n            for(let j = 1; j < cIndexs.length; j++) {\r\n                const dis = Math.abs(cIndexs[j] - i)\r\n                if (minDis > dis) {\r\n                    minDis = dis\r\n                }\r\n            }\r\n            result.push(minDis)\r\n        }\r\n    }\r\n    return result\r\n};\r\n```\r\n\r\n## 复杂度\r\n- 时间复杂度: O(M*N), N为字符串 s 的长度, M为字符 c 在字符串 s 中出现的次数\r\n- 空间复杂度: O(N), N为字符 c 在字符串 s 中出现的次数","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993102889","body":"## 思路\n1. 构造函数: 创建数组保存栈的值, 并且创建一个变量用于记录数组最大容纳数量\n2. push操作: 先比较数组的长度和最大容纳数量, 如果2个值相等, 不进行任何操作, 否则把数据添加到数组末尾\n3. pop操作: 先判断数组是否为空, 为空就返回-1, 否则移除数组最后一位的数据并返回\n4. inc操作: 取数组的长度和k中较小的进行遍历, 然后进行加等操作\n\n## 代码\n```JavaScript\nvar CustomStack = function(maxSize) {\n    this._data = []\n    this._maxSize = maxSize\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this._data.length !== this._maxSize) {\n        this._data.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if (this._data.length !== 0) {\n        return this._data.pop()\n    } else {\n        return -1\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < Math.min(k, this._data.length); i++) {\n        this._data[i] = this._data[i] + val\n    }\n};\n```\n\n## 复杂度\n### 时间复杂度\n- push: O(1)\n- pop: O(1)\n- inc: O(min(K, N)),","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994735827","body":"## 思路\n递归实现\n\n\n## 代码\n```JavaScript\n// 获取最近的一个 \"]\" 的位置\nconst getRightIndex = (arr, leftIndex) => {\n    let count = 1\n    for(let i = leftIndex + 2; i < arr.length; i++) {\n        if (arr[i] === '[') {\n            count++\n        } else if (arr[i] === ']') {\n            count--\n        }\n        if (count === 0) {\n            return i\n        }\n    }\n}\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst decodeString = (s) => {\n    let result = ''\n    for (let i = 0; i < s.length; i++) {\n        if (isNaN(s[i])) {\n            result += result = ''s[i]\n        } else {\n            let num, leftIndex\n            // 取出数字, 并计算最近的 \"[\" 的位置\n            for (let j = i + 1; j < s.length - 1; j++) {\n               if (isNaN(s.slice(i, j))) {\n                   num = Number(s.slice(i, j -1))\n                   leftIndex = j - 1\n                   break\n               }\n            }\n            const rightIndex = getRightIndex(s, leftIndex)\n            // 递归子串\n            const subResult = decodeString(s.slice(leftIndex + 1, rightIndex))\n            result += subResult.repeat(num)\n            i = rightIndex\n        }\n    }\n    return result\n};\n```\n\n## 复杂度\n- 时间复杂度: O(N) \n- 空间复杂度: O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995794228","body":"## 思路\n1. 创建2个栈, push栈和pop栈\n2. push操作: 数据直接存到push栈\n3. pop操作: 分2种情况\n    - 情况1: pop栈中有数据, 直接移除pop栈顶的元素并返回\n    - 情况2: pop栈中无数据, 需要把push栈中所有元素移到pop栈中, 此时pop栈中元素的顺序就和整个队列的先后顺序一致了, 再移除pop栈顶的元素并返回\n4. peek操作: 分2种情况\n    - 情况1: pop栈中有数据, 直接返回pop栈顶的元素   \n    - 情况2: pop栈中无数据, 需要把push栈中所有元素移到pop栈中, 此时pop栈中元素的顺序就和整个队列的先后顺序一致了, 再返回pop栈顶的元素\n5. empty操作: \n    - 2个栈都为空的情况下, 返回true \n    - 只要有一个栈不为空, 返回false\n\n## 代码\n```JavaScript\nvar MyQueue = function() {\n    this._pushStack = []\n    this._popStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this._pushStack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if (this._popStack.length === 0) {\n        while(this._pushStack.length !== 0) {\n            this._popStack.push(this._pushStack.pop())\n        }\n    }\n    return this._popStack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if (this._popStack.length === 0) {\n        while(this._pushStack.length !== 0) {\n            this._popStack.push(this._pushStack.pop())\n        }\n    }\n    return this._popStack[this._popStack.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this._popStack.length === 0 && this._pushStack.length === 0\n};\n```\n\n## 复杂度分析\n1. push操作\n    - 时间复杂度: O(1)\n    - 空间复杂度: O(1)\n2. pop操作\n    - 时间复杂度: 最坏的情况下为O(n), 最好的情况下为O(1)\n    - 空间复杂度: O(1)\n3. peek操作\n    - 时间复杂度: 最坏的情况下为O(n), 最好的情况下为O(1)\n    - 空间复杂度: O(1)\n4. empty操作\n    - 时间复杂度: O(1)\n    - 空间复杂度: O(1)\n    ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"charlestang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829254","body":"思路：\r\n从最后一位开始，模拟竖式加法，逐位向前求和。\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        n = len(num)\r\n        p = n - 1\r\n        carry = 0\r\n        while k > 0 or p >= 0:\r\n            last = k % 10\r\n            new = carry + last + (num[p] if p >= 0 else 0)\r\n            if p >= 0:\r\n                num[p] = new % 10\r\n            else:\r\n                num.insert(0, new % 10)\r\n            carry = new // 10\r\n            k = k // 10\r\n            p = p - 1\r\n        if carry == 1:\r\n            num.insert(0, 1)\r\n        return num\r\n```\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992080862","body":"## 思路\n1. 找出 c 的下标的数组，复杂度 O(n) 遍历一次，这个下标数组是天然有序的；\n2. 从头开始，每个字母的下标去 1 里找出的下标数组里找插入位置，然后比较两侧的距离，选小的。复杂度  O(n log(n))\n总体复杂度 n log(n)\n\n## 代码\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        indices = [i for i, ci in enumerate(s) if ci == c]\n        res = []\n        for i, ch in enumerate(s):\n            if ch == c:\n                res.append(0)\n            else:\n                insert = bisect.bisect_left(indices, i)\n                cur = insert if insert < len(indices) else insert - 1\n                pre = insert - 1 if insert > 0 else 0\n                res.append(min(abs(i-indices[cur]), abs(i-indices[pre])))\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993204166","body":"###  思路\n\n用两个变量记录最大值和当前长度。\n\n### 代码\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.curSize = 0\n        self.stack = []\n\n\n    def push(self, x: int) -> None:\n        if self.curSize < self.maxSize:\n            self.stack.append(x)\n            self.curSize += 1\n\n    def pop(self) -> int:\n        if self.curSize > 0:\n            self.curSize -= 1\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.curSize)):\n            self.stack[i] += val\n\n```\n\n**复杂度分析**\n\n时间复杂度，push 和 pop 都是 O(1)\ninc 复杂度是 O(k)\n空间复杂度是 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994292470","body":"### 思路\n\n使用递归方法实现：\n 1. 遇到字母就直接输出结果；\n 2. 遇到数字就计算数字；\n 3. 遇到中括号，就递归计算中括号内的内容，重复2里面计算的数字次，输出；\n\n利用递归的栈记住中间结果。\n\n\n### 代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        def process() -> str:\n            nonlocal i\n            res = ''\n            count = 0\n            while i < len(s):\n                c = s[i]\n                i += 1\n                if ord('a') <= ord(c) <= ord('z'):\n                    res += c\n                elif ord('0') <= ord(c) <= ord('9'):\n                    count = count * 10 + int(c)\n                elif c == '[':\n                    res += process() * count\n                    count = 0\n                elif c == ']':\n                    return res\n            return res\n        i = 0\n        return process()\n```\n\n**复杂度分析**\n\n因为每个字符遍历了一遍，所以 O(n)\n             ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995400421","body":"### 思路\n\n双栈实现队列，主要问题在于：栈的定义是先进后出，而队列的定义是先进先出。\n\n所以，我们实现的时候，用两个栈，第一个栈专门用于入栈，而第二个队列则只用于出栈。\n\n当我们把第一个栈元素逐一弹出并加入第二个栈后，里面元素的数量会颠倒，正好符合队列的定义。\n\n我们可以在 peek 的时候进行这个操作，如果第二个栈有元素，就访问第二个栈，如果第二个栈是空的\n就把第一个栈搬空放到第二个栈。这样子操作，peek 在第二个栈为空的时候，复杂度O(n)，但是平均到\nn 次的话，因为只搬了一次，所以平均复杂度只有O(1)。\n\npop 很好实现，就是 peek 的基础上，对第二个栈执行一个 pop，所以复杂度同 peek。\n\npush的复杂度本就O(1)\n\n### 代码\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        ans = self.peek()\n        self.stack2.pop()\n        return ans\n\n    def peek(self) -> int:\n        if self.stack2: return self.stack2[-1]\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self) -> bool:\n        return not self.stack1 and not self.stack2\n```\n\n**复杂度分析**\n\n时间复杂度：push, pop, peek, empty 平均复杂度都是 O(1)\n\n空间复杂度：O(n) 因为用了两个栈","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"flower-f":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829635","body":"### 解题思路\n题型：模拟\n思路：模拟加法运算，大于或等于 10 就向前进位\n\n### 代码\n\n```typescript\nfunction addToArrayForm(num: number[], k: number): number[] {\n    let carry = 0; // 记录进位\n    let i = num.length - 1; // 记录当前 num 数字的指针\n    const res = []; // 结果\n\n    // 当 i >= 0 或 k > 0 或 carry > 0 的时候，说明需要继续进行加法\n    while(i >= 0 || k > 0 || carry > 0) {\n        const k_add = k > 0 ? k % 10 : 0; // k 提供的加数\n        const num_add = i >= 0 ? num[i] : 0; // num 提供的加数\n        const sum = k_add + num_add + carry; // 求和\n        res.push(sum % 10); // 存储结果\n        carry = Math.floor(sum / 10); // 计算进位\n\n        i--;\n        k = Math.floor(k / 10);\n    }\n\n    return res.reverse();\n};\n```\n\n### 复杂度\n时间：O(max(n, m))\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054660","body":"### 解题思路\n使用双指针，因为对于一个点来说，影响距离的字符 c 最多只有两个（当两个 c 在该点的不同方向）。\n具体思路见代码注释。\n\n### 代码\n\n```typescript\nfunction shortestToChar(s: string, c: string): number[] {\n    const arr: number[] = [];\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === c) {\n            arr.push(i); // 存储所有的字符 c 位置\n        }\n    }\n\n    const res: number[] = [];\n    let cur = 0; // 当前选择的下标\n    let index1, index2; // 双指针\n    if (arr.length === 1) {\n        index1 = index2 = arr[0];\n    } else {\n        index1 = arr[cur], index2 = arr[++cur];\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // 当超越了 index2 指针的时候，就需要交换指针了\n        // 此处需要考虑数组边界\n        if (i > index2 && cur + 1 <= arr.length - 1) {\n            index1 = index2;\n            index2 = arr[++cur];\n        }\n\n        const dist1 = Math.abs(index1 - i);\n        const dist2 = Math.abs(index2 - i);\n        res.push(Math.min(dist1, dist2));\n    }\n\n    return res;\n};\n```\n\n### 复杂度\n时间复杂度 O(n)\n空间复杂度 O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993190380","body":"### 解题思路\n使用数组模拟栈\n\n### 代码\n\n```typescript\nclass CustomStack {\n    maxSize: number;\n    stack: number[];\n\n    constructor(maxSize: number) {\n        this.maxSize = maxSize;\n        this.stack = [];\n    }\n\n    push(x: number): void {\n        if(this.stack.length < this.maxSize) {\n            this.stack.push(x);\n        }\n    }\n\n    pop(): number {\n        if (this.stack.length === 0) {\n            return -1;\n        }\n        return this.stack.pop();\n    }\n\n    increment(k: number, val: number): void {\n        let needPop = Math.min(k, this.stack.length); // 需要弹出栈顶的元素数量\n\n        for(let i = 0; i < needPop; i++) {\n            this.stack[i] = this.stack[i] + val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n### 复杂度\n时间 O(k)\n空间 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994383806","body":"### 解题思路\n使用两个栈，一个存储倍数，一个存储字符串。遇到 [ 进栈，] 出栈。具体思路见代码注释。\n\n### 代码\n\n```typescript\nfunction decodeString(s: string): string {\n    const numStack: number[] = []; // 存储倍数的栈\n    const strStack: string[] = []; // 存储字符串的栈\n\n    let num = 0; // 暂存倍数\n    let str = ''; // 暂存字符串\n\n    for (const ch of s) {\n        if(!isNaN(+ch)) {\n            // 如果是数字\n            num = num * 10 + parseInt(ch);\n        } else if (ch === '[') {\n            // 入栈\n            numStack.push(num);\n            strStack.push(str);\n            // 清零\n            str = '';\n            num = 0;\n        } else if (ch === ']') {\n            // 出栈\n            const times = numStack.pop(); // 重复倍数\n            const temp = strStack.pop();  // 取出当前栈顶字符串\n            str = temp + str.repeat(times); // 更新 str\n        } else {\n            // 如果是字母\n            str += ch;\n        }\n    }\n\n    return str;\n};\n```\n\n### 复杂度\n时间：O(n * maxRepeatTimes)\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995472754","body":"### 解题思路\n两个栈，其中一个只能 push，另一个只能 pop。\n\n### 代码\n\n```typescript\nclass MyQueue {\n    stack1: number[];\n    stack2: number[];\n    constructor() {\n        this.stack1 = [];\n        this.stack2 = [];\n    }\n\n    push(x: number): void {\n        this.stack1.push(x);\n    }\n\n    pop(): number {\n        if(this.stack2.length) {\n            return this.stack2.pop();\n        }\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n        return this.stack2.pop();\n    }\n\n    peek(): number {\n        if(this.stack2.length) {\n            return this.stack2[this.stack2.length - 1];\n        }\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop());\n        }\n        return this.stack2[this.stack2.length - 1];\n    }\n\n    empty(): boolean {\n        return this.stack1.length === 0 && this.stack2.length === 0;\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```\n\n复杂度：\n时间：O(n)\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaominghao":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991829645","body":"### 思路\n本来的思路是直接算，然后翻转，遇到几个问题\n1. 数据会超过int的范围，需要用BigInteger(Java)\n2. 循环次数过多\n然后看了题解，将k当成一个整体与每一位运算\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n\t\tList<Integer> result = new ArrayList<>();\n\t\tfor(int i = num.length - 1; i >= 0; i--) {\n\t\t\tint temp = (num[i] + k) % 10;\n\t\t\tk = (k + num[i])/10;\n\t\t\tresult.add(temp);\n\t\t}\n\t\twhile(k!=0) {\n\t\t\tresult.add(k%10);\n\t\t\tk = k/10;\n\t\t}\n\t\tCollections.reverse(result);\n\t\treturn result;\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O(Max(N,logK))，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992082947","body":"### 思路\n粗暴做法，直接选出所有的C，然后一个个比较，取最小值，看题解之后发现可以先找出在右边的最小值，再找出在左边的最小值\n\n### 代码\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n\t\tint N = s.length();\n\t\tint[] ans = new int[N];\n\t\tint pre = -N;\n\t\tfor(int i = 0; i<N;i++) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = i-pre;\n\t\t}\n\t\tpre = 2*N;\n\t\tfor(int i = N-1; i>=0;i--) {\n\t\t\tif(s.charAt(i) == c) pre = i;\n\t\t\tans[i] = Math.min(ans[i],pre-i);\n\t\t}\n\t\treturn ans;\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993123932","body":"### 思路\n栈具有先进后出的特性，可以用数组来实现\n### 代码\n```java\nclass CustomStack {\n    int[] stack;\n    int maxSize = 0;\n    int size = 0;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if(size<maxSize) {\n            this.stack[size] = x;\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if(size>0) {\n            int result = stack[size -1];\n            size --;\n            return result;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i < k && i<size; i++) {\n            stack[i] = stack[i]+ val;\n        }\n    }\n}\n```\n### 时空复杂度\n时间复杂度\npush O(1) pop O(1) increment O(min(K,N))\n空间复杂度\nO(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994435449","body":"### 思路\n使用栈，遇到了]就开始出栈，一直到[，这样拼成一个新的字符之后，根据之前的数字重新入栈，这个数字可能是好几位，所以要特殊处理下\n\n### 代码\n```java\nclass Solution {\n    static Stack<String> strings = new Stack<>();\n    public static String decodeString(String s) {\n        char[] chars = s.toCharArray();\n        for(int i = 0; i < chars.length; i++) {\n            if(chars[i] != ']') {\n                if(Character.isDigit(chars[i])) {\n                    int tempCal = 0;\n                    while(Character.isDigit(chars[i])){\n                        tempCal = tempCal*10 + chars[i] - '0';\n                        i++;\n                    }\n                    i--;\n                    strings.push(String.valueOf(tempCal));\n                } else {\n                    strings.push(String.valueOf(chars[i]));\n                }\n\n            } else {\n                String poped, temp = \"\", newString=\"\";\n                while(!(poped = strings.pop()).equals(\"[\")) {\n                    temp = poped + temp;\n                }\n                poped = strings.pop();\n                int cal = Integer.parseInt(poped);\n                for(int j = 0; j < cal;j++) {\n                    newString += temp;\n                }\n                strings.push(newString);\n            }\n        }\n        String ans = \"\";\n        while(!strings.isEmpty()) {\n            ans = strings.pop()+ans;\n        }\n        return ans;\n    }\n}\n```\n### 时间复杂度\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995358488","body":"## 思路\n使用两个栈实现，结合栈FILO的特性和队列FIFO的要求，可以在push的时候进行一次倒腾，均摊时间复杂度可以缩短整体的时间复杂度到O(1)\n## 代码\n```java\nimport java.util.Stack;\n\nclass MyQueue {\n    Stack<Integer> stack;\n    Stack<Integer> tempStack;\n\n    public MyQueue() {\n        this.stack = new Stack<>();\n        this.tempStack = new Stack<>();\n    }\n    \n    public void push(int x) {\n        if(stack.isEmpty()) {\n            stack.push(x);\n        } else {\n          while(!stack.isEmpty()) {\n              tempStack.push(stack.pop());\n          }\n          stack.push(x);\n          while(!tempStack.empty()) {\n              stack.push(tempStack.pop());\n          }\n        }\n    }\n    \n    public int pop() {\n        return stack.pop();\n    }\n    \n    public int peek() {\n        return stack.peek();\n    }\n    \n    public boolean empty() {\n        return stack.isEmpty();\n    }\n}\n```\n时间复杂度\npush O(N)\npop O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"awesomelittle76":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991830816","body":"思路\n大整数的存储\n从高位到低位存，方便进位\n例：123456789 -> [9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n相加\n用代码模拟两数相加\n[A3, A2, A1, A0] + [B2, B1, B0]\n-> C0 = A0 + B0 如果 C0 > 10，则进位\n-> C1 = A1 + B1 + t(有进位则为1，否则为0)\n-> C2 = A2 + B2 + t\n-> C3 = A2 + t\n\nTS语法部分\nTS中的Number数据类型并不是int，所以在取余数的时候，要额外做取整\n\n代码\n\nfunction addToArrayForm(num: number[], k: number): number[] {\n  num.reverse();\n  for (let i = 0; i < num.length; i++) {\n    k += num[i];\n    num[i] = k % 10;\n    k = (k / 10) | 0;\n  }\n  while (k > 0) {\n    num.push(k % 10);\n    k = (k / 10) | 0;\n  }\n  num.reverse();\n  return num;\n}\n\n\n分析\n时间复杂度：O(n)\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992346123","body":"思路\n设想\n1. 对每一个位置，找到左边最近的 c，再找到右边最近的 c\n2. 计算左右分别距离是多少，取最小值\n步骤\n1. 从左到右遍历字符串，用 j 来表示当前最后一个 c 在什么位置，就可以求得第 i 个元素，左边最近的 c 的距离\n2. 同理从右到左遍历字符串，求得右边最近的 c 的位置\n3. 取 min\n注意点\n1. ts中，生成填充数组如果直接 new Array(5) 仅仅是具有length属性，遍历的时候依然是空的，需要 fill 具体的值\n2. for loop中，计算距离要想清楚是 i-j 还是 j-i，当从左向右遍历时，找到是左侧最近的 c，j <= i，反之 j >= i\n3. for loop 中，维护 j 可以写在第一个 for 分句里，for (let i = 0, j = -1 ... ) 这样，和写在外面 let j=-1 是一样的，这样更简洁\n\n代码\nfunction shortestToChar(s: string, c: string): number[] {\n    const n = s.length\n    let res:number[] = new Array(n).fill(-1)\n    for (let i = 0, j = -1; i < n; i++) {\n        if (s[i] === c) j = i\n        if (j !== -1) res[i] = i - j\n    }\n    for (let i = n-1, j = -1; i >=0; i--) {\n        if (s[i] === c) j = i\n        if (j !== -1) res[i] === -1 ? res[i] = j - i : res[i] = Math.min(j - i, res[i])\n    }\n    return res\n};\n分析\n时间复杂度：O(2n)\n时间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993436197","body":"思路\n用数组模拟一个栈，维护变量 top 记录栈顶的位置，用辅助数组 add 来实现 O(1) 的 inc 操作。\n● push：当前元素未达到上限 -> top + 1，推元素入数组\n● pop：当前数组不为空 -> top - 1，推元素出数组\n● inc：考虑到只有在 pop 的时候，才会明确元素有无被增量操作，因此可以在 inc 中操作 add 数组，记录每个位置元素的增量，在 pop 的时候具体执行增量操作。\n\n代码\nclass CustomStack {\n    arr : number[]\n    add : number[]\n    top :number\n\n    constructor(maxSize: number) {\n        this.arr = new Array(maxSize).fill(0)\n        this.add = new Array(maxSize).fill(0)\n        this.top = -1\n    }\n\n    push(x: number): void {\n        if (this.top != this.arr.length - 1) {\n            this.top += 1\n            this.arr[this.top] = x\n        }\n    }\n\n    pop(): number {\n        if (this.top === -1) return -1\n        const res = this.arr[this.top] + this.add[this.top]\n        if (this.top != 0) this.add[this.top - 1] += this.add[this.top]\n        this.add[this.top] = 0\n        this.top -= 1\n        return res\n    }\n\n    increment(k: number, val: number): void {\n        const p = Math.min(k - 1, this.top)\n        if (p >= 0) this.add[p] += val\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n分析\n● 时间复杂度：O(1)\n● 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994687549","body":"## 思路\n将右括号作为停止递归的条件:\n1. 字母 => 把当前的字母加到 res 里\n2. 数字 => 找到最后一个数字字符的位置，将这一位前面的字符用递归加到 res 里\n\n注意\n在遇到右括号并处理数字的时候，要记得过滤右括号\n\n## 代码\n```\nfunction decodeString(s: string): string {\n    let u = 0\n    const dfs = (s: string) : string => {\n        let res = ''\n        while(u < s.length && s[u] !== ']'){\n            // s[u]为字母\n            if ((s[u] >= 'a' && s[u] <= 'z') \n            || (s[u] >= 'A' && s[u] <= 'Z'))  {\n                res += s[u]\n                u += 1\n            }\n            // s[u]为数字\n            else if (s[u] > '0' && s[u] < '9') {\n                let k = u\n                // 找数字的最后一位\n                while (s[k] >= '0' && s[k] <= '9') k += 1\n                // 取数字字符串，转为数字，如共重复 32 次\n                let num = parseInt(s.substr(u, k - u)) \n                // u 跳到所有数字字符的后一位\n                u = k + 1\n                const y = dfs(s)\n                // 过滤括号\n                u += 1\n                // 重复 num 次\n                while(num --){ \n                    res += y\n                }\n            }\n        }\n        return res\n    }\n    return dfs(s)\n};\n```\n## 分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995694731","body":"## 思路\n用数组的 push 实现 push；pop 时用另一个数组存 pop 出来的元素；用 index 取 0 做 peek 和 empty 。\n\n## 代码\nclass MyQueue {\n  q: number[];\n  s: number[];\n  constructor() {\n    this.q = [];\n    this.s = [];\n  }\n\n  push(x: number): void {\n    this.q.push(x);\n  }\n\n  pop(): number {\n    while (this.q.length > 1) {\n      this.s.push(this.q.pop()!);\n    }\n    const res = this.q.pop();\n    while (this.s.length) {\n      this.q.push(this.s.pop()!);\n    }\n    return res!;\n  }\n\n  peek(): number {\n    return this.q[0];\n  }\n\n  empty(): boolean {\n    return this.q.length === 0;\n  }\n}\n\n## 分析\npush 时间 O(1) 空间O(n)\npop  时间 O(2n) 空间O(2n)\npeek  时间 O(1) 空间O(1)\nempty  时间 O(1) 空间O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arya-03":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991831460","body":"**代码1**\r\n初始版本，除了代码短，没有优点。执行用时：4928 ms, 在所有 Python3 提交中击败了6.65%的用户，内存消耗：15.6 MB, 在所有 Python3 提交中击败了27.26%的用户。\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        len_A=len(num)\r\n        sum=0\r\n        sum_a=0\r\n        for i in range(len_A):\r\n            sum_a=sum_a+num[i]*pow(10,(len_A-1-i))\r\n        sum=sum_a+k\r\n        result=list(map(int, str(sum)))\r\n        return result\r\n```","onTime":true},null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995437067","body":"### 思路\r\n **「输入栈」会把输入顺序颠倒；如果把「输入栈」的元素逐个弹出放到「输出栈」，再从「输出栈」弹出元素的时候，则可以负负得正，实现了先进先出。**\r\n```python\r\nclass MyQueue:\r\n    def __init__(self):\r\n        self.stack1=[]\r\n        self.stack2=[]\r\n\r\n    def push(self, x: int) -> None:\r\n        self.stack1.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.stack2:\r\n            while self.stack1:\r\n                self.stack2.append(self.stack1.pop())\r\n        return self.stack2[-1]\r\n\r\n\r\n    def empty(self) -> bool:\r\n        return not self.stack1 and not self.stack2\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bluetomlee":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833123","body":"```\r\n// train of thought：\r\n// Add up each number.Then fill the next one\r\n// the first step is traverse the array ,then the index value add then k of index number.\r\n// the second step is check boundary condition to ensure all numbers added.because num's array size is correct, but not sure k is correct\r\n// the third step is reversing array\r\n\r\n// complexity analysis：O(n)\r\n\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        vector<int> res;\r\n        int size = num.size();\r\n        for(int n = size - 1; n >= 0; n--) {\r\n            int sum = num[n] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                // for next loop to complement\r\n                k++;\r\n                sum = sum % 10;\r\n            }\r\n            res.push_back(sum);\r\n        }\r\n\r\n        for (; k > 0; k /= 10) {\r\n            res.push_back(k % 10);\r\n        }\r\n        reverse(res.begin(), res.end());\r\n        return res;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992556798","body":"```\n// thought:\n// double pointer，\n// i record c's index\n// j record current loop index\n// complexity analysis: O(n)\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector <int>res;\n        int length = s.size();\n        int i = 0;\n        for (int k = 0; k < length; k++) {\n            if (s[k] == c) {\n                i = k;\n            }\n        }\n        for (int k = 0; k < length; k++) {\n            if (s[k] == c) {\n                i = k;\n                res.push_back(0);\n            } else if (s[k] != c) {\n                res.push_back(abs(i) - abs(k));\n            }\n        }\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993577684","body":"```\n// 熟悉c++操作用法，resize设置长度，min比三目运算更友好\nclass CustomStack {\npublic:\n    vector<int> stack;\n    int count;\n\n    CustomStack(int maxSize) {\n        stack.resize(maxSize);\n        count = -1;\n    }\n    \n    void push(int x) {\n        if (count != stack.size() - 1) {\n            ++count;\n            stack[count] = x;\n        }\n    }\n    \n    int pop() {\n        if (count == -1) {\n            return -1;\n        }\n        --count;\n        return stack[count + 1];\n    }\n    \n    void increment(int k, int val) {\n        int size = min(k, count + 1);\n        for(int j = 0; j < size; ++j) {\n            stack[j] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994852656","body":"```\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                // 获取一个数字并进栈\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                // 左括号出栈\n                stk.pop_back();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                // 构造字符串\n                while (repTime--) t += o; \n                // 将构造好的字符串入栈\n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995717363","body":"```\nclass MyQueue {\nprivate: \n    stack<int> inStack;\n    stack<int> outStack;\n\n    void inToOut() {\n        while(!inStack.empty()) {\n            outStack.push(inStack.top());\n            inStack.pop();\n        }\n    }\npublic:\n    MyQueue() {}\n    \n    void push(int x) {\n        inStack.push(x);\n    }\n    \n    int pop() {\n        if (inStack.empty()) {\n            inToOut();\n        }\n        int out = outStack.top();\n        outStack.pop();\n        return out;\n    }\n    \n    int peek() {\n        if (outStack.empty()) {\n            inToOut();\n        }\n        return outStack.top();\n    }\n    \n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stackvoid":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991833487","body":"## 思路\n\n- 建一个新数组，并从末尾遍历原始数组。\n- new[i]=(old[j]+k)%10   k=(old[j]+k)/10 是整个解题的核心。\n- 注意边界，返回正确结果即可。\n\n## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] cur = new int[num.length + 5];\n        int i = num.length - 1, j = 0;\n        for (; i >= 0; i--, j++) {\n            cur[j] = (k + num[i]) % 10;\n            k = (k + num[i]) / 10;\n        }\n        while (k != 0) {\n            cur[j++] = k % 10;\n            k = k / 10;\n        }\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        for (int indexR = 0, indexCur = j - 1; indexR < j; indexR++, indexCur--) {\n            result.add(cur[indexCur]);\n        }\n        return result;\n    }\n}\n```\n\n\n\n## 算法分析\n\n时间复杂度：2次遍历数组，时间复杂度为O(N)\n\n空间复杂度：O(N)\n\nN 为 数组长度或K的最大值。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992078285","body":"## 思路\n\n- 遍历数组 寻找数组s中字符c出现的位置。\n- 遍历数组 寻找数组当前字符与mark中的距离 并取最小值\n- 返回结果数组即可\n\n## 代码\n\n```java\n\nimport java.util.ArrayList;\nimport java.util.function.Consumer;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> mark = new ArrayList<>();\n        char[] chars = s.toCharArray();\n        //1.遍历数组 寻找数组s中字符c出现的位置\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == c) {\n                mark.add(i);\n            }\n        }\n        //2.遍历数组 寻找数组当前字符与mark中的距离 取最小值\n        int[] result = new int[chars.length];\n        for (int j = 0; j < chars.length; j++) {\n            int distance = Integer.MAX_VALUE;\n            for (int k = 0; k < mark.size(); k++) {\n                int disTmp = Math.abs(j - mark.get(k));\n                if (disTmp < distance) {\n                    distance = disTmp;\n                }\n            }\n            result[j] = distance;\n        }\n        return result;\n    }\n}\n```\n\n\n\n## 复杂度分析\n\n时间复杂度：2次遍历数组，其中第二次遍历数组，还需再遍历中间结果数组，时间复杂度为O(N^2)\n\n空间复杂度：O(N)\n\nN 为 数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993194248","body":"### 思路\n\n- push和pop注意边界即可\n- inc 从栈底(数组0号)开始遍历，依次加上对应的val即可，注意 for 循环里的边界条件即可\n\n### 代码\n\n```java\nclass CustomStack {\n    int[] stack;\n    int maxSize;//数组最大长度\n    int curIndex;//当前数组下标\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        curIndex = -1;\n    }\n\n    public void push(int x) {\n        if (curIndex >= maxSize - 1) {\n            return;\n        }\n        curIndex++;\n        stack[curIndex] = x;\n    }\n\n    public int pop() {\n        if (curIndex < 0) {\n            return -1;\n        }\n        int resultValue = stack[curIndex];\n        curIndex--;\n        return resultValue;\n    }\n\n    public void increment(int k, int val) {\n        //栈底开始遍历\n        for (int index = 0; index < k && index <= curIndex; index++) {\n            stack[index] = stack[index] + val;\n        }\n    }\n}\n\n```\n\n### 复杂度分析\n\n- push：时间复杂度O(1)  空间复杂度O(1)\n- pop：时间复杂度O(1)  空间复杂度O(1)\n- inc：时间复杂度O(k)  空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994522512","body":"### 思路\n\n本题难点在于括号内嵌套括号，需要从内向外生成与拼接字符串，这与栈的先入后出特性对应。\n\n算法流程：\n构建辅助栈 stack， 遍历字符串 s 中每个字符 c；\n- 当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；\n- 当 c 为字母时，在 sb 尾部添加 c；\n- 当 c 为 [ 时，将当前 multi 和 sb 入栈，并分别置空置 0：\n     记录此 [ 前的临时结果 sb 至栈，用于发现对应 ] 后的拼接操作；\n     记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。\n     进入到新 [ 后，sb 和 multi 重新记录。\n- 当 c 为 ] 时，stack 出栈，拼接字符串 res = lastSb + curMulti * sb，其中:\n- lastSb是上个 [ 到当前 [ 的字符串，例如 \"3[a2[c]]\" 中的 a；\n- curMulti是当前 [ 到 ] 内字符串的重复倍数，例如 \"3[a2[c]]\" 中的 2。\n- 返回字符串 sb。\n\n### 代码\n\n```java\nimport java.util.LinkedList;\n\n//leetcode submit region begin(Prohibit modification and deletion)\nclass Solution {\n    public String decodeString(String s) {\n        LinkedList<Integer> numStack = new LinkedList<>();\n        LinkedList<String> strStack = new LinkedList<>();\n        StringBuilder sb = new StringBuilder();\n        int multi = 0;\n        for (Character c : s.toCharArray()) {\n            if (c >= 'a' && c <= 'z') {\n                sb.append(c);\n            } else if (c >= '0' && c <= '9') {\n                //从数组中获取的重复次数\n                multi = multi * 10 + Integer.valueOf(c + \"\");\n            } else if (c == '[') {\n                //关键点--次数和历史结果 要入栈\n                numStack.addLast(multi);\n                //重置multi参数\n                multi = 0;\n                strStack.addLast(sb.toString());\n                //重置SB\n                sb = new StringBuilder();\n            } else {\n                StringBuilder lastSb = new StringBuilder(strStack.removeLast());\n                int curMulti = numStack.removeLast();\n                for (int i = 0; i < curMulti; i++) {\n                    lastSb.append(sb.toString());\n                }\n                sb = new StringBuilder(lastSb.toString());\n            }\n        }\n        return sb.toString();\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：1次遍历数组，时间复杂度为O(N)\n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995582511","body":"### 思路\n\n本题难点在于两个栈要互相配合，不同时机需要清空另外一个栈。\n\n构建辅助栈 stackA和stackReverse， 一定要注意 不能用 for(;i<stackA.size();),因为不管是push还是pop，stack都是变化的。\n这样i就完全不准了。\n\n### 代码\n\n```java\n\n\nimport java.util.LinkedList;\nclass MyQueue {\n\n    LinkedList<Integer> stackA;\n    LinkedList<Integer> stackReverse;\n\n    public MyQueue() {\n        stackA = new LinkedList<>();\n        stackReverse = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        if (stackReverse.size() > 0) {\n            //一定注意 stackReverse 是变化值\n            while (stackReverse.size() != 0) {\n                stackA.push(stackReverse.pop());\n            }\n        }\n        stackA.push(x);\n        stackReverse.clear();\n    }\n\n    public int pop() {\n        if (stackReverse.size() == 0) {\n            while (stackA.size() != 0) {\n                stackReverse.push(stackA.pop());\n            }\n        }\n        stackA.clear();\n        return stackReverse.pop();\n    }\n\n    public int peek() {\n        if (stackReverse.size() == 0) {\n            while (stackA.size() != 0) {\n                stackReverse.push(stackA.pop());\n            }\n        }\n        return stackReverse.peek();\n    }\n\n    public boolean empty() {\n        if (stackA.size() == 0 && stackReverse.size() == 0) {\n            return true;\n        }\n        return false;\n    }\n}\n\n```\n\n### 复杂度分析\n\n时间复杂度：push() O(N);pop() O(N);peek O(N);empty() O(1)\n\n空间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cszys888":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834012","body":"## 思路\r\n1. 转换num成一个integer，叫做int_num\r\n2. 利用python内置加法求和 int_num和k，得到 int_result\r\n3. 创建一个空数组，利用除法将int_result 转换成数组\r\n\r\n## 代码\r\n```\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        # transform num to an integer\r\n        int_num = 0\r\n        for digit in num:\r\n            int_num = int_num*10 + digit\r\n        \r\n        int_result = int_num + k\r\n\r\n        result = []\r\n        while int_result // 10 > 0:\r\n            result.append(int_result % 10)\r\n            int_result = int_result// 10\r\n        result.append(int_result)\r\n        result.reverse()\r\n        return result\r\n```\r\n\r\n## 复杂度分析\r\ntime complexity: o(N)\r\nspace complexity: o(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991992449","body":"## 思路\n1. 扫描s，记录c出现的位置，存在叫做locations的list里面\n2. 遍历locations里面记录的位置，根据每个位置去计算它周围与它距离最近的点的距离。这个过程也会正好遍历一次s字符串\n\n## 代码\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        locations = []\n        n = len(s)\n        for i in range(n):\n            if s[i] == c:\n                locations.append(i)\n        \n        result = []\n        for i in range(locations[0]):\n            result.append(abs(locations[0] - i))\n        for idx in range(1, len(locations)):\n            mid = (locations[idx]+locations[idx - 1])//2\n            for i in range(locations[idx-1],mid+1):\n                result.append(abs(locations[idx-1] - i))\n            for i in range(mid+1,locations[idx]):\n                result.append(abs(locations[idx] - i))\n        for i in range(locations[-1], n):\n            result.append(abs(locations[-1] - i))\n        \n        return result\n```\n\n## 复杂度分析\n时间复杂度：O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993017938","body":"## 思路\n用O(1)的时间复杂度实现所有的操作，除了increment function\n\n## 代码\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<=self.maxSize - 1:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else:\n            val = self.stack[- 1]\n            self.stack.pop()\n            return val\n\n\n    def increment(self, k: int, val: int) -> None:\n        if k > len(self.stack):\n            k = len(self.stack)\n        for idx in range(k):\n            self.stack[idx] = self.stack[idx] + val\n```\n\n## 复杂度\n时间复杂度:\nCustomStack: O(1)\npush: O(1)\npop: O(1)\nincrement: O(N)\n空间复杂度：\nO(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994284242","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c != ']':\n                stack.append(c)\n            else:\n                tmp = \"\"\n                char = stack.pop()\n                while char != '[':\n                    tmp = char + tmp\n                    char = stack.pop()\n                digit = \"\"\n                print(stack)\n                while stack and stack[-1].isdigit():\n                    digit = stack.pop() + digit\n                digit = int(digit)\n                word = [tmp for _ in range(digit)]\n                word = \"\".join(word)\n                for t in word:\n                    stack.append(t)\n        return \"\".join(stack)\n```                \n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995432208","body":"```python3\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n        self.head = 0\n        self.tail = 0\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n        self.tail += 1\n\n    def pop(self) -> int:\n        self.head += 1\n        return self.queue[self.head - 1]\n\n    def peek(self) -> int:\n        return self.queue[self.head]\n\n    def empty(self) -> bool:\n        if self.head == self.tail:\n            return True\n        else:\n            return False\n```\n\nTime Complexity: O(1)\nSpace Complexity: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rootdavid":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991834365","body":"```cpp\n// 参考题解：https://leetcode-cn.com/problems/add-to-array-form-of-integer/solution/989-ji-zhu-zhe-ge-jia-fa-mo-ban-miao-sha-8y9r/\n\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n      int n = num.size();\n      \n      vector<int> res;\n      int sum = 0, carry = 0;\n      int i = n - 1;\n\n      // 从后往前遍历是因为符合加法运算逻辑\n      while (i >= 0 || k != 0) {\n        // 对齐计算位数，补0\n        int x = i >= 0 ? num[i] : 0;\n        // %10 取个位\n        int y = k != 0 ? k % 10 : 0;\n\n        sum = x + y + carry;\n\n        carry = sum / 10;\n\n        i--;\n        k /= 10;\n\n        res.push_back(sum % 10);\n        \n      }\n\n      // 计算最后一位的时候，可能有进位问题，有进位的话补入结果数组\n      if (carry != 0) res.push_back(carry);\n\n      // res数组是倒序的，所以需要反转\n      reverse(res.begin(), res.end());\n\n      return res;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992473664","body":"```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n      int n = s.size();\n\n      // 初始化最小值，除2因为怕最大整数越界\n      int prev = INT_MIN / 2;\n      vector<int> res(n);\n\n      for (int i = 0; i < n; i++) {\n        if (s[i] == c) prev = i;\n        res[i] = i - prev;\n      }\n\n      prev = INT_MAX / 2;\n\n      for (int i = n - 1; i >= 0; i--) {\n        if (s[i] == c) prev = i;\n        res[i] = min(res[i], prev - i);\n      }\n\n      return res;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993427654","body":"```cpp\nclass CustomStack {\npublic:\n    vector<int> stk, add;\n    int top;\n\n    CustomStack(int maxSize) {\n      stk.resize(maxSize);\n      add.resize(maxSize);\n\n      top = -1;\n    }\n    \n    void push(int x) {\n      if (top != stk.size() - 1) {\n        ++top;\n        stk[top] = x;\n      }\n    }\n    \n    int pop() {\n      if (top == -1) return -1;\n\n      int res = stk[top] + add[top];\n\n      if (top != 0) add[top - 1] += add[top];\n\n      add[top] = 0;\n\n      --top;\n      \n      return res;\n    }\n    \n    void increment(int k, int val) {\n      int lmt = min(k - 1, top);\n\n      if (lmt >= 0) add[lmt] += val;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994781072","body":"```cpp\nclass Solution {\npublic:\n    string decodeString(string s) {\n      stack<int> nums;\n      stack<string> strs;\n\n      string cur;\n      int num = 0;\n\n      for (int i = 0; i < s.size(); i++) {\n        if (s[i] == '[') {\n          nums.push(num);\n          strs.push(cur);\n\n          num = 0;\n          cur = \"\";\n        } else if (s[i] == ']') {\n          int t = nums.top();\n          nums.pop();\n\n          string tmp = cur;\n          cur = strs.top();\n          strs.pop();\n\n          while(t--) cur += tmp;\n        } else if (isdigit(s[i])) {\n          num = num * 10 + s[i] - '0';\n        } else {\n          cur += s[i];\n        }\n      }\n\n      return cur;\n      \n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995392125","body":"```cpp\nclass MyQueue {\npublic:\n    stack<int> s1, s2;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n      s1.push(x);\n    }\n    \n    int pop() {\n      peek();\n      int top = s2.top();\n      s2.pop();\n      return top;\n    }\n    \n    int peek() {\n      if (s2.empty()) {\n        while (!s1.empty()) {\n          s2.push(s1.top());\n          s1.pop();\n        } \n      }\n\n      return s2.top();\n    }\n    \n    bool empty() {\n      return s1.empty() && s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangzichengtech":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835034","body":"## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 关键点\n\n-多次利用三元运算符来判断决定变量的值，进位算是难点  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n          int carry = 0;\n        List<Integer> result = new LinkedList<>();\n        int i = num.length-1;\n        while (k>0 || i>=0){\n            int x = i <0 ?0:num[i];\n            int y = k%10;\n            k = k/10;\n            int sum = x+y+carry >=10 ? x+y+carry-10:x+y+carry;\n            result.add(sum);\n            carry = x+y+carry >= 10 ? 1:0;\n            i--;\n        }\n        if(carry == 1){\n            result.add(carry);\n        }\n\n        Collections.reverse(result);\n        return result;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(1)$\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992418443","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 分析\n\n-  利用两个指针，双指针法，并且建立两个长度为s.length的数组空间，一个指针从左往右遍历，同时往一个数组中存值，如果遇到目标字母，则往向数组对应位置存入0，如果不是目标字母，就往数组中存入上一个数组的值再加1，另一个指针从右往左遍历同理，最后比较两个数组中相同下标的值，小的值留下并存入第一个数组中，得到最后要求的数组。需要注意的是两个指针遍历开始时第一个元素如果是目标字母则赋值为0，不是则赋值为1000。(因为遍历的时候如果没有出现目标字母，无法判断该字母到目标字母的距离，只能等相反方向遍历的指针来计算其到最近的目标字母的距离)，具体请见代码。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n         int len = s.length();\n        int[] left = new int[len];\n        int[] right = new int[len];\n        left[0] = s.charAt(0) == c ?0:1000;\n        for (int i = 1; i < s.length(); i++) {\n            left[i] = s.charAt(i) == c?0:left[i-1]+1;\n        }\n        right[len-1] = s.charAt(len-1) == c ?0:1000;\n        for (int i = len-2; i >=0; i--) {\n            right[i] = s.charAt(i) == c?0:right[i+1]+1;\n        }\n        for (int i = 0; i < s.length(); i++) {\n            left[i] = Math.min(left[i],right[i]);\n        }\n        return left;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993207467","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n## 关键点\n\n-  index代表的是栈中元素的个数，\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\npackage com.wzc;\n\n    class CustomStack {\n        int[] stack;\n        int index;\n        public CustomStack(int maxSize) {\n             stack = new int[maxSize];\n             index = 0;\n        }\n\n        public void push(int x) {\n            if (index == stack.length){\n               return;\n            }\n            stack[index++] = x;\n        }\n\n        public int pop() {\n            if (index == 0){\n                return -1;\n            }\n            return stack[--index];\n        }\n\n        public void increment(int k, int val) {\n            k = Math.min(k,index);\n            for (int i = 0; i < k; i++) {\n                stack[i] = stack[i]+val;\n            }\n        }\n    }\n\n\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995865306","body":"\n## 题目地址(232. 用栈实现队列)\n\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\n\n## 题目描述\n\n```\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n \n\n说明：\n\n你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n \n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n \n\n示例：\n\n输入：\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\n输出：\n[null, null, null, 1, 1, false]\n\n解释：\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\n提示：\n\n1 <= x <= 9\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n```\n## 关键点\n\n-  利用两个栈进行操作，其中一个栈作为辅助栈（a），主要就是入栈操作需多写几行代码，入栈一个元素前先检测b栈中是否有元素，如果有元素则将b栈中的栈顶元素逐个压入a栈中，直到b栈为空为止，然后将新元素入栈a栈，没有元素则将新元素直接入栈a，最后将a栈全部元素出栈压入b栈中。\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n\n    Stack<Integer> a;\n    Stack<Integer> b;\n    public MyQueue() {\n//        a相当于辅助栈\n         a = new Stack<Integer>();\n         b = new Stack<Integer>();\n    }\n\n    public void push(int x) {\n        while (!b.isEmpty()){\n            a.push(b.peek());\n            b.pop();\n        }\n        a.push(x);\n        while(!a.isEmpty()) {\n            b.push(a.peek());\n            a.pop();\n        }\n    }\n\n    public int pop() {\n        return b.pop();\n    }\n\n    public int peek() {\n        return b.peek();\n    }\n\n    public boolean empty() {\n        return b.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(1)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alexno1no2":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835437","body":"思路：\n先用reduce计算num对应数值，\n然后加上k后转成iterable的str对象\n再利用map从高位到低位依次转成整数，\n最后转成list\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        return list(map(int, str(k+reduce(lambda a, b: a*10+b, num))))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992498036","body":"* 暴力破解\n* 先找出字符c在字符串s中的下标\n* 然后计算s中每个字母到c下标的距离中的最短的那个\n```\n class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        c_idx = [ i for i in range(len(s)) if s[i] == c ]\n        return [ min(abs( i - j )  for j in c_idx) for i in range(len(s)) ]\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993048405","body":"题解\n使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\n对于 push 操作，首先判断当前元素的个数是否达到上限，如果没有达到，就把 top 后移一个位置并添加一个元素。\n对于 pop 操作，首先判断当前栈是否为空，非空返回栈顶元素并将 top 前移一位，否则返回 -1。\n对于 inc 操作，直接对栈底的最多 k 个元素加上 val。\n代码\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n分析\n时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994729165","body":"题解\n使用列表来模拟栈的特性\n依次遍历整个字符串\n1、如果该字符不是']',直接压栈\n2、对']'的处理：\n1）、首先不停的pop出[XXX]之间的字符串，直到遇到'['为止\n2）、接下来分析要重复多少次\n3）、字符串换数字后就是重复倍数，重复字符串\n4）、最后相加，压栈\n最后得到答案\n代码\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        l_s = list(s)\n        stack = []\n        for word in l_s:\n            if word != ']':\n                stack.append(word)\n            else:\n                #字符列表\n                temp = []\n                while stack[-1] != '[' and stack:\n                    temp.append(stack.pop())\n                temp = temp[::-1]\n                #然后弹出'['\n                stack.pop()\n                #数字列表\n                nums = []\n                while len(stack) >= 1:\n                    if  stack[-1].isdigit():\n                        nums.append(stack.pop())\n                    else:\n                        break\n                nums = nums[::-1]\n                result = 0\n                for num in nums:\n                    result = result * 10 + int(num)\n                ll = temp * result\n                stack += ll\n        return ''.join(stack)\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994941954","body":"'''python\n'''\n操作两个栈，一个「输入栈」，一个「输出栈」。\n当 push() 新元素的时候，放到「输入栈」的栈顶。\n当 pop() 元素的时候，从「输出栈」弹出元素。如果「输出栈」为空，则把「输入栈」的元素逐个 pop() 并且 push() 到「输出栈」中，这一步会把「输入栈」的栈底元素放到了「输出栈」的栈顶。此时再从「输出栈」的 pop() 元素的顺序与「输入序」相同。\n\n'''\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n\n'''","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"myleswork":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991835905","body":"### 思路\n\n因为A.length最大为10000，所以不能采用类型转换来做，只能采用模拟的办法\n\n设置i作为进位，若对应位与i一起相加后大于10，说明有进位，就将i设置为1，结果对10取余；若小于10则直接进行下一高位的计算。\n\n我设置的条件时num和k同时大于0，若跳出说明至少有一个参数已经到了最高位了，那么未到最高位的参数就以基本相同的思路继续计算。\n\n### 代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       int key = num.size()-1;\n       int i = 0;\n       while(key>=0 && k){\n           num[key] = i + num[key] + k%10;\n           i = 0;\n           if(num[key] >= 10){\n               i = 1;\n               num[key] %= 10;\n           }\n           k /= 10;\n           key--;\n       }\n       //当k比num长时\n           while(k){\n               int sum = k%10+i;\n               num.insert(num.begin(),sum%10);\n               i = sum/10;\n               k /= 10;\n           }\n       \n       //当num比k长时\n           while(key>=0){\n                num[key] = i + num[key] + k%10;\n                i = 0;\n                if(num[key] >= 10){\n                    i = 1;\n                    num[key] %= 10;\n           }\n               key--;\n           }\n       \n       if(i) num.insert(num.begin(),1);\n       return num;\n       //如果num的长度大于k，那到这里就结束了\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(max(numlen,klen))  (numlen为num的长度，klen为k的长度)；\n\n空间复杂度：O(max(numlen,klen))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992043684","body":"### 思路\n\n遍历每一个字符，对当前字符设左右双指针，返回较近c和当前字符距离。\n有一点需要注意，可能左指针或右指针在向左向右遍历时，会遍历到字符头和尾，此时就需要处理距离异常的问题。通过下面这行代码就能确保得到最短且正确（某一指针遍历到边界但另一指针仍在找c这一情况）的距离：\n\n```cpp\nres.push_back(max(abs(i-left),abs(i-right)));\n```\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> res;\n        for(int i = 0;i<len;i++){\n            int left = i;\n            int right = i;\n            while(s[left]!=c && s[right]!=c){\n                if(left>0) left--;\n                if(right<len) right++;\n            }\n            res.push_back(max(abs(i-left),abs(i-right)));\n        }\n        return res;\n    }\n};\n```\n\n**复杂度分析**\n\n时间复杂度：O(n^2)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993098877","body":"### 思路\n\n用数组模拟栈\n\n栈有两种，一种是top指向栈顶元素，另一种是top指向栈顶元素上一空间。我模拟的是第一种。\n\n### 代码\n\n```cpp\nclass CustomStack {\npublic:\n    //用数组模拟栈，便于实现inc\n    //移动top指针从而实现\n    vector<int> Stack;  //栈\n    int top;            //栈顶指针\n\n    CustomStack(int maxSize) {\n        Stack.resize(maxSize);\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top!=Stack.size()-1){\n            ++top;\n            Stack[top] = x;\n        }\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        --top;\n        return Stack[top+1];\n    }\n    \n    void increment(int k, int val) {\n        for(int i = 0;i<k && i<Stack.size();i++){\n            Stack[i] += val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n**复杂度分析**\n\npush：O(1)\n\npop：O(1)\n\nincrement：O(n)\n\n### 有个问题\n\n```cpp\nvoid push(int x) {\n        if(top!=Stack.size()-1){\n            ++top;\n            Stack[top] = x;\n        }\n    }\n//if里面的语句用!=就是对的\n//if里面的语句用<就错了\n//我不理解\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994698864","body":"### 思路\n\n主要就是栈，一个数字栈num，存储数字；一个字符栈str，存储**[**、**]**、以及**字母**这些字符\n\n具体push、pop怎么操作我就不讲了，讲讲我做的时候碰到的问题，后者说是一些细节。\n\n1、在**num[str]** 系统外的字符，我们不能将他入str栈（至少按照我的代码的思路不行），那就需要额外判断，那么什么情况下可以判断当前进入循环的字符是系统外的呢？当str栈为空时，说明当前进入循环的字符是系统外字符。怎么理解？若当前进入循环的字符是系统内的字符，那么str栈里至少有一个 **“[”** 。\n\n弄明白判断条件，就可以直接在遍历循环开头进行判断，若为系统外字符，直接加入res字符串即可。\n\n2、会出现[]套[]的情况，那就需要在pop到 **[**的时候进行判断，判断str栈是否为空（判断num栈也行），**如果非空**，说明存在**[]**套**[]**的情况，就需要把当前括号内的temp重新pop回去，这时候又有两种情况（看3）；**若为空**，说明不存在**[]**套**[]**的情况，直接存入res即可。\n\n3、把当前括号内的temp重新pop回去，这时候又有两种情况：\n\n其一是str栈top是**正常的字符** ，也就是像**2[3a[a]]**这种情况，那么只需要把top取出来和temp进行连接，把top pop出来后，再把连接后的字符串push回去即可；\n\n其二是str栈top是 **[**，也就是像2[3[a]]这种情况，这时候我们要是按照第一种情况那样操作，那肯定是不行，把**[** 给连接到temp里去了。这时候我们直接push回去即可。\n\n\n\n还有就是因为存在**[]**套**[]**的情况，stack需要string类型，不能用char。\n\n\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    //判断一个字符串是否全部为数字(主要就是判断一个而已)\n    bool isNumber(string str){\n        for(char s:str){\n            if(!isdigit(s)) return false;\n        }\n        return true;\n    }\n    string decodeString(string s) {\n        stack<int> num;\n\t    stack<string> str;\n\t    string res;\n\t    int i = 0;\n\t    while (i < s.length()) {\n\t\t    string istr;         //转化为字符串进行处理\n\t\t    istr.push_back(s[i]);\n\t\t    if (str.empty() && !isNumber(istr) && istr != \"[\") {      //处理外面的字符\n\t\t\t    res += istr;\n\t\t\t    i++;\n\t\t\t    continue;\n\t\t    }\n\t\t    if (s[i] > '0'&&s[i] <= '9') {      //数字压入数字栈\n\t\t\t    int temp = s[i] - 48;\n\t\t\t    while (s[i + 1] >= '0'&&s[i + 1] <= '9') {\n\t\t\t\t    temp = temp * 10 + s[++i] - 48;\n\t\t\t    }\n\t\t\t    i++;\n\t\t\t    num.push(temp);\n\t\t\t    continue;\n\t\t    }\n\t\t    if (istr == \"[\" || isalpha(s[i])) {    // [ 或字母压入str栈\n\t\t\t    str.push(istr);\n\t\t\t    i++;\n\t\t\t    continue;\n\t\t    }\n\t\t    if (istr == \"]\") {\n\t\t\t    int weight = num.top();\n\t\t\t    num.pop();\n\t\t\t    string temp = \"\";\n\t\t\t    while (str.top() != \"[\") {\n\t\t\t\t    temp = str.top() + temp;\n\t\t\t\t    str.pop();\n\t\t\t    }\n\t\t\t    str.pop();          //把 [ pop出去\n\t\t\t    string temp1;\n\t\t\t    while (weight--) {\n\t\t\t\t    temp1 += temp;                   //不直接存进res是因为有[]套[]的情况\n\t\t\t    }\n\t\t\t    if (!str.empty()) {                  //如果str栈非空，说明存在[]套[]的情况，要把temp重新存进栈\n                    if(str.top() != \"[\"){            //会不会有3[2[a]]的情况，如果有就要改，提交一下试试\n\t\t\t\t        temp1 = str.top() + temp1;\n\t\t\t\t        str.pop();\n\t\t\t\t        str.push(temp1);          \n                    }\n                    else str.push(temp1);\n\t\t\t    }\n\t\t\t    else res += temp1;\n\t\t\t    i++;\n\t\t    }\n\t    }\n\t    return res;\n    }\n};\n```\n\n\n\n**复杂度分析**\n\n时间复杂度：稍稍大于O(n)\n\n空间复杂度：O(n)，两个stack\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995407914","body":"### 思路\n\n两个栈实现列表，不考虑任何进阶的思想，就是两个栈之间互相倒（dao，第三声）。\n\n### 代码\n\n```c++\nclass MyQueue {\npublic:\n    stack<int> queue1;  //主栈\n    stack<int> queue2;  //辅栈\n    MyQueue() {\n    }\n    \n    void push(int x) {\n        queue1.push(x);\n    }\n    \n    int pop() {\n        while(!queue1.empty()){\n            queue2.push(queue1.top());\n            queue1.pop();\n        }\n        int temp = queue2.top();\n        queue2.pop();\n        while(!queue2.empty()){\n            queue1.push(queue2.top());\n            queue2.pop();\n        }\n        return temp;\n    }\n    \n    int peek() {\n        while(!queue1.empty()){     \n            queue2.push(queue1.top());\n            queue1.pop();\n        }\n        int temp = queue2.top();\n        while(!queue2.empty()){\n            queue1.push(queue2.top());\n            queue2.pop();\n        }\n        return temp;\n    }\n    \n    bool empty() {\n        if(queue1.empty() && queue2.empty()) return true;\n        return false;\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n**复杂度分析**\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"devil-lin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991836687","body":"```\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n\n        int n = num.size();\n        for(int i = n - 1; i >= 0 || k; i --)\n        {\n            if(i >= 0)\n                k += num[i];\n            res.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(res.begin(), res.end());\n\n        return res;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992604905","body":"```\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992689479","body":"链表或者数组都可以\n没啥好说的，两三分钟就完了\n\n```\nclass CustomStack {\npublic:\n    vector <int> v;\n    int top, maxsize;\n\n    CustomStack(int maxSize) {\n        v.resize(maxSize);\n        maxsize = maxSize;\n        top = -1;\n    }\n    \n    void push(int x) {\n        if(top == maxsize - 1) return;\n        v[++ top] = x;\n    }\n    \n    int pop() {\n        if(top == -1) return -1;\n        top --;\n        return v[top + 1];\n    }\n    \n    void increment(int k, int val) {\n        int lim = min(k, top + 1);\n        for(int i = 0; i < lim; i ++) v[i] += val;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994256805","body":"栈就完了\n```\nclass Solution {\npublic:\n    string getDigits(string &s, size_t &ptr) {\n        string ret = \"\";\n        while (isdigit(s[ptr])) {\n            ret.push_back(s[ptr++]);\n        }\n        return ret;\n    }\n\n    string getString(vector <string> &v) {\n        string ret;\n        for (const auto &s: v) {\n            ret += s;\n        }\n        return ret;\n    }\n\n    string decodeString(string s) {\n        vector <string> stk;\n        size_t ptr = 0;\n\n        while (ptr < s.size()) {\n            char cur = s[ptr];\n            if (isdigit(cur)) {\n                string digits = getDigits(s, ptr);\n                stk.push_back(digits);\n            } else if (isalpha(cur) || cur == '[') {\n                stk.push_back(string(1, s[ptr++])); \n            } else {\n                ++ptr;\n                vector <string> sub;\n                while (stk.back() != \"[\") {\n                    sub.push_back(stk.back());\n                    stk.pop_back();\n                }\n                reverse(sub.begin(), sub.end());\n                stk.pop_back();\n                int repTime = stoi(stk.back()); \n                stk.pop_back();\n                string t, o = getString(sub);\n                while (repTime--) t += o; \n                stk.push_back(t);\n            }\n        }\n\n        return getString(stk);\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"spacker-343":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991838535","body":"### 思路\r\n\r\n首先得想法是把两个数加起来，再依次取出个位，添加进结果中，但是这样会溢出。\r\n于是选择从后往前遍历数组，末尾数字相加后添加进结果集中，同时判断一下有没有进位。\r\n最后还要看看 k 和进位等于 0 没有，如果没有还要继续添加进结果集中。\r\n添加数字时，要保证顺序，所以每次插入在数组开头，也就是 0 的索引位置，使用 LinkedList 而不是 ArrayList 会提升插入的性能\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res=new LinkedList<>();\r\n        int carry=0;\r\n        for(int i=num.length-1; i>=0; i--){\r\n            int sum=0;\r\n            sum=num[i]+k%10+carry;\r\n            k/=10;\r\n            carry=sum/10 > 0 ? 1:0;\r\n            sum%=10;\r\n            res.add(0, sum);\r\n        }\r\n        while(k!=0){\r\n            int sum=k%10+carry;\r\n            carry=sum/10 > 0 ? 1:0;\r\n            sum%=10;\r\n            k/=10;\r\n            res.add(0, sum);\r\n        }\r\n        if(carry!=0){\r\n            res.add(0, 1);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992038217","body":"### 思路\r\n第一眼感觉用双指针能做，找到第一个 c 字符出现位置和第二个 c 字符出现位置，然后分别求出到当前 i 的距离，再进行比较，如果没出现第二个 c 字符（也就是 right2 == s.length() ），那么就直接取第一个 c 字符到当前 i 的距离就好。\r\n\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res=new int[s.length()];\r\n        int right=0;\r\n        int right2=1;\r\n        while(right<s.length() && s.charAt(right)!=c){\r\n            right++;\r\n        }\r\n        while(right2<s.length()&&s.charAt(right2)!=c){\r\n            right2++;\r\n        }\r\n        for(int i=0; i<res.length; i++){\r\n            // 如果索引i大于第二个c字符所在位置则更新right和right2\r\n            if(i>right2){\r\n                if(right2!=s.length()){\r\n                    right=right2;\r\n                    right2=right+1;\r\n                    while(right2<s.length()&&s.charAt(right2)!=c){\r\n                        right2++;\r\n                    }\r\n                }\r\n            }\r\n            if(right2==s.length()){\r\n                // 说明此时只有right指针在c字符上\r\n                res[i]=Math.abs(right-i);\r\n            }else{\r\n                res[i]=Math.min(Math.abs(right-i), right2-i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度：O(N)\r\n空间复杂度：O(1)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993121333","body":"### 思路\r\n由于栈容量大小固定，因此考虑使用数组来模拟，并用一个index指针指向栈顶元素\r\n### 代码\r\n```java\r\nclass CustomStack {\r\n\r\n    int[] customStack;\r\n    int index;\r\n\r\n    public CustomStack(int maxSize) {\r\n        customStack=new int[maxSize];\r\n        index=-1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(index==customStack.length-1){\r\n            return;\r\n        }\r\n        customStack[++index]=x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if(index==-1){\r\n            return -1;\r\n        }\r\n        int res=customStack[index];\r\n        customStack[index--]=0;\r\n        return res;\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int inc=Math.min(index+1, k);\r\n        for(int i=0; i<inc; i++){\r\n            customStack[i]+=val;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 复杂度\r\n时间复杂度: O(1) push pop O(min(index+1, k)) increment\r\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994219771","body":"### 思路\r\n使用一个栈存储除了 ']' 的字符，遇到 ']' 就开始往结果中添加字符，可能遇到 aabbc 这种没带 ']' 的情况，所以最后还得判断一下栈是否为空。\r\n### 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        StringBuilder res=new StringBuilder();\r\n        Stack<Character> stack=new Stack<>(); \r\n        for(int i=0; i<s.length();  i++){\r\n            char c=s.charAt(i);\r\n            if(c==']'){\r\n                // 转字符\r\n                StringBuilder temp=new StringBuilder();\r\n                char ch=stack.pop();\r\n                while(ch>='a' && ch<='z'){\r\n                    temp.append(ch);\r\n                    ch=stack.pop();\r\n                }\r\n                temp.reverse();\r\n                // 转数字\r\n                StringBuilder sb=new StringBuilder();\r\n                if(!stack.isEmpty()){\r\n                    char cnum=stack.pop();\r\n                    while(cnum>='0' && cnum<='9'){\r\n                        sb.append(cnum);\r\n                        if(stack.isEmpty()){\r\n                            break;\r\n                        }\r\n                        cnum=stack.pop();\r\n                        if(cnum>='a' && cnum<='z'||cnum=='['){\r\n                            stack.push(cnum);\r\n                        }\r\n                    }\r\n                }\r\n                sb.reverse();\r\n\r\n                int num=Integer.valueOf(sb.toString());\r\n                for(int j=0; j<num; j++){\r\n                    if(!stack.isEmpty()){\r\n                        for(char m:temp.toString().toCharArray()){\r\n                            stack.push(m);\r\n                        }\r\n                    }else {\r\n                        // 避免重复入栈\r\n                        res.append(temp);\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            stack.push(c);\r\n        }\r\n        // 检查栈是否为空\r\n        if(!stack.isEmpty()){\r\n            StringBuilder temp=new StringBuilder();\r\n            char ch=stack.pop();\r\n            while(ch>='a' && ch<='z'){\r\n                temp.append(ch);\r\n                if(stack.isEmpty()){\r\n                    break;\r\n                }\r\n                ch=stack.pop();\r\n            }\r\n            temp.reverse();\r\n            res.append(temp);\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n### 复杂度\r\n时间复杂度：O(n) 每个字符会出栈，入栈一次\r\n空间复杂度：O(n) 所有字符入栈的情况","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995395407","body":"### 思路\n用两个栈，peek和pop操作，若out栈不为空，则直接从out栈中取\n\n### 代码\n```java\nclass MyQueue {\n\n    Deque<Integer> stackIn;\n    Deque<Integer> stackOut;\n\n    public MyQueue() {\n        stackIn=new LinkedList<>();\n        stackOut=new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {\n        // 如果出栈为空，则把入栈的所有元素放入到出栈中\n        if(stackOut.isEmpty()){\n            while(!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n        }\n        // 否则直接返回出栈栈顶元素\n        return stackOut.pop();\n    }\n    \n    public int peek() {\n        if(stackOut.isEmpty()){\n            while(!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n        }\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        return stackIn.isEmpty()&&stackOut.isEmpty();\n    }\n}\n```\n### 复杂度\n时间复杂度：O(1)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"de0002ou":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991842436","body":"### 思路\n\n把数字转换成数组，对应位相加传入新数组，考虑进位情况\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        list_k = []\n        while k > 0:\n            temp = k%10\n            list_k.insert(0,temp)\n            k-=temp\n            k/=10\n        res = []\n        add_up = 0\n        while list_k and num:\n            i = list_k.pop()+num.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while list_k and not num:\n            i = list_k.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while num and not list_k:\n            i = num.pop()\n            if i+add_up< 10:\n                res.insert(0,int(i+add_up))\n                add_up = 0\n            else:\n                res.insert(0,int(i-10+add_up))\n                add_up = 1\n        while not num and not list_k:\n            if add_up == 1:\n                res.insert(0,1)\n            return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度，需要遍历整个数组。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992191538","body":"### 思路\n\n从左到右遍历然后从右到左遍历，取距离的最小值\n\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pre = float('-inf')\n        res = []\n        for i,number in enumerate(s):\n            if number == c:\n                pre = i\n            res.append(i - pre)\n        pre = float('inf')\n        for j in range(len(s)-1, -1, -1):\n            if s[j] == c:\n                pre = j\n            res[j] = min(res[j], pre - j)\n        return res\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993216818","body":"### 思路\n\n队列实现，按要求来\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass CustomStack:\n    def __init__(self, maxSize: int):\n\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack)< self.maxSize:\n            self.stack.append(x)\n        else:\n            pass\n\n    def pop(self) -> int:\n        if len(self.stack) == 0:\n            return -1\n        else:\n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        x = min(k,len(self.stack))\n        for i in range(x):\n            self.stack[i] = self.stack[i] + val\n```\n\n**复杂度分析**\n时间复杂度：push和pop操作的渐进时间复杂度为O(1)O(1), inc操作的渐进时间复杂度为O(k)O(k)\n空间复杂度：用到了一个maxSize的数组作为辅助空间，渐进空间复杂度为O(maxSize)O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994753055","body":"### 思路\n\n两个栈\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, num = [], \"\", 0\n        for c in s:\n            if '0' <= c <= '9':\n                num = num * 10 + int(c)\n            elif c == '[':\n                stack.append((num, res))\n                res, num = \"\", 0\n            elif c == ']':\n                cur_num, last_res = stack.pop()\n                res = last_res + cur_num * res\n            else:\n                res += c\n        return res\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995424872","body":"### 思路\n\n两个栈\n### 代码\n\n\n```python（此处换成你的语言，比如js，py 等）\nclass MyQueue:\n\n    def __init__(self):\n        self.stack_in = []\n        self.stack_out = []\n\n\n    def push(self, x: int) -> None:\n        self.stack_in.append(x)\n\n\n    def pop(self) -> int:\n        if self.empty():\n            return None\n        if self.stack_out:\n            return self.stack_out.pop()\n        else:\n            for i in range(len(self.stack_in)):\n                self.stack_out.append(self.stack_in.pop())\n            return self.stack_out.pop()\n\n\n    def peek(self) -> int:\n        ans = self.pop()\n        self.stack_out.append(ans)\n        return ans\n\n    def empty(self) -> bool:\n        return not (self.stack_in or self.stack_out)\n\n\n\n# Your MyQueue object will be instantiated and called as such:\n# obj = MyQueue()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.peek()\n# param_4 = obj.empty()\n\n\n```\n\n**复杂度分析**\n时间复杂度：O(n)\n空间复杂度：O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"judyzhou95":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991842636","body":"### 思路\n\n先把k与个位相加。从低到高逐位检查是否大于等于十。如果是，则算出carry on (n // 10) 并加入到前一位，以及当前位保留的值 (n %= 10)。到了最高位如果还大于等于10 则需要在前面手动增加位数，并继续进行计算carry on 和保留值。\n\n### 代码\n\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num[-1] += k\n        \n        i = len(num) - 1\n        \n        while i > 0 and num[i] > 9:\n            num[i-1] += num[i] // 10\n            num[i] %= 10\n            i -= 1\n            \n        while num[0] > 9:\n            num = [num[0] // 10] + num\n            num[1] = num[1] % 10\n            \n        return num\n        \n ```\n### 复杂度\nTime Complexity: O(len(num)) \n\nSpace Complexity: O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992254880","body":"### 思路\n\n从左往右、从右往左遍历数组两遍，分别计算出当前位置距离左边target character（如果存在）的最短的距离，以及右边target character的最短距离，并取较小的那个存入答案。计算时可以加入dp思想。\n\n\n### 代码\n\n```python\n\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        n = len(s)\n        \n        res = [0 if cha == c else n for cha in s]\n        for i in range(1, n):\n            res[i] = min(res[i], res[i-1] + 1)\n            \n        for i in range(n-2, -1, -1):\n            res[i] = min(res[i], res[i+1]+1)\n            \n        return res\n```\n\n### 复杂度\nTime: O(n)\n\nSpace: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993313421","body":"### 思路\nstack是有限制的array 可以push, pop操作可以直接用array的function来做。\n\n### 代码\n\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.maxSize = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n    def increment(self, k: int, val: int) -> None:        \n        for i in range(min(len(self.stack), k)):\n            self.stack[i] += val\n\n```\n\n### 复杂度\n\npush, pop的Time Complexity 都是 O(1)\n\nincrement 的Time Complexity是O(k)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994502435","body":"### 思路\n看见类似括号的对称关系要想到用stack。\n算法需要遍历整个字符串，这里的括号有点类似四则运算的括号，内层的先处理，外层的后处理。遍历时遇见数字就在当前数字num的基础上num * 10+新数字，遇见字母就在stack最后一位加上新字母（因为字母都连在一起，而且遇见开括号时已经向stack推了空str “”，所以现在stack最后一位一定是str），遇见开括号时将空字符串“”push进stack，遇见闭括号的时候就把stack的后三位都pop出来，进行一次运算。后三位是：[......., str2, num, str1] ,把他们合并成：str2 + num * str1，作为新的字符串放在stack末尾。 之后就把stack里最后剩下的都join在一起就是答案。\n\n### 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        it = 0\n        num = 0\n        stack = [\"\"]\n        \n        while it < len(s):\n            \n            if s[it].isdigit():\n                num = num*10 + int(s[it])\n            elif s[it] == \"[\":\n                stack.append(num)\n                num = 0\n                stack.append(\"\")\n            elif s[it] == \"]\":\n                str1 = stack.pop()\n                rep = stack.pop()\n                str2 = stack.pop()\n                stack.append(str2 + str1*rep)\n            else:\n                stack[-1] += s[it]\n                \n            it += 1\n            \n        return \"\".join(stack)\n```\n### 复杂度\nTime Complexity: O(n)\nSpace Complexity: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995286810","body":"### 思路\n把一个stack中的元素转移到另一个stack把栈头转成栈尾，等同于逆序。这个class中有一个input stack和output stack。input stack负责存储输入，output stack负责把元素按照queue的方式输出。O(1)时间复杂度的秘诀就是不要重复来回倒，每个元素只转一次。输出时检查output是否为空，output stack若不为空则直接输出，如果空了就再把input全部倒进去。\n\n### 代码\n\n```python\n\nclass MyQueue:\n\n    def __init__(self):\n        self.input = []\n        self.output = []\n\n    def push(self, x: int) -> None:\n        self.input.append(x)\n        \n    def pop(self) -> int:\n        self.move()           \n        return self.output.pop()\n\n    def peek(self) -> int:\n        self.move()\n        return self.output[-1]\n\n    def empty(self) -> bool:\n        return len(self.input) == 0 and len(self.output) == 0\n\n    def move(self):\n        if not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n        \n```\n\n### 复杂度\nTime: O(1)\nSpace: O(n)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blankpathfind":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843440","body":"### 思路\n\nv1\n笨方法，先把list转成字符串，字符串转成int，相加之后结果转字符串，字符串拆开成list，害\n\n### 代码\n\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        num = [str(i) for i in num]\n        num = \"\".join(num)\n        num = int(num)\n        num = str(num+k)\n        num = [int(i) for i in num]\n        return num\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992597115","body":"### 思路\n\n开始想的是遍历，看两边最近的e,后来改成生成一个list存放e所在的index然后再遍历一遍list看最近的abs()\n\n### 代码\n\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        inlist = []\n        outlist = []\n        for i,s_i in enumerate(s):\n            if s_i == c:\n                inlist.append(i)\n        for i in range(len(s)):\n            tmp = [abs(l-i) for l in inlist]\n            outlist.append(min(tmp))\n        return outlist\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(2N)，其中 N 为数组长度。\n- 空间复杂度：O(2N)，空间复杂度较高","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993555623","body":"### 思路\r\n\r\n用list作为栈\r\n\r\n### 代码\r\n\r\n\r\n```\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.max_size = maxSize\r\n        self.stack = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) > 0:\r\n            tmp = self.stack[-1]\r\n            self.stack = self.stack[:-1]\r\n            return tmp\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if len(self.stack) > 0:\r\n            if len(self.stack) < k:\r\n                self.stack = [(i+val) for i in self.stack]\r\n            else:\r\n                for i,s in enumerate(self.stack):\r\n                    if i < k:\r\n                        self.stack[i] = s + val\r\n                    else:\r\n                        break\r\n\r\n\r\n\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994928642","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n\n        for c in s:\n            if c == '[': # 将[之前的multi和字符存入stack\n                stack.append([res, multi])\n                res, multi = \"\", 0\n            elif c == ']':\n                tmp, cur_multi = stack.pop()\n                res = tmp + res * cur_multi\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)\n            else:  # 字符串\n                res += c\n        return res\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995843825","body":"### 思路\r\npython 用list处理比较简单\r\n\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.deque = []\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        self.deque.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.deque) == 0:\r\n            return \r\n        tmp = self.deque[0]\r\n        self.deque = self.deque[1:]\r\n        return tmp\r\n\r\n\r\n    def peek(self) -> int:\r\n        return self.deque[0]\r\n\r\n    def empty(self) -> bool:\r\n        if len(self.deque) == 0:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n```\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tangjy149":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991843767","body":"### 思路\n我是从末位数的方面来考虑，因为需要进行整数的加法，那么k+arr[len-1]%10的值一定是最终和的末位数，那么便从数组的最后一位开始遍历，与k进行相加并取模放入ans数组（因为是从末尾开始，因此需要insert插入到ans的首位）\n\n### Code\n```c++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> ans;\n        int len = num.size()-1;\n        for(int i=len;i>=0;i--){\n            k=k+num[i];\n            ans.insert(ans.begin(),k%10);\n            k/=10;\n        }\n        // 此处的处理是为了防止k过大的情况\n        if(k){\n            while(k>9){\n                ans.insert(ans.begin(),k%10);\n                k/=10;\n            }\n            ans.insert(ans.begin(),k);\n        }\n        return ans;\n    }\n};\n```\n\n### 复杂度分析\n时间复杂度：O(n)（主要花销在遍历)  \n\n空间复杂度：O(n)(开辟了新的数组用于存储结果)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993110188","body":"### 思路\n用数组进行模拟即可，c++的vector本身就有push_back和pop_back的使用方式，但该题需注意，需要对添加的数进行计数，因为本身数组的大小已经被限制了maxsize，因此不能通过数组的size进行判断数据（应该），所以我添加了count进行计算当前数组已经有多少数据，来对pop和push情况进行判断\n\n### 代码\n```c++\nclass CustomStack {\npublic:\n    int count;// 计数\n    vector<int> helper;\n    CustomStack(int maxSize) {\n        helper.resize(maxSize);\n        count=0;\n    }\n    \n    void push(int x) {\n        if(count<helper.size()){\n            helper[count]=x;\n            count++;\n        }\n    }\n    \n    int pop() {\n        if(--count<0){\n            count=0;\n            return -1;\n        }\n        return helper[count];\n    }\n    \n    void increment(int k, int val) {\n        for(int i=0;i<min(k,count);i++){\n            helper[i]+=val;\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n```\n\n### 复杂度\n时间复杂度：push=O(1) pop=O(1) increment=O(n)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994691375","body":"### 思路\n每个字符串可以归结为两类数据，数字和字符，其中根据格式要求，数字会作用于后面[]的字符进行重复。此时因为存在多重[]的情况，可以考虑使用栈的特性，压入栈后弹出，这样可以满足解码的处理顺序（印象中处理多项式加减也是用栈的形式，因为存在一定情况需要提前计算，而非一定是从左到右）  \n综上，设置两个栈，分别存储数字和字符，遇到[，则将当前暂存的数和字符压入栈，遇到]则进行弹出处理，进行字符的循环，最后进行拼接\n\n### 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n        stack<string> alpha;\n        stack<int> num;\n        int flag=0,temp;// temp存储数字栈弹出的数字\n        string str=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]>='0' && s[i]<='9'){\n                flag=flag*10+s[i]-'0';\n                cout<<flag<<endl;\n            }else if(s[i]=='['){\n                num.push(flag);\n                alpha.push(str);\n                str=\"\";\n                flag=0;\n            }else if((s[i]>='a'&&s[i]<='z')||(s[i]>='A'&&s[i]<='Z')){\n                str+=s[i];\n            }else if(s[i]==']'){\n                temp=num.top();\n                num.pop();\n                cout<<str<<endl;\n                for(int j=0;j<temp;j++){\n                    alpha.top()+=str;\n                }\n                str=alpha.top();\n                alpha.pop();\n            }\n        }\n        return str;\n    }\n};\n```\n\n### 复杂度\n时间复杂度：O(N)  \n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995734933","body":"### 思路\n通过栈来实现队列，其实也就是从先进后出，改为先进先出。那么使用一个栈是完成不了的，需要两个栈来完成顺序的变化。s1负责接收输入的数据，而s2则负责输出，当需要pop操作的时候，在s2无数据时，将s1中的数据导入s2中，两次先进后出其实也就恢复了正常顺序，s2进行弹出数据即可，其他操作类似。\n\n### 代码\n```c++\nclass MyQueue {\n    stack<int> s1;\n    stack<int> s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        while(s2.empty()){\n            while(!s1.empty()){\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int temp=s2.top();\n        s2.pop();\n        return temp;\n    }\n    \n    int peek() {\n        int temp=this->pop();\n        s2.push(temp);\n        return temp;\n    }\n    \n    bool empty() {\n        return s1.empty()&&s2.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n### 复杂度\n时间复杂度：O(n) 最大开销源于颠倒s1中数据的操作  \n空间复杂度：O(n) 两个栈的使用","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lannyx":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991846050","body":"### 思路\r\n\r\niterate the array and integer from right to left, sum up and store in the ArrayList.\r\nuse a carry variable to store the tens.\r\nreverse the ArrayList in the end.\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int len = num.length - 1;\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n\r\n        while(len >= 0 || k != 0){\r\n            int x = len < 0 ? 0 : num[len];\r\n            int y = k == 0 ? 0 : k % 10;\r\n\r\n            int sum = carry + x + y;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n            \r\n            len--;\r\n            k = k / 10;\r\n        }\r\n\r\n        if (carry > 0) res.add(1);\r\n\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992149394","body":"### 思路\r\n\r\n从左到右，然后从右到左遍历两遍\r\n找到C并记录它和S[i]的距离，最后取最小值\r\n\r\n### 代码\r\n\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()]; // create new array to store answer\r\n        int dummy = Integer.MIN_VALUE/2; // initiate a variable as the min value to store char c\r\n                                         // /2 to avoid index out of bound\r\n\r\n        for(int i = 0; i < s.length(); i++){ // from left to right\r\n            if(s.charAt(i) == c) dummy = i;  // find first c, store it and calculate the next number \r\n            res[i] = i - dummy;\r\n        }\r\n\r\n        dummy = Integer.MAX_VALUE;            // from right to left\r\n        for(int i = s.length() - 1; i >= 0; i--){ \r\n            if(s.charAt(i) == c) dummy = i;\r\n            res[i] = Math.min(res[i], dummy - i);  // compare to find the min and store it\r\n        }\r\n        return res;\r\n\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993170998","body":"### 思路\n\n用数组模拟栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x) {\n        if(top < stack.length - 1){\n            top++;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop() {\n        if(top == -1){\n            return -1;\n        }else{\n            top--;\n            return stack[top + 1];\n        }\n\n    }\n    \n    public void increment(int k, int val) {\n        int limit = Math.min(k, top+1);\n        for(int i = 0; i < limit; i++){\n            stack[i] = stack[i] + val;\n        }\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(k)\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994328575","body":"### 代码\r\n\r\n``` Python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                rStr = ''\r\n                rCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    rStr = stack.pop() + rStr\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    rCount = stack.pop() + rCount\r\n                stack.append(rStr * int(rCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n\r\n\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995439328","body":"### 思路\r\nuse 2 stacks, one for push, another for pop and seek.\r\n\r\n### 代码\r\n\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n    public MyQueue() {\r\n\r\n    }\r\n    \r\n    public void push(int x) {\r\n        while(!s2.isEmpty()){\r\n            s1.push(s2.pop());\r\n        }\r\n        s1.push(x);\r\n\r\n    }\r\n    \r\n    public int pop() {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        while(!s1.isEmpty()){\r\n            s2.push(s1.pop());\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty()&&s2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)\r\n- 空间复杂度：O(N)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"nweass":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991846310","body":"## 思路\n\n考虑到需要进位，需要的位数可能发生变化，新增一个List储存结果\n\n双指针遍历两个整数，使用一个add记录进位\n\n类似题目有大数加减法\n\n## 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int i = num.length - 1;\n        int j = 0;\n        int add = 0;\n        ArrayList<Integer> resList = new ArrayList<>();\n        while(i >= 0 || k > 0 ||add != 0){\n            int x = i < 0 ? 0 : num[i];\n            int y = k == 0 ? 0 : k % 10;  \n\n            int result = x + y + add;\n            add = result /10;\n            resList.add(result % 10);\n            i--;\n            k = k / 10;\n        }\n        Collections.reverse(resList);\n        return resList;\n    }\n}\n```\n\n## 复杂度分析\n\n空间：使用了一个新建List保存结果，List大小为num[]或k的位数 O(n)\n\n时间：遍历一遍num[] 长度n或k的位数m中最大的一个，O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yugaoh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991848642","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int carry  = 0;//进位\n        int i = num.size() - 1;\n        vector<int> vec;\n\n        while(i >= 0 || k != 0)\n        {\n            int n1 = i >= 0 ? num[i] : 0;\n            int n2 = k >= 0 ? k % 10 : 0;\n\n            int value = n1 + n2 + carry;\n            vec.push_back(value % 10);\n            carry = value / 10;\n\n            --i;\n            k = k / 10;\n        }\n\n        if(carry != 0)\n            vec.push_back(carry);\n        \n        reverse(vec.begin(), vec.end());\n\n        return vec;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992079459","body":"#思路\n\n先找到字符串中的第一个char c，令right指向这个位置，则从数组开始至第一个c的最近距离都是abs(i-right)\n然后令left指向right，则left到right之间的距离都是abs(j - left)和abs(j - right)的最小值\n最后是最后一个char c右边的部分，left指向这个最后的char c，则右边部分的最短距离都是abs(j - left)\n\n#代码\n\n```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> vec;\n        int left = 0;\n        int right = 0;\n\n        for(int i = 0; i < len; i++)\n        {\n            if(c == s[i])\n            {\n                right = i;\n                break;\n            } \n        }\n\n        for(int j = 0; j < right; j++)\n        {\n            vec.push_back(abs(j - right));  \n        }\n        left = right;\n\n        for(int i = left; i < len; i++)\n        {\n            if(c == s[i])\n            {\n                right = i;\n                for(int j = left; j < right; j++)\n                {\n                    int tmp = abs(j - left) < abs(j - right) ? abs(j - left) : abs(j - right);\n                    vec.push_back(tmp);\n                }\n                left = right;   \n            }  \n        }\n\n        if(left <= len - 1)\n        {\n            for(int i =left; i < len; i++)\n            {\n                vec.push_back(abs(i - left));\n            }\n        }\n\n        return vec;\n    }\n};\n```\n\n#复杂度\n\n时间复杂度O(n2)\n\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993340696","body":"#用静态数组实现stack\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) \n    :_top(-1)\n    ,_size(maxSize)\n    ,_data(new int[_size]())\n    {\n        \n    }\n    \n    void push(int x) {\n        if( !full() )\n        {\n            _data[++_top] = x;\n        }\n    }\n    \n    int pop() {\n        if( !empty() )\n        {\n            return _data[_top--];\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int count = min(k, _top+1);\n        for(int i = 0; i < count; i++)\n        {\n            _data[i] += val;\n        }\n    }\n\n    bool empty()\n    {\n        return _top == -1;\n    }\n\n    bool full()\n    {\n        return (_top == _size - 1);\n    }\n\nprivate:\n    int _top;\n    int _size;\n    int *_data;\n};\n\n#用动态数组实现stack\nclass CustomStack {\npublic:\n    CustomStack(int maxSize)\n\t{\n\t\tvec.resize(maxSize);\n\t\ttop = -1;\n\t}\n\t\n\tvoid push(int x) \n\t{\n\t\tif(top != vec.size() - 1)\n\t\t{\n            ++top;\n\t\t\tvec[top] = x;\n\t\t}\n\t}\n\t\n\tint pop()\n\t{\n\t\tif(top != -1)\n\t\t{\n\t\t\treturn vec[top--];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tvoid increment(int k, int val)\n\t{\n\t\tint count = min(k, top + 1);\n\t\tfor(int i = 0; i < count; i++)\n\t\t{\n\t\t\tvec[i] += val;\n\t\t}\n\t}\n\t\nprivate:\n\tvector<int> vec;\n\tint top;\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994680125","body":"数字存放在数字栈，字符串存放在字符串栈，遇到右括号时候弹出一个数字栈，字母栈弹到左括号为止。\n\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) { \n        stack<int> num;\n        stack<string> strs;\n        int value = 0;\n\n        for(int i = 0; i < s.size(); ++i)\n        {\n            if(s[i] >= '0' && s[i] <= '9')\n            {\n                value = 0;\n                while(isdigit(s[i]))\n                {\n                    //防止连续数字\n                    value = value * 10 + s[i] - '0';\n                    i++;\n                }\n                num.push(value);\n\n                //当不满足while条件时，此时i指向的不是数字，要回退\n                //一步，因为for循环里有自增\n                --i;\n            }\n\n            else if(s[i] == '[' || s[i] >= 'a' && s[i] <= 'z' || s[i] >= 'A' && s[i] <= 'Z')\n            {\n                string tmp(1, s[i]);\n                strs.push(tmp);\n            }\n\n            else\n            {\n                int times = num.top();//遇到']'，弹出数字栈顶元素\n                num.pop();\n\n                string str = \"\";\n                while(strs.top() != \"[\")\n                {\n                    str = strs.top() + str;\n                    strs.pop();\n                }\n                strs.pop();\n\n                string tmp;\n                for(int i = 0; i < times; ++i)\n                {\n                    tmp += str;\n                }\n                strs.push(tmp);\n                //每结束一对[]的解码，就将其压入栈中，最后按顺序拼接即可\n            }\n        }\n\n        //当for循环执行完毕时，所有的字符串都存在strs栈里，按顺序拼接起来即可\n        string res;\n        while(strs.size() != 0)\n        {\n            res = strs.top() + res;\n            strs.pop();\n        }\n        return res;\n    }\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dahaiyidi":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991849235","body":"## Question\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/add-to-array-form-of-integer\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n\n### Note\n\n- 思路不难：将数字从最后一位开始计算加法\n- 注意进位\n- 注意有一方先遍历完毕的情况\n\n### Complexity\n\n- 时间O：max(n, logk)\n- 空间O：1 (返回值不计算在内)\n\n## Python\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        res = []\n        \n        for i in  range(len(num) - 1, -1, -1):\n            add = num[i] + k % 10  # k包含进位信息\n            k = k // 10\n\n            if add >= 10:\n                add -=10\n                k += 1 # 将进位1加到k上\n\n            res.append(add % 10)\n\n        # 若k不是零\n        while k != 0:\n            res.append(k % 10)\n            k = k // 10\n        \n        return res[::-1]\n```\n\n## C++\n\n```C++\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> res;\n        for(int i = num.size() - 1; i >= 0; i--){\n            int add = num[i] + k % 10;\n            k /= 10;\n            if (add >= 10){\n                k++;\n                add = add - 10;\n            }\n\n            res.push_back(add % 10);\n        }\n        while (k != 0){\n            res.push_back(k % 10);\n            k /= 10;\n        }\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992490670","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Question \r\n\r\n#### [989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\r\n\r\n对于非负整数 `X` 而言，*`X`* 的*数组形式*是每位数字按从左到右的顺序形成的数组。例如，如果 `X = 1231`，那么其数组形式为 `[1,2,3,1]`。\r\n\r\n给定非负整数 `X` 的数组形式 `A`，返回整数 `X+K` 的数组形式\r\n\r\n### Note\r\n\r\n- 思路不难，重要的是不要被题目吓到\r\n- 从left到right扫一遍，从right 到left扫一遍，两者取最小值\r\n\r\n### Complexity\r\n\r\n- 时间O：N\r\n- 空间O：1\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        num_s = len(s)\r\n        res = [-1] * num_s  # res 最终的值必<num_s， 也可以使用Integer.MAX_VALUE / 2\r\n\r\n        # 从left到right扫一遍，从right 到left扫一遍，两者取最小值\r\n        \r\n        n = num_s\r\n        for i in range(num_s):\r\n            if s[i] == c:\r\n                n = 0\r\n            res[i] = n\r\n            n += 1\r\n        \r\n        n = num_s\r\n        for i in range(num_s -1, -1, -1):\r\n            if s[i] == c:\r\n                n = 0\r\n            res[i] = min(res[i], n)\r\n            n += 1\r\n        \r\n        return res\r\n\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int num_s = s.size();\r\n        vector<int> res(num_s, num_s);\r\n\r\n        int n = num_s;\r\n        for(int i = 0; i < num_s; i++){\r\n            if(s[i] == c){\r\n                n = 0;\r\n            }\r\n            res[i] = n;\r\n            n++;\r\n        }\r\n\r\n        n = num_s;\r\n        for(int i = num_s - 1; i >= 0; i--){\r\n            if(s[i] == c){\r\n                n = 0;\r\n            }\r\n            res[i] = min(res[i], n);\r\n            n++;\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993622129","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Question \r\n\r\n#### [1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\r\n\r\n难度中等62\r\n\r\n请你设计一个支持下述操作的栈。\r\n\r\n实现自定义栈类 `CustomStack` ：\r\n\r\n- `CustomStack(int maxSize)`：用 `maxSize` 初始化对象，`maxSize` 是栈中最多能容纳的元素数量，栈在增长到 `maxSize` 之后则不支持 `push` 操作。\r\n- `void push(int x)`：如果栈还未增长到 `maxSize` ，就将 `x` 添加到栈顶。\r\n- `int pop()`：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 **-1** 。\r\n- `void inc(int k, int val)`：栈底的 `k` 个元素的值都增加 `val` 。如果栈中元素总数小于 `k` ，则栈中的所有元素都增加 `val` 。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 使用数组模拟\r\n- 额外使用一个数组模拟increment，以降低increment函数的时间复杂度\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：1\r\n- 空间O：maxSize\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.add = [0] * maxSize\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        ret = self.stk[self.top] + self.add[self.top]\r\n        self.top -= 1\r\n        if self.top != -1:\r\n            self.add[self.top] += self.add[self.top + 1]  # 更新add\r\n        self.add[self.top + 1] = 0\r\n        return ret\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k-1, self.top)\r\n        if lim >= 0:\r\n            self.add[lim] += val\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass CustomStack {\r\npublic:\r\n    vector<int> stk, add;\r\n    int top;\r\n    CustomStack(int maxSize) {\r\n        stk.resize(maxSize);\r\n        add.resize(maxSize);\r\n        top = -1;\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(top != stk.size() - 1){\r\n            top++;\r\n            stk[top] = x;\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        int res = -1;\r\n        if(top != -1){\r\n            res = stk[top] + add[top];\r\n            top -= 1;\r\n            if(top != -1){\r\n                add[top] += add[top + 1];\r\n            }\r\n            add[top + 1] = 0;            \r\n        }\r\n        return res;\r\n\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int lim = min(k - 1, top);\r\n        if (lim >= 0) {\r\n            add[lim] += val;\r\n        }\r\n\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack* obj = new CustomStack(maxSize);\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * obj->increment(k,val);\r\n */\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994856839","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n难度中等960\r\n\r\n给定一个经过编码的字符串，返回它解码后的字符串。\r\n\r\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\r\n\r\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\r\n\r\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 将字符、数字、[...]看成一组，由于[]存在嵌套，所以需要借用栈，不停压入状态\r\n- 注意数字可能是多位数，字符串可能存在多个字符\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O：n\r\n- 空间O：n\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n\r\n        for c in s:\r\n            if c == '[': # 将[之前的multi和字符存入stack\r\n                stack.append([res, multi])\r\n                res, multi = \"\", 0\r\n            elif c == ']': # 取出[之前存入stack的multi和字符\r\n                tmp, cur_multi = stack.pop()\r\n                res = tmp + res * cur_multi\r\n            elif '0' <= c <= '9':  # 有可能数字是多位数字\r\n                multi = multi * 10 + int(c)\r\n            else:  # 字符串\r\n                res += c\r\n        return res\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        stack<pair<string, int>> st;\r\n        string res = \"\";\r\n        int multi = 0;\r\n        for(auto c: s){\r\n            if(c == '['){\r\n                st.push(make_pair(res, multi));\r\n                res = \"\";\r\n                multi = 0;\r\n            }\r\n            else if(c == ']'){\r\n                string tmp = st.top().first;\r\n                for(int i = 0; i < st.top().second; i++){\r\n                    tmp += res;\r\n                }\r\n                res = tmp;\r\n                st.pop();\r\n            }\r\n            else if((c >= '0') && (c <= '9')){\r\n                multi = multi * 10 + (c - '0');\r\n            }\r\n            else {\r\n                res += c;\r\n            }\r\n        }\r\n        return res;\r\n\r\n    }\r\n};\r\n\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995867970","body":"From : https://github.com/dahaiyidi/awsome-leetcode\r\n\r\n## Problem\r\n\r\n#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\r\n\r\n难度简单517\r\n\r\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：\r\n\r\n实现 `MyQueue` 类：\r\n\r\n- `void push(int x)` 将元素 x 推到队列的末尾\r\n- `int pop()` 从队列的开头移除并返回元素\r\n- `int peek()` 返回队列开头的元素\r\n- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`\r\n\r\n \r\n\r\n**说明：**\r\n\r\n- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。\r\n- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\r\n\r\n \r\n\r\n**进阶：**\r\n\r\n- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\r\n\r\n------\r\n\r\n### Note\r\n\r\n- 只要st_out不为空，就可以一直从st_out pop。 peek同理。\r\n- 在push时，不需要将st_out添加到st_in中，可以直接push。\r\n- 当push时，若st_in为空，可以设置front等于该待push的值，以当做peek使用（当st_out 为空时）。\r\n\r\n------\r\n\r\n### Complexity\r\n\r\n- 时间O： 摊还复杂度1\r\n- 空间O：n\r\n\r\n------\r\n\r\n### Python\r\n\r\n```python\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.st_in, self.st_out = [], []\r\n        self.st_in_front =None\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.st_in) == 0:\r\n            self.front = x\r\n        self.st_in.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if len(self.st_out) == 0:\r\n            for _ in range(len(self.st_in)):\r\n                self.st_out.append(self.st_in.pop())\r\n        \r\n        if len(self.st_out):\r\n            return self.st_out.pop()\r\n\r\n    def peek(self) -> int:        \r\n        if len(self.st_out): \r\n            return self.st_out[-1]\r\n        return self.st_in_front\r\n        \r\n    def empty(self) -> bool:\r\n        return len(self.st_in) == 0 and len(self.st_out) == 0\r\n\r\n\r\n\r\n# Your MyQueue object will be instantiated and called as such:\r\n# obj = MyQueue()\r\n# obj.push(x)\r\n# param_2 = obj.pop()\r\n# param_3 = obj.peek()\r\n# param_4 = obj.empty()\r\n```\r\n\r\n### C++\r\n\r\n```C++\r\nclass MyQueue {\r\npublic:\r\n\r\n    stack<int> st1, st2;\r\n    int st1_front;\r\n    MyQueue() {\r\n    }\r\n    \r\n    void push(int x) {\r\n        if(st1.empty()){\r\n            st1_front = x;\r\n        }\r\n        st1.push(x);\r\n    }\r\n    \r\n    int pop() {\r\n        if(st2.empty()){\r\n            while(!st1.empty()){\r\n                st2.push(st1.top());\r\n                st1.pop();\r\n            }\r\n        }\r\n        if(!st2.empty()){\r\n            int tmp = st2.top();\r\n            st2.pop();\r\n            return tmp;\r\n\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    int peek() {\r\n        if(!st2.empty()){\r\n            return st2.top();\r\n        }\r\n        return st1_front;\r\n    }\r\n    \r\n    bool empty() {\r\n        return (st1.empty() && st2.empty());\r\n    }\r\n};\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue* obj = new MyQueue();\r\n * obj->push(x);\r\n * int param_2 = obj->pop();\r\n * int param_3 = obj->peek();\r\n * bool param_4 = obj->empty();\r\n */\r\n```\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"liuzekuan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991849933","body":"思路\n1 定义常量n，同时遍历两个数组，从末尾开始遍历，条件是两个指针的索引同时大于等于0， 将对应索引上的值相加再加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n\n2 1的循环跳出，说明此时其中一个数组已经到头了，遍历当前索引大于0的数组，将当前的索引的值 加上n 添加到集合，剩下的值依次加入到集合，循环结束，输出结果。 3.最后一个输出的数若取整为1要进一位。\n\n关键点\n循环的条件，取模，取整 集合容器的选取：方便从头部插入数据的集合，链表 边界问题：最后一个输出的数若取整为1要进一位\n\n代码\n语言支持：Java\nJava Code:\n\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //选取Linked集合从头部插入数据\n        LinkedList<Integer> linkedList =new LinkedList<>();\n        //定义常量n,记整除结果\n        String kStr=\"\"+k;\n        int n=0;\n        int i=num.length-1;\n        int j=kStr.length()-1;\n        while(i>=0&&j>=0){\n            int temp=num[i]+Integer.valueOf(\"\"+kStr.charAt(j));\n            //将对应索引上的值相加再加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((temp+n)%10);\n            n=(temp+n)/10;\n            i--;\n            j--;\n        }\n        //说明k已经遍历完，单独遍历剩下的数据\n        while(i>=0){\n            //将对应索引上的值加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((num[i]+n)%10);\n            n=(num[i]+n)/10;\n            i--;\n        }\n        //说明num已经遍历完，单独遍历剩下的数据\n        while(j>=0){\n            //将对应索引上的值加上n与10取模值， 取模结果记入集合中，整除结果赋值给n\n            linkedList.addFirst((Integer.valueOf(\"\"+kStr.charAt(j))+n)%10);\n            n=(Integer.valueOf(\"\"+kStr.charAt(j))+n)/10;\n            j--;\n        }\n        //边界问题，最后一个存在数值进1\n        if(n==1){\n            linkedList.addFirst(1);\n        }\n        return linkedList;\n    }\n}\n\n复杂度分析\n\n令 n 为数组长度。\n\n时间复杂度：O(n)  n为两个数组中较长的长度\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alfie100":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850071","body":"\n### 最低位相加模拟\n\n#### 思路\n模拟加法：A + k\n\n`当前位 = （A的当前位 + k） % 10`\n\n`当前位的进位 = （A的当前位 + k） // 10`\n\n这样可将 k 整体看作为进位，省略了变量carry\n\n#### 代码[Python]\n```Python []\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        res = []\n        while num or k:     # 若num未遍历完，【或】k未遍历完（k>0）\n            x = (num.pop() if num else 0) + k   # 若num未遍历完，pop一下；否则，设为0\n            k = x // 10\n            res.append(x%10)\n        \n        return res[::-1]\n```\n\n**复杂度分析**\n- 时间复杂度：$O(\\max(n, \\log k))$，其中 $n$ 为数组长度。\n- 空间复杂度：$O(\\max(n, \\log k))$，其中 $n$ 为数组长度。开辟了新的存储空间。\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991929448","body":"### 正向遍历 + 反向遍历\r\nLeetCode 原题连接：[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\r\n### 思路\r\n对于每个字符 s[i] 找出其距离左边及右边下一个目标字符 C 的距离，左右距离中的较小值即为答案。\r\n\r\n`从左往右遍历：`\r\n假设上一个 C 出现的位置为 pre，则当前 i 位置的字符距离 $C$ 的距离为 i-pre （pre <= i）；\r\n\r\n`从右往左遍历：`\r\n假设上一个 C 出现的位置为 pre，则当前 i 位置的字符距离 C 的距离为 pre-i （i <= pre）；\r\n\r\n\r\n### 代码 【Python】\r\n\r\n```python []\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n\r\n        n = len(s)\r\n        ans = []\r\n\r\n        # 正序遍历\r\n        pre = -n    # 设为较小的 -n 即可（距离的最大值不可能超过n）\r\n        for (i, ch) in enumerate(s):\r\n            if ch == c:\r\n                pre = i\r\n            ans.append(i-pre)\r\n\r\n        # 逆序遍历\r\n        pre = 2*n   # 设为较大的 2*n 即可（距离的最大值不可能超过n）\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                pre = i\r\n            ans[i] = min(ans[i], pre-i)\r\n        \r\n        return ans\r\n\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(n)，其中 n 为字符 s 长度。\r\n\r\n- 空间复杂度：O(n)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992623543","body":"【Python】**直接模拟 ：**\r\n\r\n```Python []\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = []\r\n        self.max_size = maxSize\r\n\r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.max_size:\r\n            self.stack.append(x)\r\n\r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) >= 1:\r\n            return self.stack.pop()\r\n        else:\r\n            return -1\r\n\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(len(self.stack), k)):\r\n            self.stack[i] += val\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(k)，其中 k 为增量函数 inc(int k, int val) 中的元素个数 k 。\r\n- 空间复杂度：O(maxSize), 其中 maxSize 为栈中最多能容纳的元素数量。\r\n\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994499816","body":"### 辅助栈\r\nLeetCode题目连接：[https://leetcode-cn.com/problems/decode-string/](https://leetcode-cn.com/problems/decode-string/)\r\n\r\n### Python代码\r\n\r\n【简洁版】：\r\n```Python []\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        num = 0\r\n        res = ''\r\n        for ch in s:\r\n            # if '0' <= ch <= '9':\r\n            if ch.isdigit():    # 0-9 【可能不止一位，需累计】\r\n                num = 10*num + int(ch)\r\n            elif ch == '[':     # 遇到左括号，入栈 (str, int) - 之前的字符串和括号外的数字\r\n                stack.append((res, num))\r\n                num = 0\r\n                res = ''\r\n            elif ch == ']':     # 遇到右括号，出栈 (str, int)\r\n                last_res, cur_num = stack.pop()\r\n                res = last_res + cur_num*res    # 之前的字符 + 当前字符*当前倍数\r\n            else:   # 有效字符，如is alpha\r\n                res += ch\r\n        \r\n        return res\r\n```\r\n\r\n【易理解版】：\r\n```Python []\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        \r\n        for ch in s:\r\n            if ch != ']':   # 非右括号]，入栈\r\n                stack.append(ch)\r\n\r\n            else:\r\n                sub = ''\r\n                while stack[-1] != '[': # 出栈，直至遇到'['\r\n                    sub = stack.pop() + sub\r\n                \r\n                stack.pop()     # '['出栈\r\n\r\n                # 计算 [ 前面的数字倍数\r\n                num = ''\r\n                while stack and '0'<=stack[-1]<='9':\r\n                    num = stack.pop() + num\r\n                num = int(num)\r\n\r\n                # 入栈当前计算得到字符串，如 2[bc] -> bcbc\r\n                stack.append(num * sub)\r\n        \r\n        return ''.join(stack)\r\n```\r\n\r\n\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)，其中 n  为字符长度。\r\n- 空间复杂度：O(n)。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995002078","body":"### 直接模拟\r\n\r\n#### Python代码：\r\n```python []\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.s1 = []\r\n        self.s2 = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.s1.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop()) \r\n        return self.s2.pop()\r\n\r\n    def peek(self) -> int:\r\n        if not self.s2:\r\n            while self.s1:\r\n                self.s2.append(self.s1.pop()) \r\n        return self.s2[-1]\r\n\r\n    def empty(self) -> bool:\r\n        if self.s1 or self.s2:\r\n            return False\r\n        else:\r\n            return True\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(n)。\r\n- 空间复杂度：O(n)。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ryan0218":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850174","body":"class Solution {\n\npublic List addToArrayForm(int[] num, int k)\n {\n\nList res = new ArrayList();\n\nint n = num.length;\n\nfor (int i = n-1; i >= 0; --i)\n{\n\nint sum = num[i] + k % 10;\n\nk /= 10;\n\nif (sum >= 10)\n{\n\nk ++;\n\nsum -= 10;\n}\n\nres.add(sum);\n}\n\n\nfor (; k > 0; k /= 10)\n{\n\nres.add(k % 10);\n}\n\nCollections.reverse(res);\n\nreturn res;\n}\n}\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wodong0012":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991850483","body":"判断k是否倒序遍历数组，在与k % 10 相加 之后在将k /10 ， 在判断结果>10 ，++k并且将结果-10，在存入数组中\n同时k的位数会大于数组长度，需要加一个循环插入大于的数据\n\n```c++\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        vector<int> results = vector<int>();\n        int listSize = num.size();\n        int temp;\n        for (int i = listSize - 1; i >= 0; i--)\n        {\n            if (k != 0)\n            {\n                temp = num[i] + k % 10;\n                k /= 10;\n                if (temp >= 10)\n                {\n                    ++k; // 进位\n                    temp -= 10;\n                }\n            }\n            else\n            {\n                temp = num[i];\n            }\n            results.push_back(temp);\n        }\n        while (k > 0)\n        {\n            results.push_back(k % 10);\n            k /= 10;\n        }\n\n        reverse(results.begin(), results.end());\n\n        return results; \n    }\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992559080","body":"先获取到每一个e的位置。并保存到数组中。\n再次遍历字符串，进入循环后拿到当前位置的位置，在判断位置集合是否只有1个数量，有就直接添加到结果集合中。\n没有就比较大小存入结果集合中。\n```c++\n\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> cI = vector<int>();\n        vector<int> outRes = vector<int>();\n\n        for (int i = 0; i < s.length(); ++i)\n        {\n            if (s[i] == c)\n            {\n                cI.push_back(i);\n            }\n        }\n        int index = 0;\n        for (size_t i = 0; i < s.length(); ++i)\n        {\n            int oneNum = cI[0] - i;\n            oneNum = abs(oneNum);\n            if (cI.size() == 1)\n            {\n                outRes.push_back(oneNum);\n                continue;\n            }\n            \n            int twoNum = cI[1] - i;\n            twoNum = abs(twoNum);\n            if (oneNum <= twoNum)\n                outRes.push_back(oneNum);\n            else\n                outRes.push_back(twoNum);\n\n\n            if (i > cI[0] && i >= cI[1]) // 不会抛越界异常\n            {\n                cI.erase(cI.begin());\n            }\n        }\n\n        return outRes;\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993579527","body":"实现方式有很多，可以是数组也可以是 其他集合，这里采用集合实现\n\n```c++\n\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) : index(-1)\n    {\n        stack.resize(maxSize);\n    }\n\n    void push(int x)\n    {\n        if (index != stack.size() - 1)\n        {\n            ++index;\n            stack[index] = x;\n        }\n    }\n\n    int pop()\n    {\n        if (index >= 0)\n        {\n            int num = stack[index];\n            index--;\n            return num;\n        }\n        return -1;\n    }\n\n    void increment(int k, int val)\n    {\n        for (size_t i = 0; i < k; ++i)\n        {\n            if (stack.size() <= k && stack.size() == i)\n            {\n                break;\n            }\n\n            stack[i] = stack[i] + val;\n        }\n    }\n\nprivate:\n    vector<int> stack;\n    int index;\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994894036","body":"使用数字一个栈，字母一个栈来解题\n\n```c++\n\nclass Solution {\npublic:\n    string src; \n    size_t ptr;\n\n    /**\n     * @brief Get the Digits object\n     * \n     * @return int \n     */\n    int getDigits() {\n        int ret = 0;\n        while (ptr < src.size() && isdigit(src[ptr])) {\n            // 每次都乘以10 ， 在加上下一个数组，也就是数字栈。\n            ret = ret * 10 + src[ptr++] - '0';\n        }\n        return ret;\n    }\n\n    string getString() {\n        if (ptr == src.size() || src[ptr] == ']') {\n            return \"\";\n        }\n\n        char cur = src[ptr]; int repTime = 1;\n        string ret;\n\n        if (isdigit(cur)) {\n            // String -> Digits [ String ] String\n            // 解析 Digits\n            repTime = getDigits(); \n            // 是数字就过滤左括号\n            ++ptr;\n            // 解析 String ， 内部还有[] 还是会回到getString中\n            string str = getString(); \n            // 解析完字符串后一定要过滤右括号\n            ++ptr;\n            // 构造字符串\n            while (repTime--) ret += str; \n        } else if (isalpha(cur)) {\n            // String -> Char String\n            // 解析 Char\n            ret = string(1, src[ptr++]);\n        }\n        \n        return ret + getString();\n    }\n\n    string decodeString(string s) {\n        src = s;\n        ptr = 0;\n        return getString();\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995788662","body":"创建两个栈，一个输入站和一个输出栈，用输入住栈控制 `push`操作，输出栈控制 `pop`和`peek`操作。\n1. 当`push`操作时，将数据存入输入站。\n2. 当`pop`时 ，如果输出栈为空，将输入栈的所有数据依次弹栈并压入输出栈中。然后在访问输出栈数据并弹栈。\n3. 当`peek`时，也是一样判断输出栈是否为空，为空压栈操作。在弹出输出栈数据。\n4. 当`empt`时，判断两个栈是否为空即可。\n\n```c++\n\nclass MyQueue {\nprivate:\n    stack<int> inStack;\n    stack<int> outStack;\n\n    void in2out() {\n        while (!inStack.empty()) {\n            // 将输入栈的元素存到输出栈中\n            outStack.push(inStack.top());\n            // 输入站的元素弹栈\n            inStack.pop();\n        }\n    }\n\npublic:\n    MyQueue() {\n\n    }\n\n    void push(int x) {\n        inStack.push(x);\n    }\n\n    // 弹栈操作\n    int pop() {\n        // 如果输出栈为空，就将 输入站中的数据 从栈顶依次压入输出栈， 这样就倒序了。\n        if (outStack.empty()) {\n            in2out();\n        }\n        int num = outStack.top(); // 访问栈顶元素\n        outStack.pop(); // 将输出栈元素弹出\n        return num;\n    }\n\n    int peek() {\n        // 如果输出栈为空，就将 输入站中的数据 从栈顶依次压入输出栈， 这样就倒序了。\n        if (outStack.empty()) {\n            in2out();\n        }\n        return outStack.top(); // 访问栈顶元素\n    }\n\n    bool empty() {\n        return inStack.empty() && outStack.empty();\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"junbuer":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991851273","body":"思路\n\n逐位相加，每次记录进位carry，直到k和num的每一位数都处理完，最后反转结果数组\n\n代码\n\n    class Solution(object):\n        def addToArrayForm(self, num, k):\n            \"\"\"\n            :type num: List[int]\n            :type k: int\n            :rtype: List[int]\n            \"\"\"\n            i = len(num) - 1\n            n = []\n            carry = 0\n            while k or (i >= 0) or carry:\n                if i >= 0:\n                    sum_ = num[i] + k % 10 + carry\n                else:\n                    sum_ = k % 10 + carry\n                n.append(sum_ % 10)\n                carry = sum_ // 10\n                k //= 10\n                i -= 1\n            n.reverse()\n            return n\n\n复杂度\n\n+ 时间复杂度 (max(n,  len(k)))\n+ 空间复杂度 O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992204112","body":"### 思路\n\n两次遍历取最小值：\n\n+ 正向遍历，计算当前字符与左边最近的字符c的距离\n+ 反向遍历，计算当前字符与右边最近的字符c的距离\n\n最后输出两次遍历的距离的最小值\n\n### 代码\n```python\n    class Solution(object):\n        def shortestToChar(self, s, c):\n            \"\"\"\n            :type s: str\n            :type c: str\n            :rtype: List[int]\n            \"\"\"\n            pre = float('-inf')\n            dis = []\n            for i in range(len(s)):\n                if s[i] == c: \n                    pre = i\n                dis.append(i - pre)\n            pre = float('inf')\n            for i in range(len(s) - 1, -1, -1):\n                if s[i] == c:\n                    pre = i\n                dis[i] = min(dis[i], pre - i)\n            return dis\n```\n### 复杂度分析\n\n+ 时间复杂度：O(n)， 两次遍历\n+ 空间复杂度：O(n)\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993270558","body":"### 思路\n\n使用数组模拟，将数组的末尾作为栈顶\n\n### 代码\n\n```python\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.Stack = [] \n        self.maxSize =maxSize\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.Stack) < self.maxSize:\n            self.Stack.append(x)\n        \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.Stack):\n            return self.Stack.pop()\n        else:\n            return -1\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(k, len(self.Stack))):\n            self.Stack[i] += val\n\n```\n\n### 复杂度分析\n\n+ 时间复杂度：push和pop为O(1)，increment为O(k)\n+ 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994696271","body":"### 思路\n\n+ 如果为数字则更新重复次数d\n+ 如果为字母则更新字符串string\n+ 如果为'['则入栈\n+ 如果为']'则出栈，并将栈顶的字符串添加到string\n\n### 代码\n```python\n    class Solution(object):\n        def decodeString(self, s):\n            \"\"\"\n            :type s: str\n            :rtype: str\n            \"\"\"\n            stk = []\n            string = \"\"\n            d= 0\n            for c in s:\n                if c.isdigit():\n                    d = d * 10 + int(c)\n                elif c.isalpha():\n                    string += c\n                elif c == '[':\n                    stk.append([d, string])\n                    d, string = 0, \"\"\n                else:\n                    cur_d, last_str = stk.pop()\n                    string = last_str + cur_d * string\n            return string \n  ```                                 \n### 复杂度分析\n\n+ 时间复杂度：O(n)\n+ 空间复杂度：O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995619512","body":"### 思路\n\n定义两个栈`in`和`out`。`in`在进队时压栈；`out`在需要出队将`in`的内容出栈并压入`out`，然后`out`出栈\n\n### 代码\n\n```python\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stk1 = []\n        self.stk2 = []\n        self.top = 0\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stk1.append(x)\n          \n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stk2) == 0:\n            while len(self.stk1):\n                self.stk2.append(self.stk1.pop())\n        return self.stk2.pop()\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if len(self.stk2):\n            return self.stk2[-1]\n        return self.stk1[0]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        if len(self.stk1) or len(self.stk2):\n            return False\n        else:\n            return True\n```\n\n### 复杂度分析\n\n+ 时间复杂度：`push`，`pop`，`peek` ，`empty`都为O(1)；`pop`最好时为O(1)，最差为O(n)\n+ 空间复杂度： O(n) ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lonkang":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991852775","body":"// 使用BigInt偷个懒\n```js\nvar addToArrayForm = function(A, K) {\n  let N = '';\n  A.forEach( e =>{\n    N = N+e\n  })\n\n  return String(BigInt(N) + BigInt(K)).split('').map(e => Number(e))\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992551403","body":"### 思路：\n参考官方题解算双向遍历\n\n### 代码：\n```js\nvar shortestToChar = function (S, C) {\n  var res = Array(S.length).fill(0);\n\n  for (let i = 0; i < S.length; i++) {\n    if (S[i] === C) continue;\n\n    let l = i,\n      r = i,\n      tmp = Infinity;\n\n    while (l >= 0) {\n      if (S[l] === C) {\n        tmp = Math.min(tmp, i - l);\n        break;\n      }\n      l--;\n    }\n\n    while (r < S.length) {\n      if (S[r] === C) {\n        tmp = Math.min(tmp, r - i);\n        break;\n      }\n      r++;\n    }\n\n    res[i] = tmp;\n  }\n  return res;\n};\n```\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993335660","body":"### 思路：\njs的数组即是栈也是队列简直无敌；\n### 代码：\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.list = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\nif(this.list.length<this.maxSize) {\n    this.list.push(x)\n}\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.list.pop()\n    return res === null ? -1 : res;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n for (var i = 0; i < this.list.length; i++) {\n    if (i < k) {\n      this.list[i] += val;\n    }\n  }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994632105","body":"### 思路：\n利用栈解题，注意字母前面的数字可能有多位\n\n遇到 \"数字\" 、\"[\"、\"字母\" 入栈（即不是右括号\"]\"的都入栈）\n\n遇到右括号\"]\"则出栈，一直出栈直到不等于左括\"[\"时停止出栈\n\n取出\"[ ]\"括号之间要的字符串str，然后取得数字，计算str重复次数后的字符串pushStr，然后pushStr再入栈\n\n最后把栈的元素拼接起来即可\n### 代码：\n\n```js\nvar decodeString = (str) => {\n  if (!str) {\n    return ''\n  }\n\n  let stack = []\n\n  // 存字母前的数字，可能有多位\n  let numstr = ''\n\n  for (let s of str) {\n    // 多位数字的处理\n    if (Number.isInteger(+s)) {\n      numstr += s\n      continue\n    }\n\n    if (numstr) {\n      stack.push(+numstr)\n      numstr = '' // 注意置空\n    }\n\n    // 不是右括号直接入栈\n    if (s != ']') {\n      stack.push(s)\n      continue\n    }\n\n    // 遇到右括号，需要出栈，直到不等于左括号\n    let str = ''\n    while (stack.length && stack.slice(-1) != '[') {\n      let top = stack.pop()\n      top += str\n      str = top\n    }\n\n    // 删掉左括号\n    stack.pop()\n\n    // 取得数字\n    let count = +stack.pop()\n\n    // 字符拼接对应的次数\n    let pushStr = str.repeat(count)\n\n    stack.push(pushStr)\n  }\n\n  return stack.join('')\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wbcz":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991853411","body":"1.数组A转换成整数，\n2.A和K再求和\n3.每位数分开\n4.再生成新数组\n\nJavaScript:\n\nConst getNewSum =（A，K）=>{\n  return（Number（ A.join（，））+K).split（，）\n}\n\n时间复杂度  O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992619409","body":"时间换空间\n\nfunction shortDistance(S, C) {\n  let arrIndexs = []\n  let resNewArr = []\n  for(let i=0; i< S.length; i++) {\n    if(S[i] == C) {\n      arrIndexs.push(i)\n    }\n  }\n\n  for(let i=0; i< S.length; i++) {\n    if(S[i] == C) {\n      resNewArr[i] = 0\n    }\n    \n    for(const index of arrIndexs) {\n      resNewArr[i] = Math.abs(index -i)\n    } \n  }\n  return resNewArr\n}\n\n下标组成的数组长度为K, 字符串长度为N,时间复杂度O(K+N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993682060","body":"数组模拟栈，先定义一个数组栈，然后对数组实现pop和push方法即可，inc方法需要用到指定次数循环k次；\n\n时间复杂度，数组的pop和push方法，O(1)\nInc方法，k次循环，复杂度O（k）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aakk474548":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855322","body":"## 思路\n\n#### 这不就是数组转成字符串加完再转成数组吗？<br/>\n\n结论：大整数算不了。估计这就是题的意义之一，大整数如何存储和加减运算\n\n#### 两层循环，从后向前逐位比。<br/>\n\n结论：想想觉得蠢，应该不至于。\n\n#### 看题解看一半<br/>\n\n思路偷到了：从num的最后一位开始加，加完了个位存起来，突突突接着往前加。<br/>\n脑子： ‘我会了‘，手：’你会个屁‘。\n\n#### 遇到几个问题再看题解之后再来<br/>\n\n- 边界：边界是num的长度或k的长度，两者共同决定循环次数，也就是最终数组长度。k.length>num.length时，得把k一位一位补完，k.length<num.length时要把num一位一位补完。<br/>\n- k的变化：全程就是对k的相加、取值和算出下一个k。相加就是num遍历结束前，k每次要和num[i]相加。取值就是k相加完取出个位。下一个k就是 除10 取整。<br/>\n- 空间：能不能不多创建那个数组。好像不能，原数组操作，向数组头添加，会增加时间复杂度。<br/>\n- 提示：提示真有用啊。再看提示其实就明白了，1就是两个正经整数，2 按位加的时候你放心做加法，没想着在这再坑你一道。\n\n## 代码\n\n```javascript\nvar addToArrayForm = function(num, k) {\n    const n = num.length;\n    const res = []\n    for(let i = n - 1; i >=0 || k != 0; i--){\n        if(i >=0){\n        \t// 相加\n            k += num[i]            \n        }\n        // 取值\n        res.push(k % 10)\n        // 下一个k\n        k = Math.floor(k / 10)\n    }\n    res.reverse()\n    return res\n};\n```\n\n## 复杂度\n时间:   O(n) <br/>\n空间:   O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992523517","body":"## 思路\n\n#### 暴力解法\n1. 先遍历一遍，把所有的位置存放在一个数组arr中\n2. 遍历s，把每个i，都拿去和arr遍历比对，计算出最小值\n3. 将最小值存储在 res 数组中\n\n#### 正反双指针\n1. 遍历两次，先从左到右，再从右到做。\n2. 先声明一个最小的整数prev当作无穷小数。\n3. 从左向右循环，遇到c则将索引赋值给prev。结果数组res每次赋值为i - prev。不用考虑前几个没遇到c的情况，一会从右向左会处理的。题干也保证了一定有c。\n4. 再将prev设置为最大整数。\n5. 从右向左循环，遇到c则将索引赋值给prev。结果数组res每次赋值为，res[i]和 prev - i 的最小值。\n\n## 代码\n\n```javascript\n    var shortestToChar = function(s, c) {\n        const len = s.length;\n        //声明成最小安全数\n        let prev = -Number.MAX_SAFE_INTEGER;\n        // 结果\n        const res = []\n        // 从左向右\n        for(let i = 0; i < len; i++){\n            if (s.charAt(i) == c) prev = i;\n            res[i] = i - prev;\n        }\n        // 此时结果大概为[-9999999999,-9999999999, 0,1,2,3,4]\n        //把prev设置为最大\n        prev = Number.MAX_SAFE_INTEGER;\n        // 从右向左\n         for(let i = len - 1; i >= 0; i--){\n\n            if (s.charAt(i) == c) prev = i;\n            // 取最小值\n            res[i] = Math.min(res[i], prev - i);\n        }\n        return res\n    };\n```\n\n## 复杂度\n时间复杂度: O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993461467","body":"## 思路\n没啥说的了，模拟一个栈的入栈出栈\n\n## 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    console.log('max' + maxSize)\n    this.maxSize = maxSize;\n    this.value = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.maxSize == this.value.length){\n        return \n    }else{\n        this.value.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if(this.value.length == 0){\n        return -1\n    }else{\n        return this.value.pop()\n    }\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n\n    let len;\n    if(this.value.length < k){\n        len = this.value.length\n    }else{\n        len = k\n    }\n    for(let i = 0; i < len; i++){\n        this.value[i]+=val \n    }\n\n};\n```\n\n## 复杂度\n这哪有复杂度\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994689916","body":"## 思路\n\n有括号匹配的都得用栈吧。通过入栈暂存，这样就可以处理多个嵌套括号得问题。\n\n## 代码\n\n```javascript\nvar decodeString = function(s) {\n     let mulStack = [], strStack = [], num = 0, res = ''\n    for (const c of s) {   \n        if (!isNaN(c)) {  \n             num = num * 10 + Number(c)\n        } else if (c == '[') {  \n            strStack.push(res)\n            mulStack.push(num) \n            res = '' \n            num = 0\n        } else if (c == ']') {  \n            res = strStack.pop() + res.repeat(mulStack.pop())\n        } else {                   \n            res += c\n        }\n    }\n    return res;\n};\n```\n\n## 复杂度\n时间: O(n)\n空间: O(1) ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995754217","body":"## 思路\n\n双栈，一个入队栈，一个出队栈\n\n## 代码\n\n```javascript\nvar MyQueue = function() {\n    this.inArr = []\n    this.outArr = []\n\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inArr.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(this.outArr.length == 0){\n        this.in2out()\n    }\n    return this.outArr.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n     if(this.outArr.length == 0){\n        this.in2out()\n    }\n    return this.outArr[this.outArr.length - 1]\n};\n\n/**\n * @return {boolean}\n */\n\nMyQueue.prototype.empty = function() {\n    return this.inArr.length == 0 && this.outArr.length == 0\n};\nMyQueue.prototype.in2out = function() {\n    while(this.inArr.length){\n        this.outArr.push(this.inArr.pop())\n    }\n};\n```\n\n## 复杂度\n时间 O(1)\n空间 O (1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wujunhong-max":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991855361","body":"## 思路\n1. 逐位相加，将数组的每一位和整数的每一位相加，若得到的数大于等于10，则进位\n2. 将得到的数放进新数组中，转置数组\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n\n    vector<int> num1;\n    int n= num.size();\n    for(int i = n-1; i>=0; i--)  // vector数组是从左往右的，num[0]是最左边的数\n    {\n        int sum = num[i]+k%10;  // 逐位相加\n        k /= 10;\n        if(sum>=10)\n        {\n            k++;\t\t\t// 进位加1\n        }\n        num1.push_back(sum%10);\n        sum = 0;\n    }\n    while(k>0)\t\t// 考虑整数k比数组 位数多 的情况\n    {\n        num1.push_back(k%10);\n        k /= 10;\n    }\n    reverse(num1.begin(), num1.end());  // 数组反转\n    return num1;\n    }\n};\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992505294","body":"## 思路\n\n1. 将出现字符的下标数字存在数组a中\n2. 遍历字符串，将每个字符下标与整个数组a比较，将最短距离存进answer数组中\n## 代码\n\n暴力解法：\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> a;\n\n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i] == c)\n                a.push_back(i);  // 将出现字符的下标数字存在数组a中\n        }\n\n        vector<int> answer;\n        for(int i=0; i<s.size(); i++)  // 遍历字符串\n        {\n            int num = s.size();\n            for(int j=0; j< a.size(); j++)   // 将每个字符下标与整个数组a比较，将最短距离存进answer数组中\n            {\n                num = min(num, abs(a[j]-i));\n            }\n            answer.push_back(num);\n        }\n        return answer;\n    }\n};\n```\n\n\n\n## 复杂度\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993594632","body":"## 思路\n\n用vector数组模拟栈\n\n- 创建一个预留一定空间的vector数组\n- 判断数组中的个数是否超出容器，进而执行push操作，判断数组是否为空，进而执行pop操作\n- 判断数组中的个数，决定对哪些元素进行加法\n\n## 代码\n\n```cpp\nclass CustomStack {\npublic:\n    CustomStack(int maxSize) {\n        a.reserve(maxSize);  // 预留长度, 里面的空间不能访问\n    }\n    \n    void push(int x) {\n        if(a.size()<a.capacity())   // 判断数组中的个数是否超出容器\n        {\n            a.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(a.size())    // 判断数组是否为空\n        {\n            int num = a.back();\n            a.pop_back();\n            return num;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    \n    void increment(int k, int val) {\n        if(a.size() != 0)\n        {\n            int m=0;\n            int n = a.size();\n            m = (n <= k)? n:k;   \n            for(int i=0; i<m; i++)\n            {\n                a[i] += val;\n            }\n            \n        }\n    }\npublic:\n    vector<int> a;\n};\n\n```\n\n## 复杂度\n\n时间复杂度：初始化（构造函数）、`push` 操作和 `pop` 操作的渐进时间复杂度为 O(1)，`inc` 操作的渐进时间复杂度为 O(k)。 \n\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994922489","body":"### 思路\n\n- 括号匹配，用栈解决\n- 用两个栈分别存储字符串的重复次数以及当前解码的字符串\n- 最开始str栈内存入“” \n- 每次遇到字母，表示该字母属于str栈顶的待解码字符串，可以直接在str栈顶字符串末尾加入该字母。\n- 每次碰到数字要读取完整的数字，此时遍历过了一次'[' ，就在字符串栈中新开一层\n- 每次遇到']'表示已经完成一个字符串的解码，此时栈顶字符串就是一个“【】”里面需要重复的字符串，重复次数为num栈顶元素次数，记录两个栈顶元素，分别减少一层， 将解码结果加入str栈顶字符串末尾\n- 遍历完s字符串，str栈顶就是最终解码结果\n\n### 代码\n\n```cpp\nclass Solution {\npublic:\n    string decodeString(string s)\n    {\n        str.push_back(\"\"); // 创建空的一层\n        for(int i=0; i<s.size(); i++)   // 遍历字符串s\n        {\n            if(isalpha(s[i]))   // 判断字符是否为字母\n                str.back() += s[i];  // 字母直接加在一层中\n            else if(isdigit(s[i]))  // 判断字符是否为数字\n            {\n                int x=0;\n                while(isdigit(s[i]))\n                {\n                    // 若s[i] == '0', 转化为整型数字是48, 不符合，所以要 -'0'转化\n                    x = x*10 + s[i] - '0'; \n                    i++;            //考虑后面的字符也是数字\n                } // 读取重复次数，此时已经遍历过一个'['\n                num.push_back(x);\n                str.push_back(\"\"); //因为遍历过一个'[', 所以新开一层\n            }\n            else // 如果是']'则出栈一次\n            {\n                int a = num.back();\n                string sstr = str.back();\n                str.pop_back();\n                num.pop_back();\n                while (a -- ) str.back() += sstr;//更新最内一层的字符串\n            }\n        }\n        return str.back();  //最后的结果是栈底\n    }\nprivate:\n    vector<int> num; // 数字栈，存储重复的次数的栈\n    vector<string> str; // 记录最内一层字符串的栈， 有'【'就开一层\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n^2)\n\n空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994991083","body":"## 思路\n\n用两个栈模拟队列，队尾push，队头pop\n\n## 代码\n\n```cpp\nclass MyQueue {\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        while(!b.empty())  // 如果b非空\n        {\n            a.push(b.top());\n            b.pop();\n        }\n        a.push(x);\n        while(! a.empty())\n        {\n            b.push(a.top());\n            a.pop();\n        }\n    }\n    \n    int pop() {\n        int ret = b.top();\n        b.pop();\n        return ret;\n    }\n    \n    int peek() {\n        return b.top();\n    }\n    \n    bool empty() {\n        return b.empty();\n    }\nprivate:\n    stack<int> a,b;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\n\n## 复杂度\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pengfeicchen":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991857243","body":"class Solution {\n    public List<Integer> addToArrayForm(int[] num, int K) {\n        List<Integer> res = new LinkedList<>();\n        for (int i = num.length - 1; i >= 0; --i) {\n            res.add(0, (num[i] + K) % 10);\n            K = (num[i] + K) / 10;\n        }\n        while (K > 0) {\n            res.add(0, K % 10);\n            K /= 10;\n        }\n        return res;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992175534","body":"class Solution {\n    public int[] shortestToChar(String S, char C) {\n        char[] cc = S.toCharArray();\n        int[] result = new int[cc.length];\n        List<Integer> index = new ArrayList<>();\n        for(int i=0;i<cc.length;i++){\n            if(cc[i]==C){\n                index.add(i);\n                System.out.print(i);\n            }\n        }\n        int count=0;\n        for(int i=0;i<cc.length;i++){\n            if(i==index.get(count)){\n                if(count<index.size()-1){\n                    count++;\n                }\n                result[i] = 0;\n            }else if(count==0 && i<index.get(count)){\n                result[i] = index.get(count)-i;\n            }else if(count==index.size()-1 && i>index.get(count)){\n                result[i] = i - index.get(count);\n            }else if(count>0){\n                if(i-index.get(count-1) < index.get(count)-i){\n                    result[i] = i-index.get(count-1);\n                }else{\n                    result[i] = index.get(count)-i;\n                }\n            }\n        }\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993223866","body":"// time:O(n) space:O(n)\npublic int[] arr;\n    public int size;\n    public int max;\n    public _1381_DesignaStackWithIncrementOperation(int maxSize) {\n        size = 0;\n        max = maxSize;\n        arr = new int[1001];\n    }\n    \n    public void push(int x) {\n        if (size < max) {\n            arr[size++] = x;\n        }\n    }\n    \n    public int pop() {\n        if (size < 1) return -1;\n        int res = arr[size - 1];\n        size--;\n        return res;\n    }\n    \n    public void increment(int k, int val) {\n        int j = k < size ? k : size;\n        for (int i = 0; i < j; i++) {\n            arr[i] += val;\n        }\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994565174","body":"public class Solution {\n    public String decodeString(String s) {\n        Stack<Integer> nums = new Stack<Integer>();\n        Stack<Character> chars = new Stack<Character>();\n        int count = 0;\n        for (int i = 0; i < s.length(); i ++) {\n            char c = s.charAt(i);\n            if (c >= '0' && c <= '9') {\n                count = count * 10 + (c - '0');\n            }\n            else if (c == ']') {\n                int repeat = nums.pop();\n                String tmp = \"\";\n                while (chars.peek() != '[') {\n                   tmp = chars.pop() + tmp;     \n                }\n                chars.pop();\n                for (int j = 0; j < repeat; j ++) {\n                    for (int k = 0; k < tmp.length(); k ++) {\n                        chars.push(tmp.charAt(k));\n                    }\n                }\n            }\n            else {\n                if (count != 0) {\n                    nums.push(count);\n                }   \n                count = 0;\n                chars.push(c);\n            }\n        }\n        String result = \"\";\n        while (!chars.isEmpty()) {\n            result = chars.pop() + result;\n        }\n        return result;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995500758","body":"class MyQueue {\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n\n    public void push(int x) {\n        stack1.push(x);\n    }\n\n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n\n    public int peek() {\n        //stack1 the node sequence pops up and presses in stack2 \n        if (stack2.isEmpty()) {// on the condition that : stack2 for, stack1, O(1)\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());//stack1stack2\n            }\n        }\n        return stack2.peek();\n    }\n\n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"stonehit":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991858521","body":"## 思路\r\n逐位相加，记录进位，计算后头插到结果数组\r\n\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        for(int i = num.length - 1;i >= 0 || k > 0;i--){\r\n            int dec = (k % 10) + carry;\r\n            dec += i >= 0 ? num[i] : 0;\r\n            k = k / 10;\r\n            carry = 0;\r\n            if(dec >= 10){\r\n                carry = 1;\r\n                dec = dec % 10;\r\n            }\r\n            res.add(0,dec);\r\n        }\r\n        if(carry != 0)  res.add(0,1);\r\n        return res;\r\n    }\r\n\r\n\r\n}\r\n```\r\n## 复杂度\r\n空间O(N)\r\n时间O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992550562","body":"## 思路\r\n前后各遍历一次，记录为C的索引位置\r\n## 代码\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int[] res = new int[S.length()];\r\n        int index = -S.length();\r\n        for(int i = 0;i<S.length();i++){\r\n            if(S.charAt(i) == C){\r\n                index = i;\r\n                res[i] = 0;\r\n            }else{\r\n                res[i] = i-index;\r\n            }\r\n        }\r\n        index = 10000;\r\n        for(int j = S.length() - 1;j>=0;j--){\r\n            if(S.charAt(j) == C){\r\n                index = j;\r\n            }else{\r\n                res[j] = Math.min(index-j,res[j]);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度\r\n时间O(N)\r\n空间O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994900268","body":"## 代码\r\n```java\r\nclass Solution {\r\n    Stack<Object> stack;\r\n    public String decodeString(String s) {\r\n        String res = \"\";\r\n        stack = new Stack();\r\n        int num = 0;\r\n        for(int i = 0;i<s.length();i++){\r\n            char c = s.charAt(i);\r\n            if(Character.isDigit(c)){\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if(c == '['){\r\n                stack.push(num);\r\n                num = 0;\r\n            }\r\n            else if(c == ']'){\r\n                String tmp = strAppendPush();\r\n                int cnt = (int)stack.pop();\r\n                String temp = String.join(\"\", Collections.nCopies(cnt, tmp));\r\n                stack.push(temp);\r\n            }else{\r\n                stack.push(String.valueOf(c));\r\n            }\r\n        }\r\n        return new StringBuilder(strAppendPush()).reverse().toString();\r\n\r\n    }\r\n    public String strAppendPush(){\r\n        StringBuilder sb = new StringBuilder();\r\n        while(!stack.isEmpty() && stack.peek() instanceof String){\r\n            sb.append(stack.pop());\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n```\r\n## 复杂度\r\n时间O(N)\r\n空间O(N)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995841218","body":"## 代码\r\n```java\r\nclass MyQueue {\r\n    public Stack<Integer> instack;\r\n    public Stack<Integer> outstack;\r\n\r\n    public MyQueue() {\r\n        instack = new Stack<>();\r\n        outstack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        instack.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(!outstack.isEmpty()){\r\n            return outstack.pop();\r\n        }else{\r\n            while(!instack.isEmpty()){\r\n                outstack.push(instack.pop());\r\n            }\r\n            return outstack.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n         if(!outstack.isEmpty()){\r\n            return outstack.peek();\r\n        }else{\r\n            while(!instack.isEmpty()){\r\n                outstack.push(instack.pop());\r\n            }\r\n            return outstack.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return instack.isEmpty() && outstack.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n#复杂度 \r\n空间O(N)\r\n时间O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ggohem":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991860708","body":"### 思路：\n\n将对应元素从个位起往前依次相加，当有进位时，需要考虑进位，这里我为了方便使用了链表的数据结构，把数组num和k都放到了两个链表上，依次遍历两个链表，并把结果存在一个新的链表上\n\n### 代码：\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list1 = new LinkedList<>();\n        LinkedList<Integer> list2 = new LinkedList<>();\n        LinkedList<Integer> list3 = new LinkedList<>();\n        for (int i : num) {\n            list1.addLast(i);\n        }\n        while (k != 0) {\n            list2.addFirst(k % 10);\n            k /= 10;\n        }\n        int carried = 0;\n        while (list1.size()!=0||list2.size() != 0 || carried != 0) {\n            int n1 = list1.size() != 0 ? list1.removeLast() : 0;\n            int n2 = list2.size() != 0 ? list2.removeLast() : 0;\n            int sum = n1 + n2 + carried;\n            int inser = sum % 10;\n            carried = sum / 10;\n            list3.addFirst(inser);\n        }\n        return list3;\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度： O(max(n,len(k)) \n- 空间复杂度：O(n)\n- 这里不是很会分析\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992070313","body":"### 思路：\n\n遍历一边字符串将所有元素进行比较进而选中待比较元素，再将其向前向后分别进行遍历查找最近的字符c，设置两个标记flag1和flag2。当只有一边出现了字符c，则肯定有一边的距离为0，此时flag1和flag2必有一个是false，这是我们选用左边距离和右边距离的最大值(把没出现c的那一边剔除)；当两边都有字符c，此时flag1和flag2都为true，这时选用左边距离和右边距离的最小值(两边都有距离)\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] dis = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) {\n            char temp = s.charAt(i);\n            boolean flag1 = false, flag2 = false;\n            int distance_1 = 0, distance_2 = 0;\n            for (int left = i; left >= 0; left--) {\n                char temp1 = s.charAt(left);\n                if (temp1 == c) {\n                    distance_1 = Math.abs((i - left));\n                    flag1 = true;\n                    break;\n                }\n            }\n            for (int right = i; right <= s.length() - 1; right++) {\n                char temp2 = s.charAt(right);\n                if (temp2 == c) {\n                    distance_2 = Math.abs((i - right));\n                    flag2 = true;\n                    break;\n                }\n            }\n            int distance = flag1 && flag2 ? Math.min(distance_1, distance_2) : Math.max(distance_1, distance_2);\n            dis[i] = distance;\n        }\n        return dis;\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度：*O*(*N*^2）\n- 空间复杂度：*O*(*N*)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993554513","body":"### 思路：\n\n用一个LinkList来实现栈(LinkList方便对末尾进行操作，同时也能随机访问每一个节点)，设置一个变量length表示当前栈的长度，一个变量maxSize表示最大长度即可完成初始化，剩下的进栈、出栈和增量操作无非是LinkList的增删改遍历罢了。\n\n### 代码：\n\n```java\nclass CustomStack {\n    LinkedList<Integer> stack;\n    int maxSize;\n    int length;\n\n    public CustomStack(int maxSize) {\n        stack = new LinkedList<>();\n        this.maxSize = maxSize;\n        length = 0;\n    }\n\n    public void push(int x) {\n        if (length < maxSize) {\n            stack.addLast(x);\n            length++;\n        }\n    }\n\n    public int pop() {\n        if (length <= maxSize && length > 0) {\n            length--;\n            return stack.removeLast();\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int idx = Math.min(length, k);\n        for (int i = 0; i < idx; i++) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n### 时空复杂度：\n\n-时间复杂度：初始化（构造函数）、`push` 操作和 `pop` 操作的渐进时间复杂度为 O(1)*O*(1)，`inc` 操作的渐进时间复杂度为 *O*(*k*)。\n\n-空间复杂度：*O*(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994824942","body":"### 思路：\n\n本质上就是括号的匹配，由此可以想到用栈的方法，用一个索引遍历字符串，当遇到数字时，直接进栈(需要`进行解析`，比如字符串“123a”里的123，要让他变为一个单独的元素“123”再进栈，索引跟着移动)；当遇到左括号'['或者字母，直接进栈；当遇到右括号']'，索引+1表示越过当前右括号指向右括号的下一个字符，栈进行连续出栈，用一个中间链表记录中间结果，直到遇见最近的左括号'['为止(此时中间结果逆序，需进行翻转)，这时再执行依次出栈操作，此时的栈顶元素必是解析后的数字，表明对应的字符串应该出现的次数，将上述翻转后的中间结果重复该数字次，再添加进栈。重复上述三个判断，直至索引遍历完字符串，这时只需要把栈中元素依次添加到字符串中即可。\n\n例如：\"23[a2[bc]]\"\n\n栈的变化应该是：                        \n\n- [\"23\",\"[\",\"a\",\"2\",\"[\",\"b\",\"c\"] -> [\"23\",\"[\",\"a\",\"bcbc\"]->.....\n\n### 代码：\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stack = new LinkedList<>();\n        ptr = 0; // 之前陷入死循环是句子int ptr = 0;在此处重新定了ptr(相当于局部变量了)，在getNums()函数里的更新的是上面的全局变量ptr，此处的局部变量没有被更新到\n        while (ptr < s.length()) {\n            if (Character.isDigit(s.charAt(ptr))) { // 一个或多个数字进行解析后直接进栈\n                String digit = getNums(s);\n                stack.addLast(digit);\n            } else if (Character.isLetter(s.charAt(ptr)) || s.charAt(ptr) == '[') {\n                // 左括号'['或字母直接进栈\n                stack.addLast(String.valueOf(s.charAt(ptr++)));\n            } else {\n                // 右括号']'出栈,直至遇见左括号'['\n                ptr++; // 跳过该右括号\n                LinkedList<String> sub = new LinkedList<>();// 用一个中间sub接收，一开始用了Stringbuilder(是整体反转，不是元素反转)\n                while (!stack.getLast().equals(\"[\")) {\n                    sub.addLast(stack.removeLast());\n                }\n                Collections.reverse(sub); // 元素反转\n                String o = getStr(sub);\n                stack.removeLast(); // 将左括号出栈\n                int repTime = Integer.parseInt(stack.removeLast()); // 此时栈顶为当前 sb 对应的字符串应该出现的次数\n                StringBuilder sb = new StringBuilder();\n                while (repTime-- > 0) {\n                    // sb.append(sb); //此处重复添加了\n                    sb.append(o);\n                }\n                stack.addLast(sb.toString());\n            }\n        }\n\n        return getStr(stack);\n\n    }\n\n    public String getNums(String s) {\n        // 将字符串了的长数字进行解析\n        StringBuilder digit = new StringBuilder();\n        while (Character.isDigit(s.charAt(ptr))) {\n            digit.append(s.charAt(ptr++));\n        }\n        return digit.toString();\n    }\n\n    public String getStr(LinkedList<String> list) {\n        StringBuilder sb = new StringBuilder();\n        for (String s : list) {\n            sb.append(s);\n        }\n        return sb.toString();\n    }\n}\n```\n\n### 时空复杂度：\n\n- 时间复杂度：*O*(*n*)，n为字符串的长度\n- 空间复杂度：*O*(*n*)，用了一个辅助栈","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995497995","body":"### 思路：\n\n用两个栈来实现一个队列，一个用来专注于进，一个用来专注于出。\n\n* 初始化队列：即初始化两个栈。\n* 入队：直接在栈1入栈即可。\n* 出队：当栈2不空时，栈2直接出栈；当栈2为空，栈1不为空时，将栈1元素依次出栈再入栈2，最后对栈2出栈即可；当栈1和栈2均为空，这时表示是一个空队列，返回值-1，表示出队失败。\n* 队列判空：判断栈1和栈2的长度是否都为0即可。\n\n### 代码：\n\n```java\nimport java.util.LinkedList;\n\nclass MyQueue {\n    LinkedList<Integer> stack1;\n    LinkedList<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new LinkedList<>();\n        stack2 = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        stack1.addLast(x);\n    }\n\n    public int pop() {\n        if (stack2.size() != 0) return stack2.removeLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.removeLast();\n        }\n        return -1;\n    }\n\n    public int peek() {\n        if (stack2.size() != 0) return stack2.getLast();\n        else if (stack1.size() != 0) {\n            while (stack1.size() != 0) {\n                stack2.addLast(stack1.removeLast());\n            }\n            return stack2.getLast();\n        }\n        return -1;\n    }\n\n    public boolean empty() {\n        return stack1.size() == 0 && stack2.size() == 0;\n    }\n}\n\n/*\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n\n### 时空复杂度：\n\n- 时间复杂度：\n  - 初始化队列：*O*(1)\n  - 入队：*O*(1)\n  - 出队：*O*(1)，最坏*O*(n)\n  - 判空：*O*(1)\n- 空间复杂度：*O*(1),只考虑额外消耗的空间。","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bigboom666":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991861963","body":"### 思路\n- k转为数组，处理两个数组的相加。\n- 双指针移动计算两个数组，标志位处理进位，结果存入stack，最后转为list\n\n### 代码\n```java\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        int[] numK = intToArray(k);\n        int a = num.length - 1;\n        int b = numK.length - 1;\n        boolean isUp = false;\n        Stack<Integer> stack = new Stack();\n        List<Integer> list = new LinkedList();\n        while(a>=0 || b>=0 || isUp){\n            int result = 0;\n            if(isUp){\n                result = 1;\n                isUp = false;\n            }\n            if(a <0 && b<0){\n                //result += 0;\n            }else if(a <0){\n                result += numK[b];\n            }else if(b <0){\n               result += num[a];\n            }else{\n                result += num[a] + numK[b];\n            }\n            a--;\n            b--;\n\n            if(result >= 10){\n                isUp = true;\n            }\n            stack.push(result % 10);\n            System.out.print(\"stack: [\");\n            System.out.print( result % 10);\n            System.out.print(\"]\");\n        }\n\n        while(!stack.isEmpty()){\n            list.add(stack.pop());\n        }\n        return list;\n    }\n\n    public int[] intToArray(int k) {\n        System.out.print(\"intToArray: [\");\n        String temp =  String.valueOf(k);\n        int[] result = new int[temp.length()];\n        for(int i=0; i<temp.length(); i++){\n            result[i] = Integer.parseInt(String.valueOf(temp.charAt(i)));\n             System.out.print(result[i]);\n        }\n        System.out.print(\"]\");\n        return result;\n    }\n```\n\n### 复杂度\nO(3n)  O(2n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992124867","body":"### 思路\n通过正反两次遍历，每次遍历计算当前char与前一个指定的c的下标差。\n\n### 代码\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int cIndex = -1;\n        for(int i=0; i<s.length(); i++){\n            if(s.charAt(i) == c){\n                result[i]=0;\n                cIndex = i;\n                continue;\n            }\n\n            if(cIndex == -1){\n                result[i]=-1;\n                continue;\n            }else{\n                result[i]=i-cIndex;\n            }\n        }\n\n\n        cIndex = -1;\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i) == c){\n                result[i]=0;\n                cIndex = i;\n                continue;\n            }\n            if(cIndex != -1){\n                int temp = cIndex -i;\n                if(result[i]==-1 || temp < result[i] ){\n                    result[i]=temp;\n                }\n                \n            }\n        }\n\n\n        return result;\n    }\n}\n\n### 复杂度\nO(n) O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993579886","body":"### 思路\n数组模拟栈，用变量记录index，标志栈顶。\n\n### 代码\nclass CustomStack {\n    int[] mStack;\n    int top = -1;\n    public CustomStack(int maxSize) {\n        mStack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(top < mStack.length-1){\n            mStack[++top] = x;\n        }\n       \n    }\n    \n    public int pop() {\n        if(top>=0){\n            return mStack[top--];\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int temp = top<k-1?top:k-1;\n        for(int i=0;i<=temp;i++){\n            mStack[i] +=val;\n        }\n    }\n}\n\n### 复杂度\n- push/pop 时间 O(1)\n- increment 时间 O(k)\n- 空间 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"darkpmm":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991863806","body":"class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        int len=num.size();\n        vector<int> ans;\n        for(int i=len-1 ; i>=0 ; --i){\n            int sum = num[i]+k%10;\n            k = k/10;\n            if(sum>=10){\n                sum = sum%10;\n                k++;\n            }\n            ans.push_back(sum);\n        }\n        while(k>0){\n            ans.push_back(k%10);\n            k=k/10;\n        }\n        reverse(ans.begin(),ans.end());\n        return ans;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pf135145":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991864094","body":"### 思路\r\n\r\n因为js在大数计算时有精度问题，因此把每一位单独计算\r\n\r\n把k转化成数组方便计数\r\n\r\n在这里为了方便所以把数组反转了\r\n\r\n考虑首位可能会出现进位问题再单独处理下\r\n\r\n\r\n### 代码\r\n\r\n``` javascript\r\nvar addToArrayForm = function(num, k) {\r\n  let over = false;\r\n  let kArr = k.toString().split('');\r\n  let index = 0;\r\n  let newArr = [];\r\n  num.reverse();\r\n  kArr.reverse();\r\n  while (index < num.length || index < kArr.length) {\r\n      let i = num[index] || 0\r\n      let k = Number(kArr[index]) || 0\r\n      let res = i + k\r\n      if (index > 0 && over) {\r\n          res += 1\r\n      }\r\n      if (res >= 10) {\r\n          over = true;\r\n          newArr.push(res - 10)\r\n      } else {\r\n          over = false;\r\n          newArr.push(res)\r\n      }\r\n      index ++\r\n  }\r\n  if (over) newArr.push(1);\r\n  return newArr.reverse()\r\n};\r\n\r\n```\r\n\r\n### 复杂度\r\n\r\n时间复杂度： o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992271708","body":"### 思路\n\n把长字符串转成数组A\n\n先存储目标字符在数组中出现的位置存储为数组B\n\n循环数组A，对比每项和数组B首个数字的差值，若小于零，则取第二位对比两个差值的绝对值，取小的，注意下是否数组B已取完\n\n### 解题\n\n```js\nvar shortestToChar = function(s, c) {\n  let sArr = s.split('');\n  let tarArr = []\n  sArr.forEach((o, idx) => {\n    if (o === c) tarArr.push(idx)\n  })\n  let newArr = []\n  sArr.forEach((o, idx) => {\n    let tarIdx = tarArr[0]\n    if (idx > tarIdx) {\n      if (tarArr.length ==1 || idx - tarIdx < tarArr[1] - idx) {\n        newArr.push(idx - tarIdx)\n      } else {\n        tarArr.shift()\n        newArr.push(tarArr[0] - idx)\n      }\n    } else {\n      newArr.push(tarIdx - idx)\n    }\n  })\n  return newArr\n};\n```\n\n### 复杂度\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)？","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993684809","body":"### 解体\n\n使用数组模拟栈\n\n\n### 代码\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this._stack = [];\n    this._size = maxSize || 0;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this._stack.length < this._size) {\n        this._stack.push(x)\n    } \n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    return this._stack.length > 0 ? this._stack.pop() : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    this._stack.forEach((o, idx) => {\n        if (idx < k) this._stack[idx] += val\n    })\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994904291","body":"### 解题\n\n使用栈的思想遇到右括号“]”时出栈\n\n\n### 代码\n\n```js\nvar decodeString = function(s) {\n  let start = /^(\\d*)\\[/\n  let end = /^\\]/\n  let str = /^[a-z]+/\n  let stack = []\n  let res = ''\n  let index = 0\n  while(index < 10) {\n    if (start.test(s)) {\n      const res = start.exec(s)\n      console.log(res[0], 'start')\n      s = s.replace(res[0], '')\n      stack.push({\n        type: 'number',\n        val: res[1] || 1\n      })\n      console.log(stack, 'start')\n      continue;\n    }\n    if (str.test(s)) {\n      const res = str.exec(s)\n      console.log(res[0], 'str')\n      s = s.replace(res[0], '')\n      stack.push({\n        type: 'string',\n        val: res[0]\n      })\n      console.log(stack, 'str')\n      continue;\n    }\n    if (end.test(s)) {\n      const res = end.exec(s)\n      console.log(res[0], 'end')\n      s = s.replace(res[0], '')\n      let str = stack.pop().val\n      let before = stack.pop()\n      let num = 1;\n      while(before.type == 'string') {\n        str = before.val + str\n        before = stack.pop()\n      }\n      num = before.val\n      stack.push({\n        type: 'string',\n        val: str.repeat(num)\n      })\n      console.log(stack, 'end')\n      continue;\n    }\n    index ++\n  }\n\n  stack.forEach(o => {\n    res = res + o.val\n  }) \n\n  return res\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995903676","body":"### 解题\n\n使用两个栈，用于在pop的时候存储数据\n\n\n### 代码\n\n```js\nvar MyQueue = function() {\n  this._stack = []\n  this._mockStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this._stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  while (this._stack.length) {\n    this._mockStack.push(this._stack.pop())\n  }\n  let res = this._mockStack.pop()\n  while (this._mockStack.length) {\n    this._stack.push(this._mockStack.pop())\n  }\n  return res\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this._stack[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this._stack.length === 0\n};\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luhnn120":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991865405","body":"### 思路\n逐位相加的思路，记录进位数。遍历完k和数组，遍历过程中，数组超出范围时，以0代替当次累加。遍历完毕后，如果存在进位，则将进位数增加到首部。\n### 代码\n```\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n  let i = num.length - 1, carry = 0,res = [];\n  while (i >= 0 || k > 0) { \n    let sum = ( i < 0 ? 0 : num[i] ) + k%10 + carry;\n    if (sum >= 10) {\n      carry = 1;\n      sum = sum % 10;\n    } else { \n      carry = 0\n    }\n    res.push(sum)\n    i--;\n    k = parseInt(k/10)\n  }\n  if (carry === 1) { \n    res.push(carry)\n  }\n  return res.reverse();\n};\n```\n### 复杂度\n时间复杂度：O(MAX(M,N)) M 数组长度，N k长度\n\n空间复杂度：O(MAX(M,N)) M 数组长度，N k长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992496590","body":"### 思路\n正反遍历数组，得到两种情况的距离值取最小值。若目标元素下标为pre，则从左到右遍历得到左邻目标元素距离为pre-i，从右到左遍历的得到右邻目标元素距离为i-pre。注意两次pre的初始值，由于数组长度在1到10^4。取初始值为±(10^4+1),使不存在目标元素时值为最大。\n### 代码\n```\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\n var shortestToChar = function(s, c) {\n  const length = s.length,result = [];\n  let pre = -Math.pow(10,4) - 1\n  for(let i = 0; i < length; i++){\n    if(s[i] === c){\n      pre = i\n    }\n    result.push(i-pre)\n  }\n  pre = Math.pow(10,4) + 1\n  for(let i = length-1; i >=0; i--){\n    if (s[i] === c) { \n      pre = i\n    }\n    let range = pre - i;\n    if (result[i] > range) {\n      result[i] = range\n    }\n  }\n  return result;\n};\n```\n### 复杂度\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993532681","body":"### 思路\n通过数组模拟栈的操作。由于栈的特性，只有数据在出栈时，才会获取到其真正的值。因此对于增量操作采用辅助数组记录下增量值，在出栈时再进行累加，将增量操作的时间复杂度从O(N)将为O(1)\n### 代码\n```\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n  this.maxSize = maxSize;\n  this.stack = [];\n  this.add = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n  if(this.stack.length < this.maxSize){\n    this.stack.push(x)\n  }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n  if(this.stack.length === 0){\n    return -1\n  }\n  let index = this.stack.length - 1\n  let rest = this.add[index] || 0\n  this.add[index] = 0;\n  if (rest) {\n    this.add[index-1] = rest + (this.add[index-1] || 0);\n  }\n  return this.stack.pop() + rest;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n  k = Math.min(this.stack.length, k)\n  if(k > 0){\n    this.add[k-1] = val + (this.add[k-1] || 0)\n  }\n};\n```\n### 复杂度\n时间复杂度：O(1)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994841593","body":"### 思路\n通过栈来进行[]的匹配，逐个遍历，当前字符不为]的进行入栈操作，否则一直出栈直到遇到[字符。如果下一位是数字则遍历直到非数字后进行重复字符串生成，将字符串入栈直到遍历完整个字符串，将栈中元素拼接返回\n### 代码\n```\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n  let len = s.length; stack = []\n  for(let i = 0; i < len; i++){\n    if(s[i] !== ']'){\n      stack.push(s[i])\n    } else {\n      let c = stack.pop()\n      let str = \"\"\n      while(c !== '['){\n        str = c + str \n        c = stack.pop()\n      }\n      let last = stack[stack.length - 1]\n      if(!Number.isNaN(parseInt(last))) {\n        stack.pop()\n        while(!Number.isNaN(parseInt(stack[stack.length - 1]))){\n          last = stack.pop() + last\n        }\n        let result = \"\"\n        for(let j = 0; j < last; j++){\n          result += str\n        }\n        stack.push(result)\n      } else {\n        stack.push(str)\n      }\n    }\n  }\n  return stack.join(\"\");\n};\n```\n### 复杂度\n空间复杂度 O(N)\n时间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995864050","body":"### 思路\n通过栈来模拟队列操作一般情况下在每次pop和peek操作时，需要将所有的元素出栈才能返回目标元素，通过一个缓存栈来将pop和peek操作时出栈的元素依次入栈。此时缓存栈栈顶元素即为队列头部元素。后续pop和peek操作时，如果缓存栈中存在元素，则对缓存栈进行出栈操作，如果不存在元素则对原本的栈内所有元素进行出栈操作保持到缓存栈中。\n### 代码\n```\nvar MyQueue = function() {\n  this.stack = []\n  this.cacheStack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if (this.cacheStack.length === 0) { \n    let c = this.stack.pop()\n    while (c) { \n      this.cacheStack.push(c);\n      c = this.stack.pop();\n    }\n  }\n  return this.cacheStack.pop();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if (this.cacheStack.length === 0) { \n    let c = this.stack.pop()\n    while (c) { \n      this.cacheStack.push(c);\n      c = this.stack.pop();\n    }\n  }\n  return this.cacheStack[this.cacheStack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.cacheStack.length === 0 && this.stack.length === 0\n};\n```\n### 复杂度\n时间复杂度：O(1)，所有元素都只进行两次入栈和两次出栈操作\n空间复杂度：O(N), 两个栈的长度等于目标队列长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"demo410":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991866798","body":"#### 思路\r\n\r\n* 从后往前遍历num数组，同时通过取余获得K的最后一位数，将两个数相加，注意进位。如果两个数的位数不一致，通过补0来继续相加。\r\n\r\n#### 代码\r\n\r\n```java\r\npublic static List<Integer> addToArrayForm(int[] num, int k) {\r\n        Stack<Integer> result = new Stack<>();\r\n        List<Integer> finalResult = new ArrayList<>();\r\n        int l = num.length;\r\n        boolean carry  = false;\r\n\r\n        while (l != 0 || k != 0){\r\n            int a = 0, b = k % 10;\r\n\r\n            if(l != 0) a = num[--l];\r\n\r\n            k /= 10;\r\n\r\n            int c = a + b;\r\n\r\n            if(carry) {\r\n                c += 1;\r\n                carry = false;\r\n            }\r\n\r\n            if(c >= 10) carry = true;\r\n            result.push(c % 10);\r\n        }\r\n\r\n        if (carry) result.push(1);\r\n        while (!result.empty()) finalResult.add(result.pop());\r\n        return result;\r\n    }\r\n```\r\n\r\n#### 复杂度\r\n\r\n* 时间复杂度：时间复杂度主要取决于数组的长度N和K的位数，即O(max(N, len(k)))\r\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992158995","body":"### 思路\n\n* l指向数组中左侧的c的位置，r指向数组中右侧c的位置，计算`Math.min(r - i, i - l)`,注意边界情况\n\n### 代码\n\n```java\n    public static int[] shortestToChar(String s, char c) {\n        int[] result = new int[s.length()];\n        int l = 0, r = 0;\n\n        while (r != s.length()) {\n\n            for (r = l + 1; r < s.length(); r++) {\n                if (s.charAt(r) == c) break;\n            }\n\n            for (int i = l; i < r; i++) {\n                if (l == 0 && s.charAt(0) != c) result[i] = r - i;\n\n                else if (r == s.length() && s.charAt(r - 1) != c) result[i] = i - l;\n\n                else {\n                    result[i] = Math.min(r - i, i - l);\n                }\n            }\n\n            l = r;\n        }\n        return result;\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993130891","body":"### 思路\n\n* 维护一个diff数组，diff[min(K, maxSize)] 代表对数组的前多少个元素相加，在pop的时候将diff数组中的值与栈顶的值相加\n\n### 代码\n\n```java\n  private final int[] innerStack;\n    private final int[] diff;\n    private final int maxSize;\n    private int length;\n\n    public CustomStack(int maxSize) {\n        this.innerStack = new int[maxSize];\n        this.diff = new int[maxSize];\n        this.maxSize = maxSize;\n        this.length = 0;\n    }\n\n    public void push(int x) {\n        if (this.length == this.maxSize) return;\n\n        this.innerStack[this.length++] = x;\n\n    }\n\n    public int pop() {\n        if (this.length == 0) return -1;\n        int res = innerStack[this.length - 1] + diff[this.length - 1];\n\n        if (this.length > 1){\n            diff[this.length - 2] += diff[this.length - 1];\n        }\n        diff[--this.length] = 0;\n\n        return res;\n    }\n\n    public void increment(int k, int val) {\n        int maxInc = Math.min(k, this.length);\n        if (this.length > 0)\n            diff[maxInc - 1] += val;\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：pop、push、increment都是O(1)\n* 空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994565283","body":"### 思路\n\n* 如果遇到 ']'，就一直在栈中找到 '['，将之间的字符连接起来，将 '['前面的数字连接起来作为出现次数再次压栈，遇到数字、字母、'['就直接压栈，最后将栈里的字符串弹出连接起来\n\n### 代码\n\n```java\n public static String decodeString(String s) {\n        LinkedList<String> repeatFrag = new LinkedList<>();\n        LinkedList<String> repeatNumStr = new LinkedList<>();\n        Stack<String> stack = new Stack<>();\n        StringBuilder builder = new StringBuilder();\n\n        int repeat = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == ']') {\n                String c = stack.pop();\n                while (!c.equals(\"[\")) {\n                    repeatFrag.addFirst(c);\n\n                    c = stack.pop();\n                }\n\n                c = stack.peek();\n\n                while (Character.isDigit(c.charAt(0))) {\n                    repeatNumStr.addFirst(String.valueOf(stack.pop()));\n\n                    if (stack.isEmpty()) break;\n                    c = stack.peek();\n                }\n\n                repeat = Integer.parseInt(String.join(\"\", repeatNumStr));\n\n                for (int j = 0; j < repeat; j++) {\n                    stack.addAll(repeatFrag);\n                }\n\n                repeatNumStr.clear();\n                repeatFrag.clear();\n            } else {\n                stack.push(String.valueOf(s.charAt(i)));\n            }\n        }\n\n        return String.join(\"\",stack);\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995374074","body":"### 思路\n\n* 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。\n* push的时候，如果stackout为空，是则直接push到stackin中。否则，将stackout中的元素全pop到stackin中再将x push到栈中\n* pop的时候，判断stackin是否为空，是则直接pop stackout中的元素、否则，将stackin中的元素全pop到stackout中，然后再将stackout中的栈顶元素pop出来\n\n### 代码\n\n```java\n private Stack<Integer> stackIn;\n    private Stack<Integer> stackOut;\n\n\n    public MyQueue() {\n        stackIn = new Stack<>();\n        stackOut = new Stack<>();\n    }\n\n    public void push(int x) {\n        if (stackOut.isEmpty()) {\n            stackIn.push(x);\n        } else{\n          while (!stackOut.isEmpty()){\n              stackIn.push(stackOut.pop());\n          }\n          stackIn.push(x);\n        }\n    }\n\n    public int pop() {\n        \n        if (stackIn.isEmpty()) return stackOut.pop();\n\n        else{\n            while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n            return stackOut.pop();\n        }\n    }\n\n    public int peek() {\n        if (stackIn.isEmpty()) return stackOut.peek();\n\n        else{\n            while (!stackIn.isEmpty()){\n                stackOut.push(stackIn.pop());\n            }\n            return stackOut.peek();\n        }\n    }\n\n    public boolean empty() {\n        return stackIn.isEmpty() && stackOut.isEmpty();\n    }\n```\n\n### 复杂度\n\n* 时间复杂度：每个操作均摊时间复杂度为 `O(1)` ，执行 `n` 个操作的总时间复杂度为 `O(n)`\n* 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"didiyang4759":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867259","body":"思路：\r\nA 的当前位 + B 的当前位 + 进位， 最后判断是否还有进位\r\n\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int n = A.length;\r\n        List<Integer> res = new ArrayList<>(); \r\n        int i = n - 1, sum = 0, carry = 0;\r\n        while (i >= 0 || K != 0) {  \r\n            int x = i >= 0 ? A[i]: 0;\r\n            int y = K != 0 ? K % 10 : 0;              \r\n            sum = x + y + carry;\r\n            carry = sum / 10;\r\n            K = K / 10;\r\n            i--;\r\n            res.add(0, sum % 10);\r\n        }\r\n        if (carry != 0) res.add(0, carry);\r\n        return res;\r\n    }\r\n}\r\n```\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993216884","body":"class CustomStack {\r\n    int[] stack;\r\n    int top;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (top != stack.length - 1) {\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if (top == -1) {\r\n            return -1;\r\n        }\r\n        --top;\r\n        return stack[top + 1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int limit = Math.min(k, top + 1);\r\n        for (int i = 0; i < limit; ++i) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzrebas":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991867485","body":"# Day 1-[989. 数组形式的整数加法](https://leetcode-cn.com/problems/add-to-array-form-of-integer/)\n\n## 思路\n遍历数组A，取出每个元素转换为字符串，再拼在一起，然后转为int整形，再与整数K相加，得出的结果再转为字符串，再遍历每一个元素输出到新的数组中。\n\n\n## 代码(python)\n```python\ndef fun(A,K):\n    a=''.join(str(x) for x in A)\n    b=int(a)+K\n    out=[]\n    for i in str(b):\n        out.append(int(i))\n    print(out)\n\nA = [1,2,0,0]\nK = 34\nfun(A,K)    #[1, 2, 3, 4]\nfun(A = [2,7,4], K = 181)   #[4, 5, 5]\nfun(A = [2,1,5], K = 806)   #[1, 0, 2, 1]\nfun(A = [9,9,9,9,9,9,9,9,9,9], K = 1)   #[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\n## 复杂度\n**时间复杂度：** O(n)，n为数组A的长度。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992248450","body":"### 思路\n1. 先找到字符C在字符串S中的所有的索引位置。\n2. 构建一个新的数组，数组长度为len(S)，对应所有C的索引位置设为0，其他元素先设为None。\n3. 再根据C的索引在对应新数组中0的位置进行排序：\n    - 最左边的0，向左排序\n    - 最右边的0，向右排序\n    - 中间位置的0，向两个0的中间排序\n\n### 代码(Python)\n```python\ndef fun(S,C):\n    C_index=[]\n    out_list=[]\n    for n,i in enumerate(S):\n        out_list.append(None)\n        if i ==C:\n            C_index.append(n)\n            out_list[n]=0\n\n    #从第一个字符C向左排序\n    for n,i in enumerate(range(C_index[0]+1)[::-1]):\n        out_list[n]=i\n    # print(out_list)   #[3, 2, 1, 0, None, 0, 0, None, None, None, None, 0, None, None]\n\n    #从最后一个字符C向右排序\n    for n,i in enumerate(out_list[C_index[-1]:]):\n        out_list[C_index[-1]+n]=n\n    # print(out_list)     #[3, 2, 1, 0, None, 0, 0, None, None, None, None, 0, 1, 2]\n\n    #中间的字符C,向两个C的中间排序\n    for i in range(len(C_index)-1):\n        subtract=C_index[i+1]-C_index[i]\n        if subtract%2==0:\n            division=subtract//2\n        else:\n            division=(subtract-1)//2\n        for j in range(1,division+1):\n            out_list[C_index[i]+j]=j\n            out_list[C_index[i+1]-j]=j\n\n    print(out_list)\n\nS = \"loveleetcodedf\"\nC = 'e'\nfun(S,C)    #[3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0, 1, 2]\n```\n\n### 复杂度分析\n- 时间复杂度： \n- 空间复杂度：\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993519056","body":"### 思路\n在python代码中，可使用list模拟栈，入栈为``list.append()``，出栈为``list.pop()``，切片可修改栈底元素。\n\n\n### 代码(Python)\n```python\nclass CustomStack():\n    def __init__(self,maxSize:int):     #初始化\n        self.maxSize=maxSize\n        self.customstack=[]\n\n    def push(self,x:int):\n        if len(self.customstack)==self.maxSize:\n            # print('已超出栈中最多能容纳的元素数量，无法再增加')\n            pass\n        else:\n            self.customstack.append(x)  #入栈\n\n    def pop(self):\n        if self.customstack==[]:\n            return -1\n        else:\n            stack_top=self.customstack[-1]\n            self.customstack.pop()  #出栈\n            return stack_top    #返回出栈的元素\n\n    def increment(self,k:int,val:int):\n        if len(self.customstack)>=k:   #注意，这里需要对比k与当前栈实际的长度，而不是与栈的最大长度maxSize对比\n            for i in range(k):\n                self.customstack[i]+=val\n        else:\n            self.customstack=[self.customstack[i]+val for i in range(len(self.customstack))]\n\n\ndef obj_API(A,B):\n    C=[]\n    obj=CustomStack(B[0][0])\n    for i in range(len(A)):     #循环A、B，依次进行对应操作\n        if i==0:\n            C.append(None)\n        else:\n            if A[i]=='push':\n                obj.push(B[i][0])\n                C.append(None)\n            elif A[i]=='pop':\n                C.append(obj.pop())\n            elif A[i]=='increment':\n                obj.increment(B[i][0],B[i][1])\n                C.append(None)\n        # print('i:',i,C,obj.customstack)\n    print(C)\n\n\nA=[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\nB=[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n\nobj_API(A,B)    #[None, None, None, 2, None, None, None, None, None, 103, 202, 201, -1]\n\n\n```\n\n### 复杂度分析\n- 时间复杂度：\n- 空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994328303","body":"### 思路\r\n用栈的方式记录字符串元素，因为左右括号的读取是先进后出的顺序\r\n依次遍历字符串中的元素，不是右括号就添加到栈，是右括号就把离栈顶最近的左括号到栈顶的元素取出来处理\r\n解题方法类似于中缀表达式转波兰表达式\r\n\r\n\r\n### 代码(Python)\r\n```python\r\ndef str_decode(s):\r\n    stack=[]\r\n    for i in range(len(s)): #遍历字符串s\r\n        if s[i] != ']':     #如果不为’]‘就添加到栈stack\r\n            stack.append(s[i])\r\n        else:               #为’]‘，就更新栈：从离栈顶最近的'['到栈顶\r\n            end_bracket_index=len(stack)-1-stack[-1::-1].index('[')   #获取离栈顶最近的'['的索引\r\n            end_num=stack[end_bracket_index-1]    #获取离栈顶最近的'['的前面数字的索引\r\n            stack_tail=stack[end_bracket_index+1:]    #获取离栈顶最近的'['到栈顶内的元素\r\n            for n in stack_tail:    #离栈顶最近的'['到栈顶内的元素不能有数字\r\n                if n.isdigit():\r\n                    return '输入错误'\r\n            if not end_num.isdigit():   #左括号前面一定有数字\r\n                return '输入错误'\r\n            stack=stack[:end_bracket_index-1]+(stack_tail*int(end_num))   #更新栈\r\n    return ''.join(x for x in stack)\r\n\r\ns1 = \"3[a]2[bc]\"\r\ns2 = \"3[a2[c]]\"\r\ns3 = \"2[abc]3[cd]ef\"\r\ns4 = \"abc3[cd]xyz\"\r\nprint(str_decode(s1))   #aaabcbc\r\nprint(str_decode(s2))   #accaccacc\r\nprint(str_decode(s3))   #abcabccdcdcdef\r\nprint(str_decode(s4))   #abccdcdcdxyz\r\n\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N),N为字符串s的长度。\r\n- 空间复杂度：\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995618392","body":"### 思路\r\n在python中，可用list模拟队列。或者用模块collections.deque。\r\n但要用栈的方式实现队列查看队首元素和删除队首元素，需2个栈，一个存栈的输入，一个存栈的输出。\r\n\r\n\r\n### 代码(Python)\r\n```python\r\nclass MyQueue():\r\n    def __init__(self):\r\n        self.queue=[]\r\n        self.out_queue=[]\r\n\r\n    def push(self,x:int):\r\n        self.queue.append(x)    #尾部插入\r\n        print('queue:',self.queue)\r\n\r\n    def stack_exchange(self,x:list,y:list): #输入栈与输出栈交换\r\n        while x != []:    #循环遍历x的栈顶，依次取出存入y栈中\r\n            stack_top=x.pop()      #x删除栈顶，并返回删除的值\r\n            y.append(stack_top)    #y插入x删除的栈顶\r\n\r\n    def empty(self):    #判断队列是否为空\r\n        if self.queue == []:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def peek(self):\r\n        if self.empty() == True:\r\n            print(f'空栈，{self.__class__.__name__}.peek操作无效')\r\n        else:\r\n            self.stack_exchange(self.queue,self.out_queue)  #交换栈\r\n            print(self.out_queue[-1])   #返回栈顶\r\n            self.stack_exchange(self.out_queue,self.queue)  #再交换回去，还原\r\n            # print('queue:',self.queue)\r\n\r\n    def pop(self):\r\n        if self.empty() == True:\r\n            print(f'空栈，{self.__class__.__name__}.pop操作无效')\r\n        else:\r\n            self.stack_exchange(self.queue,self.out_queue)  #交换栈\r\n            print(self.out_queue.pop())    #删除输出栈的栈顶\r\n            self.stack_exchange(self.out_queue,self.queue)  #再交换回去，还原，此时已删除输入栈的栈顶\r\n            # print('queue:',self.queue)\r\n\r\n\r\nmy_queue=MyQueue()\r\nmy_queue.push(1)    #queue: [1]\r\nmy_queue.push(2)    #queue: [1, 2]\r\nmy_queue.peek()     #1\r\nmy_queue.pop()          #1\r\nprint(my_queue.queue)   #[2]\r\nprint(my_queue.empty()) #False\r\nmy_queue.pop()          #2\r\nprint(my_queue.empty()) #True\r\nprint(my_queue.queue)   #[]\r\n```\r\n\r\n### 复杂度分析\r\n- 时间复杂度：O(N),N为队列的长度。\r\n- 空间复杂度：\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hacker90":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991868483","body":"\n思路：\n-\n按位相加，长度先以已知数组为标准处理\n\n\n代码\n-\nclass Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n       \n  \n       int i = 0;\n       int sum = 0;\n       vector<int> res;\n       if(k == 0)return num;\n       for(i = num.size()-1;(i>=0);--i)\n       {\n           sum = num[i] + k%10;\n           k = k/10;\n           if(sum >= 10 ){\n               k = k + 1;\n               sum = sum - 10;\n           }\n           res.push_back(sum);\n       }\n        for(;k>0;k = k/10) {\n    \n               res.push_back(k%10);\n          \n        }\n        reverse(res.begin(),res.end());\n       return res;\n    }\n};\n\n\n复杂度分析\n-\n\n空间复杂度：O(n)\n\n\n时间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992577643","body":"### 思路\n\n题目是计算到指定字符的绝对距离，考虑到字符有在左边，有在右边，即从左开始遍历，有从右开始遍历，遍历中取两者最小值即求解\n\n当从左开始遍历，没有找到字符默认距离为字符串长度\n当从右开始遍历，为保持没找到时为最大值，设置为字符串的2倍(确保第一个没找到，值为保持字符串长度)\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        \n        int len = s.size();\n        int i;\n        int p_match = -len;\n        \n        vector<int> res(len,len);\n        for(i = 0;i<len;i++) {\n            if(s[i]==c)p_match = i;\n            res[i] = min(res[i],i-p_match);\n        }\n        int rlen = 2*len;\n        for(i = len-1;i>=0;i--) {\n            if(s[i]==c)rlen = i;\n            res[i] = min(res[i],rlen-i);\n        }\n        cout<<res[0];\n        return res;\n    }\n};\n\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993590949","body":"### 思路\n\n用数组模拟\n\n### 代码\n\n\n```cpp\nclass CustomStack {\npublic:\n    int top = -1;//初始值的栈底下面即-1（0开始才有数据，再下面为-1）\n    vector<int> v; \npublic:\n    CustomStack(int maxSize) {\n        v.resize(maxSize);\n    }\n    \n    void push(int x) {\n        \n        if(top+2 <= v.size())//必须加上判断，不然会数组越界，初始top==-1,总长度为top+1（top为数据下标，加1为真实长度  这里为2是因为下面还要自加1\n        v[++top] = x;\n    }\n    \n    int pop() {\n        if(top == -1)return -1;\n        return v[top--];\n        \n    }\n    \n    void increment(int k, int val) {\n        int i;\n        for(i = 0;i < min(k,top+1);i++)\n                v[i] = v[i] + val;\n\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994884112","body":"### 思路\n\n[]用栈\n\n### 代码\n\n\n```cpp\nclass Solution {\npublic:\n\n    string decodeString(string s) {\n        int len = s.size();\n        int num = 0;\n        stack<int> numstack;\n        stack<string> strstack;\n        string cur = \"\";\n        string result = \"\";\n        for(int i=0; i<len; ++i)\n        {\n            if(s[i]>='0' && s[i]<='9')\n            {\n                num = 10*num + s[i] - '0';\n            }\n            else if(s[i] == '[')\n            {\n                numstack.push(num);\n                strstack.push(cur);\n                num = 0;\n                cur.clear();\n            }\n            else if((s[i]>='a' && s[i]<='z') || (s[i]>='A' && s[i]<='Z'))\n                cur += s[i];\n            else if(s[i] == ']')\n            {\n                int k = numstack.top();\n                numstack.pop();\n                for(int j=0; j<k; ++j)\n                    strstack.top() += cur;\n                cur = strstack.top();\n                strstack.pop();\n            }\n        }\n        result = result + cur;\n        return result;     \n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack* obj = new CustomStack(maxSize);\n * obj->push(x);\n * int param_2 = obj->pop();\n * obj->increment(k,val);\n */\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995884441","body":"### 思路\n\n用采用两个栈，一个栈输入，一个栈输出\n\n### 代码\n\n\n```cpp\nclass MyQueue {\npublic:\n    stack<int> sIn;\n    stack<int> sOut;\npublic:\n    MyQueue() {\n        sIn =  stack<int>();\n        sOut =  stack<int>();\n    }\n    \n    void push(int x) {        \n        sIn.push(x);\n        \n    }\n    \n    int pop() {\n        \n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        sOut.pop();\n        return result;\n\n            \n    }\n    \n    int peek() {\n        if(sOut.empty()) {//如果输出栈为空，则从输入栈中取数据\n          \n                while(!sIn.empty())\n                {\n                sOut.push(sIn.top());\n                sIn.pop();\n                }\n           \n        }   \n        int result = sOut.top();\n        \n        return result;\n    }\n    \n    bool empty() {\n        return (sIn.empty()&&(sOut.empty()));//两个为空才为空\n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为栈中数据长度。\n- 空间复杂度：O(N) 两个栈的空间\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alvinzhouoops":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991869153","body":"如果直接在数组A上做加法和进位，如果和的长度大于A，需要在A前面插入元素，在数组中不太好实现，所以还是要用新的数组来存放。\npython\nclass Solution{\n    def AddListAndInt(int[] A, int K):\n        n = len(A)\n        sum = A[0]\n        for i in range(1, n):\n            sum += sum*10 + A[i]\n       sum = sum + K\n       tem = []\n       while(sum > 0):\n           item = sum%10\n           tem.append(item)\n           sum = sum//10\n       return tem[::-1]\n     \n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992020789","body":"\r\n```\r\nClass Solution:\r\n    def getDisFromStr(self, String, C):\r\n        n = len(String)\r\n        res = [n for _ in range(n)]\r\n        l = r = 0\r\n        for r in range(n):\r\n            if String[r] == C:\r\n                while l <= r:\r\n                    res[l] = r - l\r\n                    l += 1\r\n       r = n -1\r\n       for l in range(n-1, -1, -1):\r\n           if String[l] == C:\r\n               while r >= l:\r\n                   res[r] = min(res[r], r-l)\r\n                   r -= 1\r\n      return res\r\n```\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993261850","body":"class CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994314996","body":"```\r\nclass Solutions:\r\n    def DecodeString(s):\r\n        def decode(index):\r\n            res = ''\r\n            count = 0\r\n            while index < len(s):\r\n                if 'a' <= s[index] <= 'z':\r\n                    res += s[index]\r\n                    index += 1\r\n                elif '0' <=  s[index] < '10':\r\n                    count = count*10 + int(s[index])\r\n                    index += 1\r\n                elif s[index] == '[':\r\n                    index += 1\r\n                    res += decode(index)\r\n                 elif s[index] == ']':\r\n                     index += 1\r\n                     return res\r\n            return res\r\n        index = 0\r\n        return decode(index)        \r\n```        \r\n\r\n        时间复杂度：O(n)\r\n        空间复杂度： O(n)\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fredxxj":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991869799","body":"# 用python处理起来非常简单，先试试\n\n```\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n        n = 0\n        for i in num:\n            n = n * 10 + i\n        n += k\n        return [int(ch) for ch in str(n)]\n```\n\n\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992549208","body":"### 思路：先得到所有字符的索引列表，然后从头开始遍历，建立下边界和上边界两个变量，如果当前索引小于上边界，则不需要调整边界，否则将上边界改为下边界，上边界取索引当中的下一个值，另外处理好索引两端即可\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        len_s = len(s)\n        dis = [i for i in range(len_s) if s[i] == c]\n        j = 0\n        lower, upper = - 2 * len_s, dis[j]\n        result = []\n        for i in range(len_s):\n            if i > upper:\n                lower = upper\n                if j < len(dis) - 1:\n                    j += 1\n                    upper = dis[j]\n                else:\n                    upper = 2 * len_s\n            result.append(min(upper - i, i - lower))\n        return result\n```\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993510551","body":"### 用一个count记录实际内容的数量即可\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxsize = maxSize\n        self.count = 0\n        self.ls = [None] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.count == self.maxsize:\n            return\n        self.ls[self.count] = x\n        self.count += 1\n\n    def pop(self) -> int:\n        if self.count == 0:\n            return -1\n        self.count -= 1\n        return self.ls[self.count]\n\n    def increment(self, k: int, val: int) -> None:\n        length = self.count if self.count < k else k\n        for i in range(length):\n            self.ls[i] += val\n```","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995759559","body":"### Python原生的list可以完美实现栈的功能，用两个列表互相倒腾就可以实现队列了\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.listA = []\n        self.listB = []\n\n    def push(self, x: int) -> None:\n        self.listA.append(x)\n\n    def pop(self) -> int:\n        if self.listB:\n            return self.listB.pop()\n        else:\n            while self.listA:\n                self.listB.append(self.listA.pop())\n            return self.listB.pop()\n\n    def peek(self) -> int:\n        if self.listB:\n            return self.listB[-1]\n        else:\n            while self.listA:\n                self.listB.append(self.listA.pop())\n            return self.listB[-1]\n\n    def empty(self) -> bool:\n        if not self.listA and not self.listB:\n            return True\n        return False\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chenyaohn":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991870273","body":"### 思路\n\n从n-1至0开始遍历A数组，将其与K对应位置上的进行累加（通过取余获取K各个位置上的值,K%10,(int)(k/10)），如大于等于10则需进位+1，flag为进位标志。\n当K位数大于A数组长度时，需将K的剩余位置的值也添加至结果集合中，同时也需要判断进位。\n最后当A数据与K全部遍历完毕后，如还有进位，则需于结果集合中再度添加1。\n\n### 代码\n\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> list = new ArrayList<Integer>();\n        boolean flag = false; // 判断是否需要进位+1\n        for (int i = num.length-1; i >=0 ; i--) {\n                if(k==0){\n                    int curValue = flag ? num[i]+1:num[i];\n                    flag = curValue>=10;\n                    list.add(flag?curValue-10:curValue);//进位则加1\n                }else {\n                    int n = k % 10;//k最后一位\n                    int curValue = flag ? num[i]+n+1:num[i]+n;\n                    flag = curValue>=10;\n                    list.add(flag ?curValue-10:curValue);\n                    k /= 10;\n                }\n            }\n\n        while (k!=0){//num数组已累加完毕，k未累加完毕\n            int n = k%10;//k最后一位\n            int curValue = flag ? n+1:n;\n            flag = curValue>=10;\n            list.add(flag?curValue-10:curValue);\n            k/=10;\n        }\n        //k已累加完毕，仍然需要进位，则结果list add 1（如9+1=10这种情况）\n        if(k==0&&flag){\n            list.add(1);\n        }\n        Collections.reverse(list);\n        return list;\n    }\n```\n\n**复杂度分析**\n- 时间复杂度：O(max(A,K))，其中 A 为数组A长度,k为k位数。\n- 空间复杂度：O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992216549","body":"### 思路\n最开始思路是获取s[i]到s中每个c字符位置，取最短的长度。实际上这里增加了很多重复比较，导致时间复杂度变高。\n查看官网题解，O(N)时间复杂度的思路是从左至右找出上一次c字符出现位置，并获取其距离，再从右至左找出上一次c字符出现位置获取其距离，与从左至右的距离比较，最终结果取最短的那个。\n### 代码\n```java\n//O(n^2>)时间复杂度\npublic int[] shortestToChar(String s, char c) {\n        int [] res = new int[s.length()];\n        for (int i = 0; i < res.length; i++) {\n            res[i] = 105;\n            for (int j = 0; j < s.length() && res[i] != 0; j++) {\n                if(s.charAt(j)==c && Math.abs(i-j)<=res[i]){\n                    res[i] = Math.abs(i-j);\n                }\n            }\n\n        }\n        return res;\n    }\n//O(n)时间复杂度\n public int[] shortestToChar2(String s, char c) {\n        int [] res = new int[s.length()];\n        int prev = 105;\n        for (int i = 0; i < res.length; i++) {\n\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            res[i] = Math.abs(i-prev);\n        }\n\n        for (int i = res.length-1; i >=0 ; i--) {\n            if(s.charAt(i)==c){\n                prev = i;\n            }\n            res[i] =Math.min(Math.abs(i-prev),res[i]);\n        }\n        return res;\n    }\n```\n### 复杂度\n时间复杂度： O(n <sup>2</sup> )\n空间复杂度： O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993341981","body":"### 思路\n由题可知，长度固定的栈，考虑用数组实现。  \n定义一个maxSize和curSize分别表示栈的最大容量以及当前容量。  \n入栈时判断是否超过最大容量，并将值以逆序下标存入数组中，同时curSize+1；出栈时根据当前容量及最大容量算出栈顶的值在数组中位置，即下标为maxSize-curSize，同时curSize-1。  \n实现increment()方法时，判断curSize是否大于增量k。\n### 代码\n```java\nclass CustomStack {\n    int curSize;\n    int maxSize;\n    int[] elements;\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.elements = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if(curSize<maxSize){\n            curSize++;\n            elements[maxSize-curSize]=x;\n        }\n    }\n\n    public int pop() {\n        int top = -1;\n        if(curSize!=0){\n            top = elements[maxSize-curSize];\n            elements[maxSize-curSize] = 0;\n            curSize--;\n        }\n        return top;\n    }\n\n    public void increment(int k, int val) {\n        for (int i = maxSize-1; i >= maxSize-(curSize>k?k:curSize)&&k>0&&curSize>0; i--) {\n            elements[i] += val;\n        }\n    }\n\n}\n```\n### 复杂度分析\n时间复杂度： push()==>O(1)；pop==>O(1)；increment()==>O(k)  \n空间复杂度：O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994686550","body":"### 思路\n因为有嵌套的情况存在，考虑使用递归处理。  \n判断字符串中是否还有[存在，如存在截取[字符截取右边的字符串，通过递归方法找到最里层[]中的字符，根据规则解码完毕后，一层层向外围处理（代码中利用了java中indexOf(str)方法只会取出字符串中首次出现的位置）。  \n需注意k可能有多位\n### 代码\n```java\n public String decodeString(String s) {\n\n        StringBuilder sb = new StringBuilder();\n        if(s.indexOf(\"[\")>-1){\n            sb.append(s.substring(0,kIndex(s,s.indexOf(\"[\")-1)));\n            sb.append(deal(s.substring(s.indexOf(\"[\")+1),Integer.parseInt(s.substring(kIndex(s,s.indexOf(\"[\")-1),s.indexOf(\"[\")))));\n        }else {\n            return s;\n        }\n\n        return sb.toString();\n    }\n//k可能不止一位数，算出k的起始点下标\n    public int kIndex(String s,int index){\n        int i = index-1;\n        for (; i >=0 ; i--) {\n            if(s.charAt(i)<'0' || s.charAt(i)>'9'){\n                break;\n            }\n        }\n        i++;\n        return i;\n    }\n\n    public String deal(String s,int count){\n        while (s.indexOf(\"[\")>-1){\n            s=s.substring(0,kIndex(s,s.indexOf(\"[\")-1))+deal(s.substring(s.indexOf(\"[\")+1),Integer.parseInt(s.substring(kIndex(s,s.indexOf(\"[\")-1),s.indexOf(\"[\"))));\n        }\n        //除最外层[]外，已经全部解码完毕\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < count; i++) {\n            sb.append(s.substring(0,s.indexOf(\"]\")));\n        }\n        sb.append(s.substring(s.indexOf(\"]\")+1));\n\n        return sb.toString();\n    }\n```\n### 复杂度分析\n时间复杂度：O(n),n为k之和  \n空间复杂度：O(n) 大概是吧...","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995754280","body":"### 思路\n题目要求使用两个栈实现队列效果。  \n栈的特性为先进后出，队列特性为先进先出。所以入栈时需要将元素放入栈顶。  \n这里先将元素放入栈2中，通过栈2的pop()方法获取栈顶元素放入栈1的栈底位置。从而实现栈1的pop()方法取出的是队列的末尾元素。\n### 代码\n```java\n //栈1 最终存放的栈\nclass MyQueue {\n\n    //栈1 最终存放的栈\n    Stack<Integer> stack1 = new Stack<Integer>();\n    //栈2\n    Stack<Integer> stack2 = new Stack<Integer>();\n\n    public MyQueue() {\n\n    }\n    public void push(int x) {\n        if(stack1.empty()){\n            stack1.push(x);\n            return;\n        }\n        while (!stack1.empty())\n            stack2.push(stack1.pop());\n        \n        stack2.push(x);\n\n        while (!stack2.empty())\n            stack1.push(stack2.pop());\n\n\n    }\n    //删除队顶元素\n    public int pop() {\n        return stack1.pop();\n    }\n\n    public int peek() {\n        return stack1.peek();\n    }\n\n    public boolean empty() {\n        return stack1.empty();\n    }\n}\n```\n### 复杂度分析\n时间复杂度：push()==>O(n);pop()==>O(1);peek()==>O(1);empty()==>O(1)。队列push()方法可能存在多个栈的push()和pop()操作，由于栈的push和pop操作为O(1)，假设栈容量为n，所以队列的push()方法也应该可以近似为O(n);  \n空间复杂度：push()==>O(n);pop()==>O(1);peek()==>O(1);empty()==>O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"eliassama":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991872005","body":"## 整体思路\n\n整个题可以看作是一个纯粹的数字相加的题，因为不管是数字还是数组，都是有序。\n\n如1024这个数，不管是number类型的1024还是数组类型的 [1,0,2,4]都是一样的，不同的只是展现形式。\n\n所以这道题的关键点在于采用哪种形式进行计算，以及如何转换为最终要的数组形式。其实计算反而不重要。\n\n在解题时需要注意下溢出问题，这个题的测试用例是会有大数的，部分编程语言是不支持大数的 ( 如js的int32只支持18位以内的精确大数 ) ，所以计算要取巧。\n\n\n\n### 解题思路\n\n采用古老而笨拙的按位进制法，即以numArray作为遍历条件，从最低位到最高位依次与k的最低位到最高位进行相加。\n\n在相加的过程中有些东西需要注意：\n\n+ 因为每次相加都是单位数相加，所以最大的值为18 ( 9 + 9 )。而每个元素只能承载单位数，所以会向前进一，所以实际最大值为19 ( 9 + 9 + 1 )。但是这个数不会超过19。所以要考虑两点：\n  + 除了个位数外，如果上次相加的数有进位的，则每次相加时都要加上进位。\n  + 如果每次相加的结构需要进位的，需要记录在下一次相加时加上。\n+ 因为以numArray作为遍历条件，所以可能会出现下列两种情况从而导致溢出问题，需要考虑进去：\n  + k的值的位数可能会比numArray的位数大，比如[2,1]和3600。\n  + 两个数相加，最后要整体向前进一位，比如[9,9,9]和1\n\n\n\n#### 版本一\n\n##### Code\n\n```typescript\nfunction addToArrayForm(numArray: number[], k: number): number[] {\n\n    const KStr: string = String(k)\n    let numArrayIndex: number = numArray.length - 1\n    let KStrIndex: number = KStr.length - 1\n    let lastNum:number = 0\n\n    for(;numArrayIndex > -1; --numArrayIndex, --KStrIndex){\n        numArray[numArrayIndex] += (parseInt(KStr[KStrIndex]) || 0) + lastNum\n        lastNum = 0\n        if(numArray[numArrayIndex] > 9){\n            numArray[numArrayIndex] -= 10\n            lastNum = 1\n        }\n    }\n    \n    if(KStrIndex > -1){\n        let overflowStr: string = String(parseInt(KStr.substring(0, KStrIndex + 1)) + lastNum)\n        KStrIndex = overflowStr.length - 1\n        lastNum = 0\n        const overflowArray: number[] = []\n        for(;KStrIndex > -1; --KStrIndex){\n            overflowArray.push(parseInt(overflowStr[KStrIndex]))\n        }\n        overflowArray.reverse()\n        numArray = [...overflowArray,...numArray]\n    }\n\n    if(lastNum === 1){\n        numArray = [1,...numArray]\n    }\n\n    return numArray\n};\n```\n\n\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度。\n- 空间复杂度：O(N)，其中 N 为 numArray 加 k 的长度，并有可能会在此基础上 + 1。\n\n\n\n#### 版本二\n\n##### Code\n\n```typescript\nfunction addToArrayForm(numArray: number[], k: number): number[] {\n\n    const kArray: string[] = String(k).split(\"\")\n    let kIndex: number = kArray.length - 1\n    let nIndex: number = numArray.length - 1\n    const resultArray: number[] = []\n\n    let lastNum:number = 0\n    for(;kIndex > -1 || nIndex > -1 ; --kIndex, --nIndex){\n        let result = (parseInt(kArray[kIndex]) || 0) + (numArray[nIndex] || 0) + lastNum\n        lastNum = 0\n        if(result > 9){\n            result -= 10\n            lastNum = 1\n        }\n        resultArray.push(result)\n\n        if(kIndex <= 0 && nIndex <= 0 && lastNum === 1){\n            resultArray.push(1)\n        }\n\n    }\n    \n    return resultArray.reverse()\n};\n```\n\n\n\n##### 复杂度分析\n\n- 时间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度。\n- 空间复杂度：O(N)，其中 N 为 numArray 或 k 的最大长度，并有可能会在此基础上 + 1。","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994828432","body":"### 整体思路\n\n 这个题有点像是编译时，将代码进行解释的操作。也可以看成是一种压缩的操作。这种一般会采用栈来做比较好一点。\n\n因为这个需要从里到外依次执行，如 `\"3[a2[c]]\"`，会先执行`2[c]`，再执行`3[a2[c]]`。而栈正好符合这个特性，即先进后出。\n\n### 解题思路\n\n整体需要将数字、字符进行压栈，每次压栈以`[`为分界，同时压入`[`之前的数字和`]`之后的字符。\n\n在`]`时代表要出栈，出栈后就紧接着去计算当前栈顶的值，然后依次取栈计算值。\n\n\n\n##### Code\n\n```typescript\nfunction decodeString(s: string): string {\n\n    const stack : string[][] = []\n    let multi : number = 0\n    let resultStr : string = \"\"\n\n    let strIndex : number = 0\n    for (; strIndex < s.length; ++strIndex) {\n        let strSingle = s[strIndex]\n        switch (strSingle) {\n            case \"[\": {\n                stack.push([`${multi}`, resultStr])\n                resultStr = \"\"\n                multi = 0\n                break\n            }\n            case \"]\": {\n                let [_multi, _resultStr] = stack.pop()\n                resultStr = _resultStr + new Array(parseInt(_multi )+1).join(resultStr)\n                break\n            }\n            default:\n                if ( !isNaN(parseInt(strSingle)) ){\n                    multi = multi * 10 + parseInt(strSingle)\n                }else {\n                    resultStr += strSingle\n                }\n        }\n    }\n\n    return resultStr\n\n}\n\n```\n\n\n\n##### 复杂度分析\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"noperoc":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991873365","body":"\n## 题目地址(989. 数组形式的整数加法)\n\nhttps://leetcode-cn.com/problems/add-to-array-form-of-integer/\n\n## 题目描述\n\n```\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。\n\n给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n\n \n\n示例 1：\n\n输入：A = [1,2,0,0], K = 34\n输出：[1,2,3,4]\n解释：1200 + 34 = 1234\n\n\n示例 2：\n\n输入：A = [2,7,4], K = 181\n输出：[4,5,5]\n解释：274 + 181 = 455\n\n\n示例 3：\n\n输入：A = [2,1,5], K = 806\n输出：[1,0,2,1]\n解释：215 + 806 = 1021\n\n\n示例 4：\n\n输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1\n输出：[1,0,0,0,0,0,0,0,0,0,0]\n解释：9999999999 + 1 = 10000000000\n\n\n \n\n提示：\n\n1 <= A.length <= 10000\n0 <= A[i] <= 9\n0 <= K <= 10000\n如果 A.length > 1，那么 A[0] != 0\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- \n\n## 思路\n- 模拟竖式 逐位相加  \n## 关键点\n\n-  最后一位剩余进位别忘了加\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        ArrayList<Integer> kk = new ArrayList<>();\n        while(k != 0){\n            int tmp = k % 10;\n            k = k / 10;\n            kk.add(0,tmp);\n        }\n        int ml = num.length;\n        int kl = kk.size();    \n        ArrayList<Integer> ans = new ArrayList<>();  \n        int flag = 0;\n        while(ml != 0 && kl != 0){\n            int tmp = num[ml-1] + kk.get(kl-1) + flag;\n            if(tmp >= 10){\n                flag = 1;\n                tmp -= 10;\n            }\n            else\n                flag = 0;\n            ans.add(0, tmp);\n            kl--;\n            ml--;\n        } \n        if(ml != 0){\n            for(int i = ml-1; i>=0 ; i--){\n                int tmp = num[i];\n                if(flag == 1){\n                    tmp++;\n                    flag = 0;\n                }\n                if(tmp == 10){\n                    tmp = 0;\n                    flag = 1;\n                }\n                ans.add(0, tmp);\n            }\n        }else if(kl != 0){\n            for(int i = kl-1; i>=0 ; i--){\n                int tmp = kk.get(i);\n                if(flag == 1){\n                    tmp++;\n                    flag = 0;\n                }\n                if(tmp == 10){\n                    tmp = 0;\n                    flag = 1;\n                }\n                ans.add(0, tmp);\n            }\n        }\n        if(flag == 1){\n            ans.add(0, 1);\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992375175","body":"\n## 题目地址(821. 字符的最短距离)\n\nhttps://leetcode-cn.com/problems/shortest-distance-to-a-character/\n\n## 题目描述\n\n```\n给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。\n\n返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。\n\n两个下标 i 和 j 之间的 距离 为 abs(i - j) ，其中 abs 是绝对值函数。\n\n \n\n示例 1：\n\n输入：s = \"loveleetcode\", c = \"e\"\n输出：[3,2,1,0,1,0,0,1,2,2,1,0]\n解释：字符 'e' 出现在下标 3、5、6 和 11 处（下标从 0 开始计数）。\n距下标 0 最近的 'e' 出现在下标 3 ，所以距离为 abs(0 - 3) = 3 。\n距下标 1 最近的 'e' 出现在下标 3 ，所以距离为 abs(1 - 3) = 2 。\n对于下标 4 ，出现在下标 3 和下标 5 处的 'e' 都离它最近，但距离是一样的 abs(4 - 3) == abs(4 - 5) = 1 。\n距下标 8 最近的 'e' 出现在下标 6 ，所以距离为 abs(8 - 6) = 2 。\n\n\n示例 2：\n\n输入：s = \"aaab\", c = \"b\"\n输出：[3,2,1,0]\n\n\n \n\n提示：\n1 <= s.length <= 104\ns[i] 和 c 均为小写英文字母\n题目数据保证 c 在 s 中至少出现一次\n```\n\n## 前置知识\n\n- \n\n## 公司\n\n- 暂无\n\n## 思路\n\n遍历每一个位置与记录字符的所有位置的大小填入ans中，初步写一下，n方有点高 应该有更低的做法\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        char[] cs = s.toCharArray();\n        List<Integer> list = new ArrayList<>();\n        for(int i = 0; i<s.length(); i++){\n            if(cs[i] == c){\n                list.add(i);\n            }\n        }\n        int[] ans = new int[s.length()];\n        for(int i = 0; i<ans.length; i++){\n            ans[i] = 999;\n        }\n        for(int i = 0; i<list.size(); i++){\n            for(int j = 0; j<s.length(); j++){\n                ans[j] = Math.abs(j - list.get(i)) < ans[j] ? Math.abs(j - list.get(i)) : ans[j];\n            }\n        }\n        return ans;\n    }\n}\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n^2)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993610643","body":"\n## 题目地址(1381. 设计一个支持增量操作的栈)\n\nhttps://leetcode-cn.com/problems/design-a-stack-with-increment-operation/\n\n## 题目描述\n\n```\n请你设计一个支持下述操作的栈。\n\n实现自定义栈类 CustomStack ：\n\nCustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。\nvoid push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\nint pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\nvoid inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\n\n \n\n示例：\n\n输入：\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\n输出：\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\n解释：\nCustomStack customStack = new CustomStack(3); // 栈是空的 []\ncustomStack.push(1);                          // 栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]\ncustomStack.push(2);                          // 栈变为 [1, 2]\ncustomStack.push(3);                          // 栈变为 [1, 2, 3]\ncustomStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4\ncustomStack.increment(5, 100);                // 栈变为 [101, 102, 103]\ncustomStack.increment(2, 100);                // 栈变为 [201, 202, 103]\ncustomStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]\ncustomStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]\ncustomStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []\ncustomStack.pop();                            // 返回 -1 --> 栈为空，返回 -1\n\n\n \n\n提示：\n\n1 <= maxSize <= 1000\n1 <= x <= 1000\n1 <= k <= 1000\n0 <= val <= 100\n每种方法 increment，push 以及 pop 分别最多调用 1000 次\n```\n\n\n## 思路\n数组模拟栈 基本操作\n\n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass CustomStack {\n\n    int[] length;\n    int index;\n    int maxSize;\n\n    public CustomStack(int maxSize) {\n        length = new int[maxSize];\n        index = 0;\n        this.maxSize = maxSize;\n    }\n    \n    public void push(int x) {\n        if(index < maxSize){\n            length[index++] = x;\n        }\n    }\n    \n    public int pop() {\n        if(index > 0){\n            return length[--index];\n        }else\n            return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if(k > maxSize){\n            for(int i = 0; i<maxSize; i++){\n                length[i] += val;\n            }\n        }else{\n            for(int i = 0; i < k; i++){\n                length[i] += val;\n            }\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994793774","body":"\n## 题目地址(394. 字符串解码)\n\nhttps://leetcode-cn.com/problems/decode-string/\n\n## 题目描述\n\n```\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。\n\n \n\n示例 1：\n\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n\n\n示例 2：\n\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n\n\n示例 3：\n\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n\n\n示例 4：\n\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n\n```\n\n## 前置知识\n\n- 栈\n\n\n## 思路\n双栈模拟，类似计算器实现的括号入栈，看了题解，交完论文慢慢重新写\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n作者：jyd\n链接：https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995783382","body":"## 思路\n\n- 来回倒腾 一个栈负责进，一个负责出\n\n## 关键点\n\n-  \n\n## 代码\n\n- 语言支持：Java\n\nJava Code:\n\n```java\n\nclass MyQueue {\n    Stack<Integer> stack1;\n    Stack<Integer> stack2;\n    public MyQueue() {\n    stack1 = new Stack<>();\n    stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        while(!stack2.empty()){\n            int tmp = stack2.pop();\n            stack1.push(tmp);\n        }\n        stack1.push(x);\n\n    }\n    \n    public int pop() {\n        while(!stack1.empty()){\n            int tmp = stack1.pop();\n            stack2.push(tmp);\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        while(!stack1.empty()){\n            int tmp = stack1.pop();\n            stack2.push(tmp);\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.empty()&&stack2.empty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"honeymeng-hub":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991874119","body":"//leetcode submit region begin(Prohibit modification and deletion)\n//遍历nums[]转化为数值，再遍历返回数组\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //idea1 ： FAILED，java中int最大2^32-1,（10位数）\n//        long tmp = 0;\n//        for (int i = num.length - 1, r = 1; i >= 0; i--) {\n//            tmp += num[i] * r;\n//            r = r * 10;\n//        }\n//        tmp = tmp + k;\n//        //从数值里取出元素放入链表\n//        String s = Long.toString(tmp);\n//        //String s1 = Integer.toString();\n//        ArrayList<Integer> list = new ArrayList<>();\n//        for (int j = 0; j < s.length(); j++) {\n//            int c = (int)s.charAt(j);\n//            list.add(Integer.parseInt(s1.valueOf(s.charAt(j))));\n//        }\n//        return list;\n        //看完答案想法二：位运算，位置对象相加，进位加在上一位\n        //评论区发现：num[]末尾+k ，取末尾添加到链表再抛弃末尾\n        //时间复杂度：O（n）数组长度\n        //空间复杂度：O（n）\n        LinkedList<Integer> list = new LinkedList<>();\n        int len = num.length;\n        int lastNum = k;\n        int i = len -1;\n        while (i >= 0 || lastNum > 0) {\n            if (i >= 0) {\n                lastNum += num[i];\n            }\n            //取余放入链表\n            list.addFirst(lastNum % 10);\n            //看看有没有进位(有就迭代，无就是0还是迭代)\n            lastNum /= 10;\n            i--;\n        }\n        return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992572641","body":"class Solution {\n    public int[] shortestToChar(String s, char c) {\n        //方法1：最小数组=====IDEA：每个字符 距离左 右字符的距离，较小的为答案\n        //从前向后遍历，记录i与左边边c的距离，从后向前遍历记录i与右边c距离，之后比较 num【i】存的数值，取小的\n        int len = s.length();\n        int[] ans = new int[len];\n        //定义迭代变量（c的初始位置）pre=Integer.MIN_VALUE / 2 （这里的数值不要紧，num【i】正反遍历会比较的）\n        int symbolC = Integer.MIN_VALUE / 2;\n        //正向遍历\n        for (int i = 0; i < len; i++) {\n            if (s.charAt(i) == c) symbolC = i;\n            ans[i] = i - symbolC;\n        }\n\n        //反向遍历\n        symbolC = Integer.MAX_VALUE / 2;\n        for (int i = len - 1; i >= 0; i--) {\n            if (s.charAt(i) == c) symbolC = i;\n            ans[i] = Math.min(symbolC - i, ans[i]);\n        }\n        return ans;\n    }\n}","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994906916","body":"//感觉逻辑对了，明天再看看\nclass Solution {\n    public String decodeString(String s) {\n        //新手操蛋题\n        Stack<String> stack = new Stack<String>();\n        int len = s.length();\n        //定义中间的字符为空字符\n        String copyStr = \"\";\n        //定义要重复的次数\n        String copyCount = \"\";\n        for (int i = 0; i < len; i++) {\n            //\"!]\"入栈\n            if (\"]\".equals(s.charAt(i))) {\n                stack.push(s.charAt(i));\n            } else {\n                //弹栈（ \"]\"）\n                //遇见 [ 停止弹栈,取出字符\n                while (\"[\".equals(stack.pop())) {\n                    copyStr += stack.pop();\n                }\n                //继续出栈，非数字为止\n                if (stack.pop() >= 48 && stack.pop() <= 57)\n                    copyCount += stack.pop();\n                //最终字符串 copyCount 遍 copyStr 用字母大A表示\n                String A = \"\";\n                for (int j = 0; j < Integer.parseInt(copyCount); j++) {\n                    A += copyCount;\n                }\n                //整体放入栈中，此次for循环结束\n                stack.push(A);\n            }\n        }\n        return stack.pop();\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995616449","body":"`栈` `队列` `经典`\n\n**思路** pop，push堆顶操作 ，队列enque，denque在队列两端操作，利用辅助栈来回倒腾即可\n\n```java\nclass MyQueue {\n//    MyQueue queue = new MyQueue();\n//queue.push(1);\n//queue.push(2);\n//queue.peek(); // 返回 1\n//queue.pop(); // 返回 1\n//queue.empty(); // 返回 false\n    Stack<Integer> pushStack = new Stack<>();\n    Stack<Integer> popStack = new Stack<>();\n\n    public MyQueue() {\n        //初始化不用管\n    }\n    \n    public void push(int x) {\n        //加在到队列末尾 \n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        //从队列开头移除并返回元素 译为 先进先出\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        //从队列开头移除并返回元素 译为 另个栈倒到这个栈，this.peek\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```\n\n复杂度分析：\n\n时间：O(N) N为栈元素个数\n\n空间：O(N) N为栈中元素个数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shu-weiran":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991880602","body":"# 思路\n将K表示为数组，两个数组逐位相加。考虑进位。最后对数组取反。\n\n\n```\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        K = list(map(int,str(K)))\n        \n        res = []\n        i,j = len(A)-1,len(K)-1\n        carry = 0\n\n        while i >= 0 and j >= 0:\n            res.append(A[i] + K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n            j -= 1\n        while i >= 0:\n            res.append(A[i] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            i -= 1\n        while j >= 0:\n            res.append(K[j] + carry)\n            res[-1],carry = res[-1] % 10, res[-1] // 10\n            j -= 1\n\n        if carry:\n            res.append(1)\n\n        return res[::-1]\n```\n\n# 时间复杂度O(n)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bryanmiracle":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991882687","body":"### 思路\r\n将数组和 k的对应项从右至左以此相加，进位时carry + 1；\r\n### 代码\r\n```\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<>();\r\n        int carry = 0;\r\n        int l1 = num.length - 1;\r\n\r\n        while (l1 >= 0 || k != 0) {\r\n            int x = l1 < 0 ? 0 : num[l1];\r\n            int y = k == 0 ? 0 : k % 10;\r\n\r\n            int sum = x + y + carry;\r\n            res.add(sum % 10);\r\n            carry = sum / 10;\r\n            l1--;\r\n            k = k / 10;\r\n        }\r\n        if (carry != 0) res.add(carry);\r\n        Collections.reverse(res);\r\n        return res;\r\n\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n**时间复杂度：O(N)**\r\n**空间复杂度：O(1)**","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992592481","body":"### 思路\r\n进行两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String S, char C) {\r\n        int N = S.length();\r\n        int[] ans = new int[N];\r\n        int prev = Integer.MIN_VALUE / 2;\r\n\r\n        for (int i = 0; i < N; ++i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = i - prev;\r\n        }\r\n\r\n        prev = Integer.MAX_VALUE / 2;\r\n        for (int i = N-1; i >= 0; --i) {\r\n            if (S.charAt(i) == C) prev = i;\r\n            ans[i] = Math.min(ans[i], prev - i);\r\n        }\r\n\r\n        return ans;\r\n    }\r\n}\r\n```\r\n### 复杂度分析\r\n时间复杂度：O(N)\r\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"riuusee":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991883145","body":"### 思路\n\n模拟一位位相加，处理进位，处理被加数、加数为0的情况\n\n### 代码\n\n```java\npublic class Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<Integer>();\n        int c = 0;  //进位\n        for (int i = num.length-1; i >= 0; i--) {   //倒着一位位相加\n            int a = num[i] + k%10 + c;\n            if (a > 9){\n                c = 1;\n                a -= 10;\n                if (i == 0 && (k/10 == 0)){ //存在进位且加数为0\n                    result.add(a);\n                    result.add(1);\n                    break;\n                }\n            }else {\n                c = 0;\n            }\n            result.add(a);\n            k /= 10;\n            while (i==0 && k > 0){ //被加数为0加数不为0\n                int b = k%10 + c;\n                if (b > 9){\n                    if(b==10 && (k/10 == 0)){ //进位\n                        result.add(0);\n                        result.add(1);\n                        break;\n                    }\n                    b -= 10;\n                    c =1;\n                }else {\n                    c = 0;\n                }\n                result.add(b);\n                k /= 10;\n            }\n        }\n        Collections.reverse(result);  //反转\n        return result;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992538326","body":"### 思路\n\n分别向前后遍历找相同字符\n\n### 代码\n\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n\n        for (int i = 0; i < n; i++){\n            int t = 10001;\n            for (int j = i; j < n; j++) {\n                if (s.charAt(j) == c){\n                    int a = j - i;\n                    if (a < t){\n                        t = a;\n                    }\n                    break;\n                }\n            }\n            for (int j = i - 1; j >= 0; j--) {\n                if (s.charAt(j) == c){\n                    int a = i - j;\n                    if (a < t){\n                        t = a;\n                    }\n                    break;\n                }\n            }\n            ans[i] = t;\n        }\n\n        return ans;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(N*N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993597484","body":"### 思路\n\n数组实现栈\n\n### 代码\n\n```java\nclass CustomStack {\n\n    int[] s;\n    int top = -1;\n\n    public CustomStack(int maxSize) {\n        s = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top < s.length-1){\n            s[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > -1){\n            return s[top--];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int t = k-1;\n        if (top < k-1){\n            t = top;\n        }\n        for (int i = 0; i <= t; i++) {\n            s[i] += val;\n        }\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: \n- push/pop O(1)\n- increment O(N)\n- 空间复杂度: O(N)\n\n\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995554997","body":"### 思路\n\n两个栈，一个进，一个出\n\n### 代码\n\n```java\nclass MyQueue {\n\n    private Stack pushStack;\n    private Stack popStack;\n\n    public MyQueue() {\n        popStack = new Stack();\n        pushStack = new Stack();\n    }\n\n    public void push(int x) {\n        pushStack.add(x);\n    }\n\n    public int pop() {\n        if (popStack.empty()){\n            while (!pushStack.empty()){\n                popStack.add(pushStack.pop());\n            }\n        }\n        return (int) popStack.pop();\n    }\n\n    public int peek() {\n        if (popStack.empty()){\n            while (!pushStack.empty()){\n                popStack.add(pushStack.pop());\n            }\n        }\n        return (int) popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.empty() && popStack.empty();\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(1)\n- 空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kevinworkspace":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991884524","body":"```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        LinkedList<Integer> list = new LinkedList<>();\n        int i = num.length - 1;\n        int x = 0;\n        int add = 0;\n        while (i >= 0 || k > 0 || add == 1) {\n            if (i >= 0) x = num[i];\n            else x = 0;\n            int res = (x + k % 10 + add) % 10;\n            add = (x + k % 10 + add) / 10;\n            list.addFirst(res);\n            i --;\n            k /= 10;\n        }\n        return list;\n    }\n}\n```\n时间复杂度: O(N)\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992410373","body":"```java\npublic int[] shortestToChar(String s, char c) {\n        int[] res = new int[s.length()];\n        int index = Integer.MIN_VALUE / 2;\n        for (int i=0; i<s.length(); i++) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            else res[i] = i - index;\n        }\n        index = Integer.MAX_VALUE / 2;\n        for (int i=s.length()-1; i>=0; i--) {\n            if (s.charAt(i) == c) {\n                index = i;\n            }\n            else res[i] = Math.min(index - i, res[i]);\n        }\n        return res;\n    }\n```\n\n时间复杂度: O(N)\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993457186","body":"```java\r\nclass CustomStack {\r\n\r\n     int[] stack;\r\n    int cnt;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        cnt = 0;\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (cnt < stack.length) {\r\n            stack[cnt++] = x;\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        if (cnt > 0) {\r\n            cnt --;\r\n            return stack[cnt];\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int num = Math.min(k, cnt);\r\n        for (int i=0; i<num; i++) {\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n时间复杂度: O(1)\r\n空间复杂度: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994735343","body":"```java\r\npublic String decodeString(String s) {\r\n        int num = 0;\r\n        StringBuffer str = new StringBuffer();\r\n        Stack<Integer> nStack = new Stack<>();\r\n        Stack<StringBuffer> aStack = new Stack<>();\r\n        for (int i=0; i<s.length(); i++) {\r\n            char c = s.charAt(i);\r\n            if (Character.isDigit(c)) {\r\n                num = num * 10 + c - '0';\r\n            }\r\n            else if (c == '[') {\r\n                nStack.add(num);\r\n                aStack.add(str);\r\n                num = 0;\r\n                str = new StringBuffer();\r\n            }\r\n            else if (Character.isLetter(c)) {\r\n                str.append(c);\r\n            }\r\n            else if (c == ']') {\r\n                int n = nStack.pop();\r\n                StringBuffer buffer = aStack.pop();\r\n                for (int j=0; j<n; j++) {\r\n                    buffer.append(str);\r\n                }\r\n                str = buffer;\r\n            }\r\n        }\r\n        return str.toString();\r\n    }\r\n```\r\n时间复杂度: O(N)\r\n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995766586","body":"```java\r\nclass MyQueue {\r\n\r\n    Stack<Integer> s1 = new Stack<>();\r\n    Stack<Integer> s2 = new Stack<>();\r\n\r\n    /** Initialize your data structure here. */\r\n    public MyQueue() {\r\n\r\n    }\r\n\r\n    /** Push element x to the back of queue. */\r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n\r\n    /** Removes the element from in front of queue and returns that element. */\r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n\r\n    /** Get the front element. */\r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) {\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n\r\n    /** Returns whether the queue is empty. */\r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"luo-frontend":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991887936","body":"JavaScript\r\n思路：\r\n1、遍历数组，从高到低，每项加上K\r\n2、如果res >= 10, 将 k % 10，得到个位保留在num得当前下标，并计算Math.floot(k% 10),得到除个位外的数值res2\r\n例如 num = [1,2,3,4], k= 1234\r\n第一次循环：num[3] === 4, 4 + 1234 = 1238\r\nk% 10 = 8，push到新数组\r\nMath.floot(k% 10) = 123\r\n令k= 123，继续循环\r\n第二次循环：num[2] === 3, 3 + 123 = 126 \r\nk% 10 = 6，push到新数组\r\nMath.floot(k% 10) = 12\r\n令k= 12，继续循环\r\n...\r\n最后得到数组[2,4,6,8]\r\n需要注意的是，这里继续循环的条件不一定循环完整个数组，而是，循环完整个数据或循环完k，即 i >= 0  || k > 0\r\n因为k不一定是和数组的length相同，当满足上面两个条件中的一个即可以继续循环\r\n```\r\nvar addToArrayForm = function(num, k) {\r\n    const res = [];\r\n    const n = num.length;\r\n    for (let i = n - 1; i >= 0 || k > 0; --i, k = Math.floor(k / 10)) {\r\n        if (i >= 0) {\r\n            k += num[i];\r\n        }\r\n        res.push(k % 10);\r\n    }\r\n    res.reverse();\r\n    return res;\r\n};\r\n```\r\n时间复杂度O(max(n,log k))","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992075508","body":"思路:\r\n1、遍历字符串s, 将字符串中每一项 === c的下标存成数组arr\r\n2、遍历字符串s, 计算字符串中每一项和数组arr每一项的间距,保留最小值,并存在result数组\r\n```\r\nvar shortestToChar = function(s, c) {\r\n    const res = []\r\n    const indexArr = []\r\n    for(let i = 0; i < s.length; i++) {\r\n        if(s[i] === c) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    for(let i = 0; i < s.length; i++) {\r\n        let index = 1000\r\n        let a = 0\r\n        indexArr.forEach((item) => {\r\n            let b = Math.abs(i - item)\r\n            if(b <= index) {\r\n                a = b\r\n                index = b\r\n            } else {\r\n                a = index\r\n            }\r\n        })\r\n        res[i] = a\r\n    }\r\n    return res\r\n};\r\n```\r\n时间复杂度:O(nm) m为数组arr的长度,即c在字符串中下标的数组","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993082455","body":"JavaScript\r\n思路:\r\n1、利用JS的push、pop方法,原理很简单,但是时间复杂度高,因为如果初始化没有给数组每项赋值,然后每次push都会是O(n)的时间,因为每次都需要重新申请地址.\r\n2、修改JS的push、pop方法,每次操作记录当前下标,这样能将push方法、pop方法降低O(1)的时间复杂度\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    return this.stack.length > 0 ? this.stack.pop() : -1\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < k && i < this.stack.length; i ++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.maxSize = maxSize\r\n    this.curIndex = 0\r\n    this.stack = []\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.stack.length < this.maxSize) {\r\n        this.stack[this.curIndex] = x\r\n        this.curIndex++\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.curIndex === 0) {\r\n        return -1\r\n    }\r\n    const res = this.stack[this.curIndex - 1]\r\n    this.stack.length-- \r\n    this.curIndex--\r\n    return res\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    for(let i = 0; i < k && i < this.stack.length; i ++) {\r\n        this.stack[i] += val\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n提交时证明我对于思路1的push、pop的时间复杂度是错误的,可能由于V8的优化,思路1比思路2快.\r\n时间复杂度: \r\npush:O(1)\r\npop:O(1)\r\nincrement:O(min(n, k)), n为数组长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994373816","body":"JavaScript\r\n思路:\r\n首先明确使用栈的数据结构, 其次由于涉及到三种类型的字符串：数字、字母、[]符号,用一个栈肯定不合适,会导致判断出错,所以使用两个栈,分别存储数字和字母,同时还需要使用两个中间变量,用于存储数字变量和字母变量.最后就是遍历字符串:\r\n1、当遇到数字时,通过中间量将数字保存起来,同时要注意多个数字的组合\r\n2、当遇到[时,将数字变量push到数字栈中,重置数字变量;将字母变量push到字母栈中,重置字母变量\r\n3、当遇到]时,取出两个栈顶元素,组合两个栈顶元素的字符串,赋值给字母变量,\r\n4、通过上面三个判断剩下的就是字母了,当遇到字母的时候,追加给字母变量\r\n\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    let numStack = [];        // 存倍数的栈\r\n    let strStack = [];        // 存 待拼接的str 的栈\r\n    let num = 0;              // 倍数的“搬运工”\r\n    let result = '';          // 字符串的“搬运工”\r\n    for (const char of s) {   // 逐字符扫描\r\n        if (!isNaN(char)) {   // 遇到数字\r\n            num = num * 10 + Number(char); // 算出倍数\r\n        } else if (char == '[') {  // 遇到 [\r\n            strStack.push(result); // result串入栈\r\n            result = '';           // 入栈后清零\r\n            numStack.push(num);    // 倍数num进入栈等待\r\n            num = 0;               // 入栈后清零\r\n        } else if (char == ']') {  // 遇到 ]，两个栈的栈顶出栈\r\n            let repeatTimes = numStack.pop(); // 获取拷贝次数\r\n            result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\r\n        } else {                   \r\n            result += char;        // 遇到字母，追加给result串\r\n        }\r\n    }\r\n    return result;\r\n};\r\n```\r\n时间复杂度O(n*m) m为构建子串中最大的循环数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jie-zi":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991888153","body":"思路：\r\n转换成两个vector，逐个按位相加，注意k可能比num长，因此要加上k比num长的部分\r\n```\r\nvector<int> addToArrayForm(vector<int>& num, int k) {\r\n    vector<int> res;\r\n    int n=num.size();\r\n    for(int i=n-1;i>=0;i--){\r\n        int sum=num[i]+k%10;\r\n        k=k/10;\r\n        if(sum>=10){\r\n            sum=sum-10;\r\n            k++;\r\n        }\r\n        res.push_back(sum);\r\n    }\r\n    while(k){\r\n        res.push_back(k%10);\r\n        k=k/10;\r\n    }\r\n    reverse(res.begin(),res.end());\r\n    return res;\r\n    }\r\n```\r\n\r\n时间复杂度O(n)\r\n空间复杂度O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992490541","body":"此题不难求解，难点在于对每一种情况的分类讨论，边界可能只有一个，也可能存在多个\r\n```\r\nint n=s.size();\r\n        vector<int> res(n, 0), index;\r\n        for (int i = 0; i < n; i++) {\r\n\t\t    if (s[i] == c) index.push_back(i);\r\n\t    }\r\n\t    int j = 0;\r\n\t   for (int i = 0; i < n; i++) {\r\n\t        //若果只有一个边界\r\n\t\t    if (index.size() == 1) res[i] = abs(i - index[j]);\r\n\t\t    //若果有多个边界\r\n\t\t    else {\r\n\t\t\t    //小于左边界\r\n\t\t\t    if (i < index[j]) res[i] = abs(i - index[j]);\r\n\t\t\t    //大于右边界\r\n\t\t\t    else if(i > index[j+1]) res[i] = abs(i - index[j+1]);\r\n\t\t\t    //在左右边界中间\r\n\t\t\t    else if (index[j] <= i && i < index[j + 1]) \r\n\t\t\t\t    res[i] = min(abs(i - index[j]), abs(i - index[j + 1]));\t\r\n\t\t\t    //正好等于右边界，j需要＋1，注意j别超出边界\r\n\t\t\t    else if(i==index[j+1]){\r\n\t\t\t\t    res[i] = 0;\r\n\t\t\t\t    if (j < index.size() - 2) j++;\r\n\t\t\t    }\r\n\t\t    }\r\n\t    }\r\n        return res;\r\n```\r\n时间复杂度O(n) \r\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xjhcassy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991891005","body":"#### 思路\n\n1. 采用LinkedList双向链表\n2. 将k依次加上num的各位，并取出最后一位\n\n代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n\n        int len = num.length;\n        int lastNum = k;\n        LinkedList<Integer> ret= new LinkedList<>();\n\n        int i = len-1;\n        while(i >=0 || lastNum > 0){\n            if(i >= 0){\n                lastNum+=num[i];\n            }\n            ret.addFirst(lastNum%10);\n            lastNum/=10;\n            i--;\n        }\n\n        return ret;\n\n    }\n```\n\n复杂度分析\n\n时间复杂度O(N);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992419299","body":"### 思路\n\n1. 先找出字符c在字符串中的索引；\n2. 再循环找出字符串中每个字符到该字符的最短距离\n\n\n\n### 代码\n\n```java\npublic int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> index = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i) == c){\n                index.add(i);\n            }\n        }\n        int[] answer = new int[s.length()];\n        int shortest = 0;\n        for (int i = 0; i < s.length(); i++) {\n            shortest = Math.abs(i - index.get(0));\n            for (int j = 1; j < index.size(); j++) {\n                if(Math.abs(i - index.get(j)) < shortest){\n                    shortest = Math.abs(i - index.get(j));\n                }\n            }\n            answer[i] = shortest;\n        }\n\n        return answer;\n    }\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(N^2)，当找出的index在2最差情况下为所有的索引都包含时，此时复杂度达到O(N^2);\n\n空间复杂度：在最差情况下，需要开创N大小的ArrayList，所以空间复杂度为O(N); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993324962","body":"### 思路\n\n1. 使用LinkedList实现Stack；\n\n\n\n### 代码\n\n```java\nclass CustomStack {\n    private int maxSize;\n    private LinkedList<Integer> stack;\n\n    public CustomStack(int maxSize) {\n        this.stack = new LinkedList<>();\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size() >= maxSize){\n            return;\n        }\n        stack.addLast(x);\n    }\n\n    public int pop() {\n        if(stack.size() == 0){\n            return -1;\n        }\n        return stack.removeLast();\n    }\n\n    public void increment(int k, int val) {\n        int num = Math.min(k, stack.size());\n        for (int i = 0; i < num; i++) {\n            stack.set(i, stack.get(i) + val);\n        }\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(min(k, stack.size));\n\n空间复杂度：O(1); ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994704508","body":"### 思路\n\n1. 通过栈实现\n\n\n\n### 代码\n\n```java\nclass Solution {\n    int ptr;\n\n    public String decodeString(String s) {\n        LinkedList<String> stk = new LinkedList<String>();\n        ptr = 0;\n\n        while (ptr < s.length()) {\n            char cur = s.charAt(ptr);\n            if (Character.isDigit(cur)) {\n                // 获取一个数字并进栈\n                String digits = getDigits(s);\n                stk.addLast(digits);\n            } else if (Character.isLetter(cur) || cur == '[') {\n                // 获取一个字母并进栈\n                stk.addLast(String.valueOf(s.charAt(ptr++))); \n            } else {\n                ++ptr;\n                LinkedList<String> sub = new LinkedList<String>();\n                while (!\"[\".equals(stk.peekLast())) {\n                    sub.addLast(stk.removeLast());\n                }\n                Collections.reverse(sub);\n                // 左括号出栈\n                stk.removeLast();\n                // 此时栈顶为当前 sub 对应的字符串应该出现的次数\n                int repTime = Integer.parseInt(stk.removeLast());\n                StringBuffer t = new StringBuffer();\n                String o = getString(sub);\n                // 构造字符串\n                while (repTime-- > 0) {\n                    t.append(o);\n                }\n                // 将构造好的字符串入栈\n                stk.addLast(t.toString());\n            }\n        }\n\n        return getString(stk);\n    }\n\n    public String getDigits(String s) {\n        StringBuffer ret = new StringBuffer();\n        while (Character.isDigit(s.charAt(ptr))) {\n            ret.append(s.charAt(ptr++));\n        }\n        return ret.toString();\n    }\n\n    public String getString(LinkedList<String> v) {\n        StringBuffer ret = new StringBuffer();\n        for (String s : v) {\n            ret.append(s);\n        }\n        return ret.toString();\n    }\n}\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(S);\n\n空间复杂度：O(S); \n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995687977","body":"### 思路\n\n1. 通过Java的LinkedList实现\n\n\n\n### 代码\n\n```java\nprivate Queue<Integer> queue;\n\n    public MyQueue() {\n        queue = new LinkedList<>();\n    }\n\n    public void push(int x) {\n        queue.offer(x);\n    }\n\n    public int pop() {\n        return queue.poll();\n    }\n\n    public int peek() {\n        return queue.peek();\n    }\n\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n```\n\n\n\n### 复杂度分析\n\n时间复杂度：O(1);\n\n空间复杂度：O(1); ","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aladingzl":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893686","body":"### 思路\n\n从低位开始，将 A 的每一位与 K 的每一位相加，和大于10时，记录进位 “+1”，将和放到数组中，考虑 K 的长度大于 A 的情况，最后将数组翻转，返回结果\n\n### 代码\n\n```javascript\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n   const res = [];\n   for(let i = num.length - 1; i >= 0; i--) {\n       let sum = num[i] + k % 10;\n       k = Math.floor(k / 10);\n       if(sum >= 10) {\n           k++;\n           sum -= 10;\n       } \n       res.push(sum);\n   }\n   for(; k > 0; k = Math.floor(k / 10)) {\n       res.push(k % 10);\n   }\n   res.reverse();\n   return res;\n};\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993084427","body":"### 思路\n\n用数组模拟一个栈，根据条件进行出栈跟入栈的操作，判断 k 与 length 的大小，对相应数量的元素进行增加 val 的操作\n\n### 代码\n\n```javascript\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.stack = [];\n    this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length < this.maxSize) {\n        this.stack.push(x);\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const ret = this.stack.pop();\n    if(!ret) return -1;\n    return ret; \n    \n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i = 0; i < k && i < this.stack.length; i++) {\n        this.stack[i] += val;\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：pop 和 push 操作 时间复杂度为 O(1) 增量操作的时间复杂度为 O(k)\n- 空间复杂度：O(maxSize)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"wangdi-1291":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991893964","body":"-思路：从低位到高位依次计算，逐位将数字加在一起。任何时候，若加法的结果大于等于10，则进位为1。\r\n\r\n\r\n-代码:\r\n###\r\nclass Solution:\r\n\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n\r\n        n = len(num)\r\n\r\n        ans = list()\r\n\r\n        carry = 0\r\n\r\n        for i in range(n):\r\n\r\n            res = k % 10\r\n\r\n            sum = num[n-i-1] + res + carry\r\n\r\n            carry = 0\r\n\r\n            k //= 10 \r\n\r\n            if sum >= 10:\r\n\r\n                carry = 1\r\n\r\n                sum = sum % 10\r\n\r\n            ans.append(sum)\r\n\r\n        if k % 10 == 0 and k // 10 == 0 and carry == 1:\r\n\r\n            ans.append(1)\r\n\r\n        else:\r\n\r\n            while k % 10 != 0 or k // 10 != 0:\r\n\r\n                sum = k % 10 + carry\r\n\r\n                carry = 0\r\n\r\n                k //= 10\r\n\r\n                if sum >= 10:\r\n\r\n                    carry = 1\r\n\r\n                    sum = sum % 10\r\n\r\n                ans.append(sum)\r\n\r\n            if k % 10 == 0 and k // 10 == 0 and carry == 1:\r\n\r\n                ans.append(1)\r\n\r\n        ans.reverse()\r\n\r\n        return ans\r\n\r\n-时间复杂度：O(max(len(num), num_k)), num_k 是k的位数。\r\n-空间复杂度：O(max(len(num), num_k)), num_k 是k的位数。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992108370","body":"### 思路\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值。\n\n### 代码\n\n\n```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> list[int]:\n        \n        n = len(s)\n        ans = list()\n        \n        for i in range(n):\n            l = i - 1\n            r = i\n            ri = li = 10**4\n            while r < n:\n                if s[r] == c:\n                    ri = r-i\n                    break\n                r += 1\n            while l >= 0:\n                if s[l] == c:\n                    li = i-l\n                    break\n                l -= 1\n            ans.append(min(ri, li))\n        return ans\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993568385","body":"### 思路\n用数组的想法处理栈\n\n### 代码\n\n\n```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top+1]\n\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, len(self.stk))\n        for i in range(lim):\n            self.stk += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n- 空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994904993","body":"### 代码\n\n```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            string = \"\"\n            count = \"\"\n            if c == \"]\":\n                while stack and stack[-1] != \"[\":\n                    string = stack.pop() + string\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    count = stack.pop() + count\n                stack.append(string * int(count))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为字符串长度。\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"offrande":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991894204","body":"第一天，慢慢学。。。复杂的思路想不出来\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\r\n        return [int(s) for s in str(int(\"\".join(list(map(str,num))))+k)]\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992415962","body":"思路：\n从头遍历，每次遇到c，就以c为中心向两边扩散，直到边界或者遇到第二个c停止。扩散时距离+1。距离取min(扩散距离，当前距离）\n\n代码：\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        distance = [float('inf') for _ in range(len(s))]\n        for i in range(len(s)):\n            ch = s[i]\n            if ch == c:\n                distance[i] = 0\n                while -1 < i-1 and distance[i-1] != c:\n                    distance[i-1] = min(distance[i-1], distance[i]+1)\n                    i -= 1\n                while i+1 < len(s) and distance[i+1] != c:\n                    distance[i+1] = min(distance[i+1], distance[i]+1)\n                    i += 1\n        return distance\n\n```\n\n时间：O(n^2)\n空间：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kandejiandefeng":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991895510","body":"思路：把整数k裁成数组，两个倒叙 ，数组length大的循环，位数相加\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let kArr = k.toString().split('').map(item => parseInt(item));\n    let maxArr, minArr, a = 0;\n    if(kArr.length > num.length) {\n        maxArr = kArr.reverse();\n        minArr = num.reverse();\n    }else {\n        minArr = kArr.reverse();\n        maxArr = num.reverse();\n    }\n    const minLen = minArr.length\n    return maxArr.reduce((arr, item, index) => {\n        const n = index > minLen - 1 ? 0 : minArr[index];\n        arr.push((item + n + a) % 10);\n        a = Math.floor((item + n + a) / 10)\n        if(index === maxArr.length - 1 && a === 1) {\n            arr.push(1);\n        }\n        return arr;\n    }, []).reverse()\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992310988","body":"思路：找出第一个相同字符的索引，然后当前字符索引到c字符索引的差和当前字符和上一个索引的的差比较\n/**\n * @param {string} s\n * @param {character} c\n * @return {number[]}\n */\nvar shortestToChar = function(s, c) {\n    let resArr = [];\n    let n = 0; \n    let str = s;\n    let i, len = s.length;\n    for(i = 0; i < len; i++) {\n        const indexc = str.indexOf(c);\n        const index = i - n;\n        if(n === 0) {\n            resArr.push(indexc - index);\n        }else if(indexc < 0){\n            resArr.push(index + 1);\n        }else {\n            resArr.push(Math.min(indexc - index, index + 1));\n        }\n        if(indexc - index === 0) {\n            str = str.slice(indexc + 1);\n            n += indexc + 1;\n        }\n    }\n    return resArr;\n};\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993076299","body":"```\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n    this.value = new Array();\r\n    this.size = maxSize;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n    if(this.value.length < this.size) {\r\n        this.value.push(x)\r\n    }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n    if(this.value.length === 0) {\r\n        return -1;\r\n    } else {\r\n        return this.value.pop();\r\n    }\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n    let i = 0;\r\n    for(i; i < k; i++) {\r\n        if(!this.value[i]) {\r\n            break;\r\n        }\r\n        this.value[i] += val;\r\n    }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994798695","body":"思路：找到第一个[计数，当找到对应数量的]后，截取循环前面数字次，然后替换掉原字符串，重复上面步骤，知道没有【】为止\r\n```\r\n/**\r\n * @param {string} s\r\n * @return {string}\r\n */\r\nvar decodeString = function(s) {\r\n    while (/\\d\\[.*?\\]/g.test(s)) {\r\n        const len = s.length;\r\n        let i = 0;\r\n        let n = 0,\r\n            start = 0,\r\n            end = 0;\r\n        for (i; i < len; i++) {\r\n            if (s[i] === '[') {\r\n                n++;\r\n                if (n === 1) {\r\n                    start = i;\r\n                }\r\n            } else if (s[i] === ']') {\r\n                n--;\r\n                if (n === 0) {\r\n                    end = i;\r\n                    const str = s.slice(start, end + 1);\r\n                    const num = parseInt(s.match(/\\d.*/) &&\r\n                        s.match(/\\d.*/)[0]);\r\n                    s = s.replace(str, (e) => {\r\n                        let strP = ''\r\n                        for (let index = 0; index < num; index++) {\r\n                            strP += str.slice(1, str.length - 1);\r\n                        }\r\n                        return strP;\r\n                    });\r\n                    s = s.slice(0, start - num.toString().length) + s.slice(start);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return s;\r\n};\r\n```\r\n复杂度O(n2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995694652","body":"```\nvar MyQueue = function() {\n    this.list = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.list.shift();\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.list[0];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.list.length;\n};\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rmadridxdh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991896853","body":"### 代码\n```Python\nclass Solution:\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\n        return list(map(int,str(int(''.join(map(str,A))) + K)))\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992518963","body":"### 思路\n对于每个字符 S[i]，试图找出距离向左或者向右下一个字符 C 的距离。答案就是这两个值的较小值\n### 代码\n`python\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        answer = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            answer.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            answer [i] = min(answer [i], prev - i)\n\n        return answer\n`\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 NN 是 S 的长度，我们需要遍历字符串两次。\n- 空间复杂度：O(N)O(N)，answer 数组的大小。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993638756","body":"### 代码\n\n\n```python\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val\n\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994910439","body":"### 代码\n\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zzzpppy":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991898319","body":"思路：\r\n使用arraylist做为新数组存最后的值，从后遍历数组中的每一位数，分别与k的个位相加，如果有进位则用一个carry存进位，每一位最后的值就是k的个位+A数组的值+carry，最后当k为0且A遍历完之后，如果carry有进位则要加入新数组，然后因为新数组是从个位加进新数组中的，最后的结果便要把它反过来。\r\n\r\n代码：\r\npublic List<Integer> addToArrayForm(int[] A, int K) {\r\n    List<Integer> res = new ArrayList<>();\r\n    int carry = 0;\r\n    int l1 = A.length - 1;\r\n    while (l1 >= 0 || K != 0) {\r\n        int x = l1 < 0 ? 0 : A[l1];\r\n        int y = K == 0 ? 0 : K % 10;\r\n\r\n        int sum = x + y + carry;\r\n        res.add(sum % 10);\r\n        carry = sum / 10;\r\n\r\n        l1--;\r\n        K = K / 10;\r\n    }\r\n    if (carry != 0) res.add(carry);\r\n    Collections.reverse(res);\r\n    return res;\r\n}\r\n\r\n时间复杂度：O（n）\r\n空间复杂度：O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992485915","body":"**思路**：\r\n两次遍历，首先从左边遍历得到第一次的距离值，然后再从右边遍历得到右边值，两个值比较最小的变小最终结果\r\n**代码**\r\n```\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] res = new int[s.length()];\r\n        int pre = Integer.MIN_VALUE/2;\r\n        for(int i = 0 ; i < s.length();i++){\r\n            if(s.charAt(i) == c)\r\n            pre = i;\r\n            res[i] = i-pre;\r\n        }\r\n        pre = Integer.MAX_VALUE/2;\r\n        for(int i = s.length()-1; i >=0;i--){\r\n            if(s.charAt(i) == c)\r\n            pre = i;\r\n            res[i] = Math.min(res[i], pre - i);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n时间复杂度 O(N)\r\n空间复杂度O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993561012","body":"**思路**\r\n使用数组模拟，push操作判断是否为栈顶，不为栈顶top右移赋值。\r\npop操作判断是否为空，为空top==-1；不为空top右移依次减值\r\n批量增判断k与栈顶比较，选较小的作为范围，然后依次赋值\r\n**代码**\r\n```\r\nclass CustomStack {\r\n    int[] stack;\r\n    int top;\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top != stack.length-1){\r\n            ++top;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == -1)\r\n        return -1;\r\n        --top;\r\n        return stack[top+1];\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        k = Math.min(k,top+1);\r\n        for(int i = 0; i < k;i++){\r\n            stack[i] += val;\r\n        }\r\n    }\r\n}\r\n```\r\n**复杂度**\r\n时间复杂度：O(1)\r\n空间复杂度:  O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994821056","body":"**思路**\n辅助栈\n今天看的题解，不太会\n**代码**\n```\nclass Solution {\n    \n    public String decodeString(String s) {\n        Queue<Character> q=new LinkedList<>();\n        for(char c:s.toCharArray()){\n            q.offer(c);\n        }\n        return decodeString(q);\n    }\n    \n    public String decodeString(Queue<Character> q){\n        StringBuilder res=new StringBuilder();\n        int num=0;\n        while(!q.isEmpty()){\n            char c=q.poll();\n            if(c>='0'&&c<='9'){\n                num=10*num+(c-'0');\n            }\n            else if(c=='['){\n                String tmp=decodeString(q);\n                while(num>0){\n                    res.append(tmp);\n                    num--;\n                }\n            }\n            else if(c==']'){\n                return res.toString();\n            }\n            else {\n                res.append(c);\n            }\n\n        }\n        return res.toString();\n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995856507","body":"**思路**\n队列的特性是先进先出，栈的特性是先进后出，利用两个队列或者两个栈实现都是一样的原理，来回倒腾就可以实现这一功能\n**代码**\n```\nclass MyQueue {\n    Deque<Integer> out;\n    Deque<Integer> in;\n\n    public MyQueue() {\n      in = new ArrayDeque<>();\n      out = new ArrayDeque<>();\n    }\n    \n    public void push(int x) {\n        while(!out.isEmpty())\n        in.addLast(out.pollLast());\n        in.addLast(x);\n    }\n    \n    public int pop() {\n        while(!in.isEmpty())\n        out.addLast(in.pollLast());\n        return out.pollLast();\n    }\n    \n    public int peek() {\n        while(!in.isEmpty())\n        out.addLast(in.pollLast());\n        return out.peekLast();\n    }\n    \n    public boolean empty() {\n        return out.isEmpty() && in.isEmpty();\n    }\n}\n```\n**复杂度**\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"uniqlell":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991899440","body":"``` java\n/**\n使用一个字母表示进位情况\n */\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer>list = new ArrayList<>();\n        int n = num.length;\n        int f = 0;\n        while(k>0||n>0){\n           int  yu = k%10;\n           int sum = 0;\n           if(n>0)\n             sum = num[n-1]+yu+f;\n            else sum = yu+f;\n            f  =0;\n            list.add(0,sum%10);\n            if(sum>9)\n            f  = 1;\n            n--;\n            k = k/10;\n        }\n        if(f>0)\n        list.add(0,f);\n        return list;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992543934","body":"### 思路\n#### 思路一：使用双指针\n- 1.以当前字符为中心，向两边展开，先遇到的为最小的，得到abs(minus)\n- 2.遍历所有的字符\n- 时间复杂度o（n2）\n- 空间复杂度o（n）\n``` \nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int l,r;\n        int arr[] = new int[n];\n        for(int i=0;i<n;i++){\n            l = i;\n            r = i;\n           while(l>=0&&s.charAt(l)!=c)l--;\n           while(r<n&&s.charAt(r)!=c)r++;\n           if(l<0)arr[i] = r-i;\n           else if(r>=n)arr[i] = i-l;\n           else arr[i] = Math.min(i-l,r-i);\n        }\n        return arr;\n    }\n}\n```\n\n#### 思路二：两次遍历\n- 1.记录左边最近的或者没有的话记为-999\n- 2.记录右边最近的或者没有的话记为最大值\n- 时间复杂度o（n）\n- 空间复杂度o（n）\n``` java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int arr[] = new int[n];\n        int temp = -999;\n        for(int i=0;i<n;i++){\n            if(s.charAt(i)==c){\n                temp = i; \n            }\n            arr[i] = i-temp;\n        }        \n        temp = 20000;\n        for(int i=n-1;i>=0;i--){\n            if(s.charAt(i)==c){\n                temp = i;\n            } \n            arr[i] = Math.min(arr[i],temp-i);\n        }\n        return arr;\n    }\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993595590","body":"\n### 思路:常规方法\n- push的时候考虑st.size()是否大于max\n- pop()的时候考虑st是否为空\n- 使用一个index记录栈里面的元素的个数，与maxSize进行比较\n    这里的index要与k进行比较,取较小值对每个进行加的操作\n``` java\n    \nclass CustomStack {\n    int[] arr;\n    int index;\n    public CustomStack(int maxSize) {\n        arr = new int[maxSize];\n        index = -1;\n\n    }\n    \n    public void push(int x) {\n       if(arr.length-1==index)\n       return;\n       arr[++index] = x;\n    }\n    \n    public int pop() {\n        if(index!=-1){\n            int val = arr[index];\n            arr[index--]=0;\n            return val;\n        }else{\n            return -1;\n        }\n    }\n    public void increment(int k, int val) {\n        int len = Math.min(k,index+1);\n        for(int i=0;i<len;i++){\n            arr[i] += val;\n        }\n    }\n}\n``` \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878903","body":"\n### 思路：使用栈的思想\n- 使用双栈的思想，一个栈用于保存倍数数字，另外一个栈用于保存字符串\n遍历所有的字符，每个字符c\n- 当c为数字字符的时候直接将c转化为数字，这里要注意数字字符连续的情况\n- 当c为字符的时候，直接添加到res\n- 当字符c为[时将mul和res分别append到每个栈中,并将两个参数更新为0和\"\"\n- 当字符c为]的时候res=last_res+cur_res*mul\n``` java\nclass Solution {\n    public String decodeString(String s) {\n       Deque<Integer>digit = new LinkedList<>();\n       Deque<String>str = new LinkedList<>();\n       StringBuilder res = new StringBuilder();\n       int mul = 0;\n       for(Character c:s.toCharArray()){\n           if(c>='0'&&c<='9'){\n               mul = mul*10+(c-'0');\n           }else if(c=='['){\n               digit.addLast(mul);\n               str.addLast(res.toString());\n               res = new StringBuilder();\n               mul = 0;\n           }else if(c==']'){\n               StringBuilder temp = new StringBuilder();\n               int n = digit.removeLast();\n               for(int i=0;i<n;i++){\n                   temp.append(res);\n               }\n               res = new StringBuilder(str.removeLast()+temp);\n           }else{\n               res.append(c);\n           }\n       }\n       return res.toString();\n    }\n}   \n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995689097","body":"### 思路：\n\n- 使用栈实现队列要使用两个栈，一个入栈，一个出栈\n### 代码\n``` java\nclass MyQueue {\n    Stack<Integer>in;\n    Stack<Integer>out;\n    /** Initialize your data structure here. */\n    public MyQueue() {\n       in = new Stack<>();\n       out = new Stack<>();\n    }\n    \n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        in.push(x);\n    }\n    \n    /** Removes the element from in front of queue and returns that element. */\n    //必须要判断out是否为空，如果为空才需要将in中的元素搬过来\n    public int pop() {\n       if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }\n       return out.pop();\n    }\n    \n    /** Get the front element. */\n    //必须要判断out是否为空，如果为空才需要将in中的元素搬过来\n    public int peek() {\n         if(out.isEmpty()){\n           while(!in.isEmpty()){\n               out.push(in.pop());\n           }\n       }      \n       return out.peek();\n    }\n    ```\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return in.isEmpty()&&out.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"alongchong":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991900063","body":"###思路\r\n从后往前加，然后翻转\r\n###代码\r\n```JAVA\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n    List<Integer> ans = new ArrayList<Integer>();\r\n        int l = num.length ;\r\n        int m = 0;\r\n        for (int i = l-1 ; i >= 0 ; i--){\r\n             m = num[i] + k % 10 ;\r\n             k /= 10;\r\n             if (m >= 10){\r\n                 k++;\r\n                 m -=10;\r\n             }\r\n             ans.add(m);\r\n        }\r\n          for (; k > 0; k /= 10) {\r\n           ans.add(k % 10);\r\n        }\r\n        Collections.reverse(ans);\r\n        return ans;        \r\n   }\r\n}\r\n```\r\n***复杂度分析***\r\n时间复杂度：$0(N)$\r\n空间复杂度：$0(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992597026","body":"###思路\n这题想了30分钟，想不出。思路来自于题解\n###代码\n```JAVA\nclass Solution {\n    public int[] shortestToChar(String S, char C) {\n        int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n    }\n}\n\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(N)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993626874","body":"###思路\r\n先看了一下讲义，大概了解栈。然后按照题目给的要求一步步写出，不过最开始的思路最后不是用的Math.min()。看了题解觉得题解的好，就成我的思路了。\r\n###代码\r\n```JAVA\r\nclass CustomStack {\r\n    int [] stack;\r\n    int top ;\r\n\r\n    public CustomStack(int maxSize) {\r\n        stack = new int[maxSize];\r\n        top = -1;\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if(top !=stack.length - 1 ){\r\n            top++;\r\n            stack[top] = x;\r\n        }\r\n    }\r\n    \r\n    public int pop() {\r\n        if(top == - 1){\r\n            return -1;\r\n        } \r\n        top--;\r\n        return stack[top + 1];\r\n        \r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        int minvalue = Math.min(k, top + 1);\r\n        for(int i = 0; i < minvalue; i++ ){\r\n            stack[i] += val; \r\n        }\r\n\r\n    }\r\n}\r\n\r\n```\r\n***复杂度分析***\r\n看了评论才知道怎么分析\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994836248","body":"###思路\n没有思路，看的题解。这种题目，对于此时的我还是太难了。\n###代码\n```JAVA\n   public String decodeString(String s) {\n\t\tStringBuffer ans=new StringBuffer();\n\t\tStack<Integer> multiStack=new Stack<>();\n\t\tStack<StringBuffer> ansStack=new Stack<>();\n\t\tint multi=0;\n\t\tfor(char c:s.toCharArray()){\n\t\t\tif(Character.isDigit(c))multi=multi*10+c-'0';\n\t\t\telse if(c=='['){\n\t\t\t\tansStack.add(ans);\n\t\t\t\tmultiStack.add(multi);\n\t\t\t\tans=new StringBuffer();\n\t\t\t\tmulti=0;\n\t\t\t}else if(Character.isAlphabetic(c)){\n\t\t\t\tans.append(c);\n\t\t\t}else{\n\t\t\t\tStringBuffer ansTmp=ansStack.pop();\n\t\t\t\tint tmp=multiStack.pop();\n\t\t\t\tfor(int i=0;i<tmp;i++)ansTmp.append(ans);\n\t\t\t\tans=ansTmp;\n\t\t\t}\n\t\t}\n\t\treturn ans.toString();\n\t}\n```\n***复杂度分析***\n时间复杂度：$0(N)$\n空间复杂度：$0(N)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tesla-1i":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991900400","body":"```\nclass Solution:\n    def addToArrayForm(self, num, k) :\n        res = []\n        for n in num[::-1]:\n            k += n \n            res.insert(0, k%10)\n            k //= 10\n        while k:\n            res.insert(0, k%10)\n            k //= 10\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992300306","body":"```\r\nclass Solution:\r\n    def shortestToChar(self, s, c):\r\n        pre = float('-inf')\r\n        res = []\r\n        for i,number in enumerate(s):\r\n            if number == c:\r\n                pre = i\r\n            res.append(i - pre)\r\n        pre = float('inf')\r\n        for j in range(len(s)-1, -1, -1):\r\n            if s[j] == c:\r\n                pre = j\r\n            res[j] = min(res[j], pre - j)\r\n        return res\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993414901","body":"```Python 参考\n\nclass CustomStack:\n\ndef __init__(self, size: int):\n    self.st = []\n    self.cnt = 0\n    self.size = size\n\ndef push(self, x: int) -> None:\n    if self.cnt < self.size:\n        self.st.append(x)\n        self.cnt += 1\n\n\ndef pop(self) -> int:\n    if self.cnt == 0: return -1\n    self.cnt -= 1\n    return self.st.pop()\n\n\ndef increment(self, k: int, val: int) -> None:\n    for i in range(0, min(self.cnt, k)):\n        self.st[i] += val\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994369559","body":"```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        curs = ''\n        curn = 0\n        for i in s:\n            if i=='[':\n                stack.append((curs,curn))\n                curs = ''\n                curn = 0                \n            elif i.isdigit():\n                curn = curn*10+int(i)\n            elif i == ']':\n                cs,cn = stack.pop()\n                curs = cs+cn*curs\n            else:\n                curs += i\n        return curs\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995541459","body":"```\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        self.stack1.append(x)\n        \n\n    def pop(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n    def peek(self):\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        return not self.stack1 and not self.stack2\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"z1ggy-o":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991901442","body":"### 思路\r\n\r\n从末位相加即可。\r\n\r\n---\r\n\r\n实现的很差。放出来当个反例。\r\n\r\n我在实现的时候眼睛紧盯着两个数组进行来进行构建，然后想要把答案存放在已有的两个数组之一。\r\n\r\n但是这样的实现需要许多的边际确认，让代码变得十分复杂。\r\n而且在最后的结果有进位的情况下，还是要对数组进行扩容，然后做 rotation。\r\n得不偿失。\r\n\r\n### 代码\r\n\r\n\r\n```cpp\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& A, int K);\r\nprivate:\r\n    vector<int> int_to_arr(int n);\r\n};\r\n\r\nvector<int> Solution::addToArrayForm(vector<int>& A, int K)\r\n{\r\n    int carry;\r\n    int sum;\r\n    int idx_a, idx_b;\r\n    vector<int> a, b;\r\n\r\n    // edge case\r\n    if (K == 0)\r\n        return A;\r\n    \r\n    // 1. convert K to array format.\r\n    vector<int> K_arr = int_to_arr(K);\r\n    \r\n    // K can be greater than A\r\n    if (K_arr.size() > A.size()) {\r\n        a = A;\r\n        b = K_arr;    \r\n    } else {\r\n        a = K_arr;\r\n        b = A;\r\n    }\r\n\r\n    // 2. Add small number to large number from the last digit to the highest digit.\r\n    //    The result can have (A.lenght + 1) digits\r\n    idx_a = a.size() - 1;\r\n    idx_b = b.size() - 1;\r\n    carry = 0;\r\n\r\n    // add all digit \r\n    int len = a.size();\r\n    for (int i = 0; i < len; i++) {\r\n        sum = a[idx_a] + b[idx_b] + carry;\r\n        if (sum <= 9) {\r\n            b[idx_b] = sum;\r\n            carry = 0;\r\n        } else {\r\n            b[idx_b] = sum - 10;\r\n            carry = 1;\r\n        }\r\n        idx_a--;\r\n        idx_b--;\r\n    }\r\n\r\n    if (carry == 0)\r\n        return b;\r\n\r\n    if (idx_a == idx_b) {\r\n        b.insert(b.begin(), carry);\r\n        return b;\r\n    }\r\n\r\n    // add the last carry to b\r\n    while (carry != 0 && idx_b >= 0) {\r\n        sum = b[idx_b] + carry;\r\n        if (sum <= 9) {\r\n            b[idx_b] = sum;\r\n            carry = 0;\r\n        } else {\r\n            b[idx_b] = sum - 10;\r\n            carry = 1;\r\n        }\r\n        idx_b--;\r\n    }\r\n    \r\n    if (carry) {\r\n        b.insert(b.begin(), carry);\r\n    }\r\n    return b;\r\n}\r\n\r\nvector<int> Solution::int_to_arr(int n)\r\n{\r\n    int r;\r\n    vector<int> arr;\r\n\r\n    while (n != 0) {\r\n        r = n % 10;\r\n        n = n / 10;\r\n        arr.push_back(r);\r\n    }\r\n\r\n    reverse(arr.begin(), arr.end());\r\n    return arr;\r\n}\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(N)，其中 N 为较长数组的长度。\r\n- 空间复杂度：O(N)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993143487","body":"### 思路\r\n\r\n用 array 实现 stack。没什么特别的。\r\n\r\n### 代码\r\n\r\n```cpp\r\nclass CustomStack {\r\npublic:\r\n    CustomStack(int maxSize) {\r\n        capacity = maxSize;\r\n        top = 0;\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (is_full()) {\r\n            return;\r\n        }\r\n\r\n        arr[top++] = x;\r\n    }\r\n    \r\n    int pop() {\r\n        if (is_empty())\r\n            return -1;\r\n        \r\n        top--;\r\n        return arr[top];\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        int len = k > top ? top : k;\r\n\r\n        for (int i = 0; i < len; i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    int capacity;\r\n    int top;\r\n    int *arr;\r\n\r\n    bool is_full() {\r\n        return top == capacity;\r\n    }\r\n\r\n    bool is_empty() {\r\n        return (top - 1) < 0;\r\n    }\r\n};\r\n```\r\n\r\n### 复杂度\r\n\r\n- 空间：O(M). M is the capacity of the stack\r\n- 时间：O(1) for push, pop. O(k) for increment, k is the number of elements that we need to increase value.","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994327015","body":"### 思路\r\n\r\n看到成对的括号本能地就想到了使用 stack。\r\n\r\n假设我们把所有的内容都 push 到 stack 当中，那么不变的永远是：\r\n- 遇到 ’]' 则开始 pop\r\n- pop 到 '[' 为止得到的是重复对象\r\n- stack 中 '[' 的下一个（或几个）值是重复次数\r\n\r\n因为重复次数可能超过 1 位数，需要做特别处理。\r\n\r\n 看到还有像@AlvinZhouOops 同学一样使用 recursive 来解的，很妙。\r\n\r\n### 代码\r\n\r\n```cpp\r\nstring Solution::decodeString(string s)\r\n{\r\n    stack<char> stack;\r\n    char c;\r\n    list<char> decoded;\r\n\r\n    for (int i = 0; i < s.length(); i++) {\r\n        c = s[i];\r\n\r\n        if (c != ']') {\r\n            stack.push(c);\r\n        } else {\r\n            list<char> tmp;\r\n\r\n            while (stack.top() != '[') {\r\n                tmp.push_front(stack.top());\r\n                stack.pop();\r\n            }\r\n            stack.pop();  // drop '['\r\n\r\n            // repeat\r\n              // the number can have more than 1 digit\r\n            int decimal = 1;\r\n            int times = 0;\r\n            while(!stack.empty() && isdigit(stack.top())) {  // must check empty here\r\n                times += (stack.top()-'0') * decimal;\r\n                decimal *= 10;\r\n                stack.pop();\r\n            }\r\n            repeat(stack, tmp, times);  // repeat and push back to stack\r\n        }\r\n    }\r\n\r\n    while (!stack.empty()) {\r\n        decoded.push_front(stack.top());\r\n        stack.pop();\r\n    }\r\n    return to_string(decoded);\r\n}\r\n\r\nvoid Solution::repeat(stack<char>& s, list<char>& l, int times)\r\n{\r\n    int len = l.size();\r\n    \r\n    // repeat\r\n    for (int i = 0; i < times-1; i++) {\r\n        auto ptr = l.begin();\r\n        for (int j = 0; j < len; j++) {\r\n            l.push_back(*ptr);\r\n            ptr++;\r\n        }\r\n    }\r\n    // push back. so they become content again.\r\n    for (auto p = l.begin(); p != l.end(); p++) {\r\n        s.push(*p);\r\n    }\r\n}\r\n\r\nstring Solution::to_string(list<char>& l)\r\n{\r\n    stringstream ss;\r\n    for (auto p = l.begin(); p != l.end(); p++) {\r\n        ss << *p;\r\n    }\r\n    return ss.str();\r\n}\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为 string 长度。\r\n\r\n- 时间复杂度：$O(n)$， 因为 repeat 和再次 push/pop 会有多余的操作，但还是在常数范围内。\r\n- 空间复杂度：$O(n)$","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995504710","body":"### 思路\r\n\r\n经典题目了。大家学数据结构的时候应该老师都有讲过。\r\n\r\n核心就是关注于 container 的功能而非实现。\r\n对于 queue 来说，FIFO 是其功能；而 stack 是 LIFO。\r\n我们只要将 stack 掉一个向，就能实现 FIFO。\r\n\r\n为了降低复杂度，我们可以使用两个 stack。\r\n我将其中一个称为 ”show“，一个称为 ”store“。show 用来为用户提供 FIFO 的机能。store 用来储存。\r\n我们只有当 show 为空的时候才将 store 中的内容转入 show （LIFO -> FIFO)，操作当的近似复杂度就可以为 $O(1)$ 了。\r\n\r\n### 代码\r\n\r\nCPP\r\n\r\n```cpp\r\nclass MyQueue {\r\npublic:\r\n    MyQueue(): size(0){\r\n    }\r\n    \r\n    void push(int x) {\r\n        store.push(x);\r\n        size++;\r\n    }\r\n    \r\n    int pop() {\r\n        int ret;\r\n\r\n        migrate();\r\n        ret = show.top();\r\n        show.pop();\r\n        size --;\r\n\r\n        return ret;\r\n    }\r\n    \r\n    int peek() {\r\n        migrate();\r\n        return show.top();\r\n    }\r\n    \r\n    bool empty() {\r\n        return size == 0;\r\n    }\r\nprivate:\r\n    int size;\r\n    stack<int> show, store;\r\n\r\n    void migrate()\r\n    {\r\n        if (!show.empty())\r\n            return;\r\n        \r\n        while (!store.empty()) {\r\n            show.push(store.top());\r\n            store.pop();\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间：amortized O(1) \r\n- 空间：O(N), N is the number of elements in the queue","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"orderkk":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991902776","body":"function fn(arr, number) {\n    let a1 = Number(arr.join(''));\n    let result = BigInt(a1) + BigInt(number)\n    return String(result).split('')\n}","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992584465","body":"var shortestToChar = function (s, c) {\n  let length = s.length\n  let arr = new Array(length).fill(length)\n  let array = s.split('');\n\n  for (let i = 0; i < length; i++) {\n    for (let j = i; j < length; j++) {\n      if (array[j] === c) {\n        arr[i] = j - i\n        break\n      }\n    }\n  }\n  for (let i = length - 1; i >= 0; i--) {\n    for (let j = i; j >= 0; j--) {\n      if (array[j] === c && arr[i] > i - j) {\n        arr[i] = i - j\n        break\n      }\n    }\n  }\n  return arr\n};","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994891641","body":"var decodeString = function (s) {\n            let result = '' // 字符串的“搬运工”\n            let strStack = [] // 存 待拼接的str 的栈\n            let numStack = [] // 存倍数的栈\n            let num = 0  // 倍数的“搬运工”\n            for (let i of s) {\n\n                if (!isNaN(i)) {\n                    num = num * 10 + Number(i)\n                } else if (i == '[') {\n                    strStack.push(result)\n                    result = ''\n                    numStack.push(num)\n                    num = 0\n                } else if (i == ']') {\n                    let repeatTimes = numStack.pop(); // 获取拷贝次数\n                    console.log(repeatTimes)\n                    result = strStack.pop() + result.repeat(repeatTimes); // 构建子串\n                } else {\n                    result += i;\n                }\n            }\n            return result\n        };","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"dudongli":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991903064","body":"思路：,将num和k从个位起逐位相加，最终然后反转res即可。\nfor i in range(len(num)-1,-1, -1):\n            A = num[i] + k % 10\n            k = k // 10\n            if A >= 10:\n                k += 1\n            res.append(A%10)\n        while k >0:\n            res.append(k%10)\n            k = k // 10\n        res.reverse()\n        return(res)\n时间复杂度O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"cureforu":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991904791","body":"### 思路\n\n模拟竖式计算\n\n### 代码\n\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int idx = num.length-1;\n        int carry = 0;\n        while (idx >= 0 || k > 0) {\n            int x = idx >= 0 ? num[idx] : 0;\n            int y = k > 0 ? k % 10 : 0;\n            int sum = x+y+carry;\n            res.add(0, sum%10);\n            carry = sum / 10;\n            idx--;\n            k /= 10;\n        }\n        if (carry == 1) {\n            res.add(0, 1);\n        }\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992260956","body":"```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int slow = 0;\n        int preFast = -1;\n        int[] res = new int[s.length()];\n        for (int fast = 0; fast < s.length(); fast++) {\n            if (s.charAt(fast) != c) {\n                continue;\n            }\n            while (slow <= fast) {\n                if (preFast == -1 || slow-preFast > fast-slow) {\n                    res[slow] = fast - slow;\n                    slow++;\n                }else {\n                    res[slow] = slow - preFast;\n                    slow++;\n                }\n            }\n            preFast = fast;\n        }\n        while (slow < s.length()) {\n            res[slow] = slow-preFast;\n            slow++;\n        }\n        return res;\n    }\n}\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993407777","body":"### 思路\n\n辅助栈\n\n### 代码\n\n\n```java\nclass CustomStack {\n    LinkedList<Integer> stack;\n    LinkedList<Integer> helper;\n    int maxSize;\n    int size;\n\n    public CustomStack(int maxSize) {\n        stack = new LinkedList<>();\n        helper = new LinkedList<>();\n        this.maxSize = maxSize;\n        this.size = 0;\n    }\n    \n    public void push(int x) {\n        if (size < maxSize) {\n            stack.push(x);\n            size++;\n        }\n    }\n    \n    public int pop() {\n        if (size > 0) {\n            size--;\n            return stack.pop();\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        if (k > size) {\n            k = size;\n        }\n        while (!stack.isEmpty()) {\n            helper.push(stack.pop());\n        }\n        while (!helper.isEmpty()) {\n            int temp = helper.pop();\n            if (k-- > 0) {\n                temp += val;\n            }\n            stack.push(temp);\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lilililisa1998":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991905659","body":"思路：先把数字k转化为数组，然后比较两个数组的长度，用0将较短的数组填充到与长数组等长，然后进行等位相加\r\nclass Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n \r\n        L_k = []\r\n        while (k / 10 != 0):\r\n            L_k.append(k % 10)\r\n            k=int(k / 10)\r\n        num= list(reversed(num))\r\n        ln=len(num)\r\n        lk=len(L_k)\r\n        if lk>ln:\r\n            q=[0]*(lk-ln)\r\n            num.extend(q)\r\n        elif lk==ln:\r\n            num.append(0)\r\n        else:\r\n            q=[0]*(ln-lk)\r\n            L_k.extend(q)\r\n\r\n        for i in range(len(num)-1):\r\n            w=num[i] + L_k[i]\r\n            num[i]=w%10\r\n            num[i+1]=int(w/10)+num[i+1]\r\n        if num[len(num)-1]==0:\r\n            num=num[:-1]\r\n        num = list(reversed(num))\r\n        return num\r\n\r\n时间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992068957","body":"思路：构建关于c的词典，存储c的坐标，然后遍历s，让s中的坐标和c的坐标相减，选择绝对值最小的\r\ndef shortestToChar( s, c):\r\n    \"\"\"\r\n    :type s: str\r\n    :type c: str\r\n    :rtype: List[int]\r\n    \"\"\"\r\n    dc=dict(name=c)\r\n    q=[]\r\n    for i in  range(len(s)): #构建关于c的词典\r\n        if(s[i] == c):\r\n            q.append(i)\r\n            dc['name']=q\r\n    \r\n    b=[]\r\n    for i in range(len(s)):\r\n        a = []\r\n        for j in dc['name']:\r\n            a.append(abs(j-i))\r\n            k=min(a)\r\n        b.append(k)\r\n    return b\r\n\r\n时间复杂度：O（n^3）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993496290","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.stack = [0] * maxSize\r\n        self.nums = [0] * maxSize ##num数组记录着inc操作要增加的数\r\n        self.size = maxSize - 1\r\n        self.p = -1\r\n\r\n    def push(self, x):\r\n        if self.p != self.size:\r\n            self.p += 1\r\n            self.stack[self.p] = x\r\n\r\n    def pop(self):\r\n        if self.p == -1:\r\n            return -1\r\n        x, val = self.stack[self.p], self.nums[self.p]\r\n        self.nums[self.p] = 0 \r\n        self.p -= 1\r\n        if self.p != -1:\r\n            self.nums[self.p] += val\r\n        return x + val\r\n\r\n    def increment(self, k, val):\r\n        if self.p >= 0:\r\n            k = min(self.p, k - 1)\r\n            self.nums[k] += val##self.nums[self.p]表示self.p位置以及它前面的位子在经过inc操作后应该加上的数字\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994770850","body":"##思路：把数组为栈，k[encoded_string]为一个可扩张项目，遇到‘]’时找到它负责的项目并扩展\r\ndef decodeString(s):\r\n    \"\"\"\r\n    :type s: str\r\n    :rtype: str\r\n    \"\"\"\r\n    i=0\r\n    while i <len(s):  #与for相比，while可以每回合更新循环范围，避免数组溢出\r\n        if s[i]==']':\r\n            for p in range(i-1,-1,-1):\r\n                if s[p]=='[':\r\n                    q=p-1\r\n                    k=0\r\n                    num=0\r\n                    while s[q].isdigit():  #计算k[encoded_string]中的k，也就是num\r\n                        num = num +int(s[q])*10**k\r\n                        k=k+1\r\n                        q=q-1\r\n                    a=s[p+1:i]*num    ##[encoded_string]*k\r\n                    if i!=len(s)-1:\r\n                        s=s[0:q+1]+a+s[i+1:]\r\n                        i = q+len(a)  #q是a前面一个位置，为了节约遍历时间，i直接从新加入到a的下一个位置开始\r\n                        break\r\n                    else:\r\n                        s = s[0:q+1] + a   ##避免s[i+1]越界\r\n                        break\r\n        i=i+1\r\n    return s\r\n\r\n#时间复杂度O(n^3)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995383226","body":"class MyQueue(object):\r\n\r\n    def __init__(self):\r\n        self.stack=[]\r\n    def push(self, x):\r\n        self.stack.append(x)\r\n    def pop(self):\r\n        a=self.stack[0]\r\n        self.stack=self.stack[1:] ##队头就是stack[0]\r\n        return a\r\n\r\n    def peek(self):\r\n        return self.stack[0]\r\n    def empty(self):\r\n        if len(self.stack)!=0:\r\n            return False\r\n        else:\r\n            return True\r\n时间复杂度O(1)\r\n空间复杂度O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"macvh":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991905870","body":"class Solution(object):\r\n    def addToArrayForm(self, num, k):\r\n        \"\"\"\r\n        :type num: List[int]\r\n        :type k: int\r\n        :rtype: List[int]\r\n        思路：类似于大数相加，先把数字k转化为数组，\r\n        \"\"\"\r\n        L_k = []\r\n        while (k / 10 != 0):\r\n            L_k.append(k % 10)\r\n            k=int(k / 10)\r\n        num= list(reversed(num))\r\n        ln=len(num)\r\n        lk=len(L_k)\r\n        if lk>ln:\r\n            q=[0]*(lk-ln)\r\n            num.extend(q)\r\n        elif lk==ln:\r\n            num.append(0)\r\n        else:\r\n            q=[0]*(ln-lk)\r\n            L_k.extend(q)\r\n\r\n        for i in range(len(num)-1):\r\n            w=num[i] + L_k[i]\r\n            num[i]=w%10\r\n            num[i+1]=int(w/10)+num[i+1]\r\n        if num[len(num)-1]==0:\r\n            num=num[:-1]\r\n        num = list(reversed(num))\r\n        return num","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992461416","body":"思路：构建关于c的词典，存储c的坐标，然后遍历s，让s中的坐标和c的坐标相减，选择绝对值最小的\r\n'''\r\n\r\ndef shortestToChar( s, c):\r\n    \"\"\"\r\n    :type s: str\r\n    :type c: str\r\n    :rtype: List[int]\r\n    \"\"\"\r\n    dc=dict(name=c)\r\n    q=[]\r\n    for i in  range(len(s)): #构建关于c的词典\r\n        if(s[i] == c):\r\n            q.append(i)\r\n            dc['name']=q\r\n\r\n    b=[]\r\n    for i in range(len(s)):\r\n        a = []\r\n        for j in dc['name']:\r\n            a.append(abs(j-i))\r\n            k=min(a)\r\n        b.append(k)\r\n    return b","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993566960","body":"class CustomStack(object):\r\n\r\n    def __init__(self, maxSize):\r\n        self.stack = [0] * maxSize\r\n        self.nums = [0] * maxSize ##num数组记录着inc操作要增加的数\r\n        self.size = maxSize - 1\r\n        self.p = -1\r\n\r\n    def push(self, x):\r\n        if self.p != self.size:\r\n            self.p += 1\r\n            self.stack[self.p] = x\r\n\r\n    def pop(self):\r\n        if self.p == -1:\r\n            return -1\r\n        x, val = self.stack[self.p], self.nums[self.p]\r\n        self.nums[self.p] = 0\r\n        self.p -= 1\r\n        if self.p != -1:\r\n            self.nums[self.p] += val\r\n            # 如果只剩一个元素，直接pop\r\n            # 如果多于一个元素，pop出去的同时，未来第一个元素要继承一下加的val\r\n        return x + val\r\n\r\n    def increment(self, k, val):\r\n        if self.p >= 0:\r\n            k = min(self.p, k - 1)\r\n            self.nums[k] += val##self.nums[self.p]表示self.p位置以及它前面的位子在经过inc操作后应该加上的数字","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994796777","body":"##思路：把数组为栈，k[encoded_string]为一个可扩张项目，遇到‘]’时找到它负责的项目并扩展\r\ndef decodeString(s):\r\n    \"\"\"\r\n    :type s: str\r\n    :rtype: str\r\n    \"\"\"\r\n    i=0\r\n    while i <len(s):  #与for相比，while可以每回合更新循环范围，避免数组溢出\r\n        if s[i]==']':\r\n            for p in range(i-1,-1,-1):\r\n                if s[p]=='[':\r\n                    q=p-1\r\n                    k=0\r\n                    num=0\r\n                    while s[q].isdigit():  #计算k[encoded_string]中的k，也就是num\r\n                        num = num +int(s[q])*10**k\r\n                        k=k+1\r\n                        q=q-1\r\n                    a=s[p+1:i]*num    ##[encoded_string]*k\r\n                    if i!=len(s)-1:\r\n                        s=s[0:q+1]+a+s[i+1:]\r\n                        i = q+len(a)  #q是a前面一个位置，为了节约遍历时间，i直接从新加入到a的下一个位置开始\r\n                        break\r\n                    else:\r\n                        s = s[0:q+1] + a   ##避免s[i+1]越界\r\n                        break\r\n        i=i+1\r\n    return s\r\n\r\n#时间复杂度O(n^3)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"callmeeliza":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991907902","body":"## 思路\n新增temp数组存上次计算的进位1，每次取三个数组的末位数进行相加，取余数存进res数组中，直到三个数组都空的时候，计算结束\n## 代码\n```javascript\nvar addToArrayForm = function(num, k) {\n    let cur = String(k).split('');\n    let res = [];\n    let temp = []\n    while(num.length > 0 || cur.length > 0 || temp.length > 0) {\n        let a = Number(num.pop() || 0);\n        let b = Number(cur.pop() || 0);\n        let c = Number(temp.pop() || 0);\n        if(a + b + c >= 10) {\n            res.unshift((a+ b + c)%10);\n            temp.push(1);\n        } else {\n            res.unshift(a+b+c)\n        }\n    }\n    return res\n};\n```\n## 复杂度分析\n-时间复杂度：O(n)，其中n为num和k的最大长度\n-空间复杂度：O(n)，其中n为num和k的最大长度或最大长度+1","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992262098","body":"## 思路\n将字符串S以字符C为界划分成字符串数组，首尾注意特殊处理，中间的字符串以中点为界分别计算距左右两边的距离\n##代码\n```javascript\nvar shortestToChar = function(s, c) {\n  let arr = s.split(c);\n  let res = [];\n  arr.forEach((str, index) => {\n    for (let i = 0; i < str.length; i++) {\n      switch (true) {\n        case index === arr.length - 1:\n        case index !== 0 && i < Math.ceil(str.length / 2):\n          res.push(i + 1);\n          break;\n        case index === 0:\n        case i >= Math.ceil(str.length / 2):\n          res.push(str.length - i);\n          break;\n      }\n    }\n    if (index < arr.length - 1) res.push(0);\n  });\n  return res;\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993324968","body":"## 思路\n没什么复杂思路，主要靠js的数组的push和pop\n## 代码\n```javascript\nvar CustomStack = function(maxSize) {\n    size = maxSize;\n    arr = [];\n};\n\nCustomStack.prototype.push = function(x) {\n    if(arr.length < size) {\n        arr.push(x)\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(arr.length === 0) {\n        return -1;\n    } else {\n        return arr.pop();\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<k&&i<arr.length;i++){\n        arr[i]+=val\n    }\n};\n```\n## 复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994886262","body":"## 思路\n先用栈定位每个 [ 对应的 ] ，并记录对应数字，然后遍历数组，从中间没有多余括号的一对括号内开始进行替换\n## 代码\n```javascript\nvar decodeString = function(s) {\n    let arr = s.split('');\n    let numArr = []\n    let numObj = {}\n    let bracketObj = {}\n    let left = []\n    let right = []\n    arr.forEach((vv,index)=>{\n        if(/\\d/g.test(vv)) {\n            numArr.push(vv);\n        }\n        if(vv==='['){\n            left.push(index);\n            numObj[index] = numArr.join('');\n            numArr = [];\n            return;\n        }\n        if(vv===']') {\n            bracketObj[left.pop()] = index;\n            right.push(index);\n        }\n    })\n    while(arr.indexOf('[') > 0) {\n        for(let key in bracketObj){\n            let before = Number(key);\n            let after = Number(bracketObj[key]);\n            let target = arr.slice(before + 1,after).join('');\n            if(target.indexOf('[') < 0) {\n                let str = ''\n                for(let i = 0; i< Number(numObj[key]);i++) {\n                    str = str + target;\n                }\n                var start = before - numObj[key].length;\n                var end = after;\n                var amount = end - start + 1;\n                var to = [str];\n                for(let i = 0;i<amount-1;i++){\n                    to.push('')\n                }\n                arr.splice(start, amount, ...to);\n                delete bracketObj[key]\n            }\n        }\n        \n    }\n    return arr.join('');\n};\n```\n## 复杂度\n时间复杂度：O(n+m)，m为括号对的数量","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995388562","body":"## 思路\n利用js中的数组的shift和push\n## 代码\n```javascript\nvar MyQueue = function() {\n    arr = []\n};\n\nMyQueue.prototype.push = function(x) {\n    arr.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    return arr.shift();\n};\n\nMyQueue.prototype.peek = function() {\n    return arr[0];\n};\n\nMyQueue.prototype.empty = function() {\n    return arr.length === 0\n};\n```\n## 复杂度\n时间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tiquiero":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991910240","body":"### 思路\n把数组A从后开始循环，整数K也从个位数开始，把两个相加，\n如果大于10有进位，把进位存carry变量，结果res存数组。\n每次循环把carry一起相加，最后反转res数组。\n\n### 代码\n\n```js\nvar addToArray = function(A, K) {\n    const res = [];\n    let i = A.length - 1, carry = 0;\n    while (i >=0 || K != 0) {\n        const x = i >= 0 ? num[i] : 0;\n        const y = K != 0 ? K % 10 : 0;\n        const sum = x + y + carry;\n\n        res.push(sum % 10);\n        carry = Math.floor(sum / 10);\n        i--;\n        K = Math.floor(K / 10);\n    }\n    if (carry) res.push(carry);\n    return res.reverse();\n}\n```\n\n** 复杂度分析 **\n- 时间复杂度O（n）\n- 空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992580358","body":"***思路\r\n设置左右两个变量，表示从两边开始最近一个和目标字符的距离，然后取他们的最小值存在res中。\r\n\r\n```js\r\nvar shortestToChar = function(s, c) {\r\n  let res = [];\r\n  for (let i = 0; i < s.length; i++) {\r\n    // left为i元素距离左边最近的一个C的距离；right为i元素距离右边最近的一个C的距离\r\n    let left = 0, right = 0;\r\n\r\n    while(left >= 0 && right < s.length ) {\r\n      if (s[i - left] === c || s[i + right] === c) {\r\n        res[i] = Math.min(left, right);\r\n        break;\r\n      }\r\n      left++;\r\n      right++;\r\n    }\r\n  }\r\n  return res;\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993315555","body":"*** 思路\n利用JS的数组来实现push和pop，最后一个根据规则相加val。\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function (maxSize) {\n  this.list = [];\n  this.maxSize = maxSize;\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function (x) {\n  if (this.list.length < this.maxSize) this.list.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function () {\n  return this.list.length ? this.list.pop() : -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function (k, val) {\n  let length = Math.min(k, this.list.length);\n  for (let i = 0; i < length; i++) {\n    this.list[i] += val;\n  }\n};\n```\n时间复杂度：push、pop：O(1)， increment：O(k)\n空间复杂度：O(maxSize)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995530989","body":"*** 思路\n利用JS的数组\n\n```js\nvar MyQueue = function() {\n  this.pushStack = [];\n  this.popStack = [];\n};\n\nMyQueue.prototype.push = function(x) {\n  this.pushStack.push(x);\n};\n\nMyQueue.prototype.pop = function() {\n  if (!this.popStack.length) {\n    while (this.pushStack.length) {\n      this.popStack.push(this.pushStack.pop());\n    }\n  }\n  return this.popStack.pop();\n};\n\nMyQueue.prototype.peek = function() {\n  if (!this.popStack.length) {\n    while (this.pushStack.length) {\n      this.popStack.push(this.pushStack.pop());\n    }\n  }\n  return this.popStack[this.popStack.length - 1];\n};\n\nMyQueue.prototype.empty = function() {\n  return !this.pushStack.length && !this.popStack.length;\n};\n```\n\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"lifuquan1208":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991910622","body":"思路：首先循环数组的，取得数组的末位进行相加之后的取余，放进结果数组，然后对相加后的结果除10去掉末位，循环结束后需要把相加的最后结果放进结果的集合中。\n代码：\n  class Solution {\n\n​    public List<Integer> addToArrayForm(int[] num, int k) {\n\n​         List<Integer> result = new ArrayList<Integer>();\n\n​        int len=num.length-1;\n\n​        for (int i=len; i>=0;i--){\n\n​            int temp=num[i]+k;\n\n​            result.add(temp%10);\n\n​             k=temp/10;\n\n​        }\n\n​        while(k!=0){\n\n​            result.add(k%10);\n\n​            k=k/10;\n\n​        }\n\n​        Collections.reverse(result);\n\n​        return result;\n\n​    }\n\n时间复杂度：0（n)\n空间复杂度：0（n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992414881","body":"### 思路：\n首先循环数组获取所有字符C出现的位置放在集合中，然后定义两个变量变量一个为一个的前一次出现的字符C的集合下标，然后根据前后与数组下标的绝对值比较，得出数值放到结果集中。\n\n### 代码：\n``` java \n public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        int j=0;\n        int k=0;\n        int result=0;\n        ArrayList<Integer> cValue = new ArrayList<Integer>();\n        for (int i = 0; i < s.length(); i++) {\n            if(s.charAt(i)==c){\n                cValue.add(i);\n            }\n        }\n        for (int i = 0; i < s.length(); i++) {\n            if(Math.abs(cValue.get(j) -i)<=Math.abs(cValue.get(k) -i)){\n                result=Math.abs(cValue.get(j) -i);\n            }else{\n                result=Math.abs(cValue.get(k) -i);\n            }\n            answer[i]= result;\n            if(result == 0&& cValue.size()>1 && j+1<=cValue.size()-1){\n                k=j;\n                j=j+1;\n            }\n        }\n        return  answer;\n}\n```\n**复杂度分析**\n- 时间复杂度：o(n²）\n- 空间复杂度：o(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993502393","body":"### 思路；直接双栈了\n### 代码：\n``` java \n Stack<Integer> stack;\n    Stack<Integer> stack2=new Stack<Integer>();\n    int s;\n    public CustomStack(int maxSize) {\n        stack=new Stack<Integer>();\n        s=maxSize;\n    }\n\n    public void push(int x) {\n        if(stack.size()<s){\n            stack.push(x);\n        }\n    }\n\n    public int pop() {\n        if(stack.isEmpty()){\n            return -1;\n        }\n        return stack.pop();\n    }\n\n    public void increment(int k, int val) {\n        int count=0;\n        if(k>stack.size()){\n            while(stack.size()>0){\n                int z=stack.pop();\n                stack2.push(z);\n            }\n\n            while(stack2.size()>0){\n                int z=stack2.pop();\n                count++;\n                if(count <= k ){\n                    stack.push(z+val);\n                }else{\n                    stack.push(z);\n                }\n            }\n\n\n        }else{\n            while(stack.size()>0){\n                int z=stack.pop();\n                stack2.push(z+val);\n            }\n\n            while(stack2.size()>0){\n                int z=stack2.pop();\n                stack.push(z);\n            }\n        }\n    }\n```\n**复杂度分析**\n- 时间复杂度：\n-空间复杂度：\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994815287","body":"###  思路：\n看了题解之后明白了双栈，自己没写出来\n### 代码：\n```  java \nclass Solution {\n    public String decodeString(String s) {\n         Stack<String> str = new Stack<>();\n        Stack<Integer> num = new Stack<>();\n        StringBuilder result = new StringBuilder();\n        int number=0;\n        for(int i=0;i<s.length();i++){\n         if(s.charAt(i)>= '0' && s.charAt(i) <= '9'){\n             number= number * 10+Integer.parseInt(String.valueOf(s.charAt(i)));\n         }else if(s.charAt(i)=='['){\n           num.push(number);\n           str.push(result.toString());\n           number=0;\n           result=new StringBuilder();\n         }else if(s.charAt(i)==']'){\n             int index = num.pop();\n             StringBuilder temp = new StringBuilder();\n             for (int j = 0; j < index; j++) {\n                 temp.append(result);\n             }\n            result = new StringBuilder(str.pop() + temp);\n         }else {\n             result.append(s.charAt(i));\n         }\n      }\n      return  result.toString();\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：O（n）\n- 空间复杂度：O（n） ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995836821","body":"### 思路：\r\n双栈，在相应的操作后，把数据进行复制\r\n### 代码:\r\n``` java\r\nStack<Integer> stack;\r\n      Stack<Integer> stack1;\r\n    public void MyQueue() {\r\n     stack=new Stack<Integer>();\r\n     stack1=new Stack<Integer>();\r\n    }\r\n\r\n    public void push(int x) {\r\n       stack.push(x);\r\n       stack1.push(x);\r\n    }\r\n\r\n    public int pop() {\r\n       int result=stack.get(0);\r\n       stack=new Stack<Integer>();\r\n       for (int i=1;i<stack1.size();i++){\r\n           stack.push(stack1.get(i));\r\n       }\r\n       stack1=stack;\r\n      return  result;\r\n    }\r\n\r\n    public int peek() {\r\n        int result=stack1.get(0);\r\n        stack.push(result);\r\n        return  stack.pop();\r\n    }\r\n\r\n    public boolean empty() {\r\n      if(stack.isEmpty()){\r\n          return  true;\r\n      }\r\n      return  false;\r\n    }\r\n\r\n    public static void main(String[] args) {\r\n    }\r\n```\r\n**复杂度分析**\r\n-时间复杂度：均摊是O(1)\r\n-空间复杂度:  O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weijie-he":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991911734","body":"## 思路\n\n模拟真正的加法计算过程\n\n从后往前依次逐位相加，如果 >=10 则进位\n\n\n\n## 代码\n\n```java\npublic List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> result = new ArrayList<>();\n        int len = num.length;\n        for (int i = len - 1;i >= 0;i--){\n            int a = num[i] + k % 10;\n            k /= 10;\n            // 如果和 > 10，需要进位\n            if (a >= 10 ){\n                k++;\n            }\n            result.add(a % 10);\n        }\n\n        // 上面循环做完，只求了结果后len位的值，由于可能进位，所以k可能还有很多位\n        for (; k > 0; k /= 10) {\n            result.add(k % 10);\n        }\n\n        Collections.reverse(result);\n        return result;\n\n    }\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：O(N)，遍历数组的时间\n- 空间复杂度：O(N)，存储 result 的空间\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992232798","body":"## 思路\n\n中心扩展法\n\n左右双指针往两边走\n\n\n\n## 代码\n\n```java\n    public int[] shortestToChar(String s, char c) {\n        return solution1(s,c);\n    }\n\n    /**\n     *  中心扩展法\n     *  左右双指针往两边走\n     *\n     *  时间复杂度：O(N^2)，N 为 S 的长度，两层循环。\n     *  空间复杂度：O(N)\n     *\n     * @param s\n     * @param c\n     * @return\n     */\n    private int[] solution1(String s, char c) {\n        char [] arr = s.toCharArray();\n        int[] distance = new int[s.length()];\n\n        for (int i = 0; i < s.length(); i++){\n            if (arr[i] == c){\n                continue;\n            }\n\n            int left = i;\n            int right = i;\n            // 这边是或的关系，只要有一头没到顶，就继续走\n            // 在循环内部用 if 来控制指针的加减\n            while (left>=0 || right < s.length()){\n                if(arr[left] == c){\n                    distance[i] = i - left;\n                    // 找到后，别忘了立马跳出循环\n                    break;\n                }\n\n                if(arr[right] == c){\n                    distance[i] = right - i;\n                    break;\n                }\n\n                if (left>0){\n                    left--;\n                }\n\n                if (right<s.length()-1){\n                    right++;\n                }\n            }\n        }\n\n        return distance;\n    }\n```\n\n\n## 复杂度分析\n\n- 时间复杂度：O(N^2)，N 为 S 的长度，两层循环。\n- 空间复杂度：O(N)\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"seventeencui":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991915088","body":"### 思路\r\n先反转，然后模拟加法运算。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> addToArrayForm(vector<int>& num, int k) {\r\n        reverse(num.begin(), num.end());\r\n\r\n        for (auto& x: num) {\r\n            k += x;\r\n            x = k % 10;\r\n            k /= 10;\r\n        }\r\n        while (k) num.push_back(k % 10), k /= 10;\r\n\r\n        reverse(num.begin(), num.end());\r\n        return num;\r\n    }\r\n};\r\n\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992590965","body":"### 思路\r\n两次遍历\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) {\r\n        int n = s.size();\r\n        vector<int> res(n, INT_MAX);\r\n        for(int i = 0, j = -1; i < n; i ++) {\r\n            if(s[i] == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = i - j;\r\n            }\r\n        }\r\n        for(int i = n - 1, j = -1; i >= 0; i --) {\r\n            if(s[i] == c) {\r\n                j = i;\r\n            }\r\n            if(j != -1) {\r\n                res[i] = min(res[i], j - i);\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993683715","body":"### 思路\r\n使用数组去模拟栈\r\n### 代码\r\n```\r\n\r\nclass CustomStack {\r\nprivate:\r\n    int maxSize;\r\n    vector<int> s;\r\npublic:\r\n    CustomStack(int maxSize) : maxSize(maxSize) {\r\n        s.reserve(maxSize);\r\n    }\r\n    \r\n    void push(int x) {\r\n        if (s.size() < maxSize)\r\n        {\r\n            s.push_back(x);\r\n        }\r\n    }\r\n    \r\n    int pop() {\r\n        if (!s.empty())\r\n        {\r\n            int res = s.back();\r\n            s.pop_back();\r\n            return res;\r\n        }\r\n        else\r\n        {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    void increment(int k, int val) {\r\n        for (int i = min(k, int(s.size()))-1; i >= 0 ; --i)\r\n        {\r\n            s[i] += val;\r\n        }\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994862757","body":"### 思路\r\n使用栈，利用栈的特性进行模拟。\r\n### 代码\r\n```\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        int num=0;\r\n        string cur;\r\n\r\n        stack<int> nums;\r\n        stack<string> strs;\r\n        for(int i=0;i<s.size();i++){\r\n            if(s[i]=='['){\r\n                nums.push(num);\r\n                strs.push(cur);\r\n                num=0;\r\n                cur=\"\";\r\n            }\r\n            else if(s[i]==']'){\r\n                int x=nums.top();\r\n                nums.pop();\r\n                string tmp=cur;\r\n                cur=strs.top();\r\n                strs.pop();\r\n                while(x--) cur+=tmp;\r\n            }\r\n            else if(s[i]>='0'&&s[i]<='9'){\r\n                num = num*10 + s[i] - '0';\r\n            }\r\n            else{\r\n                cur+=s[i];\r\n            }\r\n        }\r\n        return cur;\r\n    }\r\n};\r\n```\r\n### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fornobugworld":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991916230","body":"### 思路\n\n参考了题解中两数相加通用模板\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\ndef addToArrayForm(self, A: List[int], K: int) -> List[int]:\n    res = []\n    i, carry = len(A) - 1, 0\n    while i >= 0 or K != 0:\n        x = A[i] if i >= 0 else 0\n        y = K % 10 if K != 0 else 0\n\n        sum = x + y + carry\n        res.append(sum % 10)\n        carry = sum // 10\n\n        i -= 1\n        K //= 10\n    if carry != 0: res.append(carry)\n    return res[::-1]\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992583548","body":"### 思路\n\n参考标答，从左向右一次，只记录前一个C和自己的距离，再从右向左一次，两次取最小值\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass Solution(object):\n    def shortestToChar(self, S, C):\n        prev = float('-inf')\n        ans = []\n        for i, x in enumerate(S):\n            if x == C: prev = i\n            ans.append(i - prev)\n\n        prev = float('inf')\n        for i in xrange(len(S) - 1, -1, -1):\n            if S[i] == C: prev = i\n            ans[i] = min(ans[i], prev - i)\n\n        return ans\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993659602","body":"### 思路\n\n没做出来，直接看题解了：使用数组模拟栈，用一个变量 top 来记录当前栈顶的位置。\n\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stk = [0] * maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top != len(self.stk) - 1:\n            self.top += 1\n            self.stk[self.top] = x\n\n    def pop(self) -> int:\n        if self.top == -1:\n            return -1\n        self.top -= 1\n        return self.stk[self.top + 1]\n\n    def increment(self, k: int, val: int) -> None:\n        lim = min(k, self.top + 1)\n        for i in range(lim):\n            self.stk[i] += val\n\n\n\n```\n\n**复杂度分析**\n\n-时间复杂度：初始化（构造函数）、push 操作和 pop 操作的渐进时间复杂度为 O(1)，inc 操作的渐进时间复杂度为 O(k)。\n\n-空间复杂度：这里用到了一个长度为 maxSize 的数组作为辅助空间，渐进空间复杂度为 O(maxSize)。\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994914241","body":"### 思路\n\n看题解了，构建辅助栈 stack， 遍历字符串 s 中每个字符 c\n\n### 代码\n\n\n```py（此处换成你的语言，比如js，py 等）\n（此处撰写代码）\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack, res, multi = [], \"\", 0\n        for c in s:\n            if c == '[':\n                stack.append([multi, res])\n                res, multi = \"\", 0\n            elif c == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0' <= c <= '9':\n                multi = multi * 10 + int(c)            \n            else:\n                res += c\n        return res\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"zhouxsss":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991917000","body":"### 思路\n数组倒叙和加数 K 的个位数相加，K 减掉个位数模10后进位\n\n### 复杂度分析\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)\n\n### 代码\n\n```js\nfunction addToArrayForm(A, K) {\n  var ALen = A.length\n  if(!ALen) return []\n  // 进位\n  var add = 0\n  var res = []\n  for(let i = ALen - 1; i >= 0; i--) {\n    var basic = K % 10\n    // K % 10 个位数\n    var sum = A[i] + basic + add\n    if(sum >= 10) {\n      sum = sum - 10\n      add = 1\n    } else {\n        add = 0\n    }\n    res.unshift(sum)\n    K = (K - basic)/10\n  }\n  // 如果还有加项或者没加完的K的剩下位数，则直接连接\n  if(K || add) {\n    res = (K + add).toString().split('').concat(res)\n  }\n  return res\n}\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992529575","body":"### 思路\n对于每一个字母来说可能会有离左边最近的字符和离右边最近的字符。\n正向遍历一遍找出左边最近距离，反向遍历一遍右边最近的字符，对比求出最短距离。\n\n### 复杂度\n时间复杂度 O(n)，n为数组长度\n空间复杂度 O(n)，n为数组长度\n\n### 代码\n```js\n  /**\n   * @param {string} S\n   * @param {character} C\n   * @return {number[]}\n   */\n  function shortestToChar(S, C) {\n    var len = S.length\n    var res = new Array(len)\n    var arr = S.split('')\n    var dis = 10001\n    // 正向遍历\n    for(var i = 0; i < len; i++) {\n      if(S[i] === C) {\n        dis = 0\n      } else {\n        dis ++\n      }\n      res[i] = dis\n    }\n    var dis = 10001\n    // 反向遍历\n    for(var i = len - 1; i >= 0; i--) {\n      if(S[i] === C) {\n        dis = 0\n      } else {\n        dis ++\n      }\n      res[i] = Math.min(res[i], dis)\n    }\n    return res\n  }\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993599378","body":"/**\n * 复杂度分析：\n * 时间复杂度：push 和 pop 的时间复杂度为O(1),increment 的时间复杂度为O(n)\n * 空间复杂度：O(1)\n */\n\nfunction CustomStack(maxSize) {\n  this.maxSize = maxSize;\n  this.array = [];\n  return this;\n}\n\nCustomStack.prototype.push = function (item) {\n  if (this.array.length < this.maxSize) {\n    this.array.push(item);\n  } else {\n    console.log('超出');\n  }\n  return this.array;\n};\nCustomStack.prototype.pop = function () {\n  if (this.array.length === 0) return -1;\n  return this.array.pop();\n};\n/**\n * @param k<number> 栈底的 k 个元素\n * @param val<number> 加项\n * @summary 栈底的 k 个元素的值都增加 val\n */\nCustomStack.prototype.increment = function (k, val) {\n  var maxLen = k > this.maxSize ? this.maxSize : k;\n  for (var i = 0; i < maxLen; i++) {\n    this.array[i] += val;\n  }\n  return this.array;\n};\n\nconst stack = new CustomStack(3);\nconsole.log(stack.array);","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994895691","body":"### 思路\n利用辅助栈，保存重复次数以及前面遍历生成的结果字符串；\n每遇到左括号时压栈，遇到右括号时出栈, res 为当前字符串，和重复次数计算后，和前面的结果字符串拼接\n\n### 复杂度分析\n时间复杂度：O(n), n为数组长度\n空间复杂度：O(n), n为数组长度\n\n### 代码\n```js\n/**\n * @param {string} S\n * @return {string}\n */ \nvar decodeString = function (S) {\n  var stack = []\n  var k = 0\n  var res = ''\n  for(var i = 0; i < S.length; i++) {\n    var cur = S[i]\n    if(cur === '['){\n      // 把括号之前的结果缓存\n      stack.push([k, res])\n      // 重置当前字符串缓存\n      res = ''\n      k = 0\n    } else if(cur === ']') {\n      var [curr_k, last_res] = stack.pop()\n      res = last_res + new Array(curr_k).fill(res).join('')\n    } else if((/^\\d$/).test(cur)) {\n      k = k * 10 + Number(cur)\n    } else {\n      res += cur\n    }\n  }\n  return res\n}\n\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"hoye1113":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991917040","body":"思路：\r\n从k的个位和数组的最后元素入手，k先模10拿到个位，与数组最后一位相加后结果放入res数组，\r\n接着k/=10处理除去个位，继续拿十位数，与数组倒数第二个元素相加，如果有进位则返到k值\r\nk还小于0不需要进位且A数组没有值的情况，则环循环结束。\r\n\r\n代码：js语言\r\n\r\nvar addToArrayForm = function(A, K) {\r\n  let i = A.length - 1\r\n  let res = []\r\n  while (i >= 0 || K){\r\n    K += (A[i] || 0)\r\n    res.push( K % 10 )\r\n    K = K / 10 | 0\r\n    i--\r\n    }\r\n    return res.reverse()\r\n};\r\n\r\n\r\n复杂度分析：\r\n时间复杂度O（n）\r\n空间复杂度O（n）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992606180","body":"语言：js\r\n\r\n思路1:找到C在S中的所有索引，通过对比S[i]在CArray中最小的偏移量得到结果更新res[i]。\r\n\r\n```js\r\nvar shortestToChar = function (S, C) {\r\n    const res = Array(S.length)\r\n    const indexArr = []\r\n    for (let i = 0; i < S.length; i++) {\r\n        if (S[i] === C) {\r\n            indexArr.push(i)\r\n        }\r\n    }\r\n    for (let i = 0; i < S.length; i++) {\r\n        res[i] = indexArr.reduce((tmp, item) => {\r\n            return Math.min(tmp, Math.abs(i - item))\r\n        }, 10000)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n复杂度分析:  (n为S的legth，m为C在S中的数量)\r\n\r\n时间复杂度：O(nm)O(nm)    空间复杂度：O(nm)O(nm)\r\n\r\n\r\n\r\n思路2:中心扩展法，定义一个diff变量，让diff逐渐增加，直到两侧有一侧找到C。将diff值push到res中。\r\n\r\n```js\r\nvar shortestToChar = function(S, C) {\r\n    const res = [] // 定义返回的数组\r\n    for (let i = 0; i < S.length; i++) {\r\n        let diff = 0; // 定义指针偏移量\r\n        while ((i - diff >= 0 || i + diff < S.length) && S[i - diff] != C && S[i + diff] != C) {\r\n            diff ++\r\n        }\r\n        res.push(diff)\r\n    }\r\n    return res\r\n};\r\n```\r\n\r\n复杂度分析:( n为S的length)\r\n\r\n时间复杂度：O(n^2)  空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993679674","body":"语言：js\n```js\nvar CustomStack = function(maxSize) {\n    this.size = maxSize;\n    this.list = [];\n};\n\n\nCustomStack.prototype.push = function(x) {\n    if(this.list.length < this.size){\n        this.list.push(x);\n    }\n};\n\nCustomStack.prototype.pop = function() {\n    if(this.list.length){\n        return this.list.pop();\n    }else{\n        return -1;\n    }\n};\n\nCustomStack.prototype.increment = function(k, val) {\n    if(this.list.length < k){\n        for(let i = 0; i < this.list.length; i ++){\n            this.list[i] += val\n        }\n    }else{\n        for(let i = 0; i < k; i ++){\n            this.list[i] += val\n        }\n    }\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994910316","body":"思路：使用栈的思想，用isNaN(x) 判断当前x是否是数字\n\n语言：js\n\n```js\nvar decodeString = function (s) {\n  let [stack, num, str] = [[], '', ''];\n  for (let i = 0; i < s.length; i++) {\n    //对数字进行类型转换\n    if (!isNaN(s[i])) {\n      num += s[i];\n      //当下一位不是数字的时候直接转换\n      if (isNaN(s[i + 1])) {\n        stack.push(Number(num));\n        num = '';\n      }\n      // 右括号开始计算\n    } else if (s[i] === ']') {\n      str = '';\n      //将需要计算的字符出栈\n      while (stack[stack.length - 1] !== '[') {\n        str = stack.pop() + str;\n      }\n      // 弹出\"[\"\n      stack.pop();\n      //将计算后的字符串入栈，repeat()是复制次数\n      stack.push(str.repeat(stack.pop()));\n      // 其他直接push进入stack\n    } else {\n      stack.push(s[i]);\n    }\n  }\n  return stack.join('');\n};\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995627412","body":"语言：js\n\n```js\nvar MyQueue = function () {\n  this.s1 = [];\n  this.s2 = [];\n};\n\nMyQueue.prototype.push = function (x) {\n  //推送到队列尾端\n  this.s1.push(x);\n};\n\nMyQueue.prototype.pop = function () {\n  // 先调用peek，保证s2非空，移除并返回元素\n  this.peek();\n  return this.s2.pop();\n};\n\nMyQueue.prototype.peek = function () {\n  // 如果是空的话\n  if (!this.s2.length) {\n    // 把s1元素全部压入s2中，返回队列开头的元素\n    while (this.s1.length) {\n      this.s2.push(this.s1.pop());\n    }\n  }\n  return this.s2[this.s2.length - 1];\n};\n\nMyQueue.prototype.empty = function () {\n    //返回队列是否为空\n    return !this.s1.length && !this.s2.length;\n};\n \n```\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"gaoyi86":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918034","body":"### 思路\n\n从低位到高位计算，注意进位和边界处理。\n\n### 代码\n\n```java\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            res.add(0, (num[i] + k) % 10);\n            k = (num[i] + k) / 10;\n        }\n\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}\n```\n\n**复杂度分析**\n\\- 时间复杂度：O(1)\n\\- 空间复杂度：O(1)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994761847","body":"思路\n括号匹配问题，栈，递归\n\n代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        num = 0\n        res = \"\"\n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == \"[\":\n                stack.append((res, num))\n                res, num = \"\", 0\n            elif c == \"]\":\n                top = stack.pop()\n                res = top[0] + res * top[1]\n            else:\n                res += c \n            print(stack)\n        return res\n\n\n复杂度分析\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"ivangin":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918630","body":"#### 思路：\r\n从右向左进行加法，记录进位，同时兼容超出num总位数的情况。使用LinkedList，参考链表头插法，减少后续转置操作。\r\n#### 代码\r\n```java \r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        int i = num.length - 1;\r\n        LinkedList<Integer> ans = new LinkedList<>();\r\n        while (k > 0 || i >= 0) {\r\n            if (i >= 0){\r\n                k += num[i--];\r\n            }    \r\n            ans.addFirst(k % 10);\r\n            k /= 10;\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度  O(max(m,n))，m是数组num的长度，n是k数位的个数\r\n空间复杂度 O(1)","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993206075","body":"#### 思路：\r\n使用数组和一个栈顶指针，同时注意初始化指针为-1的情况下，出入栈的指针操作。\r\n\r\n#### 代码：\r\n\r\n```java \r\nclass CustomStack {\r\n\r\n    private int[] stack;\r\n    private int top;\r\n    private int maxSize;\r\n    public CustomStack(int maxSize) { // CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize之后则不支持 push 操作。\r\n        this.stack = new int[maxSize];\r\n        this.top = -1;\r\n        this.maxSize = maxSize;\r\n    }\r\n\r\n    public void push(int x) {//如果栈还未增长到 maxSize ，就将 x 添加到栈顶。\r\n        if (top == stack.length - 1){\r\n        return;\r\n        }\r\n        stack[++top] = x;\r\n\r\n    }\r\n\r\n    public int pop() {//弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。\r\n        if (top == -1) return -1;\r\n        return stack[top--];\r\n    }\r\n\r\n    public void increment(int k, int val) {//栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。\r\n        int num  = Math.min(k - 1, top);\r\n        if (num >= 0){\r\n        for (int i = 0; i <= num; i++) {\r\n            stack[i] += val;\r\n        }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 push\\pop->O(1) ; incr->O(k)\r\n空间复杂度 O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994245482","body":"#### 思路\r\n使用两个栈维护中间结果和重复量\r\n\r\n#### 代码\r\n\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        if (s == null || s.length() == 0) return s;\r\n        String res = \"\";\r\n        Stack<Integer> countStack = new Stack<>();\r\n        Stack<String> resStack = new Stack<>();\r\n        int index = 0;\r\n        while (index < s.length()){\r\n            if (Character.isDigit(s.charAt(index))){\r\n                int count = 0;\r\n                while(Character.isDigit(s.charAt(index))){\r\n                count = count * 10 + (s.charAt(index) - '0');//char 转成 int 是基础操作\r\n                index++;\r\n                }\r\n                countStack.push(count);\r\n            }else if (s.charAt(index) == '['){\r\n                resStack.push(res);\r\n                res = \"\";\r\n                index++;\r\n            }else if (s.charAt(index) == ']'){\r\n                StringBuffer tmp = new StringBuffer(resStack.pop());\r\n                int times = countStack.pop();\r\n                for (int i = 0; i < times; i++) {\r\n                tmp.append(res);\r\n                }\r\n                res = tmp.toString();\r\n                index++;\r\n            }else {\r\n                res += s.charAt(index);\r\n                index++;\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n#### 复杂度分析\r\n时间复杂度 O(n)\r\n空间复杂度O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995378243","body":"#### 思路\r\n两个栈，一个负责输入，一个负责输出，注意pop和peek的情况分析，2无1有的时候，需要把1里的元素全部压入2。\r\n\r\n#### 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (!s2.isEmpty()) return s2.pop();\r\n        else {\r\n            while (!s1.isEmpty()) s2.push(s1.pop());\r\n            return s2.pop();\r\n        }\r\n    }\r\n    \r\n    public int peek() {\r\n        if (!s2.isEmpty()) return s2.peek();\r\n        else {\r\n            while (!s1.isEmpty()) s2.push(s1.pop());\r\n            return s2.peek();\r\n        }\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"guoling0019":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991918971","body":"## 思路\n从右向左开始，数组的最后一位与k的最后一位相加，如果和小于10，放入新数组，如果大于10，取余，向左进一位\n\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number[]} num\n * @param {number} k\n * @return {number[]}\n */\nvar addToArrayForm = function(num, k) {\n    let sumArr = []\n\n        for(let i=num.length-1;i>=0;--i){\n            let sum = num[i]+k%10\n            k=Math.floor(k/10)\n            if(sum>=10){\n                k++\n                sum-=10\n            }\n            sumArr.push(sum)\n        }\n        for(;k>0;k=Math.floor(k/10)){\n            sumArr.push(k%10)\n        }\n        \n        return sumArr.reverse()\n};\n\n```\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992172020","body":"## 思路\r\n\r\n-  从当前元素开始分别向左右两边查询与目标元素是否相同，计算距离，取最小值\r\n\r\n## 代码\r\n\r\n- 语言支持：JavaScript\r\n\r\nJavaScript Code:\r\n\r\n```javascript\r\n\r\n/**\r\n * @param {string} s\r\n * @param {character} c\r\n * @return {number[]}\r\n */\r\nvar shortestToChar = function(s, c) {\r\n    let arr = []\r\n        for(let i=0,len=s.length;i<len;i++){\r\n            if(s[i]==c){\r\n                arr[i]=0\r\n            }\r\n            let prev=i,next=i,shorttest=Infinity;\r\n            while(prev>=0){\r\n                if(s[prev]==c){\r\n                    shorttest = Math.min(shorttest,i-prev);\r\n                    break;\r\n                }\r\n                prev--\r\n            }\r\n            while(next<s.length){\r\n                if(s[next]==c){\r\n                    shorttest=Math.min(shorttest,next-i);\r\n                    break\r\n                }\r\n                next++\r\n            }\r\n            arr[i]=shorttest;\r\n        }\r\n        return arr\r\n};\r\n\r\n```\r\n\r\n\r\n**复杂度分析**\r\n\r\n令 n 为数组长度。\r\n\r\n- 时间复杂度：O(n^2)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993224262","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.max=maxSize;\n    this.stk=[]\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stk.length<this.max){\n        this.stk.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let res = this.stk.pop()\n    return res==null?-1:res\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for(let i=0;i<this.stk.length;i++){\n        if(i<k){\n            this.stk[i]+=val\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：push和pop为O(1)、increment为O(n)\n- 空间复杂度：O(1)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994449594","body":"## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let stack = []\n           for(let i=0;i<s.length;i++){\n               let repeatStr=''\n               let repeatCount=''\n               if(s[i]==']'){\n                    while(stack.length&&stack[stack.length-1]!='['){\n                        repeatStr = stack.pop()+repeatStr\n                    }\n                    stack.pop()\n                    while(stack.length&&!isNaN(stack[stack.length-1])){\n                        repeatCount=stack.pop()+repeatCount\n                    }\n                    stack.push(repeatStr.repeat(Number(repeatCount)))\n               }else{\n                   stack.push(s[i])\n               }\n           }\n           return stack.join('')\n};\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995491130","body":"```javascript\n\nvar MyQueue = function() {\n        this.stack=[]\n        this.stack01=[]\n    };\n\n    /** \n        * @param {number} x\n        * @return {void}\n        */\n    MyQueue.prototype.push = function(x) {\n        let cur = null\n        while((cur=this.stack.pop())){\n            this.stack01.push(cur)\n        }\n        this.stack01.push(x)\n        while((cur=this.stack01.pop())){\n            this.stack.push(cur)\n        }\n    };\n\n    /**\n        * @return {number}\n        */\n    MyQueue.prototype.pop = function() {\n        return this.stack.pop()\n    };\n\n    /**\n        * @return {number}\n        */\n    MyQueue.prototype.peek = function() {\n        return this.stack[this.stack.length-1]\n    };\n\n    /**\n        * @return {boolean}\n        */\n    MyQueue.prototype.empty = function() {\n        return this.stack.length == 0\n    };\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * var obj = new MyQueue()\n * obj.push(x)\n * var param_2 = obj.pop()\n * var param_3 = obj.peek()\n * var param_4 = obj.empty()\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(n)$\n- 空间复杂度：$O(n)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"extra-man":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991920337","body":"### 思路\r\n自己想的贼复杂，还不对，最后看的力扣的答案\r\n### 代码\r\n//自己写不出来，抄的答案，\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] num, int k) {\r\n        List<Integer> res = new ArrayList<Integer>();\r\n        int n = num.length;\r\n        for (int i = n - 1; i >= 0; --i) {\r\n            int sum = num[i] + k % 10;\r\n            k /= 10;\r\n            if (sum >= 10) {\r\n                k++;\r\n                sum -= 10;\r\n            }\r\n            res.add(sum);\r\n        }\r\n        for (; k > 0; k /= 10) {\r\n            res.add(k % 10);\r\n        }\r\n        Collections.reverse(res);\r\n        return res;\r\n    }\r\n}\r\n### 复杂度分析\r\n时间复杂度：O(\\max(n,\\log k))O(max(n,logk))，其中 nn 为数组的长度。\r\n\r\n空间复杂度：O(1)O(1)\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993535221","body":"### 思路\r\n\r\n自己也不知道有没有思路，哎。\r\n看官方题解，正常（算是暴力解法）能看懂，可是自己写不出来。优化的前缀和没看懂，，，好难，\r\n\r\n### 代码\r\n```\r\n\r\nclass CustomStack {\r\n    Stack<Integer> stack;\r\n    int[] incrementals;\r\n    int maxSize = -1;\r\n\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        stack = new Stack<>();\r\n        incrementals = new int[maxSize];\r\n    }\r\n\r\n    public void push(int x) {\r\n        if (stack.size() < maxSize) {\r\n            stack.push(x);\r\n        }\r\n    }\r\n\r\n    public int pop() {\r\n        int i = stack.size() - 1;\r\n        if (i < 0) return -1;\r\n        if (i > 0) {\r\n            incrementals[i - 1] += incrementals[i];\r\n        }\r\n        int res = stack.pop() + incrementals[i];\r\n        incrementals[i] = 0;\r\n        return res;\r\n    }\r\n\r\n    public void increment(int k, int val) {\r\n        int i = Math.min(k, stack.size()) - 1;\r\n        if (i >= 0) {\r\n            incrementals[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n**复杂度分析**\r\n- 时间复杂度：O(1)\r\n- 空间复杂度： O(maxSize / N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994791174","body":"### 思路\n\n答案看懂了，但是不会写\n\n### 代码\n\n\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995818631","body":"### 思路\n\n我想的入队直接入栈就行，出的话再用另一个栈倒一遍，应该可以，\n不过代码还是写不出来，参考的力扣\n\n### 代码\n\n\n```\nprivate Stack<Integer> s1 = new Stack<>();\nprivate Stack<Integer> s2 = new Stack<>();\n\npublic void push(int x) {\nif (s1.empty()) front = x;\ns1.push(x);\n}\n\npublic void pop() {\nif (s2.isEmpty()) {\nwhile (!s1.isEmpty())\ns2.push(s1.pop());\n}\ns2.pop();\n}\n\npublic boolean empty() {\nreturn s1.isEmpty() && s2.isEmpty();}\n\n\npublic int peek(){\nif (!s2.isEmpty()) {\nreturn s2.peek();}\nreturn front;}\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(1)\n- 空间复杂度：O(1)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"a1exlism":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991921856","body":"### 思路\r\n\r\n注意范围, 还有两处边界\r\n\r\n### 代码\r\n\r\n```python\r\nclass Solution:\r\n    def addToArrayForm(self, A: List[int], K: int) -> List[int]:\r\n        for i in range(len(A)-1, -1, -1):\r\n            K += A[i]\r\n            A[i] = K % 10\r\n            K //= 10\r\n        while(K > 0):\r\n            A.insert(0, K % 10)\r\n            K //= 10\r\n        return A\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(N)，其中 N 为数组长度。\r\n- 空间复杂度：O(N) (包括数组A大小)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992617976","body":"### 思路\n\n- 记忆化解决多个 c 问题, 保存之前的状态;\n- prev 遍历两个方向保证 minimum\n\n### 代码\n\n```python\ndef shortestToCharOfficial(S: str, C: str) -> List[int]:\n        prev = float('-inf')\n        ans = []\n        # L -> R\n        for i, v in enumerate(S):\n            if v == C:\n                prev = i\n            ans.append(i-prev)\n        # print(ans)\n        # R -> L TIPS: INF\n        prev = float('inf')\n        for i in range(len(S)-1, -1, -1):\n            if S[i] == C:\n                prev = i\n            ans[i] = min(ans[i], prev-i)\n        return ans\n```\n\n**复杂度分析**\n\n- 时间复杂度: O(|S|), |S| 为 str 长度\n- 空间复杂度: O(|S|)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yetfan":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922535","body":"\n**思路**\n\n数字小的直接用加法\n\n数字大的，要考虑和k的加法和进位，超过k就只考虑进位\n\n**代码**\n\n```python\nclass Solution:\n    def addToArrayForm(self, num: List[int], k: int) -> List[int]:\n\n        if len(num) <= len(str(k)):\n            return [int(j) for j in list(str(int(\"\".join([str(i) for i in num])) + k))]\n\n\n        k = [int(i) for i in list(str(k))]\n        c = 0\n        for j in range(len(num)-1,len(num)-len(k)-1,-1):\n            n = num[j] + k[j-len(num)+len(k)] + c\n            num[j] = n % 10\n            c = n // 10\n\n        for j in range(len(num)-len(k)-1,-1,-1):\n            print(j)\n            print(num[j],c)\n\n            if c == 0:\n                return num\n            else:\n                n = num[j] + c\n                num[j] = n % 10\n                c = n // 10\n\n        if c == 1:\n            return [1] + num\n        else:\n            return num\n```\n\n**复杂度分析**\n\n时间 O(n) 加过k之后，如果没有进位会提前结束\n\n空间 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992616644","body":"**思路**\r\n\r\n标记最近的位置进行遍历\r\n\r\n**代码**\r\n\r\n\r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, S, C):\r\n        prev = float('-inf')\r\n        ans = []\r\n        for i, x in enumerate(S):\r\n            if x == C: prev = i\r\n            ans.append(i - prev)\r\n\r\n        prev = float('inf')\r\n        for i in xrange(len(S) - 1, -1, -1):\r\n            if S[i] == C: prev = i\r\n            ans[i] = min(ans[i], prev - i)\r\n\r\n        return ans\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(N)\r\n空间 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993685282","body":"\r\n**代码**\r\n\r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stk = [0] * maxSize\r\n        self.top = -1\r\n\r\n    def push(self, x: int) -> None:\r\n        if self.top != len(self.stk) - 1:\r\n            self.top += 1\r\n            self.stk[self.top] = x\r\n\r\n    def pop(self) -> int:\r\n        if self.top == -1:\r\n            return -1\r\n        self.top -= 1\r\n        return self.stk[self.top + 1]\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        lim = min(k, self.top + 1)\r\n        for i in range(lim):\r\n            self.stk[i] += val\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(1)\r\n空间 O(maxsize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920172","body":"**思路**\r\n\r\n用栈来暂存\r\n\r\n读取数字 如果大于10 则按位乘10倍 来计算数字总值\r\n\r\n读取左右括号 从而找到需要重复的n次的 “内容”\r\n\r\n**代码**\r\n\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack, res, multi = [], \"\", 0\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append([multi, res])\r\n                res, multi = \"\", 0\r\n            elif c == ']':\r\n                cur_multi, last_res = stack.pop()\r\n                res = last_res + cur_multi * res\r\n            elif '0' <= c <= '9':\r\n                multi = multi * 10 + int(c)            \r\n            else:\r\n                res += c\r\n        return res\r\n```\r\n\r\n**复杂度**\r\n\r\n时间 O(N)\r\n\r\n空间 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jackzcai":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922549","body":"//1，不可将A数组遍历得到sumA，与K做加法得到和，原因：A数组的长度可能很长，整数越界；\r\n//2，将K与A倒序的每个元素相加得到和，将和取模得到每个元素，插入到新数组中。\r\nclass Solution {\r\n    public List<Integer> addToArrayForm(int[] A, int K) {\r\n        int len = A.length;\r\n        int lastNum =K;\r\n        LinkedList<Integer> ret= new LinkedList<>();\r\n        int i = len-1;\r\n        while(i >=0 || lastNum > 0){\r\n            int tmp = lastNum % 10 + (i >= 0 ? A[i] : 0);\r\n            ret.addFirst(tmp%10);\r\n            lastNum = lastNum / 10 + tmp / 10;\r\n            i--;\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"helloxkw":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991922639","body":"思路：\n从k的个位和数组的最后元素入手，k先模10拿到个位，与数组最后一位相加后结果放入res数组，\n接着k/=10处理除去个位，继续拿十位数，与数组倒数第二个元素相加，如果有进位则返到k值\nk还小于0不需要进位且A数组没有值的情况，则环循环结束。\nclass Solution {\n    public List<Integer> addToArrayForm(int[] num, int k) {\n        //用LinkedList不断从头将位数和加入index 0\n        List<Integer> res = new LinkedList<>();\n        int n = num.length;\n        for (int i = n - 1; i >= 0; i--) {\n            //从末尾往前扫，加和取余的值\n            res.add(0, (num[i] + k) % 10);\n            //更新k存进位carry\n            k = (num[i] + k) / 10;\n        }\n\n        // post-possing: 处理k位数大于num的情况剩下的部分\n        // Time = O(log(k))\n        while (k > 0) {\n            res.add(0, k % 10);\n            k /= 10;\n        }\n\n        return res;\n    }\n}\n\n复杂度分析\n时间复杂度 O(max(m,n))，m是数组num的长度，n是k数位的个数\n空间复杂度 O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992615919","body":"class Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        int len = s.length();\n        vector<int> record;\n        vector<int> ans(len);\n        for (int i = 0; i < len; i++) {\n            if (s[i] == c) record.push_back(i);\n        }\n        \n        for (int i = 0; i < len; i++) {\n            int temp = INT_MAX;\n            for (int k = 0; k < record.size(); k++) {\n                temp = min(temp, abs(i - record[k]));\n            }\n            ans[i] = temp;\n        }\n        return ans;\n    }\n};","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993627993","body":"class CustomStack {\n\n    int[] s;\n    int top = -1;\n\n    public CustomStack(int maxSize) {\n        s = new int[maxSize];\n    }\n\n    public void push(int x) {\n        if (top < s.length-1){\n            s[++top] = x;\n        }\n    }\n\n    public int pop() {\n        if (top > -1){\n            return s[top--];\n        }\n        return -1;\n    }\n\n    public void increment(int k, int val) {\n        int t = k-1;\n        if (top < k-1){\n            t = top;\n        }\n        for (int i = 0; i <= t; i++) {\n            s[i] += val;\n        }\n    }\n}\n复杂度分析\n\n时间复杂度:\npush/pop O(1)\nincrement O(N)\n空间复杂度: O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"mongoczk":[{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/1#issuecomment-991924489","body":"思路：\r\n逐位相加：逐位将数字加在一起，若加法结果大于等于10，则需要进位\r\n代码：**JavaScript**\r\n```javascript \r\n var addToArrayForm = function(num, k) {\r\n  const arr = []\r\n  const len = num.length\r\n  for( let i = len-1; i >= 0; i-- ){\r\n    let sum = num[i] + k % 10;\r\n    k = Math.floor(k / 10);\r\n    if( sum >= 10){\r\n      k++;\r\n      sum -= 10 \r\n    }\r\n    arr.push(sum)\r\n  }\r\n  for(; k > 0; k = Math.floor( k / 10)){\r\n    arr.push(k % 10)\r\n  }\r\n  return arr.reverse();\r\n};\r\n```\r\n\r\n复杂度分析\r\n时间复杂度：O(N)，其中 N为数组的长度。\r\n空间复杂度：O(1), 除了返回值以外，使用了一个常数记录数组的长度。","onTime":false},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992616476","body":"### 思路\r\n+ 使用两次遍历，找到每个字符分别离左边和右边最近的的字符c的距离，取最小值\r\n+ 初始化记录距离的数组，每个元素值为数组长度-1，即最大距离\r\n+ 从左向右遍历： 存储数组元素到左边最近的字符c的距离，遇到字符c时更新下标\r\n+ 从右向左遍历： 比该数组元素到右边最近的字符c的距离与记录的距离，取最小值，遇到字符c时更新下标\r\n\r\n### 代码 —   **JavaScript**\r\n```javascript\r\n var shortestToChar = function(s, c) {\r\n  s = s.split('')\r\n  let len = s.length\r\n  let prev = len-1\r\n  let distance = new Array(len).fill(prev)\r\n  for(let i=0; i< len; i++){\r\n    if(s[i] == c){\r\n      distance[i] = 0\r\n      prev = i\r\n    }else{\r\n      distance[i] =  Math.abs(i-prev)\r\n    }\r\n  }\r\n  for(let i=len-1; i>=0; i--){\r\n    if(s[i] == c){\r\n      distance[i] = 0\r\n      prev = i\r\n    }else{\r\n      distance[i] = Math.min(Math.abs(i-prev),distance[i])\r\n    }\r\n  }\r\n  return distance\r\n};\r\n\r\n```\r\n\r\n**复杂度分析**\r\n+ 时间复杂度：O(n)：两次循环，n为字符串长度\r\n+ 空间复杂度：O(n): 除返回值外，使用了一个数组，长度为字符串长度，空间为 O(n)\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993534554","body":"### 思路 模拟优化\r\n\r\n- 使用数组来模拟栈\r\n- pop、push操作可以使用数组的pop、push来完成\r\n- increment操作可以用一个数组incs来维护每次increment操作时增量，pop 的时候，将弹出栈的元素的值加上incs数组中对应下标的增量即可得到 increment操作后的值\r\n- 需要注意的是，incs上的某个增量如incs[ i ]使用之后，需将增量值累加到前一个增量上，同时将这个增量incs[ i ]置为0\r\n\r\n### 代码\r\n\r\n```javascript\r\n/**\r\n * @param {number} maxSize\r\n */\r\n var CustomStack = function (maxSize) {\r\n  this.arr = [];\r\n  this.incs = new Array(maxSize).fill(0);\r\n  this.maxSize = maxSize;\r\n};\r\n\r\n/**\r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function (x) {\r\n  if (this.arr.length < this.maxSize) {\r\n    this.arr.push(x);\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function () {\r\n  if (this.arr.length > 0) {\r\n    let top = this.arr.length - 1;\r\n    if(top > 0) this.incs[top - 1] += this.incs[top];\r\n    let result = this.arr.pop() + this.incs[top];\r\n    this.incs[top] = 0;\r\n    return result\r\n  }\r\n  return -1\r\n};\r\n\r\n/**\r\n * @param {number} k\r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function (k, val) {\r\n  let m = Math.min(k, this.arr.length);\r\n  if( m > 0){\r\n    this.incs[m-1] += val;\r\n  }\r\n};\r\n```\r\n\r\n**复杂度分析**\r\n\r\n- 时间复杂度：O(1)：push、pop、increment 的时间复杂度均为 O(1)\r\n- 空间复杂度：O(n): 除返回值外，使用incs数组存放增量，数组长度n为maxSize大小","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994916277","body":"### 思路\r\n 使用辅助栈，遍历字符串，对每个字符，有：\r\n  + 如果是字母 --> 添加到 stack 当中\r\n  + 如果是数字 --> 先不着急添加到 stack 中 --> 因为有可能有多位\r\n  + 如果是 [ --> 说明重复字符串开始 --> 将数字入栈 --> 并且将数字清零\r\n  + 如果是 ] --> 说明重复字符串结束 --> 将重复字符串重复前一步储存的数字遍\r\n### 代码\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        stack = []\r\n        for c in s:\r\n            if c == ']':\r\n                repeatStr = ''\r\n                repeatCount = ''\r\n                while stack and stack[-1] != '[':\r\n                    repeatStr = stack.pop() + repeatStr\r\n                # pop 掉 \"[\"\r\n                stack.pop()\r\n                while stack and stack[-1].isnumeric():\r\n                    repeatCount = stack.pop() + repeatCount\r\n                stack.append(repeatStr * int(repeatCount))\r\n            else:\r\n                stack.append(c)\r\n        return \"\".join(stack)\r\n```\r\n**复杂度分析**\r\n+ 时间复杂度：O(N)，其中 N 为解码后的 s 的长度。\r\n+ 空间复杂度：O(N)，其中 N 为解码后的 s 的长度。\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995136403","body":"### 思路\r\n+ 构建两个栈stack和reverseStack，reverseStack的栈顶始终是最先入栈的元素，即队头\r\n+ push操作：若reverseStack为空，则入栈reverseStack，否则，入栈stack\r\n+ pop操作：reverseStack弹出栈顶元素，当reverseStack为空时，将stack中的元素依次弹出并入栈reverseStack\r\n+ peek操作：取reverseStack的栈顶元素值\r\n+ empty操作： 判断两个栈是否均为空\r\n\r\n### 代码\r\n```javascript\r\nvar MyQueue = function() {\r\n  this.stack = []\r\n  this.reverseStack = []\r\n};\r\n\r\n/** \r\n* @param {number} x\r\n* @return {void}\r\n*/\r\nMyQueue.prototype.push = function(x) {\r\n  if(this.reverseStack.length > 0){\r\n      this.stack.push(x)\r\n  }else{\r\n      this.reverseStack.push(x)\r\n  }\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.pop = function() {\r\n  let item = this.reverseStack.pop()\r\n  if(this.reverseStack.length == 0){\r\n      while(this.stack.length > 0){\r\n          this.reverseStack.push(this.stack.pop())\r\n      }\r\n  }\r\n  return item\r\n};\r\n\r\n/**\r\n* @return {number}\r\n*/\r\nMyQueue.prototype.peek = function() {\r\n return this.reverseStack[this.reverseStack.length-1]\r\n};\r\n\r\n/**\r\n* @return {boolean}\r\n*/\r\nMyQueue.prototype.empty = function() {\r\n  return this.reverseStack.length == 0 && this.stack.length ==0\r\n};\r\n```\r\n**复杂度分析**\r\n+ 时间复杂度：摊还复杂度 O(1)，最坏情况下的时间复杂度 O(n)\r\n+ 空间复杂度： push和pop操作时需要额外的空间来储存元素，空间复杂度为O(n),其他操作为O（1）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"shao-nuoya":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991959157","body":"# 思路\r\n正向及反向遍历\r\n注意初始时第一个c的位置的设定\r\n# 代码\r\n\r\n```python\r\nclass Solution:\r\n    def shortestToChar(self, s: str, c: str) -> List[int]:\r\n        n =  len(s)\r\n        left = float('-inf')\r\n        ans = [0 for _ in range(n)]\r\n        for i in range(n):\r\n            if s[i] == c:\r\n                left = i\r\n                ans[i] = 0\r\n            else:\r\n                ans[i] = i - left\r\n\r\n        right = float('inf')\r\n        for i in range(n-1, -1, -1):\r\n            if s[i] == c:\r\n                right = i\r\n            else:\r\n                ans[i] = min(right -i, ans[i])\r\n\r\n        return ans\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992981152","body":"# 类的用法\n# Code\n```python\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.stack = []\n\n    def push(self, x: int) -> None:\n        if len(self.stack)<self.maxSize:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if self.stack:\n            ans = self.stack[-1]\n            del self.stack[-1]\n            return ans\n        return -1\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, len(self.stack))):\n            self.stack[i] += val\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994127995","body":"# 栈的使用\n# code\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        multi = 0\n        res = ''\n        stack = []\n\n        for ss in s:\n            if ss == '[':\n                stack.append([multi, res])\n                res, multi = '', 0\n            elif ss == ']':\n                cur_multi, last_res = stack.pop()\n                res = last_res + cur_multi * res\n            elif '0'<=ss<='9':\n                multi = 10*multi + int(ss)\n            else:\n                res += ss\n\n        return res\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995267092","body":"# 队列\n# Code\n```python\nclass MyQueue:\n\n    def __init__(self):\n        self.queue = []\n\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop(0)\n\n    def peek(self) -> int:\n        return self.queue[0]\n\n    def empty(self) -> bool:\n        if len(self.queue)>0:\n            return False\n        else:\n            return True\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yangziqi1998666":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991978597","body":"- 时间复杂度：O(n*m)\n- 空间复杂度：O(n)   \n /**\n     * 暴力解法\n     * 既然我们需要找到最短距离，那么首先应该获取到该字符在字符串 s 中的所有下标位置。\n     * 使用O(n)的时间遍历一次字符串，并将等于目标字符的下标添加至动态数组location。\n     * 创建 res 数组，长度为s.length()\n     * 再次遍历s的过程中，再遍历location集合\n     * 寻找距离i最近的距离，并存入res中\n     *\n     * @param s\n     * @param c\n     * @return\n     */\n    public int[] shortestToChar(String s, char c) {\n        ArrayList<Integer> location = new ArrayList<Integer>();\n        for (int i=0; i < s.length(); i++){\n            if (s.charAt(i) == c)\n                location.add(i);\n        }\n\n        int[] res = new int[s.length()];\n        int min,dis;\n\n        for ( int i=0; i< s.length(); i++){\n            min = Integer.MAX_VALUE/2;\n            for (int j=0; j < location.size(); j++){\n                dis = Math.abs(location.get(j)-i);\n                if (dis<min){\n                    min = dis;\n                    res[i] = min;\n                }\n            }\n        }\n        return res;\n    }","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992811814","body":"```java\nclass CustomStack {\n    private int maxSize;\n    private int[] stack;\n    private int pointer;\n\n\n    public CustomStack(int maxSize) {\n        this.maxSize = maxSize;\n        this.pointer = -1;\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n        if (pointer != maxSize-1){\n            pointer++;\n            stack[pointer] = x;\n        }\n\n    }\n    \n    public int pop() {\n        if (pointer == -1)\n            return -1;\n        pointer--;\n        return stack[pointer+1];\n\n    }\n    \n    public void increment(int k, int val) {\n        for(int i = 0; i <= pointer && i < k; i++){\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994033719","body":"```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Character> stack = new Stack<>();\n\n        for(char c: s.toCharArray()){\n            if(c!=']')\n                stack.push(c); // 除了], 全部压入栈\n\n            else{\n                // step1. 取出[]内的字符串\n                StringBuilder sb =new StringBuilder();\n                while(!stack.isEmpty() && Character.isLetter(stack.peek()))\n                    sb.insert(0,stack.pop());\n\n                String sub = sb.toString(); // []内的字符串\n                stack.pop(); //去除 [\n\n                // step2. 获取倍数数字\n                sb = new StringBuilder();\n                while(!stack.isEmpty() && Character.isDigit(stack.peek()))\n                    sb.insert(0,stack.pop());\n\n                int count = Integer.valueOf(sb.toString());\n\n                // step3. 根据倍数把字母push回去\n                while(count>0){\n                    for(char ch: sub.toCharArray())\n                        stack.push(ch);\n                        count--;\n                }\n            }\n        }\n\n        //把栈里面所有的字母取出来\n        StringBuilder retv = new StringBuilder();\n        while(!stack.isEmpty())\n            retv.insert(0, stack.pop());\n\n        return retv.toString();\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995191908","body":"```java\r\nclass MyQueue {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> temp;\r\n\r\n    public MyQueue() {\r\n        this.stack = new Stack();\r\n        temp = new Stack();\r\n    }\r\n    \r\n    /*\r\n    时间复杂度: O(n)\r\n    空间复杂度: O(n)\r\n     */\r\n    public void push(int x) {\r\n        while(!stack.isEmpty())\r\n            temp.push(stack.pop());\r\n        temp.push(x);\r\n        while(!temp.isEmpty())\r\n            stack.push(temp.pop());\r\n    }\r\n\r\n    /* \r\n    Removes the element from the front of queue.\r\n    时间复杂度: O(1)\r\n    空间复杂度: O(1)\r\n    */\r\n    public int pop() {\r\n        return stack.pop();\r\n    }\r\n    \r\n    /* \r\n    Get the front element.\r\n    时间复杂度: O(1)\r\n    空间复杂度: O(1)\r\n    */\r\n    public int peek() {\r\n        return stack.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return stack.isEmpty();\r\n    }\r\n}\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"blessinglr":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991978913","body":"class Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        pos = [-float('inf')]\n        for idx, char in enumerate(s):\n            if char == c:\n                pos.append(idx)\n        pos.append(float('inf'))\n        i = 1\n        res = []\n        for idx, char in enumerate(s):\n            if idx == pos[i]:\n                i += 1\n                res.append(0)\n                continue\n            res.append(min(pos[i]-idx, idx-pos[i-1]))\n        return res","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992696272","body":"```python\r\nclass CustomStack:\r\n    def __init__(self, maxSize: int):\r\n        self.maxSize = maxSize\r\n        self.lst = []\r\n        self.idx = 0\r\n        \r\n    def push(self, x: int) -> None:\r\n        if self.idx < self.maxSize:\r\n            self.idx += 1\r\n            self.lst.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if self.idx == 0:\r\n            return -1\r\n        self.idx -= 1\r\n        return self.lst.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        for i in range(min(k, len(self.lst))):\r\n            self.lst[i] += val\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994837592","body":"```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        res = ''\r\n        stack = []\r\n        for char in s:\r\n            if char == ']':\r\n                strings = ''\r\n                while stack:\r\n                    temp = stack.pop()\r\n                    if temp != '[':\r\n                        strings = temp + strings\r\n                    else:\r\n                        break\r\n                num = ''\r\n                while stack and stack[-1].isdigit():\r\n                    num = stack.pop() + num\r\n                stack.append(int(num) * strings)\r\n            else:\r\n                stack.append(char)\r\n        for item in stack:\r\n            res += item\r\n        return res\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"frederickfan":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991984254","body":"# Idea: \r\nWe can set a left pointer pointing to the left occurrence of the character c and set a right pointer pointing to the right occurrence of the character c. Then we iterate the array, for each element we encountered, we check the distance between itself and the left pointer and also check the distance between itself and the right pointer. The minimum one of those two distances will be the result for the current character. \r\n\r\n# Code: \r\n```python\r\nclass Solution(object):\r\n    def shortestToChar(self, s, c):\r\n        \"\"\"\r\n        :type s: str\r\n        :type c: str\r\n        :rtype: List[int]\r\n        \"\"\"\r\n        n = len(s)\r\n        l = 0 if s[0] == c else n\r\n        r = s.find(c, 0)\r\n        res = [0 for _ in range(n)]\r\n        \r\n        for i in range(n):\r\n            res[i] = min(abs(i - l), abs(r - i))\r\n            \r\n            if i == r:\r\n                l = r \r\n                r = s.find(c, l + 1)\r\n                \r\n        \r\n        return res\r\n\r\n```\r\n# Complexity\r\n* Time: O(N)\r\n* Space: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992935560","body":"# Idea: \r\nUse the python list to simulate stack. The only feature we need to add is to increase last k elements by val. \r\n\r\n# Code: \r\n```python\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.array = []\r\n        self.n = maxSize \r\n        \r\n\r\n    def push(self, x: int) -> None:\r\n        if len(self.array) < self.n: \r\n            self.array.append(x)\r\n        \r\n        \r\n\r\n    def pop(self) -> int:\r\n        if not self.array:\r\n            return -1\r\n        return self.array.pop()\r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        length = min(k, len(self.array))\r\n        \r\n        for i in range(length):\r\n            self.array[i] += val\r\n        \r\n```\r\n# Complexity\r\nTime:  Push: O(1) Pop: O(1) Increment: O(min(k, n))\r\nSpace: O(n)\r\n\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994269395","body":"# Idea:\r\n括号匹配。\r\n# Code\r\n```python\r\nimport java.util.Stack;\r\n\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        char[] codepoint = s.toCharArray();\r\n        int number = 0;\r\n        Stack<Object> stack = new Stack<>();\r\n        for (int i = 0; i < codepoint.length; i++) {\r\n            char code = codepoint[i];\r\n            if (Character.isDigit(code)) {\r\n                number = 10 * number + (code - '0');\r\n            } else if (code == '[') {\r\n                stack.push(number);\r\n                number = 0;\r\n            } else if (code == ']') {\r\n                String reversedString = stackReverse(stack);\r\n                int times = (int) stack.pop();\r\n                String repeatReversed = reversedString.repeat(times);\r\n                stack.push(repeatReversed);\r\n            } else {\r\n                stack.push(String.valueOf(code));\r\n            }\r\n        }\r\n        return stackReverse(stack);\r\n    }\r\n    \r\n    public String stackReverse(Stack<Object> stack) {\r\n        Stack<Object> reversedStack = new Stack<>();\r\n        while (!stack.isEmpty() && (stack.peek() instanceof String)) {\r\n            reversedStack.push(stack.pop());\r\n        }\r\n        StringBuilder res = new StringBuilder();\r\n        while (!reversedStack.isEmpty()) {\r\n            res.append(reversedStack.pop());\r\n        }\r\n        return res.toString();\r\n    }\r\n}\r\n```\r\n# Complexity\r\nTime: O(n)\r\nSpace: O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995866804","body":"# Idea:\r\nWe create two stacks. First stack called \"pushStack\" is only used for \"push\" operation of the queue and the second stack called \"popStack\" is used for \"pop\"/\"peek\" operation of the queue. Whenever we need to pop or peek an element from the queue, we pop an element from the \"popStack\" stack if not empty. Otherwise, we push all the elements from \"pushStack\" onto \"popStack\". \r\n\r\n# Code\r\n```python\r\nclass MyQueue(object):\r\n\r\n    \"\"\"\r\n    Queue is fifo stack is lifo\r\n    \r\n    [1, 2, 3]\r\n    [3, 2, 1]\r\n    \r\n    [4] -> push\r\n    [3,2,1] -> peak and pop\r\n    if not queue:\r\n        push elem from first stack to sec\r\n    else:\r\n        pop or peek from the other    \r\n    \"\"\"\r\n    \r\n    def __init__(self):\r\n        self.pushStack = []\r\n        self.popStack = []\r\n\r\n    def push(self, x):\r\n        \"\"\"\r\n        :type x: int\r\n        :rtype: None\r\n        \"\"\"\r\n        self.pushStack.append(x)\r\n        \r\n\r\n    def pop(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        if self.popStack:\r\n            return self.popStack.pop()\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        return self.popStack.pop()\r\n            \r\n            \r\n\r\n    def peek(self):\r\n        \"\"\"\r\n        :rtype: int\r\n        \"\"\"\r\n        print(self.pushStack)\r\n        if self.popStack:\r\n            return self.popStack[-1]\r\n        while self.pushStack:\r\n            self.popStack.append(self.pushStack.pop())\r\n        print(self.popStack)\r\n        return self.popStack[-1]\r\n        \r\n\r\n    def empty(self):\r\n        \"\"\"\r\n        :rtype: bool\r\n        \"\"\"\r\n        return len(self.pushStack) == 0 and len(self.popStack) == 0\r\n```\r\n# Complexity\r\nTime: push: O(1) pop: amortized O(1) since the only case that takes O(n) time is when the \"popStack\" is empty, which won't happen quite often. \r\nSpace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"moirobinzhang":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-991989214","body":"思路：\n从前往后 以及 从后往前两次遍历\n第一次遍历result[i]记录i位置字符与前一个c的距离\n第二次遍历result[i]比较Min(result[i], i位置字符和后一个c的距离）\n\n代码：\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        result = []\n        \n        flag_index = len(s) - 1        \n        for i in range(len(s)):\n            if (s[i] == c):\n                flag_index = i\n            result.append(abs(flag_index - i))\n                       \n        flag_index = 0\n        for i in range(len(s) -1, -1, -1):\n            if (s[i] == c):\n                flag_index = i\n            result[i] = min(result[i], abs(flag_index - i ))\n        \n        return result\n\n复杂度分析:\n时间复杂度O（N）\n空间复杂度O（N）","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-992923831","body":"Idea:\nUse List to simulate Stack\n\nCode:\n\npublic class CustomStack {\n\n    public List<int> cList {get; set;}\n    public int maxCount {get; set;}\n    \n    public CustomStack(int maxSize) {\n        cList = new List<int>();\n        maxCount = maxSize;        \n    }\n    \n    public void Push(int x) {\n        if (cList.Count >= maxCount)\n            return;\n        \n        cList.Add(x);\n    }\n    \n    public int Pop() {\n        if (cList == null || cList.Count == 0)\n            return -1;\n        \n        int popValue = cList[cList.Count - 1];\n        cList.RemoveAt(cList.Count - 1);\n        return popValue;\n    }\n    \n    public void Increment(int k, int val) {\n        if (cList == null || cList.Count == 0)\n            return;\n        \n        int len = cList.Count >= k ? k : cList.Count;\n        \n        for (int i = 0; i < len ; i++)\n            cList[i] += val;\n    }\n}\n\n\nComplexity\nT: Push: O(1), Pop: O(1), Increment: O(N)\nS: O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994737531","body":"思路: \n用两个栈分别存放数字和字符串\n\n分析：\n    def decodeString(self, s: str) -> str:\n        numStack = []\n        strStack = []\n        num = 0;\n        result = ''\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '[':\n                strStack.append(result)\n                result = ''\n                numStack.append(num)\n                num = 0\n            elif c == ']':\n                times = numStack.pop()\n                result = strStack.pop() + result * times\n            else:\n                result += c  \n        \n        return result\n\n复杂度\n时间复杂度：O(n)\n空间复杂度：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995347777","body":"class MyQueue:\n\n    def __init__(self):\n        self.stack_input = []\n        self.stack_output = []               \n\n    def push(self, x: int) -> None:\n        self.stack_input.append(x)        \n\n    def pop(self) -> int:\n        if len(self.stack_output) == 0:\n            while self.stack_input:\n                self.stack_output.append(self.stack_input.pop())\n        return self.stack_output.pop()         \n\n    def peek(self) -> int:\n        if not len(self.stack_output) == 0 :\n            return self.stack_output[-1]\n        return self.stack_input[0]\n\n    def empty(self) -> bool:\n        return len(self.stack_input) == 0 and len(self.stack_output) == 0","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"declan92":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992054950","body":"## 思路\n最短距离->两个值之间较小值\n1. 关键字将数组分成n段子数组,子数组最小索引最大索引均为关键字,且中间无关键字;\n2. 最短距离是距离最小索引和最大索引中的较小值\n3. 从左往右遍历得出距离左边关键字距离,从右往左遍历得出距离右边关键字的距离并比较两者大小\n4. 由于 1 <= s.length <= 10000,左指针初始值可以设置为Integer.MIN_VALUE+10000,不然会超过int范围;\n## java\n```\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] ans = new int[s.length()];\n        int leftPos = Integer.MIN_VALUE + 10000;\n        for(int i = 0;i < s.length(); i++){\n            if(s.charAt(i)==c){\n                leftPos = i;\n            }\n            ans[i] = i - leftPos;\n        }\n        int rightPos = Integer.MAX_VALUE;\n        for(int i = s.length() - 1;i >=0;--i){\n            if(s.charAt(i)==c){\n                rightPos = i;\n            }\n            ans[i] = Math.min(rightPos - i,ans[i]);\n        }\n        return ans;\n    }\n}\n```\n## 复杂度\n时间:O(n),n为数组长度;    \n空间:O(n),ans[]长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993038951","body":"思路\n1. 使用数组实现,第一位的值保存栈顶位置指针,数组尾部为栈顶;\n2. 初始化:数组长度maxSize+1,ans[0] = 0,size = maxSize;\n3. push(val):数组尾部增加值,栈顶指针++;\n4. pop():数组尾部弹出值,栈顶指针--;\njava\n```\nclass CustomStack {\n    private int[] ans;\n    private size;\n\n    public CustomStack(int maxSize) {\n        ans = new int[maxSize+1];\n        size = maxSize;\n        ans[0] = 0;\n    }\n    \n    public void push(int x) {\n        if(ans[0] < size){\n            ans[++ans[0]] = x;\n        }\n    }\n    \n    public int pop() {\n        if(ans[0] > 0){\n            int res = ans[ans[0]];\n            ans[ans[0]--] = 0;\n            return res;\n        }\n        return -1;\n    }\n    \n    public void increment(int k, int val) {\n        int min = Math.min(ans[0],k);\n        for(int i = 1;i <= min; i++){\n            ans[i] = ans[i] + val;\n        }\n    }\n}\n```\n复杂度:      \n时间:Custom(int maxSize): O(1); push(int x):O(1);  pop():O(1); increment(int k, int val):O(n),n为栈深;      \n额外空间:O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994510397","body":"思路:  \n栈\n1. 遍历原始字符串s；\n2. 如果是数字，则将数字拼接然后入栈；\n3. 如果是字符或者[直接入栈;\n4. 如果是],则一直获取到[之间的元素从后向前拼接成字符串,[出栈后,再次出栈一定是数字;\n5. 第4步骤获取到数字和字符串循环拼接成字符串,然后入栈;\n6. 遍历栈,头插法录入元素转换成字符串;  \njava\n```\nclass Solution {\n    private int pointer;\n    public String decodeString(String s) {\n        pointer = 0;\n        Stack<String> ansStack = new Stack<String>();\n        while(pointer<s.length()){\n            char c = s.charAt(pointer);\n            if(Character.isDigit(c)){\n                StringBuffer buffer = new StringBuffer();\n                buffer.append(Character.toString(c));\n                while(Character.isDigit(s.charAt(++pointer))){\n                    buffer.append(Character.toString(s.charAt(pointer)));\n                }\n                ansStack.push(buffer.toString());\n            }else if(Character.isLetter(c) || c == '['){\n                ansStack.push(Character.toString(c));\n                pointer++;\n            }else{\n                Stack<String> subStack = new Stack<String>();\n                while(true){\n                    if(ansStack.peek().equals(\"[\")){\n                        ansStack.pop();\n                        break;\n                    }else{\n                        subStack.push(ansStack.pop());\n                    }\n                }\n                int num = Integer.valueOf(ansStack.pop());\n                StringBuffer buffer = new StringBuffer();\n                while(!subStack.isEmpty()){\n                    buffer.append(subStack.pop());\n                }\n                StringBuffer buffer1 = new StringBuffer();\n                for(int i = 0;i < num;i++){\n                    buffer1.append(buffer.toString());\n                }\n                ansStack.push(buffer1.toString());\n                pointer++;\n            }\n        }\n        List<String> ans = new LinkedList();\n        while(!ansStack.isEmpty()){\n            ans.add(0,ansStack.pop());\n        }\n        return String.join(\"\",ans);\n    }\n}\n```\n时间:O(m+n);m为字符串s长度,n为所有[]长度和;  \n空间:O(m);m为字符串s长度;","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995323236","body":"关键字:\n两个栈、实现队列、总操作时间复杂度为O(n);  \n思路:\n1. 队列push操作,全部元素push栈1;\n2. 队列pop操作,如果栈2没有元素,将栈1元素全部pop,然后push至栈2;\n3. 如果栈2有元素,直接pop栈2;\n4. 队列peek操作的实现类似pop;\n5. 队列empty,栈1和栈2同为空则队列空,否则非空;\njava\n```\nclass MyQueue {\n    Stack<Integer> stackIn;\n    Stack<Integer> stackOut;\n    public MyQueue() {\n         stackIn = new Stack();\n         stackOut = new Stack();\n    }\n    \n    public void push(int x) {\n        stackIn.push(x);\n    }\n    \n    public int pop() {\n        if(empty()){\n            return -1;\n        }\n        if(!stackOut.empty()){\n            return stackOut.pop();\n        }\n        while(!stackIn.empty()){\n            stackOut.push(stackIn.pop());\n        }\n        return stackOut.pop();\n    }\n    \n    public int peek() {\n        if(empty()){\n            return -1;\n        }\n        if(!stackOut.empty()){\n            return stackOut.peek();\n        }\n        while(!stackIn.empty()){\n            stackOut.push(stackIn.pop());\n        }\n        return stackOut.peek();\n    }\n    \n    public boolean empty() {\n        if(stackIn.empty() && stackOut.empty()){\n            return true;\n        }\n        return false;\n    }\n}\n```\n时间:O(n),n为队列长度;队列pop()与peek()获取的元素,全部是从栈1pop,然后push进栈2,一个元素发生一次,n个元素时间复杂度为O(n);  \n额外空间:O(1);\n错误:\npeek()操作没写return","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jiaqiliu37":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992127456","body":"```\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n        prev = float(\"-inf\")\n        ans = []\n        for i, char in enumerate(s):\n            if char == c:\n                prev = i\n            ans.append(i - prev)\n        \n        prev = float(\"inf\")\n        for i in range(len(s) -1, -1, -1): \n            if s[i] == c:\n                prev = i\n            ans[i] = min(ans[i], prev-i)\n            \n        return ans\n```\nTC：O(N)\nSC:  O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993158786","body":"```\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.stack = []\n        self.size = maxSize\n\n    def push(self, x: int) -> None:\n        if len(self.stack) < self.size:\n            self.stack.append(x)\n\n    def pop(self) -> int:\n        if not self.stack:\n            return -1\n        else: \n            return self.stack.pop()\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k,len(self.stack))):\n            self.stack[i] += val\n```\nTime complexity Increment O(n) Others O(1)\nSpace complexity O(n)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994275538","body":"```\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for i in range(len(s)):\n            if s[i] != ']':\n                stack.append(s[i])\n            else:\n                repeatstr = \"\"\n                while stack[-1].isalpha():\n                    repeatstr = stack.pop() + repeatstr\n                stack.pop()\n                repeatcount = \"\"\n    \n                while stack and stack[-1].isnumeric():\n                    repeatcount = stack.pop() + repeatcount\n                count = int(repeatcount)\n                stack.append(count * repeatstr)\n                \n        return \"\".join(stack)\n```\nTime complexity O(n)\nSpace complexity O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995511833","body":"```\nclass MyQueue:\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x: int) -> None:\n        self.stack1.append(x)\n\n    def pop(self) -> int:\n        while self.stack1:\n            self.stack2.append(self.stack1.pop())\n            \n        frontpop = 0\n        frontpop = self.stack2.pop()\n        \n        while self.stack2:\n            self.stack1.append(self.stack2.pop())\n            \n        return frontpop\n\n    def peek(self) -> int:\n        while self.stack1 != []:\n            self.stack2.append(self.stack1.pop())\n            \n        frontremove = 0\n        frontremove = self.stack2[-1]\n        \n        while self.stack2 != []:\n            self.stack1.append(self.stack2.pop())\n            \n        return frontremove\n\n    def empty(self) -> bool:\n        if self.stack1 == []:\n            return True\n        else: return False\n```\nTime complexity Push Empty O(1), Pop Peek O(n)\nSpace complexity O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yhccode1999":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992376691","body":"## 思路：\r\n\r\n- 先利用list集合储存 c 字符出现的位置；\r\n- 再判断 s 字符串中每个字符与所有 c 字符的距离，取最小值\r\n\r\n```java\r\nclass Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int n = s.length();\r\n        int[] res = new int[n];\r\n        Arrays.fill(res,10001);\r\n        List<Integer> list = new ArrayList<>();\r\n        for (int i=0;i<n;i++) {\r\n            if (s.charAt(i) == c) list.add(i);\r\n        }\r\n        int len = list.size();\r\n        for (int i=0;i<n;i++) {\r\n            for (int j=0;j<len;j++) {\r\n                res[i] = Math.min(res[i], Math.abs(i-list.get(j)));\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n}\r\n```\r\n\r\n- 空间复杂度 O(n)\r\n- 时间复杂度 O(n2)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993097849","body":"## 思路：用数组实现\r\n- nowIndex 代表当前元素的位置，-1 为栈空\r\n- maxSize 为栈最大，nowIndex == maxSize - 1 时，栈满\r\n- 每 push 一次，nowIndex 往后移动一位\r\n- 每 pop 一次，nowIndex 往前移动一位\r\n- increment 时，遍历 i 从 0 开始，需要满足 i < k && i <= nowIndex\r\n\r\n## java\r\n```java\r\nclass CustomStack {\r\n    int maxSize = 0;\r\n    int nowIndex = -1;\r\n    int[] arr;\r\n    public CustomStack(int maxSize) {\r\n        this.maxSize = maxSize;\r\n        arr = new int[maxSize];\r\n    }\r\n    \r\n    public void push(int x) {\r\n        if (nowIndex == maxSize-1) {\r\n            return;\r\n        }\r\n        arr[++nowIndex] = x;\r\n    }\r\n    \r\n    public int pop() {\r\n        if (nowIndex == -1) {\r\n            return -1;\r\n        }\r\n    }\r\n    \r\n    public void increment(int k, int val) {\r\n        for (int i=0;i<k && i<=nowIndex;i++) {\r\n            arr[i] += val;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * CustomStack obj = new CustomStack(maxSize);\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * obj.increment(k,val);\r\n */\r\n```\r\n\r\n## 复杂度分析\r\n1. 时间复杂度 \r\n- push O(1)\r\n- pop O(1)\r\n-  increment:O(k)最大O(n)\r\n2. 空间复杂度\r\n- O(maxSize)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994415761","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/decode-string/\r\n\r\n## 思路：\r\n> 注意，方括号有可能会嵌套，需要借助栈或者递归完成\r\n- 字符有四种情况\r\n1. 数字：则存起来 num (存在多位数情况)\r\n2. 左方括号：递归执行，并得到方括号内的字符串内容和与之对应的右方括号的位置，拼接 num 次得到字符串内容，并更新 index 位置\r\n3. 右方括号：返回当前的 str 字符串与当前右方括号的位置\r\n4. 字符：拼接到当前 str 的后面\r\n\r\n## Java 代码\r\n```java\r\nclass Solution {\r\n    public String decodeString(String s) {\r\n        return dfs(s, 0)[0];\r\n    }\r\n    public String[] dfs(String s, int index) {\r\n        StringBuilder str = new StringBuilder();\r\n        if (index >= s.length()) {\r\n            return new String[0];\r\n        }\r\n        int num = 0;\r\n        while(index < s.length()) {\r\n            if (s.charAt(index) >= '0' && s.charAt(index) <= '9') {\r\n                num = num * 10 + (int)(s.charAt(index) - '0');\r\n            }\r\n            else if (s.charAt(index) == '[') {\r\n                String[] temp = dfs(s, index+1);\r\n                index = Integer.valueOf(temp[1]);\r\n                while(num > 0) {\r\n                    str.append(temp[0]);\r\n                    num--;\r\n                }\r\n            }\r\n            else if (s.charAt(index) == ']') {\r\n                return new String[]{str.toString(), String.valueOf(index)};\r\n            }\r\n            else {\r\n                str.append(String.valueOf(s.charAt(index)));\r\n            }\r\n            index++;\r\n        }\r\n        return new String[]{str.toString(), \"\"};\r\n    }\r\n}\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n) 一次遍历\r\n- 空间复杂度：O(n) 递归栈\r\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995382314","body":"## 题目：\r\nhttps://leetcode-cn.com/problems/implement-queue-using-stacks/\r\n\r\n## 思路：\r\n- 前提：\r\n1. in 栈只存push的数据\r\n2. out 是 peek 和 pop 的栈\r\n- 做法：\r\n1. push 时，直接存 in 栈\r\n2. pop 和 peek 时需要判断 out 栈是否为空，如果为空，则把 in 栈的数据 pop 后再 push 进 out 栈中(栈是后进先出，经过两次压栈后就变成了先进先出)，在 out 栈中 peek 和 pop\r\n3. isEmpty 需要同时判断 in 和 out 栈是否为空\r\n\r\n## Java 代码\r\n```java\r\nclass MyQueue {\r\n    Stack<Integer> in;\r\n    Stack<Integer> out;\r\n    public MyQueue() {\r\n        in = new Stack<>();\r\n        out = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        in.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if (out.isEmpty()) {\r\n            int n = in.size();\r\n            for (int i=0;i<n;i++) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if (out.isEmpty()) {\r\n            int n = in.size();\r\n            for (int i=0;i<n;i++) {\r\n                out.push(in.pop());\r\n            }\r\n        }\r\n        return out.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return in.isEmpty() && out.isEmpty();\r\n    }\r\n}\r\n\r\n/**\r\n * Your MyQueue object will be instantiated and called as such:\r\n * MyQueue obj = new MyQueue();\r\n * obj.push(x);\r\n * int param_2 = obj.pop();\r\n * int param_3 = obj.peek();\r\n * boolean param_4 = obj.empty();\r\n */\r\n```\r\n\r\n## 复杂度分析：\r\n- 时间复杂度：O(n) 一次遍历\r\n- 空间复杂度：O(n) 两个栈辅助存储\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"aobasyp":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992404415","body":"思路：\r\n先从前往后再从后往前两次遍历\r\ntmp记录c出现的位置\r\n第一次遍历从前往后,temp[i]存放s中i位置字符与前一个c的距离\r\n第二次从后往前遍历比较取较小的\r\n\r\n```\r\n`class Solution {\r\n    public int[] shortestToChar(String s, char c) {\r\n        int[] ans = new int[s.length()];      \r\n        int i = 0, j = s.length() - 1, tmp = -1;\r\n        while (i < s.length()) {\r\n            if (s.charAt(i) == c) {\r\n                ans[i] = 0;\r\n                tmp = i;\r\n            } \r\n            if (tmp != -1) {\r\n                ans[i] = i - tmp;\r\n            } else {\r\n                ans[i] = s.length() + 1;\r\n            }\r\n            \r\n            i++;\r\n        }\r\n        tmp = -1;\r\n        while (j >= 0) {\r\n            if (s.charAt(j) == c) {\r\n                ans[j] = 0;\r\n                tmp = j;\r\n            }\r\n            if (tmp != -1) ans[j] = Math.min(ans[j], tmp - j);\r\n            \r\n            j--;\r\n        }\r\n        \r\n        return ans;\r\n    }\r\n}`\r\n```\r\n\r\n时间：O(N)\r\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993219442","body":"思路\n用一个数组\npush和pop需要注意边界\ninc 从栈底(数组0号)开始遍历，依次加上对应的val，注意 for 循环里的边界条件\n代码\n'''\nclass CustomStack {\n    int[] stack;\n    int maxSize;//数组最大长度\n    int curIndex;//当前数组下标\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        this.maxSize = maxSize;\n        curIndex = -1;\n    }\n\n    public void push(int x) {\n        if (curIndex >= maxSize - 1) {\n            return;\n        }\n        curIndex++;\n        stack[curIndex] = x;\n    }\n\n    public int pop() {\n        if (curIndex < 0) {\n            return -1;\n        }\n        int resultValue = stack[curIndex];\n        curIndex--;\n        return resultValue;\n    }\n\n    public void increment(int k, int val) {\n        //栈底开始遍历\n        for (int index = 0; index < k && index <= curIndex; index++) {\n            stack[index] = stack[index] + val;\n        }\n    }\n}\n'''\n\n复杂度分析\n\npush：时间复杂度O(1) 空间复杂度O(1)\npop：时间复杂度O(1) 空间复杂度O(1)\ninc：时间复杂度O(N) 空间复杂度O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994224390","body":"思路\n\n使用两个栈，一个记录数，一个记录字符，\n当遇到数字是压人数字栈，\n遇到'[' 将'['前的字符串压人字母栈\n遇到']',弹出字符串以及数字，并相乘，接入之前的字符串。\n\n代码\n'''\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stackInt = new Stack<>();\n        Stack<String> stackStr = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for(Character c : s.toCharArray()){\n            if(c>='0'&&c<='9'){\n                multi = multi*10 + Integer.parseInt(String.valueOf(c));\n            }else if (c=='['){\n                stackInt.push(multi);\n                stackStr.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }else if (c==']'){\n                int index = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0; i<index;i++){\n                    temp.append(res);\n                }\n                res = new StringBuilder(stackStr.pop()+temp);\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n\n    }\n}\n'''\n复杂度\n\n空间复杂度：O(N)\n\n时间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995370988","body":"思路：\n题目要求用栈的原生操作来实现队列，也就是说需要用到 pop 和 push 但是我们知道 pop 和 push 都是在栈顶的操作，\n而队列的 enque 和 deque 则是在队列的两端的操作，这么一看一个 stack 好像不太能完成，\n所以用两个队列\n\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<> ();\n    Stack<Integer> popStack = new Stack<> ();\n\n    /** Initialize your data structure here. */\n    public MyQueue() {\n\n    }\n\n    /** Push element x to the back of queue. */\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n\n    /** Removes the element from in front of queue and returns that element. */\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n\n    /** Get the front element. */\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n\n    /** Returns whether the queue is empty. */\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n\n复杂度分析\n时间复杂度：O(N)，\n空间复杂度：O(N)，","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"caohaha":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992410758","body":"```C++\r\nclass Solution \r\n{\r\npublic:\r\n    vector<int> shortestToChar(string s, char c) \r\n    {\r\n        int n = s.size();\r\n\r\n        vector<int> res(n, n-1);\r\n        // 从左往右开始遍历\r\n        if(s[0] == c)\r\n            res[0] = 0;\r\n        for (int i = 1; i < n; i++)\r\n        {\r\n            if(s[i] != c)\r\n                res[i] = res[i-1]+1;\r\n            else\r\n                res[i] = 0;\r\n        }\r\n\r\n        // 从右往左开始遍历\r\n        if(s[n-1] == c)\r\n            res[n-1] = 0;\r\n        for (int i = n-2; i >= 0; --i)\r\n        {\r\n            res[i] = min(res[i], s[i] != c ? res[i+1] + 1 : 0);\r\n        }\r\n\r\n        return res;\r\n    }\r\n};\r\n```\r\n- 时间复杂度O(n)\r\n- 空间复杂度O(n)\r\n\r\n\r\n","onTime":true},null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994214499","body":"使用栈\r\n```python\r\nclass Solution:\r\n    def decodeString(self, s: str) -> str:\r\n        # 一种是使用栈，另一种是使用递归\r\n        \"\"\"\r\n        使用栈，当遇到[时，将数字压入栈，并开始用cur_str记录括号中的字母，如果遇到]，就将之前的数字出栈并与当前\r\n        cur_str相乘\r\n        \"\"\"\r\n        mul,cur_str = 0,''\r\n        stack = []\r\n        for c in s:\r\n            if c == '[':\r\n                stack.append((mul,cur_str))\r\n                mul,cur_str = 0,''\r\n            elif c == ']':\r\n                n,pre = stack.pop()\r\n                cur_str = pre + n*cur_str\r\n            elif '0'<= c <= '9':\r\n                mul = mul*10 + int(c)\r\n            else:\r\n                # 字母\r\n                cur_str += c\r\n        return cur_str\r\n```\r\n- 时间复杂度 O(n)\r\n- 空间复杂度 O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kite-fly6618":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992416737","body":"### 思路\n两边遍历，取当前位置与前一个C字符 prev之间的更新prev,取两次遍历后中较小的那个。\n\n### 代码\n\n```js\n/**\n * @param {string} S\n * @param {character} C\n * @return {number[]}\n */\nvar shortestToChar = function(S, C) {\n    let res = [];\n    let left = [];\n    let right = []\n    let prev = -Infinity;    \n    for (let i = 0; i < S.length; i++) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        left[i] = i - prev;\n    }\n    prev = Infinity;\n    for (let i = S.length - 1; i >= 0; i--) {\n        if (S.charAt(i) == C) {\n            prev = i;\n        }\n        right[i] = prev -i;\n    }\n    for (let i  = 0; i < S.length;i ++) {\n        res[i] = Math.min(left[i],right[i])\n    }\n    return res;\n};\n```\n### 复杂度\n时间复杂度： O(n)  \n空间复杂度： O(n)  \n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993454527","body":"### 思路\n初始化栈，push,pop,直接使用数组自带的方法。increment中判断数组长度与k的大小，遍历，给对应位置，加上val.\n\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.data = []\n};\n\nCustomStack.prototype.push = function(x) {\n    if (this.data.length < this.maxSize) {\n        this.data.push(x)\n    }\n};\n\n\nCustomStack.prototype.pop = function() {\n    if (this.data.length === 0) {\n        return -1   \n    } else {\n        return this.data.pop()\n    }\n\n    \n};\n\nCustomStack.prototype.increment = function(k, val) {\n    let len = Math.min(k, this.data.length)\n    for(let i = 0;i < len ;i ++) {\n        this.data[i] = this.data[i] + val\n    }\n};\n\n```\n\n### 复杂度分析\n\n时间复杂度： O(N) --> increment()  \n空间复杂度： O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994716106","body":"\n### 思路：\n两个栈分别保存，数字和字符，遇到 ] 取出栈顶的数字和字符，计算内部子串，直至栈为空。  \n\n```js\n/**\n * @param {string} s\n * @return {string}\n */\nvar decodeString = function(s) {\n    let len = s.length\n    let stack1 = [] // 数字\n    let stack2 = [] // 字符\n    let num = 0\n    let result = ''\n    for (let i = 0; i < len; i ++) {\n       if (!isNaN(s[i])) {   \n            num = num * 10 + Number(s[i]); \n        } else if (s[i] == '[') {  \n            stack2.push(result); \n            result = '';         \n            stack1.push(num);   \n            num = 0;             \n        } else if (s[i] == ']') {  \n            let Times = stack1.pop(); \n            result = stack2.pop() + result.repeat(Times); \n        } else {                   \n            result += s[i];        \n        }\n    }\n    return result\n};\n```\n\n### 复杂度\n时间复杂度: O(N)  \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995652519","body":"### 思路\n两个栈模拟队列，一个辅助栈处理pop，将栈中的元素pop出来，获取队头元素。\n\n### 代码\n```js\nvar MyQueue = function() {\n    this.stack1 = []\n    this.stack2 = []\n};\n\nMyQueue.prototype.push = function(x) {\n    this.stack1.push(x)\n};\n\nMyQueue.prototype.pop = function() {\n    if (!this.stack2.length) {\n        while(this.stack1.length) {\n            this.stack2.push(this.stack1.pop())\n        }\n    }\n    return this.stack2.pop()\n    \n};\n\nMyQueue.prototype.peek = function() {\n    return this.stack2[this.stack2.length-1] || this.stack1[0]\n};\n\nMyQueue.prototype.empty = function() {\n    return this.stack1.length === 0 && this.stack2.length === 0\n};\n```\n### 复杂度  \n时间复杂度： O(N) --> pop()  \n空间复杂度： O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xuhzyy":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992418103","body":"思路：\n1. 第一次遍历，从前往后遍历，记录距离列表1;   \n2. 第二次遍历，从后往前遍历，记录距离列表2;   \n3. 比较两个列表，取最小值即为所求答案。    \n\n代码\n\n\tclass Solution(object):\n\t\tdef shortestToChar(self, s, c):\n\t\t\t\"\"\"\n\t\t\t:type s: str\n\t\t\t:type c: str\n\t\t\t:rtype: List[int]\n\t\t\t\"\"\"\n\t\t\tprev = float('-inf')\n\t\t\tans = []\n\t\t\tfor i in range(len(s)):\n\t\t\t\tif s[i] == c:\n\t\t\t\t\tprev = i\n\t\t\t\tans.append(i-prev)\n\n\t\t\tprev = float('inf')\n\t\t\tfor i in range(len(s)-1,-1,-1):\n\t\t\t\tif s[i] == c:\n\t\t\t\t\tprev = i\n\t\t\t\tans[i] = min(ans[i], prev-i)\n\n\t\t\treturn ans\n\n时间复杂度: O(N)  \n空间复杂度: O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993306334","body":"### 思路\n通过数组来模拟构拟栈的操作\n\n\n### 代码\n\tclass CustomStack(object):\n\n\t\tdef __init__(self, maxSize):\n\t\t\t\"\"\"\n\t\t\t:type maxSize: int\n\t\t\t\"\"\"\n\t\t\tself.stack = []\n\t\t\tself.maxSize = maxSize\n\n\t\tdef push(self, x):\n\t\t\t\"\"\"\n\t\t\t:type x: int\n\t\t\t:rtype: None\n\t\t\t\"\"\"\n\t\t\tif len(self.stack) < self.maxSize:\n\t\t\t\tself.stack.append(x)\n\n\t\tdef pop(self):\n\t\t\t\"\"\"\n\t\t\t:rtype: int\n\t\t\t\"\"\"\n\t\t\tif len(self.stack) == 0:\n\t\t\t\tres = -1\n\t\t\telse: \n\t\t\t\tres = self.stack[-1]\n\t\t\t\tself.stack = self.stack[:-1]\n\t\t\treturn res\n\n\t\tdef increment(self, k, val):\n\t\t\t\"\"\"\n\t\t\t:type k: int\n\t\t\t:type val: int\n\t\t\t:rtype: None\n\t\t\t\"\"\"\n\t\t\tfor i in range(k):\n\t\t\t\tif i + 1 > len(self.stack):\n\t\t\t\t\tbreak\n\t\t\t\tself.stack[i] += val\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994531788","body":"### 思路\n\n借助栈来解决问题，如果不是']'就入栈，反之出栈，解析出str和num后生成字符串，并将生成字符串重新入栈。\n\n### 代码\n\tclass Solution(object):\n\t\tdef decodeString(self, s):\n\t\t\t\"\"\"\n\t\t\t:type s: str\n\t\t\t:rtype: str\n\t\t\t\"\"\"\n\t\t\tstack = []\n\t\t\tfor a in s:\n\t\t\t\tif a != ']':\n\t\t\t\t\tstack.append(a)\n\t\t\t\telse:\n\t\t\t\t\ttemp = ''\n\t\t\t\t\twhile (stack and stack[-1] != '['):\n\t\t\t\t\t\ttemp += stack.pop()\n\t\t\t\t\tstack.pop()\n\t\t\t\t\ttemp = temp[::-1]\n\n\t\t\t\t\tnums = []\n\t\t\t\t\twhile (stack):\n\t\t\t\t\t\tif '0' <= stack[-1] and stack[-1] <= '9':\n\t\t\t\t\t\t\tnums.append(stack.pop())\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\tnums = nums[::-1]\n\t\t\t\t\tcounter = 0\n\t\t\t\t\tfor num in nums:\n\t\t\t\t\t\tcounter = counter * 10 + int(num)\n\t\t\t\t\tcounter = max(1,counter)\n\n\t\t\t\t\ttemp *= counter\n\t\t\t\t\tstack += temp\n\n\t\t\treturn ''.join(stack)\n\n\n**复杂度分析**\n- 时间复杂度：O(N)\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995579371","body":"### 思路\n借用两个栈实现，stack1用于push，stack2用于pop和peek。\n\n### 代码\n\n```  \nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while(self.stack1):\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while(self.stack1):\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return len(self.stack1) == 0 and len(self.stack2) == 0\n```\n\n**复杂度分析**\n- 时间复杂度：push和empt为O(1)，pop和peek均摊O(1)\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"xiao-xiao-meng-xiang-jia":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992455220","body":"int N = S.length();\n        int[] ans = new int[N];\n        int prev = Integer.MIN_VALUE / 2;\n\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = i - prev;\n        }\n\n        prev = Integer.MAX_VALUE / 2;\n        for (int i = N-1; i >= 0; --i) {\n            if (S.charAt(i) == C) prev = i;\n            ans[i] = Math.min(ans[i], prev - i);\n        }\n\n        return ans;\n\n时间复杂度：O(N)\n空间复杂度：O(N)","onTime":true},null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995595846","body":"把一个栈当作输入栈，用于压入push传入的数据，另外一个当作输出栈，用于pop()和peek()操作。每次调用pop（）或者是peek（）时，如果输出栈不为空则输出顶部数据，如果为空则将输入栈的全部数据依次压入输出栈，这样就输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。\n\nclass MyQueue {\n    Deque<Integer> inStack;\n    Deque<Integer>outStack;\n    public MyQueue() {\n        inStack = new LinkedList<Integer>();\n        outStack = new LinkedList<Integer>();\n    }\n    \n    public void push(int x) {\n        inStack.push(x);\n    }\n    \n    public int pop() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.pop();\n    }\n    \n    public int peek() {\n        if(outStack.isEmpty()){\n            in2out();\n        }\n        return outStack.peek();\n    }\n    \n    public boolean empty() {\n        return inStack.isEmpty() && outStack.isEmpty();\n    }\n    private void in2out(){\n        while(! inStack.isEmpty()){\n            outStack.push(inStack.pop());\n        }\n    }\n}\n时间复杂度：O(1);\n空间复杂度：O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"biaohuazhou":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992513597","body":"###思路\n从前遍历并求出每个下标到目标的距离  再从后遍历\n最后比较两个遍历的最小值  \n###代码\n```JAVA\n    class Solution {\n        public int[] shortestToChar(String s, char c) {\n\n            int[] ans = new int[s.length()];\n            int tmp = -1;\n            //从前往后\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    ans[i] = 0;\n                    tmp = i;\n                }\n                if (tmp != -1) {\n                    ans[i] = i - tmp;\n                } else {\n                    ans[i] = s.length() + 1;\n                }\n            }\n            tmp = -1;\n            for (int j = s.length() - 1; j >= 0; j--) {\n                if (s.charAt(j) == c) {\n                    ans[j] = 0;\n                    tmp = j;\n                }\n                if (tmp != -1) {\n                    ans[j] = Math.min(tmp - j, ans[j]);\n                }\n            }\n            return ans;\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：$0(N)$ ，N是数组S的长度\n空间复杂度：$0(N)$，N是数组ans的长度","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993088581","body":"###思路\n使用数组实现栈\n###代码\n```JAVA\n    class CustomStack {\n        private int[] stack;\n        private int maxSize;\n        private int curSize;\n\n        public CustomStack(int maxSize) {\n            stack = new int[maxSize];\n            this.maxSize = maxSize;\n            curSize = 0;\n        }\n\n        public void push(int x) {\n            if (curSize < maxSize) {\n                stack[curSize++] = x;\n            }\n        }\n\n        public int pop() {\n            if (curSize == 0) {\n                return -1;\n            }\n            return stack[--curSize];\n        }\n\n        public void increment(int k, int val) {\n            k = Math.min(k, curSize);\n            for (int i = 0; i < k; i++) {\n                stack[i] = stack[i]+val;\n\n            }\n\n        }\n    }\n```\n***复杂度分析***\n时间复杂度：\npush：O(1)\npop:O(1)\nincrement:O(k)\n空间复杂度：$O(k)$","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"codingpitaya":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992528699","body":"## 题目\n\n[821. 字符的最短距离](https://leetcode-cn.com/problems/shortest-distance-to-a-character/)\n\n## 解题思路\n\n> 先遍历一遍字符串 `s` 找到所有 `c` 字符，并记录 `c` 字符出现的数组下标，然后遍历字符串 `s` 计算所有字符距离的最小值。将结果返回。\n\n## 题解\n\n```js\nvar shortestToChar = function(s, c) {\n    let result = new Array(s.length).fill(0);\n    let locations = [];\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] === c) {\n            locations.push(i);\n        }\n    }\n    for(let i = 0; i < s.length; i++) {\n        if(s[i] !== c) {\n            let locate = Infinity;\n            for(let j = 0; j < locations.length; j++) {\n                locate = Math.min(locate, Math.abs(i - locations[j]));\n            }\n            result[i] = locate\n        }\n    }\n    return result;\n};\n```\n\n- 时间复杂度:  O(N*K) `N` 为 字符串 `s` 的长度，`K` 为字符串 `s` 中 `c` 字符出现的次数。\n\n- 空间复杂度:  O(K)   `K` 为存储数组下标的辅助数组。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993629153","body":"## 题目\n\n[1381. 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)\n\n## 解题思路\n\n> 用数组模拟栈\n\n## 题解\n\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize;\n    this.stack = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if(this.stack.length >= this.maxSize) {\n        return;\n    }\n    this.stack.push(x);\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    let element = this.stack.pop();\n    if(element) return element;\n    return -1;\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let length = this.stack.length < k ? this.stack.length : k;\n    let i = 0;\n    while(i < length){\n        this.stack[i] += val;\n        i++;\n    }\n};\n```\n\n- 时间复杂度： push 和 pop 为 O(1)，increment 时间复杂度 O(K)，K 为 题目中的 `k` 和 数组长度两个值中较小的一个。\n\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994878784","body":"## 题目\n\n[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)\n\n## 解题思路\n\n> 运用栈的思想解决这道题，将字母逐一入栈，遇到数字则记录数字（防止数字不止一位），遇到 `[` 则将记录的数字入栈，并将 `[` 入栈，遇到 `]` 则循环出栈直到栈顶元素为 `[` 并记录出栈的字符串  `str`，将栈顶 `[` 出栈，再次出栈取出记录的重复次数 `num`，将记录的出栈字符串 `str` 重复 `num` 次。最后将栈中所有字符拼接成一个字符串返回。\n\n## 题解\n\n```js\nvar decodeString = function (s) {\n    let stack = [];\n    let string = \"\";\n    for (let i = 0; i < s.length; i++) {\n        if (s[i] === \"[\") {\n            stack.push(parseInt(string));\n            stack.push(\"[\");\n            string = \"\";\n        }\n        if (s[i] === \"]\") {\n            let res = \"\";\n            while (stack[stack.length - 1] !== \"[\") {\n                res = stack.pop() + res;\n            }\n            stack.pop(); //将 [ 弹出\n            let num = stack.pop();\n            stack.push(res.repeat(num));\n        }\n        if (\n            s[i].charCodeAt() >= \"0\".charCodeAt() &&\n            s[i].charCodeAt() <= \"9\".charCodeAt()\n        ) {\n            string += s[i];\n        }\n        if (\n            (s[i].charCodeAt() >= \"a\".charCodeAt() &&\n                s[i].charCodeAt() <= \"z\".charCodeAt()) ||\n            (s[i].charCodeAt() >= \"A\".charCodeAt() &&\n                s[i].charCodeAt() <= \"Z\".charCodeAt())\n        ) {\n            stack.push(s[i]);\n        }\n    }\n    return stack.join('');\n};\n```\n\n- 时间复杂度：O(N)\n\n- 空间复杂度：O(N)\n\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995837714","body":"## 题目\n\n#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)\n\n## 解题思路\n\n> 关键在于用另一个栈来将入栈的顺序颠倒过来，每次 `push` 数据，先将 `stack` 中存的数据依次出栈存入另一个栈 `list` 中，直到 `stack` 栈空，将 `push` 进入的数字 `x` 入栈 `stack`，再将 `list` 中存的数据依次存入 `stack` 中。\n\n## 题解\n\n```js\nvar MyQueue = function() {\n    this.stack = [];\n    this.list = [];\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    let current = null;\n    while( current = this.stack.pop()) {\n        this.list.push(current)\n    }\n    this.list.push(x);\n    \n    while( current = this.list.pop()) {\n        this.stack.push(current)\n    }\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    return this.stack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    return this.stack[this.stack.length - 1];\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return this.stack.length === 0\n};\n```\n\n- 时间复杂度：O(N) 每次入栈都要先将栈中元素推出栈存入辅助栈。\n- 空间复杂度：O(N) 辅助栈空间与栈空间相同。\n\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"pwqgithub-cqu":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992579590","body":"暴力解法:\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> a;\n\n        for(int i=0; i<s.size(); i++)\n        {\n            if(s[i] == c)\n                a.push_back(i);  \n        }\n\n        vector<int> answer;\n        for(int i=0; i<s.size(); i++)  // 遍历字符串\n        {\n            int num = s.size();\n            for(int j=0; j< a.size(); j++)  \n            {\n                num = min(num, abs(a[j]-i));\n            }\n            answer.push_back(num);\n        }\n        return answer;\n    }\n};\n\n时间复杂度:N*N\n空间复杂度:N","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rex-zh":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992600011","body":"### 思路  \n1. 遍历找到第一个c，并记录位置  \n1. 遍历结果数组至上述位置，为c之前及其自身索引赋距离值  \n1. 从上述位置的下一个开始继续遍历，使用gap计算两个c之间的间距，同时作为当前索引的距离值，若出现c则反向遍历gap/2个索引重新赋更近的距离值  \n1. 遍历完毕返回结果  \n### 代码  \n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int[] answer = new int[s.length()];\n        int gap = 0;\n        int k = 0;\n        for(; k<s.length() ; k++){\n            if(s.charAt(k) == c) break;\n        }\n        for(int i=0; i<=k; i++){\n            answer[i] = k-i;\n        }\n        for(int i=k+1; i<s.length(); i++){\n            if(s.charAt(i)==c){\n                for(int j=i; j>=i-gap/2; j--){\n                    answer[j]=i-j;\n                }\n                gap=0;\n            }else{\n                gap++;\n                answer[i]=gap;\n            }\n        }\n        return answer;\n    }\n}\n```  \n### 复杂度分析  \n- 时间复杂度：O(N)，N为字符串长度  \n- 空间复杂度：也许O(N)  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993642150","body":"#### 思想  \n1. 使用C++的vector及其方法；  \n1. 使用vector.reserve(int)来控制容量；  \n1. 通过比较size和capacity判断是否栈满；  \n1. 通过vector.empty()判断是否栈空；  \n1. 循环迭代k和size较小次处理值变化。  \n#### 代码  \n```c++\nclass CustomStack {\nprivate:\n    vector<int> stack;\npublic:\n    CustomStack(int maxSize) {\n        stack.reserve(maxSize);\n    }\n    \n    void push(int x) {\n        if(stack.size() == stack.capacity()){\n            return;\n        }else{\n            stack.push_back(x);\n        }\n    }\n    \n    int pop() {\n        if(stack.empty()){\n            return -1;\n        }else{\n            int top=stack.back();\n            stack.pop_back();\n            return top;\n        }\n    }\n    \n    void increment(int k, int val) {\n        int board = k<stack.size()?k:stack.size();\n        for(int i=0; i<board; i++){\n            stack[i]+=val;\n        }\n    }\n};\n```  \n#### 算法复杂度  \n- 时间复杂度：增量O(N)，N为栈容量，其余为O(1)？  \n- 空间复杂度：O(N)，N为栈容量  ","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923350","body":"### code\r\n```c++\r\nclass Solution {\r\npublic:\r\n    string decodeString(string s) {\r\n        for(int i=0; i<s.length(); i++){\r\n            if(s[i] == ']'){\r\n                int j=i-1;\r\n                string temp;\r\n                string add;\r\n                int k=0;\r\n                for(; j>-1; j--){\r\n                    if(s[j]=='[') break;\r\n                    temp.insert(0,1,s[j]);\r\n                }\r\n                for(int m=--j; m>-1; m--){\r\n                    if(s[m]>'9' || s[m]<'0'){\r\n                        j=m+1;\r\n                        break;\r\n                    }else{\r\n                        k=k+(s[m]-'0')*pow(10,j-m);\r\n                        if(m==0){\r\n                            j=0;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                add = temp;\r\n                for(int m=1; m<k; m++){\r\n                    add.append(temp);\r\n                }\r\n                s.replace(s.begin()+j,s.begin()+i+1,add);\r\n                i=j+add.length()-1;\r\n            }\r\n        }\r\n        return s;\r\n    }\r\n};\r\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995866693","body":"#### 代码\n```java\nclass MyQueue {\n    Stack<Integer> pushStack = new Stack<> ();\n    Stack<Integer> popStack = new Stack<> ();\n\n    public MyQueue() {\n\n    }\n\n    public void push(int x) {\n        while (!popStack.isEmpty()) {\n            pushStack.push(popStack.pop());\n        }\n        pushStack.push(x);\n    }\n\n    public int pop() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.pop();\n    }\n\n    public int peek() {\n        while (!pushStack.isEmpty()) {\n            popStack.push(pushStack.pop());\n        }\n        return popStack.peek();\n    }\n\n    public boolean empty() {\n        return pushStack.isEmpty() && popStack.isEmpty();\n    }\n}\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"yutong-dai":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992604942","body":"\n# 思路\n\nforward + backward pass\n\nrecord the current char location\n\n# 代码\n\n```python\nclass Solution:\n    def shortestToChar(self, s: str, c: str) -> List[int]:\n\n        n = len(s)\n        ans = []\n\n        #forward\n        last_seen = -n    \n        for (i, cur_char) in enumerate(s):\n            if cur_char == c:\n                last_seen = i\n            ans.append(i-last_seen)\n\n        #backward\n        last_seen = 2*n   \n        for i in range(n-1, -1, -1):\n            if s[i] == c:\n                last_seen = i\n            ans[i] = min(ans[i], last_seen-i)\n        \n        return ans\n```        \n\n# 复杂度分析\n\n* 时间复杂度：O(N)\n* 空间复杂度：O(N)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993055568","body":"\n# 代码\n\nclass CustomStack:\n\n```python\n    def __init__(self, maxSize: int):\n        self.maxSize = maxSize\n        self.size = 0\n        self.lst = [None] * maxSize\n\n    def push(self, x: int) -> None:\n        if self.size < self.maxSize:\n            self.lst[self.size] = x\n            self.size += 1\n\n    def pop(self) -> int:\n        if self.size == 0:\n            return -1\n        else:\n            item = self.lst[self.size-1]\n            self.size -= 1\n            return item\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.size)):\n            self.lst[i] += val\n```\n\n# 复杂度:\n\n时间\n\n* push: O(1)\n* pop: O(1)\n* increment: O(n)\n\n空间复杂度：\n\n* push: O(2)            \n* pop: (1)\n* increment: O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994264952","body":"# 思路:\nstack 匹配 括号\n\n# 代码\n\n```python\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for char in s:\n            if char != ']':\n                stack.append(char)\n            else:\n                item = stack.pop(-1)\n                temp_str = ''\n                while item != '[':\n                    temp_str = item + temp_str\n                    item = stack.pop(-1)\n                # get numerics\n                num_str = ''\n                while stack and stack[-1].isnumeric():\n                    num_str = stack.pop(-1) + num_str\n                stack.append(int(num_str) * temp_str)\n        return \"\".join(stack)\n```\n\n# 复杂度\n\ntime: O(n)\nspace: O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"tian-pengfei":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992610167","body":"```c++\nclass Solution {\npublic:\n    vector<int> shortestToChar(string s, char c) {\n        vector<int> re(s.length(),10000);\n\n        for (int i =0 ;i<s.length();i++){\n\n            if(s[i] == c){\n                re[i] = 0;\n                for (int j =0 ;j<s.length();j++){\n                    if(re[j]>abs(j-i)){\n                        re[j]=abs(j-i);\n                    }\n                }\n            }\n\n\n        }\n\n        return  re;\n    }\n};\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993618004","body":"````c++\nclass CustomStack {\nprivate:\n    vector<int> * p_data;\n    int pos = -1;\n    int maxSize = -1;\npublic:\n\n    CustomStack(int maxSize) {\n        p_data = new vector<int>(maxSize);\n        pos = 0;\n        this->maxSize = maxSize;\n    }\n\n    void push(int x) {\n        if(pos == maxSize)return;\n        (*p_data)[pos++]=x;\n    }\n\n    int pop() {\n        if(pos == 0) return -1;\n        return p_data->at(--pos);\n    }\n\n    void increment(int k, int val) {\n        if(pos ==0) return ;\n         *new vector<int>(k,val);\n         for(int i =0 ;i<maxSize&&i<k;i++){\n             (*p_data)[i] = (p_data->at(i)+val);\n         }\n    }\n};\n\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994920927","body":"```c++\nclass Solution {\npublic:\n      //一开始没有考虑到多个数字100\n    string decodeString(string s) {\n        if(s.empty()){\n            return s;\n        }\n        char c = s.at(0);\n\n        if(isNum(c)){\n\n            //一开始没有考虑到多个数字100\n            string s_copy_num ;\n            int pos = 0;\n            while (isNum(s.at(pos))){\n                s_copy_num.push_back(s.at(pos));\n                pos++;\n            }\n\n            //中括号编码+其余部分 -->c*de(中括号部分)+ de(其余部分)\n\n            //提取中括号中部分\n            int z_num = 1;\n             pos ++; //[ 后开始遍历\n            while(z_num!=0){\n                if(s.at(pos)=='[')z_num++;\n                else if(s.at(pos)==']')z_num--;\n                pos++;\n            }\n            string z_str = s.substr(s_copy_num.length()+1,pos-s_copy_num.length()-2);\n            string o_str = pos<s.length()?s.substr(pos):\"\";\n\n            int copyNum  =  stoi(s_copy_num);\n            string result=\"\";\n            string de_z_str = decodeString(z_str);\n            string de_o_str = decodeString(o_str);\n            for(int i =0;i<copyNum;i++){\n                result.append(de_z_str);\n            }\n           return  result.append(de_o_str);\n\n        }\n        if(s.length()==1){\n\n            //#char 怎么转化为string c+\"\" leedcode无法编译通过\n            string e;\n            return e+c;\n        }\n        return c+ decodeString(s.substr(1));\n    }\n\n    static bool isNum(char c){\n        return (c>='0'&&c<='9');\n    }\n};\n````","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"rmbdream":[null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/2#issuecomment-992638943","body":"## Note\nc的位置pre未知时距离为无穷远，即先将距离赋予超大数。左右遍历，右遍历时距离为i-pre，左遍历时为pre-i\n## Code\n```java\nclass Solution {\n    public int[] shortestToChar(String s, char c) {\n        int n = s.length();\n        int[] ans = new int[n];\n        \n        // /2防止越界\n        int pre = Integer.MIN_VALUE / 2;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = i - pre;\n        }\n        pre = Integer.MAX_VALUE;\n        for (int i = n - 1; i > -1; i--) {\n            if (s.charAt(i) == c) {\n                pre = i;\n            }\n            ans[i] = Math.min(ans[i], pre - i);\n        }\n        return ans;\n    }\n}\n```\n## Complexity\n- time: O(n)\n- space: O(n)","onTime":false},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"fayepei":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993010039","body":"class CustomStack {\r\n    int top;\r\n     public CustomStack(int maxSize){\r\n        int[] stack=new int[maxSize];\r\n        top=-1;\r\n     }\r\n    \r\n     public void Push(int x) { //no need to return, for the void method\r\n         if(top!=stack.length-1){\r\n             top++;\r\n             stack[top]=x;\r\n         }\r\n     }\r\n     public int Pop() {\r\n        if(top=-1){\r\n            return -1;\r\n        }--top;\r\n         return stack[top+1];\r\n         \r\n        \r\n     }\r\n     public void Increment(int k, int val) {\r\n         int limit=Math.min(k,top+1);\r\n        for(int i=0;i<limit;i++){\r\n            stack[i]=stack[i]+val;\r\n        } \r\n         \r\n     }      \r\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"herbertpan":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993114123","body":"### 思路\n没什么特别的，标准的用array 模拟stack\n1. top指针表示 栈顶\n2. bottom 指针表示 栈底\n3. size 表示 当前栈大小：push pop 操作相关\n4. array[maxSize + 1]做内部数据结构：为什么+1，模拟stack full时top指针的位置\n\n### 代码\n```java\nclass CustomStack {\n    private int maxSize;\n    private int size;\n    private int top;\n    private int bot;\n    \n    private int[] stack;\n    \n    public CustomStack(int maxSize) {\n        this.size = 0;\n        this.top = 0;\n        this.bot = 0;\n        \n        this.maxSize = maxSize;\n        this.stack = new int[maxSize+1];\n    }\n    \n    public void push(int x) {\n        if (this.size == this.maxSize) {\n            // do nothing\n        } else {\n            this.stack[this.top++] = x;\n            this.size++;\n        }\n    }\n    \n    public int pop() {\n        if (this.size == 0) {\n            return -1;\n        } else {\n            this.top--;            \n            this.size--;\n            return this.stack[this.top];\n        }\n    }\n    \n    public void increment(int k, int val) {\n        if (k > this.maxSize) {\n            k = this.maxSize;\n        }\n        \n        for (int i = this.bot; i < k && i < this.top; i++) {\n            this.stack[i] += val;\n        }\n    }\n}\n\n```\n\n**复杂度分析**\n- 时间复杂度：push,pop都是O(1), increment是O(min(K, maxSize))\n- 空间复杂度：O(maxSize)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994403353","body":"### 解题思路\n1. 一开始想着用俩个stack，一个存num，一个存str，但是实现的时候发现，很难让两方数据对齐。\n    即test case不是全部`num[str \"num[str]\"]`的格式。\n    也有可能是`str num[str]` 或者 `num[num[str]]`的格式。所以这就需要自己填上空，使其满足`num[str \"num[str]\"]`的格式。\n    十分困难\n2. 后来选择，用一个stack，里面存全部数据num + str就方便多了。\n### 代码\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<StringBuilder> stack = new Stack<>();\n        \n        int pnt = 0;\n        while (pnt < s.length()) {\n            if (Character.isDigit(s.charAt(pnt))) {\n                // get all digits and insert as a string number\n                \n                StringBuilder sb = new StringBuilder();\n                while (pnt < s.length() && Character.isDigit(s.charAt(pnt))) {\n                    sb.append(s.charAt(pnt));\n                    pnt++;\n                }\n                // when it comes out, pnt points to \"[\"\n                stack.push(sb);          \n            } else if (Character.isLowerCase(s.charAt(pnt))) {\n                StringBuilder sb = new StringBuilder();\n                while (pnt < s.length() && Character.isLowerCase(s.charAt(pnt))) {\n                    sb.append(s.charAt(pnt));\n                    pnt++;\n                }\n                // when it comes out, pnt points to \"]\"\n                stack.push(sb);\n            } else if (s.charAt(pnt) == '[') {\n                stack.push(new StringBuilder(\"[\"));\n                pnt++;\n            } else {  // \"]\"\n                StringBuilder sb = new StringBuilder();\n                // pop all str until [\n                StringBuilder popStr = stack.pop();\n                while(!popStr.toString().equals(\"[\")) {\n                    sb.insert(0, popStr);\n                    popStr = stack.pop();\n                }\n                // pop [, pop'd already\n                \n                // pop number\n                StringBuilder numStr = stack.pop();\n                \n                // regenerate new string and insert back\n                for (int i = 0; i < Integer.valueOf(numStr.toString()); i++) {\n                    stack.push(sb);\n                }\n                \n                pnt++;\n            }\n        }\n        \n        StringBuilder sb = new StringBuilder();\n        while(!stack.isEmpty()) {\n            sb.insert(0, stack.pop());\n        }\n\n        return sb.toString();\n    }\n}\n```\n\n### 复杂度\n时间：O(n * m). n 是 string length, m是]的个数\n空间：O(n)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995516437","body":"### 思路\n两个stack 一个装push 一个装po p\n### 代码\n```java\nclass MyQueue {\n\n    private Stack<Integer> pushStack;\n    private Stack<Integer> popStack;\n    \n    public MyQueue() {\n        pushStack = new Stack<Integer>();\n        popStack = new Stack<Integer>();\n    }\n    \n    public void push(int x) {\n        pushStack.push(x);\n    }\n    \n    public int pop() {\n        if (popStack.isEmpty()) {\n            // move all pushStack to popStack\n            while (!pushStack.isEmpty()) {\n                popStack.push(pushStack.pop());\n            }\n        }\n        return popStack.pop();\n    }\n    \n    public int peek() {\n        if (popStack.isEmpty()) {\n            // move all pushStack to popStack\n            while (!pushStack.isEmpty()) {\n                popStack.push(pushStack.pop());\n            }\n            \n        }\n        return popStack.peek();\n    }\n    \n    public boolean empty() {\n        return popStack.isEmpty() && pushStack.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n```\n### 复杂度分析\n时间：amortized O(1)\n空间：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"amberma626":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993185619","body":"思路：Use array to record maxSize and simulate stack\r\n代码：\r\n```python3\r\nclass CustomStack:\r\n\r\n    def __init__(self, maxSize: int):\r\n        self.stack = [] \r\n        self.maxSize = maxSize\r\n        \r\n    def push(self, x: int) -> None:\r\n        if len(self.stack) < self.maxSize:\r\n            self.stack.append(x)       \r\n\r\n    def pop(self) -> int:\r\n        if len(self.stack) <= 0 :\r\n            return -1\r\n        else:\r\n            return self.stack.pop()        \r\n\r\n    def increment(self, k: int, val: int) -> None:\r\n        if k <= len(self.stack):\r\n            for i in range(k):\r\n                self.stack[i] += val \r\n            \r\n        else:\r\n            self.stack = [x+val for x in self.stack]\r\n```","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"phybrain":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993251967","body":"### 思路\n\n数组实现\n\n### 代码\n\n\n```python\n\nclass CustomStack:\n\n    def __init__(self, size: int):\n        self.st = []\n        self.cnt = 0\n        self.size = size\n\n    def push(self, x: int) -> None:\n        if self.cnt < self.size:\n            self.st.append(x)\n            self.cnt += 1\n\n\n    def pop(self) -> int:\n        if self.cnt == 0: return -1\n        self.cnt -= 1\n        return self.st.pop()\n\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(0, min(self.cnt, k)):\n            self.st[i] += val\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(1)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994673692","body":"### 思路\n递归\n\n### 代码\n\n\n```python\n    def decodeStringDfs(self, s: str) -> str:\n        def dfs(i):\n            res, multi = \"\", 0\n            #这里不能用for i in range(len(s)),因为递归调用时，新的循环不从0开始从i开始\n            while i < len(s):\n                #遇到数字\n                if '0' <= s[i] <= '9':\n                    multi = multi * 10 + int(s[i])#考虑数字是2位以上的情况\n                #遇到'['开始将后续的string递归\n                elif s[i] == '[':\n                    i, tmp = dfs(i + 1)\n                    #注意，返回i的含义是更新上层递归指针位置，因为内层递归已经吃掉一串str，若不跟新i，外层仍然从i+1开始，则会重复处理内层处理过的一串str。\n                    res += multi * tmp\n                    multi = 0\n                #遇到']'到达递归边界，结束递归，返回新i和处理好的内层res\n                elif s[i] == ']':\n                    return i, res\n                #遇到其他，则当字母串处理\n                else:\n                    res += s[i]\n                i+=1\n            #考虑结尾是...]abc的情况\n            return res\n        \n        return dfs(0)\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995661183","body":"### 思路\n双栈互换\n\n### 代码\n\n\n```python\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.s1 = []\n        self.s2 = []\n        self.front = None\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.s1: self.front = x\n        self.s1.append(x)\n        \n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())\n            self.front = None\n        return self.s2.pop()\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if self.s2: \n            return self.s2[-1]\n        return self.front\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        if not self.s1 and not self.s2:\n            return True\n        return False\n\n\n```\n\n**复杂度分析**\n- 时间复杂度：O(N)，其中 N 为数组长度。\n- 空间复杂度：O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"testeducative":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993270910","body":"## 代码\n```c++\nclass CustomStack {\npublic:\n    int maxS;\n    vector<int> stack;\n    CustomStack(int maxSize) {\n        maxS=maxSize;\n    }\n    \n    void push(int x) {\n        if(stack.size()<maxS)\n            stack.push_back(x);\n    }\n    \n    int pop() {\n        if(stack.size()==0)\n            return -1;\n        int back=stack.back();\n        stack.pop_back();\n        return back;\n    }\n    void increment(int k, int val) {\n        int bottom=k;\n        if(stack.size()<k)\n            bottom=stack.size();\n        for(int i=0;i<bottom;i++)\n        {\n            stack[i]+=val;\n        }\n    }\n};\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994567953","body":"# 代码\n```c++\nclass Solution {\npublic:\n    string decodeString(string s) {\n       stack<char> decode;\n        for(int i = 0; i < s.length(); ++i)\n        {\n            if(s[i] == ']')\n            {\n                string decodeS = \"\";\n                while(decode.top() != '[')\n                {\n                    decodeS += decode.top();\n                    decode.pop();\n                }\n                decode.pop();\n                int num = 0;\n                int base = 1;\n                while(!decode.empty() && isdigit(decode.top()))\n                {\n                    num +=  ((int)decode.top()-48) * base;\n                    decode.pop();\n                    base *= 10;\n                }\n                while(num != 0 )\n                {\n                    for(int j = decodeS.length() - 1; j >= 0; --j)\n                    {\n                        decode.push(decodeS[j]);\n                    }\n                    num--;\n                }\n            }\n            else\n            {\n                decode.push(s[i]);\n            }\n        }\n        string finalString;\n        for(int i = decode.size() - 1; i >= 0; i--)\n        {\n            finalString = decode.top() + finalString;\n            decode.pop();\n        }\n        return finalString;\n    }\n};","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"littleworker":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993329296","body":"### 思路\n\n使用TypeScript，栈采用数组进行模拟，直接使用数组的push 和 pop方法，在push和pop时进行长度判断\n\n### 代码\n\n\n```typescript\nclass CustomStack {\n    private arr:number[] =[];\n    private maxSize:number=0;\n    constructor(maxSize: number) {\n      this.maxSize = maxSize\n    }\n\n    push(x: number): void {\n      if(this.arr.length < this.maxSize){\n        this.arr.push(x);\n      }\n    }\n\n    pop(): number {\n        return  this.arr.pop() || -1\n    }\n\n    increment(k: number, val: number): void {\n      const maxNum = Math.min(this.arr.length,k)\n      for(let i=0;i<maxNum;i++){\n        this.arr[i] += val;\n      }\n    }\n}\n```\n\n**复杂度分析**\n- 时间复杂度：\n  push,pop: O(1)，其中 N 为数组长度。\n  inc: O(Max(K,N))，其中 K 为操作元素长度，N为数组长度。\n- 空间复杂度：O(N)，其中 N 为数组长度。","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994298220","body":"## 思路\n递归，顺序遍历字符串，遇到左括号，则找到对应的右括号，将左右括号的子串作为参数，进行递归调用；难点在于如何找到当前 左侧括号 对应的 右侧括号\n\n## TypeScript 代码\n```typescript\nfunction decodeString(s: string): string {\n  let num = 0\n  const leftStack:number[]=[];\n  let currentStr = \"\";\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    \n    if (!isNaN(Number(char))) {\n      num = num*10 + Number(char)\n    } else if (char === \"[\") {\n      leftStack.push(i)\n      for(let j=i+1;j<s.length;j++){\n        if(s[j] === '['){\n          leftStack.push(j)\n        }else if(s[j] ===']'){\n          leftStack.pop()\n          if(leftStack.length === 0){\n            currentStr += decodeString(s.slice(i+1,j)).repeat(num)\n            i = j\n            break\n          }\n        }\n      }\n      num = 0\n    } else {\n      currentStr += char;\n      num = 0\n    }\n  }\n\n  return currentStr;\n}\n```\n\n## 复杂度\n时间：O(N*N)\n空间：O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995339880","body":"## 思路\n感觉对JS来说，这个题没什么意义，用数组自带的api就可以了\n\n## 代码\n```typescript\nclass MyQueue {\n    private arr:number[]=[];\n    constructor() {\n      this.arr = []\n    }\n\n    push(x: number): void {\n      this.arr.push(x)\n    }\n\n    pop(): number {\n      return this.arr.shift()\n    }\n\n    peek(): number {\n      return this.arr[0]\n    }\n\n    empty(): boolean {\n      return !this.arr.length\n    }\n}\n```\n\n## 复杂度\n时间：O(1) 都是单个操作","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"kkstudycoding":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993486331","body":"```java\n\nclass CustomStack{\n    int [] stack;\n    int top;\n    public CustomStack (int maxSize){\n        stack = new int[maxSize];\n        top = -1;\n    }\n    \n    public void push(int x){\n        if(top!= stack.length - 1){\n            ++top;\n            stack[top] = x;\n        }\n    }\n    \n    public int pop(){\n        if(top == -1){\n            return -1;\n        }\n        --top;\n        return stack[top + 1];\n    }\n    \n    public void increment(int k, int val){\n        int limit = Math.min(k, top + 1);\n        for(int i = 0; i<limit; i++){\n            stack[i] += val;\n        }\n    }\n}\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994727441","body":"class Solution {\n    public String decodeString(String s) {\n        String result = \"\";\n        Stack<String> sta = new Stack<>();\n        \n    for (int i = 0; i < s.length(); i++) {\n        String current = s.charAt(i) + \"\";\n        \n        \n        if (!current.equals(\"]\")) {\n            sta.push(current);\n        }\n        \n        else {\n            \n            String cur = \"\";\n            while (!sta.peek().equals(\"[\")) {\n                cur = sta.pop() + cur;\n            }\n            \n            sta.pop();\n            \n            String p = \"\";\n            while (!sta.isEmpty() && \n            sta.peek().compareTo(\"0\") >= 0 && sta.peek().compareTo(\"9\") <= 0) {\n                p = sta.pop() + p;\n            }\n            int flag = Integer.parseInt(p);\n            \n            String l = cur;       \n            for (int j = 1; j < flag; j++) {\n                **cur += l;** \n            }\n            \n            sta.push(cur);\n        }\n    }\n    \n    while (!sta.isEmpty()) {\n        result = sta.pop() + result;\n    }\n    return result;\n }\n}","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"size-of":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993552437","body":"\n\n## 代码\n\n- 语言支持：JavaScript\n\nJavaScript Code:\n\n```javascript\n\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.list = []\n    this.maxSize = maxSize\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.list.length === this.maxSize) return\n    this.list[this.list.length] = x\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    if (!this.list.length) return -1\n    return this.list.splice(this.list.length - 1, 1)[0]\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    for (let i = 0; i < (this.list.length < k ? this.list.length : k); i++) {\n         this.list[i] += val\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n\n```\n\n\n**复杂度分析**\n\n令 n 为数组长度。\n\n- 时间复杂度：$O(k)$\n- 空间复杂度：$O(maxSize)$\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"grendelta":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993572332","body":"## 思路\n\n使用list来模拟栈，push判断list是否已满，pop判断list是否为空，increment取k和list size的较小值\n\n## 代码\n\n\nclass CustomStack(object):\n\n    def __init__(self, maxSize):\n        \"\"\"\n        :type maxSize: int\n        \"\"\"\n        self.maxSize = maxSize\n        self.stack = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        if len(self.stack) < self.maxSize:\n            self.stack.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if self.stack:\n            return self.stack.pop()\n        else:\n            return -1\n\n\n    def increment(self, k, val):\n        \"\"\"\n        :type k: int\n        :type val: int\n        :rtype: None\n        \"\"\"\n        for i in range(min(len(self.stack),k)):\n            self.stack[i] += val\n\n## 复杂度\n\n时间复杂度 O(N)\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993794311","body":"## 思路\n\n使用DFS来构建decode中复制【】内部内容的功能\n\n## 代码\n\nclass Solution(object):\n    def decodeString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n\n        def decode(s, pin):\n            res = \"\"\n            time = 0\n            while pin < len(s):\n                if s[pin] in '0123456789':\n                    time = time * 10 + int(s[pin])\n                elif s[pin] == '[':\n                    pin += 1\n                    pin, dec = decode(s, pin)\n                    res += time * dec\n                    time = 0\n                elif s[pin] == ']':\n                    return pin, res\n                else:\n                    res += s[pin]\n                pin += 1\n            return res\n        return decode(s, 0)\n\n## 复杂度\n\n时间复杂度 O(N)\n\n空间复杂度 O(N)","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-994967119","body":"## 思路\n\n建立两个栈，一个负责输入，一个负责peek和输出\n当peek或者输出时，将输入栈的元素放入输出栈\n\n## 代码\n\nclass MyQueue(object):\n\n    def __init__(self):\n        self.stack1 = []\n        self.stack2 = []\n\n\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: None\n        \"\"\"\n        self.stack1.append(x)\n\n\n    def pop(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2.pop()\n\n\n\n    def peek(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.stack2:\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n        return self.stack2[-1]\n\n\n    def empty(self):\n        \"\"\"\n        :rtype: bool\n        \"\"\"\n        return not self.stack1 and not self.stack2\n\n\n## 复杂度分析\n\n时间复杂度 O(N)\n\n空间复杂度 O(N)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"etrurialegend":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993589821","body":"## 思路\r\n- 用数组初始化栈最大长度和栈顶位置\r\n- push：不超过最大长度时才可操作：数组模拟的栈顶加入push的值同时栈顶的索引加一\r\n- pop：栈顶索引大于0时才可操作：栈顶索引-1并返回此时栈顶的值\r\n- increment：遍历栈逐个增加val直至到k\r\n## 代码\r\n```js\r\n/**\r\n * @param {number} maxSize\r\n */\r\nvar CustomStack = function(maxSize) {\r\n  this.maxSize = maxSize;\r\n  this.stack = [];\r\n  this.top = 0;\r\n};\r\n\r\n/** \r\n * @param {number} x\r\n * @return {void}\r\n */\r\nCustomStack.prototype.push = function(x) {\r\n  if (this.top < this.maxSize) {\r\n    this.stack[this.top] = x;\r\n    this.top += 1;\r\n  }\r\n};\r\n\r\n/**\r\n * @return {number}\r\n */\r\nCustomStack.prototype.pop = function() {\r\n  if (this.top <= 0) return -1;\r\n  this.top -= 1;\r\n  return this.stack[this.top];\r\n};\r\n\r\n/** \r\n * @param {number} k \r\n * @param {number} val\r\n * @return {void}\r\n */\r\nCustomStack.prototype.increment = function(k, val) {\r\n  if (!this.stack.length) return;\r\n  for(let i = 0; i < this.maxSize; i++) {\r\n    if (i === k) break;\r\n    this.stack[i] += val;\r\n  }\r\n};\r\n\r\n/**\r\n * Your CustomStack object will be instantiated and called as such:\r\n * var obj = new CustomStack(maxSize)\r\n * obj.push(x)\r\n * var param_2 = obj.pop()\r\n * obj.increment(k,val)\r\n */\r\n```\r\n## 复杂度\r\n时间复杂度：O(k) k为increment的长度\r\n空间复杂度：O(maxSize) maxSize是初始化时栈的长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"jay214":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993660594","body":"## 思路：\njs写起来很方便，直接用数组模拟\n\n## 代码：\n```js\n/**\n * @param {number} maxSize\n */\nvar CustomStack = function(maxSize) {\n    this.maxSize = maxSize\n    this.pool = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nCustomStack.prototype.push = function(x) {\n    if (this.pool.length < this.maxSize) {\n        this.pool.push(x)\n    }\n};\n\n/**\n * @return {number}\n */\nCustomStack.prototype.pop = function() {\n    const res = this.pool.pop()\n    return res !== undefined ? res : -1\n};\n\n/** \n * @param {number} k \n * @param {number} val\n * @return {void}\n */\nCustomStack.prototype.increment = function(k, val) {\n    let len = this.pool.length\n    for (let i = 0; i < k; i++) {\n        if (i < len) {\n            this.pool[i] += val\n        } else {\n            break\n        }\n    }\n};\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * var obj = new CustomStack(maxSize)\n * obj.push(x)\n * var param_2 = obj.pop()\n * obj.increment(k,val)\n */\n```\n## 复杂度\n时间复杂度： push 和 pop 为 O(1)，increment 时间复杂度 O(K)，K 为 题目中的 k 和 数组长度两个值中较小的一个。\n空间复杂度：不算数组存储空间的话其他操作是O(1)\n","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994923679","body":"## 思路：\n/**\n * @param {string} s\n * @return {string}\n想半天不会，看了官方思路\n使用栈\n 如果当前的字符为数位，解析出一个数字（连续的多个数位）并进栈\n如果当前的字符为字母或者左括号，直接进栈\n如果当前的字符为右括号，开始出栈，一直到左括号出栈，出栈序列反转后拼接成一个字符串，此时取出栈顶的数字，就是这个字符串应该出现的次数，我们根据这个次数和字符串构造出新的字符串并进栈\n */\n## 代码：\n```js\nvar decodeString = function(s) {\n    let tmp = []\n    let str = ''\n\n    s = s.split('')\n    for (let i = 0; i < s.length; i++) {\n        if (s[i]=== '[' || (s[i] !== ']'&&isNaN(+s[i]))) {\n            tmp.push(s[i])\n        } else if (s[i] === ']') {\n            let ss = ''\n            while ((str = tmp.pop()) !== '[') {\n                ss = str + ss\n            }\n            const num = tmp.pop()\n            tmp.push(Array(num).fill(ss).join(''))\n\n        } else if (typeof +s[i] === 'number') {\n           let num = s[i]\n           while (i+1 < s.length && !isNaN(+s[i+1])) {\n               num += s[++i]\n           }\n           tmp.push(+num)\n        } \n    }\n\n    return tmp.join('')\n};\n```\n## 复杂度：\n时间 O(S),空间O(S)，其中S为字符串长度","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"goredfish":[null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/4#issuecomment-993660929","body":"**思路**\n\n用array作为base\n\n**复杂度分析**\n\npop\\push: O(1)\n\ninc: O(k)\n\n**代码**\n```\nclass CustomStack {\n    int[] stack;\n    int top;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n        top = -1;\n\n    }\n    \n    public void push(int x) {\n        if (top == stack.length - 1) {\n            return;\n        }\n        stack[++top] = x;\n    }\n    \n    public int pop() {\n        if(top == -1) {\n            return -1;\n        }\n        return stack[top--];\n\n    }\n    \n    public void increment(int k, int val) {\n        int l = stack.length<k? stack.length:k;\n        for (int i = 0; i<l; i++) {\n            stack[i] = stack[i] + val;\n        }\n    }\n}\n```","onTime":true},{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993864633","body":"**代码**\n```\nclass Solution {\n    public String decodeString(String s) {\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        LinkedList<Integer> stack_multi = new LinkedList<>();\n        LinkedList<String> stack_res = new LinkedList<>();\n        for(Character c : s.toCharArray()) {\n            if(c == '[') {\n                stack_multi.addLast(multi);\n                stack_res.addLast(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }\n            else if(c == ']') {\n                StringBuilder tmp = new StringBuilder();\n                int cur_multi = stack_multi.removeLast();\n                for(int i = 0; i < cur_multi; i++) tmp.append(res);\n                res = new StringBuilder(stack_res.removeLast() + tmp);\n            }\n            else if(c >= '0' && c <= '9') multi = multi * 10 + Integer.parseInt(c + \"\");\n            else res.append(c);\n        }\n        return res.toString();\n    }\n}\n```\n\n**复杂度**\n\n时间复杂度O（n）","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"arteecold":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-993801383","body":"#思路\n持续进栈 遇到]开始清 一对[]为一次记录数字的信号\n#代码\nclass Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                repeatStr = ''\n                repeatCount = ''\n                while stack and stack[-1] != '[':\n                    repeatStr = stack.pop() + repeatStr\n                # pop 掉 \"[\"\n                stack.pop()\n                while stack and stack[-1].isnumeric():\n                    repeatCount = stack.pop() + repeatCount\n                stack.append(repeatStr * int(repeatCount))\n            else:\n                stack.append(c)\n        return \"\".join(stack)\n#复杂度\nO(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"sujit197":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994202560","body":"\n## 思路\n使用两个栈，一个记录数字，一个记录字符串，当遇到数字是压人数字栈，遇到'[' 将'['前的字符串压人字母栈，遇到']',弹出字符串以及数字，并相乘，接入之前的字符串。\n\n## 代码\n\n```java\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> stackInt = new Stack<>();\n        Stack<String> stackStr = new Stack<>();\n        StringBuilder res = new StringBuilder();\n        int multi = 0;\n        for(Character c : s.toCharArray()){\n            if(c>='0'&&c<='9'){\n                multi = multi*10 + Integer.parseInt(String.valueOf(c));\n            }else if (c=='['){\n                stackInt.push(multi);\n                stackStr.push(res.toString());\n                multi = 0;\n                res = new StringBuilder();\n            }else if (c==']'){\n                int index = stackInt.pop();\n                StringBuilder temp = new StringBuilder();\n                for(int i = 0; i<index;i++){\n                    temp.append(res);\n                }\n                res = new StringBuilder(stackStr.pop()+temp);\n            }else{\n                res.append(c);\n            }\n        }\n        return res.toString();\n\n\n    }\n}\n```\n\n### 复杂度\n\n空间复杂度：O(N)\n\n时间复杂度：O(N)\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"li65943930":[null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/5#issuecomment-994335243","body":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = []\n        for c in s:\n            if c == ']':\n                tmp = ''\n                mul = ''\n                while stack and stack[-1] != '[':\n                    tmp = stack.pop() + tmp\n                stack.pop()\n                while stack and stack[-1].isdigit():\n                    mul = stack.pop() + mul    \n                tmp = tmp * int(mul)\n                stack.append(tmp)\n            else:\n                stack.append(c)\n        return ''.join(stack)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"chengyufeng6":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995472136","body":"思路：双栈\n代码：\nclass MyQueue {\npublic:\n    stack<int> s_in,s_out; \n    MyQueue() {}\n    \n    void push(int x) {\n        s_in.push(x);\n    }\n    \n    int pop() {\n        if(s_out.empty())\n        {\n            while(!s_in.empty())\n            {\n                s_out.push(s_in.top());\n                s_in.pop();\n            }\n        }\n        int x = s_out.top();\n        s_out.pop();\n        return x;\n            \n    }\n    \n    int peek() {\n        if(s_out.empty())\n        {\n            while(!s_in.empty())\n            {\n                s_out.push(s_in.top());\n                s_in.pop();\n            }\n        }\n        return s_out.top();\n    }\n    \n    bool empty() {\n       return s_in.empty() && s_out.empty();\n};\n复杂度：\n时间复杂度O(1);\n空间复杂度O(n);","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"weiruizhang":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995736386","body":"```js\n/**\n * Initialize your data structure here.\n */\nvar MyQueue = function() {\n    this.inStack = [];\n    this.outStack = [];\n};\n\n/**\n * Push element x to the back of queue. \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n    this.inStack.push(x);\n};\n\n/**\n * Removes the element from in front of queue and returns that element.\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    return this.outStack.pop();\n};\n\n/**\n * Get the front element.\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n    if(!this.outStack.length) {\n        while(this.inStack.length) {\n            this.outStack.push(this.inStack.pop());\n        }\n    }\n    var p = this.outStack.pop();\n    this.outStack.push(p);\n    return p;\n};\n\n/**\n * Returns whether the queue is empty.\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n    return !this.outStack.length && !this.inStack.length;\n};\n```\n复杂度分析\n\n时间复杂度：push/empty操作是O(1)，pop/peek操作平均也是O(1)\n空间复杂度：O(N)，N为队列元素数","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"bubblefu":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995796019","body":"### 思路\r\n栈可以用list来表示，两个list可以实现一个先入先出的队列\r\n设置in_stack表示正序，out_stack表示倒序，在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。\r\n\r\n最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。\r\n### 代码\r\n```\r\nclass MyQueue:\r\n\r\n    def __init__(self):\r\n        self.in_stack = []\r\n        self.out_stack = []\r\n\r\n    def push(self, x: int) -> None:\r\n        self.in_stack.append(x)\r\n\r\n    def pop(self) -> int:\r\n        if not self.out_stack:\r\n            while self.in_stack:\r\n                self.out_stack.append(self.in_stack.pop())\r\n        return self.out_stack.pop()\r\n\r\n    def peek(self) -> int:\r\n        ans = self.pop()\r\n        self.out_stack.append(ans)\r\n        return ans\r\n\r\n    def empty(self) -> bool:\r\n        return len(self.in_stack) == 0 and len(self.out_stack) == 0\r\n```\r\n\r\n### 复杂度分析\r\n时间复杂度     O(n)\r\n空间复杂度 ：O(n) 建立了两个列表充当栈\r\n\r\n\r\n\r\n","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"coder123xt":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995875223","body":"# 两种做法\n##第一种，借鉴解析，直观形象，入栈出栈\n\n``` javascript\n var MyQueue = function() {\n  this.instack = []\n  this.outstack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.instack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  if(!this.outstack.length){\n    this.in2out()\n  }\n  return this.outstack.pop()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  if(!this.outstack.length){\n    this.in2out()\n  }\n  return this.outstack[this.outstack.length - 1]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.instack.length === 0 && this.outstack.length === 0\n};\n\nMyQueue.prototype.in2out = function(){\n  while(this.instack.length){\n    this.outstack.push(this.instack.pop())\n  }\n}\n\n## 第二种做法 ， 虽然力扣提交成功，但是没有体现出入栈和出栈的过程\n\n\nvar MyQueue = function() {\n  this.stack = []\n};\n\n/** \n * @param {number} x\n * @return {void}\n */\nMyQueue.prototype.push = function(x) {\n  this.stack.push(x)\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.pop = function() {\n  return this.stack.shift()\n};\n\n/**\n * @return {number}\n */\nMyQueue.prototype.peek = function() {\n  return this.stack[0]\n};\n\n/**\n * @return {boolean}\n */\nMyQueue.prototype.empty = function() {\n  return this.stack.length === 0\n};\n···","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"babyyre":[null,null,null,null,{"url":"https://github.com/leetcode-pp/91alg-6-daily-check/issues/7#issuecomment-995877769","body":"双栈\npython：\nclass MyQueue:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.stack1 = [] #进队列\n        self.stack2 = [] #出队列\n\n\n    def push(self, x: int) -> None:\n        \"\"\"\n        Push element x to the back of queue.\n        \"\"\"\n        if not self.stack1 and not self.stack2:\n            self.stack2.append(x)\n        else:\n            while self.stack2:\n                self.stack1.append(self.stack2.pop())\n\n            self.stack1.append(x)\n\n            while self.stack1:\n                self.stack2.append(self.stack1.pop())\n\n\n\n\n\n    def pop(self) -> int:\n        \"\"\"\n        Removes the element from in front of queue and returns that element.\n        \"\"\"\n        if not self.empty:\n            return \"empty\"\n        return self.stack2.pop()\n\n\n    def peek(self) -> int:\n        \"\"\"\n        Get the front element.\n        \"\"\"\n        if not self.empty:\n            return \"empty\"\n        return self.stack2[-1]\n\n\n    def empty(self) -> bool:\n        \"\"\"\n        Returns whether the queue is empty.\n        \"\"\"\n        return self.stack2 == []\n\n时间O(1)\n空间O(n)","onTime":true},null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]}